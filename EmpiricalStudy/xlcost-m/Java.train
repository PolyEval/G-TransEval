boolean isPerfect ( int N ) { int sumOfDivisors = 1 ; for ( int i = 2 ; i <= N / 2 ; ++ i ) { if ( N % i == 0 ) { sumOfDivisors += i ; } } if ( sumOfDivisors == N ) { return true ; } else return false ; }
void countPerfectNumbers ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; ++ i ) { if ( isPerfect ( arr [ i ] ) ) { int sum = sumOfDigits ( arr [ i ] ) ; if ( isPerfect ( sum ) ) { System . out . print ( arr [ i ] + " " ) ; } } } }
boolean issafe ( int m , int n , int i , int j ) { if ( i < 0 ) return false ; if ( j < 0 ) return false ; if ( i >= m ) return false ; if ( j >= n ) return false ; return true ; }
int [ ] endpoints ( int [ ] [ ] arr , int m , int n ) { int i = 0 ; int j = 0 ; int current_i = 0 ; int current_j = 0 ; char current_d = 'r' ; Map < Character , Character > rcd = new HashMap < > ( ) ; rcd . put ( 'l' , 'u' ) ; rcd . put ( 'u' , 'r' ) ; rcd . put ( 'r' , 'd' ) ; rcd . put ( 'd' , 'l' ) ; while ( issafe ( m , n , i , j ) ) { current_i = i ; current_j = j ; if ( arr [ i ] [ j ] == 1 ) { char move_in = rcd . get ( current_d ) ; arr [ i ] [ j ] = 0 ; if ( move_in == 'u' ) i -= 1 ; else if ( move_in == 'd' ) i += 1 ; else if ( move_in == 'l' ) j -= 1 ; else if ( move_in == 'r' ) j += 1 ; current_d = move_in ; } else { if ( current_d == 'u' ) i -= 1 ; else if ( current_d == 'd' ) i += 1 ; else if ( current_d == 'l' ) j -= 1 ; else if ( current_d == 'r' ) j += 1 ; } } return new int [ ] { current_i , current_j } ; }
int maxPresum ( int [ ] a , int [ ] b ) { int X = Math . max ( a [ 0 ] , 0 ) ; for ( int i = 1 ; i < a . length ; i ++ ) { a [ i ] += a [ i - 1 ] ; X = Math . max ( X , a [ i ] ) ; } int Y = Math . max ( b [ 0 ] , 0 ) ; for ( int i = 1 ; i < b . length ; i ++ ) { b [ i ] += b [ i - 1 ] ; Y = Math . max ( Y , b [ i ] ) ; } return X + Y ; }
int findSum ( TreeNode root ) { Queue < TreeNode > que = new LinkedList < > ( ) ; que . add ( root ) ; int ans = 0 ; while ( que . size ( ) > 0 ) { int leaf = 0 ; int nonleaf = 0 ; int length = que . size ( ) ; while ( length > 0 ) { TreeNode temp = que . peek ( ) ; que . remove ( ) ; if ( temp . left == null && temp . right == null ) leaf += temp . val ; else nonleaf += temp . val ; if ( temp . left != null ) que . add ( temp . left ) ; if ( temp . right != null ) que . add ( temp . right ) ; length -= 1 ; } ans += leaf & nonleaf ; } return ans ; }
void fizzBuzz ( int N ) { int count3 = 0 ; int count5 = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { count3 ++ ; count5 ++ ; boolean flag = false ; if ( count3 == 3 ) { System . out . print ( "Fizz" ) ; count3 = 0 ; flag = true ; } if ( count5 == 5 ) { System . out . print ( "Buzz" ) ; count5 = 0 ; flag = true ; } if ( ! flag ) { System . out . print ( i ) ; } System . out . print ( " " ) ; } }
void checkElementsOnDiagonal ( int [ ] [ ] M , int N ) { int flag = 1 ; SieveOfEratosthenes ( 1000000 ) ; for ( int i = 0 ; i < N ; i ++ ) { boolean flg = ( boolean ) ( prime [ M [ i ] [ i ] ] && prime [ M [ i ] [ N - 1 - i ] ] ) ; int val = ( flg ) ? 1 : 0 ; flag &= val ; } if ( flag != 0 ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
List < Integer > circularPermutation ( int n , int start ) { List < Integer > res = new ArrayList < > ( List . of ( 0 ) ) , ret = new ArrayList < > ( ) ; int index = - 1 ; for ( int k = 0 , add = 1 << k ; k < n ; k ++ , add = 1 << k ) { for ( int i = res . size ( ) - 1 ; i >= 0 ; i -- ) { if ( res . get ( i ) + add == start ) index = res . size ( ) ; res . add ( res . get ( i ) + add ) ; } } if ( start == 0 ) return res ; while ( ret . size ( ) < res . size ( ) ) { ret . add ( res . get ( index ) ) ; index = ( index + 1 ) % res . size ( ) ; } return ret ; }
int countPairs ( int a [ ] , int n ) { int count = 0 ; HashMap < Double , Integer > mp = new HashMap < Double , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { double y = a [ i ] ; if ( y != 0 && y != 1 ) { double x = ( ( y * 1.0 ) / ( 1 - y ) ) * y ; if ( mp . containsKey ( x ) ) count += mp . get ( x ) ; } if ( mp . containsKey ( y ) ) { mp . put ( y , mp . get ( y ) + 1 ) ; } else { mp . put ( y , 1 ) ; } } return count ; }
void sieveOfPrimes ( ) { Arrays . fill ( sieve , 1 ) ; int N = 1000000 ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( sieve [ i ] == 0 ) continue ; for ( int j = i * i ; j <= N ; j += i ) sieve [ j ] = 0 ; } }
void getArray ( int [ ] arr , int N ) { int A [ ] = new int [ N ] ; Arrays . fill ( A , 0 ) ; ArrayList < Integer > v = new ArrayList < Integer > ( ) ; sieveOfPrimes ( ) ; for ( int i = 2 ; i <= 1000000 ; i ++ ) if ( sieve [ i ] != 0 ) v . add ( i ) ; int j = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int ind = arr [ i ] ; if ( A [ i ] != 0 ) continue ; else if ( A [ ind ] != 0 ) A [ i ] = A [ ind ] ; else { int prime = v . get ( j ++ ) ; A [ i ] = prime ; A [ ind ] = A [ i ] ; } } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( A [ i ] + " " ) ; } }
boolean contains ( int num , int K , int Base ) { boolean isThere = false ; while ( num > 0 ) { int remainder = num % Base ; if ( remainder == K ) { isThere = true ; } num /= Base ; } return isThere ; }
int numberOfTiles ( int n , int m ) { if ( n % 2 == 1 ) { return - 1 ; } return ( m * n ) / 2 ; }
void canMakeEqual ( int [ ] arr1 , int [ ] arr2 , int N ) { int count = 0 ; int arr1_one = 0 , arr1_zero = 0 ; int arr2_one = 0 , arr2_zero = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr1 [ i ] == 1 ) { arr1_one ++ ; } else if ( arr1 [ i ] == 0 ) { arr1_zero ++ ; } if ( arr2 [ i ] == 1 ) { arr2_one ++ ; } else if ( arr2 [ i ] == 0 ) { arr2_zero ++ ; } } if ( arr1_one != arr2_one arr1_zero != arr2_zero ) { System . out . print ( "No" ) ; return ; } for ( int i = 0 ; i < N ; i ++ ) { count = count + ( arr1 [ i ] - arr2 [ i ] ) ; if ( count < 0 ) { System . out . print ( "No" ) ; return ; } } System . out . print ( "Yes" ) ; }
long findNthNumber ( long N ) { long result = 0 ; long p = 1 ; while ( N > 0 ) { result += ( p * ( N % 9 ) ) ; N = N / 9 ; p = p * 10 ; } return result ; }
int cntMaxOperationToMakeN_1_0 ( int [ ] arr , int N ) { int cntOp = 0 ; PriorityQueue < Integer > PQ = new PriorityQueue < Integer > ( ( a , b ) -> b - a ) ; for ( int i = 0 ; i < N ; i ++ ) { PQ . add ( arr [ i ] ) ; } while ( PQ . size ( ) > 1 ) { int X = PQ . peek ( ) ; PQ . remove ( ) ; int Y = PQ . peek ( ) ; PQ . remove ( ) ; X -- ; Y -- ; if ( X != 0 ) { PQ . add ( X ) ; } if ( Y != 0 ) { PQ . add ( Y ) ; } cntOp += 1 ; } return cntOp ; }
void checkSamePosition ( int [ ] arr , int n ) { Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int temp = ( ( i + arr [ i ] ) % n + n ) % n ; if ( mp . get ( temp ) == null ) { System . out . println ( "Yes" ) ; return ; } mp . get ( temp + 1 ) ; } System . out . println ( "No" ) ; }
void sumFib ( int N ) { long num = ( long ) Math . round ( Math . pow ( ( Math . sqrt ( 5 ) + 1 ) / 2.0 , N + 2 ) / Math . sqrt ( 5 ) ) ; System . out . println ( num - 1 ) ; }
void sumFib ( int N ) { double num = ( 1 - Math . sqrt ( 5 ) ) / 2 ; long val = Math . round ( Math . abs ( 1 / ( Math . pow ( num , N + 2 ) + Math . pow ( num , N + 1 ) + Math . pow ( num , N ) + Math . pow ( num , N - 1 ) ) ) - 1 ) ; System . out . println ( val ) ; }
void poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { System . out . print ( ( int ) Math . ceil ( Math . log ( buckets ) / Math . log ( ( minutesToTest / minutesToDie ) + 1 ) ) ) ; }
int countTrailingZeroes ( int N ) { int res = N ^ ( N - 1 ) ; return ( int ) ( Math . log ( temp ) / Math . log ( 2 ) ) ; }
void maxProduct ( int [ ] arr , int N ) { int max_product = Integer . MIN_VALUE ; int prefix_sum = 0 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { prefix_sum += arr [ i ] ; int X = prefix_sum ; int Y = sum - prefix_sum ; max_product = Math . max ( max_product , X * Y ) ; } System . out . print ( max_product ) ; }
int findMask ( int K ) { int mask = 1 ; while ( ( K & mask ) == 0 ) { mask = mask << 1 ; } return mask ; }
void sameRightSetBitPos ( int [ ] arr , int N , int K ) { int mask = findMask ( K ) ; final int pos = ( K & mask ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & mask ) == pos ) System . out . print ( arr [ i ] + " " ) ; } }
void countPronic ( int A , int B ) { int count = 0 ; for ( int i = A ; i <= B ; i ++ ) { if ( checkPronic ( i ) != false ) { count ++ ; } } System . out . print ( count ) ; }
int pronic ( int num ) { int N = ( int ) Math . sqrt ( num ) ; if ( N * ( N + 1 ) <= num ) { return N ; } return N - 1 ; }
int countPronic ( int A , int B ) { return pronic ( B ) - pronic ( A - 1 ) ; }
void sameProductQuadruples ( int [ ] nums , int N ) { int [ ] umap = new int [ 10000 ] ; int res = 0 ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = i + 1 ; j < N ; ++ j ) { int prod = nums [ i ] * nums [ j ] ; res += 8 * umap [ prod ] ; ++ umap [ prod ] ; } } System . out . println ( res ) ; }
void productExceptSelf ( int arr [ ] , int N ) { int product = 1 ; int z = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != 0 ) product *= arr [ i ] ; if ( arr [ i ] == 0 ) z += 1 ; } int a = Math . abs ( product ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( z == 1 ) { if ( arr [ i ] != 0 ) arr [ i ] = 0 ; else arr [ i ] = product ; continue ; } else if ( z > 1 ) { arr [ i ] = 0 ; continue ; } int b = Math . abs ( arr [ i ] ) ; int curr = ( int ) Math . round ( Math . exp ( Math . log ( a ) - Math . log ( b ) ) ) ; if ( arr [ i ] < 0 && product < 0 ) arr [ i ] = curr ; else if ( arr [ i ] > 0 && product > 0 ) arr [ i ] = curr ; else arr [ i ] = - 1 * curr ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
int getMax ( ArrayList < Integer > arr , int ans , ArrayList < Boolean > chosen , int N ) { if ( arr . size ( ) == N ) { ans = Math . max ( ans , calcScr ( arr ) ) ; return ans ; } for ( int i = 0 ; i < N ; i ++ ) { if ( chosen . get ( i ) ) continue ; chosen . set ( i , true ) ; arr . add ( i ) ; ans = getMax ( arr , ans , chosen , N ) ; chosen . set ( i , false ) ; arr . remove ( arr . size ( ) - 1 ) ; } return ans ; }
void singleDigitSubarrayCount ( int arr [ ] , int N ) { int res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } System . out . print ( res ) ; }
void maxSumAfterKReverse ( Integer arr [ ] , int K , int N ) { int sum = Integer . MIN_VALUE ; if ( K % 2 != 0 ) Collections . reverse ( Arrays . asList ( arr ) ) ; int currsum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { currsum += arr [ i ] ; sum = Math . max ( sum , currsum ) ; } System . out . print ( sum ) ; }
int isPossible ( int N ) { return ( ( ( N & ( N - 1 ) ) & N ) ) ; }
void countElements ( int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( isPossible ( i ) != 0 ) count ++ ; } System . out . println ( count ) ; }
void countElements ( int N ) { int Cur_Ele = 1 ; int Count = 0 ; while ( Cur_Ele <= N ) { Count ++ ; Cur_Ele = Cur_Ele * 2 ; } System . out . print ( N - Count ) ; }
void SubMasks ( int N ) { for ( int S = N ; S > 0 ; S = ( S - 1 ) & N ) { System . out . print ( S + " " ) ; } }
int power ( int x , int y ) { int res = 1 ; x = x % MOD ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % MOD ; y = y >> 1 ; x = ( x * x ) % MOD ; } return res ; }
void countPairs ( int N ) { int high = power ( 2 , N ) ; int count = 0 ; for ( int i = 0 ; i < high ; i ++ ) { for ( int j = 0 ; j < high ; j ++ ) { int X = ( i ^ j ) ; int Y = ( i j ) ; if ( X == Y ) { count ++ ; } } } System . out . println ( count % MOD ) ; }
int power ( int x , int y ) { int res = 1 ; x = x % MOD ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % MOD ; y = y >> 1 ; x = ( x * x ) % MOD ; } return res ; }
void countPairs ( int N ) { System . out . print ( power ( 3 , N ) ) ; }
int minSum ( int A [ ] , int N ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( mp . containsKey ( A [ i ] ) ) { mp . put ( A [ i ] , mp . get ( A [ i ] ) + 1 ) ; } else { mp . put ( A [ i ] , 1 ) ; } } int minSum = Integer . MAX_VALUE ; for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) { minSum = Math . min ( minSum , sum - ( it . getKey ( ) * it . getValue ( ) ) ) ; } return minSum ; }
int minimumMoves ( int [ ] a , int n ) { int min_element = Integer . MAX_VALUE ; int max_element = Integer . MIN_VALUE ; int min_ind = - 1 ; int max_ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] <= min_element ) { min_element = a [ i ] ; min_ind = i ; } if ( a [ i ] > max_element ) { max_element = a [ i ] ; max_ind = i ; } } if ( max_ind == min_ind ) { return 0 ; } else if ( max_ind > min_ind ) { return max_ind + ( n - min_ind - 2 ) ; } else { return max_ind + n - min_ind - 1 ; } }
void isCycleExists ( int [ ] arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { System . out . println ( "Yes" ) ; return ; } } System . out . println ( "No" ) ; }
int findIndex ( int arr [ ] , int n , int K ) { int sum = 0 ; int res = - 1 ; int mini = ( int ) 1e9 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { int temp = sum - arr [ i ] ; if ( temp % K == 0 ) { if ( res == - 1 mini > arr [ i ] ) { res = i + 1 ; mini = arr [ i ] ; } } } return res ; }
int minimumIncrement ( int arr [ ] , int N ) { if ( N % 2 != 0 ) { System . out . println ( "-1" ) ; System . exit ( 0 ) ; } int cntEven = 0 ; int cntOdd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { cntEven += 1 ; } } cntOdd = N - cntEven ; return Math . abs ( cntEven - cntOdd ) / 2 ; }
void divisionalArrays ( int arr [ ] , int N ) { int sum = N ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } for ( Map . Entry x : mp . entrySet ( ) ) { if ( ( int ) x . getValue ( ) > 1 ) { sum += ( int ) x . getValue ( ) - 1 ; } } System . out . println ( sum ) ; }
void totalInversions ( int arr [ ] , int K , int N ) { int inv = 0 ; int X = 0 ; int i , j ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { if ( arr [ i ] > arr [ j ] && i < j ) inv ++ ; if ( arr [ i ] > arr [ j ] ) X ++ ; } } int totalInv = X * K * ( K - 1 ) / 2 + inv * K ; System . out . println ( totalInv ) ; }
int findSize ( int N ) { if ( N == 0 ) return 1 ; if ( N == 1 ) return 1 ; int Size = 2 * findSize ( N / 2 ) + 1 ; return Size ; }
int CountOnes ( int N , int L , int R ) { if ( L > R ) { return 0 ; } if ( N <= 1 ) { return N ; } int ret = 0 ; int M = N / 2 ; int Siz_M = findSize ( M ) ; if ( L <= Siz_M ) { ret += CountOnes ( N / 2 , L , Math . min ( Siz_M , R ) ) ; } if ( L <= Siz_M + 1 && Siz_M + 1 <= R ) { ret += N % 2 ; } if ( Siz_M + 1 < R ) { ret += CountOnes ( N / 2 , Math . max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) ; } return ret ; }
int Fact ( int N ) { int result = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { result = ( result * i ) ; } return result ; }
void numberOfWays ( int M , int [ ] arr , int N ) { int [ ] B = new int [ M ] ; int [ ] counter = new int [ M + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != 0 ) { if ( B [ i % M ] == 0 ) { B [ i % M ] = arr [ i ] ; counter [ arr [ i ] ] ++ ; if ( counter [ arr [ i ] ] > 1 ) { System . out . println ( 0 ) ; return ; } } else if ( B [ i % M ] != arr [ i ] ) { System . out . println ( 0 ) ; return ; } } } int cnt = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( B [ i ] == 0 ) { cnt ++ ; } } System . out . println ( Fact ( cnt ) ) ; }
void getMax ( int arr [ ] , int N , int K ) { for ( int i = 1 ; i < N ; i ++ ) { int cur_val = arr [ i ] ; while ( K >= i ) { if ( cur_val > 0 ) { arr [ 0 ] = arr [ 0 ] + 1 ; cur_val = cur_val - 1 ; K = K - i ; } else break ; } } System . out . print ( arr [ 0 ] ) ; }
int MaximumSum ( int [ ] [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = 0 , y = i , sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ x ++ ] [ y ++ ] ; } if ( sum > ans ) ans = sum ; } for ( int i = 1 ; i < n ; i ++ ) { int x = i , y = 0 , sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ x ++ ] [ y ++ ] ; } if ( sum > ans ) ans = sum ; } return ans ; }
void numberOfIntegers ( int [ ] arr , int N ) { int cur_max = 0 , count = 0 ; if ( N == 1 ) { count = 1 ; } else { for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] > cur_max ) { cur_max = arr [ i ] ; if ( arr [ i ] > arr [ i + 1 ] ) { count ++ ; } } } if ( arr [ N - 1 ] > cur_max ) count ++ ; } System . out . println ( count ) ; }
int numberOfWays ( int n , int k ) { if ( n == 0 ) return 1 ; if ( k == 0 ) return 1 ; if ( n >= ( int ) Math . pow ( 2 , k ) ) { int curr_val = ( int ) Math . pow ( 2 , k ) ; return numberOfWays ( n - curr_val , k ) + numberOfWays ( n , k - 1 ) ; } else return numberOfWays ( n , k - 1 ) ; }
int possibleTriplets ( int arr [ ] , int N ) { int freq = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { freq ++ ; } } return ( int ) ( ( freq * 1L * ( freq - 1 ) * ( freq - 2 ) ) / 6 ) ; }
void build ( int tree [ ] , int arr [ ] , int start , int end , int index ) { if ( start == end ) { if ( start % 2 == 0 ) { tree [ index ] = arr [ start ] ; } else { tree [ index ] = - arr [ start ] ; } return ; } int mid = start + ( end - start ) / 2 ; build ( tree , arr , start , mid , 2 * index + 1 ) ; build ( tree , arr , mid + 1 , end , 2 * index + 2 ) ; tree [ index ] = tree [ 2 * index + 1 ] + tree [ 2 * index + 2 ] ; }
void update ( int tree [ ] , int index , int start , int end , int pos , int val ) { if ( start == end ) { if ( start % 2 == 0 ) { tree [ index ] = val ; } else { tree [ index ] = - val ; } return ; } int mid = start + ( end - start ) / 2 ; if ( mid >= pos ) { update ( tree , 2 * index + 1 , start , mid , pos , val ) ; } else { update ( tree , 2 * index + 2 , mid + 1 , end , pos , val ) ; } tree [ index ] = tree [ 2 * index + 1 ] + tree [ 2 * index + 2 ] ; }
int FindSum ( int tree [ ] , int start , int end , int L , int R , int index ) { if ( L > end R < start ) { return 0 ; } if ( L <= start && R >= end ) { return tree [ index ] ; } int mid = start + ( end - start ) / 2 ; int X = FindSum ( tree , start , mid , L , R , 2 * index + 1 ) ; int Y = FindSum ( tree , mid + 1 , end , L , R , 2 * index + 2 ) ; return X + Y ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int DistinctValues ( int arr [ ] , int N ) { int max_value = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; ++ i ) { max_value = Math . max ( max_value , arr [ i ] ) ; } int GCDArr = arr [ 0 ] ; for ( int i = 1 ; i < N ; ++ i ) { GCDArr = gcd ( GCDArr , arr [ i ] ) ; } int answer = ( max_value / GCDArr ) + 1 ; return answer ; }
void findDay ( int Y , int B ) { int lyear , rest , totaldays , day ; Y = ( Y - 1 ) - B ; lyear = Y / 4 ; rest = Y - lyear ; totaldays = ( rest * 365 ) + ( lyear * 366 ) + 1 ; day = ( totaldays % 7 ) ; if ( day == 0 ) System . out . println ( "Monday" ) ; else if ( day == 1 ) System . out . println ( "Tuesday" ) ; else if ( day == 2 ) System . out . println ( "Wednesday" ) ; else if ( day == 3 ) System . out . println ( "Thursday" ) ; else if ( day == 4 ) System . out . println ( "Friday" ) ; else if ( day == 5 ) System . out . println ( "Saturday" ) ; else if ( day == 6 ) System . out . println ( "Sunday" ) ; else System . out . println ( "INPUT YEAR IS WRONG!" ) ; }
void maxPossibleDiff ( Vector < Integer > arr , int N ) { arr . add ( - 1 ) ; Collections . reverse ( arr ) ; arr . add ( - 1 ) ; Collections . reverse ( arr ) ; int maxDiff = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr . get ( i ) > arr . get ( i - 1 ) && arr . get ( i ) > arr . get ( i + 1 ) ) { maxDiff += arr . get ( i ) ; } if ( arr . get ( i ) < arr . get ( i - 1 ) && arr . get ( i ) < arr . get ( i + 1 ) ) { maxDiff -= arr . get ( i ) ; } } System . out . print ( maxDiff ) ; }
void printArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
void modifyArray ( int arr [ ] , int N , int Q [ ] [ ] , int cntQuery ) { int arr1 [ ] = new int [ N + 2 ] ; int arr2 [ ] = new int [ N + 2 ] ; for ( int i = 0 ; i < cntQuery ; i ++ ) { int L = Q [ i ] [ 0 ] + 1 , R = Q [ i ] [ 1 ] + 1 ; arr1 [ L ] ++ ; arr1 [ R + 1 ] -- ; arr2 [ R + 1 ] -= R - L + 1 ; } for ( int i = 1 ; i <= N ; i ++ ) arr1 [ i ] += arr1 [ i - 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) arr2 [ i ] += arr2 [ i - 1 ] + arr1 [ i ] ; for ( int i = 1 ; i <= N ; i ++ ) arr [ i - 1 ] = arr2 [ i ] ; printArray ( arr , N ) ; }
int gcd ( int x , int y ) { if ( y == 0 ) return x ; return gcd ( y , x % y ) ; }
int lcm ( int x , int y ) { return ( x * y ) / gcd ( x , y ) ; }
int minimumCost ( int x , int y ) { int lcm_ = lcm ( x , y ) ; int costx = ( lcm_ - x ) / x ; int costy = ( lcm_ - y ) / y ; return costx + costy ; }
int findProduct ( int number_1 , int number_2 ) { if ( number_1 == Integer . MIN_VALUE number_2 == Integer . MIN_VALUE ) { return 0 ; } else return number_1 * number_2 ; }
ArrayList < Integer > calculateProduct ( ArrayList < ArrayList < Integer > > List , int index ) { int highest = Collections . max ( List . get ( index ) ) ; int lowest = Collections . min ( List . get ( index ) ) ; if ( index + 1 == List . size ( ) ) { if ( lowest < 0 && highest >= 0 ) { return ( new ArrayList < Integer > ( Arrays . asList ( highest , lowest ) ) ) ; } else if ( lowest <= 0 && highest <= 0 ) { return ( new ArrayList < Integer > ( Arrays . asList ( Integer . MIN_VALUE , lowest ) ) ) ; } else if ( lowest >= 0 && highest >= 0 ) { return ( new ArrayList < Integer > ( Arrays . asList ( highest , Integer . MIN_VALUE ) ) ) ; } } ArrayList < Integer > temp = calculateProduct ( List , index + 1 ) ; int positive = temp . get ( 0 ) ; int negative = temp . get ( 1 ) ; int highPos = findProduct ( highest , positive ) ; int highNeg = findProduct ( highest , negative ) ; int lowPos = findProduct ( lowest , positive ) ; int lowNeg = findProduct ( lowest , negative ) ; if ( lowest < 0 && highest >= 0 ) { return ( new ArrayList < Integer > ( Arrays . asList ( Math . max ( highPos , lowNeg ) , Math . min ( highNeg , lowPos ) ) ) ) ; } else if ( lowest <= 0 && highest <= 0 ) { return ( new ArrayList < Integer > ( Arrays . asList ( lowNeg , lowPos ) ) ) ; } else if ( lowest >= 0 && highest >= 0 ) { return ( new ArrayList < Integer > ( Arrays . asList ( Math . max ( lowPos , highPos ) , Math . min ( lowNeg , highNeg ) ) ) ) ; } return ( new ArrayList < Integer > ( Arrays . asList ( 0 , 0 ) ) ) ; }
void calculateSpan ( int price [ ] , int n , int S [ ] ) { S [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { S [ i ] = 1 ; for ( int j = i - 1 ; ( j >= 0 ) && ( price [ i ] >= price [ j ] ) ; j -- ) S [ i ] ++ ; } }
int power ( int a , int n , int d ) { int res = 1 ; while ( n != 0 ) { if ( ( n % 2 ) != 0 ) { res = ( ( res % d ) * ( a % d ) ) % d ; } a = ( ( a % d ) * ( a % d ) ) % d ; n /= 2 ; } return res ; }
int gcd ( int p , int q , int n ) { if ( p == q ) { return ( power ( p , n , mod ) + power ( q , n , mod ) ) % mod ; } int candidate = 1 ; int num = p - q ; int sq = ( int ) Math . sqrt ( num ) ; for ( int i = 1 ; i <= sq ; ++ i ) { if ( num % i == 0 ) { int X = power ( p , n , i ) ; int Y = power ( q , n , i ) ; int temp = ( X + Y ) % i ; if ( temp == 0 ) { candidate = Math . max ( candidate , i ) ; } temp = ( power ( p , n , num / i ) + power ( q , n , num / i ) ) % ( num / i ) ; if ( temp == 0 ) { candidate = Math . max ( candidate , num / i ) ; } } } return candidate % mod ; }
void minimumSubarrays ( int [ ] arr , int n ) { char current = 'N' ; int answer = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( current == 'N' ) { if ( arr [ i ] < arr [ i - 1 ] ) { current = 'D' ; } else if ( arr [ i ] == arr [ i - 1 ] ) { current = 'N' ; } else { current = 'I' ; } } else if ( current == 'I' ) { if ( arr [ i ] >= arr [ i - 1 ] ) { current = 'I' ; } else { current = 'N' ; answer += 1 ; } } else { if ( arr [ i ] <= arr [ i - 1 ] ) { current = 'D' ; } else { current = 'N' ; answer += 1 ; } } } System . out . print ( answer ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int calculateK ( int x , int y ) { int g = gcd ( x , y ) ; int n = y / g ; int res = n ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { res -= ( res / i ) ; while ( n % i == 0 ) n /= i ; } } if ( n != 1 ) res -= ( res / n ) ; return res ; }
void nearestPowerOfTwo ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int lg = ( int ) ( Math . log ( arr [ i ] ) / Math . log ( 2 ) ) ; int a = ( int ) ( Math . pow ( 2 , lg ) ) ; int b = ( int ) ( Math . pow ( 2 , lg + 1 ) ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) System . out . print ( a + " " ) ; else System . out . print ( b + " " ) ; } }
double Conversion ( double centi ) { double pixels = ( 96 * centi ) / 2.54 ; System . out . println ( pixels ) ; return 0 ; }
int minSwaps ( int [ ] [ ] b ) { int n = b . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( b [ 0 ] [ 0 ] ^ b [ 0 ] [ j ] ^ b [ i ] [ 0 ] ^ b [ i ] [ j ] ) == 1 ) { return - 1 ; } } } int rowSum = 0 ; int colSum = 0 ; int rowSwap = 0 ; int colSwap = 0 ; for ( int i = 0 ; i < n ; i ++ ) { rowSum += b [ i ] [ 0 ] ; colSum += b [ 0 ] [ i ] ; int cond1 = 0 ; int cond2 = 0 ; if ( b [ i ] [ 0 ] == i % 2 ) cond1 = 1 ; if ( b [ 0 ] [ i ] == i % 2 ) cond2 = 1 ; rowSwap += cond1 ; colSwap += cond2 ; } if ( rowSum != n / 2 && rowSum != ( n + 1 ) / 2 ) return - 1 ; if ( colSum != n / 2 && colSum != ( n + 1 ) / 2 ) return - 1 ; if ( n % 2 == 1 ) { if ( ( colSwap % 2 ) == 1 ) colSwap = n - colSwap ; if ( ( rowSwap % 2 ) == 1 ) rowSwap = n - rowSwap ; } else { colSwap = Math . min ( colSwap , n - colSwap ) ; rowSwap = Math . min ( rowSwap , n - rowSwap ) ; } return ( rowSwap + colSwap ) / 2 ; }
void maxNumTrailNine ( int n , int d ) { int res = n ; int cntDigits = ( int ) Math . log10 ( n ) + 1 ; int p10 = 10 ; for ( int i = 1 ; i <= cntDigits ; i ++ ) { if ( n % p10 >= d ) { break ; } else { res = n - n % p10 - 1 ; } p10 = p10 * 10 ; } System . out . println ( res ) ; }
int MinimumNoOfWays ( int arr [ ] , int n ) { int mini_no_of_ways ; if ( n % 2 == 0 ) { mini_no_of_ways = n / 2 ; } else { mini_no_of_ways = n / 2 + 1 ; } return mini_no_of_ways ; }
void count_setbit ( int N ) { int result = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( 1 << i ) & N ) > 0 ) { result ++ ; } } System . out . println ( result ) ; }
void cntWaysConsArray ( int A [ ] , int N ) { int total = 1 ; int oddArray = 1 ; for ( int i = 0 ; i < N ; i ++ ) { total = total * 3 ; if ( A [ i ] % 2 == 0 ) { oddArray *= 2 ; } } System . out . println ( total - oddArray ) ; }
int invertBits ( int n ) { int x = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; int m = 1 << x ; m = m | m - 1 ; n = n ^ m ; return n ; }
void invertSum ( int A , int B ) { int temp = countSetBits ( A ) + countSetBits ( B ) ; System . out . print ( invertBits ( temp ) ) ; }
int ValOfTheExpression ( int n ) { int [ ] factorial = new int [ n + 1 ] ; factorial [ 0 ] = factorial [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { factorial [ i ] = ( ( factorial [ i - 1 ] % mod ) * ( i % mod ) ) % mod ; } int [ ] dp = new int [ n + 1 ] ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = ( ( dp [ i - 1 ] % mod ) * ( factorial [ i ] % mod ) ) % mod ; } return dp [ n ] ; }
int minChocolates ( int [ ] a , int n ) { int i = 0 , j = 0 ; int res = 0 , val = 1 ; while ( j < n - 1 ) { if ( a [ j ] > a [ j + 1 ] ) { j += 1 ; continue ; } if ( i == j ) res += val ; else { res += get_sum ( val , i , j ) ; } if ( a [ j ] < a [ j + 1 ] ) val += 1 ; else val = 1 ; j += 1 ; i = j ; } if ( i == j ) res += val ; else res += get_sum ( val , i , j ) ; return res ; }
int get_sum ( int peak , int start , int end ) { int count = end - start + 1 ; peak = ( peak > count ) ? peak : count ; int s = peak + ( ( ( count - 1 ) * count ) >> 1 ) ; return s ; }
int [ ] RemoveElemArr ( int [ ] arr , int n , int k ) { if ( n == 0 n == 1 ) return arr ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( j < k arr [ i ] > arr [ j - k ] ) { arr [ j ++ ] = arr [ i ] ; } } while ( arr . length > j ) { arr = Arrays . copyOfRange ( arr , 0 , arr . length - 1 ) ; } return arr ; }
void printArray ( int [ ] arr ) { for ( int i = 0 ; i < arr . length ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
void UtilRemov ( int [ ] arr , int n , int k ) { arr = RemoveElemArr ( arr , n , k ) ; printArray ( arr ) ; }
void countNumberHavingKthBitSet ( int N , int K ) { int numbers_rightmost_setbit_K = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { int numbers_rightmost_bit_i = ( N + 1 ) / 2 ; N -= numbers_rightmost_bit_i ; if ( i == K ) { numbers_rightmost_setbit_K = numbers_rightmost_bit_i ; } } System . out . println ( numbers_rightmost_setbit_K ) ; }
void pairs_after_removing ( int arr [ ] , int N ) { int cntPairs = 0 ; Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { mp . put ( arr [ i ] , mp . getOrDefault ( arr [ i ] , 0 ) + 1 ) ; } for ( Map . Entry < Integer , Integer > element : mp . entrySet ( ) ) { int i = element . getKey ( ) ; cntPairs += mp . get ( i ) * ( mp . get ( i ) - 1 ) / 2 ; } for ( int i = 0 ; i < N ; i ++ ) { int pairs_after_arr_i_removed = cntPairs + 1 - mp . get ( arr [ i ] ) ; System . out . print ( pairs_after_arr_i_removed + " " ) ; } return ; }
int minimumMaxDiff ( int [ ] nums ) { TreeSet < Integer > s = new TreeSet < Integer > ( ) ; for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] % 2 == 0 ) s . add ( nums [ i ] ) ; else s . add ( nums [ i ] * 2 ) ; } int res = s . last ( ) - s . first ( ) ; while ( s . last ( ) % 2 == 0 ) { int x = s . last ( ) ; s . remove ( x ) ; s . add ( x / 2 ) ; res = Math . min ( res , s . last ( ) - s . first ( ) ) ; } return res ; }
int bitwiseXorRange ( int n ) { if ( n % 4 == 0 ) return n ; if ( n % 4 == 1 ) return 1 ; if ( n % 4 == 2 ) return n + 1 ; return 0 ; }
int evenXorRange ( int l , int r ) { int xor_l ; int xor_r ; xor_r = 2 * bitwiseXorRange ( r / 2 ) ; xor_l = 2 * bitwiseXorRange ( ( l - 1 ) / 2 ) ; return xor_l ^ xor_r ; }
double find_Variance ( int n ) { long numerator = n * n - 1 ; double ans = ( numerator * 1.0 ) / 12 ; return ans ; }
void noOfArraysPossible ( int N , int M ) { int ans = 1 ; for ( int i = 0 ; i < N ; ++ i ) { ans = ans * ( M - i ) ; } System . out . print ( ans ) ; }
void findSum ( int a , int b , int n ) { int sum = 0 ; int x = a ^ b ; if ( n % 3 == 0 ) { sum = ( n / 3 ) * ( a + b + x ) ; } else if ( n % 3 == 1 ) { sum = ( n / 3 ) * ( a + b + x ) + a ; } else { sum = ( n / 3 ) * ( a + b + x ) + a + b ; } System . out . print ( sum ) ; }
void constructArrayWithGivenLCM ( int N ) { int newArr [ ] = new int [ N ] ; int j = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { newArr [ j ] = i ; j ++ ; if ( N / i != i ) { newArr [ j ] = N / i ; j ++ ; } } } Arrays . sort ( newArr ) ; for ( int i = j ; i < N ; i ++ ) { System . out . print ( newArr [ i ] + " " ) ; } }
int onesComplement ( int n , int maxElement ) { int bits = ( int ) Math . floor ( ( Math . log ( maxElement ) / Math . log ( 2 ) ) ) + 1 ; return ( ( 1 << bits ) - 1 ) ^ n ; }
int [ ] calculateFactorial ( int N ) { int [ ] fact = new int [ N + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fact [ i ] = fact [ i - 1 ] * i ; } return fact ; }
int cntWaysSelection ( int arr [ ] , int N , int K , int L , int R ) { int cntWays = 0 ; int cntNum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= L && arr [ i ] <= R ) { cntNum ++ ; } } int [ ] fact = calculateFactorial ( cntNum ) ; for ( int i = K ; i <= cntNum ; i ++ ) { cntWays += fact [ cntNum ] / ( fact [ i ] * fact [ cntNum - i ] ) ; } return cntWays ; }
int TotalAndPair ( int arr [ ] , int N ) { int totalAND = ( 1 << 30 ) - 1 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { totalAND &= arr [ i ] & arr [ j ] ; } } return totalAND ; }
int getPower ( int p ) { int res = 1 ; while ( p > 0 ) { res *= 5 ; p -- ; } return res ; }
void printFinalPrices ( int [ ] arr ) { Stack < Integer > minStk = new Stack < > ( ) ; int n = arr . length ; int [ ] reduce = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( ! minStk . isEmpty ( ) ) { if ( minStk . peek ( ) <= arr [ i ] ) { reduce [ i ] = minStk . peek ( ) ; } else { while ( ! minStk . isEmpty ( ) && ( minStk . peek ( ) > arr [ i ] ) ) { minStk . pop ( ) ; } if ( ! minStk . isEmpty ( ) ) { reduce [ i ] = minStk . peek ( ) ; } } } minStk . add ( arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] - reduce [ i ] + " " ) ; }
int smallestDivisorGr1 ( int N ) { for ( int i = 2 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { return i ; } } return N ; }
int findValOfNWithOperat ( int N , int K ) { for ( int i = 1 ; i <= K ; i ++ ) { N += smallestDivisorGr1 ( N ) ; } return N ; }
int smallestDivisorGr1 ( int N ) { for ( int i = 2 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { return i ; } } return N ; }
int findTripleSum ( int A , int B , int C ) { int sum = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { for ( int j = 1 ; j <= B ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { int prod = ( ( ( i % M ) * ( j % M ) ) % M * ( k % M ) ) % M ; sum = ( sum + prod ) % M ; } } } return sum ; }
int getMaximum ( int N , int M , int [ ] [ ] mat ) { int global_max = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int row_min = Integer . MAX_VALUE ; for ( int k = 0 ; k < M ; k ++ ) { int m = Math . max ( mat [ i ] [ k ] , mat [ j ] [ k ] ) ; row_min = Math . min ( row_min , m ) ; } global_max = Math . max ( global_max , row_min ) ; } } return global_max ; }
void makeTree ( Vector < Integer > tree [ ] , pair edges [ ] , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { int u = edges [ i ] . first ; int v = edges [ i ] . second ; tree [ u ] . add ( v ) ; } }
void findTheGreatestX ( int P , int Q ) { HashMap < Integer , Integer > divisiors = new HashMap < > ( ) ; for ( int i = 2 ; i * i <= Q ; i ++ ) { while ( Q % i == 0 && Q > 1 ) { Q /= i ; if ( divisiors . containsKey ( i ) ) { divisiors . put ( i , divisiors . get ( i ) + 1 ) ; } else { divisiors . put ( i , 1 ) ; } } } if ( Q > 1 ) if ( divisiors . containsKey ( Q ) ) { divisiors . put ( Q , divisiors . get ( Q ) + 1 ) ; } else { divisiors . put ( Q , 1 ) ; } int ans = 0 ; for ( Map . Entry < Integer , Integer > i : divisiors . entrySet ( ) ) { int frequency = i . getValue ( ) ; int temp = P ; int cur = 0 ; while ( temp % i . getKey ( ) == 0 ) { temp /= i . getKey ( ) ; cur ++ ; } if ( cur < frequency ) { ans = P ; break ; } temp = P ; for ( int j = cur ; j >= frequency ; j -- ) { temp /= i . getKey ( ) ; } ans = Math . max ( temp , ans ) ; } System . out . print ( ans ) ; }
int divisorCount ( int n ) { int x = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == n / i ) x ++ ; else x += 2 ; } } return x ; }
int minvalue_y ( int x ) { int a = divisorCount ( x ) ; int y = x + 1 ; while ( ( a & 1 ) == ( divisorCount ( y ) & 1 ) ) y ++ ; return y ; }
int minvalue_y ( int x ) { int n = ( int ) Math . sqrt ( x ) ; if ( n * n == x ) return x + 1 ; return ( int ) Math . pow ( n + 1 , 2 ) ; }
int alternatingSumOfFirst_N ( int N ) { int alternateSum = 0 ; if ( N % 2 == 0 ) { alternateSum = ( - N ) / 2 ; } else { alternateSum = ( N + 1 ) / 2 ; } return alternateSum ; }
int minStartValue ( int [ ] nums ) { int minValue = 0 ; int sum = 0 ; for ( int n : nums ) { sum += n ; minValue = Math . min ( minValue , sum ) ; } int startValue = 1 - minValue ; return startValue ; }
int countSubArrayRemove ( int [ ] arr , int N ) { HashMap < Integer , Integer > prefix_element_count = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > suffix_element_count = new HashMap < Integer , Integer > ( ) ; int total_sum_of_elements = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { total_sum_of_elements += arr [ i ] ; if ( ! suffix_element_count . containsKey ( arr [ i ] ) ) suffix_element_count . put ( arr [ i ] , 1 ) ; else suffix_element_count . put ( arr [ i ] , suffix_element_count . get ( arr [ i ] ) + 1 ) ; } int prefix_sum = 0 ; int suffix_sum = 0 ; int count_subarray_equal_sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { prefix_sum += arr [ i ] ; if ( ! prefix_element_count . containsKey ( arr [ i ] ) ) prefix_element_count . put ( arr [ i ] , 1 ) ; else prefix_element_count . put ( arr [ i ] , prefix_element_count . get ( arr [ i ] ) + 1 ) ; suffix_sum = total_sum_of_elements - prefix_sum ; if ( ! suffix_element_count . containsKey ( arr [ i ] ) ) suffix_element_count . put ( arr [ i ] , 0 ) ; else suffix_element_count . put ( arr [ i ] , suffix_element_count . get ( arr [ i ] ) - 1 ) ; int difference = prefix_sum - suffix_sum ; int number_of_subarray_at_i_split = 0 ; if ( prefix_element_count . containsKey ( difference ) ) number_of_subarray_at_i_split = prefix_element_count . get ( difference ) ; if ( suffix_element_count . containsKey ( - difference ) ) number_of_subarray_at_i_split += suffix_element_count . get ( - difference ) ; count_subarray_equal_sum += number_of_subarray_at_i_split ; } return count_subarray_equal_sum ; }
int countXORSetBitsAdjElemRange1_N ( int N ) { int total_set_bits = 0 ; int bit_Position = 1 ; while ( N != 0 ) { total_set_bits += ( ( N + 1 ) / 2 * bit_Position ) ; N -= ( N + 1 ) / 2 ; bit_Position ++ ; } return total_set_bits ; }
int checkPerfectSquare ( int N ) { if ( N <= 0 ) { return 0 ; } double sq = Math . sqrt ( N ) ; if ( Math . floor ( sq ) == Math . ceil ( sq ) ) { return 1 ; } return 0 ; }
boolean checktwoSidesareRighTriangle ( int A , int B ) { boolean checkTriangle = false ; if ( checkPerfectSquare ( A * A + B * B ) != 0 ) { checkTriangle = true ; } if ( checkPerfectSquare ( A * A - B * B ) != 0 ) { checkTriangle = true ; } if ( checkPerfectSquare ( B * B - A * A ) != 0 ) { checkTriangle = true ; } return checkTriangle ; }
boolean valid ( int i , int j ) { if ( i >= 0 && j >= 0 && i < r && j < c ) return true ; return false ; }
int find ( int i , int j , int [ ] [ ] v ) { int s = 0 ; for ( int k = 0 ; k < 8 ; k ++ ) { int ni = i + dir [ k ] [ 0 ] , nj = j + dir [ k ] [ 1 ] ; if ( valid ( ni , nj ) ) s += v [ ni ] [ nj ] ; } return s ; }
void findsumofneighbors ( int [ ] [ ] M ) { int [ ] [ ] v = new int [ r ] ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { v [ i ] [ j ] = find ( i , j , M ) ; System . out . print ( v [ i ] [ j ] + " " ) ; } System . out . println ( "" ) ; } }
int TotalBitwiseORPair ( int arr [ ] , int N ) { int totalOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalOR |= arr [ i ] ; } return totalOR ; }
void checkSolveable ( int n , int m ) { if ( n == 1 m == 1 ) System . out . print ( "YES" ) ; else if ( m == 2 && n == 2 ) System . out . print ( "YES" ) ; else System . out . print ( "NO" ) ; }
void printFinalArray ( int [ ] a , int n , int [ ] operations , int p , int capacity ) { int i , curr = 0 ; boolean picked = false ; for ( i = 0 ; i < p ; i ++ ) { int s = operations [ i ] ; boolean flag = false ; switch ( s ) { case 1 : if ( curr != 0 ) curr -- ; break ; case 2 : if ( curr != n - 1 ) curr ++ ; break ; case 3 : if ( picked == false && a [ curr ] != 0 ) { picked = true ; a [ curr ] -- ; } break ; case 4 : if ( picked == true && a [ curr ] != capacity ) { picked = false ; a [ curr ] ++ ; } break ; default : flag = true ; } if ( flag == true ) break ; } for ( i = 0 ; i < n ; i ++ ) { System . out . print ( a [ i ] + " " ) ; } }
void constructArray ( int A [ ] , int N ) { int [ ] left = new int [ N + 1 ] ; int [ ] right = new int [ N + 1 ] ; int [ ] X = new int [ N + 1 ] ; int [ ] Y = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { X [ i ] = left [ A [ i ] ] ; left [ A [ i ] ] ++ ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { Y [ i ] = right [ A [ i ] ] ; right [ A [ i ] ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( Y [ i ] - X [ i ] + " " ) ; } }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int largestElement ( Node head_ref ) { int Max = Integer . MIN_VALUE ; Node head = head_ref ; while ( head != null ) { if ( Max < head . data ) { Max = head . data ; } head = head . next ; } return Max ; }
void probablityPrimeprod ( int N ) { int N_E = 3 * N ; int N_S = power ( 6 , N ) ; System . out . print ( N_E + " / " + N_S ) ; }
boolean checkPalindrome ( int N ) { int rev = 0 ; int temp = N ; while ( N != 0 ) { rev = rev * 10 + N % 10 ; N = N / 10 ; } N = temp ; if ( N == rev ) { return true ; } return false ; }
int closestSmallerPalindrome ( int N ) { do { N -- ; } while ( N >= 0 && ! checkPalindrome ( N ) ) ; return N ; }
int MinimumOperationReq ( int N ) { int cntDecr = 0 ; int temp = N ; while ( temp > 0 ) { int X = ( int ) Math . sqrt ( temp ) ; if ( X * X == temp ) { break ; } temp = temp - 2 ; cntDecr += 1 ; } int cntIncr = 0 ; while ( true ) { int X = ( int ) Math . sqrt ( N ) ; if ( X * X == N ) { break ; } N = N + 2 ; cntIncr += 1 ; } return Math . min ( cntIncr , cntDecr ) ; }
long power ( long x , long N ) { long res = 1 ; while ( N > 0 ) { if ( N % 2 == 1 ) { res = ( res * x ) % M ; } x = ( x * x ) % M ; N = N >> 1 ; } return res ; }
long moduloInverse ( long X ) { return power ( X , M - 2 ) ; }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; else return GCD ( b , a % b ) ; }
void check ( int x , int y ) { if ( GCD ( x , y ) == 1 ) { System . out . print ( "Yes" ) ; } else { System . out . print ( "No" ) ; } }
void findSubArray ( Vector < Integer > arr , int k ) { Point ans = new Point ( 0 , 0 ) ; int i , sum = 0 ; for ( i = 0 ; i < k ; i ++ ) { sum += arr . get ( i ) ; } int found = 0 ; if ( sum % 3 == 0 ) { ans = new Point ( 0 , i - 1 ) ; found = 1 ; } for ( int j = i ; j < arr . size ( ) ; j ++ ) { if ( found == 1 ) break ; sum = sum + arr . get ( j ) - arr . get ( j - k ) ; if ( sum % 3 == 0 ) { ans = new Point ( j - k + 1 , j ) ; found = 1 ; } } if ( found == 0 ) ans = new Point ( - 1 , 0 ) ; if ( ans . x == - 1 ) { System . out . print ( - 1 ) ; } else { for ( i = ans . x ; i <= ans . y ; i ++ ) { System . out . print ( arr . get ( i ) + " " ) ; } } }
int sumOfProd ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } return sum * sum ; }
int rev ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }
boolean check ( int n ) { int x = ( n + 7 ) / 8 ; if ( ( n + 7 ) % 8 == 0 && isPower ( 10 , x ) ) return true ; else return false ; }
void mul_2 ( int K ) { int [ ] [ ] temp = new int [ K + 1 ] [ K + 1 ] ; for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 1 ; j <= K ; j ++ ) { for ( int k = 1 ; k <= K ; k ++ ) { temp [ i ] [ j ] = ( temp [ i ] [ j ] + ( T [ i ] [ k ] * T [ k ] [ j ] ) % mod ) % mod ; } } } for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 1 ; j <= K ; j ++ ) { T [ i ] [ j ] = temp [ i ] [ j ] ; } } }
void mul_1 ( int K ) { int [ ] [ ] temp = new int [ K + 1 ] [ K + 1 ] ; for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 1 ; j <= K ; j ++ ) { for ( int k = 1 ; k <= K ; k ++ ) { temp [ i ] [ j ] = ( temp [ i ] [ j ] + ( result [ i ] [ k ] * T [ k ] [ j ] ) % mod ) % mod ; } } } for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 1 ; j <= K ; j ++ ) { result [ i ] [ j ] = temp [ i ] [ j ] ; } } }
void matrix_pow ( int K , int n ) { for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 1 ; j <= K ; j ++ ) { if ( i == j ) result [ i ] [ j ] = 1 ; } } while ( n > 0 ) { if ( n % 2 == 1 ) mul_1 ( K ) ; mul_2 ( K ) ; n /= 2 ; } }
int countFreq ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp1 = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( mp1 . containsKey ( arr [ i ] ) ) { mp1 . put ( arr [ i ] , mp1 . get ( arr [ i ] ) + 1 ) ; } else { mp1 . put ( arr [ i ] , 1 ) ; } } HashMap < Integer , Integer > mp2 = new HashMap < Integer , Integer > ( ) ; for ( Map . Entry < Integer , Integer > it : mp1 . entrySet ( ) ) { if ( mp2 . containsKey ( it . getValue ( ) ) ) { mp2 . put ( it . getValue ( ) , mp2 . get ( it . getValue ( ) ) + 1 ) ; } else { mp2 . put ( it . getValue ( ) , 1 ) ; } } int M = Integer . MIN_VALUE ; for ( Map . Entry < Integer , Integer > it : mp2 . entrySet ( ) ) { M = Math . max ( M , it . getValue ( ) ) ; } for ( Map . Entry < Integer , Integer > it : mp2 . entrySet ( ) ) { if ( M == it . getValue ( ) ) { return it . getKey ( ) ; } } return 0 ; }
int computeSalary ( int basic , char grade ) { double allowance ; double hra , da , pf ; hra = 0.2 * basic ; da = 0.5 * basic ; pf = 0.11 * basic ; if ( grade == 'A' ) { allowance = 1700.0 ; } else if ( grade == 'B' ) { allowance = 1500.0 ; } else { allowance = 1300.0 ; } double gross ; gross = Math . round ( basic + hra + da + allowance - pf ) ; return ( int ) gross ; }
int maxDisconnected ( int N , int E ) { int curr = 1 ; int rem = E ; while ( rem > 0 ) { rem = rem - Math . min ( curr , rem ) ; curr ++ ; } if ( curr > 1 ) { return N - curr ; } else { return N ; } }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findSum ( int N ) { int sum = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( gcd ( i , N ) == 1 ) { sum += i ; } } return sum ; }
void solve ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int cnt = 0 ; for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) { cnt += ( ( x . getValue ( ) ) * ( x . getValue ( ) - 1 ) / 2 ) ; } int [ ] ans = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ans [ i ] = cnt - ( mp . get ( arr [ i ] ) - 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + " " ) ; } }
double nthRoot ( int A , int N ) { double xPre = ( Math . random ( ) * 10 ) % 10 ; double eps = 1e-3 ; double delX = Integer . MAX_VALUE ; double xK = 0 ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + ( double ) A / Math . pow ( xPre , N - 1 ) ) / ( double ) N ; delX = Math . abs ( xK - xPre ) ; xPre = xK ; } return xK ; }
float RMNValue ( int arr [ ] , int n , int k ) { int Nth = 0 ; float mean = 0 , root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Nth += Math . pow ( arr [ i ] , k ) ; } mean = ( Nth / ( float ) ( n ) ) ; root = ( float ) nthRoot ( ( int ) mean , k ) ; return root ; }
int xor_operations ( int N , int arr [ ] , int M , int K ) { if ( M < 0 M >= N ) return - 1 ; if ( K < 0 K >= N - M ) return - 1 ; for ( int p = 0 ; p < M ; p ++ ) { Vector < Integer > temp = new Vector < Integer > ( ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int value = arr [ i ] ^ arr [ i + 1 ] ; temp . add ( value ) ; arr [ i ] = temp . get ( i ) ; } } int ans = arr [ K ] ; return ans ; }
boolean checkPalindromeB ( int N , int B ) { int rev = 0 ; int N1 = N ; while ( N1 > 0 ) { rev = rev * B + N1 % B ; N1 = N1 / B ; } return N == rev ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findProduct ( int N ) { int result = 1 ; for ( int i = 2 ; i < N ; i ++ ) { if ( gcd ( i , N ) == 1 ) { result *= i ; } } return result ; }
int countEqual ( int n ) { return ( n + 1 ) / 2 ; }
int smallSubarray ( int arr [ ] , int n , int total_sum ) { Map < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; int length = Integer . MAX_VALUE ; int prefixSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { prefixSum += arr [ i ] ; if ( prefixSum == total_sum ) { length = Math . min ( length , i + 1 ) ; } m . put ( prefixSum , i ) ; if ( m . containsKey ( prefixSum - total_sum ) ) { length = Math . min ( length , i - m . get ( prefixSum - total_sum ) ) ; } } return length ; }
int smallestSubarrayremoved ( int arr [ ] , int n , int k ) { int total_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > k ) { arr [ i ] = 1 ; } else if ( arr [ i ] < k ) { arr [ i ] = - 1 ; } else { arr [ i ] = 0 ; } total_sum += arr [ i ] ; } if ( total_sum == 0 ) { return 0 ; } else { return smallSubarray ( arr , n , total_sum ) ; } }
int find ( int par [ ] , int x ) { if ( par [ x ] == x ) return x ; else return par [ x ] = find ( par , par [ x ] ) ; }
int functionMax ( int arr [ ] , int n ) { Vector < Integer > [ ] setBit = new Vector [ 32 + 1 ] ; for ( int i = 0 ; i < setBit . length ; i ++ ) setBit [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < size_int ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) setBit [ j ] . add ( i ) ; } } for ( int i = size_int ; i >= 0 ; i -- ) { if ( setBit [ i ] . size ( ) == 1 ) { swap ( arr , 0 , setBit [ i ] . get ( 0 ) ) ; break ; } } int maxAnd = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { maxAnd = maxAnd & ( ~ arr [ i ] ) ; } return maxAnd ; }
long modexp ( long x , long n , long m ) { if ( n == 0 ) { return 1 ; } else if ( n % 2 == 0 ) { return modexp ( ( x * x ) % m , n / 2 , m ) ; } else { return ( x * modexp ( ( x * x ) % m , ( n - 1 ) / 2 , m ) % m ) ; } }
long modInverse ( long x , long m ) { return modexp ( x , m - 2 , m ) ; }
void countNumbers ( String N ) { long m = 1000000007 ; long factorial [ ] = new long [ 100001 ] ; factorial [ 0 ] = 1 ; for ( int i = 1 ; i < 100001 ; i ++ ) { factorial [ i ] = ( factorial [ i - 1 ] * i ) % m ; } long count [ ] = new long [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { count [ i ] = 0 ; } long length = N . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) count [ N . charAt ( i ) - '0' ] ++ ; long result = factorial [ ( int ) length ] ; for ( int i = 0 ; i < 10 ; i ++ ) { result = ( result * modInverse ( factorial [ ( int ) count [ i ] ] , m ) ) % m ; } System . out . println ( result ) ; }
void max_valid_triplet ( int A [ ] , int n ) { int ans = - 1 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( A [ i ] < A [ j ] && A [ j ] < A [ k ] ) { int value = A [ i ] + A [ j ] * A [ k ] ; if ( value > ans ) { ans = value ; } } } } } System . out . println ( ans ) ; }
long productOfProperDivi ( int num ) { return ans [ num ] ; }
int findlcm ( int n ) { int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ( ( ( i * ans ) ) / ( __gcd ( i , ans ) ) ) ; return ans ; }
int highestPower ( int n ) { int lcm = findlcm ( n ) ; int ans = 0 ; for ( int i = 1 ; ; i ++ ) { int x = ( int ) Math . pow ( 2 , i ) ; if ( lcm % x == 0 ) { ans = i ; } if ( x > n ) break ; } return ans ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int countofPermutations ( int N ) { return ( int ) ( 3 * Math . pow ( 2 , N - 1 ) ) ; }
void answer ( int L , int R ) { if ( 2 * L <= R ) System . out . println ( L + ", " + ( 2 * L ) ) ; else System . out . println ( "-1" ) ; }
void spf_array ( int spf [ ] ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < 1000 ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < 1000 ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < 1000 ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < 1000 ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } }
void frequent_prime ( int arr [ ] , int N , int K ) { spf_array ( spf ) ; Map < Integer , Integer > Hmap = new TreeMap < > ( ) ; ArrayList < Integer > result = new ArrayList < > ( ) ; int i = 0 ; int c = 0 ; for ( i = 0 ; i < N ; i ++ ) { int x = arr [ i ] ; while ( x != 1 ) { Hmap . put ( spf [ x ] , Hmap . getOrDefault ( spf [ x ] , 0 ) + 1 ) ; x = x / spf [ x ] ; } } Hmap . remove ( 1 ) ; for ( Map . Entry < Integer , Integer > x : Hmap . entrySet ( ) ) { int primeNum = x . getKey ( ) ; int frequency = x . getValue ( ) ; if ( frequency % K == 0 ) { result . add ( primeNum ) ; } } if ( result . size ( ) > 0 ) { for ( Integer it : result ) { System . out . print ( it + " " ) ; } } else { System . out . print ( "{}" ) ; } }
void initialize_xor ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { total_xor = total_xor ^ arr [ i ] ; } }
int gcd ( int x , int y ) { if ( x % y == 0 ) return y ; else return gcd ( y , x % y ) ; }
int countPairwiseCoprime ( int N , int M ) { int answer = 1 ; int g = gcd ( N , M ) ; int temp = g ; for ( int i = 2 ; i * i <= g ; i ++ ) { if ( temp % i == 0 ) { answer ++ ; while ( temp % i == 0 ) temp /= i ; } } if ( temp != 1 ) answer ++ ; return answer ; }
void countCoprimePair ( int arr [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( countPairwiseCoprime ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) + " " ) ; } }
boolean prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
int getProduct ( int a [ ] , int n ) { int p = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { p *= Math . abs ( a [ i ] - a [ j ] ) ; } } return p ; }
boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
boolean diffCube ( int N ) { return isPerfectSquare ( 12 * N - 3 ) ; }
int totalCountDifference ( int n ) { if ( n == 1 ) return 1 ; return n + totalCountDifference ( n / 2 ) ; }
int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; }
void findLCM ( Vector < Integer > arr ) { int nth_lcm = arr . get ( 0 ) ; for ( int i = 1 ; i < arr . size ( ) ; i ++ ) nth_lcm = lcm ( nth_lcm , arr . get ( i ) ) ; Landau = Math . max ( Landau , nth_lcm ) ; }
void findWays ( Vector < Integer > arr , int i , int n ) { if ( n == 0 ) findLCM ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . add ( j ) ; findWays ( arr , j , n - j ) ; arr . remove ( arr . size ( ) - 1 ) ; } }
void Landau_function ( int n ) { Vector < Integer > arr = new Vector < > ( ) ; findWays ( arr , 1 , n ) ; System . out . print ( Landau ) ; }
int findSum ( int [ ] arr , int n , int left , int right ) { int k = right - left + 1 ; int d = arr [ 1 ] / arr [ 0 ] ; int ans = arr [ left - 1 ] ; if ( d == 1 ) ans = ans * d * k ; else ans = ans * ( ( int ) Math . pow ( d , k ) - 1 / ( d - 1 ) ) ; return ans ; }
int countRepeatingDigits ( int N ) { int res = 0 ; int cnt [ ] = new int [ 10 ] ; while ( N > 0 ) { int rem = N % 10 ; cnt [ rem ] ++ ; N = N / 10 ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( cnt [ i ] > 1 ) { res ++ ; } } return res ; }
int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
int solve ( int n , int m , int k ) { int sum = 0 ; for ( int i = 0 ; i <= k ; i ++ ) sum += nCr ( n , i ) * nCr ( m , k - i ) ; return sum ; }
int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
long modPower ( long a , long b , long M ) { long res = 1 ; while ( b > 0 ) { if ( b % 2 == 1 ) res = res * a % M ; a = a * a % M ; b >>= 1 ; } return res ; }
int Cal_min ( int arr [ ] , int n , int k ) { HashSet < Integer > diff_mod = new HashSet < > ( ) ; HashMap < Integer , Integer > count_mod = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { diff_mod . add ( arr [ i ] % k ) ; count_mod . put ( arr [ i ] % k , count_mod . getOrDefault ( arr [ i ] % k , 0 ) + 1 ) ; } return Find_min ( diff_mod , count_mod , k ) ; }
void canBreakN ( long n ) { for ( long i = 2 ; ; i ++ ) { long m = i * ( i + 1 ) / 2 ; if ( m > n ) break ; long k = n - m ; if ( k % i != 0 ) continue ; System . out . println ( i ) ; return ; } System . out . println ( "-1" ) ; }
void minimumSteps ( int arr [ ] , int n ) { int i ; int dat [ ] = new int [ n + 1 ] ; for ( i = 1 ; i <= n ; i ++ ) dat [ arr [ i - 1 ] ] = i ; int b [ ] = new int [ n + 1 ] ; int j = 0 , c ; for ( i = 1 ; i <= n ; i ++ ) { c = 1 ; j = dat [ i ] ; while ( j != i ) { c ++ ; j = dat [ j ] ; } b [ i ] = c ; } System . out . println ( findlcm ( b , n ) ) ; }
double maximum ( double a , double b ) { if ( a > b ) return a ; return b ; }
void check ( long num ) { long root = ( long ) Math . sqrt ( num ) ; long pow = ( long ) ( Math . log ( root ) / Math . log ( 2 ) ) ; if ( num == ( long ) ( Math . pow ( 2 , pow ) * ( Math . pow ( 2 , pow + 1 ) - 1 ) ) ) { if ( isPrime ( pow + 1 ) ) { if ( isPrime ( ( long ) Math . pow ( 2 , pow + 1 ) - 1 ) ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; } else System . out . println ( "No" ) ; } else System . out . println ( "No" ) ; }
boolean isPrime ( long n ) { if ( n <= 1 ) return false ; else if ( n == 2 n == 3 ) return true ; else { if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( long i = 5 ; i <= Math . sqrt ( n ) ; i += 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; } return true ; } }
boolean isTriplet ( int ar [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( Math . abs ( ar [ i ] - ar [ j ] ) == 1 || Math . abs ( ar [ j ] - ar [ k ] ) == 1 || Math . abs ( ar [ i ] - ar [ k ] ) == 1 ) { int x = ar [ i ] * ar [ i ] , y = ar [ j ] * ar [ j ] , z = ar [ k ] * ar [ k ] ; if ( x == y + z y == x + z z == x + y ) return true ; } } } } return false ; }
void closestDivisors ( int n ) { for ( int i = ( int ) Math . sqrt ( n + 2 ) ; i > 0 ; i -- ) { if ( ( n + 1 ) % i == 0 ) { System . out . print ( i + ", " + ( n + 1 ) / i ) ; break ; } if ( ( n + 2 ) % i == 0 ) { System . out . print ( i + ", " + ( n + 2 ) / i ) ; break ; } } }
int count ( int n ) { int [ ] phi = new int [ n + 1 ] ; Arrays . fill ( phi , 0 ) ; int [ ] divs = new int [ n + 1 ] ; Arrays . fill ( divs , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) { phi [ i ] += i ; for ( int j = i * 2 ; j <= n ; j += i ) phi [ j ] -= phi [ i ] ; for ( int j = i ; j <= n ; j += i ) divs [ j ] ++ ; } return ( n - phi [ n ] - divs [ n ] + 1 ) ; }
void inorder ( Node node ) { if ( node == null ) return ; inorder ( node . left ) ; System . out . printf ( "%d " , node . data ) ; inorder ( node . right ) ; }
int MinimumString ( int x ) { int b = 1 ; double left_lim = Math . sqrt ( x ) + 1.0 ; double right_lim = Math . sqrt ( x ) + 2.0 ; int r = 0 ; for ( int i = ( int ) left_lim ; i <= right_lim ; i ++ ) { if ( i > left_lim && i < right_lim ) { r = i ; break ; } } return b + r ; }
boolean isPerfectSquare ( int N ) { int floorSqrt = ( int ) Math . sqrt ( N ) ; return ( N == floorSqrt * floorSqrt ) ; }
boolean legendreFunction ( int N ) { while ( N % 4 == 0 ) N /= 4 ; if ( N % 8 != 7 ) return true ; else return false ; }
int minSquares ( int N ) { if ( isPerfectSquare ( N ) ) return 1 ; for ( int i = 1 ; i * i < N ; i ++ ) { if ( isPerfectSquare ( N - i * i ) ) return 2 ; } if ( legendreFunction ( N ) ) return 3 ; return 4 ; }
boolean is_distinct ( long n , long k ) { HashSet < Long > s = new HashSet < Long > ( ) ; for ( int i = 1 ; i <= k ; i ++ ) { long tmp = n % i ; if ( s . contains ( tmp ) ) { return false ; } s . add ( tmp ) ; } return true ; }
int getDivisors ( int min , int n ) { int total = 0 ; for ( int i = min ; i < n ; ++ i ) if ( n % i == 0 && n / i >= i ) { ++ total ; if ( n / i > i ) total += getDivisors ( i , n / i ) ; } return total ; }
void findWays ( Vector < Integer > arr , int i , int n ) { if ( n == 0 ) printVector ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . add ( j ) ; findWays ( arr , j , n - j ) ; arr . remove ( arr . size ( ) - 1 ) ; } }
void spt_function ( int n ) { Vector < Integer > arr = new Vector < > ( ) ; findWays ( arr , 1 , n ) ; System . out . print ( spt ) ; }
int isUgly ( int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; if ( n % 2 == 0 ) { return ( isUgly ( n / 2 ) ) ; } if ( n % 3 == 0 ) { return ( isUgly ( n / 3 ) ) ; } if ( n % 5 == 0 ) { return ( isUgly ( n / 5 ) ) ; } return 0 ; }
int findMinDenomin ( int n ) { return ( ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ) ; }
long calculate ( long p , long q ) { long mod = 998244353 , expo ; expo = mod - 2 ; while ( expo != 0 ) { if ( ( expo & 1 ) == 1 ) { p = ( p * q ) % mod ; } q = ( q * q ) % mod ; expo >>= 1 ; } return p ; }
int powerOptimised ( int a , int n ) { int ans = 1 ; while ( n > 0 ) { int last_bit = ( n & 1 ) ; if ( last_bit > 0 ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; }
int maxGCD ( int N ) { for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return N / i ; } } return 1 ; }
int findMaximumGcd ( int n ) { int max_gcd = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i > max_gcd ) max_gcd = i ; if ( ( n / i != i ) && ( n / i != n ) && ( ( n / i ) > max_gcd ) ) max_gcd = n / i ; } } return max_gcd ; }
int findContent ( int arr [ ] , int n ) { int content = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { content = __gcd ( content , arr [ i ] ) ; } return content ; }
void inverseEqual ( int arr [ ] , int n ) { int [ ] brr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int present_index = arr [ i ] - 1 ; brr [ present_index ] = i + 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != brr [ i ] ) { System . out . println ( "No" ) ; return ; } } System . out . println ( "Yes" ) ; }
void linearCongruentialMethod ( int Xo , int m , int a , int c , int [ ] randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( ( randomNums [ i - 1 ] * a ) + c ) % m ; } }
void multiplicativeCongruentialMethod ( int Xo , int m , int a , int [ ] randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] * a ) % m ; } }
void additiveCongruentialMethod ( int Xo , int m , int c , int [ ] randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] + c ) % m ; } }
int power ( int a , int b , int m ) { a %= m ; int res = 1 ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( ( res % m ) * ( a % m ) ) % m ; a = ( ( a % m ) * ( a % m ) ) % m ; b >>= 1 ; } return res % m ; }
int productOfDivisors ( int p [ ] , int n ) { HashMap < Integer , Integer > prime = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime . containsKey ( p [ i ] ) ) prime . put ( p [ i ] , prime . get ( p [ i ] ) + 1 ) ; else prime . put ( p [ i ] , 1 ) ; } int product = 1 , d = 1 ; for ( Map . Entry < Integer , Integer > itr : prime . entrySet ( ) ) { int val = power ( itr . getKey ( ) , ( itr . getValue ( ) ) * ( itr . getValue ( ) + 1 ) / 2 , MOD ) ; product = ( power ( product , itr . getValue ( ) + 1 , MOD ) * power ( val , d , MOD ) ) % MOD ; d = ( d * ( itr . getValue ( ) + 1 ) ) % ( MOD - 1 ) ; } return product ; }
int numberOfObjects ( int N , int M ) { int initial = Math . min ( N , M ) ; int last = ( N + M ) / 3 ; return Math . min ( initial , last ) ; }
int MaxSubarrayLength ( int arr [ ] , int n , int k ) { int left = - 1 ; int right = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % k ) != 0 ) { if ( left == - 1 ) { left = i ; } right = i ; } sum += arr [ i ] ; } if ( ( sum % k ) != 0 ) { return n ; } else if ( left == - 1 ) { return - 1 ; } else { int prefix_length = left + 1 ; int suffix_length = n - right ; return n - Math . min ( prefix_length , suffix_length ) ; } }
int findDistinct ( int arr [ ] , int n ) { int maximum = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; if ( n == 1 ) return 1 ; if ( n == 2 ) { return ( maximum / gcd ( arr [ 0 ] , arr [ 1 ] ) ) ; } int k = gcd ( arr [ 0 ] , arr [ 1 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { k = gcd ( k , arr [ i ] ) ; } return ( maximum / k ) ; }
int power ( int a , int b ) { if ( b == 0 ) return 1 ; if ( b == 1 ) return a ; int tmp = power ( a , b / 2 ) ; int result = tmp * tmp ; if ( b % 2 == 1 ) result *= a ; return result ; }
int solve ( int X , int Y ) { if ( X > Y ) { int temp = X ; X = Y ; Y = temp ; } if ( X == Y ) System . out . println ( 0 ) ; else if ( Y % X == 0 ) System . out . println ( 1 ) ; else System . out . println ( 2 ) ; return 0 ; }
void findWinner ( int n , int k ) { int cnt = 0 ; if ( n == 1 ) System . out . println ( "No" ) ; else if ( ( n & 1 ) != 0 n == 2 ) System . out . println ( "Yes" ) ; else { int tmp = n ; int val = 1 ; while ( tmp > k && tmp % 2 == 0 ) { tmp /= 2 ; val *= 2 ; } for ( int i = 3 ; i <= Math . sqrt ( tmp ) ; i ++ ) { while ( tmp % i == 0 ) { cnt ++ ; tmp /= i ; } } if ( tmp > 1 ) cnt ++ ; if ( val == n ) System . out . println ( "No" ) ; else if ( n / tmp == 2 && cnt == 1 ) System . out . println ( "No" ) ; else System . out . println ( "Yes" ) ; } }
long countQuadraples ( long N ) { long cnt = 0 ; Map < Long , Long > m = new HashMap < > ( ) ; for ( long a = 1 ; a <= N ; a ++ ) { for ( long b = 1 ; b <= N ; b ++ ) { long x = a * a + b * b ; m . put ( x , m . getOrDefault ( x , 0l ) + 1 ) ; } } for ( long c = 1 ; c <= N ; c ++ ) { for ( long d = 1 ; d <= N ; d ++ ) { long x = c * c + d * d ; if ( m . containsKey ( x ) ) cnt += m . get ( x ) ; } } return cnt ; }
int numberOfPairs ( int [ ] a , int [ ] b , int n ) { int c [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = a [ i ] - b [ i ] ; } Arrays . sort ( c ) ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( c [ i ] <= 0 ) continue ; int pos = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( c [ i ] + c [ j ] > 0 ) { pos = j ; break ; } } answer += ( i - pos ) ; } return answer ; }
void isEqualFactors ( int N ) { if ( ( N % 2 == 0 ) && ( N % 4 != 0 ) ) System . out . println ( "YES" ) ; else System . out . println ( "NO" ) ; }
int count_crazy_primes ( int L , int R ) { int prime [ ] = new int [ R + 1 ] ; int countPrime [ ] = new int [ R + 1 ] ; int freqPrime [ ] = new int [ R + 1 ] ; prime [ 0 ] = 1 ; prime [ 1 ] = 1 ; for ( int p = 2 ; p * p <= R ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * p ; i <= R ; i += p ) prime [ i ] = 1 ; } } for ( int i = 1 ; i <= R ; i ++ ) { countPrime [ i ] = countPrime [ i - 1 ] ; if ( prime [ i ] != 0 ) { countPrime [ i ] ++ ; } } for ( int i = 1 ; i <= R ; i ++ ) { freqPrime [ i ] = freqPrime [ i - 1 ] ; if ( prime [ countPrime [ i ] ] != 0 ) { freqPrime [ i ] ++ ; } } return ( freqPrime [ R ] - freqPrime [ L - 1 ] ) ; }
void findNumbers ( int n , int b ) { double largest = Math . pow ( b , n ) - 1 ; System . out . println ( largest ) ; }
void maximizedArray ( int arr [ ] , int N ) { int num , i = 0 ; for ( int l = N ; l > 0 ; l -- ) { num = arr [ i ] ; int one = 0 ; int zero = 0 ; while ( num != 0 ) { if ( num % 2 == 0 ) { zero ++ ; } else { one ++ ; } num = num >> 1 ; } for ( int j = zero ; j < ( one + zero ) ; j ++ ) { num += ( 1 << j ) ; } System . out . print ( num ) ; i ++ ; if ( N > 0 ) System . out . print ( ", " ) ; } }
void sieve ( ) { v [ 1 ] = 1 ; for ( int i = 2 ; i < x ; i ++ ) v [ i ] = i ; for ( int i = 4 ; i < x ; i += 2 ) v [ i ] = 2 ; for ( int i = 3 ; i * i < x ; i ++ ) { if ( v [ i ] == i ) { for ( int j = i * i ; j < x ; j += i ) { if ( v [ j ] == j ) { v [ j ] = i ; } } } } }
int prime_factors ( int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; while ( n != 1 ) { s . add ( v [ n ] ) ; n = n / v [ n ] ; } return s . size ( ) ; }
void distinctPrimes ( int m , int k ) { Vector < Integer > result = new Vector < Integer > ( ) ; for ( int i = 14 ; i < m + k ; i ++ ) { long count = prime_factors ( i ) ; if ( count == k ) { result . add ( i ) ; } } int p = result . size ( ) ; for ( int index = 0 ; index < p - 1 ; index ++ ) { long element = result . get ( index ) ; int count = 1 , z = index ; while ( z < p - 1 && count <= k && result . get ( z ) + 1 == result . get ( z + 1 ) ) { count ++ ; z ++ ; } if ( count >= k ) System . out . print ( element + " " ) ; } }
int findGCD ( int arr [ ] , int n ) { int gcd = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { gcd = __gcd ( arr [ i ] , gcd ) ; if ( gcd == 1 ) { return 1 ; } } return gcd ; }
int findLCM ( int arr [ ] , int n ) { int lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { lcm = ( ( ( arr [ i ] * lcm ) ) / ( __gcd ( arr [ i ] , lcm ) ) ) ; } return lcm ; }
void compute ( int a [ ] , int N , int K ) { Map < Long , Long > eqVal = new HashMap < Long , Long > ( ) ; long maxX = 0 ; for ( int i = 0 ; i < N ; i ++ ) { long val = a [ i ] % K ; val = ( val == 0 ? 0 : K - val ) ; if ( val == 0 ) continue ; if ( eqVal . containsKey ( val ) ) { long numVal = eqVal . get ( val ) ; maxX = Math . max ( maxX , val + ( K * numVal ) ) ; eqVal . put ( val , eqVal . getOrDefault ( val , 0l ) + 1l ) ; } else { eqVal . put ( val , 1l ) ; maxX = Math . max ( maxX , val ) ; } } System . out . println ( maxX == 0 ? 0 : maxX + 1 ) ; }
void print_h_index ( int arr [ ] , int N ) { List < Integer > ms = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { ms . add ( arr [ i ] ) ; int t = Collections . min ( ms ) ; if ( t < ms . size ( ) ) { ms . remove ( ms . indexOf ( t ) ) ; } System . out . print ( ms . size ( ) + " " ) ; } }
void pen_hex ( long n ) { long pn = 1 ; for ( long i = 1 ; i < n ; i ++ ) { pn = i * ( 3 * i - 1 ) / 2 ; if ( pn > n ) break ; double seqNum = ( 1 + Math . sqrt ( 8 * pn + 1 ) ) / 4 ; if ( seqNum == ( long ) seqNum ) System . out . print ( pn + ", " ) ; } }
int min_value ( int arr [ ] , int N ) { int x , X , K ; HashSet < Integer > S = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { S . add ( arr [ i ] ) ; } int count = 0 ; for ( int i = 1 ; i <= 1024 ; i ++ ) { count = 0 ; for ( int it : S ) { X = ( ( i it ) - ( i & it ) ) ; if ( S . contains ( X ) ) { count ++ ; } } if ( count == S . size ( ) ) { K = i ; return K ; } } return - 1 ; }
int prefixProduct ( int [ ] a , int n ) { for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i ] * a [ i - 1 ] ; } for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( a [ j ] + ", " ) ; } return 0 ; }
void sumOfTheArrayForQuery ( int [ ] A , int N , int [ ] X , int [ ] Y , int Q ) { int sum = 0 ; HashMap < Integer , Integer > count = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( count . containsKey ( A [ i ] ) ) { count . replace ( A [ i ] , count . get ( A [ i ] ) + 1 ) ; } else { count . put ( A [ i ] , 1 ) ; } } for ( int i = 0 ; i < Q ; i ++ ) { int x = X [ i ] , y = Y [ i ] ; if ( count . containsKey ( X [ i ] ) ) { sum -= count . get ( X [ i ] ) * X [ i ] ; sum += count . get ( X [ i ] ) * Y [ i ] ; } if ( count . containsKey ( Y [ i ] ) && count . containsKey ( X [ i ] ) ) { count . replace ( Y [ i ] , count . get ( Y [ i ] ) + count . get ( X [ i ] ) ) ; } if ( count . containsKey ( X [ i ] ) ) { count . replace ( X [ i ] , 0 ) ; } System . out . print ( sum + " " ) ; } }
int maxOR ( int [ ] arr , int n ) { int max_value = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , ( max_value arr [ i ] ) ) ; } return ans ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void generateArr ( int A [ ] , int n ) { int [ ] B = new int [ n ] ; int maxi = Arrays . stream ( A ) . max ( ) . getAsInt ( ) ; int count [ ] = new int [ maxi + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { B [ i ] = count [ A [ i ] ] ; IncrementFactors ( count , A [ i ] ) ; } printArr ( B , n ) ; }
ArrayList < Integer > SieveOfEratosthenes ( int n ) { boolean [ ] prime = new boolean [ 2 * n + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= 2 * n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= 2 * n ; i += p ) prime [ i ] = false ; } } ArrayList < Integer > primes = new ArrayList < > ( ) ; for ( int p = 2 ; p <= 2 * n ; p ++ ) if ( prime [ p ] ) primes . add ( p ) ; return primes ; }
int minChanges ( int [ ] arr ) { int n = arr . length ; int ans = 0 ; int maxi = arr [ 0 ] ; for ( int i = 1 ; i < arr . length ; i ++ ) maxi = Math . max ( maxi , arr [ i ] ) ; ArrayList < Integer > primes = SieveOfEratosthenes ( maxi ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = - 1 ; for ( int j = 0 ; j < primes . size ( ) ; j ++ ) { if ( arr [ i ] == primes . get ( j ) ) { x = j ; break ; } else if ( arr [ i ] < primes . get ( j ) ) { x = j ; break ; } } int minm = Math . abs ( primes . get ( x ) - arr [ i ] ) ; if ( x > 1 ) { minm = Math . min ( minm , Math . abs ( primes . get ( x - 1 ) - arr [ i ] ) ) ; } ans += minm ; } return ans ; }
int findSum ( int [ ] a , int n , int L , int R ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( L % a [ i ] == 0 && L != 0 ) { sum += calcSum ( a [ i ] , R / a [ i ] ) - calcSum ( a [ i ] , ( L - 1 ) / a [ i ] ) ; } else { sum += calcSum ( a [ i ] , R / a [ i ] ) - calcSum ( a [ i ] , L / a [ i ] ) ; } } return sum ; }
void findPrimes ( ) { for ( int i = 1 ; i <= maxN ; i ++ ) arr [ i ] = 1 ; arr [ 0 ] = 0 ; arr [ 1 ] = 0 ; for ( int i = 2 ; i * i <= maxN ; i ++ ) { if ( arr [ i ] == 1 ) { for ( int j = i * i ; j <= maxN ; j += i ) { arr [ j ] = 0 ; } } } int sum = 0 ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= maxN ; i ++ ) { if ( arr [ i ] == 1 ) { int temp = i ; sum = 0 ; while ( temp > 0 ) { int x = temp % 10 ; sum += x ; temp = temp / 10 ; if ( arr [ sum ] == 1 ) { prefix [ i ] = 1 ; } else { prefix [ i ] = 0 ; } } } } for ( int i = 1 ; i <= maxN ; i ++ ) { prefix [ i ] += prefix [ i - 1 ] ; } }
void print_product ( int a , int b , int c , int d ) { int prod1 = a * c ; int prod2 = b * d ; int prod3 = ( a + b ) * ( c + d ) ; int real = prod1 - prod2 ; int imag = prod3 - ( prod1 + prod2 ) ; System . out . println ( real + " + " + imag + "i" ) ; }
int countWays ( int N ) { if ( N < 4 ) return 0 ; int ans = ( ( N - 1 ) * ( N - 2 ) ) / 2 ; int s = 0 ; for ( int i = 2 ; i <= N - 3 ; i ++ ) { for ( int j = 1 ; j < i ; j ++ ) { if ( N == 2 * i + j ) s ++ ; } } if ( N % 3 == 0 ) s = 3 * s + 1 ; else s = 3 * s ; return ans - s ; }
double get_concentration ( double mass , double volume ) { if ( volume == 0 ) return - 1 ; else return ( mass / volume ) * 1000 ; }
boolean isSubsetSum ( Vector < Integer > set , int n , int sum ) { boolean [ ] [ ] subset = new boolean [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < set . get ( i - 1 ) ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set . get ( i - 1 ) ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set . get ( i - 1 ) ] ; } } return subset [ n ] [ sum ] ; }
boolean isPractical ( int N ) { Vector < Integer > div = new Vector < Integer > ( ) ; storeDivisors ( N , div ) ; for ( int i = 1 ; i < N ; i ++ ) { if ( ! isSubsetSum ( div , div . size ( ) , i ) ) return false ; } return true ; }
boolean isJunction ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i + sum ( i ) == n ) count ++ ; } return count >= 2 ; }
boolean isDivBySubsetSums ( Vector < Integer > arr , int num ) { int n = arr . size ( ) ; long total = 1 << n ; for ( long i = 0 ; i < total ; i ++ ) { long sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( ( i & ( 1 << j ) ) > 0 ) sum += arr . get ( j ) ; if ( sum != 0 && num % sum != 0 ) return false ; } return true ; }
boolean isSuperNivenNum ( int n ) { int temp = n ; Vector < Integer > digits = new Vector < Integer > ( ) ; while ( n != 0 ) { int digit = n % 10 ; digits . add ( digit ) ; n = n / 10 ; } return isDivBySubsetSums ( digits , temp ) ; }
int divCount ( int n ) { boolean [ ] hash = new boolean [ n + 1 ] ; Arrays . fill ( hash , true ) ; for ( int p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( int i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; int total = 1 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { int count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = n / p ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }
boolean isHighlyCompositeNumber ( int N ) { int NdivCount = divCount ( N ) ; for ( int i = 1 ; i < N ; i ++ ) { int idivCount = divCount ( i ) ; if ( idivCount >= NdivCount ) return false ; } return true ; }
boolean isInsolite ( int n ) { int N = n ; int sum = 0 ; int product = 1 ; while ( n != 0 ) { int r = n % 10 ; sum = sum + r * r ; product = product * r * r ; n = n / 10 ; } return ( N % sum == 0 ) && ( N % product == 0 ) ; }
boolean isSaintExuperyNum ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n / i / j ; if ( i * i + j * j == k * k ) { if ( i * j * k == n ) return true ; } } } return false ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
boolean isMagnanimous ( int N ) { String s = Integer . toString ( N ) ; int l = s . length ( ) ; if ( l < 2 ) return false ; for ( int i = 0 ; i < l - 1 ; i ++ ) { String left = s . substring ( 0 , i + 1 ) ; String right = s . substring ( i + 1 ) ; int x = Integer . valueOf ( left ) ; int y = Integer . valueOf ( right ) ; if ( ! isPrime ( x + y ) ) return false ; } return true ; }
int digProduct ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int nextPrime ( int N ) { if ( N <= 1 ) return 2 ; int prime = N ; boolean found = false ; while ( ! found ) { prime ++ ; if ( isPrime ( prime ) ) found = true ; } return prime ; }
boolean isPointerPrime ( int n ) { if ( isPrime ( n ) && ( n + digProduct ( n ) == nextPrime ( n ) ) ) return true ; else return false ; }
void sieve ( ) { position [ 0 ] = - 1 ; position [ 1 ] = - 1 ; int pos = 0 ; for ( int i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( int j = i * 2 ; j <= limit ; j += i ) position [ j ] = - 1 ; } } }
int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
int power ( int x , int y ) { if ( y == 0 ) { return 1 ; } if ( y % 2 == 0 ) { return ( power ( x , y / 2 ) * power ( x , y / 2 ) ) ; } return ( x * power ( x , y / 2 ) * power ( x , y / 2 ) ) ; }
boolean isPerfectDigitalInvariant ( int x ) { for ( int fixed_power = 1 ; ; fixed_power ++ ) { int temp = x , sum = 0 ; while ( temp > 0 ) { int r = temp % 10 ; sum += power ( r , fixed_power ) ; temp = temp / 10 ; } if ( sum == x ) { return true ; } if ( sum > x ) { return false ; } } }
boolean isWasteful ( int n ) { if ( n == 1 ) return false ; int original_no = n ; int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits ++ ; original_no = original_no / 10 ; } int pDigit = 0 , count_exp = 0 , p = 0 ; for ( int i = 0 ; primes . get ( i ) <= n / 2 ; i ++ ) { while ( n % primes . get ( i ) == 0 ) { p = primes . get ( i ) ; n = n / p ; count_exp ++ ; } while ( p > 0 ) { pDigit ++ ; p = p / 10 ; } while ( count_exp > 1 ) { pDigit ++ ; count_exp = count_exp / 10 ; } } if ( n != 1 ) { while ( n > 0 ) { pDigit ++ ; n = n / 10 ; } } return ( pDigit > sumDigits ) ; }
void Solve ( int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( isWasteful ( i ) ) { System . out . print ( i + " " ) ; } } }
boolean isDNum ( int n ) { if ( n < 4 ) return false ; int numerator = 0 , hcf = 0 ; for ( int k = 2 ; k <= n ; k ++ ) { numerator = ( int ) ( Math . pow ( k , n - 2 ) - k ) ; hcf = __gcd ( n , k ) ; } if ( hcf == 1 && ( numerator % n ) != 0 ) return false ; return true ; }
boolean isComposite ( int n ) { if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }
boolean isEnlightened ( int N ) { if ( ! isComposite ( N ) ) return false ; String num = String . valueOf ( N ) ; String prefixConc = concatenatePrimeFactors ( N ) ; return num . startsWith ( prefixConc ) ; }
boolean isIdoneal ( int n ) { for ( int a = 1 ; a <= n ; a ++ ) { for ( int b = a + 1 ; b <= n ; b ++ ) { for ( int c = b + 1 ; c <= n ; c ++ ) { if ( a * b + b * c + c * a == n ) return false ; } } } return true ; }
boolean isAllDigitsDivide ( int n ) { int temp = n ; while ( temp > 0 ) { int digit = temp % 10 ; if ( ! ( checkDivisibility ( n , digit ) ) ) return false ; temp /= 10 ; } return true ; }
boolean isAllDigitsDistinct ( int n ) { boolean arr [ ] = new boolean [ 10 ] ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; }
boolean isLynchBell ( int n ) { return isAllDigitsDivide ( n ) && isAllDigitsDistinct ( n ) ; }
int printhexaRec ( int n ) { if ( n == 0 n == 1 n == 2 n == 3 n == 4 n == 5 ) return 0 ; else if ( n == 6 ) return 1 ; else return ( printhexaRec ( n - 1 ) + printhexaRec ( n - 2 ) + printhexaRec ( n - 3 ) + printhexaRec ( n - 4 ) + printhexaRec ( n - 5 ) + printhexaRec ( n - 6 ) ) ; }
void printhexa ( int n ) { if ( n < 0 ) return ; int first = 0 ; int second = 0 ; int third = 0 ; int fourth = 0 ; int fifth = 0 ; int sixth = 1 ; int curr = 0 ; if ( n < 6 ) System . out . println ( first ) ; else if ( n == 6 ) System . out . println ( sixth ) ; else { for ( int i = 6 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth + sixth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = sixth ; sixth = curr ; } } System . out . println ( curr ) ; }
boolean isGapful ( int n ) { int first_dig = firstDigit ( n ) ; int last_dig = lastDigit ( n ) ; int concatenation = first_dig * 10 + last_dig ; return ( n % concatenation == 0 ) ; }
boolean check ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
boolean isPossible ( int A , int B , int N , int K , int L ) { int needa , needb ; if ( A % K == 0 ) needa = A / K ; else needa = A / K + 1 ; if ( B % L == 0 ) needb = B / L ; else needb = B / L + 1 ; int total = needa + needb ; if ( total > N ) return false ; else return true ; }
void CountTotalfactors ( ) { tfactor [ 1 ] = pre [ 1 ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) { int mspf = spf [ i ] ; int prim = mspf ; int temp = i ; int cnt = 0 ; while ( temp % mspf == 0 ) { temp /= mspf ; cnt += 1 ; prim = prim * mspf ; } tfactor [ i ] = ( cnt + 1 ) * tfactor [ temp ] ; pre [ i ] = pre [ i - 1 ] + tfactor [ i ] ; } }
int BinarySearch ( int X ) { int start = 1 ; int end = MAX - 1 ; while ( start < end ) { int mid = ( start + end ) / 2 ; if ( pre [ mid ] == X ) return mid ; else if ( pre [ mid ] < X ) start = mid + 1 ; else end = mid ; } return start ; }
void buildSieve ( int sum ) { prime = new boolean [ sum + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < ( sum + 1 ) ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < ( sum + 1 ) ; i += p ) prime [ i ] = false ; } } }
int getSum ( int a [ ] [ ] ) { int s = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 5 ; j ++ ) s += a [ i ] [ j ] ; return s ; }
boolean checkIndex ( int n , int m , int a [ ] [ ] ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) { if ( prime [ i + j ] && ! prime [ a [ i ] [ j ] ] ) { return false ; } } return true ; }
int takeSum ( int a [ ] [ ] ) { int s = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) s += a [ i ] [ j ] ; return s ; }
long sumOfSumSeries ( int N ) { long sum = 0L ; for ( int i = 1 ; i <= N ; i ++ ) { sum = sum + ( i * ( i + 1 ) ) / 2 ; } return sum ; }
boolean isPrime ( int n ) { if ( n == 1 ) return true ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
void checkExpression ( int n ) { if ( isPrime ( n ) ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
int placeValue ( int N , int num ) { int total = 1 , value = 0 , rem = 0 ; while ( true ) { rem = N % 10 ; N = N / 10 ; if ( rem == num ) { value = total * rem ; break ; } total = total * 10 ; } return value ; }
boolean isContaindigit ( int n ) { while ( n > 0 ) { if ( ! ( n % 10 == 0 n % 10 == 1 n % 10 == 8 ) ) return false ; n = n / 10 ; } return true ; }
boolean ispalindrome ( int n ) { String temp = Integer . toString ( n ) ; int l = temp . length ( ) ; for ( int i = 0 ; i < l / 2 ; i ++ ) { if ( temp . charAt ( i ) != temp . charAt ( l - i - 1 ) ) return false ; } return true ; }
void printTetradicPrimesLessThanN ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; int p = 2 ; while ( p * p <= n ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i < n + 1 ; i += p ) prime [ i ] = false ; } p += 1 ; } for ( p = 2 ; p < n + 1 ; p ++ ) { if ( prime [ p ] && isTetradic ( p ) ) System . out . print ( p + " " ) ; } }
void BeattySequence ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int ans = ( int ) Math . floor ( i * Math . sqrt ( 2 ) ) ; System . out . print ( ans + ", " ) ; } }
int concat ( int a , int b ) { String s1 = Integer . toString ( a ) ; String s2 = Integer . toString ( b ) ; String s = s1 + s2 ; int c = Integer . parseInt ( s ) ; return c ; }
boolean isAstonishing ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += j ; if ( sum == n ) { int concatenation = concat ( i , j ) ; if ( concatenation == n ) { return true ; } } } } return false ; }
int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
boolean isSelfNum ( int n ) { for ( int m = 1 ; m <= n ; m ++ ) { if ( m + getSum ( m ) == n ) return false ; } return true ; }
int Sum ( int N ) { int SumOfPrimeDivisors [ ] = new int [ N + 1 ] ; for ( int i = 2 ; i <= N ; ++ i ) { if ( SumOfPrimeDivisors [ i ] == 1 ) { for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; }
boolean RuthAaronNumber ( int n ) { if ( Sum ( n ) == Sum ( n + 1 ) ) return true ; else return false ; }
int binomialCoeff ( int n , int k ) { int [ ] [ ] C = new int [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
void SieveOfEratosthenes ( int n , boolean isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } }
int countDigit ( int n ) { int count = 0 ; while ( n != 0 ) { n = n / 10 ; ++ count ; } return count ; }
Stack < Integer > sortStack ( Stack < Integer > input ) { Stack < Integer > tmpStack = new Stack < Integer > ( ) ; while ( ! input . empty ( ) ) { int tmp = input . peek ( ) ; input . pop ( ) ; while ( ! tmpStack . empty ( ) && tmpStack . peek ( ) < tmp ) { input . push ( tmpStack . peek ( ) ) ; tmpStack . pop ( ) ; } tmpStack . push ( tmp ) ; } return tmpStack ; }
void sortArrayUsingStacks ( int [ ] arr , int n ) { Stack < Integer > input = new Stack < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) input . push ( arr [ i ] ) ; Stack < Integer > tmpStack = sortStack ( input ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = tmpStack . peek ( ) ; tmpStack . pop ( ) ; } }
int getSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum ; }
boolean MultiplyPerfectNumber ( int n ) { if ( getSum ( n ) % n == 0 ) return true ; else return false ; }
int phi ( int n ) { int result = n ; for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) { n /= p ; } result -= result / p ; } } if ( n > 1 ) result -= result / n ; return result ; }
boolean isPower ( int a ) { if ( a == 1 ) return true ; for ( int i = 2 ; i * i <= a ; i ++ ) { double val = Math . log ( a ) / Math . log ( i ) ; if ( ( val - ( int ) val ) < 0.00000001 ) return true ; } return false ; }
boolean isCunningham ( int n ) { return isPower ( n - 1 ) || isPower ( n + 1 ) ; }
boolean checkSame ( int n , int b ) { HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; while ( n != 0 ) { int r = n % b ; n = n / b ; if ( m . containsKey ( r ) ) { m . put ( r , m . get ( r ) + 1 ) ; } else { m . put ( r , 1 ) ; } } int last = - 1 ; for ( Map . Entry < Integer , Integer > i : m . entrySet ( ) ) { if ( last != - 1 && i . getValue ( ) != last ) { return false ; } else { last = i . getValue ( ) ; } } return true ; }
int SubArrayProdct ( int arr [ ] , int n ) { int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) result *= Math . pow ( arr [ i ] , ( i + 1 ) * ( n - i ) ) ; return result ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int countWays ( int m , int n , int x , int y ) { return nCr ( m + n , m ) - nCr ( x + y , x ) * nCr ( m + n - x - y , m - x ) ; }
int averageRuns ( int runs , int matches , int notout ) { int out = matches - notout ; if ( out == 0 ) return - 1 ; int avg = ( runs ) / out ; return avg ; }
int seriesSum ( int n ) { int sum = 0 ; int currProd = 1 ; int currSum = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { currProd *= i ; currSum += i ; sum += currProd - currSum ; } return sum ; }
int seriesSumUtil ( int k , int n , int prevSum , int multi , int add ) { if ( k == n + 1 ) { return prevSum ; } multi = multi * k ; add = add + k ; prevSum = prevSum + multi - add ; return seriesSumUtil ( k + 1 , n , prevSum , multi , add ) ; }
int seriesSum ( int n ) { if ( n == 1 ) return 0 ; int prevSum = 0 ; int multi = 1 ; int add = 1 ; return seriesSumUtil ( 2 , n , prevSum , multi , add ) ; }
void Is_possible ( long N ) { long C = 0 ; long D = 0 ; while ( N % 10 == 0 ) { N = N / 10 ; C += 1 ; } if ( Math . pow ( 2 , ( long ) ( Math . log ( N ) / ( Math . log ( 2 ) ) ) ) == N ) { D = ( long ) ( Math . log ( N ) / ( Math . log ( 2 ) ) ) ; if ( C >= D ) System . out . print ( "YES" ) ; else System . out . print ( "NO" ) ; } else System . out . print ( "NO" ) ; }
int maximumAND ( int L , int R ) { return R ; }
int count ( int a [ ] , int n ) { int countElements = 0 ; for ( int i = 0 ; i < n ; i ++ ) { boolean flag = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; if ( a [ i ] % a [ j ] == 0 ) { flag = false ; break ; } } if ( flag == true ) ++ countElements ; } return countElements ; }
int countEle ( int a [ ] , int n ) { int len = 0 ; HashMap < Integer , Integer > hmap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { len = Math . max ( len , a [ i ] ) ; if ( hmap . containsKey ( a [ i ] ) ) { hmap . put ( a [ i ] , hmap . get ( a [ i ] ) + 1 ) ; } else { hmap . put ( a [ i ] , 1 ) ; } } boolean [ ] v = new boolean [ len + 1 ] ; for ( int i = 0 ; i <= len ; i ++ ) { v [ i ] = true ; } for ( int i = 0 ; i < n ; i ++ ) { if ( v [ a [ i ] ] == false ) continue ; for ( int j = 2 * a [ i ] ; j <= len ; j += a [ i ] ) { v [ j ] = false ; } } int count = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { if ( v [ i ] == true && hmap . containsKey ( i ) && hmap . get ( i ) == 1 && hmap . get ( i ) == 1 ) { count += 1 ; } } return count ; }
int find_min_sum ( int a , int b , int c ) { int x = 0 , y = 0 , g = 0 ; if ( possible_solution ( a , b , c ) == 0 ) return - 1 ; if ( g != 0 ) { a /= g ; b /= g ; } int sign_a = a > 0 ? + 1 : - 1 ; int sign_b = b > 0 ? + 1 : - 1 ; shift_solution ( a , b , - x / b ) ; if ( x < 0 ) shift_solution ( a , b , sign_b ) ; int minx1 = x ; shift_solution ( a , b , y / a ) ; if ( y < 0 ) shift_solution ( a , b , - sign_a ) ; int minx2 = x ; if ( minx2 > x ) { int temp = minx2 ; minx2 = x ; x = temp ; } int minx = Math . max ( minx1 , minx2 ) ; if ( minx > x ) return - 1 ; int miny = ( c - a * x ) / b ; return ( miny + minx ) ; }
int countPairs ( int [ ] A , int n ) { int count = 0 , i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( A [ i ] % 2 == 0 && A [ j ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ j ] % 2 != 0 ) ) count ++ ; } } return count ; }
int smallestNumber ( int N ) { return ( int ) ( N * Math . ceil ( Math . pow ( 10 , ( N - 1 ) ) / N ) ) ; }
int maxPrimefactorNum ( int N ) { int [ ] arr = new int [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) arr [ i ] = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( arr [ i ] == 1 ) { for ( int j = i ; j <= N ; j += i ) { arr [ j ] *= i ; } } } int maxValue = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( arr [ i ] > maxValue ) { maxValue = i ; } } return maxValue ; }
int linearSum ( int n ) { return ( n * ( n + 1 ) / 2 ) % mod ; }
int rangeSum ( int b , int a ) { return ( linearSum ( b ) - linearSum ( a ) ) % mod ; }
int totalSum ( int n ) { int result = 0 ; int i = 1 ; while ( true ) { result += rangeSum ( n / i , n / ( i + 1 ) ) * ( i % mod ) % mod ; result %= mod ; if ( i == n ) break ; i = n / ( n / ( i + 1 ) ) ; } return result ; }
int CountPairs ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] % 2 == 0 arr [ j ] % 2 == 0 ) count ++ ; } } return count ; }
boolean isPal ( int a [ ] [ ] , int n , int m ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) return false ; } } return true ; }
int smallestNum ( int n ) { return ( int ) ( ( n * n % 9 + 1 ) * Math . pow ( 10 , n * n / 9 ) - 1 ) ; }
void smallestNumber ( int N ) { System . out . print ( ( N % 9 + 1 ) * Math . pow ( 10 , ( N / 9 ) ) - 1 ) ; }
void findNthTerm ( int n ) { System . out . println ( n * ( 5 * n + 3 ) / 2 ) ; }
void findNthTerm ( int n ) { System . out . print ( n * ( 2 * n + 1 ) ) ; }
int reversDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }
boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
boolean isRare ( int N ) { int reverseN = reversDigits ( N ) ; if ( reverseN == N ) return false ; return isPerfectSquare ( N + reverseN ) && isPerfectSquare ( N - reverseN ) ; }
int getProduct ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; }
boolean isDouble ( int num ) { String s = Integer . toString ( num ) ; int l = s . length ( ) ; if ( s . charAt ( 0 ) == s . charAt ( 1 ) ) return false ; if ( l % 2 == 1 ) { s = s + s . charAt ( 1 ) ; l ++ ; } String s1 = s . substring ( 0 , l / 2 ) ; String s2 = s . substring ( l / 2 ) ; return s1 . equals ( s2 ) ; }
boolean isNontrivialUndulant ( int N ) { return N > 100 && isDouble ( N ) ; }
void findNthTerm ( int n ) { System . out . println ( n * ( 4 * n + 3 ) ) ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
boolean isAdditivePrime ( int n ) { if ( ! isPrime ( n ) ) return false ; return isPrime ( getSum ( n ) ) ; }
boolean isStraighLineNum ( int N ) { if ( N <= 99 ) return false ; String s = Integer . toString ( N ) ; int d = s . charAt ( 1 ) - s . charAt ( 0 ) ; for ( int i = 2 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) - s . charAt ( i - 1 ) != d ) return false ; return true ; }
void findNthTerm ( int n ) { System . out . println ( Math . pow ( 2 , n ) - 2 * n ) ; }
boolean isEvenOddForm ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 && s . charAt ( i ) % 2 != 0 ) return false ; if ( i % 2 == 1 && s . charAt ( i ) % 2 != 1 ) return false ; } return true ; }
boolean isOddEvenForm ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 && s . charAt ( i ) % 2 != 1 ) return false ; if ( i % 2 == 1 && s . charAt ( i ) % 2 != 0 ) return false ; } return true ; }
boolean isAlternating ( int n ) { String str = Integer . toString ( n ) ; return ( isEvenOddForm ( str ) || isOddEvenForm ( str ) ) ; }
void findNthTerm ( int n ) { System . out . println ( n * n - n + 1 ) ; }
boolean isDroll ( int n ) { if ( n == 1 ) return false ; int sum_even = 0 ; int sum_odd = 0 ; while ( n % 2 == 0 ) { sum_even += 2 ; n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { sum_odd += i ; n = n / i ; } } if ( n > 2 ) sum_odd += n ; return sum_even == sum_odd ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
boolean areAnagrams ( int a , int b ) { int freqA [ ] = new int [ TEN ] ; int freqB [ ] = new int [ TEN ] ; updateFreq ( a , freqA ) ; updateFreq ( b , freqB ) ; for ( int i = 0 ; i < TEN ; i ++ ) { if ( freqA [ i ] != freqB [ i ] ) return false ; } return true ; }
int DecakismyriagonNum ( int N ) { return ( 99998 * N * N - 99996 * N ) / 2 ; }
boolean iszygodromeNum ( int N ) { String s = Integer . toString ( N ) ; s = ' ' + s + ' ' ; for ( int i = 1 ; i < s . length ( ) - 1 ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) && s . charAt ( i ) != s . charAt ( i + 1 ) ) { return false ; } } return true ; }
boolean isLoeschian ( int n ) { for ( int x = 1 ; x <= Math . sqrt ( n ) ; x ++ ) { for ( int y = 1 ; y <= Math . sqrt ( n ) ; y ++ ) { if ( x * x + x * y + y * y == n ) return true ; } } return false ; }
void printSeries ( int N ) { int ith_term = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ith_term = ( 13 * i * ( i - 1 ) ) / 2 + 2 ; System . out . print ( ith_term + ", " ) ; } }
void printSeries ( int n , int a , int b , int c ) { int d ; if ( n == 1 ) { System . out . print ( a + " " ) ; return ; } if ( n == 2 ) { System . out . print ( a + " " + b + " " ) ; return ; } System . out . print ( a + " " + b + " " + c + " " ) ; for ( int i = 4 ; i <= n ; i ++ ) { d = a + b + c ; System . out . print ( d + " " ) ; a = b ; b = c ; c = d ; } }
void sieveSundaram ( ) { boolean marked [ ] = new boolean [ MAX / 2 + 1 ] ; for ( int i = 1 ; i <= ( Math . sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j += 2 * i + 1 ) marked [ j ] = true ; primes . add ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . add ( 2 * i + 1 ) ; }
Vector < pair > Pairs ( int C ) { Vector < pair > ans = new Vector < pair > ( ) ; for ( int i = 1 ; i < C ; i ++ ) { for ( int j = i + 1 ; j < C ; j ++ ) { if ( ( i * i ) + ( j * j ) == ( C * C ) ) { ans . add ( new pair ( i , j ) ) ; } } } return ans ; }
float strikerate ( float bowls , float runs ) { float z ; z = ( runs / bowls ) * 100 ; return z ; }
int factorize ( int N ) { int count = 0 ; int cnt = 0 ; while ( ( N % 2 ) == 0 ) { N = N / 2 ; count ++ ; } cnt = cnt + count ; for ( int i = 3 ; i <= Math . sqrt ( N ) ; i += 2 ) { count = 0 ; while ( N % i == 0 ) { count ++ ; N = N / i ; } cnt = cnt + count ; } if ( N > 2 ) cnt = cnt + 1 ; return cnt ; }
void ifNumberExists ( int X , int Y ) { int C , dsum ; C = X - Y - 1 ; dsum = factorize ( X ) ; if ( dsum >= C ) System . out . println ( "YES" ) ; else System . out . println ( "NO" ) ; }
boolean checkArray ( int n , int k , int arr [ ] ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; }
void print_nearest_prime ( int arr [ ] , int N ) { int maxm = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; SieveOfEratosthenes ( maxm ) ; Vector < Integer > primes = new Vector < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! prime [ arr [ i ] ] ) primes . add ( i ) ; } if ( primes . size ( ) == 0 ) { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( - 1 + " " ) ; } return ; } int curr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( curr == primes . size ( ) - 1 || i <= primes . get ( curr ) ) { System . out . print ( arr [ primes . get ( curr ) ] + " " ) ; continue ; } if ( Math . abs ( primes . get ( curr ) - i ) < Math . abs ( primes . get ( curr + 1 ) - i ) ) { System . out . print ( arr [ primes . get ( curr ) ] + " " ) ; } else { curr ++ ; System . out . print ( arr [ primes . get ( curr ) ] + " " ) ; } } }
int CountPairs ( int n ) { int cnt = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int div1 = i ; int div2 = n / i ; int sum = div1 + div2 ; if ( gcd ( sum , n ) == 1 ) cnt += 1 ; } } return cnt ; }
void allQuotients ( int N ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int k = 1 ; k <= N + 1 ; k ++ ) { s . add ( N / k ) ; } for ( int it : s ) System . out . print ( it + " " ) ; }
void findPosition ( int n ) { int i = 0 ; int pos = 0 ; while ( n > 0 ) { if ( n % 10 == 7 ) { pos = pos + ( int ) Math . pow ( 2 , i + 1 ) ; } else { pos = pos + ( int ) Math . pow ( 2 , i ) ; } i ++ ; n = n / 10 ; } System . out . print ( pos ) ; }
int greatestOddFactor ( int n ) { int pow_2 = ( int ) ( Math . log ( n ) ) ; int i = 1 ; while ( i <= pow_2 ) { int fac_2 = ( 2 * i ) ; if ( n % fac_2 == 0 ) { if ( ( n / fac_2 ) % 2 == 1 ) { return ( n / fac_2 ) ; } } i += 1 ; } return 0 ; }
void countSmaller ( String str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( str . charAt ( j ) < str . charAt ( i ) ) { cnt += 1 ; } } System . out . print ( cnt + " " ) ; } }
int sum_star_num ( int n ) { int summ = 2 * n * ( n + 1 ) * ( n - 1 ) + n ; return summ ; }
void solve ( int n , ArrayList < Point > vec ) { ArrayList < Integer > a = new ArrayList < > ( ) ; ArrayList < Integer > b = new ArrayList < > ( ) ; for ( Point pr : vec ) { a . add ( pr . x ) ; b . add ( pr . y ) ; } Collections . sort ( a ) ; Collections . sort ( b ) ; int left , right , ans ; if ( ( n & 1 ) != 0 ) { left = a . get ( n / 2 ) ; right = b . get ( n / 2 ) ; ans = right - left + 1 ; } else { left = ( a . get ( n / 2 ) + a . get ( n / 2 - 1 ) ) ; right = ( b . get ( n / 2 ) + b . get ( n / 2 - 1 ) ) ; ans = right - left + 1 ; } System . out . println ( ans ) ; }
int find_pairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } for ( Map . Entry < Integer , Integer > i : mp . entrySet ( ) ) { int count = i . getValue ( ) ; if ( count > 1 ) { ans += ( ( count * ( count - 1 ) ) / 2 ) ; } } return ans ; }
String Majority_in_linklist ( node head ) { String s = "" ; String t = "" ; int p = 0 , q = 0 ; node ptr = null ; while ( head != null ) { if ( s . equals ( head . i ) ) { p = p + 1 ; } else { if ( t . equals ( head . i ) ) { q = q + 1 ; } else { if ( p == 0 ) { s = head . i ; p = 1 ; } else { if ( q == 0 ) { t = head . i ; q = 1 ; } else { p = p - 1 ; q = q - 1 ; } } } } head = head . next ; } head = ptr ; p = 0 ; q = 0 ; while ( head != null ) { if ( s . equals ( head . i ) ) { p = 1 ; } else { if ( t . equals ( head . i ) ) { q = 1 ; } } head = head . next ; } if ( p > q ) { return s ; } else { return t ; } }
int gonNum65537 ( int n ) { return ( 65535 * n * n - 65533 * n ) / 2 ; }
int MegagonNum ( int n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; }
int gonNum120 ( int n ) { return ( 118 * n * n - 116 * n ) / 2 ; }
int TetracontaoctagonalNum ( int n ) { return ( 46 * n * n - 44 * n ) / 2 ; }
int TetracontadigonalNum ( int n ) { return ( 40 * n * n - 38 * n ) / 2 ; }
int HexacontatetragonNum ( int n ) { return ( 62 * n * n - 60 * n ) / 2 ; }
int binpow ( int a , int b ) { int res = 1 ; while ( b > 0 ) { if ( b % 2 == 1 ) res = res * a ; a = a * a ; b /= 2 ; } return res ; }
Boolean checkOverlapping ( ArrayList < Integer > a , ArrayList < Integer > b ) { if ( a . get ( 0 ) < b . get ( 0 ) ) { int temp = a . get ( 0 ) ; a . set ( 0 , b . get ( 0 ) ) ; b . set ( 0 , temp ) ; temp = a . get ( 1 ) ; a . set ( 1 , b . get ( 1 ) ) ; b . set ( 1 , temp ) ; } if ( b . get ( 0 ) <= a . get ( 0 ) && a . get ( 0 ) <= b . get ( 1 ) ) return true ; return false ; }
int find ( ArrayList < Integer > a , int i ) { if ( a . get ( i ) == i ) { return i ; } a . set ( i , find ( a , a . get ( i ) ) ) ; return a . get ( i ) ; }
Boolean checkNonOverlapping ( ArrayList < ArrayList < Integer > > arr , int n ) { ArrayList < Integer > dsu = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dsu . add ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( checkOverlapping ( arr . get ( i ) , arr . get ( j ) ) ) { if ( union ( dsu , i , j ) ) { return false ; } } } } return true ; }
boolean isPossible ( int A , int B ) { return ( A - B > 1 ) ; }
int minDivisorDifference ( int n ) { int num1 = 0 ; int num2 = 0 ; for ( int i = ( int ) Math . sqrt ( n ) ; i <= n ; i ++ ) { if ( n % i == 0 ) { num1 = i ; num2 = n / i ; break ; } } return Math . abs ( num1 - num2 ) ; }
int dfs ( Vector < Integer > g [ ] , int u , int par ) { sub [ u ] = minDivisorDifference ( u ) ; int mx = 0 ; for ( int c : g [ u ] ) { if ( c != par ) { int ans = dfs ( g , c , u ) ; mx = Math . max ( mx , ans ) ; } } sub [ u ] += mx ; return sub [ u ] ; }
int findLCMPrime ( int a , int b ) { if ( a == b ) { return a ; } return a * b ; }
void smallestNumber ( int N ) { System . out . print ( N * Math . ceil ( Math . pow ( 2 , ( N - 1 ) ) / N ) ) ; }
void smallestNumber ( int N ) { System . out . print ( N * Math . floor ( ( Math . pow ( 10 , N ) - 1 ) / N ) ) ; }
boolean istriacontagonal ( int N ) { float n = ( float ) ( ( 26 + Math . sqrt ( 224 * N + 676 ) ) / 56 ) ; return ( n - ( int ) n ) == 0 ; }
void checkSolution ( int a , int b , int c ) { if ( a == c ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
boolean isComposite ( int n ) { if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; int i = 5 ; while ( i * i <= n ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; i = i + 6 ; } return false ; }
void Compositorial_list ( int n ) { int l = 0 ; for ( int i = 4 ; i < 1000000 ; i ++ ) { if ( l < n ) { if ( isComposite ( i ) ) { compo . add ( i ) ; l += 1 ; } } } }
int calculateCompositorial ( int n ) { int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) result = result * compo . get ( i ) ; return result ; }
void numberOfDigits ( int N ) { int nod = ( int ) Math . floor ( Math . log10 ( N ) + 1 ) ; int toDecrease = ( int ) ( Math . pow ( 10 , nod ) - 1 ) / 9 ; System . out . print ( ( N + 1 ) * nod - toDecrease ) ; }
void Maxlength ( int arr [ ] , int N ) { Vector < Integer > zeroindex = new Vector < Integer > ( ) ; int maxlen ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zeroindex . add ( i ) ; } if ( zeroindex . size ( ) == 0 ) { maxlen = N ; } else { maxlen = ( int ) zeroindex . get ( 0 ) ; for ( int i = 0 ; i < zeroindex . size ( ) - 1 ; i ++ ) { if ( ( int ) zeroindex . get ( i + 1 ) - ( int ) zeroindex . get ( i ) - 1 > maxlen ) { maxlen = ( int ) zeroindex . get ( i + 1 ) - ( int ) zeroindex . get ( i ) - 1 ; } } if ( N - ( int ) zeroindex . get ( zeroindex . size ( ) - 1 ) - 1 > maxlen ) { maxlen = N - ( int ) zeroindex . get ( zeroindex . size ( ) - 1 ) - 1 ; } } System . out . println ( maxlen ) ; }
boolean isPossible ( int arr [ ] , int N , int K ) { int oddCount = 0 , evenCount = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { evenCount ++ ; } else { oddCount ++ ; } } if ( evenCount == N || ( oddCount == N && K % 2 == 0 ) || ( K == N && oddCount % 2 == 0 ) ) { return false ; } else { return true ; } }
float productOfGP ( float a , float r , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = product * a ; a = a * r ; } return product ; }
float productOfGP ( float a , float r , int n ) { return ( float ) Math . pow ( a , n ) * ( float ) Math . pow ( r , n * ( n - 1 ) / 2 ) ; }
float productOfGP ( float a , float r , int n ) { int an = ( int ) ( a * ( int ) ( Math . pow ( r , n - 1 ) ) ) ; return ( int ) Math . sqrt ( ( int ) Math . pow ( a * an , n ) ) ; }
boolean is_Chiliagon ( int N ) { float n = ( float ) ( 996 + Math . sqrt ( 7984 * N + 992016 ) ) / 1996 ; return ( n - ( int ) n ) == 0 ; }
int commonSubarrays ( int [ ] A , int [ ] B , int N ) { int [ ] Map = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) Map [ A [ i ] ] = i ; for ( int i = 0 ; i < N ; i ++ ) { B [ i ] = Map [ B [ i ] ] ; } int count = 0 ; int i = 0 , K ; while ( i < N ) { K = 1 ; i += 1 ; while ( i < N && B [ i ] == B [ i - 1 ] + 1 ) { i += 1 ; K += 1 ; } count = count + ( ( K ) * ( K + 1 ) ) / 2 ; } return count ; }
void getArrayOfSizeK ( int n , int k ) { Vector < Integer > ans = new Vector < Integer > ( ) ; int odd = n - ( ( k - 1 ) * 1 ) ; if ( odd > 0 && odd % 2 != 0 ) { for ( int i = 0 ; i < k - 1 ; i ++ ) { ans . add ( 1 ) ; } ans . add ( odd ) ; } int even = n - ( ( k - 1 ) * 2 ) ; if ( even > 0 && even % 2 == 0 && ans . size ( ) == 0 ) { for ( int i = 0 ; i < k - 1 ; i ++ ) { ans . add ( 2 ) ; } ans . add ( even ) ; } if ( ans . size ( ) > 0 ) { for ( int i = 0 ; i < k ; i ++ ) { System . out . print ( ans . get ( i ) + " " ) ; } } else { System . out . println ( "NO" ) ; } }
boolean checkDivisbility ( int num ) { int digit ; int N = num ; while ( num != 0 ) { digit = num % 10 ; num = num / 10 ; if ( digit == 0 N % digit != 0 ) return false ; } return true ; }
int inv ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; }
int derivative ( int x ) { return 3 * x * x ; }
int Image ( int x , int k ) { return x * x * x - k ; }
int next_power ( int a_t , int t , int a1 , int prime , int k ) { int power_p = ( int ) Math . pow ( prime , t + 1 ) ; int next_a = ( a_t - Image ( a_t , k ) * inv ( derivative ( a1 ) , prime ) ) % power_p ; if ( next_a < 0 ) return next_a += power_p ; return next_a ; }
int powerOfPrime ( int prime , int power , int k , int a1 ) { if ( derivative ( a1 ) != 0 ) { int a_t = a1 ; for ( int p = 1 ; p < power ; p ++ ) { a_t = next_power ( a_t , p , a1 , prime , k ) ; } return a_t ; } return - 1 ; }
int findlcm ( int arr [ ] , int n ) { int ans = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { ans = ( ( ( arr [ i ] * ans ) ) / ( gcd ( arr [ i ] , ans ) ) ) ; } return ans ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int minLCM ( int arr [ ] , int n ) { int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int g = gcd ( arr [ i ] , arr [ j ] ) ; int lcm = arr [ i ] / g * arr [ j ] ; ans = Math . min ( ans , lcm ) ; } } return ans ; }
int minLCM ( int arr [ ] , int n ) { int mx = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mx = Math . max ( mx , arr [ i ] ) ; } Vector < Integer > [ ] mul = new Vector [ mx + 1 ] ; for ( int i = 0 ; i < mul . length ; i ++ ) mul [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mul [ arr [ i ] ] . size ( ) > 1 ) { continue ; } mul [ arr [ i ] ] . add ( arr [ i ] ) ; } for ( int i = 1 ; i <= mx ; i ++ ) { for ( int j = i + i ; j <= mx ; j += i ) { if ( mul [ i ] . size ( ) > 1 ) { break ; } for ( int k : mul [ j ] ) { if ( mul [ i ] . size ( ) > 1 ) break ; mul [ i ] . add ( k ) ; } } } int ans = Integer . MAX_VALUE ; for ( int i = 1 ; i <= mx ; i ++ ) { if ( mul [ i ] . size ( ) <= 1 ) continue ; int a = mul [ i ] . get ( 0 ) , b = mul [ i ] . get ( 1 ) ; int lcm = ( a * b ) / i ; ans = Math . min ( ans , lcm ) ; } return ans ; }
boolean isSuffix ( String s1 , String s2 ) { int n1 = s1 . length ( ) ; int n2 = s2 . length ( ) ; if ( n1 > n2 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( s1 . charAt ( n1 - i - 1 ) != s2 . charAt ( n2 - i - 1 ) ) return false ; return true ; }
boolean CheckBinaryEquivalent ( int N ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; int c = ( int ) Math . pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } String bin = Integer . toString ( B_Number ) ; return isSuffix ( "001" , bin ) ; }
boolean CheckBinaryEquivalent ( int N ) { return ( N - 1 ) % 8 == 0 ; }
void print_practica_No ( int A , int B ) { for ( int i = A ; i <= B ; i ++ ) { if ( Is_Practical ( i ) == true ) { System . out . print ( i + " " ) ; } } }
float maxDivision ( Integer arr [ ] , int n ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; float mxdiv = arr [ 1 ] ; for ( int i = 2 ; i < n ; ++ i ) mxdiv = mxdiv / arr [ i ] ; return arr [ 0 ] / mxdiv ; }
void solve ( int n ) { int upper_limit = ( int ) ( Math . ceil ( Math . pow ( n , 1.0 / 4 ) ) ) ; for ( int x = 0 ; x <= upper_limit ; x ++ ) { for ( int y = 0 ; y <= upper_limit ; y ++ ) { int num1 = x * x * x * x ; int num2 = y * y * y * y ; if ( num1 - num2 == n ) { System . out . print ( "x = " + x + ", y = " + y ) ; return ; } } } System . out . print ( - 1 ) ; }
int productPairs ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; }
int power ( int x , int y ) { int p = 1000000007 ; int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
int productPairs ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = ( product % mod * ( int ) power ( arr [ i ] , ( 2 * n ) ) % mod ) % mod ; } return product % mod ; }
int numPairsWithPrimeSum ( int [ ] arr , int n ) { int N = 2 * 1000000 ; boolean [ ] isPrime = sieveOfEratosthenes ( N ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( isPrime [ sum ] ) { count ++ ; } } } return count ; }
void constructArray ( int N ) { int arr [ ] = new int [ N ] ; for ( int i = 1 ; i <= N ; i ++ ) { arr [ i - 1 ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + ", " ) ; } }
void digitsPresent ( int n ) { int lastDigit ; while ( n != 0 ) { lastDigit = n % 10 ; digit [ lastDigit ] = 1 ; n /= 10 ; } }
int checkLastDigit ( int num ) { int count = 0 ; int lastDigit ; lastDigit = num % 10 ; if ( digit [ lastDigit ] == 1 ) count ++ ; return count ; }
boolean divisorsSame ( int n ) { int even_div = 0 , odd_div = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { if ( i % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } } else { if ( i % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } if ( n / i % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } } } } return ( even_div == odd_div ) ; }
void sieveoferanthones ( ) { boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( prime [ i ] ) for ( int j = i * i ; j <= n ; j += i ) { prime [ j ] = false ; } } for ( int i = 2 ; i < n ; i ++ ) { if ( prime [ i ] ) v . add ( i ) ; } }
int find ( int K , int N ) { N -- ; while ( N -- != 0 ) { int curr_term = K ; int min_d = 9 ; int max_d = 0 ; while ( curr_term > 0 ) { int r = curr_term % 10 ; min_d = Math . min ( min_d , r ) ; max_d = Math . max ( max_d , r ) ; curr_term = curr_term / 10 ; } if ( min_d == 0 ) { break ; } K = K + min_d * max_d ; } return K ; }
double Convert ( double degree ) { double pi = 3.14159265359 ; return ( degree * ( pi / 180 ) ) ; }
long countSubarrays ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int [ ] prefixSum = new int [ n ] ; int prefixMin = 0 ; prefixSum [ 0 ] = arr [ 0 ] ; prefixMin = Math . min ( prefixMin , prefixSum [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] ; prefixMin = Math . min ( prefixMin , prefixSum [ i ] ) ; } long countSubs = 0 ; mp . put ( 0 , 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; prefixSum [ i ] - j * j >= prefixMin ; j ++ ) { if ( mp . containsKey ( prefixSum [ i ] - j * j ) ) countSubs += mp . get ( prefixSum [ i ] - j * j ) ; } if ( mp . containsKey ( prefixSum [ i ] ) ) { mp . put ( prefixSum [ i ] , mp . get ( prefixSum [ i ] ) + 1 ) ; } else { mp . put ( prefixSum [ i ] , 1 ) ; } } return countSubs ; }
boolean checkSolution ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { return ( ( a1 / a2 ) == ( b1 / b2 ) && ( b1 / b2 ) == ( c1 / c2 ) ) ; }
int chiliagonNum ( int n ) { return ( 998 * n * n - 996 * n ) / 2 ; }
void checkSolution ( int a , int b , int c ) { if ( b == 0 ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i += 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
boolean isBalancedPrime ( int n ) { if ( ! isPrime ( n ) n == 2 ) return false ; int previous_prime = n - 1 ; int next_prime = n + 1 ; while ( ! isPrime ( next_prime ) ) next_prime ++ ; while ( ! isPrime ( previous_prime ) ) previous_prime -- ; int mean = ( previous_prime + next_prime ) / 2 ; if ( n == mean ) return true ; else return false ; }
int pentacontagonNum ( int n ) { return ( 48 * n * n - 46 * n ) / 2 ; }
void positiveProduct ( int arr [ ] , int n ) { int even_count = 0 ; int odd_count = 0 ; int total_count = 0 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( total_count % 2 == 0 ) { even_count ++ ; } else { odd_count ++ ; } if ( arr [ i ] < 0 ) { total_count ++ ; } if ( total_count % 2 == 0 ) ans += even_count ; else ans += odd_count ; } System . out . println ( ans ) ; }
int sumOfGCDofPairs ( int n ) { int res = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int d1 = i ; int d2 = n / i ; res += d1 * getCount ( d1 , n ) ; if ( d1 != d2 ) res += d2 * getCount ( d2 , n ) ; } } return res ; }
boolean checkIsFibonacci ( int arr [ ] , int n ) { if ( n == 1 n == 2 ) return true ; Arrays . sort ( arr ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( ( arr [ i - 1 ] + arr [ i - 2 ] ) != arr [ i ] ) return false ; } return true ; }
int lastDigitFactorial ( int n ) { if ( n == 0 ) return 1 ; else if ( n <= 2 ) return n ; else if ( n == 3 ) return 6 ; else if ( n == 4 ) return 4 ; else return 0 ; }
int lastDigit2PowerN ( int n ) { if ( n == 0 ) return 1 ; else if ( n % 4 == 1 ) return 2 ; else if ( n % 4 == 2 ) return 4 ; else if ( n % 4 == 3 ) return 8 ; else }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int sumSubsequences ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int kLengthSubSequence ; kLengthSubSequence = nCr ( n , k ) ; int ans = sum * ( ( k * kLengthSubSequence ) / n ) ; return ans ; }
boolean hasOddNumberOfDivisors ( int n ) { if ( ( double ) Math . sqrt ( n ) == ( int ) Math . sqrt ( n ) ) return true ; return false ; }
int dfs ( int node , int parent ) { int count = 0 ; for ( int i : adj [ node ] ) { if ( i != parent ) { count += dfs ( i , node ) ; } } if ( hasOddNumberOfDivisors ( a [ node ] ) ) ++ count ; ans [ node ] = count ; return count ; }
int costCalculation ( int current , int arr [ ] , int n , int pref [ ] , int a , int r , int minimum ) { int index = lowerBound ( arr , arr . length , current ) ; int left = index * current - pref [ index ] ; int right = pref [ n ] - pref [ index ] - ( n - index ) * current ; int res = Math . min ( left , right ) ; left -= res ; right -= res ; int total = res * minimum ; total += left * a ; total += right * r ; return total ; }
void solve ( int arr [ ] , int n , int a , int r , int m ) { Arrays . sort ( arr ) ; int minimum = Math . min ( a + r , m ) ; int [ ] pref = new int [ n + 1 ] ; Arrays . fill ( pref , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref [ i + 1 ] = pref [ i ] + arr [ i ] ; int ans = 10000 ; for ( int i = 0 ; i < n ; i ++ ) ans = Math . min ( ans , costCalculation ( arr [ i ] , arr , n , pref , a , r , minimum ) ) ; ans = Math . min ( ans , costCalculation ( pref [ n ] / n , arr , n , pref , a , r , minimum ) ) ; ans = Math . min ( ans , costCalculation ( pref [ n ] / n + 1 , arr , n , pref , a , r , minimum ) ) ; System . out . println ( ans ) ; }
int findSum ( int n , int k ) { int val = ( k / ( n - 1 ) ) * n ; int rem = k % ( n - 1 ) ; if ( rem == 0 ) { val = val - 1 ; } else { val = val + rem ; } int sum = ( val * ( val + 1 ) ) / 2 ; int x = k / ( n - 1 ) ; int sum_of_multiples = ( x * ( x + 1 ) * n ) / 2 ; sum -= sum_of_multiples ; return sum ; }
Vector < Integer > getFactorization ( int x ) { int count = 0 ; Vector < Integer > v = new Vector < > ( ) ; while ( x % 2 == 0 ) { count ++ ; x = x / 2 ; } if ( count != 0 ) v . add ( count ) ; for ( int i = 3 ; i <= Math . sqrt ( x ) ; i += 2 ) { count = 0 ; while ( x % i == 0 ) { count ++ ; x /= i ; } if ( count != 0 ) v . add ( count ) ; } if ( x > 1 ) { v . add ( 1 ) ; } return v ; }
int nonPrimeDivisors ( int N ) { Vector < Integer > v = getFactorization ( N ) ; int ret = 1 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) ret = ret * ( v . get ( i ) + 1 ) ; ret = ret - v . size ( ) ; return ret ; }
boolean isPerfectSquare ( int x ) { int s = ( int ) Math . sqrt ( x ) ; return ( s * s == x ) ; }
boolean isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
boolean checkDigits ( int n ) { while ( n != 0 ) { int dig = n % 10 ; if ( dig == 4 && dig == 6 && dig == 7 && dig == 9 ) return false ; n /= 10 ; } return true ; }
boolean isFullfibonacci ( int n ) { return ( checkDigits ( n ) && isFibonacci ( n ) ) ; }
boolean checksilverRatio ( double a , double b ) { if ( a < b ) { a = a + b ; b = a - b ; a = a - b ; } double ratio1 = ( ( a / b ) * 1000 ) / 1000 ; double ratio2 = ( int ) ( ( ( 2 * a + b ) / a ) * 1000 ) ; ratio2 = ratio2 / 1000 ; if ( ratio1 == ratio2 && ( int ) ( ratio1 - 2.414 ) == 0 ) { System . out . println ( "Yes" ) ; return true ; } else { System . out . println ( "No" ) ; return false ; } }
int MIN ( int n ) { int ans = 11 ; while ( n > 0 ) { ans = Math . min ( ans , n % 10 ) ; n /= 10 ; } return ans ; }
int MAX ( int n ) { int ans = - 1 ; while ( n > 0 ) { ans = Math . max ( ans , n % 10 ) ; n /= 10 ; } return ans ; }
void Find_value ( int n , int k ) { k -- ; int x = 0 ; int y = 0 ; while ( k -- > 0 ) { x = MIN ( n ) ; y = MAX ( n ) ; if ( y - x == 0 ) break ; n *= ( y - x ) ; } System . out . print ( n ) ; }
int countBinaries ( int N ) { int ctr = 1 ; int ans = 0 ; while ( N > 0 ) { if ( N % 10 == 1 ) { ans += Math . pow ( 2 , ctr - 1 ) ; } else if ( N % 10 > 1 ) { ans = ( int ) ( Math . pow ( 2 , ctr ) - 1 ) ; } ctr ++ ; N /= 10 ; } return ans ; }
int countBinaries ( int N ) { Vector < Integer > powersOfTwo = new Vector < Integer > ( 11 ) ; powersOfTwo . add ( 1 ) ; for ( int i = 1 ; i < 11 ; i ++ ) { powersOfTwo . add ( powersOfTwo . get ( i - 1 ) * 2 ) ; } int ctr = 1 ; int ans = 0 ; while ( N > 0 ) { if ( N % 10 == 1 ) { ans += powersOfTwo . get ( ctr - 1 ) ; } else if ( N % 10 > 1 ) { ans = powersOfTwo . get ( ctr ) - 1 ; } ctr ++ ; N /= 10 ; } return ans ; }
int sum_Centered_Hexadecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Hexadecagonal_num ( i ) ; } return summ ; }
int heptadecagonal_num ( int n ) { return ( ( 15 * n * n ) - 13 * n ) / 2 ; }
int sum_heptadecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += heptadecagonal_num ( i ) ; } return summ ; }
int center_heptagonal_num ( int n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; }
int sum_center_heptagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += center_heptagonal_num ( i ) ; } return summ ; }
int Centered_Dodecagonal_num ( int n ) { return 6 * n * ( n - 1 ) + 1 ; }
int sum_Centered_Dodecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Dodecagonal_num ( i ) ; } return summ ; }
int center_Octagonal_num ( int n ) { return ( 4 * n * n - 4 * n + 1 ) ; }
int sum_center_Octagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += center_Octagonal_num ( i ) ; } return summ ; }
int Centered_decagonal_num ( int n ) { return ( 5 * n * n - 5 * n + 1 ) ; }
int sum_Centered_decagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_decagonal_num ( i ) ; } return summ ; }
int center_octadecagon_num ( int n ) { return ( 9 * n * n - 9 * n + 1 ) ; }
int sum_center_octadecagon_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += center_octadecagon_num ( i ) ; } return summ ; }
int Centered_Pentadecagonal_num ( int n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; }
int sum_Centered_Pentadecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Pentadecagonal_num ( i ) ; } return summ ; }
boolean isMyriagon ( int N ) { double n = ( 9996 + Math . sqrt ( 79984 * N + 99920016 ) ) / 19996 ; return ( n - ( int ) n ) == 0 ; }
boolean isOctadecagon ( int N ) { double n = ( 14 + Math . sqrt ( 128 * N + 196 ) ) / 32 ; return ( n - ( int ) n ) == 0 ; }
boolean isoctagonal ( int N ) { double n = ( 2 + Math . sqrt ( 12 * N + 4 ) ) / 6 ; return ( n - ( int ) n ) == 0 ; }
boolean isheptagonal ( int N ) { double n = ( 3 + Math . sqrt ( 40 * N + 9 ) ) / 10 ; return ( n - ( int ) n ) == 0 ; }
boolean isPentadecagon ( int N ) { double n = ( 11 + Math . sqrt ( 104 * N + 121 ) ) / 26 ; return ( n - ( int ) n ) == 0 ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int countSubsequences ( int arr [ ] , int n , int k ) { int countPrime = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime ( arr [ i ] ) ) countPrime ++ ; } if ( countPrime < k ) return 0 ; return nCr ( countPrime , k ) * ( int ) Math . pow ( 2 , ( n - countPrime ) ) ; }
int longestEvenOddSubarray ( int a [ ] , int n ) { int longest = 1 ; int cnt = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] + a [ i + 1 ] ) % 2 == 1 ) { cnt ++ ; } else { longest = Math . max ( longest , cnt ) ; cnt = 1 ; } } if ( longest == 1 ) return 0 ; return Math . max ( cnt , longest ) ; }
int digSum ( int a ) { int sum = 0 ; while ( a != 0 ) { sum += a % 10 ; a = a / 10 ; } return sum ; }
boolean isPrime ( int r ) { boolean s = true ; for ( int i = 2 ; i * i <= r ; i ++ ) { if ( r % i == 0 ) { s = false ; break ; } } return s ; }
boolean istetradecagonal ( int N ) { double n = ( 10 + Math . sqrt ( 96 * N + 100 ) ) / 24 ; return ( n - ( int ) n ) == 0 ; }
boolean ishexadecagonal ( int N ) { double n = ( 12 + Math . sqrt ( 112 * N + 144 ) ) / 28 ; return ( n - ( int ) n ) == 0 ; }
boolean isnonagonal ( int N ) { double n = ( 5 + Math . sqrt ( 56 * N + 25 ) ) / 14 ; return ( n - ( int ) n ) == 0 ; }
int nCr ( int n , int r ) { if ( r > n ) return 0 ; return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int countSubsequences ( int arr [ ] , int n , int k ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) countOdd ++ ; } int ans = nCr ( n , k ) - nCr ( countOdd , k ) ; return ans ; }
void divParts ( int N ) { if ( N % 2 == 0 ) System . out . println ( ( N / 2 ) - 1 ) ; else System . out . println ( ( N / 2 ) ) ; }
int solve ( String s , int n ) { int left = 0 , right = 0 ; int maxlength = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '(' ) left ++ ; else right ++ ; if ( left == right ) maxlength = Math . max ( maxlength , 2 * right ) ; else if ( right > left ) left = right = 0 ; } left = right = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '(' ) left ++ ; else right ++ ; if ( left == right ) maxlength = Math . max ( maxlength , 2 * left ) ; else if ( left > right ) left = right = 0 ; } return maxlength ; }
int Icosagonal_num ( int n ) { return ( 18 * n * n - 16 * n ) / 2 ; }
int sum_Icosagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { summ += Icosagonal_num ( i ) ; } return summ ; }
int Centered_Pentagonal_num ( int n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; }
int sum_Centered_Pentagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Pentagonal_num ( i ) ; } return summ ; }
int Centered_tridecagonal_num ( int n ) { return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; }
int sum_Centered_tridecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { summ += Centered_tridecagonal_num ( i ) ; } return summ ; }
int getMinSteps ( int n , int jump ) { int quotient = n / jump ; int remainder = n % jump ; int steps = quotient + remainder ; return steps ; }
int Betrothed_Sum ( int n ) { Vector < Integer > Set = new Vector < Integer > ( ) ; for ( int number_1 = 1 ; number_1 < n ; number_1 ++ ) { int sum_divisor_1 = 1 ; int i = 2 ; while ( i * i <= number_1 ) { if ( number_1 % i == 0 ) { sum_divisor_1 = sum_divisor_1 + i ; if ( i * i != number_1 ) sum_divisor_1 += number_1 / i ; } i ++ ; } if ( sum_divisor_1 > number_1 ) { int number_2 = sum_divisor_1 - 1 ; int sum_divisor_2 = 1 ; int j = 2 ; while ( j * j <= number_2 ) { if ( number_2 % j == 0 ) { sum_divisor_2 += j ; if ( j * j != number_2 ) sum_divisor_2 += number_2 / j ; } j = j + 1 ; } if ( sum_divisor_2 == number_1 + 1 && number_1 <= n && number_2 <= n ) { Set . add ( number_1 ) ; Set . add ( number_2 ) ; } } } int Summ = 0 ; for ( int i = 0 ; i < Set . size ( ) ; i ++ ) { if ( Set . get ( i ) <= n ) Summ += Set . get ( i ) ; } return Summ ; }
void constructArray ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( i + " " ) ; } }
int prod_of_max_min ( int n ) { int largest = 0 ; int smallest = 10 ; while ( n != 0 ) { int r = n % 10 ; largest = Math . max ( r , largest ) ; smallest = Math . min ( r , smallest ) ; n = n / 10 ; } return largest * smallest ; }
int formed_no ( int N , int K ) { if ( K == 1 ) { return N ; } int answer = N ; while ( K != 0 ) { int a_current = prod_of_max_min ( answer ) ; if ( a_current == 0 ) break ; answer += a_current ; } return answer ; }
boolean isCenteredtridecagonal ( int N ) { float n = ( float ) ( ( 13 + Math . sqrt ( 104 * N + 65 ) ) / 26 ) ; return ( n - ( int ) n ) == 0 ; }
boolean isCenteredpentagonal ( int N ) { float n = ( float ) ( ( 5 + Math . sqrt ( 40 * N - 15 ) ) / 10 ) ; return ( n - ( int ) n ) == 0 ; }
boolean isCentereddecagonal ( int N ) { double n = ( 5 + Math . sqrt ( 20 * N + 5 ) ) / 10 ; return ( n - ( int ) n ) == 0 ; }
boolean isdodecagonal ( int N ) { float n = ( float ) ( ( 4 + Math . sqrt ( 20 * N + 16 ) ) / 10 ) ; return ( n - ( int ) n ) == 0 ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i += 6 ) { if ( n % i == 0 || n % ( i + 6 ) == 0 ) { return false ; } } return true ; }
boolean SexyPrime ( int n1 , int n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && Math . abs ( n1 - n2 ) == 6 ) ; }
int countSexyPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( SexyPrime ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; }
void computePrime ( int N ) { Prime = new boolean [ N + 1 ] ; Arrays . fill ( Prime , true ) ; Prime [ 0 ] = Prime [ 1 ] = false ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( Prime [ i ] ) { for ( int j = i * i ; j < N ; j += i ) { Prime [ j ] = false ; } } } }
int countSexyPairs ( int arr [ ] , int n ) { int maxE = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; computePrime ( maxE ) ; int count = 0 ; int freq [ ] = new int [ maxE + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( Prime [ arr [ i ] ] ) { if ( arr [ i ] + 6 < freq . length && freq [ arr [ i ] + 6 ] > 0 && Prime [ arr [ i ] + 6 ] ) { count ++ ; } } } return count ; }
double nDigitPerfectSquares ( int n , int b ) { double largest = Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( b , n ) ) ) - 1 , 2 ) ; return largest ; }
void findNum ( int n , int k ) { int q = k / ( n - 1 ) ; int r = k % ( n - 1 ) ; int a = 0 ; if ( r != 0 ) a = ( n * q ) + r ; else a = ( n * q ) - 1 ; System . out . println ( a ) ; }
double cubeRoot ( double n ) { double ans = Math . pow ( 3 , ( ( 1.0 / 3 ) * ( Math . log ( n ) / Math . log ( 3 ) ) ) ) ; return ans ; }
int floorMax ( int A , int B , int N ) { int x = Math . min ( B - 1 , N ) ; return ( A * x ) / B ; }
int calculateMoves ( int n ) { int count = 0 ; int layers = n / 2 ; for ( int k = 1 ; k < layers + 1 ; k ++ ) { count += 8 * k * k ; } return count ; }
void countWays ( int n ) { if ( n <= 2 ) { System . out . print ( "-1" ) ; } else { int ans = ( n - 1 ) * ( n - 2 ) / 2 ; System . out . print ( ans ) ; } }
boolean isSumSquare ( int N ) { double n = ( 2 + Math . sqrt ( 8 * N - 4 ) ) / 2 ; return ( n - ( int ) n ) == 0 ; }
boolean isCenteredheptagonal ( int N ) { double n = ( 7 + Math . sqrt ( 56 * N - 7 ) ) / 14 ; return ( n - ( int ) n ) == 0 ; }
boolean isCenterednonadecagonal ( int N ) { float n = ( float ) ( ( 19 + Math . sqrt ( 152 * N + 209 ) ) / 38 ) ; return ( n - ( int ) n ) == 0 ; }
boolean isCenteredOctadecagonal ( int N ) { double n = ( 9 + Math . sqrt ( 36 * N + 45 ) ) / 18 ; return ( n - ( int ) n ) == 0 ; }
int countDigit ( double n ) { return ( ( int ) Math . floor ( Math . log10 ( n ) + 1 ) ) ; }
boolean isPower ( int N , int K ) { int res1 = ( int ) ( Math . log ( N ) / Math . log ( K ) ) ; double res2 = Math . log ( N ) / Math . log ( K ) ; return ( res1 == res2 ) ; }
int prevPowerofK ( int n , int k ) { int p = ( int ) ( Math . log ( n ) / Math . log ( k ) ) ; return ( int ) Math . pow ( k , p ) ; }
int nextPowerOfK ( int n , int k ) { return prevPowerofK ( n , k ) * k ; }
int subarray ( int arr [ ] , int n ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { ++ temp ; } else { ans = Math . max ( ans , temp ) ; temp = 1 ; } } ans = Math . max ( ans , temp ) ; return ans ; }
void findMaxMinSubArray ( int arr [ ] , int K , int n ) { int min = n ; int max = 0 ; int left ; int right ; int tmp ; for ( int i = 0 ; i < n ; i ++ ) { tmp = 1 ; left = i ; while ( left - 1 >= 0 && Math . abs ( arr [ left ] - arr [ left - 1 ] ) <= K ) { left -- ; tmp ++ ; } right = i ; while ( right + 1 <= n - 1 && Math . abs ( arr [ right ] - arr [ right + 1 ] ) <= K ) { right ++ ; tmp ++ ; } if ( min > tmp ) min = tmp ; if ( max < tmp ) max = tmp ; } System . out . print ( min ) ; System . out . print ( ", " ) ; System . out . print ( max ) ; }
int countElement ( int arr [ ] , int n ) { int freq [ ] = new int [ n + 1 ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { int tmpsum = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { tmpsum += arr [ j ] ; if ( tmpsum <= n ) { ans += freq [ tmpsum ] ; freq [ tmpsum ] = 0 ; } } } return ans ; }
void first_digit ( int x , int y ) { int length = ( int ) ( Math . log ( x ) / Math . log ( y ) + 1 ) ; int first_digit = ( int ) ( x / Math . pow ( y , length - 1 ) ) ; System . out . println ( first_digit ) ; }
double kthRoot ( double n , int k ) { return Math . pow ( k , ( ( 1.0 / k ) * ( Math . log ( n ) / Math . log ( k ) ) ) ) ; }
void checksum ( int n , int k ) { float first_term = ( float ) ( ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 ) ; if ( first_term - ( int ) ( first_term ) == 0 ) { for ( int i = ( int ) first_term ; i <= first_term + k - 1 ; i ++ ) { System . out . print ( i + " " ) ; } } else System . out . print ( "-1" ) ; }
void distributeN ( int A , int B , int C , int n ) { int max1 = Math . max ( A , B ) ; int max2 = Math . max ( B , C ) ; int maximum = Math . max ( max1 , max2 ) ; int sum = A + B + C ; int p = ( 3 * maximum ) - sum ; int diff = n - p ; if ( diff < 0 diff % 3 == 0 ) System . out . print ( "No" ) ; else System . out . print ( "Yes" ) ; }
int minimumSteps ( int a , int b , int c ) { if ( a < 1 b < 1 ) return - 1 ; if ( a == 1 && b == 1 ) return c ; if ( a < b ) { a = a + b ; b = a - b ; a = a - b ; } return minimumSteps ( a - b , b , c + 1 ) ; }
int count_pairs ( int x ) { int ans = 1 ; while ( x > 0 ) { if ( x % 2 == 1 ) ans = ans * 3 ; x = x / 2 ; } return ans ; }
boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
int countSquares ( int n ) { int cnt = 0 ; for ( int i = ( int ) Math . pow ( 10 , ( n - 1 ) ) ; i < Math . pow ( 10 , n ) ; i ++ ) { if ( i != 0 && isPerfectSquare ( i ) ) cnt ++ ; } return cnt ; }
int countSquares ( int n ) { int r = ( int ) Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) ; int l = ( int ) Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) ; return r - l ; }
int summation ( int N ) { int co = ( N + 1 ) / 2 ; int ce = ( N ) / 2 ; int se = 2 * ( ( ce * ( ce + 1 ) ) * ( ce * ( ce + 1 ) ) ) ; int so = ( co * co ) * ( 2 * ( ( co * co ) ) - 1 ) ; return so - se ; }
boolean isStar ( int N ) { double n = ( 6 + Math . sqrt ( 24 * N + 12 ) ) / 6 ; return ( n - ( int ) n ) == 0 ; }
void sumEvenNumbers ( int N , int K ) { int check = N - 2 * ( K - 1 ) ; if ( check > 0 && check % 2 == 0 ) { for ( int i = 0 ; i < K - 1 ; i ++ ) { System . out . print ( "2 " ) ; } System . out . println ( check ) ; } else { System . out . println ( "-1" ) ; } }
int findMinDivisor ( int arr [ ] , int n , int limit ) { int low = 0 , high = 1000000000 ; while ( low < high ) { int mid = ( low + high ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += Math . ceil ( ( double ) arr [ i ] / ( double ) mid ) ; } if ( sum <= limit ) high = mid ; else low = mid + 1 ; } return low ; }
int getCount ( int arr [ ] , int n ) { int count = 0 ; for ( int j = 1 ; j < n - 1 ; j ++ ) { int p = 0 , q = 0 ; for ( int i = 0 ; i < j ; i ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) p ++ ; } for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ k ] % arr [ j ] == 0 ) q ++ ; } count += p * q ; } return count ; }
float computeMaxValue ( float arr [ ] , int n ) { float ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { float val = Math . max ( arr [ i ] / arr [ j ] , arr [ j ] / arr [ i ] ) ; ans = Math . max ( ans , val ) ; } } return ans ; }
void kthNonDivisible ( int N , int K ) { int L = 1 ; int H = Integer . MAX_VALUE ; int ans = 0 ; while ( L <= H ) { int mid = ( L + H ) / 2 ; int sol = mid - mid / N ; if ( sol > K ) { H = mid - 1 ; } else if ( sol < K ) { L = mid + 1 ; } else { ans = mid ; H = mid - 1 ; } } System . out . print ( ans ) ; }
int kthNonDivisible ( int N , int K ) { return ( int ) ( K + Math . floor ( ( K - 1 ) / ( N - 1 ) ) ) ; }
boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
void checkSunnyNumber ( int N ) { if ( isPerfectSquare ( N + 1 ) ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } }
void findPairEvenParity ( int arr [ ] , int len ) { int firstMaximum = Integer . MIN_VALUE ; int secondMaximum = Integer . MIN_VALUE ; for ( int i = 0 ; i < len ; i ++ ) { if ( isEvenParity ( arr [ i ] ) ) { if ( arr [ i ] >= firstMaximum ) { secondMaximum = firstMaximum ; firstMaximum = arr [ i ] ; } else if ( arr [ i ] >= secondMaximum ) { secondMaximum = arr [ i ] ; } } } System . out . print ( firstMaximum + " " + secondMaximum ) ; }
boolean isHexagonal ( int N ) { float val = 8 * N + 1 ; float x = 1 + ( float ) Math . sqrt ( val ) ; float n = ( x ) / 4 ; if ( ( n - ( int ) n ) == 0 ) return true ; else return false ; }
void NumbertoCharacter ( int n ) { int rev = 0 , r = 0 ; while ( n > 0 ) { r = n % 10 ; rev = rev * 10 + r ; n = n / 10 ; } while ( rev > 0 ) { r = rev % 10 ; switch ( r ) { case 1 : System . out . print ( "one " ) ; break ; case 2 : System . out . print ( "two " ) ; break ; case 3 : System . out . print ( "three " ) ; break ; case 4 : System . out . print ( "four " ) ; break ; case 5 : System . out . print ( "five " ) ; break ; case 6 : System . out . print ( "six " ) ; break ; case 7 : System . out . print ( "seven " ) ; break ; case 8 : System . out . print ( "eight " ) ; break ; case 9 : System . out . print ( "nine " ) ; break ; case 0 : System . out . print ( "zero " ) ; break ; default : System . out . print ( "UnValid " ) ; break ; } rev = rev / 10 ; } }
int Solve ( int arr [ ] , int n ) { int temp = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; if ( ( temp + 2 ) % 4 != 0 ) count ++ ; } } return count ; }
void nCr ( int n , long p , int f [ ] [ ] ) { for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( j > i ) f [ i ] [ j ] = 0 ; else if ( j == 0 j == i ) f [ i ] [ j ] = 1 ; else f [ i ] [ j ] = ( f [ i - 1 ] [ j ] + f [ i - 1 ] [ j - 1 ] ) % ( int ) p ; } } }
boolean prodSquare ( int n ) { for ( long i = 2 ; i * i <= n ; i ++ ) for ( long j = 2 ; j <= n ; j ++ ) if ( i * i * j * j == n ) return true ; return false ; }
boolean prodSquare ( int n ) { HashMap < Float , Float > s = new HashMap < Float , Float > ( ) ; for ( int i = 2 ; i * i <= n ; ++ i ) { s . put ( ( float ) ( i * i ) , ( float ) 1 ) ; if ( s . containsKey ( ( float ) n / ( i * i ) ) ) return true ; } return false ; }
void printPair ( int n ) { System . out . print ( 1 + " " + ( n - 1 ) ) ; }
boolean isAutoBiographyNum ( int number ) { int count = 0 , position , size , digit ; String NUM ; NUM = Integer . toString ( number ) ; size = NUM . length ( ) ; for ( int i = 0 ; i < size ; i ++ ) { position = NUM . charAt ( i ) - '0' ; count = 0 ; for ( int j = 0 ; j < size ; j ++ ) { digit = NUM . charAt ( j ) - '0' ; if ( digit == i ) count ++ ; } if ( position != count ) return false ; } return true ; }
int checkArray ( int arr [ ] , int n ) { int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isAutoBiographyNum ( arr [ i ] ) == true ) { current_length ++ ; } else { current_length = 0 ; } max_length = Math . max ( max_length , current_length ) ; } return max_length ; }
int GetSum ( int n ) { Vector < Integer > divisors = new Vector < Integer > ( ) ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { divisors . add ( i ) ; if ( i != n / i ) { divisors . add ( n / i ) ; } } } int ans = 1 ; for ( int i = 0 ; i < divisors . size ( ) ; i ++ ) { ans *= ( divisors . get ( i ) + 1 ) ; } ans = ans - 1 ; return ans ; }
int [ ] calculateWays ( int n ) { int x = 0 ; int [ ] v = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) v [ i ] = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { if ( n % 2 == 0 && i == n / 2 ) break ; x = n * ( i + 1 ) - ( i + 1 ) * i ; v [ i ] = x ; v [ n - i - 1 ] = x ; } return v ; }
boolean isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= Math . sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; }
int longestPowerfulSubsequence ( int arr [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerful ( arr [ i ] ) ) answer ++ ; } return answer ; }
int maxOR ( int arr [ ] , int n ) { int max_value = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int number_of_bits = ( int ) ( ( Math . log ( max_value ) ) ) + 2 ; int complement = ( ( 1 << number_of_bits ) - 1 ) ^ max_value ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != max_value ) { c = Math . max ( c , ( complement & arr [ i ] ) ) ; } } return ( max_value + c ) ; }
void update ( int res [ ] , int L , int R , int K ) { L -= 1 ; R -= 1 ; res [ L ] ^= K ; res [ R + 1 ] ^= K ; }
boolean check ( int a [ ] , int n , int k ) { Map < Integer , Integer > m = new HashMap < > ( ) ; int extra = 0 ; for ( int i = k ; i < n ; i ++ ) m . put ( a [ i ] , m . getOrDefault ( a [ i ] , 0 ) + 1 ) ; for ( Integer x : m . values ( ) ) extra += x - 1 ; if ( extra == 0 ) return true ; for ( int i = 1 ; i + k - 1 < n ; i ++ ) { if ( m . get ( a [ i + k - 1 ] ) > 1 ) extra -- ; m . put ( a [ i + k - 1 ] , m . get ( a [ i + k - 1 ] ) - 1 ) ; m . put ( a [ i - 1 ] , m . get ( a [ i - 1 ] ) + 1 ) ; if ( m . get ( a [ i - 1 ] ) > 1 ) extra ++ ; if ( extra == 0 ) return true ; } return false ; }
int minlength ( int a [ ] , int n ) { int lo = 0 , hi = n + 1 ; int ans = 0 ; while ( lo < hi ) { int mid = ( lo + hi ) / 2 ; if ( check ( a , n , mid ) ) { ans = mid ; hi = mid ; } else lo = mid + 1 ; } return ans ; }
void SieveOfEratosthenes ( ) { int i , j ; Prime [ 0 ] = Prime [ 1 ] = false ; for ( i = 2 ; i * i <= MAX ; i ++ ) { if ( Prime [ i ] ) { for ( j = 2 * i ; j < MAX ; j += i ) { Prime [ j ] = false ; } } } }
void dfs ( int node , int parent , int h ) { height [ node ] = h ; for ( int to : graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node , h + 1 ) ; } }
void primeHeightNode ( int N ) { SieveOfEratosthenes ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( Prime [ height [ i ] ] ) { System . out . print ( i + " " ) ; } } }
int sumOfDigits ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += n % 10 ; n /= 10 ; } return sum ; }
int smallestNum ( int X , int Y ) { int res = - 1 ; for ( int i = X ; i < MAXN ; i ++ ) { int sum_of_digit = sumOfDigits ( i ) ; if ( sum_of_digit % Y == 0 ) { res = i ; break ; } } return res ; }
int calculateBill ( int units ) { if ( units <= 100 ) { return units * 10 ; } else if ( units <= 200 ) { return ( 100 * 10 ) + ( units - 100 ) * 15 ; } else if ( units <= 300 ) { return ( 100 * 10 ) + ( 100 * 15 ) + ( units - 200 ) * 20 ; } else if ( units > 300 ) { return ( 100 * 10 ) + ( 100 * 15 ) + ( 100 * 20 ) + ( units - 300 ) * 25 ; } return 0 ; }
int countValues ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int k = n ; while ( k >= i ) { if ( k % i == 0 ) k /= i ; else k -= i ; } if ( k == 1 ) answer ++ ; } return answer ; }
int countValues ( int N ) { Vector < Integer > div = new Vector < > ( ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { div . add ( i ) ; if ( N != i * i ) { div . add ( N / i ) ; } } } int answer = 0 ; for ( int i = 1 ; i * i <= N - 1 ; i ++ ) { if ( ( N - 1 ) % i == 0 ) { if ( i * i == N - 1 ) answer ++ ; else answer += 2 ; } } for ( int d : div ) { int K = N ; while ( K % d == 0 ) K /= d ; if ( ( K - 1 ) % d == 0 ) answer ++ ; } return answer ; }
int reverse ( int a ) { int rev = 0 ; while ( a != 0 ) { int r = a % 10 ; rev = rev * 10 + r ; a = a / 10 ; } return ( rev ) ; }
int prime ( int a ) { int k = 0 ; for ( int i = 2 ; i < a ; i ++ ) { if ( a % i == 0 ) { k = 1 ; break ; } } if ( k == 1 ) { return ( 0 ) ; } else { return ( 1 ) ; } }
int adam ( int a ) { int r1 = reverse ( a ) ; int s1 = a * a ; int s2 = r1 * r1 ; int r2 = reverse ( s2 ) ; if ( s1 == r2 ) { return ( 1 ) ; } else { return ( 0 ) ; } }
void sieve ( ) { for ( int i = 1 ; i <= MAX ; ++ i ) { for ( int j = i ; j <= MAX ; j += i ) divisor [ j ] . add ( i ) ; } }
int countPrimeFactors ( int n ) { if ( n == 1 ) return 0 ; int cnt = 0 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { cnt ++ ; n = n / i ; } } if ( n > 2 ) cnt ++ ; return cnt ; }
int isComposite ( int n ) { if ( n <= 1 ) return 0 ; if ( n <= 3 ) return 0 ; if ( n % 2 == 0 n % 3 == 0 ) return n ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return n ; return 0 ; }
void preCompute ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isComposite ( i ) ; } }
int countPalindromic ( int n ) { int count ; if ( n % 2 == 1 ) { count = ( int ) Math . pow ( 9 , ( n - 1 ) / 2 ) ; } else { count = ( int ) Math . pow ( 9 , ( n - 2 ) / 2 ) ; } return count ; }
int countSubArrayWithOddProduct ( int A [ ] , int N ) { int count = 0 ; int last = - 1 ; int K = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) { K = ( i - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; last = i ; } } K = ( N - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; return count ; }
double CgpaCalc ( double [ ] marks , int n ) { double grade [ ] = new double [ n ] ; double cgpa , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { grade [ i ] = ( marks [ i ] / 10 ) ; } for ( int i = 0 ; i < n ; i ++ ) { sum += grade [ i ] ; } cgpa = sum / n ; return cgpa ; }
void printMaxPair ( int arr [ ] , int n ) { int largest = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { int number = Integer . parseInt ( getNumber ( arr [ i ] , arr [ j ] ) ) ; largest = Math . max ( largest , number ) ; } System . out . println ( largest ) ; }
void printKNumbers ( int N , int K ) { for ( int i = 0 ; i < K - 1 ; i ++ ) System . out . print ( 1 + " " ) ; System . out . print ( N - K + 1 ) ; }
int minNum ( int n , int k ) { int x = ( int ) ( Math . log ( n ) / Math . log ( k ) ) + 1 ; int mn = ( int ) ( Math . pow ( k , x ) - n ) ; return mn ; }
int previousPerfectCube ( int N ) { int prevN = ( int ) Math . floor ( Math . cbrt ( N ) ) ; if ( prevN * prevN * prevN == N ) prevN -= 1 ; return prevN * prevN * prevN ; }
int findCount ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] % 2 == 0 ) && ( arr [ j ] % 2 == 1 ) ) { res ++ ; } return res ; }
int findCount ( int arr [ ] , int n ) { int count = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { count ++ ; } else { ans = ans + count ; } } return ans ; }
int sumDig ( int n ) { int s = 0 ; while ( n != 0 ) { s = s + ( n % 10 ) ; n = n / 10 ; } return s ; }
boolean Pec ( int n ) { int dup = n ; int dig = sumDig ( n ) ; if ( dig * 3 == dup ) return true ; else return false ; }
int power ( int a , int b ) { if ( b == 0 ) return 1 ; int temp = power ( a , b / 2 ) ; temp = ( temp * temp ) % MOD ; if ( b % 2 != 0 ) { temp = ( temp * a ) % MOD ; } return temp ; }
int joinNumbers ( int numA , int numB ) { int revB = 0 ; while ( numB > 0 ) { revB = revB * 10 + ( numB % 10 ) ; numB = numB / 10 ; } while ( revB > 0 ) { numA = numA * 10 + ( revB % 10 ) ; revB = revB / 10 ; } return numA ; }
int reverse ( int n ) { int r = 0 ; while ( n != 0 ) { r = r * 10 ; r = r + n % 10 ; n = n / 10 ; } return ( r ) ; }
void operation ( int n ) { int i = 1 , a , count = 0 , r ; while ( count < n ) { a = digit_sum ( i ) ; r = reverse ( i ) ; if ( i % a == 0 && r % a == 0 ) { System . out . print ( i + " " ) ; count ++ ; i ++ ; } else i ++ ; } }
int calcCount ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( k % arr [ i ] == 0 ) count ++ ; } return count ; }
boolean isPerfect ( int n ) { int sum = 1 ; int i ; for ( i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
int contiguousPerfectNumber ( int arr [ ] , int n ) { int current_length = 0 ; int max_length = 0 ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( isPerfect ( arr [ i ] ) ) current_length ++ ; else current_length = 0 ; max_length = Math . max ( max_length , current_length ) ; } return max_length ; }
boolean isPerfect ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
boolean isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= Math . sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; }
void dfs ( int node , int parent ) { if ( isPowerful ( weight [ node ] ) ) ans += 1 ; for ( int to : graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; } }
boolean isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= Math . sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; }
int contiguousPowerfulNumber ( int [ ] arr , int n ) { int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerful ( arr [ i ] ) ) current_length ++ ; else current_length = 0 ; max_length = Math . max ( max_length , current_length ) ; } return max_length ; }
int maxSum ( int arr [ ] , int K , int start , int end , int max_sum ) { if ( K == 0 ) return max_sum ; int max_sum_start = max_sum + arr [ start ] ; int max_sum_end = max_sum + arr [ end ] ; int ans = Math . max ( maxSum ( arr , K - 1 , start + 1 , end , max_sum_start ) , maxSum ( arr , K - 1 , start , end - 1 , max_sum_end ) ) ; return ans ; }
void maximizeSum ( int arr [ ] , int K , int n ) { int max_sum = 0 ; int start = 0 ; int end = n - 1 ; System . out . print ( maxSum ( arr , K , start , end , max_sum ) ) ; }
int maxPointCount ( int arr [ ] , int K , int size ) { int curr_points = 0 ; int max_points = 0 ; for ( int i = 0 ; i < K ; i ++ ) curr_points += arr [ i ] ; max_points = curr_points ; int j = size - 1 ; for ( int i = K - 1 ; i >= 0 ; i -- ) { curr_points = curr_points + arr [ j ] - arr [ i ] ; max_points = Math . max ( curr_points , max_points ) ; j -- ; } return max_points ; }
int count ( int N , int B ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( B - 1 ) * Math . pow ( B , i - 1 ) ; } return sum ; }
int GetMinCost ( int N ) { PriorityQueue < Integer > pq ; pq = new PriorityQueue < > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { pq . add ( i ) ; } int cost = 0 ; while ( pq . size ( ) > 1 ) { int mini = pq . remove ( ) ; int secondmini = pq . remove ( ) ; int current = mini * secondmini ; cost += current ; pq . add ( current ) ; } return cost ; }
int CountWays ( int N , int M ) { int count = 1 ; count = ( int ) Math . pow ( 3 , M + N ) ; count *= ( int ) Math . pow ( 2 , M * N ) ; return count ; }
int minCost ( int arr [ ] , int n , int circumference ) { Arrays . sort ( arr ) ; int [ ] arr2 = new int [ 2 * n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr2 [ i ] = arr [ i ] ; arr2 [ i + n ] = arr [ i ] + circumference ; } int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) res = Math . min ( res , arr2 [ i + ( n - 1 ) ] - arr2 [ i ] ) ; return res ; }
int CountWays ( int n ) { int ans = ( n - 1 ) / 2 ; return ans ; }
void findUniqueElements ( int arr [ ] , int N , int K ) { Set < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) s . add ( arr [ i ] ) ; int arr_sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) arr_sum += arr [ i ] ; int set_sum = 0 ; Iterator it = s . iterator ( ) ; while ( it . hasNext ( ) ) { set_sum += ( int ) it . next ( ) ; } System . out . println ( ( K * set_sum - arr_sum ) / ( K - 1 ) ) ; }
int findunique ( int a [ ] , int k ) { int res = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { int p = 0 ; for ( int j = 0 ; j < a . length ; j ++ ) { p += ( Math . abs ( a [ j ] ) & ( 1 << i ) ) != 0 ? 1 : 0 ; } p %= k ; res += Math . pow ( 2 , i ) * p ; } int c = 0 ; for ( int x = 0 ; x < a . length ; x ++ ) if ( a [ x ] == res ) { c = 1 ; break ; } return c == 1 ? res : - res ; }
int stepRequired ( int N ) { int cnt = 0 ; while ( N > 0 ) { N = N & ( N - 1 ) ; cnt ++ ; } return cnt ; }
boolean isPerfectSquare ( int x ) { int s = ( int ) Math . sqrt ( x ) ; return ( s * s == x ) ; }
boolean isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
void findEquation ( int a , int b , int c ) { int X = ( a + b + c ) ; int Y = ( a * b ) + ( b * c ) + ( c * a ) ; int Z = a * b * c ; System . out . print ( "x^3 - " + X + "x^2 + " + Y + "x - " + Z + " = 0" ) ; }
double dydx ( double x , double y ) { return ( x - y ) / 2 ; }
int numPrimeArrangements ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( prime [ i ] ) for ( int factor = 2 ; factor * i <= n ; factor ++ ) prime [ factor * i ] = false ; } int primeIndices = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( prime [ i ] ) primeIndices ++ ; int mod = ( int ) ( 1e9 + 7 ) , res = 1 ; for ( int i = 1 ; i <= primeIndices ; i ++ ) res = ( int ) ( ( 1L * res * i ) % mod ) ; for ( int i = 1 ; i <= ( n - primeIndices ) ; i ++ ) res = ( int ) ( ( 1L * res * i ) % mod ) ; return res ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
double count_heads ( int n , int r ) { double output ; output = fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; output = output / ( Math . pow ( 2 , n ) ) ; return output ; }
void PrintReverseOrder ( int N ) { if ( N <= 0 ) { return ; } else { System . out . print ( N + " " ) ; PrintReverseOrder ( N - 1 ) ; } }
int findAns ( int a , int b , int n ) { int lcm = ( a * b ) / __gcd ( a , b ) ; int multiples = ( n / lcm ) + 1 ; int answer = Math . max ( a , b ) * multiples ; int lastvalue = lcm * ( n / lcm ) + Math . max ( a , b ) ; if ( lastvalue > n ) answer = answer - ( lastvalue - n - 1 ) ; return answer ; }
int modInverse ( int n , int p ) { return power ( n , p - 2 , p ) ; }
int nCrModPFermat ( int n , int r , int p ) { if ( r == 0 ) return 1 ; if ( n < r ) return 0 ; int fac [ ] = new int [ n + 1 ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p ; }
int SumOfXor ( int a [ ] , int n ) { int mod = 10037 ; int answer = 0 ; for ( int k = 0 ; k < 32 ; k ++ ) { int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] & ( 1 << k ) ) != 0 ) x ++ ; else y ++ ; } answer += ( ( 1 << k ) % mod * ( nCrModPFermat ( x , 3 , mod ) + x * nCrModPFermat ( y , 2 , mod ) ) % mod ) % mod ; } return answer ; }
void movesRequired ( int a , int b ) { int total_moves = a % b ; System . out . println ( total_moves ) ; }
double Volume_of_cone ( double R ) { double V = ( double ) ( ( 1 / 3.0 ) * ( 3.14 ) * ( 2 * ( R * R ) ) * ( 4 * R ) ) ; return V ; }
int maximumComponentSize ( int a [ ] , int n ) { @ SuppressWarnings ( "unchecked" ) Vector < Integer > [ ] adj = new Vector [ n ] ; for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( __gcd ( a [ i ] , a [ j ] ) > 1 ) adj [ i ] . add ( j ) ; adj [ j ] . add ( i ) ; } } int answer = 0 ; int [ ] vis = new int [ n ] ; for ( int k = 0 ; k < n ; k ++ ) { vis [ k ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] == 0 ) { answer = Math . max ( answer , dfs ( i , adj , vis ) ) ; } } return answer ; }
void sieve ( ) { for ( int i = 2 ; i < 100005 ; i ++ ) { if ( spf [ i ] == 0 ) { spf [ i ] = i ; for ( int j = 2 * i ; j < 100005 ; j += i ) { if ( spf [ j ] == 0 ) spf [ j ] = i ; } } } }
void factorize ( int n , HashSet < Integer > s ) { while ( n > 1 ) { int z = spf [ n ] ; s . add ( z ) ; while ( n % z == 0 ) n /= z ; } }
int root ( int i ) { if ( par [ i ] == i ) return i ; else return par [ i ] = root ( par [ i ] ) ; }
void merge ( int a , int b ) { int p = root ( a ) ; int q = root ( b ) ; if ( p == q ) return ; if ( sizeContainer [ p ] > sizeContainer [ q ] ) { p = p + q ; q = p - q ; p = p - q ; } par [ p ] = q ; sizeContainer [ q ] += sizeContainer [ p ] ; }
int maximumComponentsizeContainer ( int a [ ] , int n ) { for ( int i = 0 ; i < 100005 ; i ++ ) { par [ i ] = i ; sizeContainer [ i ] = 1 ; } sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; factorize ( a [ i ] , s ) ; for ( int it : s ) { if ( id [ it ] == 0 ) id [ it ] = i + 1 ; else merge ( i + 1 , id [ it ] ) ; } } int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) answer = Math . max ( answer , sizeContainer [ i ] ) ; return answer ; }
boolean check ( int X , int K ) { int prime , temp , sqr , i ; prime = 0 ; temp = X ; sqr = ( int ) Math . sqrt ( X ) ; for ( i = 2 ; i <= sqr ; i ++ ) { while ( temp % i == 0 ) { temp = temp / i ; prime ++ ; } } if ( temp > 2 ) prime ++ ; if ( X == 1 ) return false ; if ( prime == 1 && K == 1 ) return true ; else if ( prime >= K ) return true ; else return false ; }
void precompute ( ) { phi [ 1 ] = 0 ; for ( int i = 2 ; i < N ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p < N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i < N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int maxAlternatingSum ( int [ ] arr , int n ) { int max_sum = 0 ; int i = 0 ; while ( i < n ) { int current_max = arr [ i ] ; int k = i ; while ( k < n && ( ( arr [ i ] > 0 && arr [ k ] > 0 ) || ( arr [ i ] < 0 && arr [ k ] < 0 ) ) ) { current_max = Math . max ( current_max , arr [ k ] ) ; k += 1 ; } max_sum += current_max ; i = k ; } return max_sum ; }
int subarrayLength ( int A [ ] , int R [ ] [ ] , int N , int M ) { for ( int i = 0 ; i < M ; ++ i ) { int l = R [ i ] [ 0 ] , r = R [ i ] [ 1 ] + 1 ; l -- ; r -- ; A [ l ] ++ ; if ( r < N ) A [ r ] -- ; } for ( int i = 1 ; i < N ; ++ i ) { A [ i ] += A [ i - 1 ] ; } int count = 0 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { if ( ! s . contains ( A [ i ] ) ) count ++ ; s . add ( A [ i ] ) ; } int [ ] repeat = new int [ count + 1 ] ; int ans = N ; int counter = 0 , left = 0 , right = 0 ; while ( right < N ) { int cur_element = A [ right ] ; repeat [ cur_element ] += 1 ; if ( repeat [ cur_element ] == 1 ) ++ counter ; while ( counter == count ) { ans = Math . min ( ans , right - left + 1 ) ; cur_element = A [ left ] ; repeat [ cur_element ] -= 1 ; ++ left ; if ( repeat [ cur_element ] == 0 ) -- counter ; } ++ right ; } return ans ; }
void ModifiedSieveOfEratosthenes ( int N , boolean Expo_Prime [ ] ) { boolean [ ] primes = new boolean [ N ] ; Arrays . fill ( primes , true ) ; for ( int i = 2 ; i < N ; i ++ ) { if ( primes [ i ] ) { int no = i ; while ( no <= N ) { Expo_Prime [ no ] = true ; no *= i ; } for ( int j = i * i ; j < N ; j += i ) primes [ j ] = false ; } } }
void FindExpoPrime ( int arr [ ] , int n ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) max = arr [ i ] ; } boolean [ ] Expo_Prime = new boolean [ max + 1 ] ; ModifiedSieveOfEratosthenes ( max + 1 , Expo_Prime ) ; Display ( arr , Expo_Prime , n ) ; }
double nthRoot ( long A , long N ) { double xPre = 7 ; double eps = 1e-3 ; double delX = Integer . MAX_VALUE ; double xK = 0 ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + ( double ) A / Math . pow ( xPre , N - 1 ) ) / ( double ) N ; delX = Math . abs ( xK - xPre ) ; xPre = xK ; } return xK ; }
boolean check ( long no , int k ) { double kth_root = nthRoot ( no , k ) ; long num = ( long ) kth_root ; if ( Math . abs ( num - kth_root ) < 1e-4 ) return true ; return false ; }
void printExpo ( long arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( check ( arr [ i ] , k ) ) System . out . print ( arr [ i ] + " " ) ; } }
void SieveOfEratosthenes ( ) { boolean [ ] check = new boolean [ N + 1 ] ; Arrays . fill ( check , true ) ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( check [ p ] == true ) { prime . add ( p ) ; for ( int i = p * p ; i <= N ; i += p ) check [ i ] = false ; } } }
boolean isPathCo_Prime ( Vector < Integer > path ) { int max = 0 ; for ( int x : path ) { if ( max < x ) max = x ; } for ( int i = 0 ; i * prime . get ( i ) <= max / 2 ; i ++ ) { int ct = 0 ; for ( int x : path ) { if ( x % prime . get ( i ) == 0 ) ct ++ ; } if ( ct > 1 ) { return false ; } } return true ; }
int CntcontSubs ( int a [ ] , int n ) { int c = 0 , d = 0 , i , sum = 1 , j ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 != 0 a [ i ] % 4 == 0 ) d ++ ; sum = a [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { sum = sum * a [ j ] ; if ( sum % 2 != 0 sum % 4 == 0 ) c ++ ; } sum = 1 ; } return c + d ; }
int CntcontSubs ( int a [ ] , int n ) { int prod = 1 ; Vector < pair > vect = new Vector < pair > ( ) ; vect . add ( new pair ( 0 , 2 ) ) ; Vector < Integer > two = new Vector < Integer > ( ) ; Vector < Integer > zero = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = a [ i ] % 4 ; if ( a [ i ] < 0 ) a [ i ] = a [ i ] + 4 ; if ( a [ i ] == 2 ) two . add ( i + 1 ) ; if ( a [ i ] == 0 ) zero . add ( i + 1 ) ; if ( a [ i ] == 0 a [ i ] == 2 ) vect . add ( new pair ( i + 1 , a [ i ] ) ) ; } vect . add ( new pair ( n + 1 , 2 ) ) ; int total = ( n * ( n + 1 ) ) / 2 ; if ( two . isEmpty ( ) ) return total ; else { int sum = 0 ; int pos1 = - 1 , pos2 = - 1 , pos3 = - 1 ; int sz = vect . size ( ) ; for ( int i = 1 ; i + 1 < sz ; i ++ ) { if ( vect . get ( i ) . second == 2 ) { sum += ( vect . get ( i ) . first - vect . get ( i - 1 ) . first ) * ( vect . get ( i + 1 ) . first - vect . get ( i ) . first ) - 1 ; } } return total - sum - two . size ( ) ; } }
int countSubarray ( int n ) { return ( ( n ) * ( n + 1 ) ) / 2 ; }
int countSubsequence ( int n ) { return ( int ) Math . pow ( 2 , n ) ; }
float y ( float x ) { return ( 1 / ( 1 + x ) ) ; }
float BooleRule ( float a , float b ) { int n = 4 ; int h ; h = ( int ) ( ( b - a ) / n ) ; float sum = 0 ; float bl = ( 7 * y ( a ) + 32 * y ( a + h ) + 12 * y ( a + 2 * h ) + 32 * y ( a + 3 * h ) + 7 * y ( a + 4 * h ) ) * 2 * h / 45 ; sum = sum + bl ; return sum ; }
int countSubsets ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int bitwiseAND = - 1 ; int bitwiseOR = 0 ; int bitwiseXOR = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) == 0 ) { if ( bitwiseAND == - 1 ) bitwiseAND = a [ j ] ; else bitwiseAND &= a [ j ] ; bitwiseOR |= a [ j ] ; bitwiseXOR ^= a [ j ] ; } } if ( bitwiseAND == bitwiseOR && bitwiseOR == bitwiseXOR ) answer = ( answer + 1 ) % mod ; } return answer ; }
int countSubsets ( int a [ ] , int n ) { int answer = 0 ; int [ ] powerOfTwo = new int [ 100005 ] ; powerOfTwo [ 0 ] = 1 ; for ( int i = 1 ; i < 100005 ; i ++ ) powerOfTwo [ i ] = ( powerOfTwo [ i - 1 ] * 2 ) % mod ; HashMap < Integer , Integer > frequency = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( frequency . containsKey ( a [ i ] ) ) { frequency . put ( a [ i ] , frequency . get ( a [ i ] ) + 1 ) ; } else { frequency . put ( a [ i ] , 1 ) ; } for ( Map . Entry < Integer , Integer > el : frequency . entrySet ( ) ) { if ( el . getKey ( ) != 0 ) answer = ( answer % mod + powerOfTwo [ el . getValue ( ) - 1 ] ) % mod ; else answer = ( answer % mod + powerOfTwo [ el . getValue ( ) ] - 1 + mod ) % mod ; } return answer ; }
int count ( int arr [ ] , int N , int K ) { int count = 0 , ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) { count = count + 1 ; } else { ans += ( count * ( count + 1 ) ) / 2 ; count = 0 ; } } ans = ans + ( count * ( count + 1 ) ) / 2 ; return ans ; }
void precomputation ( ) { for ( int i = 1 ; i < 10000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isPerfect ( i ) ; } }
void convertToTernary ( int N ) { if ( N == 0 ) return ; int x = N % 3 ; N /= 3 ; if ( x < 0 ) N += 1 ; convertToTernary ( N ) ; if ( x < 0 ) System . out . print ( x + ( 3 * - 1 ) ) ; else System . out . print ( x ) ; }
boolean isPerfectSquare ( int N ) { double sr = Math . sqrt ( N ) ; return ( sr - Math . floor ( sr ) ) == 0 ; }
int EulerTotientFunction ( int limit ) { int copy = limit ; Vector < Integer > primes = new Vector < Integer > ( ) ; for ( int i = 2 ; i * i <= limit ; i ++ ) { if ( limit % i == 0 ) { while ( limit % i == 0 ) { limit /= i ; } primes . add ( i ) ; } } if ( limit >= 2 ) { primes . add ( limit ) ; } int ans = copy ; for ( int it : primes ) { ans = ( ans / it ) * ( it - 1 ) ; } return ans ; }
long product ( int [ ] [ ] mat , int n ) { long d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += mat [ i ] [ i ] ; d2 += mat [ i ] [ n - i - 1 ] ; } return 1L * d1 * d2 ; }
float getPercentile ( int rank , int students ) { float result = ( float ) ( students - rank ) / students * 100 ; return result ; }
int fib ( int n ) { double phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return ( int ) Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; }
int calculateSum ( int l , int r ) { int sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; }
int sumFibonacci ( int k ) { int l = ( k * ( k - 1 ) ) / 2 ; int r = l + k ; int sum = calculateSum ( l , r - 1 ) ; return sum ; }
int NthSmallest ( int K ) { Queue < Integer > Q = new LinkedList < > ( ) ; int x = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) Q . add ( i ) ; for ( int i = 1 ; i <= K ; i ++ ) { x = Q . peek ( ) ; Q . remove ( ) ; if ( x % 10 != 0 ) { Q . add ( x * 10 + x % 10 - 1 ) ; } Q . add ( x * 10 + x % 10 ) ; if ( x % 10 != 9 ) { Q . add ( x * 10 + x % 10 + 1 ) ; } } return x ; }
void sumOfPrevK ( int N , int K ) { int arr [ ] = new int [ N ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { int j = i - 1 , count = 0 , sum = 0 ; while ( j >= 0 && count < K ) { sum += arr [ j ] ; j -- ; count ++ ; } arr [ i ] = sum ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; }
int findSum ( int [ ] arr , int n , int left , int right ) { int k = right - left ; int d = arr [ 1 ] - arr [ 0 ] ; int ans = arr [ left - 1 ] * ( k + 1 ) ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; return ans ; }
int get ( int x , int y , int z ) { if ( x > z ) return - 1 ; int val = z - x ; int div = ( z - x ) / y ; int ans = div * y + x ; return ans ; }
boolean subarrayPossible ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum <= 0 ) return true ; } sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { sum += arr [ i ] ; if ( sum <= 0 ) return true ; } return false ; }
int probability ( int N ) { int a = 2 ; int b = 3 ; if ( N == 1 ) { return a ; } else if ( N == 2 ) { return b ; } else { for ( int i = 3 ; i <= N ; i ++ ) { int c = a + b ; a = b ; b = c ; } return b ; } }
float y ( float x ) { float num = 1 ; float denom = ( float ) 1.0 + x * x ; return num / denom ; }
float WeedleRule ( float a , float b ) { float h = ( b - a ) / 6 ; float sum = 0 ; sum = sum + ( ( ( 3 * h ) / 10 ) * ( y ( a ) + y ( a + 2 * h ) + 5 * y ( a + h ) + 6 * y ( a + 3 * h ) + y ( a + 4 * h ) + 5 * y ( a + 5 * h ) + y ( a + 6 * h ) ) ) ; return sum ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int findSmallest ( int N ) { if ( N == 0 ) return 2 ; if ( N == 1 ) return 1 ; int prime = N , counter = 0 ; boolean found = false ; while ( ! found ) { if ( isPrime ( prime ) ) found = true ; else { prime ++ ; counter ++ ; } } return counter ; }
double maxSubArraySum ( double a [ ] , int size ) { double max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int findRemainder ( int n ) { int x = n & 3 ; return x ; }
int reverse ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }
int countReverse ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( reverse ( arr [ i ] ) == arr [ j ] ) { res ++ ; } return res ; }
int reverse ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }
int countReverse ( int arr [ ] , int n ) { HashMap < Integer , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( freq . containsKey ( arr [ i ] ) ) { freq . replace ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . put ( arr [ i ] , 1 ) ; } } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . containsKey ( arr [ i ] ) ) { freq . replace ( arr [ i ] , freq . get ( arr [ i ] ) - 1 ) ; } else { freq . put ( arr [ i ] , - 1 ) ; } if ( freq . containsKey ( reverse ( arr [ i ] ) ) ) { res += freq . get ( reverse ( arr [ i ] ) ) ; } } return res ; }
int rangeSum ( int l , int r ) { int a = 1 , b = 9 , res = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int L = Math . max ( l , a ) ; int R = Math . min ( r , b ) ; if ( L <= R ) { int sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += Math . pow ( i , i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
int TrialDivision ( int N ) { int i = 2 ; int k = ( int ) Math . ceil ( Math . sqrt ( N ) ) ; while ( i <= k ) { if ( N % i == 0 ) return 0 ; i += 1 ; } return 1 ; }
void isPossible ( int [ ] A , int n , int k ) { int countOfTwo = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] % 2 == 0 ) { countOfTwo ++ ; } } if ( k == 0 && countOfTwo == n ) System . out . print ( "NO" ) ; else if ( countOfTwo >= k ) { System . out . print ( "YES" ) ; } else System . out . print ( "No" ) ; }
int countWays ( int A , int B , int C ) { int minAddA = Math . max ( 0 , ( C + B - A + 2 ) / 2 ) ; int count_ways = Math . max ( C - minAddA + 1 , 0 ) ; return count_ways ; }
void createHash ( HashSet < Integer > hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } }
void printSeries ( int N ) { int ith_term = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ith_term = i % 2 == 0 ? 2 * i * i + 1 : 2 * i * i - 1 ; System . out . print ( ith_term + ", " ) ; } }
void sieve ( int a , int b ) { prime [ 1 ] = 1 ; for ( int i = 2 ; i * i < size ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * 2 ; j < size ; j += i ) prime [ j ] = 1 ; } } for ( int p = 1 ; p < size ; p ++ ) { for ( int q = 1 ; q < size ; q ++ ) { if ( prime [ p ] == 0 && prime [ q ] == 0 && a * p + b * q < size ) { freq [ a * p + b * q ] ++ ; } } } }
void SieveOfEratosthenes ( ) { boolean [ ] check = new boolean [ N + 1 ] ; Arrays . fill ( check , true ) ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( check [ p ] == true ) { prime . add ( p ) ; for ( int i = p * p ; i <= N ; i += p ) check [ i ] = false ; } } }
void printSumSeries ( int N ) { float sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += 1.0 / ( 2 * i - 1 ) ; } System . out . println ( sum ) ; }
void printSeriesSum ( int N ) { double sum = 0 ; int a = 1 ; int cnt = 0 ; boolean flag = true ; sum += a ; while ( cnt < N ) { int nextElement ; if ( flag == true ) { nextElement = a * 2 ; sum += nextElement ; flag = ! flag ; } else { nextElement = a * 3 / 2 ; sum += nextElement ; flag = ! flag ; } a = nextElement ; cnt ++ ; } System . out . println ( sum ) ; }
void MinimumSwapOperations ( String s ) { boolean zero_exist = false ; boolean multiple_of_2 = false ; int sum = 0 ; int index_of_zero = 0 ; boolean more_zero = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int val = s . charAt ( i ) - '0' ; if ( zero_exist == true ) more_zero = true ; if ( val == 0 ) { zero_exist = true ; index_of_zero = i ; } sum += val ; } if ( zero_exist == false sum % 3 != 0 ) { System . out . println ( "-1" ) ; return ; } for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int val = s . charAt ( i ) - '0' ; if ( val % 2 == 0 && i != index_of_zero ) multiple_of_2 = true ; } if ( multiple_of_2 == false ) { System . out . println ( "-1" ) ; return ; } int last_val = s . charAt ( s . length ( ) - 1 ) - '0' ; int second_last_val = s . charAt ( s . length ( ) - 2 ) - '0' ; if ( last_val == 0 && second_last_val % 2 == 0 ) System . out . println ( 0 ) ; else if ( ( last_val == 0 && second_last_val % 2 != 0 ) || ( last_val % 2 == 0 && second_last_val == 0 ) ) System . out . println ( 1 ) ; else if ( more_zero == true && ( last_val == 0 && second_last_val % 2 != 0 ) ) System . out . println ( 1 ) ; else System . out . println ( 2 ) ; }
void sieve ( int n ) { for ( int i = 2 ; i < n ; ++ i ) { if ( min_prime [ i ] > 0 ) { continue ; } min_prime [ i ] = i ; max_prime [ i ] = i ; int j = i + i ; while ( j < n ) { if ( min_prime [ j ] == 0 ) { min_prime [ j ] = i ; } max_prime [ j ] = i ; j += i ; } } }
int findCost ( int A , int B , int C , int X ) { sieve ( MAX ) ; int N , M ; if ( X == 1 ) { return - 1 ; } int min_cost = C + X ; int cost_for_prime = A ; N = max_prime [ X ] ; if ( N != X ) { M = X / N ; cost_for_prime += M ; min_cost = Math . min ( min_cost , cost_for_prime ) ; } M = min_prime [ X ] ; N = X / M ; if ( N != min_prime [ N ] ) { int cost_for_comp = B + M ; min_cost = Math . min ( min_cost , cost_for_comp ) ; } return min_cost ; }
int minOperations ( int A , int B ) { if ( A > B ) { A = A + B ; B = A - B ; A = A - B ; } B = B / __gcd ( A , B ) ; return B - 1 ; }
void quadrant ( String s ) { int l = s . length ( ) ; int i ; if ( s . contains ( "+" ) ) { i = s . indexOf ( '+' ) ; } else { i = s . indexOf ( '-' ) ; } String real = s . substring ( 0 , i ) ; String imaginary = s . substring ( i + 1 , l - 1 ) ; int x = Integer . valueOf ( real ) ; int y = Integer . valueOf ( imaginary ) ; if ( x > 0 && y > 0 ) System . out . print ( "Quadrant 1" ) ; else if ( x < 0 && y > 0 ) System . out . print ( "Quadrant 2" ) ; else if ( x < 0 && y < 0 ) System . out . print ( "Quadrant 3" ) ; else if ( x > 0 && y < 0 ) System . out . print ( "Quadrant 4" ) ; else if ( x == 0 && y > 0 ) System . out . print ( "Lies on positive" + " Imaginary axis" ) ; else if ( x == 0 && y < 0 ) System . out . print ( "Lies on negative" + " Imaginary axis" ) ; else if ( y == 0 && x < 0 ) System . out . print ( "Lies on negative" + " X-axis" ) ; else if ( y == 0 && x > 0 ) System . out . print ( "Lies on positive" + " X-axis" ) ; else System . out . print ( "Lies on the Origin" ) ; }
int highestPower ( int n , int k ) { int i = 0 ; int a = ( int ) Math . pow ( n , i ) ; while ( a <= k ) { i += 1 ; a = ( int ) Math . pow ( n , i ) ; } return i - 1 ; }
int PowerArray ( int n , int k ) { while ( k > 0 ) { int t = highestPower ( n , k ) ; if ( b [ t ] > 0 ) { System . out . print ( - 1 ) ; return 0 ; } else b [ t ] = 1 ; k -= Math . pow ( n , t ) ; } for ( int i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] > 0 ) { System . out . print ( i + ", " ) ; } } return 0 ; }
int PowerArray ( int n , int k ) { int count = 0 ; while ( k > 0 ) { if ( k % n == 0 ) { k /= n ; count ++ ; } else if ( k % n == 1 ) { k -= 1 ; b [ count ] ++ ; if ( b [ count ] > 1 ) { System . out . print ( - 1 ) ; return 0 ; } } else { System . out . print ( - 1 ) ; return 0 ; } } for ( int i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] != 0 ) { System . out . print ( i + ", " ) ; } } return Integer . MIN_VALUE ; }
double countdigits ( int n , int k ) { if ( n == 0 ) return 0 ; int digit = n % 10 ; if ( digit == k ) return 1 + countdigits ( n / 10 , k ) ; return countdigits ( n / 10 , k ) ; }
int largestElement ( Node head_ref ) { int max = Integer . MIN_VALUE ; Node head = head_ref ; while ( head != null ) { if ( max < head . data ) max = head . data ; head = head . next ; } return max ; }
void createHash ( HashSet < Integer > hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } }
void printModulus ( int X , int Y ) { int n = Math . max ( X , Y ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( X % i == Y % i ) System . out . print ( i + " " ) ; } }
void printModulus ( int X , int Y ) { int d = Math . abs ( X - Y ) ; int i = 1 ; while ( i * i <= d ) { if ( d % i == 0 ) { System . out . print ( i + " " ) ; if ( d / i != i ) System . out . print ( d / i + " " ) ; } i ++ ; } }
boolean difSquare ( int n ) { if ( n % 4 != 2 ) { return true ; } return false ; }
int countFibonacciDivisors ( int n ) { HashSet < Integer > hash = new HashSet < Integer > ( ) ; createHash ( hash , n ) ; int cnt = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( ( n / i == i ) && ( hash . contains ( n / i ) ) ) cnt ++ ; else { if ( hash . contains ( n / i ) ) cnt ++ ; if ( hash . contains ( n / ( n / i ) ) ) cnt ++ ; } } } return cnt ; }
int findCount ( Node root , int K ) { res = 0 ; k = K ; rec ( root ) ; return res ; }
void makearrayequal ( int arr [ ] , int n ) { int x = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x += ( arr [ i ] & 1 ) ; } System . out . println ( Math . min ( x , n - x ) ) ; }
void SieveOfEratosthenes ( Vector < Boolean > composite ) { for ( int i = 0 ; i < N ; i ++ ) { composite . add ( i , false ) ; } for ( int p = 2 ; p * p < N ; p ++ ) { if ( ! composite . get ( p ) ) { for ( int i = p * 2 ; i < N ; i += p ) { composite . add ( i , true ) ; } } } }
int sumOfElements ( int arr [ ] , int n ) { Vector < Boolean > composite = new Vector < Boolean > ( ) ; for ( int i = 0 ; i < N ; i ++ ) composite . add ( false ) ; SieveOfEratosthenes ( composite ) ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } int sum = 0 ; for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) { if ( composite . get ( it . getValue ( ) ) ) { sum += ( it . getKey ( ) ) ; } } return sum ; }
int val ( char c ) { if ( c >= '0' && c <= '9' ) return ( int ) c - '0' ; else return ( int ) c - 'A' + 10 ; }
int toDeci ( String str , int base ) { int len = str . length ( ) ; int power = 1 ; int num = 0 ; int i ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str . charAt ( i ) ) >= base ) { System . out . println ( "Invalid Number" ) ; return - 1 ; } num += val ( str . charAt ( i ) ) * power ; power = power * base ; } return num ; }
boolean isEven ( String num , int N ) { int deci = toDeci ( num , N ) ; return ( deci % 2 == 0 ) ; }
int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d == 2 d == 3 d == 5 d == 7 ) count ++ ; } return count ; }
void remove ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ( mp . containsKey ( arr [ i ] ) && mp . get ( arr [ i ] ) % 2 == 1 ) ) continue ; System . out . print ( arr [ i ] + ", " ) ; } }
void SieveOfEratosthenes ( boolean prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
int longestPrimeSubsequence ( int arr [ ] , int n ) { boolean [ ] prime = new boolean [ N + 1 ] ; Arrays . fill ( prime , true ) ; SieveOfEratosthenes ( prime , N ) ; int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { answer ++ ; } } return answer ; }
void checkPalindrome ( int num ) { String str = Integer . toString ( num ) ; int l = 0 , r = str . length ( ) - 1 ; while ( l < r ) { if ( str . charAt ( l ) != str . charAt ( r ) ) { System . out . print ( "No" ) ; return ; } l ++ ; r -- ; } System . out . print ( "Yes" ) ; return ; }
double dydx ( double x , double y ) { return ( x + y - 2 ) ; }
double rungeKutta ( double x0 , double y0 , double x , double h ) { int n = ( int ) ( ( x - x0 ) / h ) ; double k1 , k2 ; double y = y0 ; for ( int i = 1 ; i <= n ; i ++ ) { k1 = h * dydx ( x0 , y ) ; k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) ; y = y + ( 1.0 / 6.0 ) * ( k1 + 2 * k2 ) ; x0 = x0 + h ; } return y ; }
boolean isPerfectSquare ( int x ) { int s = ( int ) Math . sqrt ( x ) ; return ( s * s == x ) ; }
int isFibonacci ( int n ) { if ( isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ) return 1 ; return 0 ; }
void compute ( int a , int b ) { for ( int i = 1 ; i < 100010 ; i ++ ) { fib [ i ] = isFibonacci ( i ) ; } for ( int x = 1 ; x < 100010 ; x ++ ) { for ( int y = 1 ; y < size ; y ++ ) { if ( fib [ x ] == 1 && fib [ y ] == 1 && a * x + b * y < 100010 ) { freq [ a * x + b * y ] ++ ; } } } }
void findMaxSum ( int n1 , int n2 ) { int [ ] arr1 = new int [ MAX ] ; int [ ] arr2 = new int [ MAX ] ; int l1 = 0 , l2 = 0 ; int max1 = Math . max ( n1 , n2 ) ; int min1 = Math . min ( n1 , n2 ) ; for ( int i = max1 ; i > 0 ; i /= 10 ) arr1 [ l1 ++ ] = ( i % 10 ) ; for ( int i = min1 ; i > 0 ; i /= 10 ) arr2 [ l2 ++ ] = ( i % 10 ) ; int f = 0 ; if ( l1 != l2 ) { int index = ( max_element ( arr2 , l2 ) ) ; for ( int i = l1 - 1 ; i > ( l2 - 1 ) ; i -- ) { if ( arr1 [ i ] < arr2 [ index ] ) { int tmp = arr1 [ i ] ; arr1 [ i ] = arr2 [ index ] ; arr2 [ index ] = tmp ; f = 1 ; break ; } } } if ( f != 1 ) { int index1 = 0 , index2 = 0 ; int diff1 = 0 , diff2 = 0 ; for ( int i = l2 - 1 ; i >= 0 ; i -- ) { index1 = ( max_element ( arr1 , i ) ) ; index2 = ( max_element ( arr2 , i ) ) ; diff1 = ( arr2 [ index2 ] - arr1 [ i ] ) ; diff2 = ( arr1 [ index1 ] - arr2 [ i ] ) ; if ( diff1 > 0 diff2 > 0 ) { if ( diff1 > diff2 ) { int tmp = arr1 [ i ] ; arr1 [ i ] = arr2 [ index2 ] ; arr2 [ index2 ] = tmp ; break ; } else if ( diff2 > diff1 ) { int tmp = arr1 [ index1 ] ; arr1 [ index1 ] = arr2 [ i ] ; arr2 [ i ] = tmp ; break ; } else if ( diff1 == diff2 ) { if ( index1 <= index2 ) { int tmp = arr1 [ index1 ] ; arr1 [ index1 ] = arr2 [ i ] ; arr2 [ i ] = tmp ; break ; } else if ( index2 <= index1 ) { int tmp = arr1 [ i ] ; arr1 [ i ] = arr2 [ index2 ] ; arr2 [ index2 ] = tmp ; break ; } } } } } int f_n1 = 0 , f_n2 = 0 ; for ( int i = l1 - 1 ; i >= 0 ; i -- ) { f_n1 = ( f_n1 * 10 ) + arr1 [ i ] ; f_n2 = ( f_n2 * 10 ) + arr2 [ i ] ; } System . out . println ( f_n1 + f_n2 ) ; }
void checkCube ( int a , int b ) { String s1 = Integer . toString ( a ) ; String s2 = Integer . toString ( b ) ; int c = Integer . parseInt ( s1 + s2 ) ; if ( isPerfectCube ( c ) ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } }
boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) > 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; }
String even_or_odd ( String N ) { int len = N . length ( ) ; if ( N . charAt ( len - 1 ) == '0' || N . charAt ( len - 1 ) == '2' || N . charAt ( len - 1 ) == '4' || N . charAt ( len - 1 ) == '6' || N . charAt ( len - 1 ) == '8' || N . charAt ( len - 1 ) == 'A' || N . charAt ( len - 1 ) == 'C' || N . charAt ( len - 1 ) == 'E' ) return ( "Even" ) ; else return ( "Odd" ) ; }
boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) > 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 3 ) ) ; } return ( n % 31 == 0 ) ; }
boolean isPerfectSquare ( int x ) { int s = ( int ) Math . sqrt ( x ) ; return ( s * s == x ) ; }
boolean isFibonacci ( int N ) { return isPerfectSquare ( 5 * N * N + 4 ) || isPerfectSquare ( 5 * N * N - 4 ) ; }
int nextNonFibonacci ( int N ) { if ( N <= 3 ) return 4 ; if ( isFibonacci ( N + 1 ) ) return N + 2 ; else return N + 1 ; }
boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) <= 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 7 ) ) ; } return ( n % 71 == 0 ) ; }
int findDigits ( int n ) { int count = 0 ; while ( n != 0 ) { digit [ count ] = n % 10 ; n = n / 10 ; ++ count ; } return count ; }
int OR_of_Digits ( int n , int count ) { int ans = 0 ; for ( int i = 0 ; i < count ; i ++ ) { ans = ans | digit [ i ] ; } return ans ; }
int AND_of_Digits ( int n , int count ) { int ans = 0 ; for ( int i = 0 ; i < count ; i ++ ) { ans = ans & digit [ i ] ; } return ans ; }
int XOR_of_Digits ( int n , int count ) { int ans = 0 ; for ( int i = 0 ; i < count ; i ++ ) { ans = ans ^ digit [ i ] ; } return ans ; }
void preCompute ( ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i < 18 ; i ++ ) fact [ i ] = ( fact [ i - 1 ] * i ) ; }
void nextFactorial ( int N ) { for ( int i = 0 ; i < 21 ; i ++ ) { if ( N < fact [ i ] ) { System . out . println ( fact [ i ] ) ; break ; } } }
int largest_sum ( int arr [ ] , int n ) { int maximum = - 1 ; HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( m . get ( arr [ i ] ) > 1 ) { if ( m . containsKey ( 2 * arr [ i ] ) ) { m . put ( 2 * arr [ i ] , m . get ( 2 * arr [ i ] ) + m . get ( arr [ i ] ) / 2 ) ; } else { m . put ( 2 * arr [ i ] , m . get ( arr [ i ] ) / 2 ) ; } if ( 2 * arr [ i ] > maximum ) maximum = 2 * arr [ i ] ; } } return maximum ; }
int maxLength ( int arr [ ] , int N ) { int product = 1 , len = 0 ; for ( int i = 0 ; i < N ; i ++ ) { product *= arr [ i ] ; } if ( product >= 0 ) { return N ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 0 ) { len = Math . max ( len , Math . max ( N - i - 1 , i ) ) ; } } return len ; }
void findNumbers ( int N ) { int i = 1 ; while ( i <= N ) { System . out . print ( ( i * i * i ) + " " ) ; i ++ ; } }
int properDivisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; }
int properDivisorSum ( int n ) { int sum = 0 ; int i ; for ( i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum - n * ( n + 1 ) / 2 ; }
void findMinimumOperation ( int n , int d , int arrays [ ] [ ] ) { int cnt = 0 ; int first = Integer . MIN_VALUE , end = Integer . MAX_VALUE ; while ( n > 0 ) { int arr [ ] = { arrays [ cnt ] [ 0 ] , arrays [ cnt ] [ 1 ] } ; Arrays . sort ( arr ) ; first = Math . max ( first , arr [ 0 ] ) ; end = Math . min ( end , arr [ 1 ] ) ; cnt ++ ; n -- ; } if ( first > end ) System . out . print ( "-1" ) ; else { if ( d >= first && d <= end ) { System . out . print ( "0" ) ; } else System . out . print ( Math . min ( Math . abs ( first - d ) , Math . abs ( d - end ) ) ) ; } }
long mult ( long a , long b ) { return ( ( a % mod ) * ( b % mod ) ) % mod ; }
long calculate_factors ( long n ) { long ans , cnt ; cnt = 0 ; ans = 1 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } if ( cnt % 2 == 1 ) { ans = mult ( ans , ( cnt + 1 ) ) ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { cnt = 0 ; while ( n % i == 0 ) { cnt ++ ; n = n / i ; } if ( cnt % 2 == 1 ) { ans = mult ( ans , ( cnt + 1 ) ) ; } } if ( n > 2 ) { ans = mult ( ans , ( 2 ) ) ; } return ans % mod ; }
void getmax ( int arr [ ] , int n , int x ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } System . out . print ( Math . min ( s , x ) ) ; }
void generatePrime ( ) { int i , j ; for ( i = 2 ; i <= sz ; i ++ ) isPrime [ i ] = true ; for ( i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } }
void Pair_of_PrimeXor ( int A [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( isPrime [ ( A [ i ] ^ A [ j ] ) ] ) { System . out . print ( "(" + A [ i ] + ", " + A [ j ] + ") " ) ; } } } }
Vector < Integer > primeFactors ( int n ) { int i , j ; Vector < Integer > Prime = new Vector < Integer > ( ) ; if ( n % 2 == 0 ) { Prime . add ( 2 ) ; } while ( n % 2 == 0 ) { n = n / 2 ; } for ( i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { Prime . add ( i ) ; } while ( n % i == 0 ) { n = n / i ; } } if ( n > 2 ) { Prime . add ( n ) ; } return Prime ; }
void checkDistinctPrime ( int n ) { Vector < Integer > Prime = primeFactors ( n ) ; int product = 1 ; for ( int i : Prime ) { product *= i ; } if ( product == n ) System . out . print ( "YES" ) ; else System . out . print ( "NO" ) ; }
double nthRoot ( int A , int N ) { double xPre = Math . random ( ) * 10 % 10 ; double eps = 1e-3 ; double delX = Integer . MAX_VALUE ; double xK = 0 ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + ( double ) A / Math . pow ( xPre , N - 1 ) ) / ( double ) N ; delX = Math . abs ( xK - xPre ) ; xPre = xK ; } return xK ; }
int countPowers ( int a , int b , int k ) { return ( int ) ( Math . floor ( nthRoot ( b , k ) ) - Math . ceil ( nthRoot ( a , k ) ) + 1 ) ; }
long findDigits ( int n , int b ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double M_PI = 3.141592 ; double M_E = 2.7182 ; double x = ( ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( Math . log10 ( b ) ) ; return ( long ) ( Math . floor ( x ) + 1 ) ; }
boolean isPrime ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; }
int findSum ( int N , int k ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( int ) Math . pow ( i , k ) ; } return sum ; }
boolean isPerfectSquare ( int x ) { int s = ( int ) Math . sqrt ( x ) ; return ( s * s == x ) ; }
int isNonFibonacci ( int n ) { if ( isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ) return 0 ; else return n ; }
void compute ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isNonFibonacci ( i ) ; } }
void printSum ( int L , int R ) { int sum = ( int ) ( pref [ R ] - pref [ L - 1 ] ) ; System . out . print ( sum + " " ) ; }
void checkArray ( int a [ ] , int b [ ] , int n ) { int operations = 0 ; int i = 0 ; while ( i < n ) { if ( a [ i ] - b [ i ] == 0 ) { i ++ ; continue ; } int diff = a [ i ] - b [ i ] ; i ++ ; while ( i < n && a [ i ] - b [ i ] == diff ) { i ++ ; } operations ++ ; } System . out . println ( operations ) ; }
boolean isPerfectSquare ( int x ) { int s = ( int ) Math . sqrt ( x ) ; return ( s * s == x ) ; }
boolean isFibonacci ( int n ) { return ( isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ) ; }
int countFibonacciPairs ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( isFibonacci ( arr [ i ] ) && isFibonacci ( arr [ j ] ) ) { int prevFib = previousFibonacci ( arr [ i ] ) ; int nextFib = nextFibonacci ( arr [ i ] ) ; if ( prevFib == arr [ j ] nextFib == arr [ j ] ) { res ++ ; } } return res ; }
int countPairsWithProductK ( int arr [ ] , int n , int k ) { int count = 0 ; int i ; boolean hashmap [ ] = new boolean [ MAX ] ; for ( i = 0 ; i < n ; i ++ ) hashmap [ arr [ i ] ] = true ; for ( i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; double index = 1.0 * k / arr [ i ] ; if ( index >= 0 && ( ( index - ( int ) ( index ) ) == 0 ) && hashmap [ k / x ] ) count ++ ; hashmap [ x ] = false ; } return count ; }
void simpleSieve ( int limit , ArrayList < Integer > prime ) { boolean [ ] mark = new boolean [ limit + 1 ] ; for ( int i = 2 ; i <= limit ; ++ i ) { if ( mark [ i ] == false ) { prime . add ( i ) ; for ( int j = i ; j <= limit ; j += i ) { mark [ j ] = true ; } } } }
void primesInRange ( int low , int high ) { int limit = ( int ) Math . floor ( Math . sqrt ( high ) ) + 1 ; ArrayList < Integer > prime = new ArrayList < > ( ) ; simpleSieve ( limit , prime ) ; int n = high - low + 1 ; boolean [ ] mark = new boolean [ n + 1 ] ; for ( int i = 0 ; i < prime . size ( ) ; i ++ ) { int loLim = ( int ) Math . floor ( ( double ) low / ( int ) prime . get ( i ) ) ; loLim *= ( int ) prime . get ( i ) ; if ( loLim < low ) { loLim += ( int ) prime . get ( i ) ; } if ( loLim == ( int ) prime . get ( i ) ) { loLim += ( int ) prime . get ( i ) ; } for ( int j = loLim ; j <= high ; j += ( int ) prime . get ( i ) ) mark [ j - low ] = true ; } for ( int i = low ; i <= high ; i ++ ) { if ( ! mark [ i - low ] ) { allPrimes . add ( i ) ; } } }
int maxPrimeSubarray ( int [ ] arr , int n ) { int current_max = 0 ; int max_so_far = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! allPrimes . contains ( arr [ i ] ) ) current_max = 0 ; else { current_max ++ ; max_so_far = Math . max ( current_max , max_so_far ) ; } } return max_so_far ; }
int search ( int a [ ] , int k , int x ) { int j ; for ( j = k - 1 ; j > - 1 ; j -- ) { if ( a [ j ] == x ) return j ; } return - 1 ; }
int countPairsWith ( int n , List < Integer > perfectcubes , List < Integer > nums ) { int count = 0 ; for ( int i = 0 ; i < perfectcubes . size ( ) ; i ++ ) { int temp = perfectcubes . get ( i ) - n ; if ( temp > n && ( nums . contains ( temp ) ) ) count += 1 ; } return count ; }
int countCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) for ( int j = 1 ; j * j * j <= i ; j ++ ) if ( j * j * j == i ) cnt ++ ; return cnt ; }
int countCubes ( int a , int b ) { return ( int ) ( Math . floor ( Math . cbrt ( b ) ) - Math . ceil ( Math . cbrt ( a ) ) + 1 ) ; }
int checkArmstrong ( int x ) { int n = String . valueOf ( x ) . length ( ) ; int sum1 = 0 ; int temp = x ; while ( temp > 0 ) { int digit = temp % 10 ; sum1 += Math . pow ( digit , n ) ; temp /= 10 ; } if ( sum1 == x ) return x ; return 0 ; }
void printSumarmstrong ( int [ ] [ ] arr , int Q ) { preCompute ( ) ; for ( int i = 0 ; i < Q ; i ++ ) { printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ; } }
boolean isArmstrong ( int x , int n ) { int sum1 = 0 ; int temp = x ; while ( temp > 0 ) { int digit = temp % 10 ; sum1 += Math . pow ( digit , n ) ; temp /= 10 ; } return sum1 == x ; }
void perfectCube ( int N ) { int cube_root ; cube_root = ( int ) Math . round ( Math . cbrt ( N ) ) ; if ( cube_root * cube_root * cube_root == N ) { System . out . println ( "Yes" ) ; return ; } else { System . out . println ( "NO" ) ; return ; } }
HashMap < Integer , Integer > primeFactors ( int n ) { HashMap < Integer , Integer > primeFact = new HashMap < > ( ) ; while ( n % 2 == 0 ) { primeFact = insertPF ( primeFact , 2 ) ; n /= 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { primeFact = insertPF ( primeFact , i ) ; n /= i ; } } if ( n > 2 ) primeFact = insertPF ( primeFact , n ) ; return primeFact ; }
void check ( int arr [ ] , int N ) { int even = 0 ; int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd ++ ; } else { even ++ ; } } if ( even == N odd == N ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
void findSum ( int N ) { int sum = ( N ) * ( N + 1 ) / 2 ; int r = ( int ) ( Math . log ( N ) / Math . log ( 2 ) ) + 1 ; int expSum = ( int ) ( Math . pow ( 2 , r ) ) - 1 ; System . out . println ( sum - expSum ) ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i += 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
boolean twinPrime ( int n1 , int n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && Math . abs ( n1 - n2 ) == 2 ) ; }
int countTwinPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( twinPrime ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; }
int findMinNumber ( int n ) { int count = 0 , ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 3 != 0 ) ans *= Math . pow ( 2 , ( count % 3 ) ) ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 3 != 0 ) ans *= Math . pow ( i , ( count % 3 ) ) ; } if ( n > 2 ) ans *= n ; return ans ; }
void printPairs ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( "(" + arr [ i ] + ", " + arr [ j ] + ")" + ", " ) ; } } }
int countSteps ( int n ) { int steps = 0 ; while ( n > 0 ) { int largest = ( int ) Math . cbrt ( n ) ; n -= ( largest * largest * largest ) ; steps ++ ; } return steps ; }
int product ( int N ) { int ans = 1 ; int val = ( int ) Math . pow ( 2 , N - 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) { ans *= ( int ) Math . pow ( i , val ) ; } return ans ; }
int nearest ( int n ) { int prevSquare = ( int ) Math . sqrt ( n ) ; int nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; int ans = ( n - prevSquare ) < ( nextSquare - n ) ? ( prevSquare - n ) : ( nextSquare - n ) ; return ans ; }
int ways ( int n ) { if ( n < 3 ) { return 0 ; } int c2 = 0 ; int c1 = n - 3 ; int l = c1 + 1 ; int s = 0 ; int exp_c2 = c1 / 2 ; while ( exp_c2 >= c2 ) { int f1 = factorial ( l ) ; int f2 = factorial ( c1 ) ; int f3 = factorial ( c2 ) ; int f4 = ( f2 * f3 ) ; s += f1 / f4 ; c2 += 1 ; c1 -= 2 ; l -= 1 ; } return s ; }
boolean isPerfectCube ( int x ) { int cr = ( int ) Math . cbrt ( x ) ; return ( cr * cr * cr == x ) ; }
int sqrtSearch ( int low , int high , int N ) { if ( low <= high ) { int mid = ( int ) ( low + high ) / 2 ; if ( ( mid * mid <= N ) && ( ( mid + 1 ) * ( mid + 1 ) > N ) ) { return mid ; } else if ( mid * mid < N ) { return sqrtSearch ( mid + 1 , high , N ) ; } else { return sqrtSearch ( low , mid - 1 , N ) ; } } return low ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void printAllDivisors ( int arr [ ] , int N ) { int g = arr [ 0 ] ; HashSet < Integer > divisors = new HashSet < Integer > ( ) ; for ( int i = 1 ; i < N ; i ++ ) { g = gcd ( arr [ i ] , g ) ; } for ( int i = 1 ; i * i <= g ; i ++ ) { if ( g % i == 0 ) { divisors . add ( i ) ; if ( g / i != i ) divisors . add ( g / i ) ; } } for ( int it : divisors ) System . out . print ( it + " " ) ; }
int getSmallestPrimefactor ( int n ) { for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return i ; } return - 1 ; }
boolean ispalin ( int num ) { String s = Integer . toString ( num ) ; int st = 0 , ed = s . length ( ) - 1 ; while ( st <= ed ) { if ( s . charAt ( st ) != s . charAt ( ed ) ) return false ; st ++ ; ed -- ; } return true ; }
void CalculateXORandOR ( int n ) { int CalculateXOR = 0 ; int CalculateOR = 0 ; int start = ( int ) Math . pow ( 10 , n - 1 ) ; int end = ( int ) Math . pow ( 10 , n ) - 1 ; for ( int i = start ; i <= end ; i ++ ) { if ( ispalin ( i ) ) { CalculateXOR = CalculateXOR ^ i ; CalculateOR = CalculateOR | i ; } } System . out . print ( "XOR = " + CalculateXOR ) ; System . out . println ( " OR = " + CalculateOR ) ; }
int checkPalindrome ( int num ) { String str = String . valueOf ( num ) ; int l = 0 , r = str . length ( ) - 1 ; while ( l < r ) { if ( str . charAt ( l ) != str . charAt ( r ) ) { return 0 ; } l ++ ; r -- ; } return num ; }
void preCompute ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + checkPalindrome ( i ) ; } }
void Sieve ( ) { for ( int i = 1 ; i < 100001 ; i ++ ) k [ i ] = i ; for ( int i = 2 ; i < 100001 ; i ++ ) { if ( prime [ i ] == 0 ) for ( int j = i ; j < 100001 ; j += i ) { prime [ j ] = 1 ; while ( k [ j ] % ( i * i ) == 0 ) k [ j ] /= ( i * i ) ; } } }
int countPairs ( int arr [ ] , int n ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . containsKey ( k [ arr [ i ] ] ) ) { freq . put ( k [ arr [ i ] ] , freq . get ( k [ arr [ i ] ] ) + 1 ) ; } else freq . put ( k [ arr [ i ] ] , 1 ) ; } int sum = 0 ; for ( Map . Entry < Integer , Integer > i : freq . entrySet ( ) ) { sum += ( ( i . getValue ( ) - 1 ) * i . getValue ( ) ) / 2 ; } return sum ; }
int powOfPositive ( int n ) { int pos = ( int ) Math . floor ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ; return ( int ) Math . pow ( 2 , pos ) ; }
int powOfNegative ( int n ) { int pos = ( int ) Math . ceil ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ; return ( int ) ( - 1 * Math . pow ( 2 , pos ) ) ; }
void highestPowerOf2 ( int n ) { if ( n > 0 ) { System . out . println ( powOfPositive ( n ) ) ; } else { n = - n ; System . out . println ( powOfNegative ( n ) ) ; } }
int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 1 ) sum += ( i * i ) ; else sum -= ( i * i ) ; } return sum ; }
int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y + x ) % ( y ^ x ) == 0 ) count ++ ; } } return count ; }
boolean isPower ( int x , int y ) { int res1 = ( int ) ( Math . log ( y ) / Math . log ( x ) ) ; double res2 = Math . log ( y ) / Math . log ( x ) ; return ( res1 == res2 ) ; }
int countPower ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( isPower ( arr [ i ] , arr [ j ] ) || isPower ( arr [ j ] , arr [ i ] ) ) res ++ ; return res ; }
int xor_all_elements ( int n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; } return 0 ; }
void precompute ( ) { int fact = 1 ; for ( int i = 1 ; i <= 18 ; i ++ ) { fact = fact * i ; m . put ( fact , i ) ; } }
int sumOfParts ( int [ ] [ ] arr , int N ) { int sum_part1 = 0 , sum_part2 = 0 , sum_part3 = 0 , sum_part4 = 0 ; int totalsum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i + j < N - 1 ) { if ( i < j && i != j && i + j > 0 ) sum_part1 += arr [ i ] [ j ] ; else if ( i != j ) sum_part2 += arr [ i ] [ j ] ; } else { if ( i > j && i + j != N - 1 ) sum_part3 += arr [ i ] [ j ] ; else { if ( i + j != N - 1 && i != j ) sum_part4 += arr [ i ] [ j ] ; } } } } totalsum = sum_part1 + sum_part2 + sum_part3 + sum_part4 ; return totalsum ; }
int noOfCards ( int n ) { return n * ( 3 * n + 1 ) / 2 ; }
int subsetSum ( int arr [ ] , int n , int sum , int s , int count ) { if ( n == 0 ) { if ( sum == s ) { count ++ ; } return count ; } count = subsetSum ( arr , n - 1 , sum , s , count ) ; count = subsetSum ( arr , n - 1 , sum , s + arr [ n - 1 ] , count ) ; return count ; }
void ifPossible ( int X , int Y ) { if ( X > Y ) swap ( X , Y ) ; if ( ( X + Y ) % 5 == 0 && 3 * X >= 2 * Y ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
int isPerfectCube ( int x ) { double cr = Math . round ( Math . cbrt ( x ) ) ; if ( cr * cr * cr == ( double ) x ) return x ; return 0 ; }
void printSum ( int L , int R ) { long sum = pref [ R ] - pref [ L - 1 ] ; System . out . print ( sum + " " ) ; }
int binomialCoeff ( int n , int k ) { int [ ] [ ] C = new int [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
ArrayList < Integer > sieve ( int n ) { ArrayList < Integer > prime = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime . add ( 0 ) ; int p = 2 ; while ( p * p <= n ) { if ( prime . get ( p ) == 0 ) { for ( int i = 2 * p ; i < n + 1 ; i += p ) prime . set ( i , 1 ) ; } p += 1 ; } ArrayList < Integer > allPrimes = new ArrayList < Integer > ( ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( prime . get ( i ) == 0 ) allPrimes . add ( i ) ; } return allPrimes ; }
int log_a_to_base_b ( int a , int b ) { return ( int ) ( Math . log ( a ) / Math . log ( b ) ) ; }
String findSmallest ( int N ) { String smallest = "1" ; for ( int i = 0 ; i < N - 1 ; i ++ ) smallest += '0' ; return smallest ; }
void heapify ( int arr [ ] , int n , int i ) { int largest = i ; int l = 2 * i + 1 ; int r = 2 * i + 2 ; if ( l < n && arr [ l ] > arr [ largest ] ) largest = l ; if ( r < n && arr [ r ] > arr [ largest ] ) largest = r ; if ( largest != i ) { int swap = arr [ i ] ; arr [ i ] = arr [ largest ] ; arr [ largest ] = swap ; heapify ( arr , n , largest ) ; } }
int count ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += 7 * Math . pow ( 8 , i - 1 ) ; } return sum ; }
int nextPowerOfK ( int n , int k ) { return prevPowerofK ( n , k ) * k ; }
boolean isPalindrome ( int n ) { String str = String . valueOf ( n ) ; int s = 0 , e = str . length ( ) - 1 ; while ( s < e ) { if ( str . charAt ( s ) != str . charAt ( e ) ) { return false ; } s ++ ; e -- ; } return true ; }
void palindromicDivisors ( int n ) { Vector < Integer > PalindromDivisors = new Vector < Integer > ( ) ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { if ( isPalindrome ( i ) ) { PalindromDivisors . add ( i ) ; } } else { if ( isPalindrome ( i ) ) { PalindromDivisors . add ( i ) ; } if ( isPalindrome ( n / i ) ) { PalindromDivisors . add ( n / i ) ; } } } } Collections . sort ( PalindromDivisors ) ; for ( int i = 0 ; i < PalindromDivisors . size ( ) ; i ++ ) { System . out . print ( PalindromDivisors . get ( i ) + " " ) ; } }
int isPerfectSquare ( int x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ? x : 0 ; }
void compute ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isPerfectSquare ( i ) ; } }
void printSum ( int L , int R ) { int sum = pref [ R ] - pref [ L - 1 ] ; System . out . print ( sum + " " ) ; }
void factors ( int n , int i ) { if ( i <= n ) { if ( n % i == 0 ) { System . out . print ( i + " " ) ; } factors ( n , i + 1 ) ; } }
int solve ( int n ) { int ans = ( n * n / 4 ) ; return ans ; }
void solve ( int arr [ ] , int n ) { Set < Integer > unfilled_indices = new HashSet < Integer > ( ) ; Set < Integer > missing = new HashSet < Integer > ( ) ; for ( int i = 1 ; i < n ; i ++ ) { missing . add ( i ) ; } for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { unfilled_indices . add ( i ) ; } else { missing . remove ( arr [ i ] ) ; } } int [ ] mi = new int [ missing . size ( ) ] ; int l = 0 ; for ( int x : missing ) { mi [ l ++ ] = x ; } int m = missing . size ( ) ; for ( int it : unfilled_indices ) { arr [ it ] = mi [ m - 1 ] ; m -- ; } int pos = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == i ) { pos = i ; } } int x ; if ( pos != 0 ) { for ( int i = 1 ; i < n ; i ++ ) { if ( pos != i ) { if ( unfilled_indices . contains ( i ) ) { x = arr [ i ] ; arr [ i ] = pos ; arr [ pos ] = x ; break ; } } } } printArray ( arr , n ) ; }
void printArray ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
int maximum ( int x , int y ) { return ( ( x + y + Math . abs ( x - y ) ) / 2 ) ; }
int minimum ( int x , int y ) { return ( ( x + y - Math . abs ( x - y ) ) / 2 ) ; }
void SubarraysWithSumS ( int n , int k , int s ) { for ( int i = 0 ; i < k ; i ++ ) System . out . print ( s + " " ) ; for ( int i = k ; i < n ; i ++ ) System . out . print ( s + 1 + " " ) ; }
boolean check ( int x , Vector pos , Vector neg , int k ) { int pairs = 0 ; int p = neg . size ( ) - 1 ; int nn = neg . size ( ) - 1 ; int pp = pos . size ( ) - 1 ; for ( int i = 0 ; i < neg . size ( ) ; i ++ ) { while ( ( p >= 0 ) && ( ( int ) neg . get ( i ) * ( int ) neg . get ( p ) <= x ) ) p -- ; pairs += Math . min ( nn - p , nn - i ) ; } p = 0 ; for ( int i = pos . size ( ) - 1 ; i >= 0 ; i -- ) { while ( ( p < pos . size ( ) ) && ( ( int ) pos . get ( i ) * ( int ) pos . get ( p ) <= x ) ) p ++ ; pairs += Math . min ( p , i ) ; } p = pos . size ( ) - 1 ; for ( int i = neg . size ( ) - 1 ; i >= 0 ; i -- ) { while ( ( p >= 0 ) && ( ( int ) neg . get ( i ) * ( int ) pos . get ( p ) <= x ) ) p -- ; pairs += pp - p ; } return ( pairs >= k ) ; }
int pay ( int n ) { int cuts = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return cuts ; }
void sieve ( int n ) { for ( int i = 2 ; i <= n ; ++ i ) { if ( min_prime [ i ] > 0 ) { continue ; } min_prime [ i ] = i ; max_prime [ i ] = i ; int j = i + i ; while ( j <= n ) { if ( min_prime [ j ] == 0 ) { min_prime [ j ] = i ; } max_prime [ j ] = i ; j += i ; } } }
int pairCount ( int n , int m ) { int cnt = 0 , b , a ; for ( b = 0 ; b <= Math . sqrt ( m ) ; b ++ ) { a = m - b * b ; if ( a * a + b == n ) { cnt ++ ; } } return cnt ; }
void Calc_Max_Div ( int arr [ ] , int n ) { int vis [ ] = new int [ maxin + 1 ] ; for ( int i = 0 ; i < maxin + 1 ; i ++ ) vis [ i ] = 1 ; vis [ 0 ] = vis [ 1 ] = 0 ; for ( int i = 1 ; i <= maxin ; i ++ ) divisors [ i ] = i ; for ( int i = 4 ; i <= maxin ; i += 2 ) { vis [ i ] = 0 ; divisors [ i ] = i / 2 ; } for ( int i = 3 ; i <= maxin ; i += 2 ) { if ( divisors [ i ] != i ) { divisors [ i ] = i / divisors [ i ] ; } if ( vis [ i ] == 1 ) { for ( int j = i * i ; j < maxin ; j += i ) { vis [ j ] = 0 ; if ( divisors [ j ] == j ) divisors [ j ] = i ; } } } for ( int i = 0 ; i < n ; i ++ ) { if ( divisors [ arr [ i ] ] == arr [ i ] ) System . out . print ( "-1 " ) ; else System . out . print ( divisors [ arr [ i ] ] + " " ) ; } }
int sumOfDigit ( int n , int b ) { int unitDigit , sum = 0 ; while ( n > 0 ) { unitDigit = n % b ; sum += unitDigit ; n = n / b ; } return sum ; }
int nthDigit ( int a , int n , int b ) { for ( int i = 1 ; i < n ; i ++ ) a = a / b ; return a % b ; }
int countSum ( int N , int L , int R ) { if ( L > R ) { return 0 ; } if ( N == 1 ) { return R - L + 1 ; } if ( N > 1 ) { return ( N - 2 ) * ( R - L ) + 1 ; } return 0 ; }
int solve ( int arr [ ] , int n , int k ) { int minx = INT_MAX ; int i ; for ( i = 0 ; i < n ; i ++ ) { minx = Math . min ( minx , arr [ i ] ) ; } int decrements = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] - minx ) % k != 0 ) { return - 1 ; } else { decrements += ( ( arr [ i ] - minx ) / k ) ; } } return decrements ; }
int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
int count_of_subarrays ( int N ) { int count = binomialCoeff ( 2 * N - 1 , N ) ; return count ; }
void distribution ( int n , int k , int l , int r , int S , int Sk ) { int a [ ] = new int [ n ] ; int len = k , temp , rem , s ; int diff = S - Sk ; for ( int i = 0 ; i < len ; i ++ ) { temp = Sk / k ; rem = Sk % k ; if ( temp + rem >= l && temp + rem <= r ) { a [ i ] = temp ; } else if ( temp + rem > r ) { a [ i ] = r ; } else if ( temp + rem < r ) { System . out . print ( "-1" ) ; return ; } Sk = Sk - a [ i ] ; k = k - 1 ; } if ( Sk > 0 ) { System . out . print ( "-1" ) ; return ; } if ( len != 0 ) { k = n - len ; for ( int i = len ; i < n ; i ++ ) { temp = diff / k ; rem = diff % k ; if ( temp + rem >= l && temp + rem <= r ) { a [ i ] = temp ; } else if ( temp + rem > r ) { a [ i ] = r ; } else if ( temp + rem < r ) { System . out . print ( "-1" ) ; return ; } diff = diff - a [ i ] ; k = k - 1 ; } if ( diff != 0 ) { System . out . print ( "-1" ) ; return ; } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( a [ i ] + " " ) ; } }
int countDigit ( int n ) { int c = 0 ; while ( n != 0 ) { int r = n % 10 ; c ++ ; n /= 10 ; } return c ; }
int min_index ( int p [ ] , int n ) { int ans = 0 ; int mini = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] <= mini ) mini = p [ i ] ; if ( mini == p [ i ] ) ans ++ ; } return ans ; }
void equal_xor_sum ( int arr [ ] , int n ) { int Sum = 0 ; int Xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum = Sum + arr [ i ] ; Xor = Xor ^ arr [ i ] ; } if ( Sum == Xor ) System . out . println ( "YES" ) ; else System . out . println ( "NO" ) ; }
int Count_subarray ( int arr [ ] , int n ) { int subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { subarray_sum = 0 ; remaining_sum = 0 ; for ( int k = i ; k <= j ; k ++ ) { subarray_sum += arr [ k ] ; } for ( int l = 0 ; l < i ; l ++ ) { remaining_sum += arr [ l ] ; } for ( int l = j + 1 ; l < n ; l ++ ) { remaining_sum += arr [ l ] ; } if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; }
int set_bits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n % 2 ; n /= 2 ; } return count ; }
int minSteps ( int n ) { int ans = 0 ; while ( n != 1 ) { if ( n % 2 == 0 ) n /= 2 ; else if ( n == 3 || set_bits ( n - 1 ) < set_bits ( n + 1 ) ) n -- ; else n ++ ; ans ++ ; } return ans ; }
int minimumNo ( int n ) { int ans = 0 ; Stack < Integer > stack1 = new Stack < Integer > ( ) ; Stack < Integer > stack2 = new Stack < Integer > ( ) ; while ( n != 0 ) { int r = n % 10 ; if ( r % 2 == 0 ) { stack1 . add ( r ) ; } else { stack2 . add ( r ) ; } n = n / 10 ; } while ( ! stack1 . isEmpty ( ) && ! stack2 . isEmpty ( ) ) { if ( stack1 . peek ( ) < stack2 . peek ( ) ) { ans = ans * 10 + stack1 . peek ( ) ; stack1 . pop ( ) ; } else { ans = ans * 10 + stack2 . peek ( ) ; stack2 . pop ( ) ; } } while ( ! stack1 . isEmpty ( ) ) { ans = ans * 10 + stack1 . peek ( ) ; stack1 . pop ( ) ; } while ( ! stack2 . isEmpty ( ) ) { ans = ans * 10 + stack2 . peek ( ) ; stack2 . pop ( ) ; } return ans ; }
void findNums ( int x ) { int ans = - 1 ; for ( int i = 1 ; i <= Math . sqrt ( x ) ; i ++ ) { if ( x % i == 0 && lcm ( i , x / i ) == x ) { ans = i ; } } System . out . print ( ans + " " + ( x / ans ) ) ; }
int maxCommonElement ( int A [ ] , int D [ ] , int N ) { int cnt [ ] = new int [ MAXN ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = A [ i ] ; j < MAXN ; j += D [ i ] ) cnt [ j ] ++ ; } int ans = 0 ; int com = 0 ; for ( int i = 0 ; i < MAXN ; i ++ ) { if ( cnt [ i ] > ans ) { ans = cnt [ i ] ; com = i ; } } return com ; }
int findTrailingZeros ( int n ) { if ( ( n & 1 ) == 1 ) return 0 ; else { int ans = 0 ; n /= 2 ; while ( n != 0 ) { ans += n / 5 ; n /= 5 ; } return ans ; } }
int maxGCD ( int N , int K ) { int minSum = ( K * ( K + 1 ) ) / 2 ; if ( N < minSum ) return - 1 ; int i = ( int ) Math . sqrt ( N ) ; int res = 1 ; while ( i >= 1 ) { if ( N % i == 0 ) { if ( i >= minSum ) res = Math . max ( res , N / i ) ; if ( N / i >= minSum ) res = Math . max ( res , i ) ; } i -- ; } return res ; }
int findNumberOfEvenCells ( int n , int q [ ] [ ] , int size ) { int row [ ] = new int [ n ] ; int col [ ] = new int [ n ] ; for ( int i = 0 ; i < size ; i ++ ) { int x = q [ i ] [ 0 ] ; int y = q [ i ] [ 1 ] ; row [ x - 1 ] ++ ; col [ y - 1 ] ++ ; } int r1 = 0 , r2 = 0 ; int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( row [ i ] % 2 == 0 ) { r1 ++ ; } if ( row [ i ] % 2 == 1 ) { r2 ++ ; } if ( col [ i ] % 2 == 0 ) { c1 ++ ; } if ( col [ i ] % 2 == 1 ) { c2 ++ ; } } int count = r1 * c1 + r2 * c2 ; return count ; }
int fastmod ( int base , int exp , int mod ) { if ( exp == 0 ) return 1 ; else if ( exp % 2 == 0 ) { int ans = fastmod ( base , exp / 2 , mod ) ; return ( ans % mod * ans % mod ) % mod ; } else return ( fastmod ( base , exp - 1 , mod ) % mod * base % mod ) % mod ; }
int findPowerSum ( int n , int ar [ ] ) { final int mod = ( int ) 1e9 + 7 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int base = countSetBits ( ar [ i ] ) ; int exp = ar [ i ] ; sum += fastmod ( base , exp , mod ) ; sum %= mod ; } return sum ; }
int maxHeight ( int h1 , int h2 ) { return ( ( h1 * h2 ) - h1 - h2 ) ; }
double area ( double a , double b , double c ) { double p = ( a + b + c ) / 2 ; return Math . sqrt ( p ) * Math . sqrt ( p - a ) * Math . sqrt ( p - b ) * Math . sqrt ( p - c ) ; }
double binary_search ( ) { double s = area ( r1 + r2 , r2 + r3 , r3 + r1 ) ; double l = 0 , h = s / ( r1 + r2 + r3 ) ; while ( h - l >= 1.e-7 ) { double mid = ( l + h ) / 2 ; double s1 = area ( mid + r1 , mid + r2 , r1 + r2 ) ; double s2 = area ( mid + r1 , mid + r3 , r1 + r3 ) ; double s3 = area ( mid + r2 , mid + r3 , r2 + r3 ) ; if ( s1 + s2 + s3 < s ) { l = mid ; } else { h = mid ; } } return ( l + h ) / 2 ; }
boolean subArray ( int [ ] arr , int n , int m ) { int i ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( i = 0 ; i < n ; i ++ ) { mp . put ( arr [ i ] , i + 1 ) ; } int sumcur = 0 ; int p = Integer . MAX_VALUE ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( i = 1 ; i <= m ; i ++ ) { sumcur += mp . get ( i ) ; p = Math . min ( p , mp . get ( i ) ) ; int val = p * i - i + ( i * ( i + 1 ) ) / 2 ; if ( i == m ) { if ( val == sumcur ) { return true ; } else return false ; } } return false ; }
boolean isPalindrome ( String s ) { int left = 0 , right = s . length ( ) - 1 ; while ( left <= right ) { if ( s . charAt ( left ) != s . charAt ( right ) ) { return false ; } left ++ ; right -- ; } return true ; }
int cntSubSeq ( int arr [ ] , int n ) { int pos_count = 0 ; int neg_count = 0 ; int result ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = ( int ) Math . pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= Math . pow ( 2 , neg_count - 1 ) ; result -= 1 ; return result ; }
void FermatFactors ( int n ) { if ( n <= 0 ) { System . out . print ( "[" + n + "]" ) ; return ; } if ( ( n & 1 ) == 0 ) { System . out . print ( "[" + n / 2.0 + "," + 2 + "]" ) ; return ; } int a = ( int ) Math . ceil ( Math . sqrt ( n ) ) ; if ( a * a == n ) { System . out . print ( "[" + a + "," + a + "]" ) ; return ; } int b ; while ( true ) { int b1 = a * a - n ; b = ( int ) ( Math . sqrt ( b1 ) ) ; if ( b * b == b1 ) break ; else a += 1 ; } System . out . print ( "[" + ( a - b ) + "," + ( a + b ) + "]" ) ; return ; }
void findNums ( int arr [ ] , int n ) { int S = 0 , X = 0 ; for ( int i = 0 ; i < n ; i ++ ) { S += arr [ i ] ; X ^= arr [ i ] ; } System . out . println ( X + " " + ( X + S ) ) ; }
void decBinary ( int arr [ ] , int n ) { int k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } }
int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; }
int getNum ( int n , int k ) { int l = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; int a [ ] = new int [ l ] ; decBinary ( a , n ) ; if ( k > l ) return n ; a [ k - 1 ] = ( a [ k - 1 ] == 0 ) ? 1 : 0 ; return binaryDec ( a , l ) ; }
void solve ( int A , int B ) { double p = B / 2.0 ; double M = Math . ceil ( 4 * p ) ; int N = 1 ; int O = - 2 * A ; double Q = Math . ceil ( A * A + 4 * p * p ) ; System . out . println ( M + " " + N + " " + O + " " + Q ) ; }
int findMin ( int arr [ ] , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) m = Math . max ( m , arr [ i ] ) ; int freq [ ] = new int [ m + 2 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; for ( int i = 1 ; i <= m + 1 ; i ++ ) { int j = i ; int cnt = 0 ; while ( j <= m ) { cnt += freq [ j ] ; j += i ; } if ( cnt == 0 ) return i ; } return m + 1 ; }
int findMin ( int arr [ ] , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) m = Math . max ( m , arr [ i ] ) ; int cnt [ ] = new int [ m + 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j * j <= arr [ i ] ; j ++ ) { if ( arr [ i ] % j == 0 ) { if ( j * j == arr [ i ] ) cnt [ j ] ++ ; else { cnt [ j ] ++ ; cnt [ arr [ i ] / j ] ++ ; } } } } for ( int i = 1 ; i <= m + 1 ; i ++ ) if ( cnt [ i ] == 0 ) { return i ; } return - 1 ; }
void find_composite_nos ( int n ) { System . out . println ( 9 * n + " " + 8 * n ) ; }
int maxXOR ( int arr [ ] , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = Math . max ( ans , ( xorArr ^ arr [ i ] ) ) ; return ans ; }
int findLargest ( int [ ] arr , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = __gcd ( arr [ i ] , gcd ) ; return gcd ; }
void sieve ( ) { for ( int i = 0 ; i < sz + 1 ; i ++ ) isPrime [ i ] = true ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } }
void removePrimes ( int arr [ ] , int len ) { sieve ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( isPrime [ arr [ i ] ] ) { for ( int j = i ; j < len - 1 ; j ++ ) { arr [ j ] = arr [ j + 1 ] ; } i -- ; len -- ; } } printArray ( arr , len ) ; }
int minOR ( int [ ] arr , int n ) { if ( n == 1 ) return 0 ; int [ ] pre = new int [ n ] ; int [ ] suf = new int [ n ] ; pre [ 0 ] = arr [ 0 ] ; suf [ n - 1 ] = arr [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = ( suf [ i + 1 ] arr [ i ] ) ; int ans = Math . min ( pre [ n - 2 ] , suf [ 1 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) ans = Math . min ( ans , ( pre [ i - 1 ] suf [ i + 1 ] ) ) ; return ans ; }
int subgrids ( int N , int Z , int row [ ] , int col [ ] , int r , int d ) { Vector < Integer > conrow = new Vector < Integer > ( ) ; Vector < Integer > concol = new Vector < Integer > ( ) ; int K = ( int ) Math . sqrt ( Z ) ; conrow . add ( row [ 0 ] - 0 - 1 ) ; conrow . add ( N + 1 - row [ r - 1 ] - 1 ) ; for ( int i = 1 ; i < r ; i ++ ) { conrow . add ( row [ i ] - row [ i - 1 ] - 1 ) ; } concol . add ( col [ 0 ] - 0 - 1 ) ; concol . add ( N + 1 - col [ d - 1 ] - 1 ) ; for ( int i = 1 ; i < d ; i ++ ) { concol . add ( col [ i ] - col [ i - 1 ] - 1 ) ; } int row_size = conrow . size ( ) ; int col_size = concol . size ( ) ; int answer = 0 ; for ( int i = 0 ; i < row_size ; i ++ ) { for ( int j = 0 ; j < col_size ; j ++ ) { int total = ( concol . get ( j ) / K ) * ( conrow . get ( i ) / K ) ; answer += ( total ) ; } } return answer ; }
int sub_arrays ( int [ ] a , int n , int k ) { int sum [ ] = new int [ n + 2 ] ; for ( int i = 0 ; i < n + 2 ; i ++ ) { sum [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { a [ i ] -- ; a [ i ] %= k ; sum [ i + 1 ] += sum [ i ] + a [ i ] ; sum [ i + 1 ] %= k ; } int ans = 0 , l = 0 , r = 0 ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { mp . put ( sum [ i ] , 0 ) ; } int temp ; for ( int i = 0 ; i < n + 1 ; i ++ ) { ans += ( int ) mp . get ( sum [ i ] ) ; temp = ( int ) mp . get ( sum [ i ] ) + 1 ; mp . put ( sum [ i ] , temp ) ; r ++ ; if ( r - l >= k ) { temp = ( int ) mp . get ( sum [ l ] ) - 1 ; mp . put ( sum [ l ] , temp ) ; l ++ ; } } return ans ; }
int findCount ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( digitDividesK ( i , k ) ) count ++ ; } return count ; }
int digitSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } return sum ; }
boolean isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; }
boolean isDigitSumPalindrome ( int n ) { int sum = digitSum ( n ) ; if ( isPalindrome ( sum ) ) return true ; return false ; }
int countDigits ( int n ) { int cnt = 0 ; while ( n > 0 ) { cnt ++ ; n /= 10 ; } return cnt ; }
int digitPowSum ( int n ) { int sum = 0 ; int pw = countDigits ( n ) ; while ( n > 0 ) { int d = n % 10 ; sum += Math . pow ( d , pw ) ; pw -- ; n /= 10 ; } return sum ; }
int countNum ( int n ) { int count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == digitPowSum ( i ) ) { count ++ ; } } return count ; }
void perfectSquares ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { if ( Math . sqrt ( i ) == ( int ) Math . sqrt ( i ) ) System . out . print ( i + " " ) ; } }
void perfectSquares ( float l , float r ) { int number = ( int ) Math . ceil ( Math . sqrt ( l ) ) ; int n2 = number * number ; number = ( number * 2 ) + 1 ; while ( ( n2 >= l && n2 <= r ) ) { System . out . print ( n2 + " " ) ; n2 = n2 + number ; number += 2 ; } }
int xorK ( int n , int k ) { if ( k % 2 == 1 ) return n ; return 0 ; }
void findRemainders ( long n ) { HashSet < Long > vc = new HashSet < Long > ( ) ; for ( long i = 1 ; i <= Math . ceil ( Math . sqrt ( n ) ) ; i ++ ) vc . add ( n / i ) ; for ( long i = ( long ) ( n / Math . ceil ( Math . sqrt ( n ) ) - 1 ) ; i >= 0 ; i -- ) vc . add ( i ) ; for ( long it : vc ) System . out . print ( it + " " ) ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } }
int countPrimes ( int n ) { SieveOfEratosthenes ( ) ; int cnt = 0 ; for ( int i = 2 ; i < n ; i ++ ) { if ( prime [ i ] && prime [ i - 2 ] ) cnt ++ ; } return cnt ; }
int power ( int a , int m1 ) { if ( m1 == 0 ) return 1 ; else if ( m1 == 1 ) return a ; else if ( m1 == 2 ) return ( a * a ) % mod ; else if ( ( m1 & 1 ) != 0 ) return ( a * power ( power ( a , m1 / 2 ) , 2 ) ) % mod ; else return power ( power ( a , m1 / 2 ) , 2 ) % mod ; }
void factorialfun ( ) { factorial [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) factorial [ i ] = ( factorial [ i - 1 ] * i ) % mod ; }
void modinversefun ( ) { modinverse [ N - 1 ] = power ( factorial [ N - 1 ] , mod - 2 ) % mod ; for ( int i = N - 2 ; i >= 0 ; i -- ) modinverse [ i ] = ( modinverse [ i + 1 ] * ( i + 1 ) ) % mod ; }
int binomial ( int n , int r ) { if ( r > n ) return 0 ; int a = ( factorial [ n ] * modinverse [ n - r ] ) % mod ; a = ( a * modinverse [ r ] ) % mod ; return a ; }
int arrange ( int n , int m , int k ) { factorialfun ( ) ; modinversefun ( ) ; int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) ans += ( i * ( n - i ) * m * m ) % mod ; ans = 8 ; for ( int i = 1 ; i < m ; i ++ ) ans += ( i * ( m - i ) * n * n ) % mod ; ans = ( ans * binomial ( n * m - 2 , k - 2 ) ) % mod + 8 ; return ans ; }
int findK ( int l , int r ) { int maxExp = Integer . MIN_VALUE ; int k = - 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( distinctDigits ( i ) ) { int exp = ( l - i ) * ( i - r ) ; if ( exp >= maxExp ) { k = i ; maxExp = exp ; } } } return k ; }
void findWinner ( int n ) { if ( ( n - 1 ) % 6 == 0 ) { System . out . println ( "Second Player wins the game" ) ; } else { System . out . println ( "First Player wins the game" ) ; } }
int countIndices ( int arr [ ] , int n ) { int cnt = 0 ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) { max = arr [ i ] ; cnt ++ ; } } return cnt ; }
int min_changes ( int a [ ] , int n ) { int ans_a = 0 , ans_b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { if ( a [ i ] == 0 ) ans_a ++ ; else ans_b ++ ; } else { if ( a [ i ] == 0 ) ans_b ++ ; else ans_a ++ ; } } return Math . min ( ans_a , ans_b ) ; }
void ans ( int n ) { if ( n == 1 ) System . out . println ( "1" ) ; else System . out . println ( "0" ) ; }
void sieve ( boolean prime [ ] , int n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } }
int sumPrime ( int d ) { int maxVal = ( int ) ( Math . pow ( 2 , d ) - 1 ) ; boolean [ ] prime = new boolean [ maxVal + 1 ] ; Arrays . fill ( prime , true ) ; sieve ( prime , maxVal ) ; int sum = 0 ; for ( int i = 2 ; i <= maxVal ; i ++ ) { if ( prime [ i ] ) { sum += i ; } } return sum ; }
boolean isPossible ( int w , int h , int x , int y ) { if ( x * 2 == w && y * 2 == h ) return true ; return false ; }
int findNthDigit ( int p , int q , int N ) { int res = 0 ; while ( N > 0 ) { N -- ; p *= 10 ; res = p / q ; p %= q ; } return res ; }
int minsteps ( int n , int m ) { if ( m > n ) { return - 1 ; } else { return ( ( n + 1 ) / 2 + m - 1 ) / m * m ; } }
int compare ( Node a , Node b ) { a = removeLeadingZeros ( a ) ; b = removeLeadingZeros ( b ) ; int lenA = getSize ( a ) ; int lenB = getSize ( b ) ; if ( lenA > lenB ) { return 1 ; } else if ( lenB > lenA ) { return - 1 ; } while ( a != null && b != null ) { if ( a . data > b . data ) return 1 ; else if ( a . data < b . data ) return - 1 ; a = a . next ; b = b . next ; } return 0 ; }
long power ( long a , long m1 ) { if ( m1 == 0 ) return 1 ; else if ( m1 == 1 ) return a ; else if ( m1 == 2 ) return ( a * a ) % mod ; else if ( ( m1 & 1 ) != 0 ) return ( a * power ( power ( a , m1 / 2 ) , 2 ) ) % mod ; else return power ( power ( a , m1 / 2 ) , 2 ) % mod ; }
void factorialfun ( ) { factorial [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) factorial [ i ] = ( factorial [ i - 1 ] * i ) % mod ; }
void modinversefun ( ) { modinverse [ N - 1 ] = power ( factorial [ N - 1 ] , mod - 2 ) % mod ; for ( int i = N - 2 ; i >= 0 ; i -- ) modinverse [ i ] = ( modinverse [ i + 1 ] * ( i + 1 ) ) % mod ; }
long binomial ( int n , int r ) { if ( r > n ) return 0 ; long a = ( factorial [ n ] * modinverse [ n - r ] ) % mod ; a = ( a * modinverse [ r ] ) % mod ; return a ; }
int maxFreq ( String s ) { String binary = "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { binary += bin [ s . charAt ( i ) - '0' ] ; } binary = binary . substring ( 0 , binary . length ( ) - 1 ) ; int count = 1 , prev = - 1 , i , j = 0 ; for ( i = binary . length ( ) - 1 ; i >= 0 ; i -- , j ++ ) if ( binary . charAt ( i ) == '1' ) { count = Math . max ( count , j - prev ) ; prev = j ; } return count ; }
int sumArr ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
int sumModArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { int subSum = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { subSum += arr [ j ] ; } arr [ i ] -= subSum ; } return sumArr ( arr , n ) ; }
int sumArr ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
int sumModArr ( int arr [ ] , int n ) { int subSum = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int curr = arr [ i ] ; arr [ i ] -= subSum ; subSum += curr ; } return sumArr ( arr , n ) ; }
int lcm ( int a , int b ) { int GCD = __gcd ( a , b ) ; return ( a * b ) / GCD ; }
int MinLCM ( int a [ ] , int n ) { int [ ] Prefix = new int [ n + 2 ] ; int [ ] Suffix = new int [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = lcm ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = lcm ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = Math . min ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = Math . min ( ans , lcm ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; }
long findNum ( long x ) { for ( int i = 0 ; i < NumUnsignBits - 1 ; i ++ ) { if ( ( ( x >> i ) & 1 ) != ( ( x >> ( i + 1 ) ) & 1 ) ) { x ^= ( 1 << i ) | ( 1 << ( i + 1 ) ) ; return x ; } } return Long . MIN_VALUE ; }
int minHealth ( int health [ ] , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { gcd = __gcd ( gcd , health [ i ] ) ; } return gcd ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void constructArr ( int pair [ ] , int n ) { int size = ( 1 + ( int ) Math . sqrt ( 1 + 8 * n ) ) / 2 ; int [ ] arr = new int [ size ] ; arr [ 0 ] = ( int ) Math . sqrt ( ( pair [ 0 ] * pair [ 1 ] ) / pair [ size - 1 ] ) ; for ( int i = 1 ; i < size ; i ++ ) arr [ i ] = pair [ i - 1 ] / arr [ 0 ] ; printArr ( arr , size ) ; }
int countWays ( int n , int m ) { return factMod ( m ) ; }
int Fuss_catalan ( int n ) { int c = binomialCoeff ( 3 * n , n ) ; return c / ( 2 * n + 1 ) ; }
boolean isComposite ( int n ) { for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return true ; } return false ; }
int Power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; }
void sieve ( ) { Arrays . fill ( isPrime , true ) ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } }
int findCnt ( int [ ] arr , int n , int k ) { int ret = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; int x = Math . max ( 0 , j - i - k + 1 ) ; ret += ( x * ( x + 1 ) ) / 2 ; i = j ; } return ret ; }
boolean isHeap ( int arr [ ] , int n ) { for ( int i = 0 ; i <= ( n - 2 ) / 2 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) { return false ; } if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) { return false ; } } return true ; }
int reverse ( int num ) { int rev = 0 ; while ( num > 0 ) { rev = rev * 10 + num % 10 ; num = num / 10 ; } return rev ; }
boolean isPalindrome ( int num ) { if ( num == reverse ( num ) ) return true ; return false ; }
void printPalindromes ( int d ) { if ( d <= 0 ) return ; int smallest = ( int ) Math . pow ( 10 , d - 1 ) ; int largest = ( int ) Math . pow ( 10 , d ) - 1 ; for ( int i = smallest ; i <= largest ; i ++ ) { if ( isPalindrome ( i ) ) System . out . print ( i + " " ) ; } }
int countElements ( int p [ ] , int n ) { int ans = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( p [ i - 1 ] > p [ i ] && p [ i ] > p [ i + 1 ] ) ans ++ ; else if ( p [ i - 1 ] < p [ i ] && p [ i ] < p [ i + 1 ] ) ans ++ ; } return ans ; }
int countNums ( int a , int b , int c , int d ) { int x = b / c - ( a - 1 ) / c ; int y = b / d - ( a - 1 ) / d ; int k = ( c * d ) / __gcd ( c , d ) ; int z = b / k - ( a - 1 ) / k ; return b - a + 1 - x - y + z ; }
int cntSubArrays ( int [ ] arr , int n , int k ) { int res = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; res += Math . max ( j - i - k + 1 , 0 ) ; i = j ; } return res ; }
int maxLen ( int [ ] arr , int n ) { int min_val = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; int freq = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == min_val ) freq ++ ; } return freq ; }
void print_primes_till_N ( int N ) { int i , j , flag ; System . out . println ( "Prime numbers between 1 and " + N + " are:" ) ; for ( i = 1 ; i <= N ; i ++ ) { if ( i == 1 i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) System . out . print ( i + " " ) ; } }
void last_digit ( int X , int Y ) { System . out . print ( X % Y ) ; }
void sieve ( ) { for ( int i = 0 ; i <= sz ; i ++ ) isPrime [ i ] = true ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } }
void findPrimesD ( int d ) { int left = ( int ) Math . pow ( 10 , d - 1 ) ; int right = ( int ) Math . pow ( 10 , d ) - 1 ; for ( int i = left ; i <= right ; i ++ ) { if ( isPrime [ i ] ) { System . out . print ( i + " " ) ; } } }
int geometricMean ( int n ) { return ( int ) Math . sqrt ( n ) ; }
int two_sets ( int a [ ] , int n ) { Arrays . sort ( a ) ; return a [ n / 2 ] - a [ ( n / 2 ) - 1 ] ; }
int min_moves ( int n ) { int ans = Integer . MAX_VALUE ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { ans = Math . min ( ans , i + n / i - 2 ) ; } } return ans ; }
int findX ( int A , int B ) { int X = 0 ; for ( int bit = 0 ; bit < MAX ; bit ++ ) { int tempBit = 1 << bit ; int bitOfX = A & B & tempBit ; X += bitOfX ; } return X ; }
int cntPairs ( int a [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd ++ ; else if ( ( a [ i ] / 2 ) % 2 == 1 ) even ++ ; } int ans = odd * even + ( odd * ( odd - 1 ) ) / 2 ; return ans ; }
int min_modulo ( int l , int r ) { if ( r - l >= MOD ) return 0 ; else { int ans = MOD - 1 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { ans = Math . min ( ans , ( i * j ) % MOD ) ; } } return ans ; } }
int kthNum ( int n , int k ) { int a = ( n + 1 ) / 2 ; if ( k > a ) return ( 2 * ( k - a ) ) ; return ( 2 * k - 1 ) ; }
void find_numbers ( int N ) { if ( N == 1 ) { System . out . print ( - 1 ) ; } else { System . out . print ( N + " " + ( N + 1 ) + " " + ( N * ( N + 1 ) ) ) ; } }
void findNum ( int a [ ] , int n , int b [ ] , int m ) { int x = max_element ( a , n ) ; int y = max_element ( b , m ) ; System . out . print ( x + " " + y ) ; }
int find_k ( int a , int b ) { if ( ( a + b ) % 2 == 0 ) return ( ( a + b ) / 2 ) ; return - 1 ; }
int odd_digits ( int n ) { if ( n < 10 ) return n ; else if ( n / 10 < 10 ) return 9 ; else if ( n / 100 < 10 ) return 9 + n - 99 ; else if ( n / 1000 < 10 ) return 9 + 900 ; else if ( n / 10000 < 10 ) return 909 + n - 9999 ; else return 90909 ; }
int nDigitPalindromes ( int n ) { return ( 9 * ( int ) Math . pow ( 10 , ( n - 1 ) / 2 ) ) ; }
int maxLCM ( int n ) { return ( n * ( n - 1 ) ) ; }
int cntSubSets ( int arr [ ] , int n ) { int maxVal = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; } return ( int ) ( Math . pow ( 2 , cnt ) - 1 ) ; }
int getSum ( int n ) { return ( ( n - 1 ) + ( int ) Math . pow ( n , 2 ) ) ; }
int cntEdges ( int n ) { int edges = ( int ) Math . pow ( 2 , n ) - 2 ; return edges ; }
int count ( int n ) { return n * ( 3 * n - 1 ) / 2 ; }
int findSum ( int n ) { return ( int ) Math . pow ( n , 3 ) ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void generateArr ( int arr [ ] , int n ) { boolean flip = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) { if ( flip ^= true ) System . out . print ( ( int ) ( Math . ceil ( arr [ i ] / 2.0 ) ) + " " ) ; else System . out . print ( ( int ) ( Math . floor ( arr [ i ] / 2.0 ) ) + " " ) ; } else { System . out . print ( arr [ i ] / 2 + " " ) ; } } }
int count ( int n ) { return ( int ) ( 15 * Math . pow ( 16 , n - 1 ) ) ; }
int nth_term ( int a , int b , int n ) { int z = 0 ; if ( n % 6 == 1 ) z = a ; else if ( n % 6 == 2 ) z = b ; else if ( n % 6 == 3 ) z = b - a ; else if ( n % 6 == 4 ) z = - a ; else if ( n % 6 == 5 ) z = - b ; if ( n % 6 == 0 ) z = - ( b - a ) ; return z ; }
int cntSubSeq ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int num = arr [ k - 1 ] ; int Y = 0 ; for ( int i = k - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] == num ) Y ++ ; } int cntX = Y ; for ( int i = k ; i < n ; i ++ ) { if ( arr [ i ] == num ) cntX ++ ; } return binomialCoeff ( cntX , Y ) ; }
boolean inProportion ( int [ ] arr ) { int n = 4 ; Arrays . sort ( arr ) ; long extremes = ( long ) arr [ 0 ] * ( long ) arr [ 3 ] ; long means = ( long ) arr [ 1 ] * ( long ) arr [ 2 ] ; if ( extremes == means ) return true ; return false ; }
float findProb ( int arr [ ] , int n ) { long maxSum = Integer . MIN_VALUE , maxCount = 0 , totalPairs = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( sum == maxSum ) { maxCount ++ ; } else if ( sum > maxSum ) { maxSum = sum ; maxCount = 1 ; } totalPairs ++ ; } } float prob = ( float ) maxCount / ( float ) totalPairs ; return prob ; }
int findMissing ( int arr [ ] , int n , int k , int avg ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int num = ( avg * ( n + k ) ) - sum ; int den = k ; if ( num % den != 0 ) return - 1 ; return ( int ) ( num / den ) ; }
int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
int countNum ( int n ) { if ( n > 10 ) return 0 ; return ( 9 * factorial ( 9 ) / factorial ( 10 - n ) ) ; }
int binomialCoeff ( int n , int k ) { int [ ] [ ] C = new int [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
int findMax ( int n ) { return binomialCoeff ( n , n / 2 ) ; }
int count ( int n ) { return ( int ) ( - 1 + Math . sqrt ( 1 + 8 * n ) ) / 2 ; }
void findEquation ( int a , int b ) { int sum = ( a + b ) ; int product = ( a * b ) ; System . out . println ( "x^2 - (" + sum + "x) + (" + product + ") = 0" ) ; }
int cal ( int n ) { double res = Math . pow ( Math . ceil ( ( Math . pow ( Math . pow ( 10 , ( n - 1 ) ) , 1 / 4 ) ) ) , 4 ) ; return ( int ) res ; }
int count ( int n ) { return 3 * n * ( n - 1 ) + 1 ; }
long binomialCoeff ( long n , long k ) { if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }
long fact ( long n ) { if ( n >= 1 ) return n * fact ( n - 1 ) ; else return 1 ; }
boolean isVowel ( char ch ) { if ( ch == 'a' ch == 'e' ch == 'i' ch == 'o' ch == 'u' ) { return true ; } return false ; }
long countWords ( String s , int p , int q ) { long countc = 0 , countv = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( isVowel ( s . charAt ( i ) ) ) countv ++ ; else countc ++ ; } long a = binomialCoeff ( countc , p ) ; long b = binomialCoeff ( countv , q ) ; long c = fact ( p + q ) ; long ans = ( a * b ) * c ; return ans ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void generateArr ( int A [ ] , int n ) { int [ ] B = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < i ; j ++ ) { if ( A [ j ] % A [ i ] == 0 ) cnt ++ ; } B [ i ] = cnt ; } printArr ( B , n ) ; }
int count ( int n ) { return ( int ) Math . pow ( 2 , n - 1 ) ; }
long nextFibonacci ( int n ) { double a = n * ( 1 + Math . sqrt ( 5 ) ) / 2.0 ; return Math . round ( a ) ; }
int product ( int a [ ] , int n ) { int ans = 1 ; int val = ( int ) Math . pow ( 2 , n - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { ans *= ( int ) Math . pow ( a [ i ] , val ) ; } return ans ; }
int max_distinct_char ( String str , int n ) { int count [ ] = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ str . charAt ( i ) ] ++ ; } int max_distinct = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] != 0 ) { max_distinct ++ ; } } return max_distinct ; }
int smallesteSubstr_maxDistictChar ( String str ) { int n = str . length ( ) ; int max_distinct = max_distinct_char ( str , n ) ; int minl = n ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { String subs = null ; if ( i < j ) subs = str . substring ( i , j ) ; else subs = str . substring ( j , i ) ; int subs_lenght = subs . length ( ) ; int sub_distinct_char = max_distinct_char ( subs , subs_lenght ) ; if ( subs_lenght < minl && max_distinct == sub_distinct_char ) { minl = subs_lenght ; } } } return minl ; }
void findPair ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . print ( "-1" ) ; return ; } int i , first , second ; first = second = - 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { second = arr [ i ] ; } } System . out . println ( "n = " + first + " and r = " + second ) ; }
int sum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum = sum * ( int ) Math . pow ( 2 , n - 1 ) ; return sum ; }
int maxHeight ( int n ) { return ( ( ( int ) Math . sqrt ( 1 + 8.0 * n ) ) - 1 ) / 2 ; }
int ways ( int n ) { return n / 2 ; }
int prevPowerof2 ( int n ) { int p = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return ( int ) Math . pow ( 2 , p ) ; }
int nextPowerOf2 ( int n ) { int p = 1 ; if ( ( n == 0 ) && ! ( ( n & ( n - 1 ) ) == 0 ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
int minDiff ( int n ) { int low = prevPowerof2 ( n ) ; int high = nextPowerOf2 ( n ) ; return Math . min ( n - low , high - n ) ; }
boolean isPossible ( int x , int y , int k ) { int minMoves = Math . abs ( x ) + Math . abs ( y ) ; if ( k >= minMoves && ( k - minMoves ) % 2 == 0 ) return true ; return false ; }
int countPairs ( int arr [ ] , int n ) { HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) map . put ( arr [ i ] - i , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) map . put ( arr [ i ] - i , map . get ( arr [ i ] - i ) + 1 ) ; int res = 0 ; for ( int x : map . values ( ) ) { int cnt = x ; res += ( ( cnt * ( cnt - 1 ) ) / 2 ) ; } return res ; }
int findMinValue ( int arr [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( ( int ) ( sum / n ) + 1 ) ; }
boolean isFactorion ( int n ) { int fact [ ] = new int [ MAX ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; int org = n ; int sum = 0 ; while ( n > 0 ) { int d = n % 10 ; sum += fact [ d ] ; n /= 10 ; } if ( sum == org ) return true ; return false ; }
int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; }
long minOperations ( long n ) { long count = 0 ; long d = 0 ; if ( n == 1 ) return 0 ; while ( n > 9 ) { d = Math . max ( n % 10 , d ) ; n /= 10 ; count += 10 ; } d = Math . max ( d , n - 1 ) ; count += Math . abs ( d ) ; return count - 1 ; }
int maxCommonFactors ( int a , int b ) { int __gcd = gcd ( a , b ) ; int ans = 1 ; for ( int i = 2 ; i * i <= __gcd ; i ++ ) { if ( __gcd % i == 0 ) { ans ++ ; while ( __gcd % i == 0 ) __gcd /= i ; } } if ( __gcd != 1 ) ans ++ ; return ans ; }
void updateFreq ( int n , int [ ] freq ) { while ( n > 0 ) { int digit = n % TEN ; freq [ digit ] ++ ; n /= TEN ; } }
boolean areAnagrams ( int a , int b ) { int [ ] freqA = new int [ TEN ] ; int [ ] freqB = new int [ TEN ] ; updateFreq ( a , freqA ) ; updateFreq ( b , freqB ) ; for ( int i = 0 ; i < TEN ; i ++ ) { if ( freqA [ i ] != freqB [ i ] ) return false ; } return true ; }
int dayOfYear ( String date ) { int year = Integer . parseInt ( date . substring ( 0 , 4 ) ) ; int month = Integer . parseInt ( date . substring ( 5 , 7 ) ) ; int day = Integer . parseInt ( date . substring ( 8 ) ) ; if ( month > 2 && year % 4 == 0 && ( year % 100 != 0 year % 400 == 0 ) ) { ++ day ; } while ( -- month > 0 ) { day = day + days [ month - 1 ] ; } return day ; }
int Max_Sum ( int n ) { return ( n * ( n - 1 ) ) / 2 ; }
void convertToBinary ( int num , int a [ ] , int n ) { int pointer = n - 1 ; while ( num > 0 ) { a [ pointer ] = num % 2 ; num = num / 2 ; pointer -- ; } }
void print_seq ( int m ) { int n = ( 2 * m ) ; int a [ ] = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { a [ j ] = 0 ; } for ( int i = 0 ; i < ( int ) Math . pow ( 2 , n ) ; i ++ ) { convertToBinary ( i , a , n ) ; checkforsum ( a , n ) ; } }
boolean isDivisible ( int arr [ ] , int n ) { int lastDigit = arr [ n - 1 ] % 10 ; if ( lastDigit == 0 ) return true ; return false ; }
int solve ( int ang , int n ) { if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) { return 0 ; } else if ( ( ang * n ) % 180 != 0 ) { return 0 ; } int ans = 1 ; int freq = ( ang * n ) / 180 ; ans = ans * ( n - 1 - freq ) ; ans = ans * n ; return ans ; }
void preCompute ( ) { fact [ 0 ] = 1 ; result [ 0 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) { fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD ; result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD ; } }
boolean prime ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
void thirdNumber ( int a , int b ) { int sum = 0 , temp = 0 ; sum = a + b ; temp = 1 ; if ( sum == 0 ) { temp = 2 ; } while ( ! prime ( sum + temp ) ) { temp += 2 ; } System . out . print ( temp ) ; }
long gcd ( long a , long b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; }
long divTermCount ( long a , long b , long c , long num ) { return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( a * b * c ) / gcd ( gcd ( a , b ) , c ) ) ) ) ; }
long findNthTerm ( int a , int b , int c , long n ) { long low = 1 , high = Long . MAX_VALUE , mid ; while ( low < high ) { mid = low + ( high - low ) / 2 ; if ( divTermCount ( a , b , c , mid ) < n ) { low = mid + 1 ; } else { high = mid ; } } return low ; }
int nCr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; }
long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
long divTermCount ( long a , long b , long c , long num ) { return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( a * b * c ) / gcd ( gcd ( a , b ) , c ) ) ) ) ; }
double calculate_angle ( int n , int i , int j , int k ) { int x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; double ang1 = ( 180 * x ) / n ; double ang2 = ( 180 * y ) / n ; double ans = 180 - ang1 - ang2 ; return ans ; }
void getIndex ( int n , int shuffle [ ] [ ] ) { for ( int i = 0 ; i < 3 ; i ++ ) { if ( shuffle [ i ] [ 0 ] == n ) n = shuffle [ i ] [ 1 ] ; else if ( shuffle [ i ] [ 1 ] == n ) n = shuffle [ i ] [ 0 ] ; } System . out . println ( n ) ; }
int calculate ( int n , int k , int m , int power ) { if ( n > m ) { if ( power == 0 ) return 0 ; else return power - 1 ; } else if ( n == m ) return power ; else return calculate ( n * k , k , m , power + 1 ) ; }
void printNumber ( int holes ) { if ( holes == 0 ) System . out . print ( "1" ) ; else if ( holes == 1 ) System . out . print ( "0" ) ; else { int rem = 0 , quo = 0 ; rem = holes % 2 ; quo = holes / 2 ; if ( rem == 1 ) System . out . print ( "4" ) ; for ( int i = 0 ; i < quo ; i ++ ) System . out . print ( "8" ) ; } }
long power ( int p ) { long res = 1 ; for ( int i = 1 ; i <= p ; ++ i ) { res *= 2 ; res %= mod ; } return res % mod ; }
long subset_square_sum ( int A [ ] ) { int n = A . length ; long ans = 0 ; for ( int i : A ) { ans += ( 1 * i * i ) % mod ; ans %= mod ; } return ( 1 * ans * power ( n - 1 ) ) % mod ; }
long fact ( int n ) { long res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
long nCr ( int n , int r ) { return fact ( n ) / ( 1 * fact ( r ) * fact ( n - r ) ) ; }
long number_of_subsequences ( int arr [ ] , int k , int n ) { long s = 0 ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } for ( Map . Entry < Integer , Integer > j : mp . entrySet ( ) ) { s = s + 1 * nCr ( j . getValue ( ) , k ) ; } return s ; }
int minCost ( int arr [ ] , int n ) { int count_even = 0 ; int count_odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count_even ++ ; else count_odd ++ ; } return Math . min ( count_even , count_odd ) ; }
boolean coprime ( int a , int b ) { if ( __gcd ( a , b ) == 1 ) return true ; else return false ; }
void findNumbers ( int a , int b , int n ) { boolean possible = true ; if ( ! coprime ( a , b ) ) possible = false ; int c1 = 1 ; int c2 = 1 ; int num1 , num2 ; HashSet < Integer > st = new HashSet < Integer > ( ) ; if ( possible ) { while ( ( int ) st . size ( ) != n ) { num1 = a + ( c1 * b ) ; if ( isPrime ( num1 ) ) { st . add ( num1 ) ; } c1 ++ ; num2 = b + ( c2 * a ) ; if ( isPrime ( num2 ) ) { st . add ( num2 ) ; } c2 ++ ; } for ( int i : st ) System . out . print ( i + " " ) ; } else System . out . print ( "-1" ) ; }
int sumPairs ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] * ( 2 * n ) ) ; } return sum ; }
int minSum ( Integer arr [ ] , int n ) { int sum = 0 ; Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 4 < 2 ) sum = sum + arr [ i ] ; } return sum ; }
long getCount ( int A , int B2 , int C ) { long count = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { long j = ( B2 / i ) + 1 ; if ( C >= j ) count = ( count + C - j + 1 ) ; if ( A >= j && C >= i ) count = ( count + ( C - i + 1 ) * ( A - j + 1 ) ) ; if ( A >= j ) A = ( int ) ( j - 1 ) ; } return count ; }
int negProdSubArr ( int arr [ ] , int n ) { int positive = 1 , negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; }
int posProdSubArr ( int arr [ ] , int n ) { int total = ( n * ( n + 1 ) ) / 2 ; int cntNeg = negProdSubArr ( arr , n ) ; return ( total - cntNeg ) ; }
int distinctRemainders ( int n ) { if ( n % 2 == 0 ) return ( n / 2 ) ; return ( 1 + ( n / 2 ) ) ; }
int countUnsetBits ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int temp = i ; while ( temp > 0 ) { if ( temp % 2 == 0 ) { cnt = cnt + 1 ; } temp = temp / 2 ; } } return cnt ; }
void least_prime_factor ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( lpf [ i ] == 0 ) for ( int j = i ; j < N ; j += i ) if ( lpf [ j ] == 0 ) lpf [ j ] = i ; }
void Mobius ( ) { for ( int i = 1 ; i < N ; i ++ ) { if ( i == 1 ) mobius [ i ] = 1 ; else { if ( lpf [ i / lpf [ i ] ] == lpf [ i ] ) mobius [ i ] = 0 ; else mobius [ i ] = - 1 * mobius [ i / lpf [ i ] ] ; } } }
int gcd_pairs ( int a [ ] , int n ) { int maxi = 0 ; int [ ] fre = new int [ N ] ; for ( int i = 0 ; i < n ; i ++ ) { fre [ a [ i ] ] ++ ; maxi = Math . max ( a [ i ] , maxi ) ; } least_prime_factor ( ) ; Mobius ( ) ; int ans = 0 ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( mobius [ i ] == 0 ) continue ; int temp = 0 ; for ( int j = i ; j <= maxi ; j += i ) temp += fre [ j ] ; ans += temp * ( temp - 1 ) / 2 * mobius [ i ] ; } return ans ; }
void SieveOfEratosthenes ( ) { int i ; for ( i = 0 ; i < MAX + 1 ; i ++ ) { prime [ i ] = true ; } prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
int xorFirstNPrime ( int n ) { int count = 0 , num = 1 ; int xorVal = 0 ; while ( count < n ) { if ( prime [ num ] ) { xorVal ^= num ; count ++ ; } num ++ ; } return xorVal ; }
int negProdSubArr ( int arr [ ] , int n ) { int positive = 1 , negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; }
int sum ( int n ) { int sum = ( n * ( n + 1 ) ) / 2 ; return sum ; }
int repeatedSum ( int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { n = sum ( n ) ; } return n ; }
boolean isDivisible ( long n ) { long temp = n ; int sum = 0 ; while ( n != 0 ) { int digit = ( int ) n % 10 ; sum += digit ; n /= 10 ; } n = temp ; while ( n != 0 ) { int digit = ( int ) n % 10 ; if ( sum % digit != 0 ) return false ; n /= 10 ; } return true ; }
void least_prime_factor ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( lpf [ i ] % 2 != 1 ) for ( int j = i ; j < N ; j += i ) if ( lpf [ j ] % 2 != 0 ) lpf [ j ] = i ; }
void Mobius ( int n ) { int [ ] mobius = new int [ N ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( i == 1 ) mobius [ i ] = 1 ; else { if ( lpf [ i / lpf [ i ] ] == lpf [ i ] ) mobius [ i ] = 0 ; else mobius [ i ] = - 1 * mobius [ i / lpf [ i ] ] ; } } for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( mobius [ i ] + " " ) ; }
int getBest ( int prev , int cur ) { int maximum = Math . max ( MIN , prev ) ; for ( int i = maximum ; i <= MAX ; i ++ ) { int cnt = 0 ; int a = i ; int b = cur ; for ( int k = 0 ; k < DIGITS ; k ++ ) { if ( a % 10 != b % 10 ) cnt += 1 ; a /= 10 ; b /= 10 ; } if ( cnt <= 1 ) return i ; } return - 1 ; }
void getList ( int arr [ ] , int n ) { Vector < Integer > myList = new Vector < Integer > ( ) ; int i , cur ; boolean possible = true ; myList . add ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) { cur = arr [ i ] ; myList . add ( getBest ( myList . lastElement ( ) , cur ) ) ; if ( myList . lastElement ( ) == - 1 ) { possible = false ; break ; } } if ( possible ) { for ( i = 1 ; i < myList . size ( ) ; i ++ ) System . out . print ( myList . get ( i ) + " " ) ; } else System . out . print ( "-1" ) ; }
int maxItems ( int x , int y , int z ) { int type1 = x / COST ; x %= COST ; int type2 = y / COST ; y %= COST ; int type3 = z / COST ; z %= COST ; int type4 = Math . min ( x , Math . min ( y , z ) ) ; int maxItems = type1 + type2 + type3 + type4 ; return maxItems ; }
int countFactors ( int n , int p ) { int pwr = 0 ; while ( n > 0 && n % p == 0 ) { n /= p ; pwr ++ ; } return pwr ; }
int getCount ( int l , int r , int p ) { int cnt = 0 ; for ( int i = l ; i <= r ; i ++ ) { cnt += countFactors ( i , p ) ; } return cnt ; }
boolean topsyTurvy ( char [ ] str ) { for ( int i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == '2' str [ i ] == '4' str [ i ] == '5' str [ i ] == '6' str [ i ] == '7' str [ i ] == '9' ) { return false ; } } return true ; }
int countSubSeq ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { count ++ ; } } return ( int ) ( Math . pow ( 2 , count ) - 1 ) ; }
int countNum ( int N , int K ) { int [ ] sumPF = new int [ MAX ] ; for ( int i = 2 ; i < N ; i ++ ) { if ( sumPF [ i ] == 0 ) { for ( int j = i ; j < N ; j += i ) { sumPF [ j ] += i ; } } } int count = 0 ; for ( int i = 2 ; i < N ; i ++ ) { if ( sumPF [ i ] == K ) count ++ ; } return count ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < MAX + 1 ; i ++ ) { prime [ i ] = true ; } for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
int smallestPrime ( int d ) { int l = ( int ) Math . pow ( 10 , d - 1 ) ; int r = ( int ) Math . pow ( 10 , d ) - 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( prime [ i ] ) { return i ; } } return - 1 ; }
int largestPrime ( int d ) { int l = ( int ) Math . pow ( 10 , d - 1 ) ; int r = ( int ) Math . pow ( 10 , d ) - 1 ; for ( int i = r ; i >= l ; i -- ) { if ( prime [ i ] ) { return i ; } } return - 1 ; }
void findNumbers ( int a , int b ) { int gcd = findGCD ( a , b ) ; System . out . println ( ( a / gcd ) + " " + ( b / gcd ) ) ; }
boolean possible ( int n ) { if ( n > 3 ) { int sum = ( n * ( n + 1 ) ) / 2 ; if ( sum % 3 == 0 ) { return true ; } } return false ; }
int findNthNumber ( int A , int B , int N ) { int sum = 0 ; for ( int i = 2 ; i < N ; i ++ ) { sum = A + B ; A = B ; B = sum ; } return sum ; }
long modulo ( String num ) { long res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( long ) num . charAt ( i ) - '0' ) % mod ; return res ; }
long findSum ( String L , String R ) { long a , b , l , r , ret ; a = modulo ( L ) ; b = modulo ( R ) ; l = ( ( a * ( a - 1 ) ) % mod * inv2 ) % mod ; r = ( ( b * ( b + 1 ) ) % mod * inv2 ) % mod ; ret = ( r % mod - l % mod ) ; if ( ret < 0 ) ret = ret + mod ; else ret = ret % mod ; return ret ; }
void heapSort ( int arr [ ] , int n ) { for ( int i = n / 2 - 1 ; i >= 0 ; i -- ) heapify ( arr , n , i ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int temp = arr [ 0 ] ; arr [ 0 ] = arr [ i ] ; arr [ i ] = temp ; heapify ( arr , i , 0 ) ; } }
void checkType ( int arr [ ] , int n ) { if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) System . out . println ( "Increasing" ) ; else if ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) System . out . println ( "Decreasing" ) ; else if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) System . out . println ( "Increasing then decreasing" ) ; else System . out . println ( "Decreasing then increasing" ) ; }
void cal_IST ( int h , double r ) { double IST = ( h * r * 1.0 ) / 360 ; int int_IST = ( int ) IST ; int float_IST = ( int ) Math . ceil ( ( int ) ( ( IST - int_IST ) * 60 ) ) ; System . out . println ( int_IST + ":" + float_IST ) ; }
boolean isPossible ( int arr [ ] , int p , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < p ; i ++ ) sum += arr [ i ] ; if ( sum == ( n * m ) ) return true ; return false ; }
int maxSubArraySum ( int a [ ] , int n , int k , int i ) { int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; while ( i < n ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; i += k ; } return max_so_far ; }
int find ( int arr [ ] , int n , int k ) { int maxSum = 0 ; for ( int i = 0 ; i <= Math . min ( n , k ) ; i ++ ) { int sum = 0 ; maxSum = Math . max ( maxSum , maxSubArraySum ( arr , n , k , i ) ) ; } return maxSum ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
void solve ( int n ) { int count = 0 ; for ( int i = 3 ; count < n ; i ++ ) { if ( prime [ i ] ) { System . out . print ( i + " " ) ; count ++ ; } } }
int sum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
void firstN ( int n ) { int num = 19 , cnt = 1 ; while ( cnt != n ) { if ( sum ( num ) == 10 ) { System . out . print ( num + " " ) ; cnt ++ ; } num += 9 ; } }
void compareVal ( int x , int y ) { double a = y * Math . log ( x ) ; double b = x * Math . log ( y ) ; if ( a > b ) System . out . print ( x + "^" + y + " > " + y + "^" + x ) ; else if ( a < b ) System . out . print ( x + "^" + y + " < " + y + "^" + x ) ; else if ( a == b ) System . out . print ( x + "^" + y + " = " + y + "^" + x ) ; }
int countWays ( int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { ans *= 2 ; ans %= MOD ; } return ( ( ans - 1 + MOD ) % MOD ) ; }
void findIntegers ( int n , int a [ ] , int x , int t1 , int t2 ) { boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { int temp = ( int ) Math . pow ( a [ i ] , 2 ) + x ; if ( temp % 10 != t1 && temp % 10 != t2 ) { System . out . print ( temp + " " ) ; flag = false ; } } if ( flag ) { System . out . println ( ) ; System . out . print ( "-1" ) ; } }
void findMin ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; Arrays . sort ( arr ) ; int min = arr [ 0 ] ; int max = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int num = arr [ i ] ; int total = num + min ; int j ; for ( j = 2 ; j <= num ; j ++ ) { if ( num % j == 0 ) { int d = j ; int now = ( num / d ) + ( min * d ) ; int reduce = total - now ; if ( reduce > max ) max = reduce ; } } } System . out . println ( sum - max ) ; }
boolean Survives ( int n ) { for ( int i = 2 ; ; i ++ ) { if ( i > n ) return true ; if ( n % i == 0 ) return false ; n -= n / i ; } }
int digitSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += n % TEN ; n /= TEN ; } return sum ; }
int getNthTerm ( int n ) { int sum = digitSum ( n ) ; if ( sum % TEN == 0 ) return ( n * TEN ) ; int extra = TEN - ( sum % TEN ) ; return ( ( n * TEN ) + extra ) ; }
void firstNTerms ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( getNthTerm ( i ) + " " ) ; }
int nthXorFib ( int n , int a , int b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return ( a ^ b ) ; return nthXorFib ( n % 3 , a , b ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void flip ( int a , int b ) { int lcm = ( a * b ) / gcd ( a , b ) ; a = lcm / a ; b = lcm / b ; System . out . print ( ( a - 1 ) + " " + ( b - 1 ) ) ; }
void findRemainder ( int n ) { int l = n % 10 ; while ( n >= 10 ) n /= 10 ; int f = n ; int remainder = f % l ; System . out . println ( remainder ) ; }
double increaseInVol ( double l , double b , double h ) { double percentInc = ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ; percentInc -= 1 ; percentInc *= 100 ; return percentInc ; }
int countOccurrances ( int n , int d ) { int count = 0 ; while ( n > 0 ) { count = ( n % 10 == d ) ? count + 1 : count ; n = n / 10 ; } return count ; }
void findFactors ( int a , int b ) { int c ; c = a + b - 1 ; System . out . print ( c ) ; }
int countKdivPairs ( int A [ ] , int n , int K ) { int [ ] freq = new int [ K ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int rem = A [ i ] % K ; ans += freq [ ( K - rem ) % K ] ; freq [ rem ] ++ ; } return ans ; }
void expressDigit ( int arr [ ] , int n ) { int min = 9 , index = 0 , temp = 0 ; temp = arr [ 0 ] ; for ( int i = 1 ; i < 10 ; i ++ ) { if ( arr [ i ] < min ) { min = arr [ i ] ; index = i ; } } if ( temp < min ) { System . out . print ( 1 ) ; for ( int i = 1 ; i <= temp + 1 ; i ++ ) System . out . print ( 0 ) ; } else { for ( int i = 0 ; i < min ; i ++ ) System . out . print ( index ) ; System . out . print ( index ) ; } }
int countDigits ( int num ) { int cnt = 0 ; while ( num > 0 ) { cnt ++ ; num /= 10 ; } return cnt ; }
int sumFromStart ( int num , int n , int rem ) { num /= ( ( int ) Math . pow ( 10 , rem ) ) ; int sum = 0 ; while ( num > 0 ) { sum += ( num % 10 ) ; num /= 10 ; } return sum ; }
int sumFromEnd ( int num , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ( num % 10 ) ; num /= 10 ; } return sum ; }
float getAverage ( int n , int k , int l ) { int totalDigits = countDigits ( n ) ; if ( totalDigits < ( k + l ) ) return - 1 ; int sum1 = sumFromEnd ( n , l ) ; int sum2 = sumFromStart ( n , k , totalDigits - k ) ; return ( ( float ) ( sum1 + sum2 ) / ( float ) ( k + l ) ) ; }
int totalways ( int [ ] arr , int n ) { HashMap < Integer , Integer > cnt = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( cnt . containsKey ( arr [ i ] ) ) { cnt . put ( arr [ i ] , cnt . get ( arr [ i ] ) + 1 ) ; } else { cnt . put ( arr [ i ] , 1 ) ; } } if ( n % 2 == 1 ) { int start = 0 , endd = n - 1 ; for ( int i = start ; i <= endd ; i = i + 2 ) { if ( i == 0 ) { if ( cnt . get ( i ) != 1 ) { return 0 ; } } else { if ( cnt . get ( i ) != 2 ) { return 0 ; } } } int ways = 1 ; start = 2 ; endd = n - 1 ; for ( int i = start ; i <= endd ; i = i + 2 ) { ways = ways * 2 ; } return ways ; } else if ( n % 2 == 0 ) { int start = 1 , endd = n - 1 ; for ( int i = 1 ; i <= endd ; i = i + 2 ) { if ( cnt . get ( i ) != 2 ) return 0 ; } int ways = 1 ; for ( int i = start ; i <= endd ; i = i + 2 ) { ways = ways * 2 ; } return ways ; } return Integer . MIN_VALUE ; }
int proizvolov ( int a [ ] , int b [ ] , int n ) { return n * n ; }
void compareValues ( int a , int b , int c , int d ) { double log1 = Math . log10 ( a ) ; double num1 = log1 * b ; double log2 = Math . log10 ( c ) ; double num2 = log2 * d ; if ( num1 > num2 ) System . out . println ( a + "^" + b ) ; else System . out . println ( c + "^" + d ) ; }
double sum ( double a , double b , double c , double d , double x ) { double ans = ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ; return ans ; }
double calculateLnx ( double n ) { double num , mul , cal , sum = 0 ; num = ( n - 1 ) / ( n + 1 ) ; for ( int i = 1 ; i <= 1000 ; i ++ ) { mul = ( 2 * i ) - 1 ; cal = Math . pow ( num , mul ) ; cal = cal / mul ; sum = sum + cal ; } sum = 2 * sum ; return sum ; }
double calculateLogx ( double lnx ) { return ( lnx / 2.303 ) ; }
void printRoots ( long a , long b , long c ) { System . out . println ( 1 + ", " + c / ( a * 1.0 ) ) ; }
int permutation ( String str1 , int i , int n , int p ) { if ( i == n ) { int q = Integer . parseInt ( str1 ) ; if ( q - p > 0 && q < min1 ) { min1 = q ; count = 1 ; } } else { for ( int j = i ; j <= n ; j ++ ) { str1 = swap ( str1 , i , j ) ; permutation ( str1 , i + 1 , n , p ) ; str1 = swap ( str1 , i , j ) ; } } return min1 ; }
int longestAlternativeSequence ( int a [ ] , int n ) { int maxi1 = 0 ; int f1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( f1 % 2 != 0 ) { if ( a [ i ] % 2 == 1 ) { f1 = 1 ; maxi1 ++ ; } } else { if ( a [ i ] % 2 == 0 ) { maxi1 ++ ; f1 = 0 ; } } } int maxi2 = 0 ; int f2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( f2 % 2 != 0 ) { if ( a [ i ] % 2 == 1 ) { f2 = 1 ; maxi2 ++ ; } } else { if ( a [ i ] % 2 == 0 ) { maxi2 ++ ; f2 = 0 ; } } } return Math . max ( maxi1 , maxi2 ) ; }
int Cells ( int n , int x ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && x / i <= n ) ans ++ ; return ans ; }
int Cells ( int n , int x ) { if ( n <= 0 x <= 0 x > n * n ) return 0 ; int i = 0 , count = 0 ; while ( ++ i * i < x ) if ( x % i == 0 && x <= n * i ) count += 2 ; return i * i == x ? count + 1 : count ; }
void ZigZag ( int n ) { long [ ] fact = new long [ n + 1 ] ; long [ ] zig = new long [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) zig [ i ] = 0 ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; zig [ 0 ] = 1 ; zig [ 1 ] = 1 ; System . out . print ( "zig zag numbers: " ) ; System . out . print ( zig [ 0 ] + " " + zig [ 1 ] + " " ) ; for ( int i = 2 ; i < n ; i ++ ) { long sum = 0 ; for ( int k = 0 ; k <= i - 1 ; k ++ ) { sum += ( fact [ i - 1 ] / ( fact [ i - 1 - k ] * fact [ k ] ) ) * zig [ k ] * zig [ i - 1 - k ] ; } zig [ i ] = sum / 2 ; System . out . print ( sum / 2 + " " ) ; } }
int evenNumSubstring ( String str ) { int len = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str . charAt ( i ) - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
float Depreciation ( float v , float r , float t ) { float D = ( float ) ( v * Math . pow ( ( 1 - r / 100 ) , t ) ) ; return D ; }
int nextPowerOfFour ( int n ) { int x = ( int ) Math . floor ( Math . sqrt ( Math . sqrt ( n ) ) ) ; if ( Math . pow ( x , 4 ) == n ) return n ; else { x = x + 1 ; return ( int ) Math . pow ( x , 4 ) ; } }
int Alcuin ( int n ) { double _n = n , ans ; ans = Math . round ( ( _n * _n ) / 12 ) - Math . floor ( _n / 4 ) * Math . floor ( ( _n + 2 ) / 4 ) ; return ( int ) ans ; }
void solve ( int n ) { int i = 0 ; for ( i = 1 ; i <= n ; i ++ ) { System . out . print ( Alcuin ( i ) + ", " ) ; } }
int find_count ( Vector < Integer > ele ) { int count = 0 ; for ( int i = 0 ; i < ele . size ( ) ; i ++ ) { Vector < Integer > p = new Vector < Integer > ( ) ; int c = 0 ; for ( int j = ele . size ( ) - 1 ; j >= ( ele . size ( ) - 1 - i ) && j >= 0 ; j -- ) { p . add ( ele . get ( j ) ) ; } int j = ele . size ( ) - 1 , k = 0 ; while ( j >= 0 ) { if ( ele . get ( j ) != p . get ( k ) ) { break ; } j -- ; k ++ ; if ( k == p . size ( ) ) { c ++ ; k = 0 ; } } count = Math . max ( count , c ) ; } return count ; }
void solve ( int n ) { int count = 1 ; Vector < Integer > ele = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( count + ", " ) ; ele . add ( count ) ; count = find_count ( ele ) ; } }
int speedOfTrain ( float X , float Y ) { float Speed ; Speed = 1188 * ( ( X - Y ) / Y ) ; return ( int ) Speed ; }
int Division ( int a [ ] , int n ) { int maxi = Integer . MIN_VALUE , mini = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { maxi = Math . max ( a [ i ] , maxi ) ; mini = Math . min ( a [ i ] , mini ) ; } return maxi / mini ; }
Vector < Integer > addPrimes ( ) { int n = MAX ; boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) ans . add ( p ) ; return ans ; }
int find_Sum ( int n ) { int sum = 0 ; Vector < Integer > v = addPrimes ( ) ; for ( int i = 0 ; i < v . size ( ) && n > 0 ; i ++ ) { int flag = 1 ; int a = v . get ( i ) ; while ( a != 0 ) { int d = a % 10 ; a = a / 10 ; if ( is_prime ( d ) ) { flag = 0 ; break ; } } if ( flag == 1 ) { n -- ; sum = sum + v . get ( i ) ; } } return sum ; }
Vector < Integer > addPrimes ( ) { int n = MAX ; boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) ans . add ( p ) ; return ans ; }
int pi ( int x , Vector < Integer > v ) { int l = 0 , r = v . size ( ) - 1 , m , in = - 1 ; while ( l <= r ) { m = ( l + r ) / 2 ; if ( v . get ( m ) <= x ) { in = m ; l = m + 1 ; } else { r = m - 1 ; } } return in + 1 ; }
int Ramanujan ( int n , Vector < Integer > v ) { int upperbound = ( int ) ( 4 * n * ( Math . log ( 4 * n ) / Math . log ( 2 ) ) ) ; for ( int i = upperbound ; ; i -- ) { if ( pi ( i , v ) - pi ( i / 2 , v ) < n ) return 1 + i ; } }
void Ramanujan_Numbers ( int n ) { int c = 1 ; Vector < Integer > v = addPrimes ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( Ramanujan ( i , v ) ) ; if ( i != n ) System . out . print ( ", " ) ; } }
void solveEven ( int n , int arr [ ] , int b [ ] ) { int left = n - 1 ; for ( int i = 0 ; i < ( n / 2 ) ; ++ i ) { b [ i ] = arr [ left ] ; left = left - 2 ; if ( left < 0 ) break ; } int right = 0 ; for ( int i = n / 2 ; i <= n - 1 ; ++ i ) { b [ i ] = arr [ right ] ; right = right + 2 ; if ( right > n - 2 ) break ; } }
void solve ( int n , int arr [ ] ) { int b [ ] = new int [ n ] ; if ( n % 2 == 0 ) solveEven ( n , arr , b ) ; else solveOdd ( n , arr , b ) ; for ( int i = 0 ; i <= n - 1 ; ++ i ) { System . out . print ( b [ i ] + " " ) ; } }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
int NumberOfWays ( int X , int Y , int M , int N ) { return fact ( X + Y ) * nCr ( M , X ) * nCr ( N , Y ) ; }
int Wedderburn ( int n ) { if ( n <= 2 ) return store . get ( n ) ; else if ( n % 2 == 0 ) { int x = n / 2 , ans = 0 ; for ( int i = 1 ; i < x ; i ++ ) { ans += store . get ( i ) * store . get ( n - i ) ; } ans += ( store . get ( x ) * ( store . get ( x ) + 1 ) ) / 2 ; store . put ( n , ans ) ; return ans ; } else { int x = ( n + 1 ) / 2 , ans = 0 ; for ( int i = 1 ; i < x ; i ++ ) { ans += store . get ( i ) * store . get ( n - i ) ; } store . put ( n , ans ) ; return ans ; } }
void Wedderburn_Etherington ( int n ) { store . put ( 0 , 0 ) ; store . put ( 1 , 1 ) ; store . put ( 2 , 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( Wedderburn ( i ) ) ; if ( i != n - 1 ) System . out . print ( " " ) ; } }
int factorial ( int n ) { if ( n <= 1 ) return 1 ; return n * factorial ( n - 1 ) ; }
int nCr ( int n , int r ) { return factorial ( n ) / ( factorial ( n - r ) * factorial ( r ) ) ; }
int NumberOfWays ( int n , int x , int y ) { return nCr ( 2 * n - x - y , n - x ) * factorial ( n ) * factorial ( n ) ; }
int fact ( int n ) { int i = 1 , fac = 1 ; for ( i = 1 ; i <= n ; i ++ ) fac = fac * i ; return fac ; }
double log_Expansion ( double x , int n ) { double sum = 0 ; int i = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum = sum + Math . pow ( x , 2 * i ) / fact ( 2 * i ) ; } return sum ; }
void prime_range ( int start , int end , int [ ] a ) { for ( int i = start ; i < end ; i ++ ) { if ( prime ( a [ i ] ) ) System . out . print ( a [ i ] + " " ) ; } }
int countElements ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; float mean = ( float ) sum / n ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { float newMean = ( float ) ( sum - arr [ i ] ) / ( n - 1 ) ; if ( newMean == mean ) cnt ++ ; } return cnt ; }
boolean Prime ( int n ) { for ( int j = 2 ; j <= Math . sqrt ( n ) ; j ++ ) if ( n % j == 0 ) return false ; return true ; }
int find_prime ( int x , int xsqmodp , int y , int ysqmodp ) { int n = x * x - xsqmodp ; int n1 = y * y - ysqmodp ; for ( int j = 2 ; j <= Math . max ( Math . sqrt ( n ) , Math . sqrt ( n1 ) ) ; j ++ ) { if ( n % j == 0 && ( x * x ) % j == xsqmodp && n1 % j == 0 && ( y * y ) % j == ysqmodp ) if ( Prime ( j ) ) return j ; int j1 = n / j ; if ( n % j1 == 0 && ( x * x ) % j1 == xsqmodp && n1 % j1 == 0 && ( y * y ) % j1 == ysqmodp ) if ( Prime ( j1 ) ) return j1 ; j1 = n1 / j ; if ( n % j1 == 0 && ( x * x ) % j1 == xsqmodp && n1 % j1 == 0 && ( y * y ) % j1 == ysqmodp ) if ( Prime ( j1 ) ) return j1 ; } if ( n == n1 ) return n ; return Integer . MIN_VALUE ; }
int numberOfMinutes ( int S , int S1 ) { int Min = 0 ; Min = ( int ) ( ( ( S - S1 ) / Math . floor ( S ) ) * 60 ) ; return Min ; }
int FindElement ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + a [ i ] ; if ( sum % n == 0 ) { int m = sum / n ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == m ) return m ; } return - 1 ; }
int fac ( int num ) { if ( num == 0 ) return 1 ; int fact = 1 ; for ( int i = 1 ; i <= num ; i ++ ) fact = fact * i ; return fact ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int Max_sum ( int a [ ] , int n ) { int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) pos = 1 ; else if ( a [ i ] < 0 ) neg = 1 ; if ( ( pos == 1 ) && ( neg == 1 ) ) break ; } int sum = 0 ; if ( ( pos == 1 ) && ( neg == 1 ) ) { for ( int i = 0 ; i < n ; i ++ ) sum += Math . abs ( a [ i ] ) ; } else if ( pos == 1 ) { int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = Math . min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } else if ( neg == 1 ) { for ( int i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ; int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = Math . min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } return sum ; }
boolean checkcomposite ( int n ) { for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { return true ; } } return false ; }
int power ( int x , int y , int mod ) { int res = 1 ; while ( y != 0 ) { if ( ( y & 1 ) == 1 ) { res = ( res * x ) % mod ; } y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
int Check ( int n , int a ) { if ( a > 1 && checkcomposite ( n ) && power ( a , n - 1 , n ) == 1 ) { return 1 ; } return 0 ; }
int count ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int cnt = 0 ; int i = 0 , j = 1 ; while ( i < n && j < n ) { j = ( j <= i ) ? ( i + 1 ) : j ; while ( j < n && ( arr [ j ] - arr [ i ] ) < k ) j ++ ; cnt += ( n - j ) ; i ++ ; } return cnt ; }
int factorial ( int n ) { if ( n <= 1 ) return 1 ; return n * factorial ( n - 1 ) ; }
int nCr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; }
float Probability ( int M , int N , int X ) { return ( float ) ( nCr ( M - N - 1 , X - 2 ) / ( nCr ( M - 1 , X - 1 ) * 1.0 ) ) ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int Count_number ( int N ) { return ( N * fact ( N ) ) ; }
int fact ( int n ) { if ( n <= 1 ) return 1 ; return n * fact ( n - 1 ) ; }
int nPr ( int n , int r ) { return fact ( n ) / fact ( n - r ) ; }
void decimalToBinary ( int n ) { if ( n == 0 ) { System . out . print ( "0" ) ; return ; } decimalToBinary ( n / 2 ) ; System . out . print ( n % 2 ) ; }
void MinimumValue ( int x , int y ) { if ( x > y ) { int temp = x ; x = y ; y = temp ; } int a = 1 ; int b = x - 1 ; int c = y - b ; System . out . print ( a + " " + b + " " + c ) ; }
int getHeight ( int X ) { return ( 2 * X ) ; }
double volumeRec ( double a , double b , double e , double h ) { return ( ( ( b * h ) / 6 ) * ( 2 * a + e ) ) ; }
int firstSetBit ( int n ) { int x = n & ( n - 1 ) ; return ( n ^ x ) ; }
int NoofSequences ( int N , int M ) { HashMap < Integer , Integer > prime = new HashMap < > ( ) ; for ( int i = 2 ; i <= Math . sqrt ( M ) ; i ++ ) { while ( M % i == 0 ) { if ( prime . get ( i ) == null ) prime . put ( i , 1 ) ; else { int x = prime . get ( i ) ; prime . put ( i , ++ x ) ; } M /= i ; } } if ( M > 1 ) { if ( prime . get ( M ) != null ) { int x = prime . get ( M ) ; prime . put ( M , ++ x ) ; } else prime . put ( M , 1 ) ; } int ans = 1 ; for ( HashMap . Entry < Integer , Integer > entry : prime . entrySet ( ) ) { ans *= ( nCr ( N + entry . getValue ( ) - 1 , N - 1 ) ) ; } return ans ; }
int findHours ( int a , int b , int k ) { if ( a >= b ) return - 1 ; int time = k / ( b - a ) ; time = time + 1 ; return time ; }
int countQuadruples ( int N , int K ) { int M = N / K ; int answer = nCr ( M ) ; for ( int i = 2 ; i < M ; i ++ ) { int j = i ; int temp2 = M / i ; int count = 0 ; int check = 0 ; int temp = j ; while ( j % 2 == 0 ) { count ++ ; j /= 2 ; if ( count >= 2 ) break ; } if ( count >= 2 ) { check = 1 ; } for ( int k = 3 ; k <= Math . sqrt ( temp ) ; k += 2 ) { int cnt = 0 ; while ( j % k == 0 ) { cnt ++ ; j /= k ; if ( cnt >= 2 ) break ; } if ( cnt >= 2 ) { check = 1 ; break ; } else if ( cnt == 1 ) count ++ ; } if ( j > 2 ) { count ++ ; } if ( check == 1 ) continue ; else { if ( count % 2 == 1 ) { answer -= nCr ( temp2 ) ; } else { answer += nCr ( temp2 ) ; } } } return answer ; }
int minimum_sum ( int n , int k ) { if ( k % n == 0 ) return 0 ; return 1 ; }
int ncr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; }
int NoOfDistributions ( int N , int R ) { return ncr ( N - 1 , R - 1 ) ; }
int ncr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; }
int NoOfDistributions ( int N , int R ) { return ncr ( N + R - 1 , R - 1 ) ; }
int maxElement ( int a [ ] , int n ) { if ( n < 3 ) return - 1 ; int maxElement = a [ 0 ] ; int maxProd = a [ n - 1 ] * a [ 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { int currProd = a [ i - 1 ] * a [ ( i + 1 ) % n ] ; if ( currProd > maxProd ) { maxProd = currProd ; maxElement = a [ i ] ; } else if ( currProd == maxProd ) { maxElement = Math . max ( maxElement , a [ i ] ) ; } } return maxElement ; }
int totalWays ( int X , int Y , int M , int W ) { return ( ncr ( M , X ) * ncr ( W , Y ) ) ; }
boolean checkPerfectcube ( int n ) { int d = ( int ) Math . cbrt ( n ) ; if ( d * d * d == n ) return true ; return false ; }
int smallestPerfectCube ( int a [ ] , int n ) { int mini = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkPerfectcube ( a [ i ] ) ) { mini = Math . min ( a [ i ] , mini ) ; } } return mini ; }
void Vertices ( int x , int y ) { int val = Math . abs ( x ) + Math . abs ( y ) ; System . out . print ( val * ( x < 0 ? - 1 : 1 ) + " 0 " ) ; System . out . print ( "0 " + val * ( y < 0 ? - 1 : 1 ) ) ; }
double SumofInverseDivisors ( int N , int Sum ) { double ans = ( double ) ( Sum ) * 1.0 / ( double ) ( N ) ; return ans ; }
void CheckSubarray ( int arr [ ] , int N ) { int presum [ ] = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 1 ) { presum [ i ] = presum [ i - 1 ] + arr [ i - 1 ] ; } for ( int i = 1 ; i <= N ; i += 1 ) { for ( int j = i ; j <= N ; j += 1 ) { if ( ( presum [ j ] - presum [ i - 1 ] ) % N == 0 ) { System . out . print ( ( i - 1 ) + " " + ( j - 1 ) ) ; return ; } } } System . out . print ( - 1 ) ; }
void CheckSubarray ( int arr [ ] , int N ) { int [ ] presum = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 1 ) { presum [ i ] = presum [ i - 1 ] + arr [ i - 1 ] ; } Vector < Integer > [ ] moduloclass = new Vector [ N ] ; for ( int i = 0 ; i < N ; i += 1 ) { moduloclass [ i ] = new Vector < > ( ) ; } for ( int i = 1 ; i <= N ; i += 1 ) { moduloclass [ presum [ i ] % N ] . add ( i - 1 ) ; } if ( moduloclass [ 0 ] . size ( ) > 0 ) { System . out . print ( 0 + " " + moduloclass [ 0 ] . get ( 0 ) ) ; return ; } for ( int i = 1 ; i < N ; i += 1 ) { if ( moduloclass [ i ] . size ( ) >= 2 ) { System . out . print ( moduloclass [ i ] . get ( 0 ) + 1 + " " + moduloclass [ i ] . get ( 1 ) ) ; return ; } } }
int findNearestNumber ( int n ) { int cnt = countBits ( n ) ; cnt -= 1 ; if ( cnt % 2 == 1 ) { return 1 << ( cnt + 1 ) ; } else { int tempnum = 0 ; for ( int i = 0 ; i <= cnt ; i += 2 ) { tempnum += 1 << i ; } if ( tempnum < n ) { return ( 1 << ( cnt + 2 ) ) ; } else if ( tempnum == n ) { return n ; } for ( int i = 0 ; i <= cnt ; i += 2 ) { tempnum -= ( 1 << i ) ; if ( tempnum < n ) { return tempnum += ( 1 << i ) ; } } } return Integer . MIN_VALUE ; }
int getX ( int a , int b , int c , int d ) { int X = ( b * c - a * d ) / ( d - c ) ; return X ; }
int NoofTriplets ( int N , int K ) { int [ ] cnt = new int [ K ] ; Arrays . fill ( cnt , 0 , cnt . length , 0 ) ; for ( int i = 1 ; i <= N ; i += 1 ) { cnt [ i % K ] += 1 ; } if ( ( K & 1 ) != 0 ) { return cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] ; } else { return ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K / 2 ] * cnt [ K / 2 ] * cnt [ K / 2 ] ) ; } }
int countNum ( int n ) { if ( n == 1 ) return 1 ; int count = ( int ) Math . pow ( 2 , n - 2 ) ; return count ; }
int binaryToDecimal ( String n ) { String num = n ; int dec_value = 0 ; int base = 1 ; int len = num . length ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( num . charAt ( i ) == '1' ) dec_value += base ; base = base * 2 ; } return dec_value ; }
int findNumber ( int n ) { String s = constructString ( n - 1 ) ; int num = binaryToDecimal ( s ) ; return num ; }
int findNumber ( int n ) { int num = n - 1 ; num = 2 * ( int ) Math . pow ( 4 , num ) ; num = ( int ) Math . floor ( num / 3.0 ) ; return num ; }
int bitonic_point ( Node node ) { if ( node == null ) return - 1 ; if ( node . next == null ) return - 1 ; if ( node . data > node . next . data ) return - 1 ; while ( node . next != null ) { if ( node . data > node . next . data ) break ; node = node . next ; } int bitonicPoint = node . data ; while ( node . next != null ) { if ( node . data < node . next . data ) return - 1 ; node = node . next ; } return bitonicPoint ; }
int minSum ( int a [ ] , int n ) { Arrays . sort ( a ) ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }
boolean canConvert ( int a , int b ) { while ( b > a ) { if ( b % 10 == 1 ) { b /= 10 ; continue ; } if ( b % 2 == 0 ) { b /= 2 ; continue ; } return false ; } if ( b == a ) return true ; return false ; }
int MinRemove ( int [ ] a , int n , int k ) { int [ ] cnt = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) cnt [ 0 ] ++ ; else if ( cnt [ a [ i ] - 1 ] > 0 ) { cnt [ a [ i ] - 1 ] -- ; cnt [ a [ i ] ] ++ ; } } return n - ( k * cnt [ k - 1 ] ) ; }
int mosaic ( int n ) { int i , ans = 1 ; for ( i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 && n > 0 ) { int count = 0 ; while ( n % i == 0 ) { n /= i ; count ++ ; } ans *= count * i ; } } return ans ; }
void nMosaicNumbers ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( mosaic ( i ) + " " ) ; }
int mosaic ( int n ) { int i , ans = 1 ; for ( i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 && n > 0 ) { int count = 0 ; while ( n % i == 0 ) { n /= i ; count ++ ; } ans *= count * i ; } } return ans ; }
void lowerWythoff ( int n ) { double phi = ( 1 + Math . sqrt ( 5 ) ) / 2.0 ; for ( int i = 1 ; i <= n ; i ++ ) { double ans = Math . floor ( i * phi ) ; System . out . print ( ( int ) ans ) ; if ( i != n ) System . out . print ( " , " ) ; } }
int Total_Ways ( int n ) { int fac = 1 ; for ( int i = 2 ; i <= n - 1 ; i ++ ) { fac = fac * i ; } return ( fac * 2 ) ; }
int MaxNumbers ( int a [ ] , int n ) { int [ ] fre = { 0 , 0 , 0 } ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] %= 3 ; fre [ a [ i ] ] ++ ; } int ans = fre [ 0 ] ; int k = Math . min ( fre [ 1 ] , fre [ 2 ] ) ; ans += k ; fre [ 1 ] -= k ; fre [ 2 ] -= k ; ans += fre [ 1 ] / 3 + fre [ 2 ] / 3 ; return ans ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
int pairs ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = countSetBits ( arr [ i ] ) + countSetBits ( arr [ j ] ) ; if ( sum == k ) count ++ ; } } return count ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
int pairs ( int arr [ ] , int n , int k ) { int count = 0 ; int [ ] f = new int [ MAX + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) f [ countSetBits ( arr [ i ] ) ] ++ ; for ( int i = 0 ; i <= MAX ; i ++ ) { for ( int j = i ; j <= MAX ; j ++ ) { if ( i + j == k ) { if ( i == j ) count += ( ( f [ i ] * ( f [ i ] - 1 ) ) / 2 ) ; else count += ( f [ i ] * f [ j ] ) ; } } } return count ; }
int composite_factors ( int n ) { int count = 0 ; int i , j ; int [ ] a = new int [ n + 1 ] ; for ( i = 0 ; i < n ; i ++ ) { a [ i ] = 0 ; } for ( i = 1 ; i <= n ; ++ i ) { if ( n % i == 0 ) { a [ i ] = i ; } } for ( i = 2 ; i <= n ; i ++ ) { j = 2 ; int p = 1 ; while ( j < a [ i ] ) { if ( a [ i ] % j == 0 ) { p = 0 ; break ; } j ++ ; } if ( p == 0 && a [ i ] != 0 ) { count ++ ; } } return count ; }
int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; }
void specialSieve ( int n ) { int cnt = 0 ; int prime [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! ( prime [ i ] > 0 ) ) { cnt ++ ; for ( int j = i ; j <= n ; j += i ) prime [ j ] = cnt ; } } for ( int i = 2 ; i <= n ; i ++ ) System . out . print ( prime [ i ] + " " ) ; }
int sumOfMersenne ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 && isMersenne ( arr [ i ] ) ) { sum += arr [ i ] ; } } return sum ; }
int sumOfFactors ( int n ) { int sum = 0 ; for ( int f = 1 ; f <= n / 2 ; f ++ ) { if ( n % f == 0 ) { sum += f ; } } return sum ; }
boolean sameLength ( int A , int B ) { while ( ( A > 0 ) && ( B > 0 ) ) { A = A / 10 ; B = B / 10 ; } if ( ( A == 0 ) && ( B == 0 ) ) return true ; return false ; }
void preProcess ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) cnt_neg ++ ; if ( arr [ i ] == 0 ) exists_zero = true ; } }
int FindXorSum ( int arr [ ] , int k , int n ) { if ( n < k ) return 0 ; int [ ] x = new int [ n ] ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 ) x [ i ] = x [ i - 1 ] ^ arr [ i ] ; else x [ i ] = arr [ i ] ; if ( i >= k - 1 ) { int sum = 0 ; sum = x [ i ] ; if ( i - k > - 1 ) sum ^= x [ i - k ] ; result += sum ; } } return result ; }
int reverse ( int n ) { int rev = 0 ; while ( n > 0 ) { int d = n % 10 ; rev = rev * 10 + d ; n = n / 10 ; } return rev ; }
boolean isPalin ( int n ) { return ( n == reverse ( n ) ) ; }
int countDigits ( int n ) { int c = 0 ; while ( n > 0 ) { n = n / 10 ; c ++ ; } return c ; }
int countPalinDigits ( int [ ] arr , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 10 || isPalin ( arr [ i ] ) ) { s += countDigits ( arr [ i ] ) ; } } return s ; }
int reverse ( int n ) { int d = 0 , s = 0 ; while ( n > 0 ) { d = n % 10 ; s = s * 10 + d ; n = n / 10 ; } return s ; }
boolean isPalin ( int n ) { return n == reverse ( n ) ; }
int sumOfArray ( int [ ] arr , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] > 10 ) && isPalin ( arr [ i ] ) ) { s += arr [ i ] ; } } return s ; }
boolean isVowel ( char ch ) { if ( ch == 'a' ch == 'e' ch == 'i' ch == 'o' ch == 'u' ) return true ; else return false ; }
long fact ( long n ) { if ( n < 2 ) { return 1 ; } return n * fact ( n - 1 ) ; }
long only_vowels ( HashMap < Character , Integer > freq ) { long denom = 1 ; long cnt_vwl = 0 ; for ( Map . Entry < Character , Integer > itr : freq . entrySet ( ) ) { if ( isVowel ( itr . getKey ( ) ) ) { denom *= fact ( itr . getValue ( ) ) ; cnt_vwl += itr . getValue ( ) ; } } return fact ( cnt_vwl ) / denom ; }
long all_vowels_together ( HashMap < Character , Integer > freq ) { long vow = only_vowels ( freq ) ; long denom = 1 ; long cnt_cnst = 0 ; for ( Map . Entry < Character , Integer > itr : freq . entrySet ( ) ) { if ( ! isVowel ( itr . getKey ( ) ) ) { denom *= fact ( itr . getValue ( ) ) ; cnt_cnst += itr . getValue ( ) ; } } long ans = fact ( cnt_cnst + 1 ) / denom ; return ( ans * vow ) ; }
long no_vowels_together ( String word ) { HashMap < Character , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) { char ch = Character . toLowerCase ( word . charAt ( i ) ) ; if ( freq . containsKey ( ch ) ) { freq . put ( ch , freq . get ( ch ) + 1 ) ; } else { freq . put ( ch , 1 ) ; } } long total = total_permutations ( freq ) ; long vwl_tgthr = all_vowels_together ( freq ) ; long res = total - vwl_tgthr ; return res ; }
void updatePrimes ( ) { for ( int i = 2 ; i <= MAX ; i ++ ) { prime [ i ] = 1 ; } prime [ 0 ] = prime [ 1 ] = 0 ; for ( int i = 2 ; i * i <= MAX ; i ++ ) { if ( prime [ i ] == 1 ) { for ( int j = i * i ; j <= MAX ; j += i ) { prime [ j ] = 0 ; } } } for ( int i = 1 ; i <= MAX ; i ++ ) { prime [ i ] += prime [ i - 1 ] ; } }
int getDifference ( int l , int r ) { int total = r - l + 1 ; int primes = prime [ r ] - prime [ l - 1 ] ; int composites = total - primes ; return ( Math . abs ( primes - composites ) ) ; }
double e ( int x , int n ) { double r ; if ( n == 0 ) return 1 ; r = e ( x , n - 1 ) ; p = p * x ; f = f * n ; return ( r + p / f ) ; }
void constructSieve ( ) { for ( int i = 2 ; i <= MAX ; i ++ ) { if ( Sieve [ i ] == 0 ) { for ( int j = 2 * i ; j <= MAX ; j += i ) { int temp = j ; while ( temp > 1 && temp % i == 0 ) { Sieve [ j ] ++ ; temp = temp / i ; } } } } }
void checkElements ( int A [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( Sieve [ A [ i ] ] == k ) { System . out . println ( "YES" ) ; } else { System . out . println ( "No" ) ; } } }
long modularexpo ( long x , long y , long p ) { long res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
void multiply ( long F [ ] [ ] , long M [ ] [ ] , long m ) { long x = ( ( F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] ) % m + ( F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ) % m ) % m ; long y = ( ( F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] ) % m + ( F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ) % m ) % m ; long z = ( ( F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] ) % m + ( F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ) % m ) % m ; long w = ( ( F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] ) % m + ( F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ) % m ) % m ; F [ 0 ] [ 0 ] = x ; F [ 0 ] [ 1 ] = y ; F [ 1 ] [ 0 ] = z ; F [ 1 ] [ 1 ] = w ; }
void power ( long F [ ] [ ] , long n , long m ) { if ( n == 0 n == 1 ) return ; long M [ ] [ ] = { { 1 , 1 } , { 1 , 0 } } ; power ( F , n / 2 , m ) ; multiply ( F , F , m ) ; if ( n % 2 != 0 ) multiply ( F , M , m ) ; }
long fib ( long n , long m ) { long F [ ] [ ] = { { 1 , 1 } , { 1 , 0 } } ; if ( n == 0 ) return 0 ; power ( F , n - 1 , m ) ; return F [ 0 ] [ 0 ] ; }
int cntWays ( int arr [ ] , int n ) { if ( n == 1 ) { return 0 ; } int tot_sum = 0 , sum = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { tot_sum += arr [ i ] ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { sum += arr [ i ] ; if ( sum == tot_sum / 2 ) { ans ++ ; } } return ans ; }
void power_2 ( ) { long ans = 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { pow2 [ i ] = ans ; ans *= 2 ; } }
int countSetBits ( long x ) { int setBits = 0 ; while ( x != 0 ) { x = x & ( x - 1 ) ; setBits ++ ; } return setBits ; }
void add ( long num ) { int point = 0 ; long value = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( visited [ i ] ) continue ; else { if ( num % 2 == 1 ) { value += ( 1 << i ) ; } num /= 2 ; } } ans . add ( value ) ; }
void solve ( long n , long k ) { ans . add ( k ) ; int countk = countSetBits ( k ) ; if ( pow2 [ countk ] < n ) { System . out . print ( - 1 ) ; return ; } int count = 0 ; for ( long i = 0 ; i < pow2 [ countk ] - 1 ; i ++ ) { add ( i ) ; count ++ ; if ( count == n ) break ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans . get ( i ) + " " ) ; } }
int numberOfMen ( int D , int m , int d ) { int Men = ( m * ( D - d ) ) / d ; return Men ; }
long sumPowersK ( long n , long k ) { long sum = 0 , num = 1 ; while ( num <= n ) { sum += num ; num *= k ; } return sum ; }
long getSum ( long n , long k ) { long pwrK = sumPowersK ( n , k ) ; long sumAll = ( n * ( n + 1 ) ) / 2 ; return ( sumAll - pwrK ) ; }
int maxPeople ( int p ) { int tmp = 0 , count = 0 ; for ( int i = 1 ; i * i <= p ; i ++ ) { tmp = tmp + ( i * i ) ; if ( tmp <= p ) count ++ ; else break ; } return count ; }
int maxPeople ( int p ) { long [ ] sums = new long [ kN ] ; sums [ 0 ] = 0 ; for ( int i = 1 ; i < kN ; i ++ ) sums [ i ] = ( long ) ( i * i ) + sums [ i - 1 ] ; int it = lower_bound ( sums , 0 , kN , p ) ; if ( sums [ it ] > p ) { -- it ; } return it ; }
long squareSeries ( long n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
long maxPeople ( long n ) { long low = 0 ; long high = 1000000L ; long ans = 0L ; while ( low <= high ) { long mid = low + ( ( high - low ) / 2 ) ; long value = squareSeries ( mid ) ; if ( value <= n ) { ans = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return ans ; }
int getAverage ( int x , int y ) { int avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; }
int getfactor ( int n , int p ) { int pw = 0 ; while ( n != 0 ) { n /= p ; pw += n ; } return pw ; }
int isDivisible ( int n , int r , int p ) { int x1 = getfactor ( n , p ) ; int x2 = getfactor ( r , p ) ; int x3 = getfactor ( n - r , p ) ; if ( x1 > x2 + x3 ) return 1 ; return 0 ; }
int findIndex ( int [ ] a , int n , int k ) { int index = - 1 , max_ceil = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] + k - 1 ) / k ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= max_ceil ) { max_ceil = a [ i ] ; index = i ; } } return index ; }
int Count_Segment ( int p [ ] , int n ) { int count = 0 ; int [ ] upto = new int [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) upto [ i ] = 0 ; int j = 0 , curr = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( p [ i ] > p [ i - 1 ] && p [ i ] > p [ i + 1 ] ) { curr = p [ i ] ; j = i - 1 ; while ( j >= 0 && p [ j ] < curr ) { upto [ p [ j ] ] = curr ; j -= 1 ; } j = i + 1 ; while ( j < n && p [ j ] < curr ) { if ( upto [ curr - p [ j ] ] == curr ) count += 1 ; j += 1 ; } } } return count ; }
void dfs ( int node , int parent ) { int a = __builtin_popcount ( weight . get ( node ) + x ) ; if ( maximum < a ) { maximum = a ; ans = node ; } else if ( maximum == a ) ans = Math . min ( ans , node ) ; for ( int i = 0 ; i < graph . get ( node ) . size ( ) ; i ++ ) { if ( graph . get ( node ) . get ( i ) == parent ) continue ; dfs ( graph . get ( node ) . get ( i ) , node ) ; } }
boolean solve ( int n , int k ) { if ( n >= ( k * ( k + 1 ) ) / 2 ) { return true ; } return false ; }
void solve ( long a , long b ) { if ( a > 0 && b > 0 ) { System . out . println ( "Positive" ) ; } else if ( a <= 0 && b >= 0 ) { System . out . println ( "Zero" ) ; } else { long n = Math . abs ( a - b ) + 1 ; if ( n % 2 == 0 ) { System . out . println ( "Positive" ) ; } else { System . out . println ( "Negative" ) ; } } }
boolean isEven ( int arr [ ] , int n , int r ) { if ( r % 2 == 0 ) { if ( arr [ n - 1 ] % 2 == 0 ) return true ; } else { int oddCount = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount % 2 == 0 ) return true ; } return false ; }
int closetAND ( int arr [ ] , int n , int k ) { int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . min ( ans , Math . abs ( k - X ) ) ; } } return ans ; }
int countQuadruplets ( int l , int r , int k ) { int count = 0 ; for ( int u = l ; u <= r ; u ++ ) { for ( int v = l ; v <= r ; v ++ ) { for ( int w = l ; w <= r ; w ++ ) { for ( int x = l ; x <= r ; x ++ ) { if ( gcd ( gcd ( u , v ) , gcd ( w , x ) ) == k ) count ++ ; } } } } return count ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int count_square ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i = i + 2 ) { int k = n - i + 1 ; count += ( k * k ) ; } return count ; }
int Rate ( int N1 , int N2 ) { float rate = ( N2 - N1 ) * 100 / N1 ; return ( int ) rate ; }
void solve ( int a [ ] , int n ) { int ones = 0 , twos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ones ++ ; else twos ++ ; } int ind = 0 ; if ( twos > 0 ) a [ ind ++ ] = 2 ; boolean evenOnes = ( ones % 2 == 0 ) ? true : false ; if ( evenOnes ) ones -= 1 ; for ( int i = 0 ; i < ones ; i ++ ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < twos - 1 ; i ++ ) a [ ind ++ ] = 2 ; if ( evenOnes ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " " ) ; }
int count_pairs ( int a [ ] , int b [ ] , int n , int m ) { int odd1 = 0 , even1 = 0 ; int odd2 = 0 , even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd1 ++ ; else even1 ++ ; } for ( int i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 == 1 ) odd2 ++ ; else even2 ++ ; } int pairs = Math . min ( odd1 , odd2 ) + Math . min ( even1 , even2 ) ; return pairs ; }
int primeCount ( int arr [ ] , int n ) { int max_val = max_element ( arr ) ; boolean prime [ ] = new boolean [ max_val + 1 ] ; for ( int p = 0 ; p <= max_val ; p ++ ) prime [ p ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( prime [ arr [ i ] ] ) count ++ ; return count ; }
int [ ] getPrefixArray ( int arr [ ] , int n , int pre [ ] ) { pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } return pre ; }
int getPrime ( int arr [ ] , int n ) { int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; Vector < Boolean > prime = new Vector < > ( max_val + 1 ) ; for ( int i = 0 ; i < max_val + 1 ; i ++ ) prime . add ( i , Boolean . TRUE ) ; prime . add ( 1 , Boolean . FALSE ) ; prime . add ( 2 , Boolean . FALSE ) ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime . get ( p ) == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime . add ( i , Boolean . FALSE ) ; } } int maximum = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime . get ( arr [ i ] ) ) { maximum = Math . max ( maximum , arr [ i ] ) ; } } return maximum ; }
void CreateArray ( int N , int even , int odd ) { int EvenPreSums = 1 ; int temp = - 1 ; int OddPreSums = 0 ; for ( int i = 0 ; i <= N + 1 ; i ++ ) { if ( i * ( ( N + 1 ) - i ) == odd ) { temp = 0 ; OddPreSums = i ; break ; } } if ( temp == - 1 ) { System . out . println ( temp ) ; } else { EvenPreSums = ( ( N + 1 ) - OddPreSums ) ; int e = 1 ; int o = 0 ; int CurrSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( CurrSum % 2 == 0 ) { if ( e < EvenPreSums ) { e ++ ; System . out . print ( "0 " ) ; } else { o ++ ; System . out . print ( "1 " ) ; CurrSum ++ ; } } else { if ( e < EvenPreSums ) { e ++ ; System . out . print ( "1 " ) ; CurrSum ++ ; } else { o ++ ; System . out . print ( "0 " ) ; } } } System . out . println ( ) ; } }
int changeTheArray ( int arr [ ] , int n ) { int minEle = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; int maxEle = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int minOperations = Integer . MAX_VALUE ; for ( int num = minEle ; num <= maxEle ; num ++ ) { int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != num ) { operations += ( Math . abs ( num - arr [ i ] ) - 1 ) ; } } minOperations = Math . min ( minOperations , operations ) ; } return minOperations ; }
long getMinNum ( int N ) { int lcm = 1 ; for ( int i = 2 ; i <= N ; i ++ ) lcm = ( ( i * lcm ) / ( __gcd ( i , lcm ) ) ) ; return ( lcm + 1 ) ; }
double maxEdges ( double N ) { double edges = 0 ; edges = Math . floor ( ( N * N ) / 4 ) ; return edges ; }
int findX ( int A , int B ) { int j = 0 , x = 0 ; while ( A != 0 B != 0 ) { if ( ( A % 2 == 1 ) && ( B % 2 == 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; }
int findX ( int A , int B ) { return A & B ; }
int findSum ( int A , int B ) { return A ^ B ; }
boolean isSumEqual ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += ar [ i ] ; if ( sum == ar [ n - 1 ] ) return true ; return false ; }
int findIndex ( int a [ ] , int n ) { int res = 0 ; long min_diff = Long . MAX_VALUE ; long prod [ ] = new long [ n ] ; prod [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prod [ i ] = prod [ i - 1 ] * a [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long curr_diff = Math . abs ( ( prod [ n - 1 ] / prod [ i ] ) - prod [ i ] ) ; if ( curr_diff < min_diff ) { min_diff = curr_diff ; res = i ; } } return res ; }
void Permutation ( int n , int k ) { int [ ] p = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( int i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( p [ i ] + " " ) ; }
double perfectSquares ( int a , int b ) { return ( Math . floor ( Math . sqrt ( b ) ) - Math . ceil ( Math . sqrt ( a ) ) + 1 ) ; }
double countOnes ( int arr [ ] , int n ) { return perfectSquares ( 1 , n ) ; }
int validPosition ( int arr [ ] , int N , int K ) { int count = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] + K ) > ( sum - arr [ i ] ) ) count ++ ; } return count ; }
void count_unique ( HashSet < Integer > s , int n ) { if ( s . contains ( n ) ) return ; s . add ( n ) ; n += 1 ; while ( n % 10 == 0 ) { n = n / 10 ; } count_unique ( s , n ) ; }
int countPairs ( int arr [ ] , int n ) { int size = ( 2 * N ) + 1 ; int freq [ ] = new int [ size ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x + N ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( freq [ i ] > 0 ) { ans += ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 ; for ( int j = i + 2 ; j < 2001 ; j += 2 ) { if ( freq [ j ] > 0 && ( freq [ ( i + j ) / 2 ] > 0 ) ) { ans += ( freq [ i ] * freq [ j ] ) ; } } } } return ans ; }
int smallestSum ( int n ) { if ( n == 1 ) return 0 ; return ( 2 * ( int ) Math . pow ( 10 , n - 1 ) ) ; }
int largestSum ( int n ) { return ( 2 * ( ( int ) Math . pow ( 10 , n ) - 1 ) ) ; }
int count_pairs ( int a [ ] , int b [ ] , int n , int m ) { int odd1 = 0 , even1 = 0 ; int odd2 = 0 , even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) { odd1 ++ ; } else { even1 ++ ; } } for ( int i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 == 1 ) { odd2 ++ ; } else { even2 ++ ; } } int pairs = Math . min ( odd1 , even2 ) + Math . min ( odd2 , even1 ) ; return pairs ; }
int find_leftmost_unsetbit ( int n ) { int ind = - 1 ; int i = 1 ; while ( n > 0 ) { if ( ( n % 2 ) != 1 ) { ind = i ; } i ++ ; n >>= 1 ; } return ind ; }
int vertices ( int N , int A , int B ) { int position = 0 ; int minisum = Integer . MAX_VALUE ; int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i == A i == B ) continue ; else { int x = Math . abs ( i - A ) ; int y = Math . abs ( i - B ) ; sum = x + y ; if ( sum < minisum ) { minisum = sum ; position = i ; } } } return position ; }
int factorial ( int n ) { int f = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { f *= i ; } return f ; }
int sumFactorial ( int [ ] arr , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += factorial ( arr [ i ] ) ; } return s ; }
void dfs ( int child , int par , int color [ ] ) { if ( color [ child ] != color [ par ] ) ans ++ ; for ( int i = 0 ; i < gr . get ( child ) . size ( ) ; i ++ ) { if ( gr . get ( child ) . get ( i ) == par ) continue ; dfs ( gr . get ( child ) . get ( i ) , child , color ) ; } }
int highestPower ( String str , int len ) { int ans = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == '0' ) ans ++ ; else break ; } return ans ; }
long modInverse ( long n , long p ) { return power ( n , p - 2 , p ) ; }
long nCrModP ( long n , long r , long p ) { if ( r == 0 ) return 1 ; long fac [ ] = new long [ ( int ) n + 1 ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ ( int ) n ] * modInverse ( fac [ ( int ) r ] , p ) % p * modInverse ( fac [ ( int ) n - ( int ) r ] , p ) % p ) % p ; }
long countArrangements ( long n , long k , long p ) { return ( factorial ( n , p ) * nCrModP ( k , n , p ) ) % p ; }
int maxProd ( int N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return Math . max ( maxProd ( N / 10 ) * ( N % 10 ) , maxProd ( N / 10 - 1 ) * 9 ) ; }
void primeFactors ( int n , int freq [ ] ) { int cnt = 0 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } freq [ 2 ] = cnt ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { cnt = 0 ; while ( n % i == 0 ) { cnt ++ ; n = n / i ; } freq [ i ] = cnt ; } if ( n > 2 ) freq [ n ] = 1 ; }
int getMaximumPower ( int n , int m ) { int freq1 [ ] = new int [ n + 1 ] , freq2 [ ] = new int [ m + 1 ] ; primeFactors ( n , freq1 ) ; primeFactors ( m , freq2 ) ; int maxi = 0 ; for ( int i = 2 ; i <= m ; i ++ ) { if ( freq1 [ i ] == 0 && freq2 [ i ] == 0 ) continue ; if ( freq2 [ i ] > freq1 [ i ] ) return 0 ; if ( freq2 [ i ] != 0 ) { maxi = Math . max ( maxi , freq1 [ i ] / freq2 [ i ] ) ; } } return maxi ; }
boolean check ( int mat [ ] [ ] ) { int xorr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { xorr ^= mat [ i ] [ 0 ] ; } if ( xorr != 0 ) return true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] != mat [ i ] [ 0 ] ) return true ; } } return false ; }
int sumodd ( int n ) { return ( n * n ) ; }
int sumeven ( int n ) { return ( n * ( n + 1 ) ) ; }
void radiated_Station ( int station [ ] , int n ) { int rStation [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { int li = i - 1 , ri = i + 1 ; int lRad = station [ i ] - 1 , rRad = station [ i ] - 1 ; rStation [ i ] += station [ i ] ; while ( li >= 1 && lRad >= 1 ) { rStation [ li -- ] += lRad -- ; } while ( ri <= n && rRad >= 1 ) { rStation [ ri ++ ] += rRad -- ; } } print ( rStation , n ) ; }
int oddTriangularNumber ( int N ) { return ( N * ( ( 2 * N ) - 1 ) ) ; }
void idstrt ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) System . out . println ( "The given straight" + " lines are identical" ) ; else System . out . println ( "The given straight" + " lines are not identical" ) ; }
double area ( double a , double b , double c ) { double d = Math . abs ( ( c * c ) / ( 2 * a * b ) ) ; return d ; }
float percent ( int n , int x ) { float p = n * x ; p /= 100 ; return p ; }
float getLoss ( int price [ ] , int quantity [ ] , int X [ ] , int n ) { float loss = 0 ; for ( int i = 0 ; i < n ; i ++ ) { float originalPrice = price [ i ] ; float sellingPrice = originalPrice + percent ( ( int ) originalPrice , X [ i ] ) ; float afterDiscount = sellingPrice - percent ( ( int ) sellingPrice , X [ i ] ) ; loss += ( ( originalPrice - afterDiscount ) * quantity [ i ] ) ; } return loss ; }
int maxAbsDiff ( int arr [ ] , int n ) { int minEle = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minEle = Math . min ( minEle , arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; }
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int maximizeSum ( int a [ ] , int n ) { int cnt = 0 ; int mini = Integer . MAX_VALUE ; int minSubarray = Integer . MAX_VALUE ; int sum = maxSubArraySum ( a , n ) ; int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; cnt ++ ; minSubarray = Math . min ( a [ i ] , minSubarray ) ; if ( sum == max_ending_here ) { if ( cnt == 1 ) mini = Math . min ( mini , 0 ) ; else mini = Math . min ( mini , minSubarray ) ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; cnt = 0 ; minSubarray = Integer . MAX_VALUE ; } } return sum - mini ; }
boolean isOsiris ( int n ) { int a = n % 10 ; int b = ( n / 10 ) % 10 ; int c = n / 100 ; int digit_sum = a + b + c ; if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; }
int countTriangles ( int a [ ] , int n ) { int cnt = 0 ; int pairs = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { pairs += a [ i ] / 2 ; if ( a [ i ] % 2 == 1 && pairs > 0 ) { cnt += 1 ; pairs -= 1 ; } } cnt += ( 2 * pairs ) / 3 ; return cnt ; }
int smallestMultiple ( int n ) { if ( n == 1 ) return 5 ; return ( int ) ( Math . pow ( 10 , n - 1 ) ) ; }
int countAnomalies ( int arr [ ] , int n , int k ) { int cnt = 0 ; int i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( Math . abs ( arr [ i ] - ( sum - arr [ i ] ) ) > k ) cnt ++ ; return cnt ; }
void Divisors ( ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j * i < N ; j ++ ) { cnt [ i * j ] ++ ; } } }
int Sumofdivisors ( int A , int B , int C ) { int sum = 0 ; Divisors ( ) ; for ( int i = 1 ; i <= A ; i ++ ) { for ( int j = 1 ; j <= B ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { int x = i * j * k ; sum += cnt [ x ] ; if ( sum >= mod ) { sum -= mod ; } } } } return sum ; }
int getHCF ( int x , int y ) { int minimum = Math . min ( x , y ) ; if ( x % minimum == 0 && y % minimum == 0 ) return minimum ; for ( int i = minimum / 2 ; i >= 2 ; i -- ) { if ( x % i == 0 && y % i == 0 ) return i ; } return 1 ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
boolean isDivisible ( int n ) { if ( isPrime ( n + 1 ) ) return false ; return true ; }
void findDivisors ( int n ) { int [ ] div = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( div [ i ] + " " ) ; }
int findMaxCock ( int ar [ ] [ ] ) { if ( R < 3 C < 3 ) return - 1 ; int max_sum = Integer . MIN_VALUE ; for ( int i = 0 ; i < R - 2 ; i ++ ) { for ( int j = 0 ; j < C - 2 ; j ++ ) { int sum = ( ar [ i ] [ j ] + ar [ i ] [ j + 2 ] ) + ( ar [ i + 1 ] [ j + 1 ] ) + ( ar [ i + 2 ] [ j ] + ar [ i + 2 ] [ j + 1 ] + ar [ i + 2 ] [ j + 2 ] ) ; max_sum = Math . max ( max_sum , sum ) ; } } return max_sum ; }
int segments ( int n , int [ ] p , int m ) { HashMap < Integer , Integer > c = new HashMap < > ( ) ; c . put ( 0 , 1 ) ; boolean has = false ; int sum = 0 ; int ans = 0 ; for ( int r = 0 ; r < n ; r ++ ) { if ( p [ r ] < m ) sum -- ; else if ( p [ r ] > m ) sum ++ ; if ( p [ r ] == m ) has = true ; if ( has ) ans += ( c . get ( sum ) == null ? 0 : c . get ( sum ) ) + ( c . get ( sum - 1 ) == null ? 0 : c . get ( sum - 1 ) ) ; else c . put ( sum , c . get ( sum ) == null ? 1 : c . get ( sum ) + 1 ) ; } return ans ; }
int findMaximumDiff ( int [ ] a , int n ) { int ind1 = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( a [ 0 ] != a [ i ] ) { ind1 = i ; break ; } } int ind2 = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ n - 1 ] != a [ i ] ) { ind2 = ( n - 1 - i ) ; break ; } } return Math . max ( ind1 , ind2 ) ; }
int decideWinner ( int [ ] a , int n ) { int count0 = 0 ; int count1 = 0 ; int count2 = 0 ; int count3 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; }
int minOperations ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int maxFreq = Integer . MIN_VALUE ; maxFreq = Collections . max ( mp . entrySet ( ) , Comparator . comparingInt ( Map . Entry :: getKey ) ) . getValue ( ) ; return ( n - maxFreq ) ; }
void Add_edge ( int u , int v ) { tree . get ( u ) . add ( v ) ; tree . get ( v ) . add ( u ) ; }
void intisalise ( ) { startIdx = new int [ n + 1 ] ; endIdx = new int [ n + 1 ] ; p = new int [ n + 1 ] ; }
void Dfs ( int ch , int par ) { p [ currentIdx ] = ch ; startIdx [ ch ] = currentIdx ++ ; for ( int c : tree . get ( ch ) ) { if ( c != par ) Dfs ( c , ch ) ; } endIdx [ ch ] = currentIdx - 1 ; }
int findNode ( int v , int k ) { k += startIdx [ v ] - 1 ; if ( k <= endIdx [ v ] ) return p [ k ] ; return - 1 ; }
int CntDivbyX ( int arr [ ] , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = number * 2 + arr [ i ] ; if ( ( number % x == 0 ) ) count += 1 ; } return count ; }
int CntDivbyX ( int arr [ ] , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = ( number * 2 + arr [ i ] ) % x ; if ( number == 0 ) count += 1 ; } return count ; }
int smallestIndex ( int [ ] a , int n ) { int right1 = 0 , right0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return Math . min ( right1 , right0 ) ; }
int A_mod_B ( String N , int a ) { int len = N . length ( ) ; int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) ans = ( ans * 10 + ( int ) N . charAt ( i ) - '0' ) % a ; return ans % a ; }
int findMod ( String N ) { int mod = A_mod_B ( N , 4 ) ; int ans = ( 1 + ( int ) Math . pow ( 2 , mod ) + ( int ) Math . pow ( 3 , mod ) + ( int ) Math . pow ( 4 , mod ) ) ; return ( ans % 5 ) ; }
int countCon ( int ar [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; }
void printElements ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) System . out . print ( arr [ i ] + " " ) ; } }
void reduceFraction ( int x , int y ) { int d ; d = __gcd ( x , y ) ; x = x / d ; y = y / d ; System . out . println ( "x = " + x + ", y = " + y ) ; }
void generateSubStrings ( String s , HashMap < String , Integer > mpp ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { String temp = "" ; for ( int j = i ; j < l ; j ++ ) { temp += s . charAt ( j ) ; if ( mpp . containsKey ( temp ) ) { int x = mpp . get ( temp ) ; mpp . put ( temp , ++ x ) ; } else mpp . put ( temp , 1 ) ; } } }
void binomialCoeff ( int [ ] [ ] C ) { int i , j ; for ( i = 1 ; i < 100 ; i ++ ) { for ( j = 0 ; j < 100 ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } }
int answerQuery ( HashMap < String , Integer > mpp , int [ ] [ ] C , int k ) { int ans = 0 ; for ( HashMap . Entry < String , Integer > entry : mpp . entrySet ( ) ) { if ( entry . getValue ( ) >= k ) ans += C [ entry . getValue ( ) ] [ k ] ; } return ans ; }
int numLen ( int K ) { if ( K % 2 == 0 K % 5 == 0 ) { return - 1 ; } int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = number * 10 + 1 ; if ( ( number % K == 0 ) ) { return len ; } } return - 1 ; }
int numLen ( int K ) { if ( K % 2 == 0 K % 5 == 0 ) return - 1 ; int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return - 1 ; }
void precomputation ( int arr [ ] , int n ) { for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum1 [ j ] += i ; for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum2 [ j ] += ( sum1 [ j ] - i ) * i ; for ( int i = 1 ; i < max_Element ; i ++ ) sum2 [ i ] /= 2 ; for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) ; for ( int i = 1 ; i < max_Element ; i ++ ) sum3 [ i ] /= 3 ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( sum3 [ arr [ i ] ] + " " ) ; }
int sum ( int k , int n ) { int sum = ( int ) ( Math . pow ( k , n + 1 ) - Math . pow ( k - 1 , n + 1 ) ) ; return sum ; }
int exponent ( int A , int B ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; int y ; if ( B % 2 == 0 ) { y = exponent ( A , B / 2 ) ; y = ( y * y ) ; } else { y = A ; y = ( y * exponent ( A , B - 1 ) ) ; } return y ; }
int sum ( int k , int n ) { int sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) ; return sum ; }
int freqPairs ( int arr [ ] , int n ) { int max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int freq [ ] = new int [ max + 1 ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 2 * arr [ i ] ; j <= max ; j += arr [ i ] ) { if ( freq [ j ] >= 1 ) { count += freq [ j ] ; } } if ( freq [ arr [ i ] ] > 1 ) { count += freq [ arr [ i ] ] - 1 ; freq [ arr [ i ] ] -- ; } } return count ; }
boolean is_prime ( int num ) { int count = 0 ; for ( int i = 1 ; i * i <= ( num ) ; i ++ ) { if ( ( num ) % i == 0 ) { if ( i * i != ( num ) ) count += 2 ; else count ++ ; } } if ( count == 2 ) return true ; else return false ; }
String is_divisible ( int n ) { if ( n == 1 ) { return "YES" ; } else { if ( is_prime ( n + 1 ) ) return "NO" ; else return "YES" ; } }
int power ( int x , int y , int p ) { while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
int findCount ( int N ) { int count = power ( 2 , N , mod ) ; return count ; }
int msb ( int x ) { int ret = 0 ; while ( ( x >> ( ret + 1 ) ) != 0 ) ret ++ ; return ret ; }
int xorRange ( int l , int r ) { int max_bit = msb ( r ) ; int mul = 2 ; int ans = 0 ; for ( int i = 1 ; i <= max_bit ; i ++ ) { if ( ( l / mul ) * mul == ( r / mul ) * mul ) { if ( ( ( l & ( 1 << i ) ) != 0 ) && ( r - l + 1 ) % 2 == 1 ) ans += mul ; mul *= 2 ; continue ; } int odd_c = 0 ; if ( ( ( l & ( 1 << i ) ) != 0 ) && l % 2 == 1 ) odd_c = ( odd_c ^ 1 ) ; if ( ( ( r & ( 1 << i ) ) != 0 ) && r % 2 == 0 ) odd_c = ( odd_c ^ 1 ) ; if ( odd_c != 0 ) ans += mul ; mul *= 2 ; } int zero_bit_cnt = zero_bit_cnt = ( r - l + 1 ) / 2 ; if ( l % 2 == 1 && r % 2 == 1 ) zero_bit_cnt ++ ; if ( zero_bit_cnt % 2 == 1 ) ans ++ ; return ans ; }
long computeXOR ( int n ) { int x = n & 3 ; switch ( x ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } return 0 ; }
int countNumbers ( int x , int n ) { if ( x > n ) return 0 ; return 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ; }
boolean checkfact ( int N , int countprime , int prime ) { int countfact = 0 ; if ( prime == 2 prime == 3 ) countfact ++ ; int divide = prime ; while ( N / divide != 0 ) { countfact += N / divide ; divide = divide * divide ; } if ( countfact >= countprime ) return true ; else return false ; }
boolean check ( int N ) { int sumsquares = ( N + 1 ) * ( 2 * N + 1 ) ; int countprime = 0 ; for ( int i = 2 ; i <= Math . sqrt ( sumsquares ) ; i ++ ) { int flag = 0 ; while ( sumsquares % i == 0 ) { flag = 1 ; countprime ++ ; sumsquares /= i ; } if ( flag == 1 ) { if ( ! checkfact ( N - 1 , countprime , i ) ) return false ; countprime = 0 ; } } if ( sumsquares != 1 ) if ( ! checkfact ( N - 1 , 1 , sumsquares ) ) return false ; return true ; }
int countNonIncreasing ( int arr [ ] , int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] <= arr [ i ] ) len ++ ; else { cnt += ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len + 1 ) * len ) / 2 ) ; return cnt ; }
int recamanArray ( int arr [ ] , int n ) { Set < Integer > s = new HashSet < Integer > ( ) ; int recaman [ ] = new int [ n + 1 ] ; recamanGenerator ( recaman , n ) ; for ( int i = 0 ; i < n ; i ++ ) s . add ( recaman [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . contains ( arr [ i ] ) ) s . remove ( arr [ i ] ) ; } return s . size ( ) ; }
int countSubarrays ( int [ ] arr , int n , int k ) { long [ ] prefix_sum = new long [ MAX ] ; prefix_sum [ 0 ] = 0 ; prefix_sum = partial_sum ( prefix_sum , arr , n ) ; int sum ; if ( k == 1 ) { sum = 0 ; HashMap < Long , Integer > m = new HashMap < > ( ) ; for ( int i = n ; i >= 0 ; i -- ) { if ( m . containsKey ( prefix_sum [ i ] + 1 ) ) sum += m . get ( prefix_sum [ i ] + 1 ) ; if ( m . containsKey ( prefix_sum [ i ] ) ) m . put ( prefix_sum [ i ] , m . get ( prefix_sum [ i ] ) + 1 ) ; else m . put ( prefix_sum [ i ] , 1 ) ; } return sum ; } if ( k == - 1 ) { sum = 0 ; HashMap < Long , Integer > m = new HashMap < > ( ) ; for ( int i = n ; i >= 0 ; i -- ) { if ( m . containsKey ( prefix_sum [ i ] + 1 ) ) sum += m . get ( prefix_sum [ i ] + 1 ) ; if ( m . containsKey ( prefix_sum [ i ] - 1 ) ) sum += m . get ( prefix_sum [ i ] - 1 ) ; if ( m . containsKey ( prefix_sum [ i ] ) ) m . put ( prefix_sum [ i ] , m . get ( prefix_sum [ i ] ) + 1 ) ; else m . put ( prefix_sum [ i ] , 1 ) ; } return sum ; } sum = 0 ; long b , l = 100000000000000L ; HashMap < Long , Integer > m = new HashMap < > ( ) ; for ( int i = n ; i >= 0 ; i -- ) { b = 1 ; while ( true ) { if ( b > l ) break ; if ( m . containsKey ( prefix_sum [ i ] + b ) ) sum += m . get ( prefix_sum [ i ] + b ) ; b *= k ; } if ( m . containsKey ( prefix_sum [ i ] ) ) m . put ( ( prefix_sum [ i ] ) , m . get ( prefix_sum [ i ] ) + 1 ) ; else m . put ( ( prefix_sum [ i ] ) , 1 ) ; } return sum ; }
int kadaneAlgorithm ( int [ ] ar , int n ) { int sum = 0 , maxSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ar [ i ] ; if ( sum < 0 ) sum = 0 ; maxSum = Math . max ( maxSum , sum ) ; } return maxSum ; }
int maxFunction ( int [ ] arr , int n ) { int [ ] b = new int [ MAX ] ; int [ ] c = new int [ MAX ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i % 2 == 1 ) { b [ i ] = Math . abs ( arr [ i + 1 ] - arr [ i ] ) ; c [ i ] = - b [ i ] ; } else { c [ i ] = Math . abs ( arr [ i + 1 ] - arr [ i ] ) ; b [ i ] = - c [ i ] ; } } int ans = kadaneAlgorithm ( b , n - 1 ) ; ans = Math . max ( ans , kadaneAlgorithm ( c , n - 1 ) ) ; return ans ; }
boolean isPerfectSquare ( int [ ] arr , int n ) { HashMap < Integer , Integer > umap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( umap . containsKey ( arr [ i ] ) ) umap . put ( arr [ i ] , umap . get ( arr [ i ] ) + 1 ) ; else umap . put ( arr [ i ] , 1 ) ; } Iterator < Map . Entry < Integer , Integer > > iterator = umap . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < Integer , Integer > entry = iterator . next ( ) ; if ( entry . getValue ( ) % 2 == 1 ) return false ; } return true ; }
int minimumSteps ( int n , int m , int a , int b ) { if ( n > m ) return MAXN ; if ( n == m ) return 0 ; return Math . min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) ; }
boolean isPrime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) return false ; } return true ; }
int minimumCost ( int n ) { if ( isPrime ( n ) ) return 1 ; if ( n % 2 == 1 && isPrime ( n - 2 ) ) return 2 ; if ( n % 2 == 0 ) return 2 ; return 3 ; }
int fib ( int n ) { double phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return ( int ) Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; }
int calculateSum ( int l , int r ) { int sum = 0 ; for ( int i = l ; i <= r ; i ++ ) sum += fib ( i ) ; return sum ; }
int fib ( int n ) { double phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return ( int ) Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; }
int calculateSum ( int l , int r ) { int sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; }
double wastedWater ( double V , double M , double N ) { double wasted_amt , amt_per_min , time_to_fill ; amt_per_min = M - N ; time_to_fill = V / amt_per_min ; wasted_amt = N * time_to_fill ; return wasted_amt ; }
float sphereSide ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float R = ( float ) ( ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ) / 2 ; return R ; }
void Loss ( int SP , int P ) { float loss = 0 ; loss = ( float ) ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ; System . out . println ( "Loss = " + loss ) ; }
int possibleways ( int n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; }
int countSubarrays ( int [ ] arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { long product = 1 ; for ( int x = i ; x <= j ; x ++ ) product *= arr [ x ] ; if ( product % K == 0 ) count ++ ; } } return count ; }
void build ( int node , int start , int end , int [ ] arr , int k ) { if ( start == end ) { tree [ node ] = ( 1L * arr [ start ] ) % k ; return ; } int mid = ( start + end ) >> 1 ; build ( 2 * node , start , mid , arr , k ) ; build ( 2 * node + 1 , mid + 1 , end , arr , k ) ; tree [ node ] = ( tree [ 2 * node ] * tree [ 2 * node + 1 ] ) % k ; }
long query ( int node , int start , int end , int l , int r , int k ) { if ( start > end start > r end < l ) { return 1 ; } if ( start >= l && end <= r ) { return tree [ node ] % k ; } int mid = ( start + end ) >> 1 ; long q1 = query ( 2 * node , start , mid , l , r , k ) ; long q2 = query ( 2 * node + 1 , mid + 1 , end , l , r , k ) ; return ( q1 * q2 ) % k ; }
long countSubarrays ( int [ ] arr , int n , int k ) { long count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { long product_mod_k = query ( 1 , 0 , n - 1 , i , j , k ) ; if ( product_mod_k == 0 ) { count ++ ; } } } return count ; }
void printMaxValPair ( Vector < Long > v , int n ) { Collections . sort ( v ) ; long N = v . get ( ( int ) n - 1 ) ; if ( N % 2 == 1 ) { long first_maxima = N / 2 ; long second_maxima = first_maxima + 1 ; long ans1 = ( long ) 3e18 , ans2 = ( long ) 3e18 ; long from_left = - 1 , from_right = - 1 ; long from = - 1 ; for ( long i = 0 ; i < n ; ++ i ) { if ( v . get ( ( int ) i ) > first_maxima ) { from = i ; break ; } else { long diff = first_maxima - v . get ( ( int ) i ) ; if ( diff < ans1 ) { ans1 = diff ; from_left = v . get ( ( int ) i ) ; } } } from_right = v . get ( ( int ) from ) ; long diff1 = first_maxima - from_left ; long diff2 = from_right - second_maxima ; if ( diff1 < diff2 ) System . out . println ( N + " " + from_left ) ; else System . out . println ( N + " " + from_right ) ; } else { long maxima = N / 2 ; long ans1 = ( int ) 3e18 ; long R = - 1 ; for ( long i = 0 ; i < n - 1 ; ++ i ) { long diff = Math . abs ( v . get ( ( int ) i ) - maxima ) ; if ( diff < ans1 ) { ans1 = diff ; R = v . get ( ( int ) i ) ; } } System . out . println ( N + " " + R ) ; } }
int Permutations ( int n , int k ) { int ans = 1 ; if ( k >= 2 ) ans += ( n ) * ( n - 1 ) / 2 ; if ( k >= 3 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * 2 / 6 ; if ( k >= 4 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 / 24 ; return ans ; }
int countIntegers ( long l , long r ) { long ans = 0 , i = 1 ; long v = power ( 2 , i ) ; while ( v <= r ) { while ( v <= r ) { if ( v >= l ) ans ++ ; v = v * 3 ; } i ++ ; v = power ( 2 , i ) ; } if ( l == 1 ) ans ++ ; return ( int ) ans ; }
int sumTruncatablePrimes ( int n ) { int sum = 0 ; for ( int i = 2 ; i < n ; i ++ ) { int num = i ; boolean flag = true ; while ( num > 0 ) { if ( ! prime [ num ] ) { flag = false ; break ; } num /= 10 ; } num = i ; int power = 10 ; while ( num / power > 0 ) { if ( ! prime [ num % power ] ) { flag = false ; break ; } power *= 10 ; } if ( flag ) { sum += i ; } } return sum ; }
void nDigitPerfectSquares ( int n ) { int smallest = ( int ) Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) , 2 ) ; System . out . print ( smallest + " " ) ; int largest = ( int ) Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) - 1 , 2 ) ; System . out . print ( largest ) ; }
int MaxTraceSub ( int mat [ ] [ ] ) { int max_trace = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int r = i , s = j , trace = 0 ; while ( r < N && s < N ) { trace += mat [ r ] [ s ] ; r ++ ; s ++ ; max_trace = Math . max ( trace , max_trace ) ; } } } return max_trace ; }
int printSum ( int a , int b ) { int res = 0 ; int temp1 = 0 , temp2 = 0 ; while ( a != 0 ) { temp1 = temp1 * 10 + ( a % 10 ) ; a /= 10 ; } a = temp1 ; while ( b != 0 ) { temp2 = temp2 * 10 + ( b % 10 ) ; b /= 10 ; } b = temp2 ; while ( a != 0 ) { int sum = ( a % 10 + b % 10 ) ; if ( sum / 10 == 0 ) { res = res * 10 + sum ; } else { temp1 = 0 ; while ( sum != 0 ) { temp1 = temp1 * 10 + ( sum % 10 ) ; sum /= 10 ; } sum = temp1 ; while ( sum != 0 ) { res = res * 10 + ( sum % 10 ) ; sum /= 10 ; } } a /= 10 ; b /= 10 ; } return res ; }
int countDigits ( int a , int b ) { double digits = Math . log10 ( Math . abs ( a ) ) - Math . log10 ( Math . abs ( b ) ) + 1 ; return ( int ) Math . floor ( digits ) ; }
int smallestOdd ( int n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , n - 1 ) + 1 ; }
int longestSubArray ( int arr [ ] , int n ) { boolean isZeroPresent = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; }
int smallestEven ( int n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , n - 1 ) ; }
void printBalancedExpression ( int a , int b , int c , int d ) { if ( ( ( a == d ) && ( a != 0 ) ) || ( ( a == 0 ) && ( c == 0 ) && ( d == 0 ) ) ) { for ( int i = 1 ; i <= a ; i ++ ) System . out . print ( "((" ) ; for ( int i = 1 ; i <= c ; i ++ ) System . out . print ( ")(" ) ; for ( int i = 1 ; i <= d ; i ++ ) System . out . print ( "))" ) ; for ( int i = 1 ; i <= b ; i ++ ) System . out . print ( "()" ) ; } else System . out . print ( - 1 ) ; }
int maxProfit ( int n , int a , int b , int x , int y ) { int res = x * ( n / a ) ; res += y * ( n / b ) ; res -= Math . min ( x , y ) * ( n / ( ( a * b ) / __gcd ( a , b ) ) ) ; return res ; }
int factorial ( int f ) { int fact = 1 ; for ( int i = 2 ; i <= f ; i ++ ) fact *= ( int ) i ; return fact ; }
int kthOdd ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) k -- ; if ( k == 0 ) return arr [ i ] ; } return - 1 ; }
void lastFiveDigits ( int n ) { n = ( n / 10000 ) * 10000 + ( ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n / 10 ) % 10 ) * 10 + ( n / 1000 ) % 10 ; int ans = 1 ; for ( int i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } System . out . println ( ans ) ; }
long power ( long a , long n ) { if ( n == 0 ) { return 1 ; } long p = power ( a , n / 2 ) % mod ; p = ( p * p ) % mod ; if ( n == 1 ) { p = ( p * a ) % mod ; } return p ; }
long computeSum ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { long maxs = ( power ( 2 , i ) - 1 + mod ) % mod ; maxs = ( maxs * arr [ i ] ) % mod ; long mins = ( power ( 2 , n - 1 - i ) - 1 + mod ) % mod ; mins = ( mins * arr [ i ] ) % mod ; long V = ( maxs - mins + mod ) % mod ; sum = ( sum + V ) % mod ; } return sum ; }
int maxValue ( int n ) { if ( n == 1 ) return 0 ; return ( ( n * n / 2 ) - 1 ) ; }
int count ( int n ) { int cnt = 0 ; int p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; }
int countNumbers ( int n ) { return n - n / 2 - n / 3 - n / 5 - n / 7 + n / 6 + n / 10 + n / 14 + n / 15 + n / 21 + n / 35 - n / 30 - n / 42 - n / 70 - n / 105 + n / 210 ; }
long sum ( int n ) { if ( n == 1 ) return 1 ; else return ( ( long ) Math . pow ( n , n ) + sum ( n - 1 ) ) ; }
long power ( long a , long n ) { if ( n == 0 ) return 1 ; long p = power ( a , n / 2 ) % mod ; p = ( p * p ) % mod ; if ( ( n & 1 ) == 1 ) p = ( p * a ) % mod ; return p ; }
int countPermutations ( int n ) { if ( n == 1 ) { return 0 ; } return ( ( int ) power ( 2 , n - 1 ) - 2 ) % mod ; }
long numbers ( int n ) { return ( long ) ( Math . pow ( 2 , n + 1 ) ) - 2 ; }
int countNumbers ( int n ) { return ( n / 2520 ) ; }
int nthTerm ( int N ) { int nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += Math . pow ( i , i ) ; } return nth ; }
int nthTerm ( int N ) { int nth = 0 ; nth = ( N * N * ( N + 1 ) ) / 2 ; return nth ; }
int kthSmallest ( int n , int k ) { return ( 2 * k ) ; }
boolean isSumOfPowersOfTwo ( int n ) { if ( n % 2 == 1 ) return false ; else return true ; }
void sieve_modified ( ) { for ( int i = 1 ; i < MAX ; i += 2 ) { for ( int j = i ; j < MAX ; j += i ) prefix [ j ] += i ; } for ( int i = 1 ; i < MAX ; i ++ ) prefix [ i ] += prefix [ i - 1 ] ; }
int sumOddFactors ( int L , int R ) { return ( prefix [ R ] - prefix [ L - 1 ] ) ; }
void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } }
void getFactorization ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 ) { hash1 [ spf [ x ] ] ++ ; x = x / spf [ x ] ; } while ( x % temp == 0 ) x = x / temp ; } }
boolean check ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 && hash1 [ temp ] > 1 ) return false ; while ( x % temp == 0 ) x = x / temp ; } return true ; }
boolean hasValidNum ( int [ ] arr , int n ) { sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) getFactorization ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( check ( arr [ i ] ) ) return true ; return false ; }
int findMinRemoval ( int arr [ ] , int n ) { int temp , value = 0 ; int maximum = 0 ; if ( n == 1 ) return 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != 0 && i != n - 1 ) { value = value + Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . abs ( arr [ i ] - arr [ i + 1 ] ) + Math . abs ( arr [ i ] - arr [ i - 1 ] ) - Math . abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; } else if ( i == 0 ) { value = value + Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; } else temp = Math . abs ( arr [ i ] - arr [ i - 1 ] ) ; maximum = Math . max ( maximum , temp ) ; } return ( value - maximum ) ; }
int countQuadruples ( int a [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( a [ i ] ) ) { mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; } else { mp . put ( a [ i ] , 1 ) ; } int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( j == k ) continue ; mp . put ( a [ j ] , mp . get ( a [ j ] ) - 1 ) ; mp . put ( a [ k ] , mp . get ( a [ k ] ) - 1 ) ; int first = a [ j ] - ( a [ k ] - a [ j ] ) ; int fourth = ( a [ k ] * a [ k ] ) / a [ j ] ; if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) { if ( a [ j ] != a [ k ] ) { if ( mp . containsKey ( first ) && mp . containsKey ( fourth ) ) count += mp . get ( first ) * mp . get ( fourth ) ; } else if ( mp . containsKey ( first ) && mp . containsKey ( fourth ) ) count += mp . get ( first ) * ( mp . get ( fourth ) - 1 ) ; } if ( mp . containsKey ( a [ j ] ) ) { mp . put ( a [ j ] , mp . get ( a [ j ] ) + 1 ) ; } else { mp . put ( a [ j ] , 1 ) ; } if ( mp . containsKey ( a [ k ] ) ) { mp . put ( a [ k ] , mp . get ( a [ k ] ) + 1 ) ; } else { mp . put ( a [ k ] , 1 ) ; } } } return count ; }
double getTime ( int u , int v , int x ) { double speed = u + v ; double time = x / speed ; return time ; }
int number_of_teams ( int M ) { int N1 , N2 , sqr ; sqr = ( int ) Math . sqrt ( 1 + ( 8 * M ) ) ; N1 = ( 1 + sqr ) / 2 ; N2 = ( 1 - sqr ) / 2 ; if ( N1 > 0 ) return N1 ; return N2 ; }
int power ( int x , int y ) { int p = mod ; int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
int solve ( int n , int k ) { if ( n == 1 ) return 0 ; return ( power ( ( k - 1 ) , n - 1 ) % mod - solve ( n - 1 , k ) + mod ) % mod ; }
int findMinimum ( int x , int y ) { int low = 0 , high = y ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; }
int LucasSum ( int N ) { int sum = 0 ; int a = 2 , b = 1 , c ; sum += a ; while ( b <= N ) { sum += b ; c = a + b ; a = b ; b = c ; } return sum ; }
int sumOfDigits ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = x / 10 ; } return sum ; }
int countNumbers ( int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( i % 2 == 0 && sumOfDigits ( i ) % 3 == 0 ) count ++ ; } return count ; }
int countNumbers ( int l , int r ) { return ( ( r / 6 ) - ( l - 1 ) / 6 ) ; }
int countNumbers ( int L , int R , int K ) { if ( K == 9 ) { K = 0 ; } int totalnumbers = R - L + 1 ; int factor9 = totalnumbers / 9 ; int rem = totalnumbers % 9 ; int ans = factor9 ; for ( int i = R ; i > R - rem ; i -- ) { int rem1 = i % 9 ; if ( rem1 == K ) { ans ++ ; } } return ans ; }
int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return ( int ) Math . pow ( 2 , E - 1 ) ; }
void BalanceArray ( int [ ] A , int [ ] [ ] Q ) { int [ ] ANS = new int [ A . length ] ; int i , sum = 0 ; for ( i = 0 ; i < A . length ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . length ; i ++ ) { int index = Q [ i ] [ 0 ] ; int value = Q [ i ] [ 1 ] ; if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ; if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ; ANS [ i ] = sum ; } for ( i = 0 ; i < ANS . length ; i ++ ) System . out . print ( ANS [ i ] + " " ) ; }
int findMinSum ( int arr [ ] , int n ) { int occ = n - 1 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * ( int ) Math . pow ( 2 , occ ) ; occ -- ; } return sum ; }
int findPowerOfP ( int N , int p ) { int count = 0 ; int r = p ; while ( r <= N ) { count += ( N / r ) ; r = r * p ; } return count ; }
Vector < pair > primeFactorsofB ( int B ) { Vector < pair > ans = new Vector < pair > ( ) ; for ( int i = 2 ; B != 1 ; i ++ ) { if ( B % i == 0 ) { int count = 0 ; while ( B % i == 0 ) { B = B / i ; count ++ ; } ans . add ( new pair ( i , count ) ) ; } } return ans ; }
int largestPowerOfB ( int N , int B ) { Vector < pair > vec = new Vector < pair > ( ) ; vec = primeFactorsofB ( B ) ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) ans = Math . min ( ans , findPowerOfP ( N , vec . get ( i ) . first ) / vec . get ( i ) . second ) ; return ans ; }
int maxLenSubArr ( int a [ ] , int n ) { int count , j ; int cm = 1 , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max ) max = a [ i ] ; } for ( int i = 0 ; i < n - 1 ; ) { count = 1 ; if ( a [ i ] == a [ i + 1 ] && a [ i ] == max ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] == max ) { count ++ ; i ++ ; } else break ; } if ( count > cm ) cm = count ; } else i ++ ; } return cm ; }
int minSum ( int arr [ ] , int n , int x ) { int sum = 0 ; int largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == - 1 ) return sum ; int sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return Math . min ( sum , sumAfterOperation ) ; }
int parity ( int a ) { return a % 3 ; }
int solve ( int [ ] array , int size ) { int operations = 0 ; for ( int i = 0 ; i < size - 1 ; i ++ ) { if ( parity ( array [ i ] ) == parity ( array [ i + 1 ] ) ) { operations ++ ; if ( i + 2 < size ) { int pari1 = parity ( array [ i ] ) ; int pari2 = parity ( array [ i + 2 ] ) ; if ( pari1 == pari2 ) { if ( pari1 == 0 ) array [ i + 1 ] = 1 ; else if ( pari1 == 1 ) array [ i + 1 ] = 0 ; else array [ i + 1 ] = 1 ; } else { if ( ( pari1 == 0 && pari2 == 1 ) || ( pari1 == 1 && pari2 == 0 ) ) array [ i + 1 ] = 2 ; if ( ( pari1 == 1 && pari2 == 2 ) || ( pari1 == 2 && pari2 == 1 ) ) array [ i + 1 ] = 0 ; if ( ( pari1 == 2 && pari2 == 0 ) || ( pari1 == 0 && pari2 == 2 ) ) array [ i + 1 ] = 1 ; } } } } return operations ; }
int findDigitalRoot ( int num ) { int sum = Integer . MAX_VALUE , tempNum = num ; while ( sum >= 10 ) { sum = 0 ; while ( tempNum > 0 ) { sum += tempNum % 10 ; tempNum /= 10 ; } tempNum = sum ; } return sum ; }
void findAnswer ( int X , int N ) { int counter = 0 ; for ( int i = 1 ; counter < N ; ++ i ) { int digitalRoot = findDigitalRoot ( i ) ; if ( digitalRoot == X ) { ++ counter ; } if ( counter == N ) { System . out . print ( i ) ; break ; } } }
int findAnswer ( int X , int N ) { return ( N - 1 ) * 9 + X ; }
void preComputeXor ( int arr [ ] [ ] , int prefix_xor [ ] [ ] ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { if ( j == 0 ) prefix_xor [ i ] [ j ] = arr [ i ] [ j ] ; else prefix_xor [ i ] [ j ] = ( prefix_xor [ i ] [ j - 1 ] ^ arr [ i ] [ j ] ) ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) prefix_xor [ j ] [ i ] = ( prefix_xor [ j - 1 ] [ i ] ^ prefix_xor [ j ] [ i ] ) ; }
int ansQuerie ( int prefix_xor [ ] [ ] , int x1 , int y1 , int x2 , int y2 ) { int xor_1 = 0 , xor_2 = 0 , xor_3 = 0 ; if ( x1 != 0 ) xor_1 = prefix_xor [ x1 - 1 ] [ y2 ] ; if ( y1 != 0 ) xor_2 = prefix_xor [ x2 ] [ y1 - 1 ] ; if ( x1 != 0 && y1 != 0 ) xor_3 = prefix_xor [ x1 - 1 ] [ y1 - 1 ] ; return ( ( prefix_xor [ x2 ] [ y2 ] ^ xor_1 ) ^ ( xor_2 ^ xor_3 ) ) ; }
int LucasSequence ( int [ ] arr , int n ) { int max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int counter = 0 ; HashSet < Integer > s = new HashSet < > ( ) ; int a = 2 , b = 1 ; s . add ( a ) ; s . add ( b ) ; while ( b < max ) { int c = a + b ; a = b ; b = c ; s . add ( b ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( s . contains ( arr [ i ] ) ) { counter ++ ; } } return counter ; }
int matrixSum ( int arr [ ] [ ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i ] [ j ] ) ; } } return sum ; }
int maxAND ( int L , int R ) { int maximum = L & R ; for ( int i = L ; i < R ; i ++ ) for ( int j = i + 1 ; j <= R ; j ++ ) maximum = Math . max ( maximum , ( i & j ) ) ; return maximum ; }
int maxAND ( int L , int R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } }
int checkArray ( int [ ] arr , int n ) { return ( ( arr [ 0 ] % 2 ) > 0 && ( arr [ n - 1 ] % 2 ) > 0 && ( n % 2 ) > 0 ) ? 1 : 0 ; }
int findCount ( int arr [ ] , int n ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; }
boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
int Prime_Numbers ( int n ) { ArrayList < Integer > primes = SieveOfEratosthenes ( ) ; for ( int i = 0 ; i < ( int ) ( primes . size ( ) ) - 1 ; i ++ ) if ( primes . get ( i ) + primes . get ( i + 1 ) + 1 < N ) can [ primes . get ( i ) + primes . get ( i + 1 ) + 1 ] = true ; int ans = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( can [ i ] && isprime [ i ] == true ) { ans ++ ; } } return ans ; }
void printPermutation ( int n , int k ) { for ( int i = 1 ; i <= n ; i ++ ) { int x = 2 * i - 1 ; int y = 2 * i ; if ( i <= k ) System . out . print ( y + " " + x + " " ) ; else System . out . print ( x + " " + y + " " ) ; } }
boolean isPossible ( int Sx , int Sy , int Dx , int Dy , int x , int y ) { if ( Math . abs ( Sx - Dx ) % x == 0 && Math . abs ( Sy - Dy ) % y == 0 && ( Math . abs ( Sx - Dx ) / x ) % 2 == ( Math . abs ( Sy - Dy ) / y ) % 2 ) return true ; return false ; }
int getPairs ( int a [ ] ) { int n = a . length ; int count = ( n * ( n - 1 ) ) / 2 ; return count ; }
boolean isDigitSumOne ( int nm ) { if ( nm % 9 == 1 ) return true ; else return false ; }
void printValidNums ( int n ) { int cbrt_n = ( int ) Math . cbrt ( n ) ; for ( int i = 1 ; i <= cbrt_n ; i ++ ) { int cube = ( int ) Math . pow ( i , 3 ) ; if ( cube >= 1 && cube <= n && isDigitSumOne ( cube ) ) System . out . print ( cube + " " ) ; } }
boolean isDigitSumOne ( int nm ) { while ( nm > 9 ) { int sum_digit = 0 ; while ( nm > 0 ) { int digit = nm % 10 ; sum_digit = sum_digit + digit ; nm = nm / 10 ; } nm = sum_digit ; } if ( nm == 1 ) return true ; else return false ; }
void printValidNums ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { if ( isComposite ( i ) && isDigitSumOne ( i ) ) System . out . print ( i + " " ) ; } }
void initialize ( ) { l [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 1001 ; i ++ ) { l [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i + 1 ; j ++ ) { l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) ; } } }
int nCr ( int n , int r ) { return l [ n ] [ r ] ; }
int countRhombi ( int h , int w ) { int ct = 0 ; for ( int i = 2 ; i <= h ; i += 2 ) for ( int j = 2 ; j <= w ; j += 2 ) ct += ( h - i + 1 ) * ( w - j + 1 ) ; return ct ; }
int maxSum ( int N ) { int ans = 0 ; for ( int u = 1 ; u <= N ; u ++ ) { for ( int v = 1 ; v <= N ; v ++ ) { if ( u == v ) continue ; int degreeU = 2 ; if ( u == 1 u == N ) degreeU = 1 ; int degreeV = 2 ; if ( v == 1 v == N ) degreeV = 1 ; ans += ( degreeU * degreeV ) ; } } return ans ; }
int countSquares ( int row , int column ) { int topLeft = Math . min ( row , column ) - 1 ; int bottomRight = 8 - Math . max ( row , column ) ; int topRight = Math . min ( row , 9 - column ) - 1 ; int bottomLeft = 8 - Math . max ( row , 9 - column ) ; return ( topLeft + topRight + bottomRight + bottomLeft ) ; }
void cal_factorial ( ) { arr [ 0 ] = 1 ; for ( int i = 1 ; i <= 1000000 ; i ++ ) { arr [ i ] = ( ( arr [ i - 1 ] * i ) % mod ) ; } }
long mod_exponent ( long num , long p ) { if ( p == 0 ) return 1 ; if ( ( p & 1 ) != 0 ) { return ( ( num % mod ) * ( mod_exponent ( ( num * num ) % mod , p / 2 ) ) % mod ) % mod ; } else return ( mod_exponent ( ( num * num ) % mod , p / 2 ) ) % mod ; }
long getCount ( long x , long y ) { long ans = arr [ ( int ) x + ( int ) y - 1 ] ; ans *= mod_exponent ( arr [ ( int ) x ] , mod - 2 ) ; ans %= mod ; ans *= mod_exponent ( arr [ ( int ) y ] , mod - 2 ) ; ans %= mod ; ans *= ( x - y ) ; ans %= mod ; return ans ; }
double calculateArea ( int x , int y ) { double pi = 3.1415926536 ; double arx = pi * x * x ; double ary = pi * y * y ; return arx - ary ; }
void findValues ( int a , int b ) { if ( ( a - b ) % 2 == 1 ) { System . out . println ( "-1" ) ; return ; } System . out . println ( ( ( a - b ) / 2 ) + " " + ( ( a + b ) / 2 ) ) ; }
int minValue ( int n , int x , int y ) { float val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( int ) ( Math . ceil ( val ) - x ) ; }
int countTriplets ( int n , Vector < pair > points ) { Set < pair > pts = new HashSet < pair > ( ) ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) pts . add ( points . get ( i ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { int x = points . get ( i ) . first + points . get ( j ) . first ; int y = points . get ( i ) . second + points . get ( j ) . second ; if ( x % 2 == 0 && y % 2 == 0 ) if ( ! pts . contains ( new pair ( x / 2 , y / 2 ) ) ) ct ++ ; } return ct ; }
char getWinner ( int [ ] arr , int n ) { int gcd = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { gcd = __gcd ( gcd , arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } int totalMoves = ( maxEle / gcd ) - n ; if ( totalMoves % 2 == 1 ) return 'A' ; return 'B' ; }
void maximumFactor ( int [ ] arr ) { int [ ] rank = new int [ Arrays . stream ( arr ) . max ( ) . getAsInt ( ) + 1 ] ; int [ ] factors = new int [ Arrays . stream ( arr ) . max ( ) . getAsInt ( ) + 1 ] ; int g = 0 ; for ( int i = 2 ; i <= Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr . length ; j ++ ) if ( arr [ j ] % i == 0 ) count += 1 ; rank [ g ] = count ; factors [ g ] = i ; g ++ ; } int m = Arrays . stream ( rank ) . max ( ) . getAsInt ( ) ; for ( int i = 0 ; i < rank . length ; i ++ ) { if ( rank [ i ] == m ) System . out . print ( factors [ i ] + " " ) ; } }
int digitSum ( int n ) { int ans = 0 ; while ( n != 0 ) { ans += n % 10 ; n /= 10 ; } return ans ; }
int findInt ( int n , int m ) { int minDigit = ( int ) Math . floor ( ( double ) ( m / 9 ) ) ; int start = ( int ) Math . pow ( 10 , minDigit ) - ( int ) Math . pow ( 10 , minDigit ) % n ; while ( start < Integer . MAX_VALUE ) { if ( digitSum ( start ) == m ) return start ; else start += n ; } return - 1 ; }
double smallestDivisor ( int n ) { double mx = Math . sqrt ( n ) ; for ( int i = 2 ; i <= mx ; i ++ ) if ( n % i == 0 ) return i ; return n ; }
double maxSum ( int n ) { long res = n ; while ( n > 1 ) { double divi = smallestDivisor ( n ) ; n /= divi ; res += n ; } return res ; }
long power ( long x , long y ) { long ans = 1 ; while ( y > 0 ) { if ( ( y & 1 ) > 0 ) ans = ( ans * x ) % MOD ; y >>= 1 ; x = ( x * x ) % MOD ; } return ans % MOD ; }
long modInverse ( long x ) { return power ( x , MOD - 2 ) ; }
long countNumbers ( long n , long a , long b ) { long [ ] fact = new long [ MAX ] ; long [ ] inv = new long [ MAX ] ; long ans = 0 ; fact [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) { fact [ i ] = ( 1 * fact [ i - 1 ] * i ) ; fact [ i ] %= MOD ; } inv [ MAX - 1 ] = modInverse ( fact [ MAX - 1 ] ) ; for ( int i = MAX - 2 ; i >= 0 ; i -- ) { inv [ i ] = ( inv [ i + 1 ] * ( i + 1 ) ) ; inv [ i ] %= MOD ; } if ( a < b ) { long x = a ; a = b ; b = x ; } for ( long s = n ; s <= 9 * n ; s ++ ) { if ( ! check ( s , a , b ) ) continue ; if ( s < n * b || ( s - n * b ) % ( a - b ) != 0 ) continue ; int numDig = ( int ) ( ( s - n * b ) / ( a - b ) ) ; if ( numDig > n ) continue ; long curr = fact [ ( int ) n ] ; curr = ( curr * inv [ numDig ] ) % MOD ; curr = ( curr * inv [ ( int ) n - numDig ] ) % MOD ; ans = ( ans + curr ) % MOD ; } return ans ; }
int countOddSquares ( int n , int m ) { return ( int ) Math . pow ( m , 0.5 ) - ( int ) Math . pow ( n - 1 , 0.5 ) ; }
int Square ( int row , int column , int moves ) { int a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; }
int findNumber ( int n , int m ) { int num = ( m - 1 ) * 9 + n ; return num ; }
int count ( Node node ) { if ( node == null ) return 0 ; return count ( node . left ) + count ( node . right ) + 1 ; }
boolean checkRec ( Node node , int n ) { if ( node == null ) return false ; if ( count ( node ) == n - count ( node ) ) return true ; return checkRec ( node . left , n ) || checkRec ( node . right , n ) ; }
boolean check ( Node node ) { int n = count ( node ) ; return checkRec ( node , n ) ; }
int maxResult ( int n , int a , int b , int c ) { int maxVal = 0 ; for ( int i = 0 ; i <= n ; i += a ) for ( int j = 0 ; j <= n - i ; j += b ) { float z = ( float ) ( n - ( i + j ) ) / ( float ) c ; if ( Math . floor ( z ) == Math . ceil ( z ) ) { int x = i / a ; int y = j / b ; maxVal = Math . max ( maxVal , x + y + ( int ) z ) ; } } return maxVal ; }
int digitsCount ( int n ) { int len = 0 ; while ( n > 0 ) { len ++ ; n /= 10 ; } return len ; }
int absoluteFirstLast ( int n , int x ) { int i = 0 , mod = 1 ; while ( i < x ) { mod *= 10 ; i ++ ; } int last = n % mod ; int len = digitsCount ( n ) ; while ( len != x ) { n /= 10 ; len -- ; } int first = n ; return Math . abs ( first - last ) ; }
boolean EqualNumbers ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( a [ i ] % 2 == 0 ) { a [ i ] /= 2 ; } while ( a [ i ] % 3 == 0 ) { a [ i ] /= 3 ; } if ( a [ i ] != a [ 0 ] ) { return false ; } } return true ; }
void make_sequence ( int N ) { int [ ] arr = new int [ N + 1 ] ; int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) arr [ i ] = 1 ; else arr [ i ] = 2 ; sum += arr [ i ] ; } if ( sum % 2 == 1 ) arr [ 2 ] = 3 ; for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
int countOdd ( int L , int R ) { int N = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) N ++ ; return N ; }
int getMinCost ( int n , int m ) { int cost = ( n - 1 ) * m + ( m - 1 ) * n ; return cost ; }
void minOperation ( int n , int k , int a [ ] ) { for ( int i = k ; i < n ; i ++ ) { if ( a [ i ] != a [ k - 1 ] ) System . out . println ( - 1 ) ; } for ( int i = k - 2 ; i > - 1 ; i -- ) { if ( a [ i ] != a [ k - 1 ] ) System . out . println ( i + 1 ) ; } }
boolean digitWell ( int n , int m , int k ) { int cnt = 0 ; while ( n > 0 ) { if ( n % 10 == m ) ++ cnt ; n /= 10 ; } return cnt == k ; }
int findInt ( int n , int m , int k ) { int i = n + 1 ; while ( true ) { if ( digitWell ( i , m , k ) ) return i ; i ++ ; } }
int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 mod == 3 ) { return 0 ; } return 1 ; }
void generateSequence ( int n , int g ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( i * g + " " ) ; ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findLCMFibonacci ( int a , int b ) { return ( fib ( a ) * fib ( b ) ) / fib ( gcd ( a , b ) ) ; }
int getMinNum ( int a , int b , int c ) { if ( c < a c > b ) { return c ; } int x = ( ( b / c ) * c ) + c ; return x ; }
String isEvenOrOdd ( int L , int R ) { int oddCount = ( R - L ) / 2 ; if ( R % 2 == 1 L % 2 == 1 ) oddCount ++ ; if ( oddCount % 2 == 0 ) return "Even" ; else return "Odd" ; }
int trailing_zeros ( int N ) { int count_of_two = 0 , count_of_five = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int val = i ; while ( val % 2 == 0 && val > 0 ) { val /= 2 ; count_of_two += i ; } while ( val % 5 == 0 && val > 0 ) { val /= 5 ; count_of_five += i ; } } int ans = Math . min ( count_of_two , count_of_five ) ; return ans ; }
void SieveOfEratosthenes ( int n ) { for ( int i = 0 ; i < MAX_PRIME + 1 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { b [ j ++ ] = p ; } } }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void Sieve ( ) { for ( int i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = 2 * i ; j < MAX ; j += i ) { prime [ j ] = 1 ; } } } }
int countPairs ( int n ) { int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int val = ( ( n % i ) % j ) % n ; if ( val == max ) count ++ ; } } return count ; }
int countPairs ( int n ) { if ( n == 2 ) return 4 ; int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = n - max ; return count ; }
int countOdd ( int [ ] arr , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; } return odd ; }
int countValidPairs ( int [ ] arr , int n ) { int odd = countOdd ( arr , n ) ; return ( odd * ( odd - 1 ) ) / 2 ; }
int getMultiple ( String s ) { for ( int i = 0 ; i < 1E3 ; i += 8 ) { if ( checkSub ( Integer . toString ( i ) , s ) ) return i ; } return - 1 ; }
void alter ( long x , long y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } System . out . println ( "X = " + x + ", " + "Y = " + y ) ; }
int digitProduct ( int n ) { int prod = 1 ; while ( n > 0 ) { prod = prod * ( n % 10 ) ; n = n / 10 ; } return prod ; }
void printMultiplicativePrimes ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] && prime [ digitProduct ( i ) ] ) System . out . print ( i + " " ) ; } }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
boolean coPrime ( int n1 , int n2 ) { if ( gcd ( n1 , n2 ) == 1 ) return true ; else return false ; }
int largestCoprime ( int N ) { int half = ( int ) ( N / 2 ) ; while ( coPrime ( N , half ) == false ) half -- ; return half ; }
int largestCoprime ( int N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; }
void sieve ( int maxEle , int prime [ ] ) { prime [ 0 ] = prime [ 1 ] = 1 ; for ( int i = 2 ; i * i <= maxEle ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = 2 * i ; j <= maxEle ; j += i ) prime [ j ] = 1 ; } } }
int digitSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += n % 10 ; n = n / 10 ; } return sum ; }
void printAdditivePrime ( int arr [ ] , int n ) { int maxEle = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int prime [ ] = new int [ maxEle + 1 ] ; sieve ( maxEle , prime ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == 0 ) { int sum = digitSum ( arr [ i ] ) ; if ( prime [ sum ] == 0 ) System . out . print ( arr [ i ] + " " ) ; } } }
void printSafePrimes ( int n ) { int prime [ ] = new int [ n + 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) prime [ i ] = 1 ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == 1 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = 0 ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] != 0 ) { int temp = ( 2 * i ) + 1 ; if ( temp <= n && prime [ temp ] != 0 ) prime [ temp ] = 2 ; } } for ( int i = 5 ; i <= n ; i ++ ) if ( prime [ i ] == 2 ) System . out . print ( i + " " ) ; }
double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }
float sum ( float n ) { if ( n < 2 ) return 1 ; else return 1 / n + ( sum ( n - 1 ) ) ; }
int findSum ( int m , int n , int mth , int nth , int p ) { ArrayList < Integer > ad = findingValues ( m , n , mth , nth ) ; int a = ad . get ( 0 ) ; int d = ad . get ( 1 ) ; int sum = ( p * ( 2 * a + ( p - 1 ) * d ) ) / 2 ; return sum ; }
Set < Integer > ABUNDANT ( ) { Set < Integer > v = new HashSet < > ( ) ; for ( int i = 1 ; i < N ; i ++ ) { int sum = 1 ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { sum += j ; if ( i / j != j ) { sum += i / j ; } } } if ( sum > i ) { v . add ( i ) ; } } return v ; }
void SumOfAbundant ( int n ) { Set < Integer > v = ABUNDANT ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( v . contains ( i ) & v . contains ( n - i ) ) { System . out . print ( i + " " + ( n - i ) ) ; return ; } } System . out . print ( - 1 ) ; }
long nthTermOfTheSeries ( int n ) { long nthTerm ; if ( n % 2 == 0 ) nthTerm = ( long ) Math . pow ( n - 1 , 2 ) + n ; else nthTerm = ( long ) Math . pow ( n + 1 , 2 ) + n ; return nthTerm ; }
Vector < Integer > Divisors ( int x ) { int c = 0 ; Vector < Integer > v = new Vector < Integer > ( ) ; while ( x % 2 == 0 ) { c ++ ; x /= 2 ; } v . add ( c ) ; c = 0 ; while ( x % 3 == 0 ) { c ++ ; x /= 3 ; } v . add ( c ) ; c = 0 ; while ( x % 7 == 0 ) { c ++ ; x /= 7 ; } v . add ( c ) ; v . add ( x ) ; return v ; }
int MinOperations ( int a , int b ) { Vector < Integer > va = Divisors ( a ) ; Vector < Integer > vb = Divisors ( b ) ; if ( va . get ( 3 ) != vb . get ( 3 ) ) { return - 1 ; } int minOperations = Math . abs ( va . get ( 0 ) - vb . get ( 0 ) ) + Math . abs ( va . get ( 1 ) - vb . get ( 1 ) ) + Math . abs ( va . get ( 2 ) - vb . get ( 2 ) ) ; return minOperations ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
int lcmOfArray ( int arr [ ] , int n ) { if ( n < 1 ) return 0 ; int lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ; return lcm ; }
void candies ( int n , int k ) { int count = 0 ; int ind = 1 ; int [ ] arr = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) arr [ i ] = 0 ; int low = 0 , high = n ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; int sum = ( mid * ( mid + 1 ) ) >> 1 ; if ( sum <= n ) { count = mid / k ; low = mid + 1 ; } else { high = mid - 1 ; } } int last = ( count * k ) ; n -= ( last * ( last + 1 ) ) / 2 ; int j = 0 ; int term = ( count * k ) + 1 ; while ( n > 0 ) { if ( term <= n ) { arr [ j ++ ] = term ; n -= term ; term ++ ; } else { arr [ j ] += n ; n = 0 ; } } for ( int i = 0 ; i < k ; i ++ ) arr [ i ] += ( count * ( i + 1 ) ) + ( k * ( count * ( count - 1 ) ) / 2 ) ; for ( int i = 0 ; i < k ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
float CPwithLoss ( int sellingPrice , int loss ) { float costPrice ; costPrice = ( sellingPrice * 100 ) / ( 100 - loss ) ; return costPrice ; }
void printArr ( float arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void replaceMax ( float arr [ ] , int n ) { float max = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } float min = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; } float range = max - min ; float coeffOfRange = range / ( max + min ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max ) { arr [ i ] = coeffOfRange ; break ; } } printArr ( arr , n ) ; }
int largestOddDigit ( int n ) { int maxOdd = - 1 ; while ( n > 0 ) { int digit = n % 10 ; if ( digit % 2 == 1 && digit > maxOdd ) maxOdd = digit ; n = n / 10 ; } return maxOdd ; }
int getProduct ( int n ) { int maxOdd = largestOddDigit ( n ) ; if ( maxOdd == - 1 ) return - 1 ; return ( n * maxOdd ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void commDiv ( int a , int b ) { int n = gcd ( a , b ) ; a = a / n ; b = b / n ; System . out . println ( "A = " + a + ", B = " + b ) ; }
int minAbsDiff ( int n ) { int left = 1 << ( ( int ) Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ; int right = left * 2 ; return Math . min ( ( n - left ) , ( right - n ) ) ; }
void FindAllElements ( int n , int k ) { int sum = k ; int [ ] A = new int [ k ] ; Arrays . fill ( A , 0 , k , 1 ) ; for ( int i = k - 1 ; i >= 0 ; -- i ) { while ( sum + A [ i ] <= n ) { sum += A [ i ] ; A [ i ] *= 2 ; } } if ( sum != n ) { System . out . print ( "Impossible" ) ; } else { for ( int i = 0 ; i < k ; ++ i ) System . out . print ( A [ i ] + " " ) ; } }
boolean isEqual ( int a , int b ) { if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) return true ; return false ; }
boolean isPerfectSquare ( int num ) { long left = 1 , right = num ; while ( left <= right ) { long mid = ( left + right ) / 2 ; if ( mid * mid == num ) { return true ; } if ( mid * mid < num ) { left = mid + 1 ; } else { right = mid - 1 ; } } return false ; }
boolean isStrongPrime ( int n ) { if ( ! isPrime ( n ) n == 2 ) return false ; int previous_prime = n - 1 ; int next_prime = n + 1 ; while ( ! isPrime ( next_prime ) ) next_prime ++ ; while ( ! isPrime ( previous_prime ) ) previous_prime -- ; int mean = ( previous_prime + next_prime ) / 2 ; if ( n > mean ) return true ; else return false ; }
boolean isPrime ( long n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
boolean isFactorialPrime ( long n ) { if ( ! isPrime ( n ) ) return false ; long fact = 1 ; int i = 1 ; while ( fact <= n + 1 ) { fact = fact * i ; if ( n + 1 == fact n - 1 == fact ) return true ; i ++ ; } return false ; }
void sumArray ( int arr [ ] , int n ) { int leftSum [ ] = new int [ n ] ; int rightSum [ ] = new int [ n ] ; int Sum [ ] = new int [ n ] ; int i = 0 , j = 0 ; leftSum [ 0 ] = 0 ; rightSum [ n - 1 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( Sum [ i ] + " " ) ; }
int LcmSum ( int m ) { ETF ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j += i ) { ans [ j ] += ( i * phi [ i ] ) ; } } int answer = ans [ m ] ; answer = ( answer + 1 ) * m ; answer = answer / 2 ; return answer ; }
int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; }
int ncr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; }
int countWays ( String str ) { int freq [ ] = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { freq [ i ] = 0 ; } int nvowels = 0 , nconsonants = 0 ; int vplaces , cways , vways ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) ++ freq [ str . charAt ( i ) - 'a' ] ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) nvowels += freq [ i ] ; else nconsonants += freq [ i ] ; } vplaces = nconsonants + 1 ; cways = factorial ( nconsonants ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i != 0 && i != 4 && i != 8 && i != 14 && i != 20 && freq [ i ] > 1 ) { cways = cways / factorial ( freq [ i ] ) ; } } vways = ncr ( vplaces , nvowels ) * factorial ( nvowels ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 && freq [ i ] > 1 ) { vways = vways / factorial ( freq [ i ] ) ; } } return cways * vways ; }
int setBits ( int n ) { int count = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; count ++ ; } return count ; }
int countPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int setbits_x = setBits ( a [ i ] ) ; for ( int j = i + 1 ; j < n ; j ++ ) { int setbits_y = setBits ( a [ j ] ) ; int setbits_xor_xy = setBits ( a [ i ] ^ a [ j ] ) ; if ( setbits_x + setbits_y == setbits_xor_xy ) count ++ ; } } return count ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findPossibleDerivables ( int arr [ ] , int n , int D , int A , int B ) { int gcdAB = gcd ( A , B ) ; int counter = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( Math . abs ( arr [ i ] - D ) % gcdAB ) == 0 ) { counter ++ ; } } return counter ; }
int calSum ( int n ) { return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; }
int maxOfMin ( int a [ ] , int n , int S ) { int mi = Integer . MAX_VALUE ; int s1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s1 += a [ i ] ; mi = Math . min ( a [ i ] , mi ) ; } if ( s1 < S ) return - 1 ; if ( s1 == S ) return 0 ; int low = 0 ; int high = mi ; int ans = 0 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( s1 - ( mid * n ) >= S ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; }
void getElements ( int a , int arr [ ] , int n ) { int elements [ ] = new int [ n + 1 ] ; elements [ 0 ] = a ; for ( int i = 0 ; i < n ; i ++ ) { elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; } for ( int i = 0 ; i < n + 1 ; i ++ ) System . out . print ( elements [ i ] + " " ) ; }
int minimumX ( int n , int k ) { int mini = Integer . MAX_VALUE ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int fir = i ; int sec = n / i ; int num1 = fir * k + sec ; int res = ( num1 / k ) * ( num1 % k ) ; if ( res == n ) mini = Math . min ( num1 , mini ) ; int num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ; if ( res == n ) mini = Math . min ( num2 , mini ) ; } } return mini ; }
int minimumX ( int n , int k ) { int ans = Integer . MAX_VALUE ; for ( int rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = Math . min ( ans , rem + ( n / rem ) * k ) ; } return ans ; }
int maxGCD ( int N , int P ) { int ans = 1 ; Map < Integer , Integer > prime_factors = new HashMap < Integer , Integer > ( ) ; for ( int i = 2 ; i * i <= P ; i ++ ) { while ( P % i == 0 ) { if ( prime_factors . get ( i ) == null ) prime_factors . put ( i , 1 ) ; else prime_factors . put ( i , ( prime_factors . get ( i ) + 1 ) ) ; P /= i ; } } if ( P != 1 ) if ( prime_factors . get ( P ) == null ) prime_factors . put ( P , 1 ) ; else prime_factors . put ( P , ( prime_factors . get ( P ) + 1 ) ) ; Set < Map . Entry < Integer , Integer > > st = prime_factors . entrySet ( ) ; for ( Map . Entry < Integer , Integer > me : st ) { ans *= Math . pow ( me . getKey ( ) , me . getValue ( ) / N ) ; } return ans ; }
int getSum ( int arr [ ] , int p ) { return arr . length ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int countPairs ( int a [ ] , int n ) { int count = 0 ; Map < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( isPrime ( a [ i ] ^ a [ j ] ) && m . get ( a [ i ] ^ a [ j ] ) == null ) { m . put ( ( a [ i ] ^ a [ j ] ) , 1 ) ; count ++ ; } } } return count ; }
int count ( Node node ) { if ( node == null ) return 0 ; return count ( node . left ) + count ( node . right ) + 1 ; }
boolean check ( Node root ) { int n = count ( root ) ; Res res = new Res ( ) ; checkRec ( root , n , res ) ; return res . res ; }
int countDivisors ( int n ) { int x = 0 , ans = 1 ; while ( n % 2 == 0 ) { x ++ ; n = n / 2 ; } ans = ans * ( x + 1 ) ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { x = 0 ; while ( n % i == 0 ) { x ++ ; n = n / i ; } ans = ans * ( x + 1 ) ; } if ( n > 2 ) ans = ans * 2 ; return ans ; }
int getTotalCount ( int n , int k ) { int k_count = countDivisors ( k ) ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( k_count == countDivisors ( i ) ) count ++ ; if ( k < n ) count = count - 1 ; return count ; }
int getHermiteNumber ( int n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; }
int doubleFactorial ( int n ) { int fact = 1 ; for ( int i = 1 ; i <= n ; i = i + 2 ) { fact = fact * i ; } return fact ; }
int hermiteNumber ( int n ) { if ( n % 2 == 1 ) return 0 ; else { int number = ( int ) ( Math . pow ( 2 , n / 2 ) ) * doubleFactorial ( n - 1 ) ; if ( ( n / 2 ) % 2 == 1 ) number = number * - 1 ; return number ; } }
void find ( int n ) { int b = n ; int a = b * ( n - 1 ) ; if ( a * b > n && a / b < n ) { System . out . print ( "a = " + a + ", b = " + b ) ; } else System . out . println ( - 1 ) ; }
int SquareCube ( long N ) { int cnt = 0 , i = 1 ; while ( ( int ) ( Math . pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; }
long getSum ( int n , int d ) { long sum = 0 ; while ( d <= n ) { sum += d ; d += 10 ; } return sum ; }
boolean isPerfect ( int N ) { if ( ( Math . sqrt ( N ) - Math . floor ( Math . sqrt ( N ) ) ) != 0 ) return false ; return true ; }
void printThreeParts ( int N ) { if ( N % 3 == 0 ) System . out . println ( "x = 1, y = 1, z = " + ( N - 2 ) ) ; else System . out . println ( " x = 1, y = 2, z = " + ( N - 3 ) ) ; }
int sumX ( int N , int M , int K ) { for ( int i = 0 ; i < M ; i ++ ) { N = ( int ) sum ( K + N ) ; } N = N % MOD ; return N ; }
int countDigitsToBeRemoved ( int N , int K ) { String s = Integer . toString ( N ) ; int res = 0 ; int f_zero = 0 ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( K == 0 ) return res ; if ( s . charAt ( i ) == '0' ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( K == 0 ) return res ; else if ( f_zero == 1 ) return s . length ( ) - 1 ; return - 1 ; }
boolean isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; }
int largestPalindrome ( int [ ] A , int n ) { Arrays . sort ( A ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( isPalindrome ( A [ i ] ) ) return A [ i ] ; } return - 1 ; }
boolean isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; }
int largestPalindrome ( int [ ] A , int n ) { int currentMax = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > currentMax && isPalindrome ( A [ i ] ) ) currentMax = A [ i ] ; } return currentMax ; }
int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
boolean isPrime ( int N ) { for ( int i = 2 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; }
int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void printMode ( int [ ] a , int n ) { int max = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int t = max + 1 ; int [ ] count = new int [ t ] ; for ( int i = 0 ; i < t ; i ++ ) { count [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { count [ a [ i ] ] ++ ; } int mode = 0 ; int k = count [ 0 ] ; for ( int i = 1 ; i < t ; i ++ ) { if ( count [ i ] > k ) { k = count [ i ] ; mode = i ; } } System . out . println ( "mode = " + mode ) ; }
void checkTypeOfTriangle ( int a , int b , int c ) { int sqa = ( int ) Math . pow ( a , 2 ) ; int sqb = ( int ) Math . pow ( b , 2 ) ; int sqc = ( int ) Math . pow ( c , 2 ) ; if ( sqa == sqa + sqb sqb == sqa + sqc sqc == sqa + sqb ) { System . out . print ( "Right-angled Triangle" ) ; } else if ( sqa > sqc + sqb sqb > sqa + sqc sqc > sqa + sqb ) { System . out . print ( "Obtuse-angled Triangle" ) ; } else { System . out . print ( "Acute-angled Triangle" ) ; } }
int findLargestDivisor ( int n ) { int m = n ; Set < Integer > s = new HashSet < Integer > ( ) ; s . add ( 1 ) ; s . add ( n ) ; for ( int i = 2 ; i < ( int ) Math . sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) { s . add ( n / i ) ; s . add ( i ) ; while ( m % i == 0 ) m /= i ; } } if ( m > 1 ) s . add ( m ) ; List < Integer > l = new ArrayList < Integer > ( s ) ; Collections . sort ( l ) ; Collections . reverse ( l ) ; Vector < Integer > vec = new Vector < Integer > ( ) ; for ( int i = 2 ; i <= MAX ; i ++ ) vec . add ( i * i ) ; for ( int d : l ) { int divi = 0 ; for ( int j = 0 ; j < vec . size ( ) && vec . get ( j ) <= d ; j ++ ) { if ( d % vec . get ( j ) == 0 ) { divi = 1 ; break ; } } if ( divi == 0 ) return d ; } return 0 ; }
int findLargestDivisor ( int n ) { for ( int i = 2 ; i < Math . sqrt ( n ) + 1 ; i ++ ) { while ( n % ( i * i ) == 0 ) { n = n / i ; } } return n ; }
double findMedian ( int a [ ] , int n ) { Arrays . sort ( a ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; }
void printAMeans ( int A , int B , int N ) { float d = ( float ) ( B - A ) / ( N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( ( A + i * d ) + " " ) ; }
long getFinalElement ( long n ) { long finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; }
boolean checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; Arrays . sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
boolean isTriPerfect ( int n ) { int sum = 1 + n ; int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else sum = sum + i + n / i ; } i += 1 ; } if ( sum == 3 * n & n != 1 ) return true ; else return false ; }
void findGreater ( int a , int b ) { double x = ( double ) a * ( double ) ( Math . log ( ( double ) ( b ) ) ) ; double y = ( double ) b * ( double ) ( Math . log ( ( double ) ( a ) ) ) ; if ( y > x ) { System . out . println ( "a^b is greater" ) ; } else if ( y < x ) { System . out . println ( "b^a is greater" ) ; } else { System . out . println ( "Both are equal" ) ; } }
int sum ( int N , int X , int Y ) { int S1 , S2 , S3 ; S1 = ( ( N / X ) ) * ( 2 * X + ( N / X - 1 ) * X ) / 2 ; S2 = ( ( N / Y ) ) * ( 2 * Y + ( N / Y - 1 ) * Y ) / 2 ; S3 = ( ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; }
long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
long modexp ( long x , long n ) { if ( n == 0 ) { return 1 ; } else if ( n % 2 == 0 ) { return modexp ( ( x * x ) % m , n / 2 ) ; } else { return ( x * modexp ( ( x * x ) % m , ( n - 1 ) / 2 ) % m ) ; } }
long getFractionModulo ( long a , long b ) { long c = gcd ( a , b ) ; a = a / c ; b = b / c ; long d = modexp ( b , m - 2 ) ; long ans = ( ( a % m ) * ( d % m ) ) % m ; return ans ; }
int startingPoint ( int Length , int Speed1 , int Speed2 ) { int result1 = 0 , result2 = 0 ; int time1 = Length / Speed1 ; int time2 = Length / Speed2 ; result1 = __gcd ( time1 , time2 ) ; result2 = time1 * time2 / ( result1 ) ; return result2 ; }
float firstTime ( int Length , int Speed1 , int Speed2 ) { float result = 0 ; int relativeSpeed = Math . abs ( Speed1 - Speed2 ) ; result = ( ( float ) Length / relativeSpeed ) ; return result ; }
int findNumber ( int n ) { int i = n - 1 ; while ( i > 0 ) { if ( sumOfDigits ( i ) > sumOfDigits ( n ) ) return i ; i -- ; } return - 1 ; }
int findTwoThreePrime ( int l , int r ) { if ( l == 1 ) l ++ ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; while ( num % 2 == 0 ) num /= 2 ; while ( num % 3 == 0 ) num /= 3 ; if ( num == 1 ) count ++ ; } return count ; }
int findNth ( int N ) { int b = 14 ; int i ; for ( i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) b = b * 2 ; else b = b - 8 ; } return b ; }
void icanobifNumbers ( int N ) { int first = 0 , second = 1 ; if ( N == 1 ) System . out . print ( first ) ; else if ( N == 2 ) System . out . print ( first + " " + second ) ; else { System . out . print ( first + " " + second + " " ) ; for ( int i = 3 ; i <= N ; i ++ ) { int x = reversDigits ( first ) ; int y = reversDigits ( second ) ; System . out . print ( x + y + " " ) ; int temp = second ; second = x + y ; first = temp ; } } }
int addNDigits ( int a , int b , int n ) { int num = a ; for ( int i = 0 ; i <= 9 ; i ++ ) { int tmp = a * 10 + i ; if ( tmp % b == 0 ) { a = tmp ; break ; } } if ( num == a ) return - 1 ; for ( int j = 0 ; j < n - 1 ; j ++ ) a *= 10 ; return a ; }
void predictMatrix ( int arr [ ] [ ] , int range1a , int range1b , int range0a , int range0b , int K , int b [ ] [ ] ) { int c = 0 ; while ( K != 0 ) { K -- ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { c = 0 ; if ( i > 0 && arr [ i - 1 ] [ j ] == 1 ) c ++ ; if ( j > 0 && arr [ i ] [ j - 1 ] == 1 ) c ++ ; if ( i > 0 && j > 0 && arr [ i - 1 ] [ j - 1 ] == 1 ) c ++ ; if ( i < N - 1 && arr [ i + 1 ] [ j ] == 1 ) c ++ ; if ( j < N - 1 && arr [ i ] [ j + 1 ] == 1 ) c ++ ; if ( i < N - 1 && j < N - 1 && arr [ i + 1 ] [ j + 1 ] == 1 ) c ++ ; if ( i < N - 1 && j > 0 && arr [ i + 1 ] [ j - 1 ] == 1 ) c ++ ; if ( i > 0 && j < N - 1 && arr [ i - 1 ] [ j + 1 ] == 1 ) c ++ ; if ( arr [ i ] [ j ] == 1 ) { if ( c >= range1a && c <= range1b ) b [ i ] [ j ] = 1 ; else b [ i ] [ j ] = 0 ; } if ( arr [ i ] [ j ] == 0 ) { if ( c >= range0a && c <= range0b ) b [ i ] [ j ] = 1 ; else b [ i ] [ j ] = 0 ; } } } for ( int k = 0 ; k < N ; k ++ ) for ( int m = 0 ; m < N ; m ++ ) arr [ k ] [ m ] = b [ k ] [ m ] ; } }
int countMoves ( int n ) { int ct = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ct += i * ( n - i ) ; ct += n ; return ct ; }
int Triplets ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = i ; j <= n ; ++ j ) { int x = i * i + j * j ; int y = ( int ) Math . sqrt ( x ) ; if ( y * y == x && y <= n ) ++ ans ; } } return ans ; }
int countTriplets ( int n ) { ArrayList < Integer > perfectSquares = getPerfectSquares ( ( int ) Math . pow ( n , 2 ) ) ; int count = 0 ; for ( int a = 1 ; a <= n ; a ++ ) { int aSquare = ( int ) Math . pow ( a , 2 ) ; for ( int i = 0 ; i < perfectSquares . size ( ) ; i ++ ) { int cSquare = perfectSquares . get ( i ) ; int bSquare = cSquare - aSquare ; int b = ( int ) Math . sqrt ( bSquare ) ; int c = ( int ) Math . sqrt ( cSquare ) ; if ( c < a || ! perfectSquares . contains ( bSquare ) ) continue ; if ( ( b >= a ) && ( b <= c ) && ( aSquare + bSquare == cSquare ) ) count ++ ; } } return count ; }
void SumsOfDigits ( int n ) { int sum = 0 ; for ( int base = 2 ; base <= n / 2 ; ++ base ) sum += solve ( n , base ) ; System . out . println ( sum ) ; }
int minimumMoves ( int k , int l , int r ) { int count = r - l + 1 ; if ( count % k == 0 ) return 0 ; return ( k - ( count % k ) ) ; }
boolean checkPerfectcube ( int n ) { int d = ( int ) Math . cbrt ( n ) ; if ( d * d * d == n ) return true ; return false ; }
int largestNonPerfectcubeNumber ( int [ ] a , int n ) { int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! checkPerfectcube ( a [ i ] ) ) maxi = Math . max ( a [ i ] , maxi ) ; } return maxi ; }
int sumNatural ( int n ) { int sum = ( n * ( n + 1 ) ) ; return sum ; }
void checkIfPossibleRec ( int x , int a , int b , boolean isPossible [ ] , int n ) { if ( x > n ) return ; if ( isPossible [ x ] ) return ; isPossible [ x ] = true ; checkIfPossibleRec ( x + a , a , b , isPossible , n ) ; checkIfPossibleRec ( x + b , a , b , isPossible , n ) ; }
boolean checkPossible ( int n , int a , int b ) { boolean isPossible [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) isPossible [ i ] = false ; checkIfPossibleRec ( 0 , a , b , isPossible , n ) ; return isPossible [ n ] ; }
boolean isDivisibleRec ( int x , int a , int b , int n ) { if ( x > n ) return false ; if ( n % x == 0 ) return true ; return ( isDivisibleRec ( x * 10 + a , a , b , n ) || isDivisibleRec ( x * 10 + b , a , b , n ) ) ; }
boolean isDivisible ( int a , int b , int n ) { return isDivisibleRec ( a , a , b , n ) || isDivisibleRec ( b , a , b , n ) ; }
int sumOdd ( int n ) { int terms = ( n + 1 ) / 2 ; int sum = terms * terms ; return sum ; }
int suminRange ( int l , int r ) { return sumOdd ( r ) - sumOdd ( l - 1 ) ; }
int sumNatural ( int n ) { int sum = ( n * ( n + 1 ) ) / 2 ; return sum ; }
int suminRange ( int l , int r ) { return sumNatural ( r ) - sumNatural ( l - 1 ) ; }
boolean CheckArray ( int arr [ ] , int n ) { int prod = 1 ; for ( int i = 0 ; i < n ; ++ i ) prod *= arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] == prod / arr [ i ] ) return true ; return false ; }
boolean CheckArray ( int arr [ ] , int n ) { int prod = 1 ; ArrayList < Integer > freq = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { freq . add ( arr [ i ] ) ; prod *= arr [ i ] ; } int root = ( int ) Math . sqrt ( prod ) ; if ( root * root == prod ) { if ( freq . contains ( root ) & freq . lastIndexOf ( root ) != ( freq . size ( ) ) ) { return true ; } } return false ; }
long sumOfAllPalindrome ( int L , int R ) { long sum = 0 ; if ( L <= R ) for ( int i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) && isOddLength ( i ) ) { sum += i ; } } return sum ; }
boolean divisibleBy25 ( String number ) { if ( number . length ( ) < 2 ) return false ; int length = number . length ( ) ; int lastTwo = ( number . charAt ( length - 2 ) - '0' ) * 10 + ( number . charAt ( length - 1 ) - '0' ) ; if ( lastTwo % 25 == 0 ) return true ; return false ; }
boolean divisibleBy75 ( String number ) { if ( divisibleBy3 ( number ) && divisibleBy25 ( number ) ) return true ; return false ; }
int breakEvenPoint ( int exp1 , int S , int M ) { double earn = S - M ; double exp = exp1 ; double res = Math . ceil ( exp / earn ) ; int res1 = ( int ) res ; return res1 ; }
int otherNumber ( int A , int Lcm , int Hcf ) { return ( Lcm * Hcf ) / A ; }
int sum ( int a , int b ) { int sum = 0 ; for ( int i = 1 ; i <= Math . min ( a , b ) ; i ++ ) if ( a % i == 0 && b % i == 0 ) sum += i ; return sum ; }
int sumcommDiv ( int a , int b ) { int n = gcd ( a , b ) ; int sum = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum += i ; else sum += ( n / i ) + i ; } } return sum ; }
int minimumNumbers ( int n , int s ) { if ( ( s % n ) > 0 ) return s / n + 1 ; else return s / n ; }
int search ( int arr [ ] , int strt , int end , int value ) { for ( int i = strt ; i <= end ; i ++ ) { if ( arr [ i ] == value ) return i ; } return - 1 ; }
int checkPostorder ( Node node , int postOrder [ ] , int index ) { if ( node == null ) return index ; index = checkPostorder ( node . left , postOrder , index ) ; index = checkPostorder ( node . right , postOrder , index ) ; if ( node . data == postOrder [ index ] ) index ++ ; else return - 1 ; return index ; }
int sumAP ( int n , int d ) { n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; }
int sumMultiples ( int A , int B , int n ) { n -- ; int common = ( A * B ) / __gcd ( A , B ) ; return sumAP ( n , A ) + sumAP ( n , B ) - sumAP ( n , common ) ; }
boolean isPossible ( int N ) { if ( isPrime ( N ) && isPrime ( N - 2 ) ) return true ; else return false ; }
int totalPairs ( int [ ] arr1 , int [ ] arr2 , int K , int n , int m ) { HashSet < pair > s = new HashSet < pair > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] > arr2 [ j ] ) { if ( arr1 [ i ] % arr2 [ j ] == K ) s . add ( new pair ( arr1 [ i ] , arr2 [ j ] ) ) ; } else { if ( arr2 [ j ] % arr1 [ i ] == K ) s . add ( new pair ( arr2 [ j ] , arr1 [ i ] ) ) ; } } } return s . size ( ) ; }
int contiguousPerfectSquare ( int [ ] arr , int n ) { int a ; float b ; int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { b = ( float ) Math . sqrt ( arr [ i ] ) ; a = ( int ) b ; if ( a == b ) current_length ++ ; else current_length = 0 ; max_length = Math . max ( max_length , current_length ) ; } return max_length ; }
float getSum ( int a , int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { sum += ( i / Math . pow ( a , i ) ) ; } return sum ; }
int getIndex ( int a [ ] , int n ) { if ( n == 1 ) return 0 ; int ptrL = 0 , ptrR = n - 1 , sumL = a [ 0 ] , sumR = a [ n - 1 ] ; while ( ptrR - ptrL > 1 ) { if ( sumL < sumR ) { ptrL ++ ; sumL += a [ ptrL ] ; } else if ( sumL > sumR ) { ptrR -- ; sumR += a [ ptrR ] ; } else { break ; } } return ptrL ; }
int getPosition ( int a [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] / m + ( a [ i ] % m ) ) ; } int ans = - 1 , max = - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( max < a [ i ] ) { max = a [ i ] ; ans = i ; } } return ans + 1 ; }
int calcFunction ( int n , int r ) { int finalDenominator = 1 ; int mx = Math . max ( r , n - r ) ; for ( int i = mx + 1 ; i <= n ; i ++ ) { int denominator = ( int ) Math . pow ( i , i ) ; int numerator = ( int ) Math . pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; }
void generateNumbers ( int n , int num , int a , int b ) { if ( num > 0 && num < n ) st . add ( num ) ; if ( num >= n ) return ; if ( num * 10 + a > num ) generateNumbers ( n , num * 10 + a , a , b ) ; generateNumbers ( n , num * 10 + b , a , b ) ; }
int findSmallest ( int arr [ ] , int n ) { int MAX = max_element ( arr ) ; Vector < Integer > prime = findPrime ( MAX ) ; Set < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) s . add ( arr [ i ] ) ; long ans = - 1 ; for ( int i = 0 ; i < prime . size ( ) ; i ++ ) { if ( ! s . contains ( prime . get ( i ) ) ) { ans = ( prime . get ( i ) ) ; break ; } } return ( int ) ans ; }
int minOperations ( int [ ] A , int n ) { if ( ( n & 1 ) > 0 ) return - 1 ; int zeros = 0 , consZeros = 0 , ones = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] == 0 ) zeros ++ ; else ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return - 1 ; }
int minimumCuts ( int a [ ] , int n ) { Arrays . sort ( a ) ; int gcd = a [ 1 ] - a [ 0 ] ; int s = gcd ; for ( int i = 2 ; i < n ; i ++ ) { gcd = findgcd ( gcd , a [ i ] - a [ i - 1 ] ) ; s += a [ i ] - a [ i - 1 ] ; } if ( 360 - s > 0 ) gcd = findgcd ( gcd , 360 - s ) ; return ( 360 / gcd ) - n ; }
int countdig ( int m ) { if ( m == 0 ) return 0 ; else return 1 + countdig ( m / 10 ) ; }
int countSteps ( int x ) { int c = 0 ; int last = x ; while ( last > 0 ) { int digits = countdig ( last ) ; digits -= 1 ; int divisor = ( int ) Math . pow ( 10 , digits ) ; int first = last / divisor ; int lastnumber = first * divisor ; int skipped = ( last - lastnumber ) / first ; skipped += 1 ; c += skipped ; last = last - ( first * skipped ) ; } return c ; }
int findNum ( int div [ ] , int rem [ ] , int N ) { int num = rem [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; }
void profitLoss ( int N , int M ) { if ( N == M ) System . out . print ( "No Profit nor Loss" ) ; else { float result = 0 ; result = ( float ) ( Math . abs ( N - M ) ) / M ; if ( N - M < 0 ) System . out . print ( "Loss = -" + result * 100 + "%" ) ; else System . out . print ( "Profit = " + result * 100 + "%" ) ; } }
void niceIndices ( int A [ ] , int n ) { int sum = 0 ; Map < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { m . put ( A [ i ] , ( m . get ( A [ i ] ) == null ) ? 0 : m . get ( A [ i ] ) + 1 ) ; sum += A [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { int k = sum - A [ i ] ; if ( k % 2 == 0 ) { k = k >> 1 ; if ( m . containsKey ( k ) ) { if ( ( A [ i ] == k && m . get ( k ) > 1 ) || ( A [ i ] != k ) ) System . out . print ( ( i + 1 ) + " " ) ; } } } }
void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } }
Vector < Integer > getFactorization ( int x ) { Vector < Integer > ret = new Vector < Integer > ( ) ; while ( x != 1 ) { int temp = spf [ x ] ; ret . add ( temp ) ; while ( x % temp == 0 ) x = x / temp ; } return ret ; }
int maxElement ( int A [ ] , int n ) { sieve ( ) ; Map < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int j = 0 ; j < n ; ++ j ) { Vector < Integer > p = getFactorization ( A [ j ] ) ; for ( int i = 0 ; i < p . size ( ) ; i ++ ) m . put ( p . get ( i ) , m . get ( p . get ( i ) ) == null ? 0 : m . get ( p . get ( i ) ) + 1 ) ; } int cnt = 0 , ans = 10000000 ; Set < Map . Entry < Integer , Integer > > st = m . entrySet ( ) ; for ( Map . Entry < Integer , Integer > me : st ) { if ( me . getValue ( ) >= cnt ) { cnt = me . getValue ( ) ; if ( ans > me . getKey ( ) ) ans = me . getKey ( ) ; else ans = ans ; } } return ans ; }
int countPieces ( int N ) { return 2 * N ; }
float SellingPrice ( float CP , float PP ) { float P_decimal = 1 + ( PP / 100 ) ; float res = P_decimal * CP ; return res ; }
long sumMultiples ( long n ) { n -- ; return sumAP ( n , 3 ) + sumAP ( n , 7 ) - sumAP ( n , 21 ) ; }
boolean productSumDivisible ( int n , int size ) { int sum = 0 , product = 1 ; while ( n > 0 ) { if ( size % 2 == 0 ) { product *= n % 10 ; } else { sum += n % 10 ; } n = n / 10 ; size -- ; } if ( product % sum == 0 ) { return true ; } return false ; }
long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
long powGCD ( long a , long n , long b ) { for ( int i = 0 ; i < n ; i ++ ) a = a * a ; return gcd ( a , b ) ; }
long power ( long x , long y , long p ) { while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
long powerGCD ( long a , long b , long n ) { long e = power ( a , n , b ) ; return gcd ( e , b ) ; }
int lastCoordinate ( int n , int a , int b ) { return ( ( n + 1 ) / 2 ) * a - ( n / 2 ) * b ; }
boolean allOddDigits ( int n ) { while ( n != 0 ) { if ( ( n % 10 ) % 2 == 0 ) return false ; n /= 10 ; } return true ; }
int largestNumber ( int n ) { if ( n % 2 == 0 ) n -- ; for ( int i = n ; ; i -= 2 ) if ( allOddDigits ( i ) ) return i ; }
int findNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }
void countDigit ( int n ) { int temp = n , sum = 0 , product = 1 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } System . out . print ( "Sum = " + sum ) ; System . out . print ( "Product=" + product ) ; }
int findNum ( int N , int K ) { int rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
boolean isDivisiblePalindrome ( int n ) { int hash [ ] = new int [ 10 ] ; int digitSum = 0 ; while ( n != 0 ) { digitSum += n % 10 ; hash [ n % 10 ] ++ ; n /= 10 ; } if ( digitSum % 3 != 0 ) return false ; int oddCount = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( hash [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount > 1 ) return false ; else return true ; }
int countNumbers ( int N ) { return ( int ) Math . sqrt ( N ) - 1 ; }
int countOrderedPairs ( int N ) { int count_pairs = 0 ; for ( int i = 1 ; i <= ( int ) Math . sqrt ( N - 1 ) ; ++ i ) { for ( int j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= ( int ) ( Math . sqrt ( N - 1 ) ) ; return count_pairs ; }
int toK ( int N , int K ) { int w = 1 ; int s = 0 ; while ( N != 0 ) { int r = N % K ; N = N / K ; s = r * w + s ; w *= 10 ; } return s ; }
void hasConsecutiveZeroes ( int N , int K ) { int z = toK ( N , K ) ; if ( check ( z ) ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
boolean check ( int s ) { int [ ] freq = new int [ 10 ] ; int r , i ; for ( i = 0 ; i < 10 ; i ++ ) { freq [ i ] = 0 ; } while ( s != 0 ) { r = s % 10 ; s = ( int ) ( s / 10 ) ; freq [ r ] += 1 ; } int xor__ = 0 ; for ( i = 0 ; i < 10 ; i ++ ) { xor__ = xor__ ^ freq [ i ] ; if ( xor__ == 0 ) return true ; else return false ; } return true ; }
int lcm ( int a , int b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; }
int dfs ( int src , Vector < Integer > adj [ ] , boolean [ ] visited ) { visited [ src ] = true ; int count = 1 ; for ( int i = 0 ; i < adj [ src ] . size ( ) ; i ++ ) if ( ! visited [ adj [ src ] . get ( i ) ] ) count += dfs ( adj [ src ] . get ( i ) , adj , visited ) ; return count ; }
int findMinTime ( int arr [ ] , int P [ ] , int n ) { Vector < Integer > [ ] adj = new Vector [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { adj [ arr [ i ] ] . add ( P [ i ] ) ; } boolean [ ] visited = new boolean [ n + 1 ] ; int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! visited [ i ] ) { ans = lcm ( ans , dfs ( i , adj , visited ) ) ; } } return ans ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) { prime [ i ] = false ; } } } }
void SieveOfEratosthenes ( ) { for ( int p = 2 ; p * p <= MAX ; p ++ ) if ( prime [ p ] == false ) for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = true ; }
int superpower ( int n ) { SieveOfEratosthenes ( ) ; int superPower = 0 , factor = 0 ; int i = 2 ; while ( n > 1 && i <= MAX ) { if ( ! prime [ i ] ) { factor = 0 ; while ( n % i == 0 && n > 1 ) { factor ++ ; n = n / i ; } if ( superPower < factor ) superPower = factor ; } i ++ ; } return superPower ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int countPrime ( Node head_ref ) { int count = 0 ; Node ptr = head_ref ; while ( ptr != null ) { if ( isPrime ( ptr . data ) ) { count ++ ; } ptr = ptr . next ; } return count ; }
void pairwiseDifference ( int arr [ ] , int n ) { int diff ; for ( int i = 0 ; i < n - 1 ; i ++ ) { diff = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; System . out . print ( diff + " " ) ; } }
int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; }
int npr ( int n , int r ) { int pnr = factorial ( n ) / factorial ( n - r ) ; return pnr ; }
int countPermutations ( int n , int r , int k ) { return factorial ( k ) * ( r - k + 1 ) * npr ( n - k , r - k ) ; }
long sumMultiples ( long n ) { n -- ; return sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 10 ) ; }
int GIF ( double n ) { return ( int ) Math . floor ( n ) ; }
int ncr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; }
int smallestDivisor ( int n ) { if ( n % 2 == 0 ) return 2 ; for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return i ; } return n ; }
int countRabbits ( int Heads , int Legs ) { int count = 0 ; count = ( Legs ) - 2 * ( Heads ) ; count = count / 2 ; return count ; }
int compositeProduct ( int arr [ ] , int n ) { int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; boolean [ ] prime = new boolean [ max_val + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = true ; prime [ 1 ] = true ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) { prime [ i ] = false ; } } } int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! prime [ arr [ i ] ] ) { product *= arr [ i ] ; } } return product ; }
int markingScheme ( int N , int answerKey [ ] , int studentAnswer [ ] ) { int positive = 0 , negative = 0 , notattempt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( studentAnswer [ i ] == 0 ) notattempt ++ ; else if ( answerKey [ i ] == studentAnswer [ i ] ) positive ++ ; else if ( answerKey [ i ] != studentAnswer [ i ] ) negative ++ ; } return ( positive * 3 ) + ( negative * - 1 ) ; }
boolean SumDivisible ( int n , int k ) { int sum = 0 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 1 ) sum += n % 10 ; n = n / 10 ; position ++ ; } if ( sum % k == 0 ) return true ; return false ; }
int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f = f * i ; return f ; }
int waysOfConsonants ( int size1 , int [ ] freq ) { int ans = fact ( size1 ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) continue ; else ans = ans / fact ( freq [ i ] ) ; } return ans ; }
int waysOfVowels ( int size2 , int [ ] freq ) { return fact ( size2 ) / ( fact ( freq [ 0 ] ) * fact ( freq [ 4 ] ) * fact ( freq [ 8 ] ) * fact ( freq [ 14 ] ) * fact ( freq [ 20 ] ) ) ; }
int countWays ( String str ) { int [ ] freq = new int [ 200 ] ; for ( int i = 0 ; i < 200 ; i ++ ) freq [ i ] = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) freq [ str . charAt ( i ) - 'a' ] ++ ; int vowel = 0 , consonant = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) != 'a' && str . charAt ( i ) != 'e' && str . charAt ( i ) != 'i' && str . charAt ( i ) != 'o' && str . charAt ( i ) != 'u' ) consonant ++ ; else vowel ++ ; } return waysOfConsonants ( consonant + 1 , freq ) * waysOfVowels ( vowel , freq ) ; }
int findX ( int n , int k ) { int r = n , v , u ; int m = ( int ) Math . sqrt ( k ) + 1 ; for ( int i = 2 ; i <= m && k > 1 ; i ++ ) { if ( i == m ) { i = k ; } for ( u = v = 0 ; k % i == 0 ; v ++ ) { k /= i ; } if ( v > 0 ) { int t = n ; while ( t > 0 ) { t /= i ; u += t ; } r = Math . min ( r , u / v ) ; } } return r ; }
int ncr ( int n , int r ) { int ncr = fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; return ncr ; }
void maxSum ( int [ ] a , int n ) { int maxAnd = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ; int maxOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxOR |= a [ i ] ; } System . out . println ( ( maxAnd + maxOR ) ) ; }
int sum_odd ( int n ) { int sum = 0 , pos = 1 ; while ( n > 0 ) { if ( pos % 2 == 1 ) sum += n % 10 ; n = n / 10 ; pos ++ ; } return sum ; }
boolean check_prime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
double calculateSum ( double n ) { return 2 * ( Math . pow ( n , 6 ) + 15 * Math . pow ( n , 4 ) + 15 * Math . pow ( n , 2 ) + 1 ) ; }
int solve ( int n ) { int count = 0 , num = 1 ; int prod = 1 ; while ( count < n ) { if ( ! prime [ num ] ) { prod *= num ; count ++ ; } num ++ ; } return prod ; }
void ReplaceElements ( int arr [ ] , int n ) { int prod = 1 ; for ( int i = 0 ; i < n ; ++ i ) { prod *= arr [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { arr [ i ] = prod / arr [ i ] ; } }
int sum ( int n ) { if ( n == 0 ) return 0 ; if ( n % 2 == 1 ) { return square ( ( n + 1 ) / 2 ) + sum ( n / 2 ) ; } else { return square ( n / 2 ) + sum ( n / 2 ) ; } }
int oddDivSum ( int a , int b ) { return sum ( b ) - sum ( a - 1 ) ; }
int countBits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n >>= 1 ; } return count ; }
boolean isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= Math . sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; }
boolean isPower ( int a ) { if ( a == 1 ) return true ; for ( int i = 2 ; i * i <= a ; i ++ ) { double val = Math . log ( a ) / Math . log ( i ) ; if ( ( val - ( int ) val ) < 0.00000001 ) return true ; } return false ; }
boolean isAchillesNumber ( int n ) { if ( isPowerful ( n ) && ! isPower ( n ) ) return true ; else return false ; }
int OddDivCount ( int a , int b ) { int res = 0 ; for ( int i = a ; i <= b ; ++ i ) { int divCount = 0 ; for ( int j = 1 ; j <= i ; ++ j ) { if ( i % j == 0 ) { ++ divCount ; } } if ( ( divCount % 2 ) != 0 ) { ++ res ; } } return res ; }
int divisor ( int a ) { int div = 1 , count = 0 ; for ( int i = 2 ; i <= Math . sqrt ( a ) ; i ++ ) { while ( a % i == 0 ) { count ++ ; a = a / i ; } div = div * ( count + 1 ) ; count = 0 ; } if ( a > 1 ) { div = div * ( 2 ) ; } return div ; }
int OddDivCount ( int a , int b ) { int res = 0 ; for ( int i = a ; i <= b ; ++ i ) { int divCount = divisor ( i ) ; if ( divCount % 2 == 1 ) { ++ res ; } } return res ; }
boolean Check_is_possible ( int l , int r , int k ) { int div_count = ( r / k ) - ( l / k ) ; if ( l % k == 0 ) { div_count ++ ; } return ( div_count > 1 ) ; }
boolean isValid ( int N , int K ) { HashSet < Integer > m1 = new HashSet < Integer > ( ) ; HashSet < Integer > m2 = new HashSet < Integer > ( ) ; while ( N > 0 ) { m1 . add ( N % 10 ) ; N /= 10 ; } while ( K > 0 ) { m2 . add ( K % 10 ) ; K /= 10 ; } if ( m1 . equals ( m2 ) ) { return true ; } return false ; }
int largestSquareFactor ( int num ) { int answer = 1 ; for ( int i = 2 ; i < Math . sqrt ( num ) ; ++ i ) { int cnt = 0 ; int j = i ; while ( num % j == 0 ) { cnt ++ ; j *= i ; } if ( ( cnt & 1 ) != 0 ) { cnt -- ; answer *= Math . pow ( i , cnt ) ; } else { answer *= Math . pow ( i , cnt ) ; } } return answer ; }
int nth_group ( int n ) { return n * ( 2 * ( int ) Math . pow ( n , 2 ) + 1 ) ; }
boolean checkUnusual ( int n ) { int factor = largestPrimeFactor ( n ) ; if ( factor > Math . sqrt ( n ) ) { return true ; } else { return false ; } }
void printPossible ( int a , int b , int c ) { if ( ( a + b + c ) % 2 != 0 a + b < c ) System . out . println ( "NO" ) ; else System . out . println ( "YES" ) ; }
int isChangeable ( int notes [ ] , int n ) { int fiveCount = 0 ; int tenCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( notes [ i ] == 5 ) fiveCount ++ ; else if ( notes [ i ] == 10 ) { if ( fiveCount > 0 ) { fiveCount -- ; tenCount ++ ; } else return 0 ; } else { if ( fiveCount > 0 && tenCount > 0 ) { fiveCount -- ; tenCount -- ; } else if ( fiveCount >= 3 ) { fiveCount -= 3 ; } else return 0 ; } } return 1 ; }
int sumSubarrayMins ( int A [ ] , int n ) { int [ ] left = new int [ n ] ; int [ ] right = new int [ n ] ; Stack < pair > s1 = new Stack < pair > ( ) ; Stack < pair > s2 = new Stack < pair > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { int cnt = 1 ; while ( ! s1 . isEmpty ( ) && ( s1 . peek ( ) . first ) > A [ i ] ) { cnt += s1 . peek ( ) . second ; s1 . pop ( ) ; } s1 . push ( new pair ( A [ i ] , cnt ) ) ; left [ i ] = cnt ; } for ( int i = n - 1 ; i >= 0 ; -- i ) { int cnt = 1 ; while ( ! s2 . isEmpty ( ) && ( s2 . peek ( ) . first ) >= A [ i ] ) { cnt += s2 . peek ( ) . second ; s2 . pop ( ) ; } s2 . push ( new pair ( A [ i ] , cnt ) ) ; right [ i ] = cnt ; } int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) result = ( result + A [ i ] * left [ i ] * right [ i ] ) ; return result ; }
boolean isPerfectPower ( int n ) { if ( n == 1 ) { return true ; } for ( int x = 2 ; x <= Math . sqrt ( n ) ; x ++ ) { int y = 2 ; int p = ( int ) Math . pow ( x , y ) ; while ( p <= n && p > 0 ) { if ( p == n ) { return true ; } y ++ ; p = ( int ) Math . pow ( x , y ) ; } } return false ; }
boolean isTrojan ( int n ) { if ( ! isPerfectPower ( n ) && isStrongNumber ( n ) ) { return true ; } else { return false ; } }
double Nth_Term ( int n ) { return ( 2 * Math . pow ( n , 3 ) - 3 * Math . pow ( n , 2 ) + n + 6 ) / 6 ; }
int Sum_upto_nth_Term ( int n ) { return ( 1 - ( int ) Math . pow ( - 2 , n ) ) ; }
int Nth_Term ( int n ) { return ( int ) ( 3 * Math . pow ( n , 2 ) - n + 2 ) / ( 2 ) ; }
void countPermutations ( int N , int B ) { int x = ( int ) Math . pow ( B , N ) ; int y = ( int ) Math . pow ( B , N - 1 ) ; System . out . println ( x - y ) ; }
int calculateDifference ( int [ ] arr , int n ) { int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; boolean [ ] prime = new boolean [ max_val + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int P1 = 1 , P2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { P1 *= arr [ i ] ; } else if ( arr [ i ] != 1 ) { P2 *= arr [ i ] ; } } return Math . abs ( P2 - P1 ) ; }
int CalculateDifference ( int arr [ ] , int n ) { int max_val = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_val ) max_val = arr [ i ] ; } boolean [ ] prime = new boolean [ max_val + 1 ] ; for ( int i = 0 ; i <= max_val ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int S1 = 0 , S2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { S1 += arr [ i ] ; } else if ( arr [ i ] != 1 ) { S2 += arr [ i ] ; } } return Math . abs ( S2 - S1 ) ; }
int EqualNumbers ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n != 0 ) return n - 1 ; return n ; }
int getMin ( int arr [ ] , int n , int k ) { int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { res = Math . min ( res , arr [ i ] ) ; } } return res ; }
int getMax ( int arr [ ] , int n , int k ) { int res = Integer . MIN_VALUE ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { res = Math . max ( res , arr [ i ] ) ; } } return res ; }
void printNumberWithDR ( int k , int d ) { if ( d == 0 && k != 1 ) System . out . print ( "-1" ) ; else { System . out . print ( d ) ; k -- ; while ( k -- > 0 ) System . out . print ( "0" ) ; } }
int count_odd_pair ( int n , int a [ ] ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } int ans = odd * even * 2 ; return ans ; }
int count_even_pair ( int odd_sum_pairs , int n ) { int total_pairs = ( n * ( n - 1 ) ) ; int ans = total_pairs - odd_sum_pairs ; return ans ; }
int findSteps ( int n , int m , int a [ ] ) { int cur = 1 ; int steps = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( a [ i ] >= cur ) steps += ( a [ i ] - cur ) ; else steps += ( n - cur + a [ i ] ) ; cur = a [ i ] ; } return steps ; }
int xorEqualsOrCount ( int N ) { int count = 0 ; int bit ; while ( N > 0 ) { bit = N % 2 ; if ( bit == 0 ) count ++ ; N = N / 2 ; } return ( int ) Math . pow ( 2 , count ) ; }
int fact ( int n ) { if ( n == 1 ) return 1 ; return n * fact ( n - 1 ) ; }
double sum ( int x , int n ) { double total = 1.0 ; for ( int i = 1 ; i <= n ; i ++ ) { total = total + ( Math . pow ( x , i ) / fact ( i + 1 ) ) ; } return total ; }
double sum ( int x , int n ) { double total = 1.0 ; double previous = 1.0 ; for ( int i = 1 ; i <= n ; i ++ ) { previous = ( previous * x ) / ( i + 1 ) ; total = total + previous ; } return total ; }
boolean isPowerOfTwo ( int x ) { return ( x > 0 && ( ! ( ( x & ( x - 1 ) ) > 0 ) ) ) ; }
void Count_pairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerOfTwo ( a [ i ] ) ) count ++ ; } int ans = ( count * ( count - 1 ) ) / 2 ; System . out . println ( ans ) ; }
int numberOfDivisors ( int num ) { int c = 0 ; for ( int i = 1 ; i <= num ; i ++ ) { if ( num % i == 0 ) { c += 1 ; } } return c ; }
int countNumbers ( int n ) { int c = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( numberOfDivisors ( i ) == 9 ) c += 1 ; } return c ; }
int countNumbers ( int n ) { int c = 0 ; int limit = ( int ) Math . sqrt ( n ) ; int prime [ ] = new int [ limit + 1 ] ; for ( int i = 1 ; i <= limit ; i ++ ) { prime [ i ] = i ; } for ( int i = 2 ; i * i <= limit ; i ++ ) { if ( prime [ i ] == i ) { for ( int j = i * i ; j <= limit ; j += i ) { if ( prime [ j ] == j ) { prime [ j ] = i ; } } } } for ( int i = 2 ; i <= limit ; i ++ ) { int p = prime [ i ] ; int q = prime [ i / prime [ i ] ] ; if ( p * q == i && q != 1 && p != q ) { c += 1 ; } else if ( prime [ i ] == i ) { if ( Math . pow ( i , 8 ) <= n ) { c += 1 ; } } } return c ; }
int sumNth ( int A [ ] , int B [ ] , int m , int n ) { int res = 0 ; if ( n == 1 ) { for ( int i = 0 ; i < m ; i ++ ) res = res + A [ i ] ; } else if ( n == 2 ) { for ( int i = 0 ; i < m ; i ++ ) res = res + B [ i ] * m ; } else { int f [ ] = new int [ n ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; for ( int i = 0 ; i < m ; i ++ ) { res = res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ; } } return res ; }
int factorial ( int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = result * i ; return result ; }
int nCr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; }
int calculate_result ( int n ) { int result = 2 * nCr ( ( n - 2 ) , ( n / 2 - 1 ) ) ; return result ; }
void isHalfReducible ( int arr [ ] , int n , int m ) { int frequencyHash [ ] = new int [ m + 1 ] ; int i ; for ( i = 0 ; i < frequencyHash . length ; i ++ ) frequencyHash [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { frequencyHash [ arr [ i ] % ( m + 1 ) ] ++ ; } for ( i = 0 ; i <= m ; i ++ ) { if ( frequencyHash [ i ] >= n / 2 ) break ; } if ( i <= m ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
void generateDivisors ( int n ) { for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) arr . add ( i ) ; { arr . add ( i ) ; arr . add ( n / i ) ; } } } }
double harmonicMean ( int n ) { generateDivisors ( n ) ; double sum = 0.0 ; int len = arr . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) sum = sum + n / arr . get ( i ) ; sum = sum / n ; return arr . size ( ) / sum ; }
boolean isOreNumber ( int n ) { double mean = harmonicMean ( n ) ; if ( mean - Math . floor ( mean ) == 0 ) return true ; else return false ; }
int sum_of_series ( int n ) { int result = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) result = result - ( int ) Math . pow ( i , 2 ) ; else result = result + ( int ) Math . pow ( i , 2 ) ; } return result ; }
int sum_of_series ( int n ) { int result = 0 ; if ( n % 2 == 0 ) { result = - ( n * ( n + 1 ) ) / 2 ; } else { result = ( n * ( n + 1 ) ) / 2 ; } return result ; }
int digitProduct ( int [ ] digits , int start , int end ) { int pro = 1 ; for ( int i = start ; i <= end ; i ++ ) { pro *= digits [ i ] ; } return pro ; }
int numberOfDistinct ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) prime [ i ] = true ; for ( int i = 0 ; i <= MAX ; i ++ ) sum [ i ] = 0 ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } for ( int i = 1 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) sum [ i ] = 1 ; sum [ i ] += sum [ i - 1 ] ; } }
double calculateAlternateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; double sum = Math . pow ( fibo [ 0 ] , 2 ) + Math . pow ( fibo [ 1 ] , 2 ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum -= fibo [ i ] ; else sum += fibo [ i ] ; } return sum ; }
int getValue ( int n ) { int i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return k / 2 ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
void ulam ( ) { arr . add ( 1 ) ; arr . add ( 2 ) ; for ( int i = 3 ; i < MAX ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr . size ( ) - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr . size ( ) ; k ++ ) { if ( arr . get ( j ) + arr . get ( k ) == i ) { count ++ ; } if ( count > 1 ) break ; } if ( count > 1 ) break ; } if ( count == 1 ) { arr . add ( i ) ; } } }
long nthKyneaNumber ( int n ) { n = ( 1 << n ) + 1 ; n = n * n ; n = n - 2 ; return n ; }
long nthKyneaNumber ( int n ) { return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; }
boolean isProthNumber ( int n ) { int k = 1 ; while ( k < ( n / k ) ) { if ( n % k == 0 ) { if ( isPowerOfTwo ( n / k ) ) return true ; } k = k + 2 ; } return false ; }
boolean isInterprime ( int n ) { if ( n < 4 ) return false ; int prev_prime = n ; int next_prime = n ; while ( ! isPrime ( prev_prime ) ) { prev_prime -- ; } while ( ! isPrime ( next_prime ) ) { next_prime ++ ; } if ( ( prev_prime + next_prime ) == 2 * n ) return true ; else return false ; }
boolean isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; }
boolean isThabitNumber ( int n ) { n = n + 1 ; if ( n % 3 == 0 ) n = n / 3 ; else return false ; if ( isPowerOfTwo ( n ) ) return true ; else return false ; }
int get_last_two_digit ( long N ) { if ( N <= 10 ) { long ans = 0 , fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ( int ) ans % 100 ; } return 13 ; }
boolean isProductEven ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) == 0 ) return true ; return false ; }
int calculateSquareSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += ( fibo [ i ] * fibo [ i ] ) ; } return sum ; }
int fib ( int n ) { if ( n == 0 ) { return 0 ; } if ( n == 1 n == 2 ) { return ( f [ n ] = 1 ) ; } if ( f [ n ] > 0 ) { return f [ n ] ; } int k = ( ( n & 1 ) > 0 ) ? ( n + 1 ) / 2 : n / 2 ; f [ n ] = ( ( n & 1 ) > 0 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; }
int calculateSumOfSquares ( int n ) { return fib ( n ) * fib ( n + 1 ) ; }
void sieve ( ) { int arr [ ] = new int [ N + 1 ] ; arr [ 0 ] = 1 ; arr [ 1 ] = 1 ; for ( int i = 2 ; i <= Math . sqrt ( N ) ; i ++ ) if ( arr [ i ] == 0 ) for ( int j = i * i ; j <= N ; j += i ) arr [ j ] = 1 ; long runningPrimeSum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] == 0 ) runningPrimeSum += i ; dp [ i ] = runningPrimeSum ; } }
int fnMod ( int n ) { int rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; return 0 ; }
int MinimumMoves ( int a [ ] , int n , int x ) { int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { int p = ( a [ i - 1 ] - a [ i ] ) / x + 1 ; ans += p ; a [ i ] += p * x ; } } return ans ; }
int SumOfDigits ( String str , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( int ) ( str . charAt ( i ) - '0' ) ; return sum ; }
boolean isPrime ( int k ) { if ( k <= 1 ) return false ; for ( int i = 2 ; i < k ; i ++ ) if ( k % i == 0 ) return false ; return true ; }
int check ( int num , int k ) { int flag = 1 ; for ( int i = 2 ; i < k ; i ++ ) { if ( num % i == 0 ) flag = 0 ; } if ( flag == 1 ) { if ( num % k == 0 ) return 1 ; else return 0 ; } else return 0 ; }
int findCount ( int a , int b , int k ) { int count = 0 ; if ( ! isPrime ( k ) ) return 0 ; else { int ans ; for ( int i = a ; i <= b ; i ++ ) { ans = check ( i , k ) ; if ( ans == 1 ) count ++ ; else continue ; } } return count ; }
int findMinEqualSums ( int [ ] a , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; } int sum1 = 0 , sum2 = 0 ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { sum1 += a [ i ] ; sum2 = sum - sum1 ; if ( Math . abs ( sum1 - sum2 ) < min ) { min = Math . abs ( sum1 - sum2 ) ; } if ( min == 0 ) { break ; } } return min ; }
void SieveOfEratosthenes ( ) { boolean [ ] prime = new boolean [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( prime [ p ] ) arr . add ( p ) ; }
boolean isEuclid ( long n ) { long product = 1 ; int i = 0 ; while ( product < n ) { product = product * arr . get ( i ) ; if ( product + 1 == n ) return true ; i ++ ; } return false ; }
boolean isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; }
int NumberOfSolutions ( int x , int y , int z , int n ) { int ans = 0 ; for ( int i = 0 ; i <= x ; i ++ ) { for ( int j = 0 ; j <= y ; j ++ ) { int temp = n - i - j ; if ( temp >= 0 ) { temp = Math . min ( temp , z ) ; ans += temp + 1 ; } } } return ans ; }
int solve ( int n ) { int count = 0 , num = 1 ; long sum = 0 ; while ( count < n ) { if ( prime [ num ] ) { sum += num ; count ++ ; } num ++ ; } return ( int ) sum ; }
long fact ( int p ) { if ( p <= 1 ) return 1 ; return p * fact ( p - 1 ) ; }
int findNum ( int n , int a , int b ) { int result = 0 ; int aCount = 0 ; int bCount = 0 ; return ( int ) findNumUtil ( result , a , aCount , b , bCount , n ) ; }
void findkth ( int n , int k ) { Vector < Integer > v1 = new Vector < Integer > ( ) ; Vector < Integer > v2 = new Vector < Integer > ( ) ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { v1 . add ( i ) ; if ( i != Math . sqrt ( n ) ) v2 . add ( n / i ) ; } } Collections . reverse ( v2 ) ; if ( k > ( v1 . size ( ) + v2 . size ( ) ) ) System . out . print ( "Doesn't Exist" ) ; else { if ( k <= v1 . size ( ) ) System . out . print ( v1 . get ( k - 1 ) ) ; else System . out . print ( v2 . get ( k - v1 . size ( ) - 1 ) ) ; } }
int NumberOfSolutions ( int a , int b , int c , int d ) { int ans = 0 ; for ( int i = a ; i <= b ; i ++ ) if ( d >= Math . max ( c , i + 1 ) ) ans += d - Math . max ( c , i + 1 ) + 1 ; return ans ; }
double CountDigits ( int n ) { if ( n == 1 ) return 1 ; double sum = 0 ; for ( int i = 2 ; i <= n ; ++ i ) { sum += ( ( double ) Math . log ( i ) / ( double ) Math . log ( 10 ) ) ; } sum *= n ; return Math . ceil ( sum ) ; }
String findNumber ( int n , int d ) { String ans = "" ; if ( d != 10 ) { ans += Integer . toString ( d ) ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } else { if ( n == 1 ) ans += "Impossible" ; else { ans += '1' ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } } return ans ; }
void countDigits ( double val , long [ ] arr ) { while ( ( long ) val > 0 ) { long digit = ( long ) val % 10 ; arr [ ( int ) digit ] ++ ; val = ( long ) val / 10 ; } return ; }
void countFrequency ( int x , int n ) { long [ ] freq_count = new long [ 10 ] ; for ( int i = 1 ; i <= n ; i ++ ) { double val = Math . pow ( ( double ) x , ( double ) i ) ; countDigits ( val , freq_count ) ; } for ( int i = 0 ; i <= 9 ; i ++ ) { System . out . print ( freq_count [ i ] + " " ) ; } }
void form_sieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( int j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } }
int nthTerm ( int n ) { return ( int ) Math . pow ( n , 2 ) + 4 * n ; }
long NthTerm ( long n ) { long x = ( 3 * n * n ) % 1000000009 ; return ( x - n + 1000000009 ) % 1000000009 ; }
void PowerOfTwo ( ) { int x = 1 ; for ( int i = 0 ; i < 31 ; i ++ ) { power [ i ] = x ; x *= 2 ; } pre [ 0 ] = 1 ; for ( int i = 1 ; i < 31 ; i ++ ) pre [ i ] = pre [ i - 1 ] + power [ i ] ; }
int Sum ( int n ) { int ans = n * ( n + 1 ) / 2 ; for ( int i = 0 ; i < 31 ; i ++ ) { if ( power [ i ] > n ) { ans -= 2 * pre [ i - 1 ] ; break ; } } return ans ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
boolean checkSemiPrime ( int n ) { int i = 0 ; while ( arr . get ( i ) <= n / 2 ) { if ( sprime [ n - arr . get ( i ) ] ) { return true ; } i ++ ; } return false ; }
int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; }
int nextGreater ( int N ) { int power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; }
float area ( float r ) { if ( r < 0 ) return - 1 ; float area = ( float ) ( 3.14 * Math . pow ( r / ( 2 * Math . sqrt ( 2 ) ) , 2 ) ) ; return area ; }
float area ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) Math . pow ( ( a * Math . sqrt ( 3 ) ) / ( Math . sqrt ( 2 ) ) , 2 ) ; return area ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < N ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < N ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < N ; i += p ) prime [ i ] = false ; } } }
int almostPrimes ( int n ) { int ans = 0 ; for ( int i = 6 ; i <= n ; i ++ ) { int c = 0 ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { if ( j * j == i ) { if ( prime [ j ] ) c ++ ; } else { if ( prime [ j ] ) c ++ ; if ( prime [ i / j ] ) c ++ ; } } } if ( c == 2 ) ans ++ ; } return ans ; }
float heightCalculate ( int H , int n , int m ) { float N = ( float ) ( n * 1.0 ) ; float M = ( float ) ( m * 1.0 ) ; float h = H * ( float ) Math . sqrt ( N / ( N + M ) ) ; return h ; }
int numberOfSolutions ( int n ) { int c = 0 ; for ( int x = 0 ; x <= n ; ++ x ) if ( n == x + ( n ^ x ) ) ++ c ; return c ; }
int findNumber ( int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int [ ] count = new int [ 10 ] ; int x = i ; int count1 = 0 , count2 = 0 ; while ( x > 0 ) { count [ x % 10 ] ++ ; x /= 10 ; count1 ++ ; } for ( int j = 0 ; j < 10 ; j ++ ) { if ( count [ j ] == 1 ) count2 ++ ; } if ( count1 == count2 ) return i ; } return - 1 ; }
boolean isprime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) if ( x % i == 0 ) return false ; return true ; }
boolean isNSqMinusnMSqPrime ( int m , int n ) { if ( n - m == 1 && isprime ( m + n ) ) return true ; else return false ; }
int countNumbers ( int N ) { return ( int ) ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 ; }
void buildPrefix ( ) { boolean prime [ ] = new boolean [ MAX + 1 ] ; for ( int i = 0 ; i < MAX + 1 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } prefix [ 0 ] = prefix [ 1 ] = 0 ; for ( int p = 2 ; p <= MAX ; p ++ ) { prefix [ p ] = prefix [ p - 1 ] ; if ( prime [ p ] == true ) prefix [ p ] += p ; } }
int sumPrimeRange ( int L , int R ) { buildPrefix ( ) ; return prefix [ R ] - prefix [ L - 1 ] ; }
int findPosition ( int n , int f , int b ) { return n - Math . max ( f + 1 , n - b ) + 1 ; }
int nthOdd ( int n ) { return ( 2 * n - 1 ) ; }
int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; }
int countSolutions ( int a ) { int count = Integer . bitCount ( a ) ; count = ( int ) Math . pow ( 2 , count ) ; return count ; }
boolean isPermutation ( Node first , Node second ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; Node temp1 = first ; while ( temp1 != null ) { sum1 += temp1 . data ; mul1 *= temp1 . data ; temp1 = temp1 . next ; } Node temp2 = second ; while ( temp2 != null ) { sum2 += temp2 . data ; mul2 *= temp2 . data ; temp2 = temp2 . next ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; }
void SieveOfEratosthenes ( int n , boolean isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } }
void findPrimePair ( int n ) { int flag = 0 ; boolean [ ] isPrime = new boolean [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ; for ( int i = 2 ; i < n ; i ++ ) { int x = n / i ; if ( isPrime [ i ] && isPrime [ x ] && x != i && x * i == n ) { System . out . println ( i + " " + x ) ; flag = 1 ; return ; } } if ( flag == 0 ) System . out . println ( "No such pair found" ) ; }
void solveProportion ( int a , int b1 , int b2 , int c ) { int A = a * b2 ; int B = b1 * b2 ; int C = b1 * c ; int gcd = __gcd ( __gcd ( A , B ) , C ) ; System . out . print ( A / gcd + ":" + B / gcd + ":" + C / gcd ) ; }
int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) + n - 3 ; }
int nthTerm ( int n ) { return 5 * ( int ) Math . pow ( n , 2 ) - 5 * n ; }
int nthTerm ( int n ) { return 3 * ( int ) Math . pow ( n , 2 ) + 2 * n - 5 ; }
int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) + 3 * n - 5 ; }
int nthTerm ( int n ) { return 3 * ( int ) Math . pow ( n , 2 ) - 4 * n + 2 ; }
int nthTerm ( int n ) { return 4 * ( int ) Math . pow ( n , 2 ) - 3 * n + 2 ; }
boolean isProduct ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i ; ++ cnt ; } } if ( num > 1 ) ++ cnt ; return cnt == 2 ; }
void findNumbers ( int N ) { Vector < Integer > vec = new Vector < Integer > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( isProduct ( i ) && ! isPerfectSquare ( i ) ) { vec . add ( i ) ; } } Iterator < Integer > itr = vec . iterator ( ) ; while ( itr . hasNext ( ) ) { System . out . print ( itr . next ( ) + " " ) ; } }
int countDivisors ( int n , int k ) { int count = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 && i % k == 0 ) { count ++ ; } } return count ; }
int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 3 ) + ( int ) Math . pow ( n , 2 ) ; }
int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + ( int ) Math . pow ( ( n * ( n + 1 ) / 2 ) , 2 ) ; }
float volume ( float r , float h ) { return ( float ) 1 / 3 * pi * h * r * r ; }
int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }
int maxDistance ( int [ ] arr , int n ) { HashMap < Integer , Integer > map = new HashMap < > ( ) ; int max_dist = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! map . containsKey ( arr [ i ] ) ) map . put ( arr [ i ] , i ) ; else max_dist = Math . max ( max_dist , i - map . get ( arr [ i ] ) ) ; } return max_dist ; }
int calculateSum ( int n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; }
int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) - n - 1 ; }
int nthTerm ( int n ) { return 6 * ( int ) Math . pow ( n , 2 ) - 4 * n - 2 ; }
int nthTerm ( int n ) { return 4 * ( int ) Math . pow ( n , 2 ) - 7 * n + 3 ; }
int nthTerm ( int n ) { return ( int ) Math . pow ( n , 2 ) + 2 * n + 2 ; }
void checkSolution ( int a , int b , int c ) { if ( ( ( b * b ) - ( 4 * a * c ) ) > 0 ) System . out . println ( "2 solutions" ) ; else if ( ( ( b * b ) - ( 4 * a * c ) ) == 0 ) System . out . println ( "1 solution" ) ; else System . out . println ( "No solutions" ) ; }
BigInteger Bytes ( int kilobytes ) { BigInteger Bytes = new BigInteger ( "0" ) ; BigInteger kilo = BigInteger . valueOf ( kilobytes ) ; Bytes = kilo . multiply ( BigInteger . valueOf ( 1024 ) ) ; return Bytes ; }
long NthTerm ( long n ) { long x = ( 2 * n * n ) % 1000000009 ; return ( x - n + 1000000009 ) % 1000000009 ; }
int sum ( int n ) { int ans = ( n * ( n - 1 ) ) / 2 ; return ans ; }
long getNthTerm ( long N ) { return ( ( int ) Math . pow ( N , 2 ) + N + 1 ) ; }
int findSum ( int N ) { return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ; }
long getNthTerm ( long N ) { return 4 * ( long ) Math . pow ( N , 2 ) - 3 * N + 2 ; }
double findCosNTheta ( double sinTheta , int n ) { double cosTheta = Math . sqrt ( 1 - sinTheta * sinTheta ) ; double ans = 0 ; long toggle = 1 ; for ( int i = 1 ; i <= n ; i += 2 ) { ans = ans + nCr [ n ] [ i ] * Math . pow ( cosTheta , n - i ) * Math . pow ( sinTheta , i ) * toggle ; toggle = toggle * - 1 ; } return ans ; }
long findSum ( int n ) { long sum2 , sum5 , sum10 ; sum2 = ( ( n / 2 ) * ( 4 + ( n / 2 - 1 ) * 2 ) ) / 2 ; sum5 = ( ( n / 5 ) * ( 10 + ( n / 5 - 1 ) * 5 ) ) / 2 ; sum10 = ( ( n / 10 ) * ( 20 + ( n / 10 - 1 ) * 10 ) ) / 2 ; return sum2 + sum5 - sum10 ; }
int nthTerm ( int N ) { return ( ( 3 * N * N ) - ( 6 * N ) + 2 ) ; }
int nthTerm ( int N ) { return ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ; }
void binomial ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = nCr [ i - 1 ] [ j ] + nCr [ i - 1 ] [ j - 1 ] ; } } }
double findTanNTheta ( double tanTheta , int n ) { double ans = 0 , numerator = 0 , denominator = 0 ; long toggle = 1 ; for ( int i = 1 ; i <= n ; i += 2 ) { numerator = numerator + nCr [ n ] [ i ] * Math . pow ( tanTheta , i ) * toggle ; toggle = toggle * - 1 ; } denominator = 1 ; toggle = - 1 ; for ( int i = 2 ; i <= n ; i += 2 ) { numerator = numerator + nCr [ n ] [ i ] * Math . pow ( tanTheta , i ) * toggle ; toggle = toggle * - 1 ; } ans = numerator / denominator ; return ans ; }
int product ( int n ) { v . clear ( ) ; for ( int i = 0 ; i < n + 100 ; i ++ ) v . add ( new Vector < Integer > ( ) ) ; factors ( n + 100 ) ; if ( n % 4 == 0 ) { int x = n / 4 ; x *= x ; return x * x ; } else { if ( isPrime ( n ) ) return - 1 ; else { int ans = - 1 ; if ( v . get ( n ) . size ( ) > 2 ) { int fac = v . get ( n ) . get ( v . get ( n ) . size ( ) - 3 ) ; for ( int i = v . get ( n ) . size ( ) - 1 ; i >= 0 ; i -- ) { for ( int j = v . get ( n ) . size ( ) - 1 ; j >= 0 ; j -- ) { if ( ( fac * 2 ) + ( v . get ( n ) . get ( j ) + v . get ( n ) . get ( i ) ) == n ) ans = Math . max ( ans , fac * fac * v . get ( n ) . get ( j ) * v . get ( n ) . get ( i ) ) ; } } return ans ; } } } return 0 ; }
boolean arePermutations ( int a [ ] , int b [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] ; mul1 *= a [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { sum2 += b [ i ] ; mul2 *= b [ i ] ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; }
void binomial ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = nCr [ i - 1 ] [ j ] + nCr [ i - 1 ] [ j - 1 ] ; } } }
double findCosnTheta ( double cosTheta , int n ) { double sinTheta = Math . sqrt ( 1 - cosTheta * cosTheta ) ; double ans = 0 ; int toggle = 1 ; for ( int i = 0 ; i <= n ; i += 2 ) { ans = ans + nCr [ n ] [ i ] * Math . pow ( cosTheta , n - i ) * Math . pow ( sinTheta , i ) * toggle ; toggle = toggle * - 1 ; } return ans ; }
float CalculateRatio ( float m , float n ) { return ( 2 * m - 1 ) / ( 2 * n - 1 ) ; }
long power ( long x , long y , long p ) { long res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
long sumProd ( long n , long t ) { long dino = power ( t + 1 , MOD - 2 , MOD ) ; long ans = 1 ; for ( long i = n + t + 1 ; i > n ; -- i ) ans = ( ans % MOD * i % MOD ) % MOD ; long tfact = 1 ; for ( int i = 1 ; i <= t ; ++ i ) tfact = ( tfact * i ) % MOD ; ans = ans * dino - tfact + MOD ; return ans % MOD ; }
int sumOfDigitsSingle ( int x ) { int ans = 0 ; while ( x != 0 ) { ans += x % 10 ; x /= 10 ; } return ans ; }
int sumOfDigitsTwoParts ( int N ) { int A = closest ( N ) ; return sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) ; }
int nextPerfectCube ( int N ) { int nextN = ( int ) Math . floor ( Math . cbrt ( N ) ) + 1 ; return nextN * nextN * nextN ; }
double findSum ( long n ) { return Math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; }
int sum ( int x , int y , int n ) { int sum1 = ( int ) ( ( Math . pow ( x , 2 ) * ( Math . pow ( x , 2 * n ) - 1 ) ) / ( Math . pow ( x , 2 ) - 1 ) ) ; int sum2 = ( int ) ( ( x * y * ( Math . pow ( x , n ) * Math . pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ) ; return sum1 + sum2 ; }
int powerDigitSum ( int a , int n ) { int res = 1 ; while ( n > 0 ) { if ( n % 2 == 1 ) { res = res * digSum ( a ) ; res = digSum ( res ) ; } a = digSum ( digSum ( a ) * digSum ( a ) ) ; n /= 2 ; } return res ; }
void printPair ( int g , int l ) { System . out . print ( g + " " + l ) ; }
int mostFrequent ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int max_count = 1 , res = arr [ 0 ] ; int curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ n - 1 ] ; } return res ; }
int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
long power ( long a , long b ) { long res = 1 ; while ( b != 0 ) { if ( ( b & 1 ) != 0 ) { res *= a ; res %= mod ; } b /= 2 ; a *= a ; a %= mod ; } return res ; }
long minPlayer ( long n , long k ) { long num = ( ( power ( k , n ) - 1 ) + mod ) % mod ; long den = ( power ( k - 1 , mod - 2 ) + mod ) % mod ; long ans = ( ( ( num * den ) % mod ) * k ) % mod ; return ans ; }
void sieve ( int N ) { prime . add ( 0 , false ) ; prime . add ( 1 , false ) ; for ( int i = 2 ; i <= N ; i ++ ) { if ( prime . get ( i ) ) { for ( int j = 2 ; i * j <= N ; j ++ ) { prime . add ( i * j , false ) ; } } } }
int countLogNeeded ( int N ) { int count = 0 ; sieve ( N ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( prime . get ( i ) ) { count ++ ; } } return count ; }
float rmsValue ( int arr [ ] , int n ) { int square = 0 ; float mean = 0 ; float root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { square += Math . pow ( arr [ i ] , 2 ) ; } mean = ( square / ( float ) ( n ) ) ; root = ( float ) Math . sqrt ( mean ) ; return root ; }
double Mixture ( int X , int Y , int Z ) { double result1 = 0.0 , result = 0.0 ; result1 = ( ( X - Y ) / ( float ) X ) ; result = Math . pow ( result1 , Z ) ; result = result * X ; return result ; }
int coin ( int totalRupees , int X , int Y , int Z ) { float one = 0 , fifty = 0 , twentyfive = 0 , result = 0 , total = 0 ; one = X * 1 ; fifty = ( ( Y * 1 ) / 2 ) ; twentyfive = ( ( Z * 1 ) / 4 ) ; total = one + fifty + twentyfive ; result = ( ( totalRupees ) / total ) ; return ( int ) result ; }
float sumOfSeries ( int x , int k ) { float y = ( float ) ( ( ( float ) ( x ) / 81 ) * ( 9 * k - 1 + Math . pow ( 10 , ( - 1 ) * k ) ) ) ; return y ; }
int calculateSum ( int n ) { int a1 = 1 , a2 = 2 ; int r = 2 ; int d = 1 ; return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( int ) ( Math . pow ( r , n ) - 1 ) / ( r - 1 ) ; }
int findProduct ( int n ) { int product = - 1 ; int si = factors . size ( ) ; for ( int i = 0 ; i < si ; i ++ ) { for ( int j = 0 ; j < si ; j ++ ) { for ( int k = 0 ; k < si ; k ++ ) { for ( int l = 0 ; l < si ; l ++ ) { int s = factors . get ( i ) + factors . get ( j ) + factors . get ( k ) + factors . get ( l ) ; if ( s == n ) { int p = factors . get ( i ) * factors . get ( j ) * factors . get ( k ) * factors . get ( l ) ; if ( p > product ) { product = p ; } } } } } } return product ; }
int modExp ( int a , int b ) { int result = 1 ; while ( b > 0 ) { if ( b == 1 ) result = result * a ; a = a * a ; b /= 2 ; } return result ; }
int check ( int num ) { if ( num == 1 num < 3 ) return - 1 ; else if ( num % 4 == 0 ) return modExp ( num / 4 , 4 ) ; else if ( num % 6 == 0 ) return modExp ( num / 3 , 2 ) * modExp ( num / 6 , 2 ) ; else if ( num % 10 == 0 ) return modExp ( num / 5 , 2 ) * ( num / 10 ) * ( num / 2 ) ; else return - 1 ; }
void sieveOfEratosthenes ( int N , int s [ ] ) { boolean [ ] prime = new boolean [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) prime [ i ] = false ; for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= N ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } }
int findSum ( int N ) { int [ ] s = new int [ N + 1 ] ; int ans = 1 ; sieveOfEratosthenes ( N , s ) ; int currFactor = s [ N ] ; int power = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( currFactor == s [ N ] ) { power ++ ; continue ; } int sum = 0 ; for ( int i = 0 ; i <= power ; i ++ ) sum += Math . pow ( currFactor , i ) ; ans *= sum ; currFactor = s [ N ] ; power = 1 ; } return ans ; }
int countMultiples ( int n ) { int multiple [ ] = { 2 , 3 , 5 } ; int count = 0 , mask = ( int ) Math . pow ( 2 , 3 ) ; for ( int i = 1 ; i < mask ; i ++ ) { int prod = 1 ; for ( int j = 0 ; j < 3 ; j ++ ) { if ( ( i & 1 << j ) > 0 ) prod = prod * multiple [ j ] ; } if ( count_setbits ( i ) % 2 == 1 ) count = count + n / prod ; else count = count - n / prod ; } return count ; }
int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; }
boolean isDivisible ( long n ) { while ( n / 100 > 0 ) { long d = n % 10 ; n /= 10 ; n -= d * 5 ; } return ( n % 17 == 0 ) ; }
int calculateSum ( int n ) { return ( ( int ) Math . pow ( 2 , n + 1 ) + n - 2 ) ; }
int nextPowerOf2 ( int n ) { int count = 0 ; if ( n != 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
int removeElement ( int n ) { if ( n == 1 n == 2 ) return 0 ; int a = nextPowerOf2 ( n ) ; if ( n == a n == a - 1 ) return 1 ; else if ( n == a - 2 ) return 0 ; else if ( n % 2 == 0 ) return 1 ; else return 2 ; }
int calculateSum ( int n ) { return ( n * ( 4 * n * n + 6 * n - 1 ) / 3 ) ; }
int bridge_length ( int trainLength , int Speed , int Time ) { return ( ( Time * Speed ) - trainLength ) ; }
int findN ( int k ) { int ans ; if ( k == 0 ) ans = 3 ; if ( k == 1 ) ans = 1 ; else if ( k % 4 == 0 ) ans = k ; else if ( k % 4 == 3 ) ans = k - 1 ; else ans = - 1 ; return ans ; }
long repeatedSum ( long n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
long repeatedProduct ( long n ) { long prod = 1 ; while ( n > 0 prod > 9 ) { if ( n == 0 ) { n = prod ; prod = 1 ; } prod *= n % 10 ; n /= 10 ; } return prod ; }
long maxSumProduct ( long N ) { if ( N < 10 ) return N ; return Math . max ( repeatedSum ( N ) , repeatedProduct ( N ) ) ; }
int Circular ( int n ) { int Result = 1 ; while ( n > 0 ) { Result = Result * n ; n -- ; } return Result ; }
float Time ( float arr [ ] , int n , float Emptypipe ) { float fill = 0 ; for ( int i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / ( float ) Emptypipe ) ; return 1 / fill ; }
void smallestSubsegment ( int a [ ] , int n ) { HashMap < Integer , Integer > left = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ; int mx = 0 ; int mn = - 1 , strindex = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( count . get ( x ) == null ) { left . put ( x , i ) ; count . put ( x , 1 ) ; } else count . put ( x , count . get ( x ) + 1 ) ; if ( count . get ( x ) > mx ) { mx = count . get ( x ) ; mn = i - left . get ( x ) + 1 ; strindex = left . get ( x ) ; } else if ( ( count . get ( x ) == mx ) && ( i - left . get ( x ) + 1 < mn ) ) { mn = i - left . get ( x ) + 1 ; strindex = left . get ( x ) ; } } for ( int i = strindex ; i < strindex + mn ; i ++ ) System . out . print ( a [ i ] + " " ) ; }
long modInv ( long x ) { long n = MOD - 2 ; long result = 1 ; while ( n > 0 ) { if ( ( n & 1 ) > 0 ) { result = result * x % MOD ; } x = x * x % MOD ; n = n / 2 ; } return result ; }
long getSum ( long n , long k ) { long ans = 1 ; for ( long i = n + 1 ; i > n - k ; i -- ) { ans = ans * i % MOD ; } ans = ans * modInv ( k + 1 ) % MOD ; return ans ; }
int calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = Math . min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; int area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; }
void printCombination ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( int j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( int k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { System . out . println ( i + " " + j + " " + k ) ; return ; } } } } } } }
void printCombination ( int n ) { System . out . print ( 1 + " " ) ; if ( ( n - 2 ) % 3 == 0 ) System . out . print ( 2 + " " + ( n - 3 ) ) ; else System . out . print ( 1 + " " + ( n - 2 ) ) ; }
int Loss ( int costPrice , int sellingPrice ) { int Loss = ( costPrice - sellingPrice ) ; return Loss ; }
boolean isPalindrome ( int n ) { if ( n % 11 == 0 ) { return true ; } return false ; }
int percent ( int a , int b ) { float result = 0 ; result = ( ( b - a ) * 100 ) / a ; return ( int ) result ; }
int nextPerfectSquare ( int N ) { int nextN = ( int ) Math . floor ( Math . sqrt ( N ) ) + 1 ; return nextN * nextN ; }
void Smallest_prime_factor ( ) { for ( int i = 1 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i <= MAXN ; i += 2 ) if ( spf [ i ] == i ) for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; }
int Digit_Sum ( int copy ) { int d = 0 ; while ( copy > 0 ) { d += copy % 10 ; copy /= 10 ; } return d ; }
void Sum_Of_All_Digits ( ) { for ( int n = 2 ; n < MAXN ; n ++ ) { sum_digits [ n ] = sum_digits [ n / spf [ n ] ] + Digit_Sum ( spf [ n ] ) ; if ( Digit_Sum ( n ) == sum_digits [ n ] ) isValid [ n ] = true ; } for ( int n = 2 ; n < MAXN ; n ++ ) { if ( isValid [ n ] ) ans [ n ] = 1 ; ans [ n ] += ans [ n - 1 ] ; } }
long binomialCoeff ( long n , long k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
long catalan ( long n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
boolean isPrime ( int n ) { int i , c = 0 ; for ( i = 1 ; i < n / 2 ; i ++ ) { if ( n % i == 0 ) c ++ ; } if ( c == 1 ) { return true ; } else { return false ; } }
int prevComplement ( int n , int b ) { int maxDigit , maxNum = 0 , digits = 0 , num = n ; while ( n != 0 ) { digits ++ ; n = n / 10 ; } maxDigit = b - 1 ; while ( ( digits -- ) > 0 ) { maxNum = maxNum * 10 + maxDigit ; } return maxNum - num ; }
int complement ( int n , int b ) { return prevComplement ( n , b ) + 1 ; }
boolean isFascinating ( int num ) { int [ ] freq = new int [ 10 ] ; String val = "" + num + num * 2 + num * 3 ; for ( int i = 0 ; i < val . length ( ) ; i ++ ) { int digit = val . charAt ( i ) - '0' ; if ( freq [ digit ] > 0 && digit != 0 ) return false ; else freq [ digit ] ++ ; } for ( int i = 1 ; i < freq . length ; i ++ ) { if ( freq [ i ] == 0 ) return false ; } return true ; }
int binomial_coefficient ( int n , int m ) { int res = 1 ; if ( m > n - m ) m = n - m ; for ( int i = 0 ; i < m ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
void computeTotient ( ) { for ( int i = 1 ; i < N ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p < N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i < N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } }
void CoPrimes ( ) { computeTotient ( ) ; for ( int i = 1 ; i < N ; i ++ ) S [ i ] = S [ i - 1 ] + phi [ i ] ; }
boolean isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; }
int previousPowerOfTwo ( int n ) { while ( ( n & n - 1 ) > 1 ) { n = n & n - 1 ; } return n ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int MaximumDivisors ( int X , int Y ) { int [ ] arr = new int [ Y - X + 1 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) arr [ i ] = 0 ; int mx = 0 ; int cnt = 0 ; for ( int i = 1 ; i * i <= Y ; i ++ ) { int sq = i * i ; int first_divisible ; if ( ( X / i ) * i >= X ) first_divisible = ( X / i ) * i ; else first_divisible = ( X / i + 1 ) * i ; for ( int j = first_divisible ; j <= Y ; j += i ) { if ( j < sq ) continue ; else if ( j == sq ) arr [ j - X ] ++ ; else arr [ j - X ] += 2 ; } } for ( int i = X ; i <= Y ; i ++ ) { if ( arr [ i - X ] > mx ) { cnt = 1 ; mx = arr [ i - X ] ; } else if ( arr [ i - X ] == mx ) cnt ++ ; } return cnt ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
int NearestElement ( int A , int D , int P ) { if ( A == 0 ) return 0 ; else if ( D == 0 ) return - 1 ; else { int X = power ( D , P - 2 , P ) ; return ( X * ( P - A ) ) % P ; } }
int binaryToDecimal ( String n ) { String num = n ; int dec_value = 0 ; int base = 1 ; int len = num . length ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( num . charAt ( i ) == '1' ) dec_value += base ; base = base * 2 ; } return dec_value ; }
int numberSequence ( int n ) { if ( n == 1 ) return 1 ; String s = "" ; for ( int i = 1 ; i < n ; i ++ ) s += '1' ; s += '0' ; for ( int i = 1 ; i <= n ; i ++ ) s += '1' ; int num = binaryToDecimal ( s ) ; return num ; }
int numberSequence ( int n ) { int num = ( int ) ( Math . pow ( 4 , n ) - Math . pow ( 2 , n ) ) - 1 ; return num ; }
int complement ( int num ) { int i , len = 0 , temp , comp ; temp = num ; while ( true ) { len ++ ; num = num / 10 ; if ( Math . abs ( num ) == 0 ) break ; } num = temp ; comp = ( int ) Math . pow ( 10 , len ) - num ; return comp ; }
int calculate ( int ar [ ] , int size ) { int count = 0 ; for ( int i = 0 ; i < size ; i ++ ) if ( ar [ i ] % 2 == 0 && ar [ i ] != 0 && ar [ i ] != 2 ) count ++ ; return count ; }
int prime ( int num ) { int i , flag = 0 ; for ( i = 2 ; i <= num / 2 ; i ++ ) { if ( num % i == 0 ) { flag = 1 ; break ; } } if ( flag == 0 ) return 1 ; else return 0 ; }
void print_alternate_prime ( int n ) { int counter = 0 ; for ( int num = 2 ; num < n ; num ++ ) { if ( prime ( num ) == 1 ) { if ( counter % 2 == 0 ) System . out . print ( num + " " ) ; counter ++ ; } } }
void SieveOfEratosthenes ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } boolean flag = true ; for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { if ( flag ) { System . out . print ( p + " " ) ; flag = false ; } else { flag = true ; } } } }
boolean findGreater ( int x , int y ) { if ( x > y ) { return false ; } else { return true ; } }
int max_profit ( int a [ ] , int b [ ] , int n , int fee ) { int i , j , profit ; int l , r , diff_day = 1 , sum = 0 ; b [ 0 ] = 0 ; b [ 1 ] = diff_day ; for ( i = 1 ; i < n ; i ++ ) { l = 0 ; r = diff_day ; sum = 0 ; for ( j = n - 1 ; j >= i ; j -- ) { profit = ( a [ r ] - a [ l ] ) - fee ; if ( profit > 0 ) { sum = sum + profit ; } l ++ ; r ++ ; } if ( b [ 0 ] < sum ) { b [ 0 ] = sum ; b [ 1 ] = diff_day ; } diff_day ++ ; } return 0 ; }
int binomialCoeff ( int x , int n , int k ) { int sum = 0 , term = 1 ; for ( int i = 1 ; i <= n && sum < k ; ++ i ) { term *= x - i + 1 ; term /= i ; sum += term ; } return sum ; }
int minTrials ( int n , int k ) { int low = 1 , high = k ; while ( low < high ) { int mid = ( low + high ) / 2 ; if ( binomialCoeff ( mid , n , k ) < k ) low = mid + 1 ; else high = mid ; } return low ; }
void preprocess ( ) { for ( int i = 1 ; i < N ; i ++ ) { int num = i ; for ( int j = 2 ; j <= Math . sqrt ( num ) ; j ++ ) { if ( num % j == 0 ) { v [ i ] . add ( j ) ; while ( num % j == 0 ) { num = num / j ; } } } if ( num > 2 ) v [ i ] . add ( num ) ; } }
int query ( int number , int n ) { return v [ number ] . get ( n - 1 ) ; }
int getsum ( int a ) { int r = 0 , sum = 0 ; while ( a > 0 ) { r = a % 10 ; sum = sum + r ; a = a / 10 ; } return sum ; }
long boost_hyperfactorial ( long num ) { long val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { val = val * ( long ) Math . pow ( i , i ) ; } return val ; }
int boost_hyperfactorial ( int num ) { int val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y != 0 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
int findOddPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ( A [ i ] % 2 == 1 ) ) count ++ ; return count * ( count - 1 ) / 2 ; }
int summ ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
void printDigitalRoot ( int n ) { int maxi = 1 ; int dig = 1 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { int d1 = summ ( n / i ) ; int d2 = summ ( i ) ; if ( d1 > maxi ) { dig = n / i ; maxi = d1 ; } if ( d2 > maxi ) { dig = i ; maxi = d2 ; } if ( d1 == maxi ) { if ( dig < ( n / i ) ) { dig = n / i ; maxi = d1 ; } } if ( d2 == maxi ) { if ( dig < i ) { dig = i ; maxi = d2 ; } } } } System . out . println ( dig + " " + maxi ) ; }
int gcd ( int a , int b ) { if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
boolean isSurd ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int j = i ; while ( j < n ) j = j * i ; if ( j == n ) return false ; } return true ; }
long LastTwoDigit ( long num ) { long one = num % 10 ; num /= 10 ; long tens = num % 10 ; tens *= 10 ; num = tens + one ; return num ; }
int power ( long x , long y , long p ) { while ( y > 0 ) { long r = y & 1 ; if ( r == 1 ) res = ( res * ( int ) x ) % ( int ) p ; x = ( x * x ) % p ; } return res ; }
long modPower ( long x , long y , long p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
long gcd ( long a , long b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
long gcdPow ( long a , long n , long c ) { if ( a % c == 0 ) return c ; long modexpo = modPower ( a , n , c ) ; return gcd ( modexpo , c ) ; }
int countOddSum ( int ar [ ] , int n ) { int temp [ ] = { 1 , 0 } ; int result = 0 , val = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { val = ( ( val + ar [ i ] ) % 2 + 2 ) % 2 ; temp [ val ] ++ ; } result = temp [ 0 ] * temp [ 1 ] ; return ( result ) ; }
int countOddSum ( int a [ ] , int n ) { int c_odd = 0 , result = 0 ; boolean odd = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) { odd = ! odd ; } if ( odd ) { c_odd ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { result += c_odd ; if ( a [ i ] % 2 == 1 ) { c_odd = ( n - i - c_odd ) ; } } return result ; }
void findNthRoot ( double x , int n ) { double low , high ; if ( x >= 0 && x <= 1 ) { low = x ; high = 1 ; } else { low = 1 ; high = x ; } double epsilon = 0.00000001 ; double guess = ( low + high ) / 2 ; while ( Math . abs ( ( Math . pow ( guess , n ) ) - x ) >= epsilon ) { if ( Math . pow ( guess , n ) > x ) { high = guess ; } else { low = guess ; } guess = ( low + high ) / 2 ; } System . out . println ( guess ) ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int SumOfPrimeDivisors ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 ) { if ( isPrime ( i ) ) sum += i ; } } return sum ; }
int Sum ( int N ) { int SumOfPrimeDivisors [ ] = new int [ N + 1 ] ; for ( int i = 2 ; i <= N ; ++ i ) { if ( SumOfPrimeDivisors [ i ] == 0 ) { for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int SumOfPrimeDivisors ( int n ) { int sum = 0 ; int root_n = ( int ) Math . sqrt ( n ) ; for ( int i = 1 ; i <= root_n ; i ++ ) { if ( n % i == 0 ) { if ( i == n / i && isPrime ( i ) ) { sum += i ; } else { if ( isPrime ( i ) ) { sum += i ; } if ( isPrime ( n / i ) ) { sum += ( n / i ) ; } } } } return sum ; }
int rangesum ( int n , int l , int r ) { int [ ] arr = new int [ n ] ; int c = 1 , i = 0 ; while ( c <= n ) { arr [ i ++ ] = c ; c += 2 ; } c = 2 ; while ( c <= n ) { arr [ i ++ ] = c ; c += 2 ; } int sum = 0 ; for ( i = l - 1 ; i < r ; i ++ ) { sum += arr [ i ] ; } return sum ; }
int sumeven ( int n , int l , int r ) { int sum = 0 ; int mid = n / 2 ; if ( r <= mid ) { int first = ( 2 * l - 1 ) ; int last = ( 2 * r - 1 ) ; int no_of_terms = r - l + 1 ; sum = ( ( no_of_terms ) * ( ( first + last ) ) ) / 2 ; } else if ( l >= mid ) { int first = ( 2 * ( l - n / 2 ) ) ; int last = ( 2 * ( r - n / 2 ) ) ; int no_of_terms = r - l + 1 ; sum = ( ( no_of_terms ) * ( ( first + last ) ) ) / 2 ; } else { int sumleft = 0 , sumright = 0 ; int first_term1 = ( 2 * l - 1 ) ; int last_term1 = ( 2 * ( n / 2 ) - 1 ) ; int no_of_terms1 = n / 2 - l + 1 ; sumleft = ( ( no_of_terms1 ) * ( ( first_term1 + last_term1 ) ) ) / 2 ; int first_term2 = 2 ; int last_term2 = ( 2 * ( r - n / 2 ) ) ; int no_of_terms2 = r - mid ; sumright = ( ( no_of_terms2 ) * ( ( first_term2 + last_term2 ) ) ) / 2 ; sum = ( sumleft + sumright ) ; } return sum ; }
int sumodd ( int n , int l , int r ) { int mid = n / 2 + 1 ; int sum = 0 ; if ( r <= mid ) { int first = ( 2 * l - 1 ) ; int last = ( 2 * r - 1 ) ; int no_of_terms = r - l + 1 ; sum = ( ( no_of_terms ) * ( ( first + last ) ) ) / 2 ; } else if ( l > mid ) { int first = ( 2 * ( l - mid ) ) ; int last = ( 2 * ( r - mid ) ) ; int no_of_terms = r - l + 1 ; sum = ( ( no_of_terms ) * ( ( first + last ) ) ) / 2 ; } else { int sumleft = 0 , sumright = 0 ; int first_term1 = ( 2 * l - 1 ) ; int last_term1 = ( 2 * mid - 1 ) ; int no_of_terms1 = mid - l + 1 ; sumleft = ( ( no_of_terms1 ) * ( ( first_term1 + last_term1 ) ) ) / 2 ; int first_term2 = 2 ; int last_term2 = ( 2 * ( r - mid ) ) ; int no_of_terms2 = r - mid ; sumright = ( ( no_of_terms2 ) * ( ( first_term2 + last_term2 ) ) ) / 2 ; sum = ( sumleft + sumright ) ; } return sum ; }
int rangesum ( int n , int l , int r ) { int sum = 0 ; if ( n % 2 == 0 ) return sumeven ( n , l , r ) ; else return sumodd ( n , l , r ) ; }
void groupElements ( int arr [ ] , int n ) { boolean visited [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { visited [ i ] = false ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ! visited [ i ] ) { System . out . print ( arr [ i ] + " " ) ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { System . out . print ( arr [ i ] + " " ) ; visited [ j ] = true ; } } } } }
float rainDayProbability ( int a [ ] , int n ) { float count = 0 , m ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; } m = count / n ; return m ; }
void distance ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { double d = Math . pow ( ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) + Math . pow ( z2 - z1 , 2 ) * 1.0 ) , 0.5 ) ; System . out . println ( "Distance is " + d ) ; return ; }
boolean DivisibleBy41 ( int first , int second , int c , int n ) { int digit [ ] = new int [ n ] ; digit [ 0 ] = first ; digit [ 1 ] = second ; for ( int i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ; int ans = digit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ; if ( ans % 41 == 0 ) return true ; else return false ; }
int findTetrahedralNumber ( int n ) { return ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) ; }
void printSeries ( int n ) { int prev = 0 ; int curr ; for ( int i = 1 ; i <= n ; i ++ ) { curr = findTetrahedralNumber ( i ) ; curr = curr + prev ; System . out . print ( curr + " " ) ; prev = curr ; } }
void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = ( i * ( i + 1 ) * ( i + 2 ) * ( i + 3 ) / 24 ) ; System . out . print ( num + " " ) ; } }
long findTriangularNumber ( int n ) { return ( n * ( n + 1 ) ) / 2 ; }
void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) / 6 ; System . out . print ( num + " " ) ; } }
long calculateSum ( int n ) { long sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
long calculateSum ( int n ) { long sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
float findArea ( float a ) { float area ; area = ( float ) ( 5 * Math . sqrt ( 3 ) * a * a ) ; return area ; }
float findVolume ( float a ) { float volume ; volume = ( float ) ( ( ( float ) 5 / 12 ) * ( 3 + Math . sqrt ( 5 ) ) * a * a * a ) ; return volume ; }
int findNthNonSquare ( int n ) { double x = ( double ) n ; double ans = x + Math . floor ( 0.5 + Math . sqrt ( x ) ) ; return ( int ) ans ; }
void count_even_odd ( int min , int max , int steps [ ] [ ] ) { int a , b , even , odd ; boolean beven = true , aeven = false ; int n = 2 ; for ( int i = 0 ; i < n ; i ++ ) { a = steps [ i ] [ 0 ] ; b = steps [ i ] [ 1 ] ; if ( ! ( aeven || ( a & 1 ) > 0 ) ) aeven = true ; if ( beven ) { if ( ( b & 1 ) > 0 ) beven = false ; } else if ( ! ( ( a & 1 ) > 0 ) ) { if ( ! ( ( b & 1 ) > 0 ) ) beven = true ; } else { if ( ( b & 1 ) > 0 ) beven = true ; } } if ( beven ) { even = ( int ) max / 2 - ( int ) ( min - 1 ) / 2 ; odd = 0 ; } else { even = ( int ) max / 2 - ( int ) ( min - 1 ) / 2 ; odd = 0 ; } if ( ! ( beven ^ aeven ) ) even += max - min + 1 - ( int ) max / 2 + ( int ) ( min - 1 ) / 2 ; else odd += max - min + 1 - ( int ) max / 2 + ( int ) ( min - 1 ) / 2 ; System . out . print ( "even = " + even + ", odd = " + odd ) ; }
int getMaxOnes ( int n , int x ) { int zeroes = ( n / x ) ; zeroes = zeroes * zeroes ; int total = n * n ; int ans = total - zeroes ; return ans ; }
int ways ( int n ) { int first = 2 ; int second = 3 ; int res = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; }
int minimumOperations ( int [ ] a , int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . get ( a [ i ] ) != null ) { int x = mp . get ( a [ i ] ) ; mp . put ( a [ i ] , ++ x ) ; } else mp . put ( a [ i ] , 1 ) ; } int count = 0 ; for ( HashMap . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { if ( entry . getValue ( ) > 1 ) { count += ( entry . getValue ( ) - 1 ) ; } } return count ; }
void findVolume ( float a , float h ) { float Volume ; Volume = 3 * ( float ) ( Math . sqrt ( 3 ) ) * a * a * h / 2 ; System . out . println ( "Volume: " + Volume ) ; }
double MinimumMail ( int n , int k , int x ) { double m = ( n - 1 ) + Math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + Math . ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; }
int findAllSequence ( int N ) { if ( N % 2 == 0 ) { return ( int ) ( Math . pow ( 2 , N / 2 + 1 ) + Math . pow ( 2 , N / 2 ) - 2 ) ; } else { return ( int ) ( Math . pow ( 2 , ( N + 1 ) / 2 ) + Math . pow ( 2 , ( N + 1 ) / 2 ) - 2 ) ; } }
void computeTotient ( ) { for ( int i = 1 ; i <= N ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p <= N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i <= N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } }
long power ( long x , long y , long p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
long calculate ( long x , long k , long mod ) { long arr [ ] = new long [ N ] ; long count = 0 ; while ( mod > 1 ) { arr [ ( int ) count ++ ] = mod ; mod = phi [ ( int ) mod ] ; } long result = 1 ; long loop = count + 1 ; arr [ ( int ) count ] = 1 ; for ( int i = ( int ) Math . min ( k , loop ) - 1 ; i >= 0 ; i -- ) result = power ( x , result , arr [ i ] ) ; return result ; }
int countOnes ( int n ) { int count = 1 ; int rem = 1 ; while ( rem != 0 ) { rem = ( rem * 10 + 1 ) % n ; count ++ ; } return count ; }
void fibonacci ( double n ) { double fib ; for ( double i = 0 ; i < n ; i ++ ) { fib = ( Math . pow ( ( 1 + Math . sqrt ( 5 ) ) , i ) - Math . pow ( ( 1 - Math . sqrt ( 5 ) ) , i ) ) / ( Math . pow ( 2 , i ) * Math . sqrt ( 5 ) ) ; System . out . print ( ( int ) fib + " " ) ; } }
int findLCM ( int a , int b ) { int lar = Math . max ( a , b ) ; int small = Math . min ( a , b ) ; for ( int i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } }
int center_hexadecagonal_num ( int n ) { return 8 * n * n - 8 * n + 1 ; }
int findNature ( int a , int b , int n ) { int [ ] seq = new int [ 100 ] ; seq [ 0 ] = a ; seq [ 1 ] = b ; for ( int i = 2 ; i <= n ; i ++ ) seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ; if ( ( seq [ n ] & 1 ) != 0 ) return 1 ; else return 0 ; }
boolean findNature ( int a , int b , int n ) { if ( n == 0 ) return ( a & 1 ) == 1 ? true : false ; if ( n == 1 ) return ( b & 1 ) == 1 ? true : false ; if ( ( a & 1 ) == 0 ) { if ( ( b & 1 ) == 0 ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ( b & 1 ) == 0 ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } }
void check ( long m , long n ) { double RHS = m * ( double ) Math . log ( n ) ; double LHS = n * ( double ) Math . log ( m ) ; if ( LHS > RHS ) System . out . print ( "m^n > n^m" ) ; else if ( LHS < RHS ) System . out . print ( "m^n < n^m" ) ; else System . out . print ( "m^n = n^m" ) ; }
int numberOfmeet ( int a , int b ) { int ans ; if ( a > b ) ans = a - b ; else ans = b - a ; if ( a < 0 ) a = a * ( - 1 ) ; if ( b < 0 ) b = b * ( - 1 ) ; return ans / gcd ( a , b ) ; }
void SieveOfEratosthenes ( Vector < Integer > primes ) { boolean prime [ ] = new boolean [ MAX ] ; for ( int i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) { prime [ i ] = false ; } } } for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { primes . add ( primes . size ( ) , p ) ; } } }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int maxDivisorRange ( int a , int b , int l , int h ) { int g = gcd ( a , b ) ; int res = - 1 ; for ( int i = l ; i * i <= g && i <= h ; i ++ ) if ( g % i == 0 ) res = Math . max ( res , Math . max ( i , g / i ) ) ; return res ; }
int findMaxGCD ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; int high = arr [ n - 1 ] ; int [ ] divisors = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= Math . sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++ ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ; } } } for ( int i = high ; i >= 1 ; i -- ) if ( divisors [ i ] >= k ) return i ; return 0 ; }
void primes ( int n ) { int i = 2 ; int j = 0 ; int [ ] result = new int [ n ] ; int z = 0 ; while ( j < n ) { boolean flag = true ; for ( int item = 2 ; item <= ( int ) ( i * 1 / 2 ) ; item ++ ) if ( i % item == 0 && i != item ) { flag = false ; break ; } if ( flag ) { result [ z ++ ] = i ; j += 1 ; } i += 1 ; } for ( i = 0 ; i < result . length ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) System . out . print ( result [ j ] ) ; System . out . print ( " " ) ; } }
int subtractOne ( int x ) { int m = 1 ; while ( ! ( ( x & m ) > 0 ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
int subtractOne ( int x ) { return ( ( x << 1 ) + ( ~ x ) ) ; }
int Log2n ( int n ) { return ( n > 1 ) ? 1 + Log2n ( n / 2 ) : 0 ; }
boolean isPowerOfd ( int n , int d ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % ( Log2n ( d ) ) == 0 ) ; } return false ; }
void meanVector ( int mat [ ] [ ] ) { System . out . print ( "[ " ) ; for ( int i = 0 ; i < rows ; i ++ ) { double mean = 0.00 ; int sum = 0 ; for ( int j = 0 ; j < cols ; j ++ ) sum += mat [ j ] [ i ] ; mean = sum / rows ; System . out . print ( ( int ) mean + " " ) ; } System . out . print ( "]" ) ; }
void findMissing ( int a [ ] , int b [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) System . out . print ( a [ i ] + " " ) ; } }
int countDigits ( int n ) { double ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += Math . log10 ( i ) ; ans = ans * n ; return 1 + ( int ) Math . floor ( ans ) ; }
void checksum ( int n ) { if ( n == 0 ) { System . out . println ( "-2 -1 0 1 2" ) ; return ; } int inc ; if ( n > 0 ) inc = 1 ; else inc = - 1 ; for ( int i = 0 ; i <= n - 4 ; i += inc ) { if ( i + i + 1 + i + 2 + i + 3 + i + 4 == n ) { System . out . print ( ( i ) + " " + ( i + 1 ) + " " + ( i + 2 ) + " " + ( i + 3 ) + " " + ( i + 4 ) ) ; return ; } } System . out . println ( "-1" ) ; }
void checksum ( int n ) { if ( n % 5 == 0 ) System . out . println ( ( n / 5 - 2 ) + " " + ( n / 5 - 1 ) + " " + ( n / 5 ) + " " + ( n / 5 + 1 ) + " " + ( n / 5 + 2 ) ) ; else System . out . println ( "-1" ) ; }
void printGreater ( int x , int y ) { double X = y * Math . log ( x ) ; double Y = x * Math . log ( y ) ; if ( Math . abs ( X - Y ) < 1e-9 ) { System . out . println ( "Equal" ) ; } else if ( X > Y ) { System . out . println ( x + "^" + y ) ; } else { System . out . println ( y + "^" + x ) ; } }
int dfs ( int i ) { if ( visited [ i ] == 1 ) return 0 ; visited [ i ] = 1 ; int x = dfs ( goesTo [ i ] ) ; return ( x + 1 ) ; }
int noOfTranspositions ( int P [ ] , int n ) { for ( int i = 1 ; i <= n ; i ++ ) visited [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) goesTo [ P [ i ] ] = i + 1 ; int transpositions = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( visited [ i ] == 0 ) { int ans = dfs ( i ) ; transpositions += ans - 1 ; } } return transpositions ; }
int sumOfSeries ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; }
void findMissing ( int a [ ] , int b [ ] , int n , int m ) { HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < m ; i ++ ) s . add ( b [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ! s . contains ( a [ i ] ) ) System . out . print ( a [ i ] + " " ) ; }
int countUnmarked ( int N ) { if ( N % 2 == 0 ) return N / 2 ; else return N / 2 + 1 ; }
int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int calculateSeries ( int n ) { return factorial ( n + 1 ) - 1 ; }
int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int Pentatope_number ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 24 ; }
int minimumLength ( int x , int y , int z ) { return 1 + Math . abs ( x - y ) + Math . abs ( y - z ) ; }
boolean areEquivalent ( int num1 , int num2 ) { return divSum ( num1 ) == divSum ( num2 ) ; }
int dodecahedral_num ( int n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; }
long centered_heptagonal_num ( long n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; }
int centeredIcosahedralNum ( int n ) { return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ; return sum ; }
boolean checkHankelMatrix ( int n , int m [ ] [ ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i + j < n ) { if ( m [ i ] [ j ] != m [ i + j ] [ 0 ] ) return false ; } else { if ( m [ i ] [ j ] != m [ i + j - n + 1 ] [ n - 1 ] ) return false ; } } } return true ; }
int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
int Centered_Triangular_num ( int n ) { return ( 3 * n * n + 3 * n + 2 ) / 2 ; }
int Dodecagonal_number ( int n ) { return 5 * n * n - 4 * n ; }
boolean check ( int d , int x ) { if ( bit ( x / d ) <= bit ( d ) ) return true ; return false ; }
int countDivisor ( int n ) { return n - bs ( n ) + 1 ; }
boolean isPower ( int n ) { for ( int x = 2 ; x <= ( int ) Math . sqrt ( n ) ; x ++ ) { float f = ( float ) Math . log ( n ) / ( float ) Math . log ( x ) ; if ( ( f - ( int ) f ) == 0.0 ) return true ; } return false ; }
void wrapper ( int q , int n [ ] ) { int digitSum [ ] = new int [ N ] ; int factorDigitSum [ ] = new int [ N ] ; sumOddDigit ( digitSum ) ; sumFactor ( digitSum , factorDigitSum ) ; for ( int i = 0 ; i < q ; i ++ ) System . out . print ( factorDigitSum [ n [ i ] ] + " " ) ; }
boolean everMeet ( int x1 , int x2 , int v1 , int v2 ) { if ( x1 < x2 && v1 <= v2 ) { return false ; } if ( x1 > x2 && v1 >= v2 ) { return false ; } if ( x1 < x2 ) { swap ( x1 , x2 ) ; swap ( v1 , v2 ) ; } return ( ( x1 - x2 ) % ( v1 - v2 ) == 0 ) ; }
int find_maximum ( int a [ ] , int n , int k ) { HashMap < Integer , Integer > b = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; int d = Math . min ( 1 + i , n - i ) ; if ( ! b . containsKey ( x ) ) b . put ( x , d ) ; else { b . put ( x , Math . min ( d , b . get ( x ) ) ) ; } } int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( x != k - x && b . containsKey ( k - x ) ) ans = Math . min ( Math . max ( b . get ( x ) , b . get ( k - x ) ) , ans ) ; } return ans ; }
int number_of_digits ( int n ) { int i ; int res ; int sum = 0 ; for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; }
int MaximumHeight ( int [ ] a , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; }
int distinctGCDs ( int [ ] arr , int N ) { int M = - 1 , ans = 0 ; HashMap < Integer , Integer > Mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { M = Math . max ( M , arr [ i ] ) ; if ( Mp . containsKey ( arr [ i ] ) ) Mp . put ( arr [ i ] , 1 ) ; else Mp . put ( arr [ i ] , 0 ) ; } for ( int i = 1 ; i <= M ; i ++ ) { int currGcd = 0 ; for ( int j = i ; j <= M ; j += i ) { if ( Mp . containsKey ( j ) ) { currGcd = gcd ( currGcd , j ) ; if ( currGcd == i ) { ans ++ ; break ; } } } } return ans ; }
void printCollatz ( int n ) { while ( n != 1 ) { System . out . print ( n + " " ) ; if ( ( n & 1 ) == 1 ) n = 3 * n + 1 ; else n = n / 2 ; } System . out . print ( n ) ; }
boolean isProduct ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; }
void SieveOfEratosthenes ( int n , boolean prime [ ] , boolean primesquare [ ] , int a [ ] ) { for ( int i = 2 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int i = 0 ; i <= ( n * n ) ; i ++ ) primesquare [ i ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } int j = 0 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { a [ j ] = p ; primesquare [ p * p ] = true ; j ++ ; } } }
int countDivisors ( int n ) { if ( n == 1 ) return 1 ; boolean prime [ ] = new boolean [ n + 1 ] , primesquare [ ] = new boolean [ n * n + 1 ] ; SieveOfEratosthenes ( n , prime , primesquare , a ) ; int ans = 1 ; for ( int i = 0 ; ; i ++ ) { if ( a [ i ] * a [ i ] * a [ i ] > n ) break ; int cnt = 1 ; while ( n % a [ i ] == 0 ) { n = n / a [ i ] ; } ans = ans * cnt ; } if ( prime [ n ] ) ans = ans * 2 ; else if ( primesquare [ n ] ) ans = ans * 3 ; else if ( n != 1 ) ans = ans * 4 ; }
int sumofFactors ( int n ) { int res = 1 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
boolean checkArithmetic ( int n ) { int count = countDivisors ( n ) ; int sum = sumofFactors ( n ) ; return ( sum % count == 0 ) ; }
int findGCD ( ArrayList < Integer > arr , int n ) { int result = arr . get ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) result = gcd ( arr . get ( i ) , result ) ; return result ; }
int binomialCoeff ( int n , int k ) { int [ ] [ ] C = new int [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
double sumTillX ( double x , double n ) { double odd = Math . ceil ( n / 2.0 ) ; if ( x <= odd ) return x * x ; double even = x - odd ; return ( ( odd * odd ) + ( even * even ) + even ) ; }
double rangeSum ( double N , double L , double R ) { return sumTillX ( R , N ) - sumTillX ( L - 1 , N ) ; }
int magicOfSequence ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) sum += ( i * i * i + i * 2 ) ; return sum ; }
int magicOfSequence ( int N ) { return ( N * ( N + 1 ) / 2 ) + 2 * N ; }
boolean isProduct ( int arr [ ] , int n , int x ) { HashSet < Integer > hset = new HashSet < > ( ) ; if ( n < 2 ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { if ( x == 0 ) return true ; else continue ; } if ( x % arr [ i ] == 0 ) { if ( hset . contains ( x / arr [ i ] ) ) return true ; hset . add ( arr [ i ] ) ; } } return false ; }
int repUnitValue ( int n ) { if ( n % 2 == 0 n % 5 == 0 ) return 0 ; int rem = 1 ; int power = 1 ; int k = 1 ; while ( rem % n != 0 ) { k ++ ; power = power * 10 % n ; rem = ( rem + power ) % n ; } return k ; }
boolean isSplittable ( int n , int m ) { int total_sum = ( n * ( n + 1 ) ) / 2 ; int sum_s1 = ( total_sum + m ) / 2 ; int sum_s2 = total_sum - sum_s1 ; if ( total_sum < m ) return false ; if ( sum_s1 + sum_s2 == total_sum && sum_s1 - sum_s2 == m ) return ( GCD ( sum_s1 , sum_s2 ) == 1 ) ; return false ; }
boolean isPossibleToZero ( int a [ ] , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i & 1 ) == 0 ) odd += a [ i ] ; else even += a [ i ] ; } return ( odd == even ) ; }
double cosXSertiesSum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }
boolean isBlumInteger ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) prime [ i ] = true ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = i * 2 ; j <= n ; j += i ) prime [ j ] = false ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] ) { if ( ( n % i == 0 ) && ( ( i - 3 ) % 4 ) == 0 ) { int q = n / i ; return ( q != i && prime [ q ] && ( q - 3 ) % 4 == 0 ) ; } } } return false ; }
List < Integer > primeFactors ( int n ) { List < Integer > res = new ArrayList < Integer > ( ) ; if ( n % 2 == 0 ) { while ( n % 2 == 0 ) n = n / 2 ; res . add ( 2 ) ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; res . add ( i ) ; } } if ( n > 2 ) res . add ( n ) ; return res ; }
boolean isHoax ( int n ) { List < Integer > pf = primeFactors ( n ) ; if ( pf . get ( 0 ) == n ) return false ; int all_pf_sum = 0 ; for ( int i = 0 ; i < pf . size ( ) ; i ++ ) { int pf_sum ; for ( pf_sum = 0 ; pf . get ( i ) > 0 ; pf_sum += pf . get ( i ) % 10 , pf . set ( i , pf . get ( i ) / 10 ) ) ; all_pf_sum += pf_sum ; } int sum_n ; for ( sum_n = 0 ; n > 0 ; sum_n += n % 10 , n /= 10 ) ; return sum_n == all_pf_sum ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int summingSeries ( long n ) { return ( int ) Math . pow ( n , 2 ) ; }
int nCr ( int n , int r ) { int Nr = n , Dr = 1 , ans = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { ans = ( ans * Nr ) / ( Dr ) ; Nr -- ; Dr ++ ; } return ans ; }
int solve ( int n ) { int N = 2 * n - 2 ; int R = n - 1 ; return nCr ( N , R ) * fact ( n - 1 ) ; }
void printSumsOfDigits ( int n ) { for ( int base = 2 ; base < n ; ++ base ) System . out . print ( solve ( n , base ) + " " ) ; }
boolean check ( int N , int D ) { int temp = ( N * ( N + 1 ) ) / 2 + D ; return ( temp % 2 == 0 ) ; }
boolean isValidNesbitt ( double a , double b , double c ) { double A = a / ( b + c ) ; double B = b / ( a + c ) ; double C = c / ( a + b ) ; double inequality = A + B + C ; return ( inequality >= 1.5 ) ; }
int exactPrimeFactorCount ( int n ) { int count = 0 ; if ( n % 2 == 0 ) { count ++ ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { count ++ ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) count ++ ; return count ; }
int no_of_digit ( int a , int b ) { return ( ( int ) ( b * Math . log10 ( a ) ) + 1 ) ; }
Vector < Long > gen ( long n , Vector < Long > r ) { long a = r . get ( r . size ( ) - 1 ) ; a ++ ; for ( int i = 1 ; i <= n ; a += 2 , i ++ ) { r . add ( a ) ; } return r ; }
Vector < Long > conell ( long n ) { Vector < Long > res = new Vector < Long > ( ) ; long k = 1 ; res . add ( 0L ) ; while ( true ) { res = gen ( k , res ) ; k ++ ; int j = res . size ( ) - 1 ; while ( j != n && j + k > n ) { k -- ; } if ( j >= n ) { break ; } } res . remove ( 0 ) ; return res ; }
long factorial ( int n ) { long res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { res *= i ; } return res ; }
void printNComposite ( int n ) { long fact = factorial ( n + 1 ) ; for ( int i = 2 ; i <= n + 1 ; ++ i ) { System . out . print ( fact + i + " " ) ; } }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
boolean coprime ( int a , int b ) { return ( gcd ( a , b ) == 1 ) ; }
boolean isCubeFree ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i * i <= n ; i ++ ) if ( n % ( i * i * i ) == 0 ) return false ; return true ; }
void printCubeFree ( int n ) { boolean [ ] cubFree = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) cubFree [ i ] = true ; for ( int i = 2 ; i * i * i <= n ; i ++ ) { if ( cubFree [ i ] ) { for ( int multiple = 1 ; i * i * i * multiple <= n ; multiple ++ ) { cubFree [ i * i * i * multiple ] = false ; } } } for ( int i = 2 ; i <= n ; i ++ ) { if ( cubFree [ i ] == true ) System . out . print ( i + " " ) ; } }
int inversegrayCode ( int n ) { int inv = 0 ; for ( ; n != 0 ; n = n >> 1 ) inv ^= n ; return inv ; }
int calculateDivisors ( int A , int B ) { int N = ( A - B ) ; int noOfDivisors = 0 ; for ( int i = 1 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( ( N % i ) == 0 ) { if ( i > B ) noOfDivisors ++ ; if ( ( N / i ) != i && ( N / i ) > B ) noOfDivisors ++ ; } } return noOfDivisors ; }
int numberOfPossibleWaysUtil ( int A , int B ) { if ( A == B ) return - 1 ; if ( A < B ) return 0 ; int noOfDivisors = 0 ; noOfDivisors = calculateDivisors ( A , B ) ; return noOfDivisors ; }
void printPowerNumber ( int X , int N ) { power . add ( 1 ) ; List < Integer > res = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= X ; i ++ ) { nextPower ( N ) ; res . add ( power . get ( power . size ( ) - 1 ) ) ; res . add ( power . get ( 0 ) ) ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . get ( i ) ) ; }
int firstDigit ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact = fact * i ; while ( fact % 10 == 0 ) fact = fact / 10 ; } while ( fact >= 10 ) fact = fact / 10 ; return fact ; }
boolean possibleToReach ( int a , int b ) { int c = ( int ) Math . cbrt ( a * b ) ; int re1 = a / c ; int re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; }
ArrayList < Long > primes ( long n ) { boolean [ ] prime = new boolean [ ( int ) n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = i * 2 ; j <= n ; j += i ) prime [ j ] = false ; } } ArrayList < Long > arr = new ArrayList < Long > ( ) ; for ( int i = 2 ; i < n ; i ++ ) if ( prime [ i ] ) arr . add ( ( long ) i ) ; return arr ; }
int countDigits ( long n ) { long temp = n ; int c = 0 ; while ( temp != 0 ) { temp = temp / 10 ; c ++ ; } return c ; }
boolean frugal ( long n ) { ArrayList < Long > r = primes ( n ) ; long t = n ; long s = 0 ; for ( int i = 0 ; i < r . size ( ) ; i ++ ) { if ( t % r . get ( i ) == 0 ) { long k = 0 ; while ( t % r . get ( i ) == 0 ) { t = t / r . get ( i ) ; k ++ ; } if ( k == 1 ) s = s + countDigits ( r . get ( i ) ) ; else if ( k != 1 ) s = s + countDigits ( r . get ( i ) ) + countDigits ( k ) ; } } return ( countDigits ( n ) > s && s != 0 ) ; }
int nthSquareCube ( int n ) { return n * n * n * n * n * n ; }
int findGreatest ( int [ ] arr , int n ) { int result = - 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . max ( result , arr [ i ] ) ; return result ; }
int isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; if ( ( sr - Math . floor ( sr ) ) == 0 ) return ( int ) ( Math . floor ( sr ) ) ; else return - 1 ; }
int findS ( int s ) { int sr = isPerfectSquare ( s ) ; if ( sr == - 1 ) return - 1 ; return isTriangular ( sr ) ; }
long powerNumbers ( int n ) { HashSet < Long > v = new HashSet < Long > ( ) ; for ( long i = 2 ; i * i * i <= n ; i ++ ) { long j = i * i ; while ( j * i <= n ) { j *= i ; long s = ( long ) Math . sqrt ( j ) ; if ( s * s != j ) v . add ( j ) ; } } return v . size ( ) + ( long ) Math . sqrt ( n ) ; }
void NicomachuTheorum_sum ( int n ) { int sum = 0 ; for ( int k = 1 ; k <= n ; k ++ ) sum += k * k * k ; int triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
int checkDigits ( int n ) { while ( n > 0 ) { if ( ( ( n % 10 ) % 2 ) > 0 ) return 0 ; n /= 10 ; } return 1 ; }
int largestNumber ( int n ) { for ( int i = n ; ; i -- ) if ( checkDigits ( i ) > 0 ) return i ; }
int largestNumber ( int n ) { String s = "" ; int duplicate = n ; while ( n > 0 ) { s = ( char ) ( n % 10 + 48 ) + s ; n /= 10 ; } int index = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( ( ( int ) ( s . charAt ( i ) - '0' ) % 2 ) & 1 ) > 0 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; int num = 0 ; for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( int ) ( s . charAt ( i ) - '0' ) ; num = num * 10 + ( ( int ) s . charAt ( index ) - ( int ) ( '0' ) - 1 ) ; for ( int i = index + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 + 8 ; return num ; }
int countDigits ( int n ) { return ( int ) ( n * Math . log10 ( 2 ) + 1 ) ; }
int check_digits ( int n ) { while ( n != 0 ) { if ( ( n % 10 ) % 2 != 0 ) return 0 ; n /= 10 ; } return 1 ; }
int smallest_number ( int n ) { for ( int i = n ; ; i ++ ) if ( check_digits ( i ) != 0 ) return i ; }
int trickyCase ( String s , int index ) { int index1 = - 1 ; for ( int i = index - 1 ; i >= 0 ; i -- ) { int digit = s . charAt ( i ) - '0' ; if ( digit != 8 ) { index1 = i ; break ; } } if ( index1 == - 1 ) return 2 * ( int ) Math . pow ( 10 , s . length ( ) ) ; int num = 0 ; for ( int i = 0 ; i < index1 ; i ++ ) num = num * 10 + ( s . charAt ( i ) - '0' ) ; if ( s . charAt ( index1 ) % 2 == 0 ) num = num * 10 + ( s . charAt ( index1 ) - '0' + 2 ) ; else num = num * 10 + ( s . charAt ( index1 ) - '0' + 1 ) ; for ( int i = index1 + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 ; return num ; }
int smallestNumber ( int n ) { int num = 0 ; String s = "" ; int duplicate = n ; while ( n > 0 ) { s = ( char ) ( n % 10 + 48 ) + s ; n /= 10 ; } int index = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int digit = s . charAt ( i ) - '0' ; int val = digit & 1 ; if ( val == 1 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; if ( s . charAt ( index ) == '9' ) { num = trickyCase ( s , index ) ; return num ; } for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( s . charAt ( i ) - '0' ) ; num = num * 10 + ( s . charAt ( index ) - '0' + 1 ) ; for ( int i = index + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 ; return num ; }
int findBucketNo ( int p ) { return ( int ) Math . ceil ( ( Math . sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; }
int mean ( int a [ ] [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += a [ i ] [ j ] ; return sum / ( n * n ) ; }
int variance ( int a [ ] [ ] , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { a [ i ] [ j ] -= m ; a [ i ] [ j ] *= a [ i ] [ j ] ; } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += a [ i ] [ j ] ; return sum / ( n * n ) ; }
long productPrimeFactors ( int n ) { long product = 1 ; if ( n % 2 == 0 ) { product *= 2 ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { product = product * i ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) product = product * n ; return product ; }
int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
void sieve ( ) { boolean isPrime [ ] = new boolean [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( isPrime [ p ] == true ) primes . add ( p ) ; }
int modMult ( int a , int b , int mod ) { int res = 0 ; a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; }
int countWays ( int n , int m ) { int ans = 1 ; for ( int i = 1 ; i < primes . size ( ) ; i ++ ) { int powers = power ( n , primes . get ( i ) ) ; if ( powers == 0 ) break ; ans = modMult ( ans , powers + 1 , m ) % m ; } if ( ( ( ans - 1 ) % m ) < 0 ) return ( ans - 1 + m ) % m ; else return ( ans - 1 ) % m ; }
int subset ( int ar [ ] , int n ) { int res = 0 ; Arrays . sort ( ar ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; }
int findNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } }
void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { System . out . print ( i + ", " + j + ", " + k ) ; return ; } } } System . out . print ( "No Triplet" ) ; }
int sumofFactors ( int n ) { int res = 1 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
boolean checkFriendly ( int n , int m ) { int sumFactors_n = sumofFactors ( n ) ; int sumFactors_m = sumofFactors ( m ) ; int gcd_n = gcd ( n , sumFactors_n ) ; int gcd_m = gcd ( m , sumFactors_m ) ; if ( n / gcd_n == m / gcd_m && sumFactors_n / gcd_n == sumFactors_m / gcd_m ) return true ; else return false ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int primorial ( int n ) { int p = 2 ; n -- ; for ( int i = 3 ; n != 0 ; i ++ ) { if ( isPrime ( i ) == true ) { p = p * i ; n -- ; } i ++ ; } return p ; }
int findNextPrime ( int n ) { int nextPrime = n + 2 ; while ( true ) { if ( isPrime ( nextPrime ) == true ) break ; nextPrime ++ ; } return nextPrime ; }
int findSum ( int n ) { int multiTerms = n * ( n + 1 ) / 2 ; int sum = multiTerms ; for ( int i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; }
double procal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }
void testSomeNumbers ( int limit , int n ) { if ( n < 3 ) return ; for ( int a = 1 ; a <= limit ; a ++ ) for ( int b = a ; b <= limit ; b ++ ) { int pow_sum = ( int ) ( Math . pow ( a , n ) + Math . pow ( b , n ) ) ; double c = Math . pow ( pow_sum , 1.0 / n ) ; int c_pow = ( int ) Math . pow ( ( int ) c , n ) ; if ( c_pow == pow_sum ) { System . out . println ( "Count example found" ) ; return ; } } System . out . println ( "No counter example within given" + " range and data" ) ; }
void series ( int A , int X , int n ) { int nFact = factorial ( n ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { int niFact = factorial ( n - i ) ; int iFact = factorial ( i ) ; int aPow = ( int ) Math . pow ( A , n - i ) ; int xPow = ( int ) Math . pow ( X , i ) ; System . out . print ( ( nFact * aPow * xPow ) / ( niFact * iFact ) + " " ) ; } }
void series ( int A , int X , int n ) { int term = ( int ) Math . pow ( A , n ) ; System . out . print ( term + " " ) ; for ( int i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; System . out . print ( term + " " ) ; } }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void productReduce ( int n , int num [ ] , int den [ ] ) { int new_num = 1 , new_den = 1 ; for ( int i = 0 ; i < n ; i ++ ) { new_num *= num [ i ] ; new_den *= den [ i ] ; } int GCD = gcd ( new_num , new_den ) ; new_num /= GCD ; new_den /= GCD ; System . out . println ( new_num + "/" + new_den ) ; }
int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
int repeatedNumberSum ( int n , int x ) { int sum = x * digSum ( n ) ; return digSum ( sum ) ; }
int totalSumDivisibleByNum ( int n , int number ) { int firstnum = ( int ) Math . pow ( 10 , n - 1 ) ; int lastnum = ( int ) Math . pow ( 10 , n ) ; int sum = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; }
int minRemove ( int a [ ] , int b [ ] , int n , int m ) { HashMap < Integer , Integer > countA = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > countB = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( countA . containsKey ( a [ i ] ) ) countA . put ( a [ i ] , countA . get ( a [ i ] ) + 1 ) ; else countA . put ( a [ i ] , 1 ) ; } for ( int i = 0 ; i < m ; i ++ ) { if ( countB . containsKey ( b [ i ] ) ) countB . put ( b [ i ] , countB . get ( b [ i ] ) + 1 ) ; else countB . put ( b [ i ] , 1 ) ; } int res = 0 ; Set < Integer > s = countA . keySet ( ) ; for ( int x : s ) if ( countB . containsKey ( x ) ) res += Math . min ( countB . get ( x ) , countA . get ( x ) ) ; return res ; }
int totalSumDivisibleByNum ( int digit , int number ) { int firstnum = ( int ) Math . pow ( 10 , digit - 1 ) ; int lastnum = ( int ) Math . pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; int count = ( ( lastnum - firstnum ) / number + 1 ) ; return ( ( lastnum + firstnum ) * count ) / 2 ; }
int numberofterm ( int n , int number ) { int firstnum = ( int ) Math . pow ( 10 , n - 1 ) ; int lastnum = ( int ) Math . pow ( 10 , n ) ; int count = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; }
int sumofseries ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) res += ( i ) * ( i + 1 ) * ( i + 2 ) ; return res ; }
int sumofseries ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) ; }
int seiresSum ( int n , int [ ] a ) { int res = 0 , i ; for ( i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }
int seiresSum ( int n , int [ ] a ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }
void printGMeans ( int A , int B , int N ) { float R = ( float ) Math . pow ( ( float ) ( B / A ) , 1.0 / ( float ) ( N + 1 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) System . out . print ( A * Math . pow ( R , i ) + " " ) ; }
boolean checkdigit ( int n , int k ) { while ( n != 0 ) { int rem = n % 10 ; if ( rem == k ) return true ; n = n / 10 ; } return false ; }
boolean isValid ( long i , long m ) { long sq_i = ( long ) Math . sqrt ( i ) ; long sq = Math . min ( m , sq_i ) ; for ( long j = 2 ; j <= sq ; j ++ ) if ( i % j == 0 ) return false ; return true ; }
void findLargestNum ( long n , long m ) { for ( long i = n ; i > m ; i -- ) { if ( isValid ( i , m ) ) { System . out . println ( i ) ; return ; } } System . out . println ( "Number Doesn't Exists" ) ; }
void georgeCantor ( int n ) { int i = 1 ; int j = 1 ; int k = 1 ; while ( k < n ) { j ++ ; k ++ ; if ( k == n ) break ; while ( j > 1 && k < n ) { i ++ ; j -- ; k ++ ; } if ( k == n ) break ; i ++ ; k ++ ; if ( k == n ) break ; while ( i > 1 && k < n ) { i -- ; j ++ ; k ++ ; } } System . out . println ( "N-th term : " + i + "/" + j ) ; }
boolean isDivisible ( long n ) { while ( n / 100 > 0 ) { int last_digit = ( int ) n % 10 ; n /= 10 ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; }
int digitSum ( long n ) { int digSum = 0 ; while ( n > 0 ) { digSum += n % 10 ; n /= 10 ; } return digSum ; }
long countInteger ( long n , long s ) { if ( n < s ) return 0 ; for ( long i = s ; i <= Math . min ( n , s + 163 ) ; i ++ ) if ( ( i - digitSum ( i ) ) > s ) return ( n - i + 1 ) ; return 0 ; }
int division ( int num1 , int num2 ) { if ( num1 == 0 ) return 0 ; if ( num2 == 0 ) return Integer . MAX_VALUE ; boolean negResult = false ; if ( num1 < 0 ) { num1 = - num1 ; if ( num2 < 0 ) num2 = - num2 ; else negResult = true ; } else if ( num2 < 0 ) { num2 = - num2 ; negResult = true ; } int quotient = 0 ; while ( num1 >= num2 ) { num1 = num1 - num2 ; quotient ++ ; } if ( negResult ) quotient = - quotient ; return quotient ; }
boolean pronic_check ( int n ) { int x = ( int ) ( Math . sqrt ( n ) ) ; if ( x * ( x + 1 ) == n ) return true ; else return false ; }
int power ( int n , int r ) { int count = 0 ; for ( int i = r ; ( n / i ) >= 1 ; i = i * r ) count += n / i ; return count ; }
boolean isOrthogonal ( int [ ] [ ] a , int m , int n ) { if ( m != n ) return false ; int [ ] [ ] trans = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) trans [ i ] [ j ] = a [ j ] [ i ] ; int [ ] [ ] prod = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int k = 0 ; k < n ; k ++ ) { sum = sum + ( a [ i ] [ k ] * a [ j ] [ k ] ) ; } prod [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && prod [ i ] [ j ] != 0 ) return false ; if ( i == j && prod [ i ] [ j ] != 1 ) return false ; } } return true ; }
int digitNumber ( long n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 9 ; if ( n % 2 != 0 ) { int temp = digitNumber ( ( n - 1 ) / 2 ) % mod ; return ( 9 * ( temp * temp ) % mod ) % mod ; } else { int temp = digitNumber ( n / 2 ) % mod ; return ( temp * temp ) % mod ; } }
int countExcluding ( int n , int d ) { if ( d == 0 ) return ( 9 * digitNumber ( n - 1 ) ) % mod ; else return ( 8 * digitNumber ( n - 1 ) ) % mod ; }
boolean isPerfectSquare ( int x ) { if ( x >= 0 ) { int sr = ( int ) Math . sqrt ( x ) ; return ( ( sr * sr ) == x ) ; } return false ; }
void checkperfectsquare ( int n ) { if ( Math . ceil ( ( double ) Math . sqrt ( n ) ) == Math . floor ( ( double ) Math . sqrt ( n ) ) ) { System . out . print ( "perfect square" ) ; } else { System . out . print ( "not a perfect square" ) ; } }
void printGP ( int a , int r , int n ) { int curr_term ; for ( int i = 0 ; i < n ; i ++ ) { curr_term = a * ( int ) Math . pow ( r , i ) ; System . out . print ( curr_term + " " ) ; } }
int Nth_of_AP ( int a , int d , int N ) { return ( a + ( N - 1 ) * d ) ; }
boolean checkFibinnary ( int n ) { int prev_last = 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 && prev_last != 0 ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; }
boolean check ( int n , int p ) { int maximum = - 1 ; while ( ( n % 2 ) == 0 ) { maximum = Math . max ( maximum , 2 ) ; n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { maximum = Math . max ( maximum , i ) ; n = n / i ; } } if ( n > 2 ) maximum = Math . max ( maximum , n ) ; return ( maximum <= p ) ; }
int Nonagonal ( int n ) { return n * ( 7 * n - 5 ) / 2 ; }
void Nonagonal ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( i * ( 7 * i - 5 ) / 2 ) ; System . out . print ( " " ) ; } }
int findLcm ( int [ ] [ ] arr , int size ) { int ans = arr [ 0 ] [ 1 ] ; for ( int i = 1 ; i < size ; i ++ ) ans = ( ( ( arr [ i ] [ 1 ] * ans ) ) / ( gcd ( arr [ i ] [ 1 ] , ans ) ) ) ; return ( ans ) ; }
boolean checkplusperfect ( int x ) { int temp = x ; int n = 0 ; while ( x != 0 ) { x /= 10 ; n ++ ; } x = temp ; int sum = 0 ; while ( x != 0 ) { sum += Math . pow ( x % 10 , n ) ; x /= 10 ; } return ( sum == temp ) ; }
int sum_series ( int n ) { int nSquare = n * n ; return nSquare * ( nSquare - 1 ) / 4 ; }
boolean isPrime ( int n ) { if ( n == 0 n == 1 ) return false ; int root = ( int ) Math . sqrt ( n ) ; for ( int i = 2 ; i <= root ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
boolean isSandwitched ( int n ) { return ( isPrime ( n - 1 ) && isPrime ( n + 1 ) ) ; }
boolean Div_by_8 ( int n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; }
float mean ( float mid [ ] , int freq [ ] , int n ) { float sum = 0 , freqSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + mid [ i ] * freq [ i ] ; freqSum = freqSum + freq [ i ] ; } return sum / freqSum ; }
float groupedSD ( float lower_limit [ ] , float upper_limit [ ] , int freq [ ] , int n ) { float mid [ ] = new float [ n ] ; float sum = 0 , freqSum = 0 , sd ; for ( int i = 0 ; i < n ; i ++ ) { mid [ i ] = ( lower_limit [ i ] + upper_limit [ i ] ) / 2 ; sum = sum + freq [ i ] * mid [ i ] * mid [ i ] ; freqSum = freqSum + freq [ i ] ; } sd = ( float ) Math . sqrt ( ( sum - freqSum * mean ( mid , freq , n ) * mean ( mid , freq , n ) ) / ( freqSum - 1 ) ) ; return sd ; }
Boolean divisibleBy20 ( String num ) { int lastTwoDigits = Integer . parseInt ( num . substring ( num . length ( ) - 2 , num . length ( ) ) ) ; return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) ; }
double findArea ( double d ) { return ( d * d ) / 2 ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
int sumOfSeries ( int n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }
int getMSB ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( ( n + 1 ) >> 2 ) ; }
void multiply ( int F [ ] [ ] , int M [ ] [ ] ) { int x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ; int y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ; int z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ; int w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ; F [ 0 ] [ 0 ] = x ; F [ 0 ] [ 1 ] = y ; F [ 1 ] [ 0 ] = z ; F [ 1 ] [ 1 ] = w ; }
void power ( int F [ ] [ ] , int n ) { if ( n == 0 n == 1 ) return ; int [ ] [ ] M = { { 1 , 1 } , { 1 , 0 } } ; for ( int m = getMSB ( n ) ; m > 0 ; m = m >> 1 ) { multiply ( F , F ) ; if ( ( n & m ) > 0 ) { multiply ( F , M ) ; } } }
int fib ( int n ) { int [ ] [ ] F = { { 1 , 1 } , { 1 , 0 } } ; if ( n == 0 ) return 0 ; power ( F , n - 1 ) ; return F [ 0 ] [ 0 ] ; }
boolean isDvisibleBy12 ( String num ) { if ( num . length ( ) >= 3 ) { int d1 = ( int ) num . charAt ( num . length ( ) - 1 ) ; if ( d1 % 2 != 0 ) return false ; int d2 = ( int ) num . charAt ( num . length ( ) - 2 ) ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num . charAt ( i ) ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = Integer . parseInt ( num ) ; return ( number % 12 == 0 ) ; } }
int StepstoReachTarget ( int target ) { target = Math . abs ( target ) ; int n = ( int ) Math . ceil ( ( - 1.0 + ( int ) Math . sqrt ( 1 + 8.0 * target ) ) / 2 ) ; int sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; int d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) != 0 ? 2 : 1 ) ; }
float Calculate_GST ( float org_cost , float N_price ) { return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; }
int avg_of_even_num ( int n ) { return n + 1 ; }
int avg_of_odd_num ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; }
int avg_of_odd_num ( int n ) { return n ; }
double seriesSum ( int n ) { int i = 1 ; double res = 0.0 ; boolean sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ( double ) ++ i / ++ i ; } else { sign = ! sign ; res = res - ( double ) ++ i / ++ i ; } } return res ; }
Boolean check ( int n ) { int d = ( int ) Math . sqrt ( n ) ; if ( d * d == n ) return true ; return false ; }
int largestNonPerfectSquareNumber ( int a [ ] , int n ) { int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! check ( a [ i ] ) ) maxi = Math . max ( a [ i ] , maxi ) ; } return maxi ; }
int modInverse ( int a , int prime ) { a = a % prime ; for ( int x = 1 ; x < prime ; x ++ ) if ( ( a * x ) % prime == 1 ) return x ; return - 1 ; }
void printModIverses ( int n , int prime ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( modInverse ( i , prime ) + " " ) ; }
int countSymmetric ( int n ) { if ( n == 0 ) return 1 ; return 1 << ( ( n * ( n + 1 ) ) / 2 ) ; }
void SternSequenceFunc ( Vector < Integer > BrocotSequence , int n ) { for ( int i = 1 ; BrocotSequence . size ( ) < n ; i ++ ) { int considered_element = BrocotSequence . get ( i ) ; int precedent = BrocotSequence . get ( i - 1 ) ; BrocotSequence . add ( considered_element + precedent ) ; BrocotSequence . add ( considered_element ) ; } for ( int i = 0 ; i < 15 ; ++ i ) System . out . print ( BrocotSequence . get ( i ) + " " ) ; }
int centeredNonagonal ( int n ) { return ( 3 * n - 2 ) * ( 3 * n - 1 ) / 2 ; }
void sieve ( int n , boolean prime [ ] ) { for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < n ; i += p ) prime [ i ] = false ; } } }
void printSophieGermanNumber ( int n ) { boolean prime [ ] = new boolean [ 2 * n + 1 ] ; Arrays . fill ( prime , true ) ; sieve ( 2 * n + 1 , prime ) ; for ( int i = 2 ; i < n ; ++ i ) { if ( prime [ i ] && prime [ 2 * i + 1 ] ) System . out . print ( i + " " ) ; } }
void fib ( int f [ ] , int N ) { f [ 1 ] = 1 ; f [ 2 ] = 1 ; for ( int i = 3 ; i <= N ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; }
void printAP ( int a , int d , int n ) { int curr_term ; curr_term = a ; for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( curr_term + " " ) ; curr_term = curr_term + d ; } }
float Mean ( float arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum / n ; }
boolean isRevDiffDivisible ( int x , int k ) { int n = x ; int m = 0 ; int flag ; while ( x > 0 ) { m = m * 10 + x % 10 ; x /= 10 ; } return ( Math . abs ( n - m ) % k == 0 ) ; }
int countNumbers ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) if ( isRevDiffDivisible ( i , k ) ) ++ count ; return count ; }
boolean isRatioPossible ( int lowCost , int upCost , int lowQuant , int upQuant , int r ) { for ( int i = lowQuant ; i <= upQuant ; i ++ ) { int ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; }
int centeredHexagonalNumber ( int n ) { return 3 * n * ( n - 1 ) + 1 ; }
long oddNumSum ( int n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; }
boolean isPerfectSquare ( int n ) { if ( n < 0 ) return false ; int root = Math . round ( ( int ) ( Math . sqrt ( n ) ) ) ; return n == root * root ; }
void printnonsquare ( int n ) { int count = 0 ; for ( int i = 1 ; count < n ; ++ i ) { if ( ! isPerfectSquare ( i ) ) { System . out . print ( i + " " ) ; count ++ ; } } }
int nonsquare ( int n ) { return n + ( int ) ( 0.5 + ( Math . sqrt ( n ) ) ) ; }
void printNonSquare ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( nonsquare ( i ) + " " ) ; }
int trailingZero ( int x ) { int i = 5 , count = 0 ; while ( x > i ) { count = count + x / i ; i = i * 5 ; } return count ; }
int countProductTrailing ( int M , int N ) { return trailingZero ( N ) + trailingZero ( M ) ; }
boolean isTrimorphic ( int N ) { int cube = N * N * N ; while ( N > 0 ) { if ( N % 10 != cube % 10 ) return false ; N /= 10 ; cube /= 10 ; } return true ; }
boolean checkTrimorphic ( int num ) { int cube = num * num * num ; while ( num > 0 ) { if ( num % 10 != cube % 10 ) return false ; num /= 10 ; cube /= 10 ; } return true ; }
int averageEven ( int n ) { if ( n % 2 != 0 ) { System . out . println ( "Invalid Input" ) ; return - 1 ; } int sum = 0 , count = 0 ; while ( n >= 2 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; }
int averageEven ( int n ) { if ( n % 2 != 0 ) { System . out . println ( "Invalid Input" ) ; return - 1 ; } return ( n + 2 ) / 2 ; }
int averageOdd ( int n ) { if ( n % 2 == 0 ) { System . out . println ( "Invalid Input" ) ; return - 1 ; } int sum = 0 , count = 0 ; while ( n >= 1 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; }
long fifthPowerSum ( int n ) { return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) / 12 ; }
int find_distance ( int n ) { return n * ( 3 * n + 7 ) ; }
void nearestPerfectSquare ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int sr = ( int ) Math . sqrt ( arr [ i ] ) ; if ( ( sr & 1 ) == ( arr [ i ] & 1 ) ) System . out . print ( ( sr * sr ) + " " ) ; else { sr ++ ; System . out . print ( ( sr * sr ) + " " ) ; } } }
int squareSum ( int n ) { return n * ( 4 * n * n - 1 ) / 3 ; }
int squareSum ( int n ) { return 2 * n * ( n + 1 ) * ( 2 * n + 1 ) / 3 ; }
Boolean isMunchhausen ( int n ) { long sum = 0l ; int temp = n ; while ( temp > 0 ) { int index = temp % 10 ; sum = sum + pwr [ index ] ; temp /= 10 ; } return ( sum == n ) ; }
int kthdigit ( int a , int b , int k ) { int p = ( int ) Math . pow ( a , b ) ; int count = 0 ; while ( p > 0 && count < k ) { int rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; }
Boolean isPentagonal ( int N ) { int i = 1 , M ; do { M = ( 3 * i * i - i ) / 2 ; i += 1 ; } while ( M < N ) ; return ( M == N ) ; }
long fourthPowerSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i * i * i ) ; return sum ; }
int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; }
int unitnumber ( int x , int y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( ( int ) ( Math . pow ( x , y ) ) ) % 10 ) ; }
boolean isPrime ( int n ) { if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i * i <= n ; i += 2 ) if ( n % i == 0 ) return false ; return true ; }
int nextPrime ( int start ) { int next = start + 1 ; while ( ! isPrime ( next ) ) next ++ ; return next ; }
boolean areAdjacentPrimes ( int a , int b , int c ) { if ( ! isPrime ( a ) || ! isPrime ( b ) || ! isPrime ( c ) ) return false ; int next = nextPrime ( a ) ; if ( next != b ) return false ; if ( nextPrime ( b ) != c ) return false ; return true ; }
int findDivisor ( int x , int y ) { if ( x == y ) return y ; return 2 ; }
long digSum ( long n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
long PowDigSum ( long n , long x ) { long sum = digSum ( n ) ; long rem = x % 6 ; if ( ( sum == 3 sum == 6 ) && x > 1 ) return 9 ; else if ( x == 1 ) return sum ; else if ( x == 0 ) return 1 ; else if ( rem == 0 ) return digSum ( ( long ) Math . pow ( sum , 6 ) ) ; else return digSum ( ( long ) Math . pow ( sum , rem ) ) ; }
float AvgofSquareN ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; }
float AvgofSquareN ( int n ) { return ( float ) ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
int sumofFactors ( int n ) { if ( n % 2 != 0 ) return 0 ; int res = 1 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
float func ( float x ) { return ( 1 / ( 1 + x * x ) ) ; }
float calculate ( float lower_limit , float upper_limit , int interval_limit ) { float value ; float interval_size = ( upper_limit - lower_limit ) / interval_limit ; float sum = func ( lower_limit ) + func ( upper_limit ) ; for ( int i = 1 ; i < interval_limit ; i ++ ) { if ( i % 3 == 0 ) sum = sum + 2 * func ( lower_limit + i * interval_size ) ; else sum = sum + 3 * func ( lower_limit + i * interval_size ) ; } return ( 3 * interval_size / 8 ) * sum ; }
int LCM ( int a , int b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; }
int lcmOfNumerator ( Vector < pair > vect ) { int lcm = vect . get ( 0 ) . first ; for ( int i = 1 ; i < vect . size ( ) ; i ++ ) lcm = LCM ( vect . get ( i ) . first , lcm ) ; return lcm ; }
int gcdOfDemoninators ( Vector < pair > vect ) { int gcd = vect . get ( 0 ) . second ; for ( int i = 1 ; i < vect . size ( ) ; i ++ ) gcd = __gcd ( vect . get ( i ) . second , gcd ) ; return gcd ; }
void lcmOfRationals ( Vector < pair > vect ) { System . out . print ( lcmOfNumerator ( vect ) + "/" + gcdOfDemoninators ( vect ) ) ; }
void makePermutation ( int [ ] a , int n ) { HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( a [ i ] ) ) { count . put ( a [ i ] , count . get ( a [ i ] ) + 1 ) ; } else { count . put ( a [ i ] , 1 ) ; } } int next_missing = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( a [ i ] ) && count . get ( a [ i ] ) != 1 a [ i ] > n a [ i ] < 1 ) { count . put ( a [ i ] , count . get ( a [ i ] ) - 1 ) ; while ( count . containsKey ( next_missing ) ) next_missing ++ ; a [ i ] = next_missing ; count . put ( next_missing , 1 ) ; } } }
float focal_length_convex ( float R ) { return - ( R / 2 ) ; }
float focal_length ( float image_distance , float object_distance ) { return 1 / ( ( 1 / image_distance ) + ( 1 / object_distance ) ) ; }
int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
int countSolutions ( int n , int val ) { int total = 0 ; if ( n == 1 && val >= 0 ) return 1 ; for ( int i = 0 ; i <= val ; i ++ ) { total += countSolutions ( n - 1 , val - i ) ; } return total ; }
int lcm ( int a , int b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
boolean twinPrime ( int n1 , int n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && Math . abs ( n1 - n2 ) == 2 ) ; }
int mobius ( int n ) { int p = 0 ; if ( n % 2 == 0 ) { n = n / 2 ; p ++ ; if ( n % 2 == 0 ) return 0 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; p ++ ; if ( n % i == 0 ) return 0 ; } } return ( p % 2 == 0 ) ? - 1 : 1 ; }
void fib ( int f [ ] , int n ) { int i ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( i = 2 ; i <= n ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; }
void fibcoef ( int fc [ ] [ ] , int f [ ] , int n ) { for ( int i = 0 ; i <= n ; i ++ ) fc [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { int k = j ; while ( k > 0 ) { k -- ; fc [ i ] [ j ] *= f [ k ] ; } k = 1 ; while ( ( j + 1 ) != k ) fc [ i ] [ j ] /= f [ k ++ ] ; } } }
double sumOfSeries ( int n ) { return 0.0246 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }
int sumofNterm ( int a , int d , int b , int r , int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( a + ( i - 1 ) * d ) * ( b * Math . pow ( r , i - 1 ) ) ) ; return sum ; }
double sumOfTheSeries ( int n ) { double sum = 0.0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 1.0 / ( i * ( i + 1 ) ) ; return sum ; }
long sum ( long n ) { long root = ( long ) Math . sqrt ( n ) ; long ans = 0 ; for ( int i = 1 ; i <= root ; i ++ ) ans += n / i ; ans = 2 * ans - ( root * root ) ; return ans ; }
int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 2 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
int sumOfTheSeries ( int n ) { int sum_n = ( n * ( n + 1 ) / 2 ) ; int sum_sq_n = ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; return ( sum_n + sum_sq_n ) ; }
int sumofsquare ( int n ) { int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ; return sum ; }
int factorial ( int start , int end ) { int res = 1 ; for ( int i = start ; i <= end ; i ++ ) res *= i ; return res ; }
int sumofsquare ( int n ) { return factorial ( n + 1 , 2 * n ) / factorial ( 1 , n ) ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum = sum + i ; return sum ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + i * i ; return sum ; }
int sumOfSeries ( int n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
int evenSum ( int n ) { int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; }
int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; }
int evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; }
double Series ( int n ) { int i ; double sums = 0.0 , ser ; for ( i = 1 ; i <= n ; ++ i ) { ser = 1 / Math . pow ( i , i ) ; sums += ser ; } return sums ; }
int TrinomialValue ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k < - n k > n ) return 0 ; return TrinomialValue ( n - 1 , k - 1 ) + TrinomialValue ( n - 1 , k ) + TrinomialValue ( n - 1 , k + 1 ) ; }
int Series ( int n ) { int i ; int sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; }
double Series ( double x , int n ) { double sum = 1 , term = 1 , fct = 1 ; double p = 1 , multi = 1 ; for ( int i = 1 ; i < n ; i ++ ) { fct = fct * multi * ( multi + 1 ) ; p = p * x * x ; term = ( - 1 ) * term ; multi += 2 ; sum = sum + ( term * p ) / fct ; } return sum ; }
boolean isPresent ( int arr [ ] , int low , int high , int value ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] == value ) return true ; else if ( arr [ mid ] > value ) high = mid - 1 ; else low = mid + 1 ; } return false ; }
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int value = x - arr1 [ i ] ; if ( isPresent ( arr2 , 0 , n - 1 , value ) ) count ++ ; } return count ; }
int two_factor ( int n ) { int twocount = 0 ; while ( n % 2 == 0 ) { twocount ++ ; n = n / 2 ; } return twocount ; }
int five_factor ( int n ) { int fivecount = 0 ; while ( n % 5 == 0 ) { fivecount ++ ; n = n / 5 ; } return fivecount ; }
int find_con_zero ( int arr [ ] , int n ) { int twocount = 0 ; int fivecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { twocount += two_factor ( arr [ i ] ) ; fivecount += five_factor ( arr [ i ] ) ; } if ( twocount < fivecount ) return twocount ; else return fivecount ; }
int fib ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 ; int fn = 5 ; while ( t < n ) { fn = ( int ) Math . round ( fn * PHI ) ; t ++ ; } return fn ; }
int first ( int a , int b , int c ) { a %= b ; for ( int i = 1 ; i <= b ; i ++ ) { a = a * 10 ; if ( a / b == c ) return i ; a %= b ; } return - 1 ; }
void subsetDifference ( int n ) { int s = n * ( n + 1 ) / 2 ; if ( n % 4 == 0 ) { System . out . println ( "First subset sum = " + s / 2 ) ; System . out . println ( "Second subset sum = " + s / 2 ) ; System . out . println ( "Difference = " + 0 ) ; } else { if ( n % 4 == 1 n % 4 == 2 ) { System . out . println ( "First subset sum = " + s / 2 ) ; System . out . println ( "Second subset sum = " + ( ( s / 2 ) + 1 ) ) ; System . out . println ( "Difference = " + 1 ) ; } else { System . out . println ( "First subset sum = " + s / 2 ) ; System . out . println ( "Second subset sum = " + s / 2 ) ; System . out . println ( "Difference = " + 0 ) ; } } }
float func ( float x , float y ) { return ( x + y + x * y ) ; }
void euler ( float x0 , float y , float h , float x ) { float temp = - 0 ; while ( x0 < x ) { temp = y ; y = y + h * func ( x0 , y ) ; x0 = x0 + h ; } System . out . println ( "Approximate solution at x = " + x + " is " + y ) ; }
void timeToMeet ( double s , double v ) { double V = 3 * v / 2 ; double time = s / V ; System . out . println ( ( float ) time ) ; }
int maxcoefficientvalue ( int n ) { if ( n % 2 == 0 ) return binomialCoeff ( n , n / 2 ) ; else return binomialCoeff ( n , ( n + 1 ) / 2 ) ; }
int LCM ( int x , int y , int z ) { int ans = ( ( x * y ) / ( __gcd ( x , y ) ) ) ; return ( ( z * ans ) / ( __gcd ( ans , z ) ) ) ; }
int findDivisible ( int n , int x , int y , int z ) { int lcm = LCM ( x , y , z ) ; int ndigitnumber = ( int ) Math . pow ( 10 , n - 1 ) ; int reminder = ndigitnumber % lcm ; if ( reminder == 0 ) return ndigitnumber ; ndigitnumber += lcm - reminder ; if ( ndigitnumber < Math . pow ( 10 , n ) ) return ndigitnumber ; else return 0 ; }
int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 1 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
int sumOfTheSeries ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
void checksum ( int n ) { if ( n == 0 ) { System . out . println ( "-1 0 1" ) ; return ; } int inc ; if ( n > 0 ) inc = 1 ; else inc = - 1 ; for ( int i = 0 ; i <= n - 2 ; i += inc ) { if ( i + i + 1 + i + 2 == n ) { System . out . println ( i + " " + ( i + 1 ) + " " + ( i + 2 ) ) ; return ; } } System . out . println ( "-1" ) ; }
void checksum ( int n ) { if ( n % 3 == 0 ) System . out . println ( n / 3 - 1 + " " + n / 3 + " " + ( n / 3 + 1 ) ) ; else System . out . println ( "-1" ) ; }
void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { System . out . println ( "x = " + i + ", y = " + ( n - ( i * a ) ) / b ) ; return ; } } System . out . println ( "No solution" ) ; }
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } } return sum ; }
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }
int sum_all_divisors ( int num ) { int sum = 0 ; for ( int i = 1 ; i <= Math . sqrt ( num ) ; i ++ ) { sum += t1 + t2 ; } return sum ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int sumOfLargePrimeFactor ( int n ) { int prime [ ] = new int [ n + 1 ] , sum = 0 ; Arrays . fill ( prime , 0 ) ; int max = n / 2 ; for ( int p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = p ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] != 0 ) sum += prime [ p ] ; else sum += p ; } return sum ; }
int gcd ( int a , int b ) { if ( a == 0 b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
int cpFact ( int x , int y ) { while ( gcd ( x , y ) != 1 ) { x = x / gcd ( x , y ) ; } return x ; }
int binomialCoeffSum ( int n ) { return ( 1 << n ) ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
int countUnsetBitsInGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return ( r - l + 1 ) - countSetBits ( n & num ) ; }
long evenPowerSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int j = 2 * i ; sum = sum + ( j * j * j * j ) ; } return sum ; }
long evenPowerSum ( int n ) { return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; }
int balancedprime ( int n ) { boolean [ ] prime = new boolean [ MAX + 1 ] ; for ( int k = 0 ; k < MAX + 1 ; k ++ ) prime [ k ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } Vector < Integer > v = new Vector < Integer > ( ) ; for ( int p = 3 ; p <= MAX ; p += 2 ) if ( prime [ p ] ) v . add ( p ) ; int count = 0 ; for ( int i = 1 ; i < v . size ( ) ; i ++ ) { if ( ( int ) v . get ( i ) == ( ( int ) v . get ( i + 1 ) + ( int ) v . get ( i - 1 ) ) / 2 ) count ++ ; if ( count == n ) return ( int ) v . get ( i ) ; } return 1 ; }
int calculateNoOFactors ( int n ) { if ( n == 1 ) return 1 ; int ans = 1 ; int dup = factor [ n ] ; int c = 1 ; int j = n / factor [ n ] ; while ( j != 1 ) { if ( factor [ j ] == dup ) c += 1 ; else { dup = factor [ j ] ; ans = ans * ( c + 1 ) ; c = 1 ; } j = j / factor [ j ] ; } ans = ans * ( c + 1 ) ; return ans ; }
int smallest ( int n ) { for ( int i = 1 ; ; i ++ ) if ( calculateNoOFactors ( i ) >= n ) return i ; }
int squaresum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
int counLastDigitK ( int low , int high , int k ) { int count = 0 ; for ( int i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; }
int minimumSum ( int n ) { if ( isPrime ( n ) ) return 1 ; if ( n % 2 == 0 ) return 2 ; if ( isPrime ( n - 2 ) ) return 2 ; return 3 ; }
int lastDigit ( int n ) { return ( n % 10 ) ; }
double numberOfTriangles ( int n ) { double ans = 2 * ( pow ( 3 , n ) ) - 1 ; return ans ; }
boolean isPrime ( int x ) { if ( x == 0 x == 1 ) return false ; for ( int i = 2 ; i * i <= x ; ++ i ) if ( x % i == 0 ) return false ; return true ; }
void findPrimes ( int n ) { System . out . print ( n ) ; System . out . print ( 2 + " " + ( n - 2 ) ) ; { System . out . print ( 3 + " " ) ; n = n - 3 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime ( i ) && isPrime ( n - i ) ) { System . out . print ( i + " " + ( n - i ) ) ; break ; } } } }
boolean checkDigits ( int n ) { while ( n > 0 ) { int dig = n % 10 ; if ( dig != 2 && dig != 3 && dig != 5 && dig != 7 ) return false ; n /= 10 ; } return true ; }
boolean prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
boolean isFullPrime ( int n ) { return ( checkDigits ( n ) && prime ( n ) ) ; }
void coef ( int n ) { c [ 0 ] = 1 ; for ( int i = 0 ; i < n ; c [ 0 ] = - c [ 0 ] , i ++ ) { c [ 1 + i ] = 1 ; for ( int j = i ; j > 0 ; j -- ) c [ j ] = c [ j - 1 ] - c [ j ] ; } }
boolean isPrime ( int n ) { coef ( n ) ; c [ 0 ] ++ ; c [ n ] -- ; int i = n ; while ( ( i -- ) > 0 && c [ i ] % n == 0 ) ; return i < 0 ; }
int motzkin ( int n ) { if ( n == 0 n == 1 ) return 1 ; return ( ( 2 * n + 1 ) * motzkin ( n - 1 ) + ( 3 * n - 3 ) * motzkin ( n - 2 ) ) / ( n + 2 ) ; }
double sumOfSeries ( int n ) { return ( 0.666 ) * ( 1 - 1 / Math . pow ( 10 , n ) ) ; }
boolean check ( int n ) { int l = countDigit ( n ) ; int dup = n ; int sum = 0 ; while ( dup > 0 ) { sum += pow ( dup % 10 , l ) ; dup /= 10 ; } return ( n == sum ) ; }
String getResult ( String st ) { int sum = 0 ; int length = st . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { sum = sum + ( int ) Math . pow ( st . charAt ( i ) - '0' , length ) ; } int number = Integer . parseInt ( st ) ; if ( number == sum ) return "yes" ; else return "no" ; }
int solve ( int low , int high , int T ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; }
int nthSHN ( int n , int dp [ ] ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; }
int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
void leyland ( int n ) { List < Integer > ans = new ArrayList < Integer > ( ) ; for ( int x = 2 ; x <= n ; x ++ ) { for ( int y = 2 ; y <= x ; y ++ ) { int temp = ( int ) Math . pow ( x , y ) + ( int ) Math . pow ( y , x ) ; ans . add ( temp ) ; } } Collections . sort ( ans ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans . get ( i ) + " " ) ; }
Boolean isOverflow ( long a , long b ) { if ( a == 0 b == 0 ) return false ; long result = a * b ; if ( a == result / b ) return false ; else return true ; }
int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; while ( k -- > 0 ) { sum += cur ; cur += 2 ; } return sum ; }
int oddSum ( int n ) { return ( n * n ) ; }
double mphTOkmph ( double mph ) { return mph * 1.60934 ; }
int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; }
int trace ( int n , int m ) { int an = 1 + ( n - 1 ) * ( m + 1 ) ; int rowmajorSum = sn ( n , an ) ; an = 1 + ( n - 1 ) * ( n + 1 ) ; int colmajorSum = sn ( n , an ) ; return rowmajorSum + colmajorSum ; }
void precompute ( int prefix [ ] , int suffix [ ] ) { boolean prime [ ] = new boolean [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { prime [ i ] = true ; } for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( prime [ i ] ) { for ( int j = i * i ; j < MAX ; j += i ) { prime [ j ] = false ; } } } prefix [ 1 ] = 1 ; suffix [ MAX - 1 ] = ( int ) 1e9 + 7 ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] ) { prefix [ i ] = i ; } else { prefix [ i ] = prefix [ i - 1 ] ; } } for ( int i = MAX - 2 ; i > 1 ; i -- ) { if ( prime [ i ] ) { suffix [ i ] = i ; } else { suffix [ i ] = suffix [ i + 1 ] ; } } }
int query ( int prefix [ ] , int suffix [ ] , int L , int R ) { if ( prefix [ R ] < L suffix [ L ] > R ) { return 0 ; } else { return prefix [ R ] - suffix [ L ] ; } }
void printXYZ ( int n ) { if ( n == 1 ) System . out . println ( - 1 ) ; else { System . out . println ( "x is " + n ) ; System . out . println ( "y is " + ( n + 1 ) ) ; System . out . println ( "z is " + ( n * ( n + 1 ) ) ) ; } }
int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
int term ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; }
int term ( int n ) { return n * ( n + 1 ) / 2 ; }
float avgOfFirstN ( int n ) { return ( float ) ( 1 + n ) / 2 ; }
int summation ( int n ) { int sum ; sum = ( int ) ( Math . pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; return sum ; }
double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; for ( i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; }
int term ( int n ) { int x = ( ( ( 1 ) + ( int ) Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; return x ; }
boolean isMember ( int a , int d , int x ) { if ( d == 0 ) return ( x == a ) ; return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; }
double compute ( int a , int b ) { double AM , GM , HM ; AM = ( a + b ) / 2 ; GM = Math . sqrt ( a * b ) ; HM = ( GM * GM ) / AM ; return HM ; }
int countDigits ( int n ) { int c = 0 ; do { c ++ ; n = n / 10 ; } while ( n != 0 ) ; return c ; }
boolean isDeserium ( int x ) { int temp = x ; int p = countDigits ( x ) ; int sum = 0 ; while ( x != 0 ) { int digit = x % 10 ; sum += Math . pow ( digit , p ) ; p -- ; x = x / 10 ; } return ( sum == temp ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int sameRemainder ( int a , int b , int c ) { int a1 = ( b - a ) , b1 = ( c - b ) , c1 = ( c - a ) ; return gcd ( a1 , gcd ( b1 , c1 ) ) ; }
float mean ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; float mean = ( float ) sum / n ; return mean ; }
float sd ( int arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) ; float sdd = sum / n ; return sdd ; }
boolean checkDivisibility ( String num ) { int length = num . length ( ) ; if ( length == 1 && num . charAt ( 0 ) == '0' ) return true ; if ( length % 3 == 1 ) { num += "00" ; length += 2 ; } else if ( length % 3 == 2 ) { num += "0" ; length += 1 ; } int sum = 0 , p = 1 ; for ( int i = length - 1 ; i >= 0 ; i -- ) { int group = 0 ; group += num . charAt ( i -- ) - '0' ; group += ( num . charAt ( i -- ) - '0' ) * 10 ; group += ( num . charAt ( i ) - '0' ) * 100 ; sum = sum + group * p ; p *= ( - 1 ) ; } sum = Math . abs ( sum ) ; return ( sum % 13 == 0 ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findNumber ( int arr [ ] , int n ) { int ans = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) ans = gcd ( ans , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == ans ) return ans ; return - 1 ; }
void modularEquation ( int a , int b ) { if ( a < b ) { System . out . println ( "No solution possible " ) ; return ; } if ( a == b ) { System . out . println ( "Infinite Solution possible " ) ; return ; } int count = 0 ; int n = a - b ; int y = ( int ) Math . sqrt ( a - b ) ; for ( int i = 1 ; i <= y ; ++ i ) { if ( n % i == 0 ) { if ( n / i > b ) count ++ ; if ( i > b ) count ++ ; } } if ( y * y == n && y > b ) count -- ; System . out . println ( count ) ; }
void SieveofEratosthenes ( int n ) { boolean [ ] visited = new boolean [ n * n + 2 ] ; for ( int i = 2 ; i <= n + 1 ; i ++ ) if ( ! visited [ i ] ) { for ( int j = i * i ; j <= n + 1 ; j += i ) visited [ j ] = true ; primes . add ( i ) ; } }
boolean specialPrimeNumbers ( int n , int k ) { SieveofEratosthenes ( n ) ; int count = 0 ; for ( int i = 0 ; i < primes . size ( ) ; i ++ ) { for ( int j = 0 ; j < i - 1 ; j ++ ) { if ( primes . get ( j ) + primes . get ( j + 1 ) + 1 == primes . get ( i ) ) { count ++ ; break ; } } if ( count == k ) return true ; } return false ; }
int minOp ( int num ) { int rem ; int count = 0 ; while ( num > 0 ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num /= 10 ; } return count ; }
int findSubarraySum ( int arr [ ] , int n , int sum ) { HashMap < Integer , Integer > prevSum = new HashMap < > ( ) ; int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == sum ) res ++ ; if ( prevSum . containsKey ( currsum - sum ) ) res += prevSum . get ( currsum - sum ) ; Integer count = prevSum . get ( currsum ) ; if ( count == null ) prevSum . put ( currsum , 1 ) ; else prevSum . put ( currsum , count + 1 ) ; } return res ; }
int minimumMoves ( int A [ ] , int N ) { int one = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] == 1 ) one ++ ; if ( one != 0 ) return N - one ; int minimum = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { int g = A [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { g = __gcd ( A [ j ] , g ) ; if ( g == 1 ) { minimum = Math . min ( minimum , j - i ) ; break ; } } } if ( minimum == Integer . MAX_VALUE ) return - 1 ; else return N + minimum - 1 ; }
boolean sumSquare ( int n ) { HashMap < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i * i <= n ; ++ i ) { s . put ( i * i , 1 ) ; if ( s . containsKey ( n - i * i ) ) { System . out . println ( ( int ) Math . sqrt ( n - i * i ) + "^2 + " + i + "^2" ) ; return true ; } } return false ; }
int countPairs ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; }
boolean judgeSquareSum ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int count = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { count ++ ; n /= i ; } if ( i % 4 == 3 && count % 2 != 0 ) return false ; } } return n % 4 != 3 ; }
void preCompute ( int mat [ ] [ ] , int prefixCnt [ ] [ ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 0 ) { prefixCnt [ i ] [ j ] = 1 ; } else { prefixCnt [ i ] [ j ] = 0 ; } } } for ( int i = 0 ; i < M ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) prefixCnt [ i ] [ j ] += prefixCnt [ i ] [ j - 1 ] ; for ( int i = 1 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) prefixCnt [ i ] [ j ] += prefixCnt [ i - 1 ] [ j ] ; }
int countQuery ( int prefixCnt [ ] [ ] , int pi , int pj , int qi , int qj ) { int cnt = prefixCnt [ qi ] [ qj ] ; if ( pi > 0 ) cnt -= prefixCnt [ pi - 1 ] [ qj ] ; if ( pj > 0 ) cnt -= prefixCnt [ qi ] [ pj - 1 ] ; if ( pi > 0 && pj > 0 ) cnt += prefixCnt [ pi - 1 ] [ pj - 1 ] ; return cnt ; }
void series ( int n , int d ) { if ( d == 0 ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( "0 " ) ; System . out . println ( ) ; return ; } if ( n % 2 == 0 ) { for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( Math . pow ( - 1 , i ) * d + " " ) ; } System . out . println ( ) ; } else { float m = n ; float r = ( m / ( m - 1 ) ) ; float g = ( float ) ( d * ( float ) ( Math . sqrt ( r ) ) ) ; System . out . print ( "0 " ) ; for ( int i = 1 ; i < n ; i ++ ) { System . out . print ( Math . pow ( - 1 , i ) * g + " " ) ; } System . out . println ( ) ; } }
int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { String str = String . valueOf ( i ) ; countr += str . split ( "1" , - 1 ) . length - 1 ; } return countr ; }
int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) { int divider = i * 10 ; countr += ( n / divider ) * i + Math . min ( Math . max ( n % divider - i + 1 , 0 ) , i ) ; } return countr ; }
int countPairs ( int arr [ ] , int n ) { int result = 0 ; HashSet < Integer > Hash = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Hash . add ( arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; if ( Hash . contains ( product ) ) { result ++ ; } } } return result ; }
boolean check ( long a , long b ) { long c = 0 ; while ( a != 0 ) { c = c + a % 10 ; a = a / 10 ; } return ( c == b ) ; }
long root ( long n ) { boolean found = false ; long mx = ( long ) 1E18 ; for ( long i = 0 ; i <= 90 ; i ++ ) { long s = i * i + 4 * n ; long sq = ( long ) Math . sqrt ( s ) ; if ( sq * sq == s && check ( ( sq - i ) / 2 , i ) ) { found = true ; mx = Math . min ( mx , ( sq - i ) / 2 ) ; } } if ( found ) return mx ; else return - 1 ; }
int factors ( int n ) { HashMap < Integer , Integer > prime = new HashMap < Integer , Integer > ( ) ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; ++ i ) { while ( n % i == 0 ) { if ( prime . containsKey ( i ) ) { prime . put ( i , prime . get ( i ) + 1 ) ; } else { prime . put ( i , 1 ) ; } n = n / i ; } } if ( n > 2 ) { if ( prime . containsKey ( n ) ) { prime . put ( n , prime . get ( n ) + 1 ) ; } else { prime . put ( n , 1 ) ; } } int ans1 = 1 , ans2 = 1 ; for ( Map . Entry < Integer , Integer > it : prime . entrySet ( ) ) { ans1 *= 2 * it . getValue ( ) + 1 ; ans2 *= it . getValue ( ) + 1 ; } return ans1 - ans2 ; }
int gcdOfFactorial ( int m , int n ) { int min = m < n ? m : n ; return factorial ( min ) ; }
boolean asPowerSum ( int w , int m ) { while ( m > 0 ) { if ( ( m - 1 ) % w == 0 ) m = ( m - 1 ) / w ; else if ( ( m + 1 ) % w == 0 ) m = ( m + 1 ) / w ; else if ( m % w == 0 ) m = m / w ; else } return ( m == 0 ) ; }
int dotProduct ( int vect_A [ ] , int vect_B [ ] ) { int product = 0 ; for ( int i = 0 ; i < n ; i ++ ) product = product + vect_A [ i ] * vect_B [ i ] ; return product ; }
void crossProduct ( int vect_A [ ] , int vect_B [ ] , int cross_P [ ] ) { cross_P [ 0 ] = vect_A [ 1 ] * vect_B [ 2 ] - vect_A [ 2 ] * vect_B [ 1 ] ; cross_P [ 1 ] = vect_A [ 2 ] * vect_B [ 0 ] - vect_A [ 0 ] * vect_B [ 2 ] ; cross_P [ 2 ] = vect_A [ 0 ] * vect_B [ 1 ] - vect_A [ 1 ] * vect_B [ 0 ] ; }
int calculate ( int n , int power ) { int sum = 0 ; int bp = ( int ) Math . pow ( n , power ) ; while ( bp != 0 ) { int d = bp % 10 ; sum += d ; bp /= 10 ; } return sum ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( 1 * res * x ) % p ; x = ( 1 * x * x ) % p ; } return res ; }
int countEvenWays ( int n ) { return power ( 2 , n / 2 - 1 , MOD ) ; }
void cal_factor ( ) { factor [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( int i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( int i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( int j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } }
int no_of_representations ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = a [ i ] ; int flag = 0 ; while ( factor [ temp ] != 1 ) { flag = - 1 ; count ++ ; temp = temp / factor [ temp ] ; } count += flag ; } return count ; }
boolean coprime ( int a , int b ) { return ( __gcd ( a , b ) == 1 ) ; }
void pairSum ( int n ) { int mid = n / 2 ; for ( int i = mid ; i >= 1 ; i -- ) { if ( coprime ( i , n - i ) == true ) { System . out . print ( i + " " + ( n - i ) ) ; break ; } } }
int coutSubSeq ( int A [ ] , int N , int M ) { int sum = 0 ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; }
int countSubSeq ( int A [ ] , int N , int M ) { int ans = 0 ; int h [ ] = new int [ M ] ; Arrays . fill ( h , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = A [ i ] % M ; h [ A [ i ] ] ++ ; } for ( int i = 0 ; i < M ; i ++ ) { for ( int j = i ; j < M ; j ++ ) { int rem = ( M - ( i + j ) % M ) % M ; if ( rem < j ) continue ; if ( i == j && rem == j ) ans += h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 ; else if ( i == j ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ; else if ( i == rem ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ; else if ( rem == j ) ans += h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 ; else ans = ans + h [ i ] * h [ j ] * h [ rem ] ; } } return ans ; }
int findTerm ( int n ) { if ( n == 1 ) return n ; else { int term = 7 ; for ( int i = 2 ; i <= n ; i ++ ) term = term * 2 + ( i - 1 ) ; return term ; } }
int findNumber ( int n ) { n -- ; int i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; }
int findNumber ( int n ) { int x = ( int ) Math . floor ( ( - 1 + Math . sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ; int base = ( x * ( x + 1 ) ) / 2 + 1 ; return n - base + 1 ; }
float correlationCoefficient ( int X [ ] , int Y [ ] , int n ) { int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; int squareSum_X = 0 , squareSum_Y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / ( float ) ( Math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) ; return corr ; }
void result ( long n , long k , long t ) { if ( t <= k ) System . out . println ( t ) ; else if ( t <= n ) System . out . println ( k ) ; else { long temp = t - n ; temp = k - temp ; System . out . println ( temp ) ; } }
float weightedMean ( int X [ ] , int W [ ] , int n ) { int sum = 0 , numWeight = 0 ; for ( int i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( float ) ( numWeight ) / sum ; }
int weightedMean ( int n ) { return ( 2 * n + 1 ) / 3 ; }
int sumOfDigits ( int a ) { int sum = 0 ; while ( a != 0 ) { sum += a % 10 ; a /= 10 ; } return sum ; }
int findMax ( int x ) { int b = 1 , ans = x ; while ( x != 0 ) { int cur = ( x - 1 ) * b + ( b - 1 ) ; if ( sumOfDigits ( cur ) > sumOfDigits ( ans ) || ( sumOfDigits ( cur ) == sumOfDigits ( ans ) && cur > ans ) ) ans = cur ; x /= 10 ; b *= 10 ; } return ans ; }
int series ( int n ) { return ( 8 * n * n ) + 1 ; }
double gcd ( double a , double b ) { if ( a < b ) return gcd ( b , a ) ; if ( Math . abs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - Math . floor ( a / b ) * b ) ) ; }
float harmonicMean ( float arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) 1 / arr [ i ] ; return ( float ) n / sum ; }
float harmonicMean ( int arr [ ] , int freq [ ] , int n ) { float sum = 0 , frequency_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( float ) freq [ i ] / arr [ i ] ; frequency_sum = frequency_sum + freq [ i ] ; } return ( frequency_sum / sum ) ; }
void calculate ( int a [ ] , int b [ ] , int n , int m ) { int mul = 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = ( int ) Math . floor ( a [ i ] / mul ) ; System . out . print ( x + " " ) ; } }
void modBigNumber ( String num , long m ) { Vector < Integer > vec = new Vector < > ( ) ; long mod = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { int digit = num . charAt ( i ) - '0' ; mod = mod * 10 + digit ; int quo = ( int ) ( mod / m ) ; vec . add ( vec . size ( ) , quo ) ; mod = mod % m ; } System . out . print ( "Remainder:"   +   mod   +   "" ) ; System . out . print ( "Quotient : " ) ; boolean zeroflag = false ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) { if ( vec . get ( i ) == 0 && zeroflag == false ) { continue ; } zeroflag = true ; System . out . print ( vec . get ( i ) ) ; } return ; }
int findPowerOfP ( int n , int p ) { int count = 0 ; int r = p ; while ( r <= n ) { count += ( n / r ) ; r = r * p ; } return count ; }
Vector < pair > primeFactorsofK ( int k ) { Vector < pair > ans = new Vector < pair > ( ) ; for ( int i = 2 ; k != 1 ; i ++ ) { if ( k % i == 0 ) { int count = 0 ; while ( k % i == 0 ) { k = k / i ; count ++ ; } ans . add ( new pair ( i , count ) ) ; } } return ans ; }
int largestPowerOfK ( int n , int k ) { Vector < pair > vec = new Vector < pair > ( ) ; vec = primeFactorsofK ( k ) ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) ans = Math . min ( ans , findPowerOfP ( n , vec . get ( i ) . first ) / vec . get ( i ) . second ) ; return ans ; }
int calculate_sum ( int a , int N ) { int m = N / a ; int sum = m * ( m + 1 ) / 2 ; int ans = a * sum ; return ans ; }
void fourDistinctFactors ( ) { boolean [ ] primeAll = new boolean [ N + 1 ] ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( primeAll [ p ] == false ) { for ( int i = p * 2 ; i <= N ; i += p ) primeAll [ i ] = true ; } } ArrayList < Integer > prime = new ArrayList < Integer > ( ) ; for ( int p = 2 ; p <= N ; p ++ ) if ( ! primeAll [ p ] ) prime . add ( p ) ; for ( int i = 0 ; i < prime . size ( ) ; ++ i ) { int p = prime . get ( i ) ; if ( 1L * p * p * p <= N ) fourDiv [ p * p * p ] = true ; for ( int j = i + 1 ; j < prime . size ( ) ; ++ j ) { int q = prime . get ( j ) ; if ( 1L * p * q > N ) break ; fourDiv [ p * q ] = true ; } } }
int horner ( int poly [ ] , int n , int x ) { int result = poly [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; }
int findSign ( int poly [ ] , int n , int x ) { int result = horner ( poly , n , x ) ; if ( result > 0 ) return 1 ; else if ( result < 0 ) return - 1 ; return 0 ; }
double ucal ( double u , int n ) { if ( n == 0 ) return 1 ; double temp = u ; for ( int i = 1 ; i <= n / 2 ; i ++ ) temp = temp * ( u - i ) ; for ( int i = 1 ; i < n / 2 ; i ++ ) temp = temp * ( u + i ) ; return temp ; }
int digitLCM ( int n ) { int lcm = 1 ; while ( n > 0 ) { lcm = ( n % 10 * lcm ) / lcm_fun ( n % 10 , lcm ) ; if ( lcm == 0 ) return 0 ; n = n / 10 ; } return lcm ; }
void gcdMax ( int [ ] a , int [ ] b , int n , int N ) { int [ ] cnt = new int [ N ] ; int [ ] first = new int [ N ] ; int [ ] second = new int [ N ] ; for ( int i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) first [ i ] = Math . max ( first [ i ] , j ) ; cnt = new int [ N ] ; for ( int i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) second [ i ] = Math . max ( second [ i ] , j ) ; int x ; for ( x = N - 1 ; x >= 0 ; x -- ) if ( first [ x ] > 0 && second [ x ] > 0 ) break ; System . out . println ( first [ x ] + " " + second [ x ] ) ; }
int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
long ispowerof2 ( long num ) { if ( ( num & ( num - 1 ) ) == 0 ) return 1 ; return 0 ; }
int median ( int a [ ] , int l , int r ) { int n = r - l + 1 ; n = ( n + 1 ) / 2 - 1 ; return n + l ; }
int IQR ( int [ ] a , int n ) { Arrays . sort ( a ) ; int mid_index = median ( a , 0 , n ) ; int Q1 = a [ median ( a , 0 , mid_index ) ] ; int Q3 = a [ mid_index + median ( a , mid_index + 1 , n ) ] ; return ( Q3 - Q1 ) ; }
void printPierpont ( int n ) { boolean [ ] arr = new boolean [ n + 1 ] ; int two = 1 , three = 1 ; while ( two + 1 < n ) { arr [ two ] = true ; while ( two * three + 1 < n ) { arr [ three ] = true ; arr [ two * three ] = true ; three *= 3 ; } three = 1 ; two *= 2 ; } ArrayList < Integer > v = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] ) v . add ( i + 1 ) ; arr = new boolean [ n + 1 ] ; for ( int p = 2 ; p * p < n ; p ++ ) { if ( arr [ p ] == false ) for ( int i = p * 2 ; i < n ; i += p ) arr [ i ] = true ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) if ( ! arr [ v . get ( i ) ] ) System . out . print ( v . get ( i ) + " " ) ; }
boolean isWoodall ( int x ) { if ( x % 2 == 0 ) return false ; if ( x == 1 ) return true ; int p = 0 ; while ( x % 2 == 0 ) { x = x / 2 ; p ++ ; if ( p == x ) return true ; } return false ; }
void print_result ( int a [ ] , int n , int k , int m ) { Vector < Vector < Integer > > v = new Vector < Vector < Integer > > ( m ) ; for ( int i = 0 ; i < m ; i ++ ) v . add ( new Vector < Integer > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int rem = a [ i ] % m ; v . get ( rem ) . add ( a [ i ] ) ; if ( v . get ( rem ) . size ( ) == k ) { for ( int j = 0 ; j < k ; j ++ ) System . out . print ( v . get ( rem ) . get ( j ) + " " ) ; return ; } } System . out . print ( "-1" ) ; }
int smallestX ( int n ) { int [ ] temp = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) temp [ i ] = 0 ; if ( n == 0 ) return - 1 ; int count = 0 , x = 0 ; for ( x = 1 ; count < 10 ; x ++ ) { int y = x * n ; while ( y > 0 ) { if ( temp [ y % 10 ] == 0 ) { count ++ ; temp [ y % 10 ] = 1 ; } y /= 10 ; } } return x - 1 ; }
int digSum ( int n ) { int sum = 0 , rem = 0 ; while ( n > 0 ) { rem = n % 10 ; sum += rem ; n /= 10 ; } return sum ; }
int findX ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( i + digSum ( i ) == n ) return i ; return - 1 ; }
boolean isDivisible ( int x , int y ) { if ( y == 1 ) return true ; int z = gcd ( x , y ) ; if ( z == 1 ) return false ; return isDivisible ( x , y / z ) ; }
boolean isDigitPresent ( int m , boolean hash [ ] ) { while ( m > 0 ) { if ( hash [ m % 10 ] ) return true ; m = m / 10 ; } return false ; }
int countDivisibles ( int n ) { boolean hash [ ] = new boolean [ 10 ] ; int m = n ; while ( m > 0 ) { hash [ m % 10 ] = true ; m = m / 10 ; } int ans = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( isDigitPresent ( i , hash ) ) ans ++ ; if ( n / i != i ) { if ( isDigitPresent ( n / i , hash ) ) ans ++ ; } } } return ans ; }
void printTwoDivisibleParts ( String num , int f , int s ) { int N = num . length ( ) ; int [ ] prefixReminder = new int [ N + 1 ] ; int [ ] suffixReminder = new int [ N + 1 ] ; suffixReminder [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) suffixReminder [ i ] = ( suffixReminder [ i - 1 ] * 10 + ( num . charAt ( i - 1 ) - '0' ) ) % f ; prefixReminder [ N ] = 0 ; int base = 1 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { prefixReminder [ i ] = ( prefixReminder [ i + 1 ] + ( num . charAt ( i ) - '0' ) * base ) % s ; base = ( base * 10 ) % s ; } for ( int i = 0 ; i < N ; i ++ ) { if ( prefixReminder [ i ] == 0 && suffixReminder [ i ] == 0 && num . charAt ( i ) != '0' ) { System . out . println ( num . substring ( 0 , i ) + " " + num . substring ( i ) ) ; return ; } } System . out . println ( "Not Possible" ) ; }
int sum ( int n ) { int rem = 0 ; int sum_of_digits = 0 ; while ( n > 0 ) { rem = n % 10 ; sum_of_digits += rem ; n = n / 10 ; } return sum_of_digits ; }
int count ( int n ) { int c = 0 ; for ( int i = n - 97 ; i <= n ; i ++ ) { int a = sum ( i ) ; int b = sum ( a ) ; if ( ( i + a + b ) == n ) { c += 1 ; } } return c ; }
boolean isPowerOfK ( int n , int k ) { boolean oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; }
int isOctal ( int n ) { while ( n > 0 ) { if ( ( n % 10 ) >= 8 ) return 0 ; else n = n / 10 ; } return 1 ; }
void printFactorialNums ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { System . out . print ( fact + " " ) ; fact = fact * x ; x ++ ; } }
float Cel_To_Fah ( float n ) { return ( ( n * 9.0f / 5.0f ) + 32.0f ) ; }
boolean printPairs ( int arr [ ] , int n , int k ) { boolean isPairFound = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { System . out . print ( "(" + arr [ i ] + ", " + arr [ j ] + ")" + " " ) ; isPairFound = true ; } } } return isPairFound ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
void print_sequence ( int n , int k ) { int b = n / ( k * ( k + 1 ) / 2 ) ; if ( b == 0 ) { System . out . println ( "-1" ) ; } else { int r = 1 ; for ( int x = 1 ; x * x <= n ; x ++ ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; if ( n / x <= b && n / x > r ) r = n / x ; } for ( int i = 1 ; i < k ; i ++ ) System . out . print ( r * i + " " ) ; int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ; System . out . println ( res ) ; } }
int countCompositions ( int n ) { return 1 << ( n - 1 ) ; }
int computeLastDigit ( long A , long B ) { int variable = 1 ; return 1 ; else if  ( ( B - A ) >= 5 )  return 0 ; else  { for ( long i = A + 1 ; i <= B ; i ++ ) variable = ( int ) ( variable * ( i % 10 ) ) % 10 ; return variable % 10 ; } }
long findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
int findMin ( int a [ ] , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . log ( a [ i ] ) ; int x = ( int ) Math . exp ( sum / n ) ; return x + 1 ; }
int countdigits ( int N ) { int count = 0 ; while ( N > 0 ) { count ++ ; N = N / 10 ; } return count ; }
float sumOfAP ( float a , float d , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + a ; a = a + d ; } return sum ; }
float sumOfAP ( float a , float d , float n ) { float sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; }
boolean printPairs ( int arr [ ] , int n , int k ) { HashMap < Integer , Boolean > occ = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) occ . put ( arr [ i ] , true ) ; boolean isPairFound = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( occ . get ( k ) && k < arr [ i ] ) { System . out . print ( "(" + k + ", " + arr [ i ] + ") " ) ; isPairFound = true ; } if ( arr [ i ] >= k ) { Vector < Integer > v = findDivisors ( arr [ i ] - k ) ; for ( int j = 0 ; j < v . size ( ) ; j ++ ) { if ( arr [ i ] % v . get ( j ) == k && arr [ i ] != v . get ( j ) && occ . get ( v . get ( j ) ) ) { System . out . print ( "(" + arr [ i ] + ", " + v . get ( j ) + ") " ) ; isPairFound = true ; } } v . clear ( ) ; } } return isPairFound ; }
int sumOfSeries ( int n ) { int x ; if ( n % 2 == 0 ) x = ( n / 2 ) * ( n + 1 ) ; else x = ( ( n + 1 ) / 2 ) * n ; return x * x ; }
int findValue ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) ans = Math . max ( ans , Math . abs ( arr [ i ] - arr [ j ] ) + Math . abs ( i - j ) ) ; return ans ; }
int findValue ( int arr [ ] , int n ) { int a [ ] = new int [ n ] ; int b [ ] = new int [ n ] ; int tmp ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( arr [ i ] + i ) ; b [ i ] = ( arr [ i ] - i ) ; } int x = a [ 0 ] , y = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) x = a [ i ] ; if ( a [ i ] < y ) y = a [ i ] ; } int ans1 = ( x - y ) ; x = b [ 0 ] ; y = b [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( b [ i ] > x ) x = b [ i ] ; if ( b [ i ] < y ) y = b [ i ] ; } int ans2 = ( x - y ) ; return Math . max ( ans1 , ans2 ) ; }
int countsubarray ( int array [ ] , int n , int k ) { int count = 0 ; int i , j , mul ; for ( i = 0 ; i < n ; i ++ ) { if ( array [ i ] < k ) count ++ ; mul = array [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { mul = mul * array [ j ] ; if ( mul < k ) count ++ ; else break ; } } return count ; }
long multiplyFactors ( int n ) { long prod = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; }
long power ( long x , long y ) { long res = 1 ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % M ; y = ( y >> 1 ) % M ; x = ( x * x ) % M ; } return res ; }
int countFactors ( int n ) { int count = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) count ++ ; else count += 2 ; } } return count ; }
long multiplyFactors ( int n ) { int numFactor = countFactors ( n ) ; long product = power ( n , numFactor / 2 ) ; if ( numFactor % 2 == 1 ) product = ( product * ( int ) Math . sqrt ( n ) ) % M ; return product ; }
void printTrib ( int n ) { int dp [ ] = new int [ n ] ; dp [ 0 ] = dp [ 1 ] = 0 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i < n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( dp [ i ] + " " ) ; }
void power ( int T [ ] [ ] , int n ) { if ( n == 0 n == 1 ) return ; int M [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; power ( T , n / 2 ) ; multiply ( T , T ) ; if ( n % 2 != 0 ) multiply ( T , M ) ; }
int tribonacci ( int n ) { int T [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; if ( n == 0 n == 1 ) return 0 ; else power ( T , n - 2 ) ; return T [ 0 ] [ 0 ] ; }
char getMaxOccuringChar ( String str ) { int count [ ] = new int [ ASCII_SIZE ] ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) count [ str . charAt ( i ) ] ++ ; int max = - 1 ; char result = ' ' ; for ( int i = 0 ; i < len ; i ++ ) { if ( max < count [ str . charAt ( i ) ] ) { max = count [ str . charAt ( i ) ] ; result = str . charAt ( i ) ; } } return result ; }
int counDivisors ( int X ) { int count = 0 ; for ( int i = 1 ; i <= X ; ++ i ) { if ( X % i == 0 ) { count ++ ; } } return count ; }
int countDivisorsMult ( int arr [ ] , int n ) { int mul = 1 ; for ( int i = 0 ; i < n ; ++ i ) mul *= arr [ i ] ; return counDivisors ( mul ) ; }
void SieveOfEratosthenes ( int largest , ArrayList < Integer > prime ) { boolean [ ] isPrime = new boolean [ largest + 1 ] ; Arrays . fill ( isPrime , true ) ; for ( int p = 2 ; p * p <= largest ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= largest ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= largest ; p ++ ) if ( isPrime [ p ] ) prime . add ( p ) ; }
long countDivisorsMult ( int [ ] arr , int n ) { int largest = 0 ; for ( int a : arr ) { largest = Math . max ( largest , a ) ; } ArrayList < Integer > prime = new ArrayList < Integer > ( ) ; SieveOfEratosthenes ( largest , prime ) ; Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < prime . size ( ) ; j ++ ) { while ( arr [ i ] > 1 && arr [ i ] % prime . get ( j ) == 0 ) { arr [ i ] /= prime . get ( j ) ; if ( mp . containsKey ( prime . get ( j ) ) ) { mp . put ( prime . get ( j ) , mp . get ( prime . get ( j ) ) + 1 ) ; } else { mp . put ( prime . get ( j ) , 1 ) ; } } } if ( arr [ i ] != 1 ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } } long res = 1 ; for ( int it : mp . keySet ( ) ) res *= ( mp . get ( it ) + 1L ) ; return res ; }
void generatePrimeFactors ( ) { factor [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( int i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( int i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( int j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } }
int calculateNoOFactors ( int n ) { if ( n == 1 ) return 1 ; int ans = 1 ; int dup = factor [ n ] ; int c = 1 ; int j = n / factor [ n ] ; while ( j != 1 ) { if ( factor [ j ] == dup ) c += 1 ; else { dup = factor [ j ] ; ans = ans * ( c + 1 ) ; c = 1 ; } j = j / factor [ j ] ; } ans = ans * ( c + 1 ) ; return ans ; }
void digit_product_Sum ( int N ) { int a [ ] = new int [ N + 1 ] ; int product = 1 ; a [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { product = a [ i - 1 ] / 10 ; if ( product == 0 ) product = 1 ; else product = a [ i - 1 ] % 10 ; int val = a [ i - 1 ] / 10 ; if ( val == 0 ) val = a [ i - 1 ] ; a [ i ] = a [ i - 1 ] + ( val * product ) ; } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( a [ i ] + " " ) ; }
float geometricMean ( int arr [ ] , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product = product * arr [ i ] ; float gm = ( float ) Math . pow ( product , ( float ) 1 / n ) ; return gm ; }
float geometricMean ( int [ ] arr , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) Math . log ( arr [ i ] ) ; sum = sum / n ; return ( float ) Math . exp ( sum ) ; }
long smallestNumber ( int n ) { if ( n >= 0 && n <= 9 ) { return n ; } Stack < Integer > digits = new Stack < > ( ) ; for ( int i = 9 ; i >= 2 && n > 1 ; i -- ) { while ( n % i == 0 ) { digits . push ( i ) ; n = n / i ; } } if ( n != 1 ) { return - 1 ; } long k = 0 ; while ( ! digits . empty ( ) ) { k = k * 10 + digits . peek ( ) ; digits . pop ( ) ; } return k ; }
boolean isMagic ( int n ) { int sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return ( sum == 1 ) ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
boolean checkCircular ( int N ) { int count = 0 , temp = N ; while ( temp > 0 ) { count ++ ; temp /= 10 ; } int num = N ; while ( isPrime ( num ) ) { int rem = num % 10 ; int div = num / 10 ; num = ( int ) ( ( Math . pow ( 10 , count - 1 ) ) * rem ) + div ; if ( num == N ) return true ; } return false ; }
boolean productOfSingelDgt ( int n ) { if ( n >= 0 && n <= 9 ) return true ; int [ ] prime = { 2 , 3 , 5 , 7 } ; for ( int i = 0 ; i < SIZE && n > 1 ; i ++ ) while ( n % prime [ i ] == 0 ) n = n / prime [ i ] ; return ( n == 1 ) ; }
void printSequence ( int n ) { int a = 1 ; int ans = 2 ; int N = 1000000007 ; for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( ans + " " ) ; ans = ( ( a % N ) * ( ans % N ) ) % N ; a = ans ; ans = ( ans + 1 ) % N ; } }
int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
int findSum ( int n ) { return n * ( n + 1 ) / 2 ; }
int findSum ( int n ) { if ( n % 2 == 0 ) return ( n / 2 ) * ( n + 1 ) ; else return ( ( n + 1 ) / 2 ) * n ; }
int count ( int x , int y ) { Map < Integer , Integer > m = new HashMap < > ( ) ; while ( x % y != 0 ) { x = x % y ; ans ++ ; if ( m . containsKey ( x ) ) return - 1 ; m . put ( x , 1 ) ; x = x * 10 ; } return ans ; }
void solve ( int n ) { double a = n / 2 ; if ( n % 2 != 0 ) { System . out . println ( ( Math . ceil ( a ) - 1 ) + " " + ( Math . floor ( a ) + 1 ) ) ; } else { if ( ( int ) ( a ) % 2 == 0 ) { System . out . println ( ( Math . ceil ( a ) - 1 ) + " " + ( Math . floor ( a ) + 1 ) ) ; } else { System . out . println ( ( Math . ceil ( a ) - 2 ) + " " + ( Math . floor ( a ) + 2 ) ) ; } } }
int divCount ( int n ) { boolean hash [ ] = new boolean [ n + 1 ] ; Arrays . fill ( hash , true ) ; for ( int p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( int i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; int total = 1 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { int count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = n / p ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }
int maxPrimefactorNum ( int N ) { int [ ] arr = new int [ N + 1 ] ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( arr [ i ] == 0 ) for ( int j = 2 * i ; j <= N ; j += i ) arr [ j ] ++ ; arr [ i ] = 1 ; } return getMax ( arr ) ; }
int maxPrimefactorNum ( int N ) { if ( N < 2 ) return 0 ; boolean [ ] arr = new boolean [ N + 1 ] ; int prod = 1 , res = 0 ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == false ) { for ( int i = p * 2 ; i <= N ; i += p ) arr [ i ] = true ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; }
int arraySum ( int arr [ ] , int n ) { int x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; }
int countDigits ( int a , int b ) { int count = 0 ; int p = Math . abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }
int countDigits ( int a , int b ) { if ( a == 0 b == 0 ) return 1 ; return ( int ) Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ; }
int area_fun ( int side ) { int area = side * side ; return area ; }
boolean isPalindrome ( int n ) { bool isPalindrome  ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; } public static void main  ( String args [ ] ) { if ( isPalindrome ( 1001 ) ) System . out . println ( "Yes, it is Palindrome" ) ; else System . out . println ( "No, not Palindrome" ) ; } }
int lastPosition ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; }
int maxSum ( int n ) { if ( n == 1 ) return 1 ; else return ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ; }
boolean check ( int n ) { if ( n <= 0 ) return false ; return 1162261467 % n == 0 ; }
void productPuzzle ( int a [ ] , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . log10 ( a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ( int ) ( EPS + Math . pow ( 10.00 , sum - Math . log10 ( a [ i ] ) ) ) + " " ) ; }
int changeEvenBits ( int n ) { int to_subtract = 0 ; int m = 0 ; for ( int x = n ; x > 0 ; x >>= 2 ) { if ( ( x & 1 ) > 0 ) to_subtract += ( 1 << m ) ; m += 2 ; } return n - to_subtract ; }
int closestNumber ( int n , int m ) { int q = n / m ; int n1 = m * q ; int n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( Math . abs ( n - n1 ) < Math . abs ( n - n2 ) ) return n1 ; return n2 ; }
boolean checkPronic ( int x ) { for ( int i = 0 ; i <= ( int ) ( Math . sqrt ( x ) ) ; i ++ ) if ( x == i * ( i + 1 ) ) return true ; return false ; }
int countConsecutive ( int N ) { int count = 0 ; for ( int L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { double a = ( double ) ( ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ) ; if ( a - ( int ) a == 0.0 ) count ++ ; } return count ; }
int findMinSum ( int num ) { int sum = 0 ; for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
int compute_average ( int a , int b ) { return ( a + b ) / 2 ; }
int minNum ( int arr [ ] , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd += 1 ; return ( ( odd % 2 ) != 0 ) ? 1 : 2 ; }
int minNum ( int arr [ ] , int n ) { Boolean odd = false ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd = ! odd ; if ( odd ) return 1 ; return 2 ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int findPrime ( int n ) { int num = n + 1 ; while ( num > 0 ) { if ( isPrime ( num ) ) return num ; num = num + 1 ; } return 0 ; }
void sieveOfEratostheneses ( ) { isPrime [ 1 ] = true ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( ! isPrime [ i ] ) { for ( int j = 2 * i ; j < MAX ; j += i ) isPrime [ j ] = true ; } } }
int findPrime ( int n ) { int num = n + 1 ; while ( num > 0 ) { if ( ! isPrime [ num ] ) return num ; num = num + 1 ; } return 0 ; }
int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }
int pell ( int n ) { if ( n <= 2 ) return n ; int a = 1 ; int b = 2 ; int c ; for ( int i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; }
int nCr ( int n , int r ) { if ( r > n / 2 ) r = n - r ; int answer = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { answer *= ( n - r + i ) ; answer /= i ; } return answer ; }
int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = Math . max ( high , arr [ i ] ) ; int divisors [ ] = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= Math . sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++ ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ; } } } for ( int i = high ; i >= 1 ; i -- ) if ( divisors [ i ] > 1 ) return i ; return 1 ; }
int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = Math . max ( high , arr [ i ] ) ; int count [ ] = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; int counter = 0 ; for ( int i = high ; i >= 1 ; i -- ) { int j = i ; while ( j <= high ) { if ( count [ j ] > 0 ) counter += count [ j ] ; j += i ; if ( counter == 2 ) return i ; } counter = 0 ; } return 1 ; }
int count_one ( int n ) { int c_one = 0 ; while ( n != 0 ) { int rem = n % 10 ; if ( rem == 1 ) c_one = c_one + 1 ; n = n / 10 ; } return c_one ; }
int checkEvil ( int n ) { int i = 0 , bin = 0 , n_one = 0 ; while ( n != 0 ) { int r = n % 2 ; bin = bin + r * ( int ) ( Math . pow ( 10 , i ) ) ; n = n / 2 ; } n_one = count_one ( bin ) ; if ( n_one % 2 == 0 ) return 1 ; else return 0 ; }
int calculateLeaps ( int n ) { if ( n == 0 n == 1 ) { return 1 ; } else { int leaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } }
int power ( long x , long y , long p ) { long res = 1 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return ( int ) res ; }
void printLastKDigits ( int a , int b , int k ) { System . out . print ( "Last " + k + " digits of " + a + "^" + b + " = " ) ; int temp = 1 ; for ( int i = 1 ; i <= k ; i ++ ) temp *= 10 ; temp = power ( a , b , temp ) ; for ( int i = 0 ; i < k - Integer . toString ( temp ) . length ( ) ; i ++ ) System . out . print ( 0 ) ; if ( temp != 0 ) System . out . print ( temp ) ; }
int msbPos ( int n ) { int pos = 0 ; while ( n != 0 ) { pos ++ ; n = n >> 1 ; } return pos ; }
int josephify ( int n ) { int position = msbPos ( n ) ; int j = 1 << ( position - 1 ) ; n = n ^ j ; n = n << 1 ; n = n | 1 ; return n ; }
int CountPairs ( int n ) { int k = n ; int imin = 1 ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / imin ; } return ans ; }
int reverseDigits ( int num ) { int rev = 0 ; while ( num > 0 ) { rev = rev * 10 + num % 10 ; num /= 10 ; } return rev ; }
int square ( int num ) { return ( num * num ) ; }
boolean checkAdamNumber ( int num ) { int a = square ( num ) ; int b = square ( reverseDigits ( num ) ) ; if ( a == reverseDigits ( b ) ) return true ; return false ; }
int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }
int totalDigits ( int n ) { int number_of_digits = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) number_of_digits += ( n - i + 1 ) ; return number_of_digits ; }
int findSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int sum = arr [ 0 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) { sum = sum + arr [ i + 1 ] ; } } return sum ; }
void decToBinary ( int n ) { int [ ] binaryNum = new int [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( binaryNum [ j ] ) ; }
int decimalToBinary ( int N ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; double c = Math . pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } return B_Number ; }
int stirlingFactorial ( double n ) { if ( n == 1 ) return 1 ; double z ; z = Math . sqrt ( 2 * 3.14 * n ) * Math . pow ( ( n / e ) , n ) ; return ( int ) ( z ) ; }
int countXorPair ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; }
int countXorPair ( int arr [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return odd * even ; }
long count_of_ways ( long n ) { long count = 0 ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
boolean isPalindrome ( final long number ) { return number == reverse ( number ) ; }
long reverse ( long number ) { long reverse = 0 ; while ( number > 0 ) { long remainder = number % 10 ; reverse = ( reverse * 10 ) + remainder ; number = number / 10 ; } return reverse ; }
int sub ( int a , int b ) { return a + flipSign ( b ) ; }
int mul ( int a , int b ) { if ( a < b ) return mul ( b , a ) ; int sum = 0 ; for ( int i = Math . abs ( b ) ; i > 0 ; i -- ) sum += a ; if ( b < 0 ) sum = flipSign ( sum ) ; return sum ; }
int division ( int a , int b ) { if ( b == 0 ) throw new ArithmeticException ( ) ; int quotient = 0 , dividend ; int divisor = flipSign ( Math . abs ( b ) ) ; for ( dividend = Math . abs ( a ) ; dividend >= Math . abs ( divisor ) ; dividend += divisor ) quotient ++ ; if ( areDifferentSign ( a , b ) ) quotient = flipSign ( quotient ) ; return quotient ; }
int numOfCombinations ( int arr [ ] , int N ) { int C [ ] = { 0 , 0 , 0 } ; for ( int i = 0 ; i < N ; ++ i ) ++ C [ arr [ i ] % 3 ] ; return C [ 1 ] * C [ 2 ] + C [ 0 ] * ( C [ 0 ] - 1 ) / 2 + C [ 0 ] * ( C [ 0 ] - 1 ) * ( C [ 0 ] - 2 ) / 6 + C [ 1 ] * ( C [ 1 ] - 1 ) * ( C [ 1 ] - 2 ) / 6 + C [ 2 ] * ( C [ 2 ] - 1 ) * ( C [ 2 ] - 2 ) / 6 + C [ 0 ] * C [ 1 ] * C [ 2 ] ; }
int powmod ( int x , int y , int p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) ( Math . sqrt ( m ) + 1 ) ; int [ ] value = new int [ m ] ; for ( int i = n ; i >= 1 ; -- i ) value [ powmod ( a , i * n , m ) ] = i ; for ( int j = 0 ; j < n ; ++ j ) { int cur = ( powmod ( a , j , m ) * b ) % m ; if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - j ; if ( ans < m ) return ans ; } } return - 1 ; }
int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) ( Math . sqrt ( m ) + 1 ) ; int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * a ) % m ; int [ ] value = new int [ m ] ; for ( int i = 1 , cur = an ; i <= n ; ++ i ) { if ( value [ cur ] == 0 ) value [ cur ] = i ; cur = ( cur * an ) % m ; } for ( int i = 0 , cur = b ; i <= n ; ++ i ) { if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return - 1 ; }
int findRectNum ( int n ) { return n * ( n + 1 ) ; }
double f ( double x ) { return 1 * pow ( x , 3 ) + 2 * x * x + 10 * x - 20 ; }
void Muller ( double a , double b , double c ) { int i ; double res ; for ( i = 0 ; ; ++ i ) { double f1 = f ( a ) ; double f2 = f ( b ) ; double f3 = f ( c ) ; double d1 = f1 - f3 ; double d2 = f2 - f3 ; double h1 = a - c ; double h2 = b - c ; double a0 = f3 ; double a1 = ( ( ( d2 * pow ( h1 , 2 ) ) - ( d1 * pow ( h2 , 2 ) ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; double a2 = ( ( ( d1 * h2 ) - ( d2 * h1 ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; double x = ( ( - 2 * a0 ) / ( a1 + abs ( sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; double y = ( ( - 2 * a0 ) / ( a1 - abs ( sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; if ( x >= y ) res = x + c ; else res = y + c ; double m = res * 100 ; double n = c * 100 ; m = floor ( m ) ; n = floor ( n ) ; if ( m == n ) break ; a = b ; b = c ; c = res ; if ( i > MAX_ITERATIONS ) { System . out . println ( "Root cannot be found using" + " Muller's method" ) ; break ; } } if ( i <= MAX_ITERATIONS ) System . out . println ( "The value of the root is " + res ) ; }
int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
int countPairs ( int N ) { int count = 0 ; for ( int i = 1 ; i <= Math . cbrt ( N ) ; i ++ ) { int cb = i * i * i ; int diff = N - cb ; int cbrtDiff = ( int ) Math . cbrt ( diff ) ; if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; } return count ; }
long findMinValue ( long arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { val += ( double ) ( Math . log ( ( double ) ( arr [ i ] ) ) ) ; } long left = arr [ 0 ] , right = arr [ n - 1 ] ; long ans = 0 ; while ( left <= right ) { long mid = ( left + right ) / 2 ; double temp = ( double ) n * ( double ) ( Math . log ( ( double ) ( mid ) ) ) ; if ( val < temp ) { ans = mid ; right = mid - 1 ; } else { left = mid + 1 ; } } return ans ; }
boolean isprime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) if ( x % i == 0 ) return false ; return true ; }
boolean isSumOfKprimes ( int N , int K ) { if ( N < 2 * K ) return false ; if ( K == 1 ) return isprime ( N ) ; if ( K == 2 ) { if ( N % 2 == 0 ) return true ; return isprime ( N - 2 ) ; } return true ; }
int sumOfTermsInNthRow ( int n ) { int sum = ( int ) ( n * ( 2 * pow ( n , 2 ) + 1 ) ) ; return sum ; }
void printEqualModNumbers ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int d = arr [ n - 1 ] - arr [ 0 ] ; if ( d == 0 ) { System . out . println ( "Infinite solution" ) ; return ; } Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) { v . add ( i ) ; if ( i != d / i ) v . add ( d / i ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int temp = arr [ 0 ] % v . get ( i ) ; int j ; for ( j = 1 ; j < n ; j ++ ) if ( arr [ j ] % v . get ( i ) != temp ) break ; if ( j == n ) System . out . print ( v . get ( i ) + " " ) ; } }
int firstDigit ( int x ) { while ( x >= 10 ) x = x / 10 ; return x ; }
int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; }
int FindLCM ( int a , int b ) { return ( a * b ) / new BigInteger ( a + "" ) . gcd ( new BigInteger ( b + "" ) ) . intValue ( ) ; }
int rangeDivisor ( int m , int n , int a , int b ) { int lcm = FindLCM ( a , b ) ; int a_divisor = n / a - ( m - 1 ) / a ; int b_divisor = n / b - ( m - 1 ) / b ; int common_divisor = n / lcm - ( m - 1 ) / lcm ; int ans = a_divisor + b_divisor - common_divisor ; return ans ; }
int getOccurence ( int n , int d ) { int result = 0 ; int itr = d ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && itr / 10 == d ) { result ++ ; itr ++ ; } else if ( itr / 10 == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; }
void printUnique ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { int num = i ; boolean visited [ ] = new boolean [ 10 ] ; while ( num != 0 ) { if ( visited [ num % 10 ] ) break ; visited [ num % 10 ] = true ; num = num / 10 ; } if ( num == 0 ) System . out . print ( i + " " ) ; } }
int findSumOfDigits ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) multiply ( i ) ; int sum = 0 ; int size = v . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) sum += v . get ( i ) ; return sum ; }
int findMinZero ( int p ) { int first = 1 , second = 1 , number = 2 , next = 1 ; while ( next > 0 ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }
int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int i ; for ( i = 2 ; i <= n ; i ++ ) if ( ( n % i == 0 ) && ( ( n / i ) % 2 == 1 ) ) break ; return i ; }
int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int ans = 1 ; while ( n % 2 == 0 ) { n /= 2 ; ans *= 2 ; } return ans ; }
int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { if ( N % 2 == 0 ) return 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) res ^= arr [ i ] ; return res ; }
int printKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return - 1 ; }
int div ( int x ) { int ans = 0 ; for ( int i = 1 ; i <= x ; i ++ ) if ( x % i == 0 ) ans += i ; return ans ; }
void sieve ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] == false ) allPrimes . add ( p ) ; }
int factorialDivisors ( int n ) { int result = 1 ; for ( int i = 0 ; i < allPrimes . size ( ) ; i ++ ) { int p = allPrimes . get ( i ) ; int exp = 0 ; while ( p <= n ) { exp = exp + ( n / p ) ; p = p * allPrimes . get ( i ) ; } result = result * ( ( int ) Math . pow ( allPrimes . get ( i ) , exp + 1 ) - 1 ) / ( allPrimes . get ( i ) - 1 ) ; } return result ; }
int countIterations ( int arr [ ] , int n ) { boolean oneFound = false ; int res = 0 ; for ( int i = 0 ; i < n ; ) { if ( arr [ i ] == 1 ) oneFound = true ; while ( i < n && arr [ i ] == 1 ) i ++ ; int count_zero = 0 ; while ( i < n && arr [ i ] == 0 ) { count_zero ++ ; i ++ ; } if ( oneFound == false && i == n ) return - 1 ; int curr_count ; if ( i < n && oneFound == true ) { if ( ( count_zero & 1 ) == 0 ) curr_count = count_zero / 2 ; else curr_count = ( count_zero + 1 ) / 2 ; count_zero = 0 ; } else { curr_count = count_zero ; count_zero = 0 ; } res = Math . max ( res , curr_count ) ; } return res ; }
boolean isAutomorphic ( int N ) { int sq = N * N ; while ( N > 0 ) { if ( N % 10 != sq % 10 ) return false ; N /= 10 ; sq /= 10 ; } return true ; }
void printConsecutive ( int last , int first ) { System . out . print ( first ++ ) ; for ( int x = first ; x <= last ; x ++ ) System . out . print ( " + " + x ) ; }
void findConsecutive ( int N ) { for ( int last = 1 ; last < N ; last ++ ) { for ( int first = 0 ; first < last ; first ++ ) { if ( 2 * N == ( last - first ) * ( last + first + 1 ) ) { System . out . print ( N + " = " ) ; printConsecutive ( last , first + 1 ) ; return ; } } } System . out . print ( "-1" ) ; }
void printCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { for ( int j = 1 ; j * j * j <= i ; j ++ ) { if ( j * j * j == i ) { System . out . print ( j * j * j + " " ) ; break ; } } } }
void printCubes ( int a , int b ) { int acrt = ( int ) Math . cbrt ( a ) ; int bcrt = ( int ) Math . cbrt ( b ) ; for ( int i = acrt ; i <= bcrt ; i ++ ) if ( i * i * i >= a && i * i * i <= b ) System . out . print ( i * i * i + " " ) ; }
int findCount ( int m , int n ) { int num1 = 0 ; for ( int i = 0 ; i < m ; i ++ ) num1 = ( num1 * 10 ) + 9 ; int num2 = 0 ; for ( int i = 0 ; i < ( m - 1 ) ; i ++ ) num2 = ( num2 * 10 ) + 9 ; return ( ( num1 / n ) - ( num2 / n ) ) ; }
int findNthEvenDigitNumber ( int n ) { int count = 0 ; for ( int i = 0 ; ; i ++ ) { int curr = i ; boolean isCurrEvenDigit = true ; while ( curr != 0 ) { if ( curr % 10 == 1 curr % 10 == 3 curr % 10 == 5 curr % 10 == 7 curr % 10 == 9 ) isCurrEvenDigit = false ; curr = curr / 10 ; } if ( isCurrEvenDigit == true ) count ++ ; if ( count == n ) return i ; } }
int findNthEvenDigitNumber ( int n ) { if ( n == 1 ) { return 0 ; } Vector < Integer > v = new Vector < > ( ) ; n = n - 1 ; while ( n > 0 ) { v . add ( n % 5 ) ; n = n / 5 ; } int result = 0 ; for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) { result = result * 10 ; result = result + v . get ( i ) ; } return 2 * result ; }
int fibonacci ( int n ) { int a = 0 ; int b = 1 ; int c = 0 ; if ( n <= 1 ) return n ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; }
boolean isMultipleOf10 ( int n ) { int f = fibonacci ( 30 ) ; return ( f % 10 == 0 ) ; }
boolean isMultipleOf10 ( int n ) { if ( n % 15 == 0 ) return true ; return false ; }
boolean isDivisibleBy25 ( String str ) { int n = str . length ( ) ; if ( n == 1 ) return false ; return ( ( str . charAt ( n - 1 ) - '0' == 0 && str . charAt ( n - 2 ) - '0' == 0 ) || ( ( str . charAt ( n - 2 ) - '0' ) * 10 + ( str . charAt ( n - 1 ) - '0' ) ) % 25 == 0 ) ; }
int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }
boolean isLeap ( int y ) { if ( y % 100 != 0 && y % 4 == 0 y % 400 == 0 ) return true ; return false ; }
int offsetDays ( int d , int m , int y ) { int offset = d ; if ( m - 1 == 11 ) offset += 335 ; if ( m - 1 == 10 ) offset += 304 ; if ( m - 1 == 9 ) offset += 273 ; if ( m - 1 == 8 ) offset += 243 ; if ( m - 1 == 7 ) offset += 212 ; if ( m - 1 == 6 ) offset += 181 ; if ( m - 1 == 5 ) offset += 151 ; if ( m - 1 == 4 ) offset += 120 ; if ( m - 1 == 3 ) offset += 90 ; if ( m - 1 == 2 ) offset += 59 ; if ( m - 1 == 1 ) offset += 31 ; if ( isLeap ( y ) && m > 2 ) offset += 1 ; return offset ; }
void addDays ( int d1 , int m1 , int y1 , int x ) { int offset1 = offsetDays ( d1 , m1 , y1 ) ; int remDays = isLeap ( y1 ) ? ( 366 - offset1 ) : ( 365 - offset1 ) ; int y2 , offset2 = 0 ; if ( x <= remDays ) { y2 = y1 ; offset2 = offset1 + x ; } else { x -= remDays ; y2 = y1 + 1 ; int y2days = isLeap ( y2 ) ? 366 : 365 ; while ( x >= y2days ) { x -= y2days ; y2 ++ ; y2days = isLeap ( y2 ) ? 366 : 365 ; } offset2 = x ; } revoffsetDays ( offset2 , y2 ) ; System . out . println ( "d2 = " + d2 + ", m2 = " + m2 + ", y2 = " + y2 ) ; }
int divisorSum ( int N , int K ) { int sum = 0 ; for ( int i = 2 ; i <= Math . ceil ( Math . sqrt ( N ) ) ; i ++ ) if ( N % i == 0 ) sum += ( i + N / i ) ; return sum ; }
boolean isPrime ( int n ) { if ( n == 1 n == 0 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
boolean isHyperPerfect ( int N , int K ) { int sum = divisorSum ( N , K ) ; if ( ( 1 + K * ( sum ) ) == N ) return true ; else return false ; }
void printWellOrdered ( int number , int x , int k ) { if ( k == 0 ) { System . out . print ( number + " " ) ; return ; } for ( int i = ( x + 1 ) ; i < 10 ; i ++ ) printWellOrdered ( number * 10 + i , i , k - 1 ) ; }
void generateWellOrdered ( int k ) { printWellOrdered ( 0 , 0 , k ) ; }
long moduloMultiplication ( long a , long b , long mod ) { long res = 0 ; a %= mod ; while ( b > 0 ) { if ( ( b & 1 ) > 0 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; } return res ; }
int number0f2s ( int n ) { int count = 0 ; while ( n > 0 ) { if ( n % 10 == 2 ) count ++ ; n = n / 10 ; } return count ; }
int numberOf2sinRange ( int n ) { int count = 0 ; for ( int i = 2 ; i <= n ; i ++ ) count += number0f2s ( i ) ; return count ; }
int numberOf2sinRange ( int n ) { String s = "" ; for ( int i = 0 ; i < n + 1 ; i ++ ) s += String . valueOf ( i ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '2' ) { count ++ ; } } return count ; }
int count2sinRangeAtDigit ( int number , int d ) { int powerOf10 = ( int ) Math . pow ( 10 , d ) ; int nextPowerOf10 = powerOf10 * 10 ; int right = number % powerOf10 ; int roundDown = number - number % nextPowerOf10 ; int roundup = roundDown + nextPowerOf10 ; int digit = ( number / powerOf10 ) % 10 ; if ( digit < 2 ) { return roundDown / 10 ; } if ( digit == 2 ) { return roundDown / 10 + right + 1 ; } return roundup / 10 ; }
int numberOf2sinRange ( int number ) { String convert ; convert = String . valueOf ( number ) ; String s = convert ; int len = s . length ( ) ; int count = 0 ; for ( int digit = 0 ; digit < len ; digit ++ ) { count += count2sinRangeAtDigit ( number , digit ) ; } return count ; }
boolean isDivisibleBy5 ( String str ) { int n = str . length ( ) ; return ( ( ( str . charAt ( n - 1 ) - '0' ) == 0 ) || ( ( str . charAt ( n - 1 ) - '0' ) == 5 ) ) ; }
boolean isTidy ( int num ) { int prev = 10 ; while ( num != 0 ) { int rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; }
boolean areMirror ( Node a , Node b ) { if ( a == null && b == null ) return true ; if ( a == null b == null ) return false ; return a . data == b . data && areMirror ( a . left , b . right ) && areMirror ( a . right , b . left ) ; }
void printPairs ( int arr [ ] , int n ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( arr [ i ] ) == Math . abs ( arr [ j ] ) ) v . add ( Math . abs ( arr [ i ] ) ) ; if ( v . size ( ) == 0 ) return ; Collections . sort ( v ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) System . out . print ( - v . get ( i ) + " " + v . get ( i ) ) ; }
int minToggle ( int arr [ ] , int n ) { int zero [ ] = new int [ n + 1 ] ; zero [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } int ans = n ; for ( int i = 1 ; i <= n ; ++ i ) ans = Math . min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; }
long LCM ( int arr [ ] , int n ) { int max_num = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_num < arr [ i ] ) { max_num = arr [ i ] ; } } long res = 1 ; while ( x <= max_num ) { Vector < Integer > indexes = new Vector < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] % x == 0 ) { indexes . add ( indexes . size ( ) , j ) ; } } if ( indexes . size ( ) >= 2 ) { for ( int j = 0 ; j < indexes . size ( ) ; j ++ ) { arr [ indexes . get ( j ) ] = arr [ indexes . get ( j ) ] / x ; } res = res * x ; } else { x ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { res = res * arr [ i ] ; } return res ; }
void kFactors ( int n , int k ) { ArrayList < Integer > P = new ArrayList < Integer > ( ) ; while ( n % 2 == 0 ) { P . add ( 2 ) ; n /= 2 ; } for ( int i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; P . add ( i ) ; } } if ( n > 2 ) P . add ( n ) ; if ( P . size ( ) < k ) { System . out . println ( "-1" ) ; return ; } for ( int i = 0 ; i < k - 1 ; i ++ ) System . out . print ( P . get ( i ) + ", " ) ; int product = 1 ; for ( int i = k - 1 ; i < P . size ( ) ; i ++ ) product = product * P . get ( i ) ; System . out . println ( product ) ; }
int nondecdigits ( int n ) { int x = 0 ; for ( x = n ; x >= 1 ; x -- ) { int no = x ; int prev_dig = 11 ; boolean flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no /= 10 ; } if ( flag == true ) break ; } return x ; }
void nondecdigits ( String s ) { int m = s . length ( ) ; int [ ] a = new int [ m + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) a [ i ] = ( int ) s . charAt ( i ) - ( int ) '0' ; int level = m - 1 ; for ( int i = m - 1 ; i > 0 ; i -- ) { if ( a [ i ] < a [ i - 1 ] ) { a [ i - 1 ] -- ; level = i - 1 ; } } if ( a [ 0 ] != 0 ) { for ( int i = 0 ; i <= level ; i ++ ) System . out . print ( a [ i ] ) ; for ( int i = level + 1 ; i < m ; i ++ ) System . out . print ( "9" ) ; } else { for ( int i = 1 ; i < level ; i ++ ) System . out . print ( a [ i ] ) ; for ( int i = level + 1 ; i < m ; i ++ ) System . out . print ( "9" ) ; } }
int countDivisors ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cnt ++ ; cnt = cnt + 2 ; } } return cnt ; }
boolean hasEvenNumberOfFactors ( int n ) { double root_n = Math . sqrt ( n ) ; if ( ( root_n * root_n ) == n ) return false ; return true ; }
void printStatusOfDoors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( hasEvenNumberOfFactors ( i ) ) System . out . print ( "closed" + " " ) ; else System . out . print ( "open" + " " ) ; } }
boolean validate ( long n ) { for ( int i = 0 ; i < 10 ; i ++ ) { long temp = n ; int count = 0 ; while ( temp > 0 ) { if ( temp % 10 == i ) count ++ ; if ( count > i ) return false ; temp /= 10 ; } } return true ; }
boolean check ( String str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 9 == 0 ) ; }
int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i ; j < N ; j ++ ) for ( int k = i ; k <= j ; k ++ ) res = res ^ arr [ k ] ; return res ; }
int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; }
boolean check ( String str ) { int n = str . length ( ) ; if ( ( str . charAt ( n - 1 ) - '0' ) % 2 != 0 ) return false ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 3 == 0 ) ; }
int checkPrime ( int n ) { if ( n <= 1 ) return - 1 ; if ( n <= 3 ) return 0 ; if ( n % 2 == 0 n % 3 == 0 ) return - 1 ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return - 1 ; return 0 ; }
void printPrimePoints ( int n ) { int count = countDigits ( n ) ; if ( count == 1 count == 2 ) { System . out . print ( "-1" ) ; return ; } boolean found = false ; for ( int i = 1 ; i < ( count - 1 ) ; i ++ ) { int left = n / ( ( int ) Math . pow ( 10 , count - i ) ) ; int right = n % ( ( int ) Math . pow ( 10 , count - i - 1 ) ) ; if ( checkPrime ( left ) == 0 && checkPrime ( right ) == 0 ) { System . out . print ( i + " " ) ; found = true ; } } if ( found == false ) System . out . print ( "-1" ) ; }
int countOddPrimeFactors ( int n ) { int result = 1 ; while ( n % 2 == 0 ) n /= 2 ; for ( int i = 3 ; i * i <= n ; i += 2 ) { int divCount = 0 ; while ( n % i == 0 ) { n /= i ; ++ divCount ; } result *= divCount + 1 ; } if ( n > 2 ) result *= 2 ; return result ; }
int politness ( int n ) { return countOddPrimeFactors ( n ) - 1 ; }
int politness ( int n ) { int count = 0 ; for ( int i = 2 ; i <= Math . sqrt ( 2 * n ) ; i ++ ) { int a ; if ( ( 2 * n ) % i != 0 ) continue ; a = 2 * n ; a /= i ; a -= ( i - 1 ) ; if ( a % 2 != 0 ) continue ; a /= 2 ; if ( a > 0 ) { count ++ ; } } return count ; }
int power ( int num , int n ) { if ( n == 0 ) return 1 ; else if ( n % 2 == 0 ) return power ( num , n / 2 ) * power ( num , n / 2 ) ; else return num * power ( num , n / 2 ) * power ( num , n / 2 ) ; }
int checkRecursive ( int num , int x , int k , int n ) { if ( x == 0 ) res ++ ; int r = ( int ) Math . floor ( Math . pow ( num , 1.0 / n ) ) ; for ( int i = k + 1 ; i <= r ; i ++ ) { int a = x - ( int ) Math . pow ( i , n ) ; if ( a >= 0 ) checkRecursive ( num , x - ( int ) Math . pow ( i , n ) , i , n ) ; } return res ; }
int check ( int x , int n ) { return checkRecursive ( x , x , 0 , n ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
boolean check ( String str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 3 == 0 ) ; }
int reverseNum ( int n ) { int rem , rev = 0 ; while ( n > 0 ) { rem = n % 10 ; rev = rev * 10 + rem ; n /= 10 ; } return rev ; }
boolean isPalindrom ( int num ) { return num == reverseNum ( num ) ; }
int nthPalindrome ( int n , int k ) { int num = ( int ) Math . pow ( 10 , k - 1 ) ; while ( true ) { if ( isPalindrom ( num ) ) -- n ; if ( n == 0 ) break ; ++ num ; } return num ; }
int findMax ( int n , int a [ ] , int b [ ] , int k [ ] , int m ) { int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { int lowerbound = a [ i ] ; int upperbound = b [ i ] ; for ( int j = lowerbound ; j <= upperbound ; j ++ ) arr [ j ] += k [ i ] ; } int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) res = Math . max ( res , arr [ i ] ) ; return res ; }
boolean isPerfectSquare ( int n ) { int sq = ( int ) Math . sqrt ( n ) ; return ( n == sq * sq ) ; }
int countPerfectDivisors ( int n ) { int count = 0 ; for ( int i = 1 ; i * i <= n ; ++ i ) { if ( n % i == 0 ) { if ( isPerfectSquare ( i ) ) ++ count ; if ( n / i != i && isPerfectSquare ( n / i ) ) ++ count ; } } return count ; }
void precomputeCounts ( ) { for ( int i = 1 ; i * i < MAX ; ++ i ) { for ( int j = i * i ; j < MAX ; j += i * i ) ++ perfectDiv [ j ] ; } }
int countPerfectDivisors ( int n ) { return perfectDiv [ n ] ; }
void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } }
int getDigitProduct ( int x ) { if ( x < 10 ) return x ; if ( prodDig [ x ] != 0 ) return prodDig [ x ] ; int prod = ( x % 10 ) * getDigitProduct ( x / 10 ) ; return ( prodDig [ x ] = prod ) ; }
void findSeed ( int n ) { List < Integer > res = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= n / 2 ; i ++ ) if ( i * getDigitProduct ( i ) == n ) res . add ( i ) ; if ( res . size ( ) == 0 ) { System . out . println ( "NO seed exists" ) ; return ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . get ( i ) + " " ) ; }
void sieveOfEratosthenes ( ) { for ( int i = 2 ; i * i < MAX ; ++ i ) { if ( primedivisor [ i ] == 0 ) { for ( int j = i * i ; j < MAX ; j += i ) { primedivisor [ j ] = i ; } } } for ( int i = 1 ; i < MAX ; ++ i ) { if ( primedivisor [ i ] == 0 ) { primedivisor [ i ] = i ; } } }
void findDivisors ( int arr [ ] , int n ) { for ( int i = 0 ; i < MAX ; ++ i ) { pos [ i ] = divInd [ i ] = - 1 ; dist [ i ] = INF ; } for ( int i = 0 ; i < n ; ++ i ) { int num = arr [ i ] ; while ( num > 1 ) { int div = primedivisor [ num ] ; divisors . get ( i ) . add ( div ) ; while ( num % div == 0 ) { num /= div ; } } } }
void nearestGCD ( int arr [ ] , int n ) { findDivisors ( arr , n ) ; for ( int i = 0 ; i < n ; ++ i ) { for ( int div : divisors . get ( i ) ) { if ( divInd [ div ] == - 1 ) { divInd [ div ] = i ; } else { int ind = divInd [ div ] ; divInd [ div ] = i ; if ( dist [ i ] > Math . abs ( ind - i ) ) { dist [ i ] = Math . abs ( ind - i ) ; pos [ i ] = ind + 1 ; } if ( dist [ ind ] > Math . abs ( ind - i ) ) { dist [ ind ] = Math . abs ( ind - i ) ; pos [ ind ] = i + 1 ; } } } } }
int maxPrimefactorNum ( int N ) { int arr [ ] = new int [ N + 5 ] ; Arrays . fill ( arr , 0 ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( arr [ i ] == 0 ) { for ( int j = 2 * i ; j <= N ; j += i ) { arr [ j ] ++ ; } } arr [ i ] = 1 ; } int maxval = 0 , maxint = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] > maxval ) { maxval = arr [ i ] ; maxint = i ; } } return maxint ; }
int maxPrimefactorNum ( int N ) { boolean arr [ ] = new boolean [ N + 5 ] ; for ( int i = 3 ; i * i <= N ; i += 2 ) { if ( ! arr [ i ] ) { for ( int j = i * i ; j <= N ; j += i ) { arr [ j ] = true ; } } } Vector < Integer > prime = new Vector < > ( ) ; prime . add ( prime . size ( ) , 2 ) ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( ! arr [ i ] ) { prime . add ( prime . size ( ) , i ) ; } } int i = 0 , ans = 1 ; while ( ans * prime . get ( i ) <= N && i < prime . size ( ) ) { ans *= prime . get ( i ) ; i ++ ; } return ans ; }
void sieveSundaram ( ) { boolean [ ] marked = new boolean [ MAX / 2 + 100 ] ; for ( int i = 1 ; i <= ( Math . sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ; primes . add ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . add ( 2 * i + 1 ) ; }
int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; int maxele = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; ; for ( int i = 2 ; i <= maxele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = Math . max ( ans , count ) ; } return ans ; }
void SieveOfEratosthenes ( ) { for ( int i = 2 ; i * i <= MAX ; ++ i ) { if ( prime [ i ] == 0 ) for ( int j = i * 2 ; j <= MAX ; j += i ) prime [ j ] = i ; } for ( int i = 1 ; i < MAX ; ++ i ) if ( prime [ i ] == 0 ) prime [ i ] = i ; }
int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int element = arr [ i ] ; while ( element > 1 ) { int div = prime [ element ] ; ++ countdiv [ div ] ; ans = Math . max ( ans , countdiv [ div ] ) ; while ( element % div == 0 ) element /= div ; } } return ans ; }
int countOfBinaryNumberLessThanN ( int N ) { Queue < Integer > q = new LinkedList < > ( ) ; q . add ( 1 ) ; int cnt = 0 ; int t ; while ( q . size ( ) > 0 ) { t = q . peek ( ) ; q . remove ( ) ; if ( t <= N ) { cnt ++ ; q . add ( t * 10 ) ; q . add ( t * 10 + 1 ) ; } } return cnt ; }
long SubArraySum ( int arr [ ] , int n ) { long result = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; }
int nthElement ( int a , int b , int n ) { ArrayList < Integer > seq = new ArrayList < Integer > ( n * n + 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) seq . add ( a * i ) ; Collections . sort ( seq ) ; for ( int i = 1 , k = n ; i <= n && k > 0 ; i ++ ) { if ( seq . indexOf ( b * i ) == - 1 ) { seq . add ( b * i ) ; Collections . sort ( seq ) ; k -- ; } } return seq . get ( n - 1 ) ; }
boolean findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }
int multiplicativeOrder ( int A , int N ) { if ( GCD ( A , N ) != 1 ) return - 1 ; int result = 1 ; int K = 1 ; while ( K < N ) { result = ( result * A ) % N ; if ( result == 1 ) return K ; K ++ ; } return - 1 ; }
int sumOfRange ( int a , int b ) { int i = ( a * ( a + 1 ) ) >> 1 ; int j = ( b * ( b + 1 ) ) >> 1 ; return ( i - j ) ; }
int sumofproduct ( int n ) { int sum = 0 ; int root = ( int ) Math . sqrt ( n ) ; for ( int i = 1 ; i <= root ; i ++ ) { int up = n / i ; int low = Math . max ( n / ( i + 1 ) , root ) ; sum += ( i * sumOfRange ( up , low ) ) ; sum += ( i * ( n / i ) ) ; } return sum ; }
boolean isPrime ( int n ) { if ( n <= 1 ) { return false ; } if ( n <= 3 ) { return true ; } if ( n % 2 == 0 n % 3 == 0 ) { return false ; } for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
int power ( int x , int y , int p ) { while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; }
void findPrimefactors ( HashSet < Integer > s , int n ) { while ( n % 2 == 0 ) { s . add ( 2 ) ; n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { s . add ( i ) ; n = n / i ; } } if ( n > 2 ) { s . add ( n ) ; } }
int findPrimitive ( int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; if ( isPrime ( n ) == false ) { return - 1 ; } int phi = n - 1 ; findPrimefactors ( s , phi ) ; for ( int r = 2 ; r <= phi ; r ++ ) { boolean flag = false ; for ( Integer a : s ) { if ( power ( r , phi / ( a ) , n ) == 1 ) { flag = true ; break ; } } if ( flag == false ) { return r ; } } return - 1 ; }
int kPrimeFactor ( int n , int k ) { while ( n % 2 == 0 ) { k -- ; n = n / 2 ; if ( k == 0 ) return 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( k == 1 ) return i ; k -- ; n = n / i ; } } if ( n > 2 && k == 1 ) return n ; return - 1 ; }
void sieveOfEratosthenes ( int [ ] s ) { boolean [ ] prime = new boolean [ MAX + 1 ] ; for ( int i = 2 ; i <= MAX ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= MAX ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= MAX ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } }
int kPrimeFactor ( int n , int k , int [ ] s ) { while ( n > 1 ) { if ( k == 1 ) return s [ n ] ; k -- ; n /= s [ n ] ; } return - 1 ; }
int gcd ( int a , int b ) { return b > 0 ? gcd ( b , a % b ) : a ; }
int countGCD ( int L , int R , int g ) { L = ( L + g - 1 ) / g ; R = R / g ; int ans = 0 ; for ( int i = L ; i <= R ; i ++ ) for ( int j = L ; j <= R ; j ++ ) if ( gcd ( i , j ) == 1 ) ans ++ ; return ans ; }
int minPower ( int n , int x ) { if ( x == 1 ) return n ; int ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n /= x ; } return ans ; }
int calSum ( int n ) { int a = 3 , b = 0 , c = 2 ; return 3 ; return 3 ; return 5 ; int sum = 5 ; while ( n > 2 ) { int d = a + b ; sum += d ; a = b ; b = c ; c = d ; n -- ; } return sum ; }
int sumDivisorsOfDivisors ( int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int j = 2 ; j <= Math . sqrt ( n ) ; j ++ ) { int count = 0 ; while ( n % j == 0 ) { n /= j ; count ++ ; } if ( count != 0 ) mp . put ( j , count ) ; } if ( n != 1 ) mp . put ( n , 1 ) ; int ans = 1 ; for ( HashMap . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { int pw = 1 ; int sum = 0 ; for ( int i = entry . getValue ( ) + 1 ; i >= 1 ; i -- ) { sum += ( i * pw ) ; pw = entry . getKey ( ) ; } ans *= sum ; } return ans ; }
int findMinNumber ( int n ) { int count = 0 , ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 2 == 1 ) ans *= 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 2 == 1 ) ans *= i ; } if ( n > 2 ) ans *= n ; return ans ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void findgcd ( int n , int x , int y ) { int g = gcd ( x , y ) ; for ( int i = 0 ; i < g ; i ++ ) System . out . print ( n ) ; }
int gcd ( int a , int b ) { if ( ( a % b ) == 0 ) return b ; return gcd ( b , a % b ) ; }
int firstFactorialDivisibleNumber ( int x ) { int new_x = x ; for ( i = 1 ; i < x ; i ++ ) { new_x /= gcd ( i , new_x ) ; if ( new_x == 1 ) break ; } return i ; }
int countFactorialXNotY ( int x , int y ) { return ( firstFactorialDivisibleNumber ( y ) - firstFactorialDivisibleNumber ( x ) ) ; }
int firstFactorialDivisibleNumber ( int x ) { int fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }
int gcd ( int a , int b ) { if ( ( a % b ) == 0 ) return b ; return gcd ( b , a % b ) ; }
int firstFactorialDivisibleNumber ( int x ) { int new_x = x ; for ( i = 1 ; i < x ; i ++ ) { new_x /= gcd ( i , new_x ) ; if ( new_x == 1 ) break ; } return i ; }
int fact ( int n ) { int num = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { num = num * i ; } return num ; }
boolean SieveOfEratosthenes ( int n , boolean isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) isPrime [ i ] = false ; } } return false ; }
int highestPowerof2 ( int n ) { int res = 0 ; for ( int i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; }
int highestPowerof2 ( int n ) { int p = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return ( int ) Math . pow ( 2 , p ) ; }
int getFirstDigit ( int x ) { while ( x >= 10 ) x /= 10 ; return x ; }
int getCountWithSameStartAndEndFrom1 ( int x ) { if ( x < 10 ) return x ; int tens = x / 10 ; int res = tens + 9 ; int firstDigit = getFirstDigit ( x ) ; int lastDigit = x % 10 ; if ( lastDigit < firstDigit ) res -- ; return res ; }
int getCountWithSameStartAndEnd ( int start , int end ) { return getCountWithSameStartAndEndFrom1 ( end ) - getCountWithSameStartAndEndFrom1 ( start - 1 ) ; }
void sieveOfEratosthenes ( int n , boolean isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } }
boolean rightTruPrime ( int n ) { boolean isPrime [ ] = new boolean [ n + 1 ] ; sieveOfEratosthenes ( n , isPrime ) ; while ( n != 0 ) { if ( isPrime [ n ] ) n = n / 10 ; else return false ; } return true ; }
int countMaxChoco ( int money , int price , int wrap ) { if ( money < price ) return 0 ; int choc = money / price ; choc = choc + ( choc - 1 ) / ( wrap - 1 ) ; return choc ; }
void SieveOfEratosthenes ( int n , boolean prime [ ] ) { for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } }
void mersennePrimes ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; SieveOfEratosthenes ( n , prime ) ; for ( int k = 2 ; ( ( 1 << k ) - 1 ) <= n ; k ++ ) { long num = ( 1 << k ) - 1 ; if ( prime [ ( int ) ( num ) ] ) System . out . print ( num + " " ) ; } }
int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }
int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
void sieve ( boolean prime [ ] , int n ) { for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } }
int maxDigitInPrimes ( int L , int R ) { boolean prime [ ] = new boolean [ R + 1 ] ; Arrays . fill ( prime , false ) ; sieve ( prime , R ) ; int freq [ ] = new int [ 10 ] ; int val ; for ( int i = L ; i <= R ; i ++ ) { if ( ! prime [ i ] ) { while ( p > 0 ) { freq [ p % 10 ] ++ ; p /= 10 ; } } } int max = freq [ 0 ] , ans = 0 ; for ( int j = 1 ; j < 10 ; j ++ ) { if ( max <= freq [ j ] ) { max = freq [ j ] ; ans = j ; } } return ( max != 0 ) ? ans : - 1 ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void simpleSieve ( ) { Arrays . fill ( arr , true ) ; for ( int p = 2 ; p * p < 1001 ; p ++ ) { if ( arr [ p ] ) { for ( int i = p * 2 ; i < 1001 ; i = i + p ) arr [ i ] = false ; } } }
int find_sphene ( int N ) { int [ ] arr1 = new int [ 8 ] ; int count = 0 ; int j = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( N % i == 0 && count < 8 ) { count ++ ; arr1 [ j ++ ] = i ; } } if ( count == 8 && ( arr [ arr1 [ 1 ] ] && arr [ arr1 [ 2 ] ] && arr [ arr1 [ 3 ] ] ) ) return 1 ; return 0 ; }
int maxHandshake ( int n ) { return ( n * ( n - 1 ) ) / 2 ; }
int gcd ( int i , int j ) { if ( i == j ) return i ; if ( i > j ) return gcd ( i - j , j ) ; return gcd ( i , j - i ) ; }
boolean ispossible ( int x , int y , int a , int b ) { x = Math . abs ( x ) ; y = Math . abs ( y ) ; a = Math . abs ( a ) ; b = Math . abs ( b ) ; return ( gcd ( x , y ) == gcd ( a , b ) ) ; }
int ApowBmodM ( String a , int b , int m ) { int ans = aModM ( a , m ) ; int mul = ans ; for ( int i = 1 ; i < b ; i ++ ) ans = ( ans * mul ) % m ; return ans ; }
boolean divisible ( String N , int digit ) { int ans = 0 ; for ( int i = 0 ; i < N . length ( ) ; i ++ ) { ans = ( ans * 10 + ( N . charAt ( i ) - '0' ) ) ; ans %= digit ; } return ( ans == 0 ) ; }
int allDigits ( String N ) { Boolean [ ] divide = new Boolean [ 10 ] ; Arrays . fill ( divide , Boolean . FALSE ) ; for ( int digit = 2 ; digit <= 9 ; digit ++ ) { if ( divisible ( N , digit ) ) divide [ digit ] = true ; } int result = 0 ; for ( int i = 0 ; i < N . length ( ) ; i ++ ) { if ( divide [ N . charAt ( i ) - '0' ] == true ) result ++ ; } return result ; }
int countNums ( int n , int x , int y ) { boolean [ ] arr = new boolean [ n + 1 ] ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; int result = 0 ; for ( int i = Math . min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }
int reverse ( int x ) { int rev = 0 ; while ( x > 0 ) { rev = ( rev * 10 ) + x % 10 ; x = x / 10 ; } return rev ; }
void printEmirp ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { int rev = reverse ( p ) ; if ( p != rev && rev <= n && prime [ rev ] ) { System . out . print ( p + " " + rev + " " ) ; prime [ rev ] = false ; } } } }
int getSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= ( Math . sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; { sum = sum + i ; sum = sum + ( n / i ) ; } } } sum = sum - n ; return sum ; }
boolean checkAbundant ( int n ) { return ( getSum ( n ) > n ) ; }
int longLenSub ( int [ ] arr , int n ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( um . containsKey ( arr [ i ] - 1 ) && len < um . get ( arr [ i ] - 1 ) ) len = um . get ( arr [ i ] - 1 ) ; if ( um . containsKey ( arr [ i ] + 1 ) && len < um . get ( arr [ i ] + 1 ) ) len = um . get ( arr [ i ] + 1 ) ; um . put ( arr [ i ] , len + 1 ) ; if ( longLen < um . get ( arr [ i ] ) ) longLen = um . get ( arr [ i ] ) ; } return longLen ; }
boolean isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= Math . sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; }
int divisorsSum ( int n ) { for ( int i = 1 ; i <= ( Math . sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { sum = sum + i ; } { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum ; }
boolean isDeficient ( int n ) { return ( divisorsSum ( n ) < ( 2 * n ) ) ; }
boolean isKeith ( int x ) { ArrayList < Integer > terms = new ArrayList < Integer > ( ) ; while ( temp > 0 ) { terms . add ( temp % 10 ) ; temp = temp / 10 ; n ++ ; } Collections . reverse ( terms ) ; int next_term = 0 , i = n ; while ( next_term < x ) { next_term = 0 ; for ( int j = 1 ; j <= n ; j ++ ) next_term += terms . get ( i - j ) ; terms . add ( next_term ) ; i ++ ; } return ( next_term == x ) ; }
int hcf ( int a , int b ) { if ( b == 0 ) return a ; return hcf ( b , a % b ) ; }
int findlcm ( int a , int b ) { if ( b == 1 ) return a ; a = ( a * b ) / hcf ( a , b ) ; b -= 1 ; return findlcm ( a , b ) ; }
boolean canBeSumofConsec ( int n ) { return ( ( ( n & ( n - 1 ) ) != 0 ) && n != 0 ) ; }
void Sieve ( ) { int n = MAX ; int nNew = ( int ) Math . sqrt ( n ) ; int [ ] marked = new int [ n / 2 + 500 ] ; for ( int i = 1 ; i <= ( nNew - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= n / 2 ; j = j + 2 * i + 1 ) marked [ j ] = 1 ; primes . add ( 2 ) ; for ( int i = 1 ; i <= n / 2 ; i ++ ) if ( marked [ i ] == 0 ) primes . add ( 2 * i + 1 ) ; }
int binarySearch ( int left , int right , int n ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( mid == 0 || mid == primes . size ( ) - 1 ) return primes . get ( mid ) ; if ( primes . get ( mid ) == n ) return primes . get ( mid - 1 ) ; if ( primes . get ( mid ) < n && primes . get ( mid + 1 ) > n ) return primes . get ( mid ) ; if ( n < primes . get ( mid ) ) return binarySearch ( left , mid - 1 , n ) ; else return binarySearch ( mid + 1 , right , n ) ; } return 0 ; }
int evenFibSum ( int limit ) { if ( limit < 2 ) return 0 ; long ef1 = 0 , ef2 = 2 ; long sum = ef1 + ef2 ; while ( ef2 <= limit ) { long ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return ( int ) sum ; }
boolean isPerfect ( int n ) { int s = ( int ) ( Math . sqrt ( n ) ) ; return ( s * s == n ) ; }
int divisorsCount ( int n ) { int count = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) count += 1 ; else count += 2 ; } } return count ; }
long evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }
void buildSegtmentTree ( int node , int a , int b ) { if ( a == b ) { segmentTree [ node ] = divisors [ a ] ; return ; } buildSegtmentTree ( 2 * node , a , ( a + b ) / 2 ) ; buildSegtmentTree ( 2 * node + 1 , ( ( a + b ) / 2 ) + 1 , b ) ; segmentTree [ node ] = Math . max ( segmentTree [ 2 * node ] , segmentTree [ 2 * node + 1 ] ) ; }
int query ( int node , int a , int b , int l , int r ) { if ( l > b a > r ) return - 1 ; if ( a >= l && b <= r ) return segmentTree [ node ] ; return Math . max ( query ( 2 * node , a , ( a + b ) / 2 , l , r ) , query ( 2 * node + 1 , ( ( a + b ) / 2 ) + 1 , b , l , r ) ) ; }
int countSteps ( int x , int y ) { if ( x % y == 0 ) return x / y ; return x / y + countSteps ( y , x % y ) ; }
void primeFactorize ( int a ) { for ( int i = 2 ; i * i <= a ; i += 2 ) { int cnt = 0 ; while ( a % i == 0 ) { cnt ++ ; a /= i ; } ma . put ( i , cnt ) ; } if ( a > 1 ) ma . put ( a , 1 ) ; }
int commDiv ( int a , int b ) { primeFactorize ( a ) ; int res = 1 ; for ( Map . Entry < Integer , Integer > m : ma . entrySet ( ) ) { int cnt = 0 ; int key = m . getKey ( ) ; int value = m . getValue ( ) ; while ( b % key == 0 ) { b /= key ; cnt ++ ; } res *= ( Math . min ( cnt , value ) + 1 ) ; } return res ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
float y ( float x ) { return 1 / ( 1 + x * x ) ; }
float trapezoidal ( float a , float b , float n ) { float h = ( b - a ) / n ; float s = y ( a ) + y ( b ) ; for ( int i = 1 ; i < n ; i ++ ) s += 2 * y ( a + i * h ) ; return ( h / 2 ) * s ; }
long spellsCount ( String num ) { int n = num . length ( ) ; long result = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; while ( i < n - 1 && num . charAt ( i + 1 ) == num . charAt ( i ) ) { count ++ ; i ++ ; } result = result * ( long ) Math . pow ( 2 , count - 1 ) ; } return result ; }
int numSquareSum ( int n ) { int squareSum = 0 ; while ( n != 0 ) { squareSum += ( n % 10 ) * ( n % 10 ) ; n /= 10 ; } return squareSum ; }
boolean isHappynumber ( int n ) { int slow , fast ; slow = fast = n ; do { slow = numSquareSum ( slow ) ; fast = numSquareSum ( numSquareSum ( fast ) ) ; } while ( slow != fast ) ; return ( slow == 1 ) ; }
int kaprekar ( int n ) { int prev = 0 ; return kaprekarRec ( n , prev ) ; }
float sqroot ( float s ) { int pSq = 0 ; int N = 0 ; for ( int i = ( int ) ( s ) ; i > 0 ; i -- ) { for ( int j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } float d = s - pSq ; float P = d / ( 2.0f * N ) ; float A = N + P ; float sqrt_of_s = A - ( ( P * P ) / ( 2.0f * A ) ) ; return sqrt_of_s ; }
int power ( int x , int a ) { int res = 1 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) res = res * x ; x = x * x ; a >>= 1 ; } return res ; }
int breakInteger ( int N ) { if ( N == 2 ) return 1 ; if ( N == 3 ) return 2 ; int maxProduct = - 1 ; switch ( N % 3 ) { case 0 : maxProduct = power ( 3 , N / 3 ) ; break ; case 1 : maxProduct = 2 * 2 * power ( 3 , ( N / 3 ) - 1 ) ; break ; case 2 : maxProduct = 2 * power ( 3 , N / 3 ) ; break ; } return maxProduct ; }
int maxProd ( int n ) { if ( n == 2 n == 3 ) return ( n - 1 ) ; int res = 1 ; while ( n > 4 ) { n -= 3 ; res *= 3 ; } return ( n * res ) ; }
int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
int countMultiples ( int n ) { return n / 3 + n / 7 - n / 21 ; }
void sieve ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . add ( p ) ; }
long factorialDivisors ( int n ) { long result = 1 ; for ( int i = 0 ; i < allPrimes . size ( ) ; i ++ ) { long p = allPrimes . get ( i ) ; long exp = 0 ; while ( p <= n ) { exp = exp + ( n / p ) ; p = p * allPrimes . get ( i ) ; } result = result * ( exp + 1 ) ; } return result ; }
int nonFibonacci ( int n ) { int prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; }
long reversDigits ( long num ) { long rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }
boolean isPalindrome ( long num ) { return ( reversDigits ( num ) == num ) ; }
int countOddSquares ( int n , int m ) { return ( int ) Math . pow ( ( double ) m , 0.5 ) - ( int ) Math . pow ( ( double ) n - 1 , 0.5 ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; int k ; for ( k = 0 ; ( ( a b ) & 1 ) == 0 ; ++ k ) { a >>= 1 ; b >>= 1 ; } while ( ( a & 1 ) == 0 ) a >>= 1 ; do { while ( ( b & 1 ) == 0 ) b >>= 1 ; if ( a > b ) { int temp = a ; a = b ; b = temp ; } b = ( b - a ) ; } while ( b != 0 ) ; return a << k ; }
int gcd ( int a , int b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; { return gcd ( a >> 1 , b ) ; return gcd ( a >> 1 , b >> 1 ) << 1 ; } if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; }
int countWindowDistinct ( int win [ ] , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int j ; for ( j = 0 ; j < i ; j ++ ) if ( win [ i ] == win [ j ] ) break ; if ( j == i ) dist_count ++ ; } return dist_count ; }
int toInt ( char x ) { return x - '0' ; }
void findNDigitNums ( int n ) { char [ ] out = new char [ n + 1 ] ; int index = 0 ; int evenSum = 0 , oddSum = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) { out [ index ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , out , index + 1 , evenSum + i , oddSum ) ; } }
void findNDigitNumsUtil ( int n , int sum , char out [ ] , int index ) { if ( index > n sum < 0 ) return ; if ( index == n ) { if ( sum == 0 ) { out [ index ] = '\0' ; System . out . print ( out ) ; System . out . print ( " " ) ; } return ; } for ( int i = 0 ; i <= 9 ; i ++ ) { out [ index ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , sum - i , out , index + 1 ) ; } }
void findNDigitNums ( int n , int sum ) { char [ ] out = new char [ n + 1 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) { out [ 0 ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , sum - i , out , 1 ) ; } }
void operation ( int n , int k ) { boolean answered = false ; if ( n < k ) { answered = true ; System . out . println ( "No" ) ; } boolean ok = factors ( n , k ) ; if ( ! ok && ! answered ) { answered = true ; System . out . println ( "No" ) ; } if ( ok && ! answered ) System . out . println ( "Yes" ) ; }
boolean isPalUtil ( int num , int dupNum ) { if ( oneDigit ( num ) ) return ( num == ( dupNum ) % 10 ) ; if ( ! isPalUtil ( num / 10 , dupNum ) ) return false ; dupNum /= 10 ; return ( num % 10 == ( dupNum ) % 10 ) ; }
boolean isPal ( int num ) { if ( num < 0 ) num = - num ; return isPalUtil ( num , dupNum ) ; }
void printPalPrimesLessThanN ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= n ; i += p ) { prime [ i ] = false ; } } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] && isPal ( p ) ) { System . out . print ( p + " " ) ; } } }
int countPrimeFactors ( int n ) { int count = 0 ; while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; }
void printKAlmostPrimes ( int k , int n ) { for ( int i = 1 , num = 2 ; i <= n ; num ++ ) { if ( countPrimeFactors ( num ) == k ) { System . out . print ( num + " " ) ; i ++ ; } } return ; }
int findPieces ( int n ) { return ( n * ( n + 1 ) ) / 2 + 1 ; }
String numToWords ( int n , String s ) { String str = "" ; if ( n > 19 ) { str += ten [ n / 10 ] + one [ n % 10 ] ; } else { str += one [ n ] ; } if ( n != 0 ) { str += s ; } return str ; }
String convertToWords ( long n ) { String out = "" ; out += numToWords ( ( int ) ( n / 10000000 ) , "crore " ) ; out += numToWords ( ( int ) ( ( n / 100000 ) % 100 ) , "lakh " ) ; out += numToWords ( ( int ) ( ( n / 1000 ) % 100 ) , "thousand " ) ; out += numToWords ( ( int ) ( ( n / 100 ) % 10 ) , "hundred " ) ; if ( n > 100 && n % 100 > 0 ) { out += "and " ; } out += numToWords ( ( int ) ( n % 100 ) , "" ) ; return out ; }
long findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 ) ; return ( long ) Math . floor ( x ) + 1 ; }
int findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += Math . log10 ( i ) ; return ( int ) ( Math . floor ( digits ) ) + 1 ; }
void findPairs ( int n ) { int cubeRoot = ( int ) Math . pow ( n , 1.0 / 3.0 ) ; int cube [ ] = new int [ cubeRoot + 1 ] ; for ( int i = 1 ; i <= cubeRoot ; i ++ ) cube [ i ] = i * i * i ; int l = 1 ; int r = cubeRoot ; while ( l < r ) { if ( cube [ l ] + cube [ r ] < n ) l ++ ; else if ( cube [ l ] + cube [ r ] > n ) r -- ; else { System . out . println ( "(" + l + ", " + r + ")" ) ; l ++ ; r -- ; } } }
int countEvenSum ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int sum = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { sum = sum + arr [ j ] ; if ( sum % 2 == 0 ) result ++ ; } } return ( result ) ; }
int countEvenSum ( int arr [ ] , int n ) { int temp [ ] = { 1 , 0 } ; int result = 0 , sum = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { sum = ( ( sum + arr [ i ] ) % 2 + 2 ) % 2 ; temp [ sum ] ++ ; } result = result + ( temp [ 0 ] * ( temp [ 0 ] - 1 ) / 2 ) ; result = result + ( temp [ 1 ] * ( temp [ 1 ] - 1 ) / 2 ) ; return ( result ) ; }
long countEvenSum ( int a [ ] , int n ) { long res = 0 ; int s = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] % 2 == 1 ) { s = n - i - 1 - s ; } else { s = s + 1 ; } res = res + s ; } return res ; }
boolean isPossible ( int a , int b , int c ) { return ( c % gcd ( a , b ) == 0 ) ; }
int gcd ( int a , int b ) { while ( b != 0 ) { int t = b ; b = a % b ; a = t ; } return a ; }
int findMinDiff ( int a , int b , int x , int y ) { int g = gcd ( a , b ) ; int diff = Math . abs ( x - y ) % g ; return Math . min ( diff , g - diff ) ; }
int calculateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = fibo [ 0 ] + fibo [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; }
void findCombinations ( int n ) { int arr [ ] = new int [ n ] ; findCombinationsUtil ( arr , 0 , n , n ) ; }
boolean isPower ( int x , int y ) { int res1 = ( int ) Math . log ( y ) / ( int ) Math . log ( x ) ; double res2 = Math . log ( y ) / Math . log ( x ) ; return ( res1 == res2 ) ; }
boolean isPerfectSquare ( int n ) { for ( int sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; }
int findCount ( int d ) { return 9 * ( ( int ) ( Math . pow ( 10 , d - 1 ) ) - ( int ) ( Math . pow ( 9 , d - 1 ) ) ) ; }
int countDyckPaths ( int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }
void printDivisors ( int n ) { Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) System . out . printf ( "%d " , i ) ; else { System . out . printf ( "%d " , i ) ; v . add ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) System . out . printf ( "%d " , v . get ( i ) ) ; }
void printDivisors ( int n ) { int i ; for ( i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) System . out . print ( i + " " ) ; } if ( i - ( n / i ) == 1 ) { i -- ; } for ( ; i >= 1 ; i -- ) { if ( n % i == 0 ) System . out . print ( n / i + " " ) ; } }
void printDivisors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) System . out . print ( i + " " ) ; }
boolean isTriangular ( int num ) { if ( num < 0 ) return false ; int sum = 0 ; for ( int n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; }
int has0 ( int x ) { while ( x != 0 ) { if ( x % 10 == 0 ) return 1 ; x /= 10 ; } return 0 ; }
int getCount ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) count += has0 ( i ) ; return count ; }
char xor_c ( char a , char b ) { return ( a == b ) ? '0' : '1' ; }
int greyConverter ( int n ) { return n ^ ( n >> 1 ) ; }
int seriesSum ( int calculated , int current , int N ) { int i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return ( gcd ( b , a % b ) ) ; }
void findSmallest ( int a , int b ) { int lcm = ( a * b ) / gcd ( a , b ) ; System . out . print ( "x = " + lcm / a + "y=" + lcm / b ) ; }
int power ( int x , int y , int p ) { while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
void squareRoot ( int n , int p ) { if ( p % 4 != 3 ) { System . out . print ( "Invalid Input" ) ; return ; } n = n % p ; int x = power ( n , ( p + 1 ) / 4 , p ) ; if ( ( x * x ) % p == n ) { System . out . print ( "Square root is " + x ) ; return ; } x = p - x ; if ( ( x * x ) % p == n ) { System . out . print ( "Square root is " + x ) ; return ; } System . out . print ( "Square root doesn't exist " ) ; }
int getSum ( int BITree [ ] , int index ) { int sum = 0 ; while ( index > 0 ) { sum += BITree [ index ] ; index -= index & ( - index ) ; } return sum ; }
void convert ( int arr [ ] , int n ) { int [ ] temp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) temp [ i ] = arr [ i ] ; Arrays . sort ( temp ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = lower_bound ( temp , 0 , n , arr [ i ] ) + 1 ; } }
int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; convert ( arr , n ) ; int [ ] BIT = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) BIT [ i ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { invcount += getSum ( BIT , arr [ i ] - 1 ) ; updateBIT ( BIT , n , arr [ i ] , 1 ) ; } return invcount ; }
int modFact ( int n , int p ) { if ( n >= p ) return 0 ; int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = ( result * i ) % p ; return result ; }
int largestPower ( int n , int p ) { int x = 0 ; while ( n > 0 ) { n /= p ; x += n ; } return x ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; s while  ( y > 0 )  { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; }
int modFact ( int n , int p ) { if ( n >= p ) { return 0 ; } int res = 1 ; boolean isPrime [ ] = new boolean [ n + 1 ] ; Arrays . fill ( isPrime , true ) ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = 2 * i ; j <= n ; j += i ) { isPrime [ j ] = false ; } } } for ( int i = 2 ; i <= n ; i ++ ) { if ( isPrime [ i ] ) { int k = largestPower ( n , i ) ; res = ( res * power ( i , k , p ) ) % p ; } } return res ; }
int modInverse ( int a , int p ) { return power ( a , p - 2 , p ) ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
boolean miillerTest ( int d , int n ) { int a = 2 + ( int ) ( Math . random ( ) % ( n - 4 ) ) ; int x = power ( a , d , n ) ; if ( x == 1 x == n - 1 ) return true ; while ( d != n - 1 ) { x = ( x * x ) % n ; d *= 2 ; if ( x == 1 ) return false ; if ( x == n - 1 ) return true ; } return false ; }
boolean isPrime ( int n , int k ) { if ( n <= 1 n == 4 ) return false ; if ( n <= 3 ) return true ; int d = n - 1 ; while ( d % 2 == 0 ) d /= 2 ; for ( int i = 0 ; i < k ; i ++ ) if ( ! miillerTest ( d , n ) ) return false ; return true ; }
int inv ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; }
int findMinX ( int num [ ] , int rem [ ] , int k ) { int prod = 1 ; for ( int i = 0 ; i < k ; i ++ ) prod *= num [ i ] ; int result = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int pp = prod / num [ i ] ; result += rem [ i ] * inv ( pp , num [ i ] ) * pp ; } return result % prod ; }
int findMinX ( int num [ ] , int rem [ ] , int k ) { while ( true ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } }
int largestFiboLessOrEqual ( int n ) { fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; int i ; for ( i = 2 ; fib [ i - 1 ] <= n ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } return ( i - 2 ) ; }
boolean isValid ( int n , int d ) { int digit = n % 10 ; int sum = digit ; if ( digit == d ) return false ; n /= 10 ; while ( n > 0 ) { digit = n % 10 ; if ( digit == d digit <= sum ) return false ; else { sum += digit ; n /= 10 ; } } return true ; }
int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; }
int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return n * ( n + 1 ) * ( 3 * m - n + 1 ) / 6 ; }
void printFibRepresntation ( int n ) { while ( n > 0 ) { int f = nearestSmallerEqFib ( n ) ; System . out . print ( f + " " ) ; n = n - f ; } }
int countWaysUtil ( int n , int parts , int nextPart ) { if ( parts == 0 && n == 0 ) return 1 ; if ( n <= 0 parts <= 0 ) return 0 ; if ( dp [ n ] [ nextPart ] [ parts ] != - 1 ) return dp [ n ] [ nextPart ] [ parts ] ; for ( int i = nextPart ; i <= n ; i ++ ) ans += countWaysUtil ( n - i , parts - 1 , i ) ; return ( dp [ n ] [ nextPart ] [ parts ] = ans ) ; }
int countWays ( int n ) { for ( int i = 0 ; i < 5001 ; i ++ ) { for ( int j = 0 ; j < 5001 ; j ++ ) { for ( int l = 0 ; l < 5 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; } } return countWaysUtil ( n , 4 , 1 ) ; }
int pairAndSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; }
long Euler_totient_function ( long n ) { long result = 1 ; for ( long i = 2 ; i * i <= n ; i ++ ) { long c = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { c ++ ; n /= i ; } } if ( c > 0 ) { long power = ( long ) Math . pow ( i , c - 1 ) ; long sm = ( long ) Math . pow ( i , c - 1 ) * ( i - 1 ) ; result *= sm ; } } if ( n > 1 ) { result *= ( n - 1 ) ; } return result ; }
int nextSparse ( int x ) { ArrayList < Integer > bin = new ArrayList < Integer > ( ) ; while ( x != 0 ) { bin . add ( x & 1 ) ; x >>= 1 ; } bin . add ( 0 ) ; int last_final = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( bin . get ( i ) == 1 && bin . get ( i - 1 ) == 1 && bin . get ( i + 1 ) != 1 ) { bin . set ( i + 1 , 1 ) ; for ( int j = i ; j >= last_final ; j -- ) bin . set ( j , 0 ) ; last_final = i + 1 ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += bin . get ( i ) * ( 1 << i ) ; return ans ; }
boolean isPower ( int n ) { double p ; if ( n <= 1 ) { return true ; } for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { p = Math . log ( n ) / Math . log ( i ) ; if ( ( Math . ceil ( p ) == Math . floor ( p ) ) && p > 1 ) { return true ; } } return false ; }
int sumBitDifferences ( int arr [ ] , int n ) { for ( int i = 0 ; i < 32 ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) count ++ ; ans += ( count * ( n - count ) * 2 ) ; } return ans ; }
void generateUtil ( int x , int arr [ ] , int curr_sum , int curr_idx ) { if ( curr_sum == x ) { printArr ( arr , curr_idx ) ; return ; } int num = 1 ; while ( num <= x - curr_sum && ( curr_idx == 0 num <= arr [ curr_idx - 1 ] ) ) { arr [ curr_idx ] = num ; generateUtil ( x , arr , curr_sum + num , curr_idx + 1 ) ; num ++ ; } }
void generate ( int x ) { int arr [ ] = new int [ x ] ; generateUtil ( x , arr , 0 , 0 ) ; }
boolean isPerfect ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
boolean check ( int num , int dig ) { for ( int base = 2 ; base <= 32 ; base ++ ) if ( checkUtil ( num , dig , base ) ) return true ; return false ; }
boolean isLucky ( int n ) { boolean arr [ ] = new boolean [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; }
int countFact ( int low , int high ) { int fact = 1 , x = 1 ; while ( fact < low ) { fact = fact * x ; x ++ ; } int res = 0 ; while ( fact <= high ) { res ++ ; fact = fact * x ; x ++ ; } return res ; }
int nthMagicNo ( int n ) { int pow = 1 , answer = 0 ; while ( n != 0 ) { pow = pow * 5 ; if ( ( int ) ( n & 1 ) == 1 ) answer += pow ; n >>= 1 ; } return answer ; }
int modInverse ( int a , int m ) { for ( int x = 1 ; x < m ; x ++ ) if ( ( ( a % m ) * ( x % m ) ) % m == 1 ) return x ; return 1 ; }
int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int phi ( int n ) { int result = 1 ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) result ++ ; return result ; }
int phi ( int n ) { float result = n ; for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / ( float ) p ) ) ; } } if ( n > 1 ) result *= ( 1.0 - ( 1.0 / ( float ) n ) ) ; return ( int ) result ; }
int getDifference ( Date dt1 , Date dt2 ) { int n1 = dt1 . y * 365 + dt1 . d ; for ( int i = 0 ; i < dt1 . m - 1 ; i ++ ) { n1 += monthDays [ i ] ; } n1 += countLeapYears ( dt1 ) ; int n2 = dt2 . y * 365 + dt2 . d ; for ( int i = 0 ; i < dt2 . m - 1 ; i ++ ) { n2 += monthDays [ i ] ; } n2 += countLeapYears ( dt2 ) ; return ( n2 - n1 ) ; }
long countOfMultiples ( long n ) { return ( n / 3 + n / 5 - n / 15 ) ; }
int getPeriod ( int n ) { int rem = 1 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ; int d = rem ; int count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; }
int calculateAddedValue ( int number ) { int result = 0 ; int decimalPlace = 1 ; if ( number == 0 ) { result += ( 5 * decimalPlace ) ; } while ( number > 0 ) { if ( number % 10 == 0 ) result += ( 5 * decimalPlace ) ; number /= 10 ; decimalPlace *= 10 ; } return result ; }
int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }
int getRemainder ( int num , int divisor ) { while ( num >= divisor ) num -= divisor ; return num ; }
int minInsertion ( String str ) { int n = str . length ( ) ; int res = 0 ; int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ str . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] % 2 == 1 ) res ++ ; } return ( res == 0 ) ? 0 : res - 1 ; }
int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
double sum ( int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 1.0 / factorial ( i ) ; return sum ; }
double sum ( int n ) { double sum = 0 ; int fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { fact *= i ; sum += 1.0 / fact ; } return sum ; }
long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { System . out . print ( square + " " ) ; square = square + odd ; odd = odd + 2 ; } }
boolean isOperand ( char c ) { return ( c >= '0' && c <= '9' ) ; }
int value ( char c ) { return ( int ) ( c - '0' ) ; }
int evaluate ( String exp ) { if ( exp . length ( ) == 0 ) return - 1 ; int res = value ( exp . charAt ( 0 ) ) ; for ( int i = 1 ; i < exp . length ( ) ; i += 2 ) { char opr = exp . charAt ( i ) , opd = exp . charAt ( i + 1 ) ; if ( isOperand ( opd ) == false ) return - 1 ; if ( opr == '+' ) res += value ( opd ) ; else if ( opr == '-' ) res -= value ( opd ) ; else if ( opr == '*' ) res *= value ( opd ) ; else if ( opr == '/' ) res /= value ( opd ) ; else return - 1 ; } return res ; }
double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }
void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; System . out . print ( f1 + " " ) ; for ( i = 1 ; i < n ; i ++ ) { System . out . print ( f2 + " " ) ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } }
int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int lcm ( int a , int b ) { return ( a / gcd ( a , b ) ) * b ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void rearrange ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] += ( arr [ arr [ i ] ] % n ) * n ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] /= n ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; System . out . println ( "" ) ; }
int maxdiff ( int arr [ ] , int n ) { Map < Integer , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) freq . put ( arr [ i ] , freq . get ( arr [ i ] ) == null ? 1 : freq . get ( arr [ i ] ) + 1 ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( freq . get ( arr [ i ] ) > freq . get ( arr [ j ] ) && arr [ i ] > arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ i ] ) - freq . get ( arr [ j ] ) ) ; else if ( freq . get ( arr [ i ] ) < freq . get ( arr [ j ] ) && arr [ i ] < arr [ j ] ) ans = Math . max ( ans , freq . get ( arr [ j ] ) - freq . get ( arr [ i ] ) ) ; } } return ans ; }
void printSequencesRecur ( int arr [ ] , int n , int k , int index ) { int i ; if ( k == 0 ) { printArray ( arr , index ) ; } if ( k > 0 ) { for ( i = 1 ; i <= n ; ++ i ) { arr [ index ] = i ; printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; } } }
void printSequences ( int n , int k ) { int arr [ ] = new int [ k ] ; printSequencesRecur ( arr , n , k , 0 ) ; return ; }
boolean isMultipleof5 ( int n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; }
boolean isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
boolean isPowerofTwo ( int n ) { if ( n == 0 ) return false ; if ( ( n & ( ~ ( n - 1 ) ) ) == n ) return true ; return false ; }
int reversDigits ( int num ) { if ( num > 0 ) { reversDigits ( num / 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; }
int countSubsequences ( int arr [ ] ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; else even ++ ; } return ( ( 1 << odd ) - 1 ) * ( 1 << even ) ; }
int findDiff ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 0 , max_count = 0 , min_count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . max ( max_count , count ) ; min_count = Math . min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }
int XorSum ( int A [ ] , int B [ ] , int N , int M ) { int ans = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( ans == - 1 ) ans = ( A [ i ] & B [ j ] ) ; else ans ^= ( A [ i ] & B [ j ] ) ; } } return ans ; }
int countbitdiff ( int xo ) { int count = 0 ; while ( xo != 0 ) { if ( xo % 2 == 1 ) { count ++ ; } xo = xo / 2 ; } return count ; }
void convertXOR ( int arr [ ] [ ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int X = arr [ i ] [ j ] ; int temp = findXOR ( X ) ; arr [ i ] [ j ] = temp ; } } printXORmatrix ( arr ) ; }
int countSet ( int N ) { int ans = 0 ; while ( N > 0 ) { ans += N & 1 ; N >>= 1 ; } return ans ; }
int countSub ( int [ ] arr , int k ) { int ans = 0 ; int setK = 0 ; for ( int i = 0 ; i < 5 ; i ++ ) { if ( countSet ( arr [ i ] ) == k ) setK += 1 ; else setK = 0 ; ans += setK ; } return ans ; }
void oddXorSubarray ( int a [ ] , int n ) { int odd = 0 ; int c_odd = 0 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 != 0 ) { odd = ( odd == 0 ) ? 1 : 0 ; } if ( odd != 0 ) { c_odd ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { result += c_odd ; if ( a [ i ] % 2 != 0 ) { c_odd = ( n - i - c_odd ) ; } } System . out . println ( result ) ; }
void countPairs ( int arr [ ] , int N , int K ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . get ( K - arr [ i ] ) != null ) cnt += mp . get ( K - arr [ i ] ) ; mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; } System . out . println ( cnt ) ; }
void uniqueLevels ( TreeNode root ) { int uniqueLevels = 0 ; Queue < TreeNode > que = new LinkedList < > ( ) ; que . add ( root ) ; while ( que . size ( ) > 0 ) { int length = que . size ( ) ; int prefix_XOR = 0 ; int prefix_OR = 0 ; boolean flag = true ; for ( int i = 0 ; i < length ; i ++ ) { TreeNode temp = que . peek ( ) ; que . remove ( ) ; prefix_OR |= temp . val ; prefix_XOR ^= temp . val ; if ( prefix_XOR != prefix_OR ) flag = false ; if ( temp . left != null ) que . add ( temp . left ) ; if ( temp . right != null ) que . add ( temp . right ) ; } if ( flag ) uniqueLevels += 1 ; } System . out . print ( uniqueLevels ) ; }
int query ( int l , int r , int [ ] pre ) { if ( l == 0 ) return pre [ r ] ; else return pre [ r ] - pre [ l - 1 ] ; }
void countInRange ( int [ ] arr , int N , ArrayList < Pair > queries , int Q ) { int [ ] pre = new int [ N ] ; pre [ 0 ] = check ( arr [ 0 ] ) ; for ( int i = 1 ; i < N ; i ++ ) { pre [ i ] = pre [ i - 1 ] + check ( arr [ i ] ) ; } int c = 0 ; int q = 0 ; while ( q < Q ) { int l = queries . get ( q ) . item1 ; int r = queries . get ( q ) . item2 ; c ++ ; q ++ ; System . out . print ( query ( l , r , pre ) + " " ) ; } }
void Bitwise_AND_sum_i ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { int [ ] frequency = new int [ 32 ] ; for ( int i = 0 ; i < N ; i ++ ) { int bit_position = 0 ; int num = arr1 [ i ] ; while ( num != 0 ) { if ( ( num & 1 ) != 0 ) { frequency [ bit_position ] += 1 ; } bit_position += 1 ; num >>= 1 ; } } for ( int i = 0 ; i < M ; i ++ ) { int num = arr2 [ i ] ; int value_at_that_bit = 1 ; int bitwise_AND_sum = 0 ; for ( int bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( ( num & 1 ) != 0 ) { bitwise_AND_sum += frequency [ bit_position ] * value_at_that_bit ; } num >>= 1 ; value_at_that_bit <<= 1 ; } System . out . print ( bitwise_AND_sum + " " ) ; } }
void Bitwise_OR_sum_i ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { int frequency [ ] = new int [ 32 ] ; Arrays . fill ( frequency , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { int bit_position = 0 ; int num = arr1 [ i ] ; while ( num != 0 ) { if ( ( num & 1 ) != 0 ) { frequency [ bit_position ] += 1 ; } bit_position += 1 ; num >>= 1 ; } } for ( int i = 0 ; i < M ; i ++ ) { int num = arr2 [ i ] ; int value_at_that_bit = 1 ; int bitwise_OR_sum = 0 ; for ( int bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( ( num & 1 ) != 0 ) { bitwise_OR_sum += N * value_at_that_bit ; } else { bitwise_OR_sum += frequency [ bit_position ] * value_at_that_bit ; } num >>= 1 ; value_at_that_bit <<= 1 ; } System . out . print ( bitwise_OR_sum + " " ) ; } return ; }
void constructArray ( int A [ ] , int N , int K ) { int B [ ] = new int [ N ] ; int totalXOR = A [ 0 ] ^ K ; for ( int i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( B [ i ] + " " ) ; } }
void countPairs ( int [ ] arr , int k , int size ) { int count = 0 , x ; for ( int i = 0 ; i < size - 1 ; i ++ ) { for ( int j = i + 1 ; j < size ; j ++ ) { x = arr [ i ] | arr [ j ] ; if ( x == k ) count ++ ; } } System . out . println ( count ) ; }
void dfs ( int node , int xorr , int k ) { visited [ node ] = 1 ; if ( node != 1 && xorr == k ) ans ++ ; for ( pair x : adj [ node ] ) { if ( visited [ x . first ] != 1 ) { int xorr1 = xorr ^ x . second ; dfs ( x . first , xorr1 , k ) ; } } }
int maxDiff ( int [ ] arr , int n ) { int SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { boolean isSingleOccurance = true ; for ( int j = i + 1 ; j <= n - 1 ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { isSingleOccurance = false ; arr [ i ] = arr [ j ] = 0 ; break ; } } if ( isSingleOccurance ) { if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ; else SubsetSum_2 += arr [ i ] ; } } return Math . abs ( SubsetSum_1 - SubsetSum_2 ) ; }
int build_num ( int bit [ ] ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) if ( bit [ i ] > 0 ) ans += ( 1 << i ) ; return ans ; }
int maximumOR ( int arr [ ] , int n , int k ) { int bit [ ] = new int [ 32 ] ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) bit [ j ] ++ ; } } int max_or = build_num ( bit ) ; for ( int i = k ; i < n ; i ++ ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i - k ] & ( 1 << j ) ) > 0 ) bit [ j ] -- ; } for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) bit [ j ] ++ ; } max_or = Math . max ( build_num ( bit ) , max_or ) ; } return max_or ; }
int build_num ( int bit [ ] , int k ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) if ( bit [ i ] == k ) ans += ( 1 << i ) ; return ans ; }
int minimumAND ( int arr [ ] , int n , int k ) { int bit [ ] = new int [ 32 ] ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) bit [ j ] ++ ; } } int min_and = build_num ( bit , k ) ; for ( int i = k ; i < n ; i ++ ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i - k ] & ( 1 << j ) ) > 0 ) bit [ j ] -- ; } for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) bit [ j ] ++ ; } min_and = Math . min ( build_num ( bit , k ) , min_and ) ; } return min_and ; }
void findMinXORSubarray ( int arr [ ] , int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_xor = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_xor ^= arr [ i ] ; int min_xor = curr_xor ; for ( int i = k ; i < n ; i ++ ) { curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; if ( curr_xor < min_xor ) { min_xor = curr_xor ; res_index = ( i - k + 1 ) ; } } System . out . println ( min_xor ) ; }
int findmax ( int arr [ ] , int n , int k ) { int trav , i ; int c = 0 , maximum = 0 ; for ( i = 0 ; i < n - k + 1 ; i ++ ) { trav = i - 1 ; c = 0 ; while ( trav >= 0 && arr [ trav ] == 1 ) { trav -- ; c ++ ; } trav = i + k ; while ( trav < n && arr [ trav ] == 1 ) { trav ++ ; c ++ ; } c += k ; if ( c > maximum ) maximum = c ; } return maximum ; }
int powerOfTwo ( int a [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( a [ i ] ) ) { mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; } else { mp . put ( a [ i ] , 1 ) ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { boolean f = false ; for ( int j = 0 ; j < 31 ; j ++ ) { int s = ( 1 << j ) - a [ i ] ; if ( mp . containsKey ( s ) && ( mp . get ( s ) > 1 || mp . get ( s ) == 1 && s != a [ i ] ) ) f = true ; } if ( f == false ) count ++ ; } return count ; }
int maxDiff ( int [ ] arr , int n ) { int result = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += Math . abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs ( arr [ n - 1 ] ) ; return result ; }
void findArray ( int n , int a , int b , int c ) { int arr [ ] = new int [ n + 1 ] ; for ( int bit = 30 ; bit >= 0 ; bit -- ) { int set = a & ( 1 << bit ) ; if ( set != 0 ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] |= set ; } else { if ( ( b & ( 1 << bit ) ) != 0 ) { arr [ 0 ] |= ( 1 << bit ) ; if ( ( c & ( 1 << bit ) ) == 0 ) { arr [ 1 ] |= ( 1 << bit ) ; } } } } int aa = Integer . MAX_VALUE , bb = 0 , cc = 0 ; for ( int i = 0 ; i < n ; i ++ ) { aa &= arr [ i ] ; bb |= arr [ i ] ; cc ^= arr [ i ] ; } if ( a == aa && b == bb && c == cc ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; } else System . out . println ( "-1" ) ; }
int countSubarray ( int [ ] arr , int K , int N ) { if ( K % 2 != 0 ) return 0 ; if ( N < K ) return 0 ; int start = 0 ; int i = 0 ; int count = 0 ; int currXor = arr [ i ++ ] ; while ( i < K ) { currXor ^= arr [ i ] ; i ++ ; } if ( currXor == 0 ) count ++ ; currXor ^= arr [ start ++ ] ; while ( i < N ) { currXor ^= arr [ i ] ; i ++ ; if ( currXor == 0 ) count ++ ; currXor ^= arr [ start ++ ] ; } return count ; }
int findLargestNumber ( int [ ] arr ) { int k = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int [ ] m = new int [ k + 1 ] ; for ( int n : arr ) ++ m [ n ] ; for ( int n = arr . length - 1 ; n > 0 ; -- n ) { if ( n == m [ n ] ) return n ; } return - 1 ; }
int maxDiff ( int arr [ ] , int n ) { HashMap < Integer , Integer > hashPositive = new HashMap < > ( ) ; HashMap < Integer , Integer > hashNegative = new HashMap < > ( ) ; int SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { if ( arr [ i ] > 0 ) { if ( hashPositive . containsKey ( arr [ i ] ) ) { hashPositive . replace ( arr [ i ] , hashPositive . get ( arr [ i ] ) + 1 ) ; } else { hashPositive . put ( arr [ i ] , 1 ) ; } } } for ( int i = 0 ; i <= n - 1 ; i ++ ) { if ( arr [ i ] > 0 && hashPositive . containsKey ( arr [ i ] ) ) { if ( hashPositive . get ( arr [ i ] ) == 1 ) { SubsetSum_1 += arr [ i ] ; } } } for ( int i = 0 ; i <= n - 1 ; i ++ ) { if ( arr [ i ] < 0 ) { if ( hashNegative . containsKey ( Math . abs ( arr [ i ] ) ) ) { hashNegative . replace ( Math . abs ( arr [ i ] ) , hashNegative . get ( Math . abs ( arr [ i ] ) ) + 1 ) ; } else { hashNegative . put ( Math . abs ( arr [ i ] ) , 1 ) ; } } } for ( int i = 0 ; i <= n - 1 ; i ++ ) { if ( arr [ i ] < 0 && hashNegative . containsKey ( Math . abs ( arr [ i ] ) ) ) { if ( hashNegative . get ( Math . abs ( arr [ i ] ) ) == 1 ) { SubsetSum_2 += arr [ i ] ; } } } return Math . abs ( SubsetSum_1 - SubsetSum_2 ) ; }
int NoCarrySum ( int N , int M ) { return N ^ M ; }
boolean CheckBits ( int N , int K ) { int check = 0 ; int count = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( ( ( 1 << i ) & N ) > 0 ) { if ( check == 0 ) { check = 1 ; } else { if ( count < K ) { return false ; } } count = 0 ; } else { count ++ ; } } return true ; }
int RecursiveFunction ( ArrayList < Integer > ref , int bit ) { if ( ref . size ( ) == 0 bit < 0 ) return 0 ; ArrayList < Integer > curr_on = new ArrayList < > ( ) ; ArrayList < Integer > curr_off = new ArrayList < > ( ) ; for ( int i = 0 ; i < ref . size ( ) ; i ++ ) { if ( ( ( ref . get ( i ) >> bit ) & 1 ) == 0 ) curr_off . add ( ref . get ( i ) ) ; else curr_on . add ( ref . get ( i ) ) ; } if ( curr_off . size ( ) == 0 ) return RecursiveFunction ( curr_on , bit - 1 ) ; if ( curr_on . size ( ) == 0 ) return RecursiveFunction ( curr_off , bit - 1 ) ; return Math . min ( RecursiveFunction ( curr_off , bit - 1 ) , RecursiveFunction ( curr_on , bit - 1 ) ) + ( 1 << bit ) ; }
int minimumFlips ( int X , int Y , int Z ) { int res = 0 ; while ( X > 0 Y > 0 Z > 0 ) { if ( ( ( X % 2 == 1 ) || ( Y % 2 == 1 ) ) && ( Z % 2 == 1 ) ) { X = X >> 1 ; Y = Y >> 1 ; Z = Z >> 1 ; continue ; } else if ( ! ( X % 2 == 1 ) && ! ( Y % 2 == 1 ) && ( Z % 2 == 1 ) ) { res ++ ; } else if ( ( X % 2 == 1 ) || ( Y % 2 == 1 ) ) { if ( ( X % 2 == 1 ) && ( Y % 2 == 1 ) && ! ( Z % 2 == 1 ) ) { res += 2 ; } else if ( ( ( X % 2 == 1 ) || ( Y % 2 == 1 ) ) && ! ( Z % 2 == 1 ) ) { res ++ ; } } X = X >> 1 ; Y = Y >> 1 ; Z = Z >> 1 ; } return res ; }
int FlipBits ( int n ) { return n -= ( n & ( - n ) ) ; }
int calculate ( Vector < Integer > section , int pos ) { if ( pos < 0 ) return 0 ; Vector < Integer > on_section = new Vector < Integer > ( ) , off_section = new Vector < Integer > ( ) ; for ( int el : section ) { if ( ( ( el >> pos ) & 1 ) == 0 ) off_section . add ( el ) ; else on_section . add ( el ) ; } if ( off_section . size ( ) == 0 ) return calculate ( on_section , pos - 1 ) ; if ( on_section . size ( ) == 0 ) return calculate ( off_section , pos - 1 ) ; return Math . min ( calculate ( off_section , pos - 1 ) , calculate ( on_section , pos - 1 ) ) + ( 1 << pos ) ; }
int minXorValue ( int a [ ] , int n ) { Vector < Integer > section = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) section . add ( a [ i ] ) ; return calculate ( section , 30 ) ; }
void SieveOfEratosthenes ( boolean [ ] prime ) { prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } }
void prime_xor ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { if ( ( i + 1 ) % k == 0 ) { ans ^= arr [ i ] ; } } } System . out . println ( ans ) ; }
int xorOfArray ( int arr [ ] , int n ) { int xor_arr = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xor_arr = xor_arr ^ arr [ i ] ; } return xor_arr ; }
void countEvenBit ( int A [ ] , int B [ ] , int n , int m ) { int i , j , cntOdd = 0 , cntEven = 0 ; for ( i = 0 ; i < n ; i ++ ) { int x = Integer . bitCount ( A [ i ] ) ; if ( x % 2 == 1 ) { cntEven ++ ; } else { cntOdd ++ ; } } int [ ] CountB = new int [ m ] ; for ( i = 0 ; i < m ; i ++ ) { int x = Integer . bitCount ( B [ i ] ) ; if ( x % 2 == 1 ) { CountB [ i ] = cntEven ; } else { CountB [ i ] = cntOdd ; } } for ( i = 0 ; i < m ; i ++ ) { System . out . print ( CountB [ i ] + " " ) ; } }
boolean isEven ( int n ) { if ( ( n ^ 1 ) == n + 1 ) return true ; else return false ; }
int bitwiseOrTillN ( int n ) { int result = 2 ; for ( int i = 4 ; i <= n ; i = i + 2 ) { result = result | i ; } return result ; }
void minRange ( int arr [ ] , int n , int k ) { int l = 0 , r = n ; int j = - 1 ; HashMap < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n ) { j ++ ; if ( j < n && hm . size ( ) < k ) hm . put ( arr [ j ] , hm . getOrDefault ( arr [ j ] , 0 ) + 1 ) ; if ( hm . size ( ) == k && ( ( r - l ) >= ( j - i ) ) ) { l = i ; r = j ; break ; } } if ( hm . size ( ) < k ) break ; while ( hm . size ( ) == k ) { if ( hm . getOrDefault ( arr [ i ] , 0 ) == 1 ) hm . remove ( arr [ i ] ) ; else hm . put ( arr [ i ] , hm . getOrDefault ( arr [ i ] , 0 ) - 1 ) ; i ++ ; if ( hm . size ( ) == k && ( r - l ) >= ( j - i ) ) { l = i ; r = j ; } } if ( hm . getOrDefault ( arr [ i ] , 0 ) == 1 ) hm . remove ( arr [ i ] ) ; else hm . put ( arr [ i ] , hm . getOrDefault ( arr [ i ] , 0 ) - 1 ) ; } if ( l == 0 && r == n ) System . out . println ( "Invalid k" ) ; else System . out . println ( l + " " + r ) ; }
int bitwiseOrTillN ( int n ) { if ( n < 2 ) return 0 ; int bitCount = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; return ( int ) Math . pow ( 2 , bitCount ) - 2 ; }
int bitwiseAndOdd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; }
int bitwiseAndOdd ( int n ) { return 1 ; }
void construct_Xor_Tree_Util ( int [ ] current , int start , int end , int x ) { if ( start == end ) { xor_tree [ x ] = current [ start ] ; return ; } int left = x * 2 + 1 ; int right = x * 2 + 2 ; int mid = start + ( end - start ) / 2 ; construct_Xor_Tree_Util ( current , start , mid , left ) ; construct_Xor_Tree_Util ( current , mid + 1 , end , right ) ; xor_tree [ x ] = ( xor_tree [ left ] ^ xor_tree [ right ] ) ; }
void genSequence ( int n , int val ) { for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int x = i ^ ( i >> 1 ) ^ val ; System . out . print ( x + " " ) ; } }
boolean check ( int arr [ ] , int n , int m , int d ) { int i = 0 ; while ( i < n && m > 0 ) { m -- ; i += d ; } return m == 0 ? true : false ; }
int maximumDistance ( int arr [ ] , int n , int m ) { int low = 1 , high = n - 1 ; int ans = 0 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; boolean flag = check ( arr , n , m , mid ) ; if ( flag ) { ans = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return ans ; }
int minTrees ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
void longest ( int a [ ] , int n , int k ) { int [ ] freq = new int [ 7 ] ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) { end = i ; start = l ; } } for ( int i = start ; i <= end ; i ++ ) System . out . print ( a [ i ] + " " ) ; }
int extraElement ( int A [ ] , int B [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; }
int maxConsecutiveOnes ( int x ) { int count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; }
int maxOnes ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int currMax = maxConsecutiveOnes ( arr [ i ] ) ; ans = Math . max ( ans , currMax ) ; } return ans ; }
int maxOR ( int L , int R ) { if ( L == R ) { return L ; } int ans = 0 ; for ( int i = MAX - 1 ; i >= 0 ; i -- ) { int p , lbit , rbit ; p = 1 << i ; if ( ( rbit == 1 ) && ( lbit == 0 ) ) { ans += ( p << 1 ) - 1 ; break ; } if ( rbit == 1 ) { ans += p ; } } return ans ; }
int findLen ( int [ ] arr , int n , int m ) { Vector < Integer > filter = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & m ) == m ) filter . add ( arr [ i ] ) ; if ( filter . size ( ) == 0 ) return 0 ; int c_and = filter . get ( 0 ) ; for ( int i = 1 ; i < filter . size ( ) ; i ++ ) c_and &= filter . get ( i ) ; if ( c_and == m ) return filter . size ( ) ; return 0 ; }
int toggleBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
int clearBit ( int n , int k ) { return ( n & ( ~ ( 1 << ( k - 1 ) ) ) ) ; }
int getMinSteps ( int K ) { return Integer . bitCount ( K ) ; }
int sum ( int a [ ] , int n ) { Map < Integer , Integer > cnt = new HashMap < Integer , Integer > ( ) ; int ans = 0 , pre_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( i * a [ i ] ) - pre_sum ; pre_sum += a [ i ] ; if ( cnt . containsKey ( a [ i ] - 1 ) ) ans -= cnt . get ( a [ i ] - 1 ) ; if ( cnt . containsKey ( a [ i ] + 1 ) ) ans += cnt . get ( a [ i ] + 1 ) ; if ( cnt . containsKey ( a [ i ] ) ) { cnt . put ( a [ i ] , cnt . get ( a [ i ] ) + 1 ) ; } else { cnt . put ( a [ i ] , 1 ) ; } } return ans ; }
int cntElements ( int arr [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; }
int xor_triplet ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j ; k < n ; k ++ ) { int xor1 = 0 , xor2 = 0 ; for ( int x = i ; x < j ; x ++ ) { xor1 ^= arr [ x ] ; } for ( int x = j ; x <= k ; x ++ ) { xor2 ^= arr [ x ] ; } if ( xor1 == xor2 ) { ans ++ ; } } } } return ans ; }
int findSubarray ( int array [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; mp . put ( 0 , 1 ) ; int answer = 0 ; int preXor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int value = 1 ; preXor ^= array [ i ] ; for ( int j = 1 ; j <= MAX ; j ++ ) { int Y = value ^ preXor ; if ( mp . containsKey ( Y ) ) { answer += mp . get ( Y ) ; } value *= 2 ; } if ( mp . containsKey ( preXor ) ) { mp . put ( preXor , mp . get ( preXor ) + 1 ) ; } else { mp . put ( preXor , 1 ) ; } } return answer ; }
int max_xor ( int arr [ ] , int n ) { int maxXor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { maxXor = Math . max ( maxXor , arr [ i ] ^ arr [ j ] ) ; } } return maxXor ; }
int CountTriplets ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int first = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { first ^= arr [ j ] ; if ( first == 0 ) ans += ( j - i ) ; } } return ans ; }
void findMajority ( int arr [ ] , int n ) { int len = 32 ; int number = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) count ++ ; } if ( count > ( n / 2 ) ) number += ( 1 << i ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == number ) count ++ ; if ( count > ( n / 2 ) ) System . out . println ( number ) ; else System . out . println ( "Majority Element Not Present" ) ; }
int countBits ( int a , int b ) { int count = 0 ; while ( a > 0 b > 0 ) { int last_bit_a = a & 1 ; int last_bit_b = b & 1 ; if ( last_bit_a != last_bit_b ) count ++ ; a = a >> 1 ; b = b >> 1 ; } return count ; }
int CountSetBits ( int n ) { if ( n == 0 ) return 0 ; if ( ( n & 1 ) == 1 ) return 1 + CountSetBits ( n >> 1 ) ; else return CountSetBits ( n >> 1 ) ; }
long calculate ( int bit_cnt ) { long res = 1 ; while ( bit_cnt -- > 0 ) { res = res * 3 ; } return res ; }
int unset_bit_count ( long n ) { int count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count ++ ; n = n >> 1 ; } return count ; }
long bit_q ( int i , int j ) { long sum = 0 ; while ( j > 0 ) { sum += bit [ j ] ; j -= ( j & ( j * - 1 ) ) ; } i -- ; while ( i > 0 ) { sum -= bit [ i ] ; i -= ( i & ( i * - 1 ) ) ; } return sum ; }
void bit_up ( int i , long diff ) { while ( i <= n ) { bit [ i ] += diff ; i += i & - i ; } }
void initialise ( ) { Ideal_pair = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { root_node [ i ] = true ; bit [ i ] = 0 ; } }
long Idealpairs ( ) { int r = - 1 ; for ( int i = 1 ; i <= n ; i ++ ) if ( root_node [ i ] ) { r = i ; break ; } dfs ( r ) ; return Ideal_pair ; }
int pairORSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; }
int solve ( int A [ ] , int B [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { { if ( Integer . bitCount ( A [ i ] & A [ j ] ) == B [ j ] ) { cnt ++ ; } } } return cnt ; }
long multiplyByFifteen ( long n ) { long prod = ( n << 3 ) ; prod += ( n << 2 ) ; prod += ( n << 1 ) ; prod += n ; return prod ; }
void balTernary ( int ter ) { int carry = 0 , base = 10 ; int i = 32 ; while ( ter > 0 ) { int rem = ter % base ; rem = rem + carry ; if ( rem == 0 ) { arr [ i -- ] = 0 ; carry = 0 ; } else if ( rem == 1 ) { arr [ i -- ] = 1 ; carry = 0 ; } else if ( rem == 2 ) { arr [ i -- ] = - 1 ; carry = 1 ; } else if ( rem == 3 ) { arr [ i -- ] = 0 ; carry = 1 ; } ter = ( int ) ( ter / base ) ; } if ( carry == 1 ) arr [ i ] = 1 ; }
boolean isDefeat ( String s1 , String s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( s1 . charAt ( i ) == '0' && s2 . charAt ( i ) == '1' ) || ( s1 . charAt ( i ) == '1' && s2 . charAt ( i ) == '0' ) ) continue ; else if ( ( s1 . charAt ( i ) == '0' && s2 . charAt ( i ) == 'Z' ) || ( s1 . charAt ( i ) == 'Z' && s2 . charAt ( i ) == '0' ) ) continue ; else { return true ; } } return false ; }
boolean check ( int a [ ] [ ] , int b [ ] [ ] ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( a [ i ] [ j ] != b [ i ] [ j ] ) { a [ i ] [ j ] ^= 1 ; a [ 0 ] [ 0 ] ^= 1 ; a [ 0 ] [ j ] ^= 1 ; a [ i ] [ 0 ] ^= 1 ; } } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( a [ i ] [ j ] != b [ i ] [ j ] ) return false ; } } return true ; }
int FindIndexKthBit ( int n , int k ) { int cnt = 0 ; int ind = 0 ; while ( n > 0 ) { if ( ( n & 1 ) != 0 ) cnt ++ ; if ( cnt == k ) return ind ; ind ++ ; n = n >> 1 ; } return - 1 ; }
boolean check ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == 1 ) return true ; return false ; }
void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void findArray ( int [ ] q , int n ) { int ans ; int [ ] arr = new int [ n ] ; for ( int k = 0 , j = 0 ; j < n / 4 ; j ++ ) { ans = q [ k ] ^ q [ k + 3 ] ; arr [ k + 1 ] = q [ k + 1 ] ^ ans ; arr [ k + 2 ] = q [ k + 2 ] ^ ans ; arr [ k ] = q [ k ] ^ ( ( arr [ k + 1 ] ) ^ ( arr [ k + 2 ] ) ) ; arr [ k + 3 ] = q [ k + 3 ] ^ ( arr [ k + 1 ] ^ arr [ k + 2 ] ) ; k += 4 ; } printArray ( arr , n ) ; }
int countX ( int n ) { String binary = Integer . toBinaryString ( n ) ; int count = 0 ; for ( int i = 0 ; i < binary . length ( ) ; i ++ ) { if ( binary . charAt ( i ) == '1' ) count ++ ; } int answer = ( int ) Math . pow ( 2 , count ) ; return answer ; }
void binToDecimal3 ( int n ) { int a [ ] = new int [ 64 ] ; int x = 0 , i ; for ( i = 0 ; n > 0 ; i ++ ) { a [ i ] = n % 2 ; n /= 2 ; } x = ( i < 3 ) ? 3 : i ; int d = 0 , p = 0 ; for ( int j = x - 3 ; j < x ; j ++ ) d += a [ j ] * Math . pow ( 2 , p ++ ) ; System . out . print ( d + " " ) ; d = 0 ; p = 0 ; for ( int k = 0 ; k < 3 ; k ++ ) d += a [ k ] * Math . pow ( 2 , p ++ ) ; System . out . print ( d ) ; }
void binToDecimal3 ( int n ) { int last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; n = n >> 3 ; while ( n > 7 ) n = n >> 1 ; int first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; System . out . println ( first_3 + " " + last_3 ) ; }
int nextPowerOf2 ( int n ) { int p = 1 ; if ( n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
int memoryUsed ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int nearest = nextPowerOf2 ( sum ) ; return nearest ; }
boolean isPowerOfTwo ( int x ) { if ( x == 0 ) return false ; if ( ( x & ( x - 1 ) ) == 0 ) return true ; else return false ; }
int countNum ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerOfTwo ( a [ i ] ) || isPowerOfTwo ( a [ i ] + 1 ) ) count ++ ; } return count ; }
boolean checkEvenParity ( int x ) { int parity = 0 ; while ( x != 0 ) { x = x & ( x - 1 ) ; parity ++ ; } if ( parity % 2 == 0 ) return true ; else return false ; }
long sumlist ( int a [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkEvenParity ( a [ i ] ) ) sum += a [ i ] ; } return sum ; }
int minDistance ( int n1 , int n2 ) { int bitCount1 = ( int ) Math . floor ( ( Math . log ( n1 ) / Math . log ( 2 ) ) ) + 1 ; int bitCount2 = ( int ) Math . floor ( ( Math . log ( n2 ) / Math . log ( 2 ) ) ) + 1 ; int bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; int maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * ( int ) Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * ( int ) Math . pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue ; if ( xorValue == 0 ) bitCountXorValue = 1 ; else { bitCountXorValue = ( int ) Math . floor ( ( Math . log ( xorValue ) / Math . log ( 2 ) ) ) + 1 ; } int disSimilarBitPosition = maxBitCount - bitCountXorValue ; int result = bitCount1 + bitCount2 - 2 * disSimilarBitPosition ; return result ; }
int findOddPair ( int A [ ] , int N ) { int oddPair = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
int countOddPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 != 1 ) ) { count ++ ; } } int evenPairCount = count * ( count - 1 ) / 2 ; int totPairs = N * ( N - 1 ) / 2 ; return totPairs - evenPairCount ; }
int findevenPair ( int [ ] A , int N ) { int i , j ; int evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] ^ A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; }
int findEvenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 != 0 ) count ++ ; } int totalPairs = ( N * ( N - 1 ) / 2 ) ; int oddEvenPairs = count * ( N - count ) ; return totalPairs - oddEvenPairs ; }
int findevenPair ( int [ ] A , int N ) { int i , j ; int evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; }
int calculate ( int X ) { int number_of_bits = 8 ; return ( ( 1 << number_of_bits ) - 1 ) ^ X ; }
int alternate ( int a , int b , int x ) { return x = a ^ b ^ x ; }
int countZeros ( int x ) { int total_bits = sizeofInt * 8 ; int res = 0 ; while ( ( x & ( 1 << ( total_bits - 1 ) ) ) == 0 ) { x = ( x << 1 ) ; res ++ ; } return res ; }
int countZeros ( int x ) { int y ; int n = 32 ; y = x >> 16 ; if ( y != 0 ) { n = n - 16 ; x = y ; } y = x >> 8 ; if ( y != 0 ) { n = n - 8 ; x = y ; } y = x >> 4 ; if ( y != 0 ) { n = n - 4 ; x = y ; } y = x >> 2 ; if ( y != 0 ) { n = n - 2 ; x = y ; } y = x >> 1 ; if ( y != 0 ) return n - 2 ; return n - x ; }
void LeadingZeros ( int x , int y ) { if ( ( x ^ y ) <= ( x & y ) ) System . out . print ( "Equal" ) ; else if ( ( x & ( ~ y ) ) > y ) System . out . print ( y ) ; else System . out . print ( x ) ; }
void subset ( int nthBit , int num , int numOfBits ) { if ( nthBit >= 0 ) { if ( ( num & ( 1 << nthBit ) ) != 0 ) { System . out . print ( numOfBits - nthBit + " " ) ; } subset ( nthBit - 1 , num , numOfBits ) ; } else return ; }
void solve ( int A , int B ) { int count = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } System . out . println ( "Number of different bits : " + count ) ; }
int countSubarrWithEqualZeroAndOne ( int arr [ ] , int n ) { Map < Integer , Integer > um = new HashMap < > ( ) ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += ( arr [ i ] == 0 ) ? - 1 : arr [ i ] ; um . put ( curr_sum , um . get ( curr_sum ) == null ? 1 : um . get ( curr_sum ) + 1 ) ; } int count = 0 ; for ( Map . Entry < Integer , Integer > itr : um . entrySet ( ) ) { if ( itr . getValue ( ) > 1 ) count += ( ( itr . getValue ( ) * ( itr . getValue ( ) - 1 ) ) / 2 ) ; } if ( um . containsKey ( 0 ) ) count += um . get ( 0 ) ; return count ; }
int setRightmostUnsetBit ( int n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; return n | ( n + 1 ) ; }
int OR ( int a [ ] , int n ) { int ans = a [ 0 ] ; int i ; for ( i = 1 ; i < n ; i ++ ) { ans |= a [ i ] ; } return ans ; }
int hammingDistance ( int n1 , int n2 ) { int x = n1 ^ n2 ; int setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; }
boolean isKthBitSet ( int n , int k ) { if ( ( n >> ( k - 1 ) ) == 1 ) return true ; return false ; }
int setKthBit ( int n , int k ) { return ( ( 1 << ( k - 1 ) ) n ) ; }
boolean allBitsAreSet ( int n ) { if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; }
boolean bitsAreInAltOrder ( int n ) { int num = n ^ ( n >> 1 ) ; return allBitsAreSet ( num ) ; }
boolean bitsAreInAltPatrnInGivenRange ( int n , int l , int r ) { int num , left_shift ; if ( isKthBitSet ( n , r ) ) { num = n ; left_shift = r ; } else { num = setKthBit ( n , ( r + 1 ) ) ; left_shift = r + 1 ; } num = num & ( ( 1 << left_shift ) - 1 ) ; num = num >> ( l - 1 ) ; return bitsAreInAltOrder ( num ) ; }
boolean findParity ( int x ) { int y = x ^ ( x >> 1 ) ; y = y ^ ( y >> 2 ) ; y = y ^ ( y >> 4 ) ; y = y ^ ( y >> 8 ) ; y = y ^ ( y >> 16 ) ; if ( ( y & 1 ) > 0 ) return true ; return false ; }
int bit ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n = n & ( n - 1 ) ; } return count ; }
int maxSumOfBits ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = bit ( arr [ i ] ) ; } int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; }
long increment ( long i ) { i = - ( ~ i ) ; return i ; }
char increment ( char i ) { int i1 = - ( ~ ( int ) ( i ) ) ; return ( char ) ( i1 ) ; }
void MakePreSum ( int [ ] arr , int [ ] presum , int n ) { presum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) presum [ i ] = presum [ i - 1 ] + arr [ i ] ; }
int lenOfLongSubarr ( int arr [ ] , int n ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( ! um . containsKey ( sum ) ) um . put ( sum , i ) ; if ( um . containsKey ( sum - 1 ) ) { if ( maxLen < ( i - um . get ( sum - 1 ) ) ) maxLen = i - um . get ( sum - 1 ) ; } } return maxLen ; }
int bit_count ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n = n & ( n - 1 ) ; } return count ; }
int maxsum ( int [ ] arr , int n ) { int [ ] bits = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { bits [ i ] = bit_count ( arr [ i ] ) ; } int [ ] sum = new int [ 32 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum [ bits [ i ] ] += arr [ i ] ; } int maximum = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { maximum = Math . max ( sum [ i ] , maximum ) ; } return maximum ; }
int findOddPair ( int A [ ] , int N ) { int i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; }
boolean allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( num == new_num ) return true ; return false ; }
boolean bitsAreComplement ( int a , int b , int l , int r ) { int xor_value = a ^ b ; return allBitsSetInTheGivenRange ( xor_value , l , r ) ; }
boolean allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return true ; return false ; }
boolean checkSame ( int n ) { int set = 0 ; int unset = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 1 ) set ++ ; else unset ++ ; n = n >> 1 ; } if ( set == unset ) return true ; else return false ; }
boolean isBalanced ( String s ) { Stack < Character > st = new Stack < Character > ( ) ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '(' ) { st . push ( s . charAt ( i ) ) ; } else if ( st . empty ( ) ) { return false ; } else { st . pop ( ) ; } } if ( ! st . empty ( ) ) { return false ; } return true ; }
boolean isBalancedSeq ( String s1 , String s2 ) { if ( isBalanced ( s1 + s2 ) ) { return true ; } return isBalanced ( s2 + s1 ) ; }
void KthCharacter ( int m , int n , int k ) { int distance = ( int ) Math . pow ( 2 , n ) ; int Block_number = k / distance ; int remaining = k % distance ; int s [ ] = new int [ 32 ] ; int x = 0 ; for ( ; m > 0 ; x ++ ) { s [ x ] = m % 2 ; m = m / 2 ; } int root = s [ x - 1 - Block_number ] ; if ( remaining == 0 ) { System . out . println ( root ) ; return ; } Boolean flip = true ; while ( remaining > 1 ) { if ( ( remaining & 1 ) > 0 ) { flip = ! flip ; } remaining = remaining >> 1 ; } if ( flip ) { System . out . println ( ( root > 0 ) ? 0 : 1 ) ; } else { System . out . println ( root ) ; } }
int MSBPosition ( long N ) { int msb_p = - 1 ; while ( N > 0 ) { N = N >> 1 ; msb_p ++ ; } return msb_p ; }
long findBitwiseOR ( long L , long R ) { long res = 0 ; int msb_p1 = MSBPosition ( L ) ; int msb_p2 = MSBPosition ( R ) ; while ( msb_p1 == msb_p2 ) { long res_val = ( 1 << msb_p1 ) ; res += res_val ; L -= res_val ; R -= res_val ; msb_p1 = MSBPosition ( L ) ; msb_p2 = MSBPosition ( R ) ; } msb_p1 = Math . max ( msb_p1 , msb_p2 ) ; for ( int i = msb_p1 ; i >= 0 ; i -- ) { long res_val = ( 1 << i ) ; res += res_val ; } return res ; }
int getInteger ( int L , int R ) { int number = 0 ; for ( int i = L ; i <= R ; i ++ ) number += Math . pow ( 2 , i ) ; return number ; }
long maxOR ( long arr [ ] , int n , int k , int x ) { long preSum [ ] = new long [ n + 1 ] ; long suffSum [ ] = new long [ n + 1 ] ; long res = 0 , pow = 1 ; for ( int i = 0 ; i < k ; i ++ ) pow *= x ; preSum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) preSum [ i + 1 ] = preSum [ i ] | arr [ i ] ; suffSum [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] ; res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = Math . max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) ; return res ; }
int findXor ( int arr [ ] , int n ) { int xoR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xoR = xoR ^ arr [ i ] ; } return xoR * 2 ; }
int turnOnK ( int n , int k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; }
void setBitwiseORk ( int n ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( i n ) == n ) { v . add ( i ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { System . out . print ( v . get ( i ) + " " ) ; } }
int smallerNumsWithSameSetBits ( int n ) { int temp = __builtin_popcount ( n ) ; int count = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( temp == __builtin_popcount ( i ) ) count ++ ; } return count ; }
int findEletobeInserted ( int A [ ] , int n , int k ) { int ans = k ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; return ans ; }
int andSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < BITS ; i ++ ) { int countSetBits = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) countSetBits ++ ; } int subset = ( 1 << countSetBits ) - 1 ; subset = ( subset * ( 1 << i ) ) ; ans += subset ; } return ans ; }
int Root ( int idx ) { int i = idx ; while ( i != id [ i ] ) { id [ i ] = id [ id [ i ] ] ; i = id [ i ] ; } return i ; }
void Union ( int a , int b ) { int i = Root ( a ) , j = Root ( b ) ; if ( i != j ) { if ( sz [ i ] >= sz [ j ] ) { id [ j ] = i ; sz [ i ] += sz [ j ] ; sz [ j ] = 0 ; } else { id [ i ] = j ; sz [ j ] += sz [ i ] ; sz [ i ] = 0 ; } } }
void UnionUtil ( Edge e [ ] , int W [ ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) { int u , v ; u = e [ i ] . u ; v = e [ i ] . v ; u -- ; v -- ; if ( W [ u ] % 2 == 0 && W [ v ] % 2 == 0 ) Union ( u , v ) ; } }
int findMax ( int n , int W [ ] ) { int maxi = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( W [ i ] % 2 == 0 ) maxi = Math . max ( maxi , sz [ i ] ) ; return maxi ; }
int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
int multiplyWith4 ( int n ) { return ( n << 2 ) ; }
boolean isEven ( int n ) { boolean isEven = true ; for ( int i = 1 ; i <= n ; i ++ ) isEven = ! isEven ; return isEven ; }
boolean isEven ( int n ) { return ( ( n / 2 ) * 2 == n ) ; }
boolean checkValidPair ( int num1 , int num2 ) { String s1 = Integer . toString ( num1 ) ; String s2 = Integer . toString ( num2 ) ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) for ( int j = 0 ; j < s2 . length ( ) ; j ++ ) if ( s1 . charAt ( i ) == s2 . charAt ( j ) ) return true ; return false ; }
int countPairs ( int [ ] arr , int n ) { int numberOfPairs = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( checkValidPair ( arr [ i ] , arr [ j ] ) ) numberOfPairs ++ ; return numberOfPairs ; }
int countSetBits ( int n ) { long count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return ( int ) count ; }
boolean isPowerOf2 ( int num ) { if ( num != 0 && ( num & ( num - 1 ) ) == 0 ) return true ; return false ; }
boolean checkSubsequence ( int [ ] arr , int n ) { if ( n == 1 ) return isPowerOf2 ( arr [ 0 ] ) ; int total = 0 ; for ( int i = 0 ; i < NUM_BITS ; i ++ ) total = total | ( 1 << i ) ; for ( int i = 0 ; i < NUM_BITS ; i ++ ) { int ans = total ; for ( int j = 0 ; j < n ; j ++ ) { int p = arr [ j ] & ( 1 << i ) ; if ( p == 0 ) ans = ans & arr [ j ] ; } if ( isPowerOf2 ( ans ) ) return true ; } return false ; }
int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; }
void constructSTUtil ( int arr [ ] , int ss , int se , int st [ ] , int si , boolean operation ) { if ( ss == se ) { st [ si ] = arr [ ss ] ; return ; } int mid = getMid ( ss , se ) ; constructSTUtil ( arr , ss , mid , st , si * 2 + 1 , ! operation ) ; constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 , ! operation ) ; if ( operation ) { st [ si ] = ( st [ 2 * si + 1 ] st [ 2 * si + 2 ] ) ; } else { st [ si ] = ( st [ 2 * si + 1 ] ^ st [ 2 * si + 2 ] ) ; } }
void constructTree ( int low , int high , int pos , int [ ] a ) { if ( low == high ) { level [ pos ] = 0 ; tree [ pos ] = a [ high ] ; return ; } int mid = ( low + high ) / 2 ; constructTree ( low , mid , 2 * pos + 1 , a ) ; constructTree ( mid + 1 , high , 2 * pos + 2 , a ) ; level [ pos ] = level [ 2 * pos + 1 ] + 1 ; if ( ( level [ pos ] & 1 ) > 0 ) tree [ pos ] = tree [ 2 * pos + 1 ] | tree [ 2 * pos + 2 ] ; else tree [ pos ] = tree [ 2 * pos + 1 ] ^ tree [ 2 * pos + 2 ] ; }
void update ( int low , int high , int pos , int index , int [ ] a ) { if ( low == high && low == index ) { tree [ pos ] = a [ low ] ; return ; } if ( index < low index > high ) return ; if ( low != high ) { int mid = ( low + high ) / 2 ; update ( low , mid , 2 * pos + 1 , index , a ) ; update ( mid + 1 , high , 2 * pos + 2 , index , a ) ; if ( ( level [ pos ] & 1 ) > 0 ) tree [ pos ] = tree [ 2 * pos + 1 ] | tree [ 2 * pos + 2 ] ; else tree [ pos ] = tree [ 2 * pos + 1 ] ^ tree [ 2 * pos + 2 ] ; } }
void updateValue ( int index , int value , int [ ] a , int n ) { a [ index ] = value ; update ( 0 , n - 1 , 0 , index , a ) ; }
int maxXOR ( int n , int k ) { int c = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; return ( ( 1 << c ) - 1 ) ; }
long divide ( long dividend , long divisor ) { long sign = ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? - 1 : 1 ; dividend = Math . abs ( dividend ) ; divisor = Math . abs ( divisor ) ; long quotient = 0 , temp = 0 ; for ( int i = 31 ; i >= 0 ; -- i ) { if ( temp + ( divisor << i ) <= dividend ) { temp += divisor << i ; quotient |= 1L << i ; } } if ( sign == - 1 ) quotient = - quotient ; return quotient ; }
int count ( int n ) { int c = 0 ; while ( n != 0 ) { c ++ ; n = n >> 1 ; } return c ; }
int swapBitsInPair ( int x ) { return ( ( x & 0b10101010 ) >> 1 ) | ( ( x & 0b01010101 ) << 1 ) ; }
int evenbitsetnumber ( int n ) { int count = 0 , res = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
int getmsb ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( n + 1 ) >> 1 ; }
int getevenbits ( int n ) { n = getmsb ( n ) ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; if ( ( n & 1 ) == 1 ) n = n >> 1 ; return n ; }
int setallevenbits ( int n ) { return n | getevenbits ( n ) ; }
int getmsb ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( n + 1 ) >> 1 ; }
int getevenbits ( int n ) { n = getmsb ( n ) ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; if ( ( n & 1 ) == 0 ) n = n >> 1 ; return n ; }
int setalloddbits ( int n ) { return n | getevenbits ( n ) ; }
int setevenbits ( int n ) { int temp = n ; int count = 0 ; int res = 0 ; for ( temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n & res ) ; }
int setoddbits ( int m ) { int count = 0 ; int res = 0 ; for ( int temp = m ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( m & res ) ; }
int getAlternateBits ( int n , int m ) { int tempn = setevenbits ( n ) ; int tempm = setoddbits ( m ) ; return ( tempn tempm ) ; }
int takeLandFsetbits ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( ( n + 1 ) >> 1 ) + 1 ; }
int toggleFandLbits ( int n ) { if ( n == 1 ) return 0 ; return n ^ takeLandFsetbits ( n ) ; }
int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
boolean checkOdious ( int n ) { return ( countSetBits ( n ) % 2 == 1 ) ; }
int setleftmostunsetbit ( int n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; int pos = 0 ; for ( int temp = n , count = 0 ; temp > 0 ; temp >>= 1 , count ++ ) if ( ( temp & 1 ) == 0 ) pos = count ; return ( n | ( 1 << ( pos ) ) ) ; }
int getPosOfRightmostSetBit ( int n ) { return ( int ) ( Math . log ( n & - n ) / Math . log ( 2 ) ) ; }
int toggleLastKBits ( int n , int k ) { int num = ( 1 << k ) - 1 ; return ( n ^ num ) ; }
int incrementByOne ( int n ) { int k = getPosOfRightmostSetBit ( ~ n ) ; n = ( ( 1 << k ) n ) ; if ( k != 0 ) n = toggleLastKBits ( n , k ) ; return n ; }
void printNumHavingAltBitPatrn ( int n ) { int curr_num = 1 , i = 1 ; System . out . print ( curr_num + " " ) ; while ( i != 0 ) { i ++ ; curr_num <<= 1 ; if ( n < curr_num ) break ; System . out . print ( curr_num + " " ) ; curr_num = ( ( curr_num ) << 1 ) ^ 1 ; if ( n < curr_num ) break ; System . out . print ( curr_num + " " ) ; } }
int xnor ( int a , int b ) { if ( a < b ) { int t = a ; a = b ; b = t ; } if ( a == 0 && b == 0 ) return 1 ; int a_rem = 0 ; int b_rem = 0 ; int count = 0 ; int xnornum = 0 ; while ( true ) { a_rem = a & 1 ; b_rem = b & 1 ; if ( a_rem == b_rem ) xnornum |= ( 1 << count ) ; count ++ ; a = a >> 1 ; b = b >> 1 ; if ( a < 1 ) break ; } return xnornum ; }
int togglebit ( int n ) { if ( n == 0 ) return 1 ; int i = n ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return i ^ n ; }
void MaximumSum ( int a [ ] , int b [ ] , int n ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 |= a [ i ] ; sum2 |= b [ i ] ; } System . out . println ( sum1 + sum2 ) ; }
int posOfCarryBit ( int a , int b ) { return posOfRightmostSetBit ( a & b ) ; }
boolean isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
boolean differAtOneBitPos ( int a , int b ) { return isPowerOfTwo ( a ^ b ) ; }
long power2 ( long n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 2 ; return power2 ( n / 2 ) * power2 ( n / 2 ) ; }
long multiply ( long x , long n ) { return x * power2 ( n ) ; }
long multiply ( long x , long n ) { return x << n ; }
boolean isDivBy2PowerM ( int n , int m ) { if ( ( n & ( ( 1 << m ) - 1 ) ) == 0 ) return true ; return false ; }
int findWinner ( int N ) { return N & 1 ; }
void wrapper ( int arr [ ] , int n , int l [ ] , int r [ ] , int q ) { int prefodd [ ] = new int [ 100 ] ; int prefeven [ ] = new int [ 100 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ( i ) % 2 == 0 ) { prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ; } else { prefeven [ i ] = prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] ; } } int i = 0 ; while ( i != q ) { ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) ; i ++ ; } }
int countgroup ( int a [ ] , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; return 0 ; }
int perfectPowerOf2 ( int n ) { int per_pow = 1 ; while ( n > 0 ) { per_pow = per_pow << 1 ; n = n >> 1 ; } return per_pow ; }
int solve ( int p [ ] , int n ) { int G = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] % 2 != 0 ) G ^= ( p [ i ] + 1 ) ; G ^= ( p [ i ] - 1 ) ; } return G ; }
boolean isDivisibleby17 ( int n ) { if ( n == 0 n == 17 ) return true ; if ( n < 17 ) return false ; return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) ; }
long answer ( long n ) { long m = 2 ; long ans = 1 ; long r = 1 ; while ( r < n ) { r = ( ( long ) Math . pow ( 2 , m ) - 1 ) * ( ( long ) Math . pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; }
int maxAND ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) res = res > ( arr [ i ] & arr [ j ] ) ? res : ( arr [ i ] & arr [ j ] ) ; return res ; }
int checkBit ( int pattern , int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( ( pattern & arr [ i ] ) == pattern ) count ++ ; return count ; }
int index ( int i ) { return 1 + ( i >> 31 ) - ( - i >> 31 ) ; }
int countPairs ( int arr [ ] , int n ) { HashMap < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hm . containsKey ( arr [ i ] ) ) hm . put ( arr [ i ] , hm . get ( arr [ i ] ) + 1 ) ; else hm . put ( arr [ i ] , 1 ) ; } int ans = 0 ; for ( Map . Entry < Integer , Integer > it : hm . entrySet ( ) ) { int count = it . getValue ( ) ; ans += ( count * ( count - 1 ) ) / 2 ; } return ans ; }
int countones ( long n ) { int c = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; c ++ ; } return c ; }
boolean checking ( String s ) { int c = 0 ; int n = s . length ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '0' ) c ++ ; if ( c >= 6 && s . charAt ( i ) == '1' ) return true ; } return false ; }
int countSetBitsInGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return countSetBits ( n & num ) ; }
boolean areAllBitsSet ( long n ) { if ( n == 0 ) return false ; if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; }
int findUnique ( int a [ ] , int n , int k ) { byte sizeof_int = 4 ; int INT_SIZE = 8 * sizeof_int ; int count [ ] = new int [ INT_SIZE ] ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; int res = 0 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; }
boolean powerOfTwo ( int n ) { return ( ( n & n - 1 ) == 0 ) ; }
boolean onlyFirstAndLastAreSet ( int n ) { if ( n == 1 ) return true ; return powerOfTwo ( n - 1 ) ; }
boolean allBitsAreSet ( int n ) { if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; }
boolean bitsAreInAltOrder ( int n ) { int num = n ^ ( n >>> 1 ) ; return allBitsAreSet ( num ) ; }
int setBit ( int xorValue ) { int count = 0 ; while ( xorValue >= 1 ) { if ( xorValue % 2 == 1 ) count ++ ; xorValue /= 2 ; } return count ; }
int minFlip ( int n , int k ) { int size = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; int max = ( int ) Math . pow ( 2 , k ) - 1 ; max = max << ( size - k ) ; int xorValue = ( n ^ max ) ; return ( setBit ( xorValue ) ) ; }
int setallbitgivenrange ( int n , int l , int r ) { int range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) ; return ( n range ) ; }
int countBits ( int number ) { return ( int ) ( Math . log ( number ) / Math . log ( 2 ) + 1 ) ; }
int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = n / 2 ; msb ++ ; } return ( 1 << msb ) ; }
int setAllBitsAfterMSB ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return n ; }
int toggle ( int n ) { n = n ^ setAllBitsAfterMSB ( n ) ; return n ; }
boolean checkPowerof8 ( int n ) { double i = Math . log ( n ) / Math . log ( 8 ) ; return ( i - Math . floor ( i ) < 0.000001 ) ; }
boolean adjacentSet ( int n ) { int x = ( n & ( n >> 1 ) ) ; if ( x > 0 ) return true ; else return false ; }
int getRightMostSetBit ( int n ) { return ( int ) ( ( Math . log ( n & - n ) ) / ( Math . log ( 2 ) ) ) + 1 ; }
int posOfRightMostSameBit ( int m , int n ) { return getRightMostSetBit ( ~ ( m ^ n ) ) ; }
void printNonConsecutive ( int n ) { int p = ( 1 << n ) ; for ( int i = 1 ; i < p ; i ++ ) if ( ( i & ( i << 1 ) ) == 0 ) System . out . print ( i + " " ) ; }
int isKthBitSet ( int x , int k ) { return ( ( x & ( 1 << ( k - 1 ) ) ) > 0 ) ? 1 : 0 ; }
int leftmostSetBit ( int x ) { int count = 0 ; while ( x > 0 ) { count ++ ; x = x >> 1 ; } return count ; }
int isBinPalindrome ( int x ) { int l = leftmostSetBit ( x ) ; int r = 1 ; while ( l > r ) { if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) return 0 ; l -- ; r ++ ; } return 1 ; }
int findNthPalindrome ( int n ) { int pal_count = 0 ; int i = 0 ; for ( i = 1 ; i <= INT_MAX ; i ++ ) { if ( isBinPalindrome ( i ) > 0 ) { pal_count ++ ; } if ( pal_count == n ) break ; } return i ; }
int convertStringToInt ( String s ) { int ans = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' ) ans += 1 << i ; } return ans ; }
int getNthNumber ( int n ) { Queue < String > q = new LinkedList < > ( ) ; if ( n == 1 ) return 1 ; n = n - 1 ; q . add ( "11" ) ; while ( n -- > 0 ) { String curr = q . remove ( ) ; if ( n == 0 ) return convertStringToInt ( curr ) ; int len = curr . length ( ) ; if ( len % 2 == 0 ) { q . add ( curr . substring ( 0 , len / 2 ) + "0" + curr . substring ( len / 2 ) ) ; q . add ( curr . substring ( 0 , len / 2 ) + "1" + curr . substring ( len / 2 ) ) ; } else { char midChar = curr . charAt ( len / 2 ) ; q . add ( curr . substring ( 0 , len / 2 ) + midChar + curr . substring ( len / 2 ) ) ; } } return - 1 ; }
int constructNthNumber ( int group_no , int aux_num , int op ) { int a [ ] = new int [ INT_SIZE ] ; int num = 0 , len_f ; int i = 0 ; if ( op == 2 ) { len_f = 2 * group_no ; a [ len_f - 1 ] = a [ 0 ] = 1 ; while ( aux_num > 0 ) { a [ group_no + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } else if ( op == 0 ) { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 0 ; while ( aux_num > 0 ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 1 ; while ( aux_num > 0 ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } for ( i = 0 ; i < len_f ; i ++ ) num += ( 1 << i ) * a [ i ] ; return num ; }
int getNthNumber ( int n ) { int group_no = 0 , group_offset ; int count_upto_group = 0 , count_temp = 1 ; int op , aux_num ; while ( count_temp < n ) { group_no ++ ; count_upto_group = count_temp ; count_temp += 3 * ( 1 << ( group_no - 1 ) ) ; } group_offset = n - count_upto_group - 1 ; if ( ( group_offset + 1 ) <= ( 1 << ( group_no - 1 ) ) ) { aux_num = group_offset ; } else { if ( ( ( group_offset + 1 ) - ( 1 << ( group_no - 1 ) ) ) % 2 == 1 ) else aux_num = ( ( group_offset ) - ( 1 << ( group_no - 1 ) ) ) / 2 ; } return constructNthNumber ( group_no , aux_num , op ) ; }
void shuffle ( int N , int key ) { int NO_OF_BITS = N ; int reverse_num = 0 , temp ; for ( int i = 0 ; i < NO_OF_BITS ; i ++ ) { temp = ( key & ( 1 << i ) ) ; if ( temp > 0 ) reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) ; } System . out . print ( reverse_num ) ; }
int bitExtracted ( int number , int k , int p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; }
void areSame ( int a , int b ) { if ( ( a - b ) == 0 ) System . out . println ( "Same" ) ; else System . out . println ( "Not Same" ) ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( countSetBits ( i ) == 2 ) sum += i ; return sum ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; 1 << i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { int num = ( 1 << i ) + ( 1 << j ) ; if ( num <= n ) sum += num ; } } return sum ; }
int findMax ( int num ) { byte size_of_int = 4 ; int num_copy = num ; int j = size_of_int * 8 - 1 ; int i = 0 ; while ( i < j ) { int m = ( num_copy >> i ) & 1 ; int n = ( num_copy >> j ) & 1 ; if ( m > n ) { int x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; }
int toggleLastMBits ( int n , int m ) { int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; }
int getPosOfRightmostSetBit ( int n ) { return ( int ) ( ( Math . log10 ( n & - n ) ) / ( Math . log10 ( 2 ) ) ) + 1 ; }
int setRightmostUnsetBit ( int n ) { if ( n == 0 ) return 1 ; if ( ( n & ( n + 1 ) ) == 0 ) return n ; int pos = getPosOfRightmostSetBit ( ~ n ) ; return ( ( 1 << ( pos - 1 ) ) n ) ; }
int previousSmallerInteger ( int n ) { int pos = getFirstSetBitPos ( n ) ; return ( n & ~ ( 1 << ( pos - 1 ) ) ) ; }
int getRightMostSetBit ( int n ) { if ( n == 0 ) return 0 ; return ( int ) ( ( Math . log10 ( n & - n ) ) / Math . log10 ( 2 ) ) + 1 ; }
int posOfRightMostDiffBit ( int m , int n ) { return getRightMostSetBit ( m ^ n ) ; }
int posOfRightMostDiffBit ( int m , int n ) { return ( int ) Math . floor ( Math . log10 ( Math . pow ( m ^ n , 2 ) ) ) + 2 ; }
int getFirstSetBitPos ( int n ) { return ( ( int ) ( Math . log ( n & - n ) / Math . log ( 2 ) ) + 1 ) - 1 ; }
int nextGreaterWithOneMoreSetBit ( int n ) { int pos = getFirstSetBitPos ( ~ n ) ; if ( pos > - 1 ) return ( 1 << pos ) | n ; return ( ( n << 1 ) + 1 ) ; }
int setKthBit ( int n , int k ) { return ( ( 1 << k ) n ) ; }
int getNext ( int n ) { int c = n ; int c0 = 0 ; int c1 = 0 ; while ( ( ( c & 1 ) == 0 ) && ( c != 0 ) ) { c0 ++ ; c >>= 1 ; } while ( ( c & 1 ) == 1 ) { c1 ++ ; c >>= 1 ; } if ( c0 + c1 == 31 c0 + c1 == 0 ) return - 1 ; return n + ( 1 << c0 ) + ( 1 << ( c1 - 1 ) ) - 1 ; }
void reverseArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { swap ( arr , i , ( n + ~ i + 1 ) + ~ 1 + 1 ) ; } }
int countNum ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < > ( ) ; int count = 0 , maxm = Integer . MIN_VALUE , minm = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( arr [ i ] ) ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; } for ( int i = minm ; i <= maxm ; i ++ ) if ( ! s . contains ( i ) ) count ++ ; return count ; }
long CountXORandSumEqual ( long x ) { long count = CountZeroBit ( x ) ; return ( 1L << count ) ; }
int maxXORInRange ( int L , int R ) { int LXR = L ^ R ; int msbPos = 0 ; while ( LXR > 0 ) { msbPos ++ ; LXR >>= 1 ; } int maxXOR = 0 ; int two = 1 ; while ( msbPos -- > 0 ) { maxXOR += two ; two <<= 1 ; } return maxXOR ; }
int missingNumber ( int arr1 [ ] , int arr2 [ ] , int n ) { int mnum = 0 ; for ( int i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; }
int CountORandSumEqual ( int N ) { int count = CountZeroBit ( N ) ; return ( 1 << count ) ; }
int toggleKthBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
int countValues ( int x ) { int count = 0 , n = 1 ; while ( x != 0 ) { if ( x % 2 == 0 ) count += n ; n *= 2 ; x /= 2 ; } return count ; }
void constructXOR ( int A [ ] , int n ) { int XOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) XOR ^= A [ i ] ; for ( int i = 0 ; i < n ; i ++ ) A [ i ] = XOR ^ A [ i ] ; }
long kBitDifferencePairs ( int arr [ ] , int n , int k ) { int MAX = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; long [ ] count = new long [ MAX + 1 ] ; Arrays . fill ( count , 0 ) ; for ( int i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] ] ; long ans = 0 ; if ( k == 0 ) { for ( int i = 0 ; i <= MAX ; ++ i ) ans += ( count [ i ] * ( count [ i ] - 1 ) ) / 2 ; return ans ; } for ( int i = 0 ; i <= MAX ; ++ i ) { if ( count [ i ] == 0 ) continue ; for ( int j = i + 1 ; j <= MAX ; ++ j ) { if ( Integer . bitCount ( i ^ j ) == k ) ans += count [ i ] * count [ j ] ; } } return ans ; }
void multiply ( int F [ ] [ ] , int M [ ] [ ] ) { int x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ; int y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ; int z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ; int w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ; F [ 0 ] [ 0 ] = x ; F [ 0 ] [ 1 ] = y ; F [ 1 ] [ 0 ] = z ; F [ 1 ] [ 1 ] = w ; }
void power ( int F [ ] [ ] , int n ) { if ( n == 0 n == 1 ) { return ; } int M [ ] [ ] = { { 1 , 1 } , { 1 , 0 } } ; power ( F , n / 2 ) ; multiply ( F , F ) ; if ( n % 2 != 0 ) { multiply ( F , M ) ; } }
int countWays ( int n ) { int F [ ] [ ] = { { 1 , 1 } , { 1 , 0 } } ; if ( n == 0 ) { return 0 ; } power ( F , n ) ; return F [ 0 ] [ 0 ] ; }
int countTrailingZero ( int x ) { int count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; }
int totalFlips ( String A , String B , String C , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; ++ i ) { if ( A . charAt ( i ) == B . charAt ( i ) && C . charAt ( i ) == '1' ) ++ count ; else if ( A . charAt ( i ) != B . charAt ( i ) && C . charAt ( i ) == '0' ) ++ count ; } return count ; }
int countNumbers ( int n ) { int k = 0 ; int count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += ( int ) ( Math . pow ( 2 , k ) ) ; k += 1 ; n >>= 1 ; } return count ; }
int multiply ( int n , int m ) { int ans = 0 , count = 0 ; while ( m > 0 ) { if ( m % 2 == 1 ) ans += n << count ; count ++ ; m /= 2 ; } return ans ; }
boolean EqualNumber ( int A , int B ) { if ( ( A ^ B ) != 0 ) return true ; else return false ; }
int countXOR ( int n ) { int count0 = 0 , count1 = 0 ; while ( n != 0 ) { if ( n % 2 == 0 ) count0 ++ ; else count1 ++ ; n /= 2 ; } return ( count0 ^ count1 ) ; }
int xorPairCount ( int arr [ ] , int n , int x ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . contains ( x ^ arr [ i ] ) && ( x ^ arr [ i ] ) == ( int ) s . toArray ( ) [ s . size ( ) - 1 ] ) { result ++ ; } s . add ( arr [ i ] ) ; } return result ; }
int xorPairCount ( int arr [ ] , int n , int x ) { Map < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = x ^ arr [ i ] ; if ( m . containsKey ( curr_xor ) ) result += m . get ( curr_xor ) ; if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } } return result ; }
int msbPos ( long n ) { int msb_p = - 1 ; while ( n > 0 ) { n = n >> 1 ; msb_p ++ ; } return msb_p ; }
long andOperator ( long x , long y ) { while ( x > 0 && y > 0 ) { int msb_p1 = msbPos ( x ) ; int msb_p2 = msbPos ( y ) ; if ( msb_p1 != msb_p2 ) break ; long msb_val = ( 1 << msb_p1 ) ; res = res + msb_val ; x = x - msb_val ; y = y - msb_val ; } return res ; }
int multiplyTen ( int n ) { return ( n << 1 ) + ( n << 3 ) ; }
int countValues ( int n ) { int countV = 0 ; for ( int i = 0 ; i <= n ; i ++ ) if ( ( n + i ) == ( n ^ i ) ) countV ++ ; return countV ; }
int countValues ( int n ) { int unset_bits = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) unset_bits ++ ; n = n >> 1 ; } return 1 << unset_bits ; }
int countSubarrays ( int [ ] arr , int n ) { int difference = 0 ; int ans = 0 ; int [ ] hash_positive = new int [ n + 1 ] ; int [ ] hash_negative = new int [ n + 1 ] ; hash_positive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) == 1 ) { difference ++ ; } else { difference -- ; } if ( difference < 0 ) { ans += hash_negative [ - difference ] ; hash_negative [ - difference ] ++ ; } else { ans += hash_positive [ difference ] ; hash_positive [ difference ] ++ ; } } return ans ; }
void printTwoSetBitNums ( int n ) { int x = 1 ; while ( n > 0 ) { int y = 0 ; while ( y < x ) { System . out . print ( ( ( 1 << x ) + ( 1 << y ) ) + " " ) ; n -- ; if ( n == 0 ) return ; y ++ ; } x ++ ; } }
void printRepeatingEven ( int arr [ ] , int n ) { long _xor = 0L ; long pos ; for ( int i = 0 ; i < n ; ++ i ) { pos = 1 << arr [ i ] ; _xor ^= pos ; } for ( int i = 0 ; i < n ; ++ i ) { pos = 1 << arr [ i ] ; if ( ! ( ( pos & _xor ) != 0 ) ) { System . out . print ( arr [ i ] + " " ) ; _xor ^= pos ; } } }
int countSetBits ( int x ) { int count = 0 ; while ( x != 0 ) { x &= ( x - 1 ) ; count ++ ; } return count ; }
boolean isBleak ( int n ) { for ( int x = 1 ; x < n ; x ++ ) if ( x + countSetBits ( x ) == n ) return false ; return true ; }
void diameter ( Node root ) { if ( root == null ) return ; ans = Integer . MIN_VALUE ; lh = 0 ; rh = 0 ; f = 0 ; int height_of_tree = height ( root ) ; int [ ] lPath = new int [ 100 ] ; int pathlen = 0 ; printPathsRecur ( k . left , lPath , pathlen , lh ) ; System . out . print ( k . data + " " ) ; int [ ] rPath = new int [ 100 ] ; f = 1 ; printPathsRecur ( k . right , rPath , pathlen , rh ) ; }
int countSetBits ( int x ) { int count = 0 ; while ( x != 0 ) { x &= ( x - 1 ) ; count ++ ; } return count ; }
int ceilLog2 ( int x ) { int count = 0 ; x -- ; while ( x > 0 ) { x = x >> 1 ; count ++ ; } return count ; }
boolean isBleak ( int n ) { for ( int x = n - ceilLog2 ( n ) ; x < n ; x ++ ) if ( x + countSetBits ( x ) == n ) return false ; return true ; }
int countStrings ( int n ) { int a [ ] = new int [ n ] , b [ ] = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } from 2 ^ n return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }
int myXOR ( int x , int y ) { int res = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { int b1 = ( ( x & ( 1 << i ) ) == 0 ) ? 0 : 1 ; int b2 = ( ( y & ( 1 << i ) ) == 0 ) ? 0 : 1 ; int xoredBit = ( ( b1 & b2 ) != 0 ) ? 0 : ( b1 b2 ) ; res <<= 1 ; res |= xoredBit ; } return res ; }
int myXOR ( int x , int y ) { return ( x y ) & ( ~ x ~ y ) ; }
int myXOR ( int x , int y ) { return ( x & ( ~ y ) ) | ( ( ~ x ) & y ) ; }
int swapBits ( int n , int p1 , int p2 ) { n ^= 1 << p1 ; n ^= 1 << p2 ; return n ; }
int multiplyBySevenByEight ( int n ) { return ( n - ( n >> 3 ) ) ; }
int subtract ( int x , int y ) { while ( y != 0 ) { int borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; }
int subtract ( int x , int y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; }
int square ( int n ) { if ( n < 0 ) n = - n ; int res = n ; for ( int i = 1 ; i < n ; i ++ ) res += n ; return res ; }
double temp_convert ( int F1 , int B1 , int F2 , int B2 , int T ) { float t2 ; t2 = F2 + ( float ) ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ; return t2 ; }
int Divisible ( int arr [ ] , int n ) { int count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) count_even ++ ; return count_even + ( n - count_even ) / 2 ; }
int nextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
int maxLength ( int arr [ ] , int n ) { int maxLen = 0 ; int i = 0 ; int j = i + 1 ; while ( j < n ) { if ( arr [ i ] != arr [ j ] ) { maxLen = Math . max ( maxLen , 2 ) ; int l = i - 1 ; int r = j + 1 ; while ( l >= 0 && r < n && arr [ l ] == arr [ i ] && arr [ r ] == arr [ j ] ) { l -- ; r ++ ; } maxLen = Math . max ( maxLen , 2 * ( r - j ) ) ; } i ++ ; j = i + 1 ; } return maxLen ; }
int maxLength ( int a [ ] , int n ) { int maxLen = 0 ; int prev_cnt = 0 , curr_cnt = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) curr_cnt ++ ; else { prev_cnt = curr_cnt ; curr_cnt = 1 ; } maxLen = Math . max ( maxLen , Math . min ( prev_cnt , curr_cnt ) ) ; } return ( 2 * maxLen ) ; }
boolean freivald ( int a [ ] [ ] , int b [ ] [ ] , int c [ ] [ ] ) { int r [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) r [ i ] = ( int ) ( Math . random ( ) ) % 2 ; int br [ ] = new int [ N ] ; Arrays . fill ( br , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) br [ i ] = br [ i ] + b [ i ] [ j ] * r [ j ] ; int cr [ ] = new int [ N ] ; Arrays . fill ( cr , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) cr [ i ] = cr [ i ] + c [ i ] [ j ] * r [ j ] ; int axbr [ ] = new int [ N ] ; Arrays . fill ( axbr , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) axbr [ i ] = axbr [ i ] + a [ i ] [ j ] * br [ j ] ; for ( int i = 0 ; i < N ; i ++ ) if ( axbr [ i ] - cr [ i ] != 0 ) return false ; return true ; }
boolean isProduct ( int a [ ] [ ] , int b [ ] [ ] , int c [ ] [ ] , int k ) { for ( int i = 0 ; i < k ; i ++ ) if ( freivald ( a , b , c ) == false ) return false ; return true ; }
int children ( Node root ) { if ( root == null ) return 0 ; return root . children + 1 ; }
int randomNodeUtil ( Node root , int count ) { if ( root == null ) return 0 ; if ( count == children ( root . left ) ) return root . data ; if ( count < children ( root . left ) ) return randomNodeUtil ( root . left , count ) ; return randomNodeUtil ( root . right , count - children ( root . left ) - 1 ) ; }
int randomNode ( Node root ) { int count = ( int ) Math . random ( ) * ( root . children + 1 ) ; return randomNodeUtil ( root , count ) ; }
float calc_Expectation ( float a [ ] , float n ) { float prb = ( 1 / n ) ; float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] * prb ; return sum ; }
int findLargestd ( int [ ] S , int n ) { boolean found = false ; Arrays . sort ( S ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return Integer . MAX_VALUE ; return - 1 ; }
void recaman ( int n ) { int arr [ ] = new int [ n ] ; arr [ 0 ] = 0 ; System . out . print ( arr [ 0 ] + " ," ) ; for ( int i = 1 ; i < n ; i ++ ) { int curr = arr [ i - 1 ] - i ; int j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; System . out . print ( arr [ i ] + ", " ) ; } }
int countPairs ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) s . add ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . contains ( sumOfDiv ( arr [ i ] ) ) ) { int sum = sumOfDiv ( arr [ i ] ) ; if ( isAmicable ( arr [ i ] , sum ) ) count ++ ; } } return count / 2 ; }
int findArea ( Integer arr [ ] , int n ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; int [ ] dimension = { 0 , 0 } ; for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; }
int findArea ( int arr [ ] , int n ) { Set < Integer > s = new HashSet < > ( ) ; int first = 0 , second = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . contains ( arr [ i ] ) ) { s . add ( arr [ i ] ) ; continue ; } if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } return ( first * second ) ; }
void printAllPaths ( Node root ) { if ( root == null ) return ; ArrayList < PATH > Allpaths = new ArrayList < > ( ) ; for ( int i = 0 ; i < MAX_PATH_SIZE ; i ++ ) { Allpaths . add ( new PATH ( ) ) ; } printAllPathsUtil ( root , Allpaths , 0 , 0 ) ; }
int longLenStrictBitonicSub ( int arr [ ] , int n ) { HashMap < Integer , Integer > inc = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > dcr = new HashMap < Integer , Integer > ( ) ; int len_inc [ ] = new int [ n ] ; int len_dcr [ ] = new int [ n ] ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( inc . containsKey ( arr [ i ] - 1 ) ) len = inc . get ( arr [ i ] - 1 ) ; len_inc [ i ] = len + 1 ; inc . put ( arr [ i ] , len_inc [ i ] ) ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { int len = 0 ; if ( dcr . containsKey ( arr [ i ] - 1 ) ) len = dcr . get ( arr [ i ] - 1 ) ; len_dcr [ i ] = len + 1 ; dcr . put ( arr [ i ] , len_dcr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) if ( longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) ) longLen = len_inc [ i ] + len_dcr [ i ] - 1 ; return longLen ; }
void leftRotatebyOne ( int arr [ ] , int n ) { int i , temp ; temp = arr [ 0 ] ; for ( i = 0 ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = temp ; }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
boolean pairInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; }
int pairsInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }
int maxSum ( int arr [ ] , int n ) { int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = Math . max ( res , curr_sum ) ; } return res ; }
int maxSum ( int arr [ ] , int n ) { int cum_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; int curr_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ; int res = curr_val ; for ( int i = 1 ; i < n ; i ++ ) { int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ; curr_val = next_val ; res = Math . max ( res , next_val ) ; } return res ; }
int countRotations ( int arr [ ] , int n ) { int min = arr [ 0 ] , min_index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; }
int countRotations ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }
void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) System . out . print ( arr [ i % n ] + " " ) ; }
int findMin ( int arr [ ] , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }
void reverseArray ( int arr [ ] , int start , int end ) { while ( start < end ) { int temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; start ++ ; end -- ; } }
void rightRotate ( int arr [ ] , int d , int n ) { reverseArray ( arr , 0 , n - 1 ) ; reverseArray ( arr , 0 , d - 1 ) ; reverseArray ( arr , d , n - 1 ) ; }
int maxHamming ( int arr [ ] , int n ) { int brr [ ] = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; int maxHam = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int currHam = 0 ; for ( int j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = Math . max ( maxHam , currHam ) ; } return maxHam ; }
void rearrangeArr ( int arr [ ] , int n ) { int evenPos = n / 2 ; int oddPos = n - evenPos ; int [ ] tempArr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) tempArr [ i ] = arr [ i ] ; Arrays . sort ( tempArr ) ; int j = oddPos - 1 ; for ( int i = 0 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j -- ; } j = oddPos ; for ( int i = 1 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j ++ ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
void moveZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] != 0 ) ) { temp = arr [ count ] ; arr [ count ] = arr [ i ] ; arr [ i ] = temp ; count = count + 1 ; } } }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
void modifyAndRearrangeArr ( int arr [ ] , int n ) { if ( n == 1 ) return ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( arr [ i ] != 0 ) && ( arr [ i ] == arr [ i + 1 ] ) ) { arr [ i ] = 2 * arr [ i ] ; arr [ i + 1 ] = 0 ; i ++ ; } } pushZerosToEnd ( arr , n ) ; }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; System . out . println ( ) ; }
void RearrangePosNeg ( int arr [ ] , int n ) { int key , j ; for ( int i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; if ( key > 0 ) continue ; j = i - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } }
boolean isLeaf ( Node node ) { if ( node == null ) return false ; if ( node . left == null && node . right == null ) return true ; return false ; }
int leftLeavesSum ( Node node ) { int res = 0 ; if ( node != null ) { if ( isLeaf ( node . left ) ) res += node . left . data ; else res += leftLeavesSum ( node . left ) ; res += leftLeavesSum ( node . right ) ; } return res ; }
void reverse ( int arr [ ] , int l , int r ) { if ( l < r ) { arr = swap ( arr , l , r ) ; reverse ( arr , ++ l , -- r ) ; } }
void RearrangePosNeg ( int arr [ ] , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; RearrangePosNeg ( arr , l , m ) ; RearrangePosNeg ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } }
void rearrangeNaive ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; int i ; for ( i = 0 ; i < n ; i ++ ) temp [ arr [ i ] ] = i ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } System . out . println ( "" ) ; }
void rearrange ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ arr [ i ] % n ] += i * n ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] /= n ; } }
void rearrange ( int arr [ ] , int n ) { int max_idx = n - 1 , min_idx = 0 ; int max_elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] / max_elem ; }
void rearrange ( int arr [ ] , int n ) { int max_ele = arr [ n - 1 ] ; int min_ele = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_ele ; max_ele -= 1 ; } else { arr [ i ] = min_ele ; min_ele += 1 ; } } }
void leftLeavesSumRec ( Node node , boolean isleft , Sum summ ) { if ( node == null ) return ; if ( node . left == null && node . right == null && isleft ) summ . sum = summ . sum + node . data ; leftLeavesSumRec ( node . left , true , summ ) ; leftLeavesSumRec ( node . right , false , summ ) ; }
int leftLeavesSum ( Node node ) { Sum suum = new Sum ( ) ; leftLeavesSumRec ( node , false , suum ) ; return suum . sum ; }
void rearrange ( int arr [ ] , int n ) { int j = 0 , temp ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) { if ( i != j ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } } }
void segregateElements ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
void rearrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 , temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } }
void printPostorder ( Node node ) { if ( node == null ) return ; printPostorder ( node . left ) ; printPostorder ( node . right ) ; System . out . print ( node . key + " " ) ; }
void printInorder ( Node node ) { if ( node == null ) return ; printInorder ( node . left ) ; System . out . print ( node . key + " " ) ; printInorder ( node . right ) ; }
void printPreorder ( Node node ) { if ( node == null ) return ; System . out . print ( node . key + " " ) ; printPreorder ( node . left ) ; printPreorder ( node . right ) ; }
int largest ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; return arr [ n - 1 ] ; }
void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) System . out . print ( arr [ i ] + " " ) ; } }
void findElements ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void findElements ( int arr [ ] , int n ) { int first = Integer . MIN_VALUE ; int second = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) System . out . print ( arr [ i ] + " " ) ; }
double findMean ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return ( double ) sum / ( double ) n ; }
double findMedian ( int a [ ] , int n ) { Arrays . sort ( a ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; }
int findSmallestMissinginSortedArray ( int [ ] arr ) { if ( arr [ 0 ] != 0 ) return 0 ; if ( arr [ arr . length - 1 ] == arr . length - 1 ) return arr . length ; int first = arr [ 0 ] ; return findFirstMissing ( arr , 0 , arr . length - 1 , first ) ; }
int findFirstMissing ( int [ ] arr , int start , int end , int first ) { if ( start < end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] != mid + first ) return findFirstMissing ( arr , start , mid , first ) ; else return findFirstMissing ( arr , mid + 1 , end , first ) ; } return start + first ; }
double sumNodes ( int l ) { double leafNodeCount = Math . pow ( 2 , l - 1 ) ; double sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; double sum = sumLastLevel * l ; return sum ; }
void buildSparseTable ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) lookup [ i ] [ 0 ] = arr [ i ] ; for ( int j = 1 ; ( 1 << j ) <= n ; j ++ ) { for ( int i = 0 ; ( i + ( 1 << j ) - 1 ) < n ; i ++ ) { if ( lookup [ i ] [ j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] ; else lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ; } } }
int query ( int L , int R ) { int j = ( int ) Math . log ( R - L + 1 ) ; if ( lookup [ L ] [ j ] <= lookup [ R - ( 1 << j ) + 1 ] [ j ] ) return lookup [ L ] [ j ] ; else return lookup [ R - ( 1 << j ) + 1 ] [ j ] ; }
void add ( int arr [ ] , int N , int lo , int hi , int val ) { arr [ lo ] += val ; if ( hi != N - 1 ) arr [ hi + 1 ] -= val ; }
void updateArray ( int arr [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) arr [ i ] += arr [ i - 1 ] ; }
void FillPrefixSuffix ( int prefix [ ] , int arr [ ] , int suffix [ ] , int n ) { prefix [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix [ i ] = GCD ( prefix [ i - 1 ] , arr [ i ] ) ; suffix [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffix [ i ] = GCD ( suffix [ i + 1 ] , arr [ i ] ) ; }
int GCDoutsideRange ( int l , int r , int prefix [ ] , int suffix [ ] , int n ) { if ( l == 0 ) return suffix [ r + 1 ] ; if ( r == n - 1 ) return prefix [ l - 1 ] ; return GCD ( prefix [ l - 1 ] , suffix [ r + 1 ] ) ; }
int lowerIndex ( int arr [ ] , int n , int x ) { int l = 0 , h = n - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] >= x ) h = mid - 1 ; else l = mid + 1 ; } return l ; }
int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; count = upperIndex ( arr , n , y ) - lowerIndex ( arr , n , x ) + 1 ; return count ; }
void precompute ( int arr [ ] , int n , int pre [ ] ) { Arrays . fill ( pre , 0 ) ; pre [ n - 1 ] = arr [ n - 1 ] * ( int ) ( Math . pow ( 2 , 0 ) ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) pre [ i ] = pre [ i + 1 ] + arr [ i ] * ( 1 << ( n - 1 - i ) ) ; }
int decimalOfSubarr ( int arr [ ] , int l , int r , int n , int pre [ ] ) { if ( r != n - 1 ) return ( pre [ l ] - pre [ r + 1 ] ) / ( 1 << ( n - 1 - r ) ) ; return pre [ l ] / ( 1 << ( n - 1 - r ) ) ; }
int answerQuery ( int a [ ] , int n , int l , int r ) { int count = 0 ; l = l - 1 ; for ( int i = l ; i < r ; i ++ ) { int element = a [ i ] ; int divisors = 0 ; for ( int j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; }
void addConsideringGrid ( Node root , int level , int index ) { if ( root == null ) return ; if ( grid . containsKey ( level - index ) ) grid . put ( level - index , grid . get ( level - index ) + ( root . data ) ) ; else grid . put ( level - index , root . data ) ; addConsideringGrid ( root . left , level + 1 , index - 1 ) ; addConsideringGrid ( root . right , level + 1 , index + 1 ) ; }
Vector < Integer > diagonalSum ( Node root ) { grid . clear ( ) ; addConsideringGrid ( root , 0 , 0 ) ; Vector < Integer > ans = new Vector < > ( ) ; for ( Map . Entry < Integer , Integer > x : grid . entrySet ( ) ) { ans . add ( x . getValue ( ) ) ; } return ans ; }
void make_prefix ( int A [ ] , int n ) { for ( int j = 0 ; j < 32 ; j ++ ) one [ 0 ] [ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int a = A [ i - 1 ] ; for ( int j = 0 ; j < 32 ; j ++ ) { int x = ( int ) Math . pow ( 2 , j ) ; if ( ( a & x ) != 0 ) one [ i ] [ j ] = 1 + one [ i - 1 ] [ j ] ; else one [ i ] [ j ] = one [ i - 1 ] [ j ] ; } } }
void type1 ( int [ ] arr , int start , int limit ) { for ( int i = start ; i <= limit ; i ++ ) arr [ i ] ++ ; }
void type2 ( int [ ] arr , int [ ] [ ] query , int start , int limit ) { for ( int i = start ; i <= limit ; i ++ ) { if ( query [ i ] [ 0 ] == 1 ) type1 ( arr , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; else if ( query [ i ] [ 0 ] == 2 ) type2 ( arr , query , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; } }
void record_sum ( int record [ ] , int l , int r , int n , int adder ) { for ( int i = l ; i <= r ; i ++ ) { record [ i ] += adder ; } }
int solveQuery ( int start , int end , int arr [ ] ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = start ; i <= end ; i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; int count = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) if ( entry . getKey ( ) == entry . getValue ( ) ) count ++ ; return count ; }
int answer_query ( int a [ ] , int n , int l , int r ) { int count = 0 ; for ( int i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; }
void countIndex ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i + 1 < n && a [ i ] == a [ i + 1 ] ) prefixans [ i ] = 1 ; if ( i != 0 ) prefixans [ i ] += prefixans [ i - 1 ] ; } }
int answer_query ( int l , int r ) { if ( l == 0 ) return prefixans [ r - 1 ] ; else return prefixans [ r - 1 ] - prefixans [ l - 1 ] ; }
void update ( int D [ ] , int l , int r , int x ) { D [ l ] += x ; D [ r + 1 ] -= x ; }
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; }
int minJumps ( int arr [ ] , int n ) { int [ ] jumps = new int [ n ] ; int min ; jumps [ n - 1 ] = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == 0 ) jumps [ i ] = Integer . MAX_VALUE ; else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ; else { min = Integer . MAX_VALUE ; for ( int j = i + 1 ; j < n && j <= arr [ i ] + i ; j ++ ) { if ( min > jumps [ j ] ) min = jumps [ j ] ; } if ( min != Integer . MAX_VALUE ) jumps [ i ] = min + 1 ; else jumps [ i ] = min ; } } return jumps [ 0 ] ; }
int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 , min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }
int findMaxAverage ( int [ ] arr , int n , int k ) { if ( k > n ) return - 1 ; int [ ] csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; }
int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }
int findMinOps ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 , j = n - 1 ; i <= j ; ) { if ( arr [ i ] == arr [ j ] ) { i ++ ; j -- ; } else if ( arr [ i ] > arr [ j ] ) { j -- ; arr [ j ] += arr [ j + 1 ] ; ans ++ ; } else { i ++ ; arr [ i ] += arr [ i - 1 ] ; ans ++ ; } } return ans ; }
int findSmallest ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 0 ; i < n && arr [ i ] <= res ; i ++ ) res = res + arr [ i ] ; return res ; }
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; start = s ; end = i ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; s = i + 1 ; } } return ( end - start + 1 ) ; }
int findMinDiff ( int [ ] arr , int n ) { int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . abs ( ( arr [ i ] - arr [ j ] ) ) ; return diff ; }
int findMinDiff ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int diff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }
boolean checkbit ( int array [ ] , int index ) { int val = array [ index >> 5 ] & ( 1 << ( index & 31 ) ) ; if ( val == 0 ) return false ; return true ; }
void setbit ( int array [ ] , int index ) { array [ index >> 5 ] |= ( 1 << ( index & 31 ) ) ; }
void sortInWave ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i += 2 ) swap ( arr , i , i + 1 ) ; }
void sortInWave ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i += 2 ) { if ( i > 0 && arr [ i - 1 ] > arr [ i ] ) swap ( arr , i - 1 , i ) ; if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) swap ( arr , i , i + 1 ) ; } }
void moveToEnd ( int mPlusN [ ] , int size ) { int i , j = size - 1 ; for ( i = size - 1 ; i >= 0 ; i -- ) { if ( mPlusN [ i ] != - 1 ) { mPlusN [ j ] = mPlusN [ i ] ; j -- ; } } }
void merge ( int mPlusN [ ] , int N [ ] , int m , int n ) { int i = n ; int j = 0 ; int k = 0 ; while ( k < ( m + n ) ) { if ( ( i < ( m + n ) && mPlusN [ i ] <= N [ j ] ) || ( j == n ) ) { mPlusN [ k ] = mPlusN [ i ] ; k ++ ; i ++ ; } else { mPlusN [ k ] = N [ j ] ; k ++ ; j ++ ; } } }
boolean sortedAfterSwap ( int A [ ] , boolean B [ ] , int n ) { int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { j = i ; while ( B [ j ] ) { j ++ ; } Arrays . sort ( A , i , 1 + j ) ; i = j ; } } for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) { return false ; } } return true ; }
int sortedAfterSwap ( int [ ] A , int [ ] B , int n ) { int t = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] != 0 ) { if ( A [ i ] != i + 1 ) t = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = t ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return 0 ; } return 1 ; }
void segregate0and1 ( int arr [ ] , int n ) { int type0 = 0 ; int type1 = n - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type0 ] = arr [ type0 ] + arr [ type1 ] ; arr [ type1 ] = arr [ type0 ] - arr [ type1 ] ; arr [ type0 ] = arr [ type0 ] - arr [ type1 ] ; type1 -- ; } else { type0 ++ ; } } }
boolean increasing ( int a [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) if ( a [ i ] >= a [ i + 1 ] ) return false ; return true ; }
boolean decreasing ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] < arr [ i + 1 ] ) return false ; return true ; }
int shortestUnsorted ( int a [ ] , int n ) { if ( increasing ( a , n ) == true || decreasing ( a , n ) == true ) return 0 ; else return 3 ; }
int indexOf ( int [ ] arr , int ele ) { for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == ele ) { return i ; } } return - 1 ; }
int minSwaps ( int [ ] arr , int N ) { int ans = 0 ; int [ ] temp = Arrays . copyOfRange ( arr , 0 , N ) ; Arrays . sort ( temp ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != temp [ i ] ) { ans ++ ; swap ( arr , i , indexOf ( arr , temp [ i ] ) ) ; } } return ans ; }
void printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { if ( m > n ) { int tempp [ ] = arr1 ; arr1 = arr2 ; arr2 = tempp ; int temp = m ; m = n ; n = temp ; } Arrays . sort ( arr1 ) ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( arr1 [ i ] + " " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) == - 1 ) System . out . print ( arr2 [ i ] + " " ) ; } }
void printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { if ( m > n ) { int tempp [ ] = arr1 ; arr1 = arr2 ; arr2 = tempp ; int temp = m ; m = n ; n = temp ; } Arrays . sort ( arr1 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) != - 1 ) System . out . print ( arr2 [ i ] + " " ) ; } }
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }
void intersection ( int a [ ] , int b [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( a [ i ] > b [ j ] ) { j ++ ; } else if ( b [ j ] > a [ i ] ) { i ++ ; } else { System . out . print ( a [ i ] + " " ) ; i ++ ; j ++ ; } } }
void sort012 ( int a [ ] , int arr_size ) { int lo = 0 ; int hi = arr_size - 1 ; int mid = 0 , temp = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : { temp = a [ lo ] ; a [ lo ] = a [ mid ] ; a [ mid ] = temp ; lo ++ ; mid ++ ; break ; } case 1 : mid ++ ; break ; case 2 : { temp = a [ mid ] ; a [ mid ] = a [ hi ] ; a [ hi ] = temp ; hi -- ; break ; } } } }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void sortArr ( int arr [ ] , int n ) { int i , cnt0 = 0 , cnt1 = 0 , cnt2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { switch ( arr [ i ] ) { case 0 : cnt0 ++ ; break ; case 1 : cnt1 ++ ; break ; case 2 : cnt2 ++ ; break ; } } i = 0 ; while ( cnt0 > 0 ) { arr [ i ++ ] = 0 ; cnt0 -- ; } while ( cnt1 > 0 ) { arr [ i ++ ] = 1 ; cnt1 -- ; } while ( cnt2 > 0 ) { arr [ i ++ ] = 2 ; cnt2 -- ; } printArr ( arr , n ) ; }
int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }
int binarySearch ( int arr [ ] , int low , int high , int x ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( x == arr [ mid ] ) return mid ; if ( x > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return - 1 ; }
int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 , i ; Arrays . sort ( arr ) ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( binarySearch ( arr , i + 1 , n - 1 , arr [ i ] + k ) != - 1 ) count ++ ; return count ; }
void constructArr ( int arr [ ] , int pair [ ] , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }
int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { int max = arr1 [ 0 ] ; int min = arr2 [ 0 ] ; int i ; for ( i = 1 ; i < n1 && i < n2 ; ++ i ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; if ( arr2 [ i ] < min ) min = arr2 [ i ] ; } while ( i < n1 ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; i ++ ; } while ( i < n2 ) { if ( arr2 [ i ] < min ) min = arr2 [ i ] ; i ++ ; } return max * min ; }
int findElement ( int arr [ ] , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; }
int findPos ( int arr [ ] , int key ) { int l = 0 , h = 1 ; int val = arr [ 0 ] ; while ( val < key ) { l = h ; if ( 2 * h < arr . length - 1 ) h = 2 * h ; else h = arr . length - 1 ; val = arr [ h ] ; } return binarySearch ( arr , l , h , key ) ; }
int findSingle ( int ar [ ] , int ar_size ) { int res = ar [ 0 ] ; for ( int i = 1 ; i < ar_size ; i ++ ) res = res ^ ar [ i ] ; return res ; }
boolean isPresent ( int B [ ] , int m , int x ) { for ( int i = 0 ; i < m ; i ++ ) if ( B [ i ] == x ) return true ; return false ; }
int findMaxSubarraySumUtil ( int A [ ] , int B [ ] , int n , int m ) { int max_so_far = - 2147483648 , curr_max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPresent ( B , m , A [ i ] ) ) { curr_max = 0 ; continue ; } curr_max = Math . max ( A [ i ] , curr_max + A [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; }
int findMaxSum ( int [ ] arr , int n ) { int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int prefix_sum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; int suffix_sum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = Math . max ( res , prefix_sum ) ; } return res ; }
int getTotalHeight ( Node root ) { if ( root == null ) return 0 ; return getTotalHeight ( root . left ) + getHeight ( root ) + getTotalHeight ( root . right ) ; }
int findMaxSum ( int [ ] arr , int n ) { int [ ] preSum = new int [ n ] ; int [ ] suffSum = new int [ n ] ; int ans = Integer . MIN_VALUE ; preSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = Math . max ( ans , preSum [ n - 1 ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = Math . max ( ans , preSum [ i ] ) ; } return ans ; }
int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; }
int ceilSearch ( int arr [ ] , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } }
void findMajority ( int arr [ ] , int n ) { int maxCount = 0 ; int index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) System . out . println ( arr [ index ] ) ; else System . out . println ( "No Majority Element" ) ; }
int getTotalHeight ( Node root ) { sum = 0 ; getTotalHeightUtil ( root ) ; return sum ; }
int majorityElement ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int count = 1 , max_ele = - 1 , temp = arr [ 0 ] , ele = 0 , f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( temp == arr [ i ] ) { count ++ ; } else { count = 1 ; temp = arr [ i ] ; } if ( max_ele < count ) { max_ele = count ; ele = arr [ i ] ; if ( max_ele > ( n / 2 ) ) { f = 1 ; break ; } } } return ( f == 1 ? ele : - 1 ) ; }
boolean isMajority ( int arr [ ] , int n , int x ) { int i , last_index = 0 ; last_index = ( n % 2 == 0 ) ? n / 2 : n / 2 + 1 ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return true ; } return false ; }
int _binarySearch ( int arr [ ] , int low , int high , int x ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( ( mid == 0 x > arr [ mid - 1 ] ) && ( arr [ mid ] == x ) ) return mid ; else if ( x > arr [ mid ] ) return _binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return _binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return - 1 ; }
boolean isMajority ( int arr [ ] , int n , int x ) { int i = _binarySearch ( arr , 0 , n - 1 , x ) ; if ( i == - 1 ) return false ; if ( ( ( i + n / 2 ) <= ( n - 1 ) ) && arr [ i + n / 2 ] == x ) return true ; else return false ; }
boolean isMajorityElement ( int arr [ ] , int n , int key ) { if ( arr [ n / 2 ] == key ) return true ; else return false ; }
int findPeak ( int arr [ ] , int n ) { if ( n == 1 ) return 0 ; if ( arr [ 0 ] >= arr [ 1 ] ) return 0 ; if ( arr [ n - 1 ] >= arr [ n - 2 ] ) return n - 1 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] >= arr [ i - 1 ] && arr [ i ] >= arr [ i + 1 ] ) return i ; } return 0 ; }
int findPeak ( int arr [ ] , int n ) { return findPeakUtil ( arr , 0 , n - 1 , n ) ; }
void printRepeating ( int arr [ ] , int size ) { int i , j ; System . out . println ( "Repeated Elements are :" ) ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) System . out . print ( arr [ i ] + " " ) ; } } }
void printRepeating ( int arr [ ] , int size ) { int count [ ] = new int [ size ] ; int i ; System . out . println ( "Repeated elements are : " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) System . out . print ( arr [ i ] + " " ) ; else count [ arr [ i ] ] ++ ; } }
void printRepeating ( int arr [ ] , int size ) { int S = 0 ; int P = 1 ; int x , y ; int D ; int n = size - 2 , i ; for ( i = 0 ; i < size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; } S = S - n * ( n + 1 ) / 2 ; P = P / fact ( n ) ; D = ( int ) Math . sqrt ( S * S - 4 * P ) ; x = ( D + S ) / 2 ; y = ( S - D ) / 2 ; System . out . println ( "The two repeating elements are :" ) ; System . out . print ( x + " " + y ) ; }
int fact ( int n ) { return ( n == 0 ) ? 1 : n * fact ( n - 1 ) ; }
void printRepeating ( int arr [ ] , int size ) { int xor = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor ^= i ; set_bit_no = ( xor & ~ ( xor - 1 ) ) ; for ( i = 0 ; i < size ; i ++ ) { int a = arr [ i ] & set_bit_no ; if ( a != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { int a = i & set_bit_no ; if ( a != 0 ) x = x ^ i ; else y = y ^ i ; } System . out . println ( "The two reppeated elements are :" ) ; System . out . println ( x + " " + y ) ; }
int linearSearch ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; }
int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum , i , j ; for ( i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { int p = j - 1 ; System . out . println ( "Sum found between indexes " + i + " and " + p ) ; return 1 ; } if ( curr_sum > sum j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } System . out . println ( "No subarray found" ) ; return 0 ; }
int maxTripletSum ( int arr [ ] , int n ) { int sum = - 1000000 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }
int maxTripletSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }
int maxTripletSum ( int arr [ ] , int n ) { int maxA = - 100000000 , maxB = - 100000000 ; int maxC = - 100000000 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; } return ( maxA + maxB + maxC ) ; }
int minimum ( int a , int b , int c ) { return Math . min ( Math . min ( a , b ) , c ) ; }
void smallestDifferenceTriplet ( int arr1 [ ] , int arr2 [ ] , int arr3 [ ] , int n ) { Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; Arrays . sort ( arr3 ) ; int res_min = 0 , res_max = 0 , res_mid = 0 ; int i = 0 , j = 0 , k = 0 ; int diff = 2147483647 ; while ( i < n && j < n && k < n ) { int sum = arr1 [ i ] + arr2 [ j ] + arr3 [ k ] ; int max = maximum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) ; int min = minimum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) ; if ( min == arr1 [ i ] ) i ++ ; else if ( min == arr2 [ j ] ) j ++ ; else k ++ ; if ( diff > ( max - min ) ) { diff = max - min ; res_max = max ; res_mid = sum - ( max + min ) ; res_min = min ; } } System . out . print ( res_max + ", " + res_mid + ", " + res_min ) ; }
boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { System . out . print ( "Triplet is " + A [ i ] + ", " + A [ j ] + ", " + A [ k ] ) ; return true ; } } } } return false ; }
boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; quickSort ( A , 0 , arr_size - 1 ) ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { l = i + 1 ; r = arr_size - 1 ; while ( l < r ) { if ( A [ i ] + A [ l ] + A [ r ] == sum ) { System . out . print ( "Triplet is " + A [ i ] + ", " + A [ l ] + ", " + A [ r ] ) ; return true ; } else if ( A [ i ] + A [ l ] + A [ r ] < sum ) l ++ ; else r -- ; } } return false ; }
boolean areConsecutive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { boolean visited [ ] = new boolean [ n ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - min ] != false ) return false ; visited [ arr [ i ] - min ] = true ; } return true ; } return false ; }
boolean areConsecutive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { int j ; if ( arr [ i ] < 0 ) j = - arr [ i ] - min ; else j = arr [ i ] - min ; if ( arr [ j ] > 0 ) arr [ j ] = - arr [ j ] ; else return false ; } return true ; } return false ; }
int getMax ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }
void relativeComplement ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( arr1 [ i ] < arr2 [ j ] ) { System . out . print ( arr1 [ i ] + " " ) ; i ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) { j ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; j ++ ; } } while ( i < n ) System . out . print ( arr1 [ i ] + " " ) ; }
int minOps ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int max = arr [ arr . length - 1 ] ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }
void search ( int arr [ ] , int search_Element ) { int left = 0 ; int length = arr . length ; int right = length - 1 ; int position = - 1 ; for ( left = 0 ; left <= right ; ) { if ( arr [ left ] == search_Element ) { position = left ; System . out . println ( "Element found in Array at " + ( position + 1 ) + " Position with " + ( left + 1 ) + " Attempt" ) ; break ; } if ( arr [ right ] == search_Element ) { position = right ; System . out . println ( "Element found in Array at " + ( position + 1 ) + " Position with " + ( length - right ) + " Attempt" ) ; break ; } left ++ ; right -- ; } if ( position == - 1 ) System . out . println ( "Not found in Array with " + left + " Attempt" ) ; }
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; }
int exponentialSearch ( int arr [ ] , int n , int x ) { if ( arr [ 0 ] == x ) return 0 ; int i = 1 ; while ( i < n && arr [ i ] <= x ) i = i * 2 ; return Arrays . binarySearch ( arr , i / 2 , Math . min ( i , n - 1 ) , x ) ; }
int findCrossOver ( int arr [ ] , int low , int high , int x ) { if ( arr [ high ] <= x ) return high ; if ( arr [ low ] > x ) return low ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] <= x && arr [ mid + 1 ] > x ) return mid ; if ( arr [ mid ] < x ) return findCrossOver ( arr , mid + 1 , high , x ) ; return findCrossOver ( arr , low , mid - 1 , x ) ; }
void countSort ( int arr [ ] , int n , int exp ) { int output [ ] = new int [ n ] ; int i , count [ ] = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) count [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) count [ ( arr [ i ] / exp ) % n ] ++ ; for ( i = 1 ; i < n ; i ++ ) count [ i ] += count [ i - 1 ] ; for ( i = n - 1 ; i >= 0 ; i -- ) { output [ count [ ( arr [ i ] / exp ) % n ] - 1 ] = arr [ i ] ; count [ ( arr [ i ] / exp ) % n ] -- ; } for ( i = 0 ; i < n ; i ++ ) arr [ i ] = output [ i ] ; }
void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n , int x ) { int diff = Integer . MAX_VALUE ; int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } System . out . print ( "The closest pair is [" + ar1 [ res_l ] + ", " + ar2 [ res_r ] + "]" ) ; }
int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; }
int minCost ( int cost [ ] [ ] , int m , int n ) { if ( n < 0 m < 0 ) return Integer . MAX_VALUE ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ; }
int minCost ( int cost [ ] [ ] , int m , int n ) { int i , j ; int tc [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return tc [ m ] [ n ] ; }
int matrixChainMemoised ( int [ ] p , int i , int j ) { if ( i == j ) { return 0 ; } if ( dp [ i ] [ j ] != - 1 ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] = Integer . MAX_VALUE ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i ] [ j ] ; }
int MatrixChainOrder ( int [ ] p , int n ) { int i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; }
int MatrixChainOrder ( int p [ ] , int n ) { int m [ ] [ ] = new int [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; }
int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }
int binomialCoeff ( int n , int k ) { int C [ ] = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }
int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }
int max ( int x , int y ) { return ( x > y ) ? x : y ; }
int lps ( char seq [ ] , int i , int j ) { if ( i == j ) { return 1 ; } if ( seq [ i ] == seq [ j ] && i + 1 == j ) { return 2 ; } if ( seq [ i ] == seq [ j ] ) { return lps ( seq , i + 1 , j - 1 ) + 2 ; } return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; }
int cutRod ( int price [ ] , int n ) { if ( n <= 0 ) return 0 ; int max_val = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) max_val = Math . max ( max_val , price [ i ] + cutRod ( price , n - i - 1 ) ) ; return max_val ; }
int cutRod ( int price [ ] , int n ) { int val [ ] = new int [ n + 1 ] ; val [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int max_val = Integer . MIN_VALUE ; for ( int j = 0 ; j < i ; j ++ ) max_val = Math . max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; }
int minPalPartion ( String string , int i , int j ) { if ( i >= j || isPalindrome ( string , i , j ) ) return 0 ; int ans = Integer . MAX_VALUE , count ; for ( int k = i ; k < j ; k ++ ) { count = minPalPartion ( string , i , k ) + minPalPartion ( string , k + 1 , j ) + 1 ; ans = Math . min ( ans , count ) ; } return ans ; }
int maxDivide ( int a , int b ) { while ( a % b == 0 ) a = a / b ; return a ; }
int getNthUglyNo ( int n ) { int i = 1 ; int count = 1 ; while ( n > count ) { i ++ ; if ( isUgly ( i ) == 1 ) count ++ ; } return i ; }
int optimalSearchTree ( int keys [ ] , int freq [ ] , int n ) { return optCost ( freq , 0 , n - 1 ) ; }
int sum ( int freq [ ] , int i , int j ) { int s = 0 ; for ( int k = i ; k <= j ; k ++ ) { if ( k >= freq . length ) continue ; s += freq [ k ] ; } return s ; }
int optimalSearchTree ( int keys [ ] , int freq [ ] , int n ) { int cost [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) cost [ i ] [ i ] = freq [ i ] ; for ( int L = 2 ; L <= n ; L ++ ) { for ( int i = 0 ; i <= n - L + 1 ; i ++ ) { int j = i + L - 1 ; cost [ i ] [ j ] = Integer . MAX_VALUE ; for ( int r = i ; r <= j ; r ++ ) { int c = ( ( r > i ) ? cost [ i ] [ r - 1 ] : 0 ) + ( ( r < j ) ? cost [ r + 1 ] [ j ] : 0 ) + sum ( freq , i , j ) ; if ( c < cost [ i ] [ j ] ) cost [ i ] [ j ] = c ; } } } return cost [ 0 ] [ n - 1 ] ; }
boolean isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
int countParenth ( char symb [ ] , char oper [ ] , int n ) { int F [ ] [ ] = new int [ n ] [ n ] ; int T [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { F [ i ] [ i ] = ( symb [ i ] == 'F' ) ? 1 : 0 ; T [ i ] [ i ] = ( symb [ i ] == 'T' ) ? 1 : 0 ; } for ( int gap = 1 ; gap < n ; ++ gap ) { for ( int i = 0 , j = gap ; j < n ; ++ i , ++ j ) { T [ i ] [ j ] = F [ i ] [ j ] = 0 ; for ( int g = 0 ; g < gap ; g ++ ) { int k = i + g ; int tik = T [ i ] [ k ] + F [ i ] [ k ] ; int tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ; if ( oper [ k ] == '&' ) { T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ; F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == ' ' ) { F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] ; T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == '^' ) { T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ; F [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ; } } } } return T [ 0 ] [ n - 1 ] ; }
int getCount ( char keypad [ ] [ ] , int n ) { if ( keypad == null n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; int row [ ] = { 0 , 0 , - 1 , 0 , 1 } ; int col [ ] = { 0 , - 1 , 0 , 1 , 0 } ; int [ ] [ ] count = new int [ 10 ] [ n + 1 ] ; int i = 0 , j = 0 , k = 0 , move = 0 , ro = 0 , co = 0 , num = 0 ; int nextNum = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) { count [ i ] [ 0 ] = 0 ; count [ i ] [ 1 ] = 1 ; } for ( k = 2 ; k <= n ; k ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { if ( keypad [ i ] [ j ] != '*' && keypad [ i ] [ j ] != '#' ) { num = keypad [ i ] [ j ] - '0' ; count [ num ] [ k ] = 0 ; for ( move = 0 ; move < 5 ; move ++ ) { ro = i + row [ move ] ; co = j + col [ move ] ; if ( ro >= 0 && ro <= 3 && co >= 0 && co <= 2 && keypad [ ro ] [ co ] != '*' && keypad [ ro ] [ co ] != '#' ) { nextNum = keypad [ ro ] [ co ] - '0' ; count [ num ] [ k ] += count [ nextNum ] [ k - 1 ] ; } } } } } } totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) totalCount += count [ i ] [ n ] ; return totalCount ; }
int getCount ( char keypad [ ] [ ] , int n ) { if ( keypad == null n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; int [ ] odd = new int [ 10 ] ; int [ ] even = new int [ 10 ] ; int i = 0 , j = 0 , useOdd = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) odd [ i ] = 1 ; for ( j = 2 ; j <= n ; j ++ ) { useOdd = 1 - useOdd ; if ( useOdd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 8 ] ; even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] ; even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] ; even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] ; even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] ; even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] ; even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] ; even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ; even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ; even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] ; } else { odd [ 0 ] = even [ 0 ] + even [ 8 ] ; odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] ; odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] ; odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] ; odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] ; odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] ; odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] ; odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] ; odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] ; odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] ; } } totalCount = 0 ; if ( useOdd == 1 ) { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += even [ i ] ; } else { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += odd [ i ] ; } return totalCount ; }
int finalCount ( int n , int sum ) { int ans = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; }
int finalCount ( int n , int sum ) { for ( int i = 0 ; i <= 100 ; ++ i ) { for ( int j = 0 ; j <= 500 ; ++ j ) { lookup [ i ] [ j ] = - 1 ; } } int ans = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; }
void findCount ( int n , int sum ) { int start = ( int ) Math . pow ( 10 , n - 1 ) ; int end = ( int ) Math . pow ( 10 , n ) - 1 ; int count = 0 ; int i = start ; while ( i < end ) { int cur = 0 ; int temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = temp / 10 ; } if ( cur == sum ) { count ++ ; i += 9 ; } else i ++ ; } System . out . println ( count ) ; }
int countNonDecreasing ( int n ) { int dp [ ] [ ] = new int [ 10 ] [ n + 1 ] ; for ( int i = 0 ; i < 10 ; i ++ ) dp [ i ] [ 1 ] = 1 ; for ( int digit = 0 ; digit <= 9 ; digit ++ ) { for ( int len = 2 ; len <= n ; len ++ ) { for ( int x = 0 ; x <= digit ; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ i ] [ n ] ; return count ; }
long countNonDecreasing ( int n ) { int N = 10 ; long count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count /= i ; } return count ; }
int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( int x = 1 ; x <= Math . ceil ( Math . sqrt ( i ) ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } int res = dp [ n ] ; return res ; }
int minCoins ( int coins [ ] , int m , int V ) { int table [ ] = new int [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = Integer . MAX_VALUE ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( coins [ j ] <= i ) { int sub_res = table [ i - coins [ j ] ] ; if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } if ( table [ V ] == Integer . MAX_VALUE ) return - 1 ; return table [ V ] ; }
int superSeq ( String X , String Y , int m , int n ) { if ( m == 0 ) return n ; if ( n == 0 ) return m ; if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }
int superSeq ( String X , String Y , int m , int n ) { int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }
int sumOfDigitsFrom1ToN ( int n ) { int result = 0 ; for ( int x = 1 ; x <= n ; x ++ ) result += sumOfDigits ( x ) ; return result ; }
int sumOfDigits ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = x / 10 ; } return sum ; }
int sumOfDigitsFrom1ToN ( int n ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; int d = ( int ) ( Math . log10 ( n ) ) ; int a [ ] = new int [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ; int p = ( int ) ( Math . ceil ( Math . pow ( 10 , d ) ) ) ; int msd = n / p ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) ; }
int sumOfDigitsFrom1ToN ( int n ) { int d = ( int ) ( Math . log10 ( n ) ) ; int a [ ] = new int [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ; return sumOfDigitsFrom1ToNUtil ( n , a ) ; }
int countWays ( int N ) { if ( N == 1 ) return 4 ; int countB = 1 , countS = 1 , prev_countB , prev_countS ; for ( int i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; } int result = countS + countB ; return ( result * result ) ; }
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int max = 0 ; int b ; for ( b = N - 3 ; b >= 1 ; b -- ) { int curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; }
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ ] = new int [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = 0 ; for ( b = n - 3 ; b >= 1 ; b -- ) { int curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; }
int count ( int n ) { int table [ ] = new int [ n + 1 ] , i ; Arrays . fill ( table , 0 ) ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }
float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }
int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = - 1 , m2 = - 1 ; for ( count = 0 ; count <= n ; count ++ ) { if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; } if ( ar1 [ i ] <= ar2 [ j ] ) { m1 = m2 ; m2 = ar1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; }
double area ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return Math . abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; }
boolean isInside ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x , int y ) { double A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) ; double A1 = area ( x , y , x2 , y2 , x3 , y3 ) ; double A2 = area ( x1 , y1 , x , y , x3 , y3 ) ; double A3 = area ( x1 , y1 , x2 , y2 , x , y ) ; return ( A == A1 + A2 + A3 ) ; }
boolean isLucky ( int n ) { int next_position = n ; if ( counter > n ) return true ; if ( n % counter == 0 ) return false ; next_position -= next_position / counter ; counter ++ ; return isLucky ( next_position ) ; }
float squareRoot ( float n ) { float x = n ; float y = 1 ; double e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }
int maxDiffUtil ( Node t , Res res ) { if ( t == null ) return Integer . MAX_VALUE ; if ( t . left == null && t . right == null ) return t . key ; int val = Math . min ( maxDiffUtil ( t . left , res ) , maxDiffUtil ( t . right , res ) ) ; res . r = Math . max ( res . r , t . key - val ) ; return Math . min ( val , t . key ) ; }
int maxDiff ( Node root ) { Res res = new Res ( ) ; maxDiffUtil ( root , res ) ; return res . r ; }
void inorder ( Node root ) { if ( root != null ) { inorder ( root . left ) ; System . out . print ( root . key + "" ) ; inorder ( root . right ) ; } }
int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
int multiply ( int x , int y ) { if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; else return 0 ; }
int pow ( int a , int b ) { if ( b > 0 ) return multiply ( a , pow ( a , b - 1 ) ) ; else return 1 ; }
float getAvg ( float prev_avg , float x , int n ) { return ( prev_avg * n + x ) / ( n + 1 ) ; }
int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; }
int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; }
int findSmallerInRight ( String str , int low , int high ) { int countRight = 0 , i ; for ( i = low + 1 ; i <= high ; ++ i ) if ( str . charAt ( i ) < str . charAt ( low ) ) ++ countRight ; return countRight ; }
int findRank ( String str ) { int len = str . length ( ) ; int mul = fact ( len ) ; int rank = 1 ; int countRight ; for ( int i = 0 ; i < len ; ++ i ) { mul /= len - i ; countRight = findSmallerInRight ( str , i , len - 1 ) ; rank += countRight * mul ; } return rank ; }
void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { System . out . print ( C + " " ) ; C = C * ( line - i ) / i ; } System . out . println ( ) ; } }
float exponential ( int n , float x ) { float sum = 1 ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }
void printCombination ( int arr [ ] , int n , int r ) { int data [ ] = new int [ r ] ; combinationUtil ( arr , n , r , 0 , data , 0 ) ; }
int myRand ( int arr [ ] , int freq [ ] , int n ) { int prefix [ ] = new int [ n ] , i ; prefix [ 0 ] = freq [ 0 ] ; for ( i = 1 ; i < n ; ++ i ) prefix [ i ] = prefix [ i - 1 ] + freq [ i ] ; int r = ( ( int ) ( Math . random ( ) * ( 323567 ) ) % prefix [ n - 1 ] ) + 1 ; int indexc = findCeil ( prefix , r , 0 , n - 1 ) ; return arr [ indexc ] ; }
boolean isPerfectSquare ( int x ) { int s = ( int ) Math . sqrt ( x ) ; return ( s * s == x ) ; }
boolean isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
int findgroups ( int arr [ ] , int n ) { int c [ ] = new int [ ] { 0 , 0 , 0 } ; int i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }
int findTrailingZeros ( int n ) { int count = 0 ; for ( int i = 5 ; n / i >= 1 ; i *= 5 ) count += n / i ; return count ; }
int catalan ( int n ) { if ( n <= 1 ) { return 1 ; } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res += catalan ( i ) * catalan ( n - i - 1 ) ; } return res ; }
long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
void catalan ( int n ) { int cat_ = 1 ; System . out . print ( cat_ + " " ) ; for ( int i = 1 ; i < n ; i ++ ) { cat_ *= ( 4 * i - 2 ) ; cat_ /= ( i + 1 ) ; System . out . print ( cat_ + " " ) ; } }
int calcAngle ( double h , double m ) { if ( h < 0 m < 0 h > 12 m > 60 ) System . out . println ( "Wrong input" ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) { m = 0 ; h += 1 ; if ( h > 12 ) h = h - 12 ; } int hour_angle = ( int ) ( 0.5 * ( h * 60 + m ) ) ; int minute_angle = ( int ) ( 6 * m ) ; int angle = Math . abs ( hour_angle - minute_angle ) ; angle = Math . min ( 360 - angle , angle ) ; return angle ; }
int getInvCount ( int [ ] [ ] arr ) { int inv_count = 0 ; for ( int i = 0 ; i < 3 - 1 ; i ++ ) for ( int j = i + 1 ; j < 3 ; j ++ ) if ( arr [ j ] [ i ] > 0 && arr [ j ] [ i ] > arr [ i ] [ j ] ) inv_count ++ ; return inv_count ; }
boolean isSolvable ( int [ ] [ ] puzzle ) { int invCount = getInvCount ( puzzle ) ; return ( invCount % 2 == 0 ) ; }
double find ( double p ) { return Math . ceil ( Math . sqrt ( 2 * 365 * Math . log ( 1 / ( 1 - p ) ) ) ) ; }
int countSolutions ( int n ) { int res = 0 ; for ( int x = 0 ; x * x < n ; x ++ ) for ( int y = 0 ; x * x + y * y < n ; y ++ ) res ++ ; return res ; }
int countSolutions ( int n ) { int x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; }
double func ( double x ) { return ( x * x * x - x * x + 2 ) ; }
void regulaFalsi ( double a , double b ) { if ( func ( a ) * func ( b ) >= 0 ) { System . out . println ( "You have not assumed right a and b" ) ; } double c = a ; for ( int i = 0 ; i < MAX_ITER ; i ++ ) { c = ( a * func ( b ) - b * func ( a ) ) / ( func ( b ) - func ( a ) ) ; if ( func ( c ) == 0 ) break ; else if ( func ( c ) * func ( a ) < 0 ) b = c ; else a = c ; } System . out . println ( "The value of root is : " + ( int ) c ) ; }
double func ( double x ) { return x * x * x - x * x + 2 ; }
double derivFunc ( double x ) { return 3 * x * x - 2 * x ; }
void newtonRaphson ( double x ) { double h = func ( x ) / derivFunc ( x ) ; while ( Math . abs ( h ) >= EPSILON ) { h = func ( x ) / derivFunc ( x ) ; x = x - h ; } System . out . print ( "The value of the" + " root is : " + Math . round ( x * 100.0 ) / 100.0 ) ; }
int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; }
boolean oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; }
int countSetBits ( int n ) { int bitCount = 0 ; for ( int i = 1 ; i <= n ; i ++ ) bitCount += countSetBitsUtil ( i ) ; return bitCount ; }
int countSetBitsUtil ( int x ) { if ( x <= 0 ) return 0 ; return ( x % 2 == 0 ? 0 : 1 ) + countSetBitsUtil ( x / 2 ) ; }
int swapBits ( int num , int p1 , int p2 , int n ) { int shift1 , shift2 , value1 , value2 ; while ( n -- > 0 ) { shift1 = 1 << p1 ; shift2 = 1 << p2 ; value1 = ( ( num & shift1 ) ) ; value2 = ( ( num & shift2 ) ) ; if ( ( value1 == 0 && value2 != 0 ) || ( value2 == 0 && value1 != 0 ) ) { if ( value1 != 0 ) { num = num & ( ~ shift1 ) ; num = num | shift2 ; } else { num = num & ( ~ shift2 ) ; num = num | shift1 ; } } p1 ++ ; p2 ++ ; } return num ; }
int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }
int smallest ( int x , int y , int z ) { int c = 0 ; while ( x != 0 && y != 0 && z != 0 ) { x -- ; y -- ; z -- ; c ++ ; } return c ; }
int min ( int x , int y ) { return y + ( ( x - y ) & ( ( x - y ) >> ( ( Integer . SIZE / 8 ) * CHAR_BIT - 1 ) ) ) ; }
int smallest ( int x , int y , int z ) { return Math . min ( x , Math . min ( y , z ) ) ; }
int snoob ( int x ) { int rightOne , nextHigherOneBit , rightOnesPattern , next = 0 ; if ( x > 0 ) { rightOne = x & - x ; nextHigherOneBit = x + rightOne ; rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( rightOnesPattern ) / rightOne ; rightOnesPattern >>= 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; }
int addOne ( int x ) { int m = 1 ; while ( ( int ) ( x & m ) >= 1 ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
int addOne ( int x ) { return ( - ( ~ x ) ) ; }
int fun ( int n ) { return n & ( n - 1 ) ; }
int isPowerOfFour ( int n ) { int count = 0 ; int x = n & ( n - 1 ) ; if ( n > 0 && x == 0 ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; }
boolean isPowerOfFour ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ( n & 0xAAAAAAAA ) == 0 ; }
double logn ( int n , int r ) { return Math . log ( n ) / Math . log ( r ) ; }
void findPostOrderUtil ( int pre [ ] , int n , int minval , int maxval , INT preIndex ) { if ( preIndex . data == n ) return ; if ( pre [ preIndex . data ] < minval pre [ preIndex . data ] > maxval ) { return ; } int val = pre [ preIndex . data ] ; preIndex . data ++ ; findPostOrderUtil ( pre , n , minval , val , preIndex ) ; findPostOrderUtil ( pre , n , val , maxval , preIndex ) ; System . out . print ( val + " " ) ; }
void findPostOrder ( int pre [ ] , int n ) { INT preIndex = new INT ( 0 ) ; findPostOrderUtil ( pre , n , Integer . MIN_VALUE , Integer . MAX_VALUE , preIndex ) ; }
int getModulo ( int n , int d ) { return ( n & ( d - 1 ) ) ; }
int min ( int x , int y ) { return y ^ ( ( x ^ y ) & - ( x << y ) ) ; }
int max ( int x , int y ) { return x ^ ( ( x ^ y ) & - ( x << y ) ) ; }
int absbit32 ( int x , int y ) { int sub = x - y ; int mask = ( sub >> 31 ) ; return ( sub ^ mask ) - mask ; }
int max ( int x , int y ) { int abs = absbit32 ( x , y ) ; return ( x + y + abs ) / 2 ; }
int min ( int x , int y ) { int abs = absbit32 ( x , y ) ; return ( x + y - abs ) / 2 ; }
int getOddOccurrence ( int arr [ ] , int arr_size ) { int i ; for ( i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; }
int getOddOccurrence ( int arr [ ] , int n ) { HashMap < Integer , Integer > hmap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hmap . containsKey ( arr [ i ] ) ) { int val = hmap . get ( arr [ i ] ) ; hmap . put ( arr [ i ] , val + 1 ) ; } else hmap . put ( arr [ i ] , 1 ) ; } for ( Integer a : hmap . keySet ( ) ) { if ( hmap . get ( a ) % 2 != 0 ) return a ; } return - 1 ; }
int countWays ( int N , int K ) { return K * fastPow ( K - 1 , N - 1 ) ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
void initialize ( ) { BitsSetTable256 [ 0 ] = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ i / 2 ] ; } }
int countSetBits ( int N ) { int count = 0 ; for ( int i = 0 ; i < 4 * 8 ; i ++ ) { if ( ( N & ( 1 << i ) ) != 0 ) count ++ ; } return count ; }
int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { count ++ ; n &= ( n - 1 ) ; } return count ; }
int FlippedCount ( int a , int b ) { return countSetBits ( a ^ b ) ; }
int nextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
int nextPowerOf2 ( int n ) { int p = 1 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( p < n ) p <<= 1 ; return p ; }
int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }
boolean getParity ( int n ) { boolean parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 2 != 0 ) return false ; n = n / 2 ; } return true ; }
boolean isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; }
int getFirstSetBitPos ( int n ) { return ( int ) ( ( Math . log10 ( n & - n ) ) / Math . log10 ( 2 ) ) + 1 ; }
int Right_most_setbit ( int num ) { int pos = 1 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { if ( ( num & ( 1 << i ) ) == 0 ) pos ++ ; else break ; } return pos ; }
void bin ( long n ) { long i ; System . out . print ( "0" ) ; for ( i = 1 << 30 ; i > 0 ; i = i / 2 ) { if ( ( n & i ) != 0 ) { System . out . print ( "1" ) ; } else { System . out . print ( "0" ) ; } } }
int findPosition ( int n ) { if ( ! isPowerOfTwo ( n ) ) return - 1 ; int i = 1 , pos = 1 ; while ( ( i & n ) == 0 ) { i = i << 1 ; ++ pos ; } return pos ; }
boolean isPowerOfTwo ( int n ) { return n > 0 && ( ( n & ( n - 1 ) ) == 0 ) ; }
int findPosition ( int n ) { if ( ! isPowerOfTwo ( n ) ) return - 1 ; int count = 0 ; while ( n > 0 ) { n = n >> 1 ; ++ count ; } return count ; }
void swap ( int [ ] xp , int [ ] yp ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; }
void swap ( int a , int b ) { a = ( a & b ) + ( a b ) ; b = a + ( ~ b ) + 1 ; a = a + ( ~ b ) + 1 ; System . out . print ( "After swapping: a = " + a + ", b = " + b ) ; }
boolean checkSentence ( char [ ] str ) { int len = str . length ; if ( str [ 0 ] < 'A' str [ 0 ] > 'Z' ) return false ; if ( str [ len - 1 ] != '.' ) return false ; int prev_state = 0 , curr_state = 0 ; int index = 1 ; while ( index <= str . length ) { if ( str [ index ] >= 'A' && str [ index ] <= 'Z' ) curr_state = 0 ; else if ( str [ index ] == ' ' ) curr_state = 1 ; else if ( str [ index ] >= 'a' && str [ index ] <= 'z' ) curr_state = 2 ; else if ( str [ index ] == '.' ) curr_state = 3 ; if ( prev_state == curr_state && curr_state != 2 ) return false ; if ( prev_state == 2 && curr_state == 0 ) return false ; if ( curr_state == 3 && prev_state != 1 ) return ( index + 1 == str . length ) ; index ++ ; prev_state = curr_state ; } return false ; }
int maxOnesIndex ( int arr [ ] , int n ) { int max_count = 0 ; int max_index = 0 ; int prev_zero = - 1 ; int prev_prev_zero = - 1 ; for ( int curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; }
int findLength ( int arr [ ] , int n ) { int max_len = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int mn = arr [ i ] , mx = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { mn = min ( mn , arr [ j ] ) ; mx = max ( mx , arr [ j ] ) ; if ( ( mx - mn ) == j - i ) max_len = max ( max_len , mx - mn + 1 ) ; } } return max_len ; }
boolean isSubSequence ( String str1 , String str2 , int m , int n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 . charAt ( m - 1 ) == str2 . charAt ( n - 1 ) ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; }
void segregate0and1 ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) count ++ ; } for ( int i = 0 ; i < count ; i ++ ) arr [ i ] = 0 ; for ( int i = count ; i < n ; i ++ ) arr [ i ] = 1 ; }
void find3Numbers ( int [ ] nums ) { if ( nums . length < 3 ) { System . out . print ( "No such triplet found" ) ; return ; } int seq = 1 ; int min_num = nums [ 0 ] ; int max_seq = Integer . MIN_VALUE ; int store_min = min_num ; for ( int i = 1 ; i < nums . length ; i ++ ) { if ( nums [ i ] == min_num ) continue ; else if ( nums [ i ] < min_num ) { min_num = nums [ i ] ; continue ; } else if ( nums [ i ] < max_seq ) { max_seq = nums [ i ] ; store_min = min_num ; } else if ( nums [ i ] > max_seq ) { seq ++ ; if ( seq == 3 ) { System . out . println ( "Triplet: " + store_min + ", " + max_seq + ", " + nums [ i ] ) ; return ; } max_seq = nums [ i ] ; } } System . out . print ( "No such triplet found" ) ; }
int maxCircularSum ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } int curr_max = a [ 0 ] , max_so_far = a [ 0 ] , curr_min = a [ 0 ] , min_so_far = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { curr_max = Math . max ( curr_max + a [ i ] , a [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; curr_min = Math . min ( curr_min + a [ i ] , a [ i ] ) ; min_so_far = Math . min ( min_so_far , curr_min ) ; } if ( min_so_far == sum ) { return max_so_far ; } return Math . max ( max_so_far , sum - min_so_far ) ; }
int GetCeilIndex ( int arr [ ] , int T [ ] , int l , int r , int key ) { while ( r - l > 1 ) { int m = l + ( r - l ) / 2 ; if ( arr [ T [ m ] ] >= key ) r = m ; else l = m ; } return r ; }
void generateUtil ( int A [ ] , int B [ ] , int C [ ] , int i , int j , int m , int n , int len , boolean flag ) { if ( flag ) { if ( len != 0 ) printArr ( C , len + 1 ) ; for ( int k = i ; k < m ; k ++ ) { if ( len == 0 ) { C [ len ] = A [ k ] ; generateUtil ( A , B , C , k + 1 , j , m , n , len , ! flag ) ; } else if ( A [ k ] > C [ len ] ) { C [ len + 1 ] = A [ k ] ; generateUtil ( A , B , C , k + 1 , j , m , n , len + 1 , ! flag ) ; } } } else { for ( int l = j ; l < n ; l ++ ) { if ( B [ l ] > C [ len ] ) { C [ len + 1 ] = B [ l ] ; generateUtil ( A , B , C , i , l + 1 , m , n , len + 1 , ! flag ) ; } } } }
void generate ( int A [ ] , int B [ ] , int m , int n ) { int C [ ] = new int [ m + n ] ; generateUtil ( A , B , C , 0 , 0 , m , n , 0 , true ) ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; System . out . println ( "" ) ; }
void replace_elements ( int arr [ ] , int n ) { int pos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ pos ++ ] = arr [ i ] ; while ( pos > 1 && arr [ pos - 2 ] == arr [ pos - 1 ] ) { pos -- ; arr [ pos - 1 ] ++ ; } } for ( int i = 0 ; i < pos ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void arrangeString ( String str , int x , int y ) { int count_0 = 0 ; int count_1 = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '0' ) count_0 ++ ; else count_1 ++ ; } while ( count_0 > 0 count_1 > 0 ) { for ( int j = 0 ; j < x && count_0 > 0 ; j ++ ) { if ( count_0 > 0 ) { System . out . print ( "0" ) ; count_0 -- ; } } for ( int j = 0 ; j < y && count_1 > 0 ; j ++ ) { if ( count_1 > 0 ) { System . out . print ( "1" ) ; count_1 -- ; } } } }
int maxDiff ( int arr [ ] , int arr_size ) { int max_diff = arr [ 1 ] - arr [ 0 ] ; int i , j ; for ( i = 0 ; i < arr_size ; i ++ ) { for ( j = i + 1 ; j < arr_size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_diff ) max_diff = arr [ j ] - arr [ i ] ; } } return max_diff ; }
int maxDiff ( int arr [ ] , int n ) { int maxDiff = - 1 ; int maxRight = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > maxRight ) maxRight = arr [ i ] ; else { int diff = maxRight - arr [ i ] ; if ( diff > maxDiff ) { maxDiff = diff ; } } } return maxDiff ; }
int maxDiff ( int arr [ ] , int n ) { int diff = arr [ 1 ] - arr [ 0 ] ; int curr_sum = diff ; int max_sum = curr_sum ; for ( int i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; }
int maxIndexDiff ( int arr [ ] , int n ) { int maxDiff = - 1 ; int i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; }
int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; }
int findMaximum ( int arr [ ] , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; else return findMaximum ( arr , mid + 1 , high ) ; }
void constructLowerArray ( int arr [ ] , int countSmaller [ ] , int n ) { int i , j ; for ( i = 0 ; i < n ; i ++ ) countSmaller [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] < arr [ i ] ) countSmaller [ i ] ++ ; } } }
void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + " " ) ; System . out . println ( "" ) ; }
int findMissingPositive ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) { int x = Math . abs ( arr [ i ] ) ; if ( x - 1 < size && arr [ x - 1 ] > 0 ) arr [ x - 1 ] = - arr [ x - 1 ] ; } for ( i = 0 ; i < size ; i ++ ) if ( arr [ i ] > 0 ) return i + 1 ; return size + 1 ; }
int findMissing ( int arr [ ] , int size ) { int shift = segregate ( arr , size ) ; int arr2 [ ] = new int [ size - shift ] ; int j = 0 ; for ( int i = shift ; i < size ; i ++ ) { arr2 [ j ] = arr [ i ] ; j ++ ; } return findMissingPositive ( arr2 , j ) ; }
void fillDepth ( int parent [ ] , int i , int depth [ ] ) { if ( depth [ i ] != 0 ) { return ; } if ( parent [ i ] == - 1 ) { depth [ i ] = 1 ; return ; } if ( depth [ parent [ i ] ] == 0 ) { fillDepth ( parent , parent [ i ] , depth ) ; } depth [ i ] = depth [ parent [ i ] ] + 1 ; }
int maxRepeating ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) arr [ ( arr [ i ] % k ) ] += k ; int max = arr [ 0 ] , result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; }
int maxPathSum ( int ar1 [ ] , int ar2 [ ] , int m , int n ) { int i = 0 , j = 0 ; int result = 0 , sum1 = 0 , sum2 = 0 ; while ( i < m && j < n ) { if ( ar1 [ i ] < ar2 [ j ] ) sum1 += ar1 [ i ++ ] ; else if ( ar1 [ i ] > ar2 [ j ] ) sum2 += ar2 [ j ++ ] ; else { result += max ( sum1 , sum2 ) + ar1 [ i ] ; sum1 = 0 ; sum2 = 0 ; i ++ ; j ++ ; } } while ( i < m ) sum1 += ar1 [ i ++ ] ; while ( j < n ) sum2 += ar2 [ j ++ ] ; result += max ( sum1 , sum2 ) ; return result ; }
void smallestGreater ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int diff = Integer . MAX_VALUE ; int closest = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] && arr [ j ] - arr [ i ] < diff ) { diff = arr [ j ] - arr [ i ] ; closest = j ; } } if ( closest == - 1 ) System . out . print ( "_ " ) ; else System . out . print ( arr [ closest ] + " " ) ; } }
void smallestGreater ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . add ( arr [ i ] ) ; Vector < Integer > newAr = new Vector < > ( ) ; for ( int p : s ) { newAr . add ( p ) ; } for ( int i = 0 ; i < n ; i ++ ) { int temp = lowerBound ( newAr , 0 , newAr . size ( ) , arr [ i ] ) ; if ( temp < n ) System . out . print ( newAr . get ( temp ) + " " ) ; else System . out . print ( "_ " ) ; } }
long arraySum ( int arr [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum ; }
long maxDiff ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; long arraysum = arraySum ( arr , n ) ; long diff1 = Math . abs ( arraysum - 2 * arraySum ( arr , k ) ) ; int end = arr . length - 1 ; int start = 0 ; while ( start < end ) { int temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; start ++ ; end -- ; } long diff2 = Math . abs ( arraysum - 2 * arraySum ( arr , k ) ) ; return ( Math . max ( diff1 , diff2 ) ) ; }
int minNumber ( int a [ ] , int n , int x ) { Arrays . sort ( a ) ; int k ; for ( k = 0 ; a [ ( n ) / 2 ] != x ; k ++ ) { a [ n ++ ] = x ; Arrays . sort ( a ) ; } return k ; }
int minNumber ( int a [ ] , int n , int x ) { int l = 0 , h = 0 , e = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == x ) e ++ ; else if ( a [ i ] > x ) h ++ ; else if ( a [ i ] < x ) l ++ ; } int ans = 0 ; if ( l > h ) ans = l - h ; else if ( l < h ) ans = h - l - 1 ; return ans + 1 - e ; }
int fun ( int x ) { int y = ( x / 4 ) * 4 ; int ans = 0 ; for ( int i = y ; i <= x ; i ++ ) ans ^= i ; return ans ; }
int query ( int x ) { if ( x == 0 ) return 0 ; int k = ( x + 1 ) / 2 ; return ( ( x %= 2 ) != 0 ) ? 2 * fun ( k ) : ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) ; }
void preprocess ( int arr [ ] , int N , int left [ ] , int right [ ] ) { left [ 0 ] = 0 ; int lastIncr = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) lastIncr = i ; left [ i ] = lastIncr ; } right [ N - 1 ] = N - 1 ; int firstDecr = N - 1 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > arr [ i + 1 ] ) firstDecr = i ; right [ i ] = firstDecr ; } }
boolean isSubarrayMountainForm ( int arr [ ] , int left [ ] , int right [ ] , int L , int R ) { return ( right [ L ] >= left [ R ] ) ; }
void sieveOfEratosthenes ( boolean isPrime [ ] ) { isPrime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) isPrime [ i ] = false ; } } }
int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; }
int queryPrimesUtil ( int [ ] st , int ss , int se , int qs , int qe , int index ) { if ( qs <= ss && qe >= se ) return st [ index ] ; if ( se < qs ss > qe ) return 0 ; int mid = getMid ( ss , se ) ; return queryPrimesUtil ( st , ss , mid , qs , qe , 2 * index + 1 ) + queryPrimesUtil ( st , mid + 1 , se , qs , qe , 2 * index + 2 ) ; }
void updateValueUtil ( int [ ] st , int ss , int se , int i , int diff , int si ) { if ( i < ss i > se ) return ; st [ si ] = st [ si ] + diff ; if ( se != ss ) { int mid = getMid ( ss , se ) ; updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) ; updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) ; } }
void updateValue ( int arr [ ] , int [ ] st , int n , int i , int new_val , boolean isPrime [ ] ) { if ( i < 0 i > n - 1 ) { System . out . println ( "Invalid Input" ) ; return ; } int diff = 0 ; int oldValue ; oldValue = arr [ i ] ; arr [ i ] = new_val ; if ( isPrime [ oldValue ] && isPrime [ new_val ] ) return ; if ( ( ! isPrime [ oldValue ] ) && ( ! isPrime [ new_val ] ) ) return ; if ( isPrime [ oldValue ] && ! isPrime [ new_val ] ) { diff = - 1 ; } if ( ! isPrime [ oldValue ] && isPrime [ new_val ] ) { diff = 1 ; } updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) ; }
int constructSTUtil ( int arr [ ] , int ss , int se , int [ ] st , int si , boolean isPrime [ ] ) { if ( ss == se ) { if ( isPrime [ arr [ ss ] ] ) st [ si ] = 1 ; else st [ si ] = 0 ; return st [ si ] ; } int mid = getMid ( ss , se ) ; st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 , isPrime ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 , isPrime ) ; return st [ si ] ; }
void checkEVENodd ( int arr [ ] , int n , int l , int r ) { if ( arr [ r ] == 1 ) System . out . println ( "odd" ) ; else System . out . println ( "even" ) ; }
int findMean ( int arr [ ] , int l , int r ) { int sum = 0 , count = 0 ; for ( int i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; } int mean = ( int ) Math . floor ( sum / count ) ; return mean ; }
void calculatePrefixSum ( int arr [ ] , int n ) { prefixSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] ; }
int findMean ( int l , int r ) { if ( l == 0 ) return ( int ) Math . floor ( prefixSum [ r ] / ( r + 1 ) ) ; return ( int ) Math . floor ( ( prefixSum [ r ] - prefixSum [ l - 1 ] ) / ( r - l + 1 ) ) ; }
void updateQuery ( int arr [ ] , int n , int q , int l , int r , int k ) { if ( q == 0 ) { arr [ l - 1 ] += k ; arr [ r ] += - k ; } else { arr [ l - 1 ] += - k ; arr [ r ] += k ; } return ; }
void generateArray ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; ++ i ) arr [ i ] += arr [ i - 1 ] ; }
int calculateProduct ( int [ ] A , int L , int R , int P ) { L = L - 1 ; R = R - 1 ; int ans = 1 ; for ( int i = L ; i <= R ; i ++ ) { ans = ans * A [ i ] ; ans = ans % P ; } return ans ; }
int modInverse ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; }
void calculate_Pre_Product ( int A [ ] , int N , int P ) { pre_product [ 0 ] = A [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { pre_product [ i ] = pre_product [ i - 1 ] * A [ i ] ; pre_product [ i ] = pre_product [ i ] % P ; } }
void calculate_inverse_product ( int A [ ] , int N , int P ) { inverse_product [ 0 ] = modInverse ( pre_product [ 0 ] , P ) ; for ( int i = 1 ; i < N ; i ++ ) inverse_product [ i ] = modInverse ( pre_product [ i ] , P ) ; }
int calculateProduct ( int A [ ] , int L , int R , int P ) { L = L - 1 ; R = R - 1 ; int ans ; if ( L == 0 ) ans = pre_product [ R ] ; else ans = pre_product [ R ] * inverse_product [ L - 1 ] ; return ans ; }
void buildPrefix ( ) { boolean prime [ ] = new boolean [ MAX + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } prefix [ 0 ] = prefix [ 1 ] = 0 ; for ( int p = 2 ; p <= MAX ; p ++ ) { prefix [ p ] = prefix [ p - 1 ] ; if ( prime [ p ] ) prefix [ p ] ++ ; } }
int query ( int L , int R ) { return prefix [ R ] - prefix [ L - 1 ] ; }
void command ( boolean arr [ ] , int a , int b ) { arr [ a ] ^= true ; arr [ b + 1 ] ^= true ; }
void incrementByD ( int [ ] arr , query [ ] q_arr , int n , int m , int d ) { int [ ] sum = new int [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { sum [ q_arr [ i ] . start ] += d ; if ( ( q_arr [ i ] . end + 1 ) < n ) sum [ q_arr [ i ] . end + 1 ] -= d ; } arr [ 0 ] += sum [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum [ i ] += sum [ i - 1 ] ; arr [ i ] += sum [ i ] ; } }
void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
double probability ( int a [ ] , int b [ ] , int size1 , int size2 ) { int max1 = Integer . MIN_VALUE , count1 = 0 ; for ( int i = 0 ; i < size1 ; i ++ ) { if ( a [ i ] > max1 ) { max1 = a [ i ] ; count1 = 1 ; } else if ( a [ i ] == max1 ) { count1 ++ ; } } int max2 = Integer . MIN_VALUE , count2 = 0 ; for ( int i = 0 ; i < size2 ; i ++ ) { if ( b [ i ] > max2 ) { max2 = b [ i ] ; count2 = 1 ; } else if ( b [ i ] == max2 ) { count2 ++ ; } } return ( double ) ( count1 * count2 ) / ( size1 * size2 ) ; }
int countDe ( int arr [ ] , int n ) { int v [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) v [ i ] = arr [ i ] ; Arrays . sort ( arr ) ; int count1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count1 ++ ; Collections . reverse ( Arrays . asList ( arr ) ) ; int count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count2 ++ ; return ( Math . min ( count1 , count2 ) ) ; }
int printMinimumProduct ( int arr [ ] , int n ) { int first_min = Math . min ( arr [ 0 ] , arr [ 1 ] ) ; int second_min = Math . max ( arr [ 0 ] , arr [ 1 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] < first_min ) { second_min = first_min ; first_min = arr [ i ] ; } else if ( arr [ i ] < second_min ) second_min = arr [ i ] ; } return first_min * second_min ; }
long noOfTriples ( long arr [ ] , int n ) { Arrays . sort ( arr ) ; long count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == arr [ 2 ] ) count ++ ; if ( arr [ 0 ] == arr [ 2 ] ) return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 ; else if ( arr [ 1 ] == arr [ 2 ] ) return ( count - 1 ) * ( count ) / 2 ; return count ; }
boolean checkReverse ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { temp [ i ] = arr [ i ] ; } Arrays . sort ( temp ) ; int front ; for ( front = 0 ; front < n ; front ++ ) { if ( temp [ front ] != arr [ front ] ) { break ; } } int back ; for ( back = n - 1 ; back >= 0 ; back -- ) { if ( temp [ back ] != arr [ back ] ) { break ; } } if ( front >= back ) { return true ; } do { front ++ ; if ( arr [ front - 1 ] < arr [ front ] ) { return false ; } } while ( front != back ) ; return true ; }
boolean checkReverse ( int arr [ ] , int n ) { if ( n == 1 ) { return true ; } int i ; for ( i = 1 ; arr [ i - 1 ] < arr [ i ] && i < n ; i ++ ) ; if ( i == n ) { return true ; } int j = i ; while ( j < n && arr [ j ] < arr [ j - 1 ] ) { if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) { return false ; } j ++ ; } if ( j == n ) { return true ; } int k = j ; if ( arr [ k ] < arr [ i - 1 ] ) { return false ; } while ( k > 1 && k < n ) { if ( arr [ k ] < arr [ k - 1 ] ) { return false ; } k ++ ; } return true ; }
void sortExceptUandL ( int a [ ] , int l , int u , int n ) { int b [ ] = new int [ n - ( u - l + 1 ) ] ; for ( int i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; Arrays . sort ( b ) ; for ( int i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; }
int findMinSwaps ( int arr [ ] , int n ) { int noOfZeroes [ ] = new int [ n ] ; int i , count = 0 ; noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { noOfZeroes [ i ] = noOfZeroes [ i + 1 ] ; if ( arr [ i ] == 0 ) noOfZeroes [ i ] ++ ; } for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) count += noOfZeroes [ i ] ; } return count ; }
void printList ( Node head ) { while ( head != null ) { System . out . print ( head . data + "->" ) ; head = head . next ; } }
void sortlist ( int arr [ ] , int N , Node head ) { HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; Node temp = head ; while ( temp != null ) { if ( hash . containsKey ( temp . data ) ) hash . put ( temp . data , hash . get ( temp . data ) + 1 ) ; else hash . put ( temp . data , 1 ) ; temp = temp . next ; } temp = head ; for ( int i = 0 ; i < N ; i ++ ) { int frequency = hash . get ( arr [ i ] ) ; while ( frequency -- > 0 ) { temp . data = arr [ i ] ; temp = temp . next ; } } }
void printRepeating ( Integer [ ] arr , int size ) { SortedSet < Integer > s = new TreeSet < > ( ) ; Collections . addAll ( s , arr ) ; System . out . print ( s ) ; }
int min_noOf_operation ( int arr [ ] , int n , int k ) { int noOfSubtraction ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; }
int maxSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; }
int countPairs ( int a [ ] , int n , int k ) { Arrays . sort ( a ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n && a [ j ] - a [ i ] < k ) { res ++ ; j ++ ; } } return res ; }
void sortedMerge ( int a [ ] , int b [ ] , int res [ ] , int n , int m ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int i = 0 , j = 0 , k = 0 ; while ( i < n && j < m ) { if ( a [ i ] <= b [ j ] ) { res [ k ] = a [ i ] ; i += 1 ; k += 1 ; } else { res [ k ] = b [ j ] ; j += 1 ; k += 1 ; } } while ( i < n ) { res [ k ] = a [ i ] ; i += 1 ; k += 1 ; } while ( j < m ) { res [ k ] = b [ j ] ; j += 1 ; k += 1 ; } }
int findMaxPairs ( int a [ ] , int b [ ] , int n , int k ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; boolean [ ] flag = new boolean [ n ] ; Arrays . fill ( flag , false ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( Math . abs ( a [ i ] - b [ j ] ) <= k && flag [ j ] == false ) { result ++ ; flag [ j ] = true ; break ; } } } return result ; }
int findMaxPairs ( int a [ ] , int b [ ] , int n , int k ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int result = 0 ; for ( int i = 0 , j = 0 ; i < n && j < n ; ) { if ( Math . abs ( a [ i ] - b [ j ] ) <= k ) { result ++ ; i ++ ; j ++ ; } else if ( a [ i ] > b [ j ] ) j ++ ; else i ++ ; } return result ; }
int sumOfMinAbsDifferences ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int sum = 0 ; sum += Math . abs ( arr [ 0 ] - arr [ 1 ] ) ; sum += Math . abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) sum += Math . min ( Math . abs ( arr [ i ] - arr [ i - 1 ] ) , Math . abs ( arr [ i ] - arr [ i + 1 ] ) ) ; return sum ; }
int findSmallestDifference ( int A [ ] , int B [ ] , int m , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; int a = 0 , b = 0 ; int result = Integer . MAX_VALUE ; while ( a < m && b < n ) { if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
boolean arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }
void findLarger ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = n - 1 ; i >= n / 2 ; i -- ) System . out . print ( arr [ i ] + " " ) ; }
int minSwapsToSort ( int arr [ ] , int n ) { ArrayList < ArrayList < Integer > > arrPos = new ArrayList < ArrayList < Integer > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { arrPos . add ( new ArrayList < Integer > ( Arrays . asList ( arr [ i ] , i ) ) ) ; } Collections . sort ( arrPos , new Comparator < ArrayList < Integer > > ( ) { @ Override public int compare ( ArrayList < Integer > o1 , ArrayList < Integer > o2 ) { return o1 . get ( 0 ) . compareTo ( o2 . get ( 0 ) ) ; } } ) ; boolean [ ] vis = new boolean [ n ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || arrPos . get ( i ) . get ( 1 ) == i ) continue ; int cycle_size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = true ; j = arrPos . get ( j ) . get ( 1 ) ; cycle_size ++ ; } ans += ( cycle_size - 1 ) ; } return ans ; }
int minSwapToMakeArraySame ( int a [ ] , int b [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp . put ( b [ i ] , i ) ; } for ( int i = 0 ; i < n ; i ++ ) b [ i ] = mp . get ( a [ i ] ) ; return minSwapsToSort ( b , n ) ; }
int singleelement ( int arr [ ] , int n ) { int low = 0 , high = n - 2 ; int mid ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( arr [ mid ] == arr [ mid ^ 1 ] ) { low = mid + 1 ; } else { high = mid - 1 ; } } return arr [ low ] ; }
int getMissingNo ( int a [ ] , int n ) { int n_elements_sum = n * ( n + 1 ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += a [ i ] ; return n_elements_sum - sum ; }
int countOccurrences ( int arr [ ] , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; }
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r < l ) return - 1 ; int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; }
int countOccurrences ( int arr [ ] , int n , int x ) { int ind = binarySearch ( arr , 0 , n - 1 , x ) ; if ( ind == - 1 ) return 0 ; int count = 1 ; int left = ind - 1 ; while ( left >= 0 && arr [ left ] == x ) { count ++ ; left -- ; } int right = ind + 1 ; while ( right < n && arr [ right ] == x ) { count ++ ; right ++ ; } return count ; }
void printClosest ( int arr [ ] , int n , int x ) { int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 , diff = Integer . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } System . out . println ( " The closest pair is " + arr [ res_l ] + " and " + arr [ res_r ] ) ; }
int countOnes ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
int findMissingUtil ( int arr1 [ ] , int arr2 [ ] , int N ) { if ( N == 1 ) return arr1 [ 0 ] ; if ( arr1 [ 0 ] != arr2 [ 0 ] ) return arr1 [ 0 ] ; int lo = 0 , hi = N - 1 ; while ( lo < hi ) { int mid = ( lo + hi ) / 2 ; if ( arr1 [ mid ] == arr2 [ mid ] ) lo = mid ; else hi = mid ; if ( lo == hi - 1 ) break ; } return arr1 [ hi ] ; }
void printTwoElements ( int arr [ ] , int size ) { int i ; System . out . print ( "The repeating element is " ) ; for ( i = 0 ; i < size ; i ++ ) { int abs_val = Math . abs ( arr [ i ] ) ; if ( arr [ abs_val - 1 ] > 0 ) arr [ abs_val - 1 ] = - arr [ abs_val - 1 ] ; else System . out . println ( abs_val ) ; } System . out . print ( "And the missing element is " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) System . out . println ( i + 1 ) ; } }
void findFourElements ( int A [ ] , int n , int X ) { for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k + 1 ; l < n ; l ++ ) { if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) System . out . print ( A [ i ] + " " + A [ j ] + " " + A [ k ] + " " + A [ l ] ) ; } } } } }
void findFourElements ( int arr [ ] , int n , int X ) { HashMap < Integer , pair > mp = new HashMap < Integer , pair > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) mp . put ( arr [ i ] + arr [ j ] , new pair ( i , j ) ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( mp . containsKey ( X - sum ) ) { pair p = mp . get ( X - sum ) ; if ( p . first != i && p . first != j && p . second != i && p . second != j ) { System . out . print ( arr [ i ] + ", " + arr [ j ] + ", " + arr [ p . first ] + ", " + arr [ p . second ] ) ; return ; } } } } }
int findMajority ( int arr [ ] , int n ) { return arr [ n / 2 ] ; }
void minAdjDifference ( int arr [ ] , int n ) { if ( n < 2 ) return ; int res = Math . abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < n ; i ++ ) res = Math . min ( res , Math . abs ( arr [ i ] - arr [ i - 1 ] ) ) ; res = Math . min ( res , Math . abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; System . out . print ( "Min Difference = " + res ) ; }
int getMin ( int arr [ ] , int n ) { return Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; }
int getMax ( int arr [ ] , int n ) { return Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; }
int deleteElement ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) break ; if ( i < n ) { n = n - 1 ; for ( int j = i ; j < n ; j ++ ) arr [ j ] = arr [ j + 1 ] ; } return n ; }
int deleteElement ( int arr [ ] , int n , int x ) { if ( arr [ n - 1 ] == x ) return ( n - 1 ) ; int prev = arr [ n - 1 ] , i ; for ( i = n - 2 ; i >= 0 && arr [ i ] != x ; i -- ) { int curr = arr [ i ] ; arr [ i ] = prev ; prev = curr ; } if ( i < 0 ) return 0 ; arr [ i ] = prev ; return ( n - 1 ) ; }
int maxWater ( int [ ] arr , int n ) { int res = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int left = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) { left = Math . max ( left , arr [ j ] ) ; } int right = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { right = Math . max ( right , arr [ j ] ) ; } res += Math . min ( left , right ) - arr [ i ] ; } return res ; }
int findWater ( int arr [ ] , int n ) { int result = 0 ; int left_max = 0 , right_max = 0 ; int lo = 0 , hi = n - 1 ; while ( lo <= hi ) { if ( arr [ lo ] < arr [ hi ] ) { if ( arr [ lo ] > left_max ) left_max = arr [ lo ] ; else result += left_max - arr [ lo ] ; lo ++ ; } else { if ( arr [ hi ] > right_max ) right_max = arr [ hi ] ; else result += right_max - arr [ hi ] ; hi -- ; } } return result ; }
int maxWater ( int arr [ ] , int n ) { int size = n - 1 ; int prev = arr [ 0 ] ; int prev_index = 0 ; int water = 0 ; int temp = 0 ; for ( int i = 1 ; i <= size ; i ++ ) { if ( arr [ i ] >= prev ) { prev = arr [ i ] ; prev_index = i ; temp = 0 ; } else { water += prev - arr [ i ] ; temp += prev - arr [ i ] ; } } if ( prev_index < size ) { water -= temp ; prev = arr [ size ] ; for ( int i = size ; i >= prev_index ; i -- ) { if ( arr [ i ] >= prev ) { prev = arr [ i ] ; } else { water += prev - arr [ i ] ; } } } return water ; }
int maxWater ( int [ ] arr , int n ) { int left = 0 ; int right = n - 1 ; int l_max = 0 ; int r_max = 0 ; int result = 0 ; while ( left <= right ) { if ( r_max <= l_max ) { result += Math . max ( 0 , r_max - arr [ right ] ) ; r_max = Math . max ( r_max , arr [ right ] ) ; right -= 1 ; } else { result += Math . max ( 0 , l_max - arr [ left ] ) ; l_max = Math . max ( l_max , arr [ left ] ) ; left += 1 ; } } return result ; }
int missingK ( int [ ] a , int k , int n ) { int difference = 0 , ans = 0 , count = k ; boolean flag = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ; if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { difference += ( a [ i + 1 ] - a [ i ] ) - 1 ; if ( difference >= count ) { ans = a [ i ] + count ; flag = true ; break ; } else count -= difference ; } } if ( flag ) return ans ; else return - 1 ; }
int leastFrequent ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int min_count = n + 1 , res = - 1 ; int curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count < min_count ) { min_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count < min_count ) { min_count = curr_count ; res = arr [ n - 1 ] ; } return res ; }
int leastFrequent ( int arr [ ] , int n ) { Map < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int key = arr [ i ] ; if ( count . containsKey ( key ) ) { int freq = count . get ( key ) ; freq ++ ; count . put ( key , freq ) ; } else count . put ( key , 1 ) ; } int min_count = n + 1 , res = - 1 ; for ( Entry < Integer , Integer > val : count . entrySet ( ) ) { if ( min_count >= val . getValue ( ) ) { res = val . getKey ( ) ; min_count = val . getValue ( ) ; } } return res ; }
int maximumSum ( int a [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) sort ( a , i , n ) ; int sum = a [ n - 1 ] [ M - 1 ] ; int prev = a [ n - 1 ] [ M - 1 ] ; int i , j ; for ( i = n - 2 ; i >= 0 ; i -- ) { for ( j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i ] [ j ] < prev ) { prev = a [ i ] [ j ] ; sum += prev ; break ; } } if ( j == - 1 ) return 0 ; } return sum ; }
int maximumSum ( int a [ ] [ ] , int n ) { int prev = Math . max ( a [ n - 1 ] [ 0 ] , a [ n - 1 ] [ M - 1 ] + 1 ) ; int sum = prev ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int max_smaller = Integer . MIN_VALUE ; for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i ] [ j ] < prev && a [ i ] [ j ] > max_smaller ) max_smaller = a [ i ] [ j ] ; } if ( max_smaller == Integer . MIN_VALUE ) return 0 ; prev = max_smaller ; sum += max_smaller ; } return sum ; }
int findValue ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == k ) k *= 2 ; return k ; }
int findSmallest ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] >= 1 ) break ; if ( j == n ) return a [ i ] ; } return - 1 ; }
int findSmallest ( int a [ ] , int n ) { int smallest = min_element ( a ) ; for ( int i = 1 ; i < n ; i ++ ) if ( a [ i ] % smallest >= 1 ) return - 1 ; return smallest ; }
int CalculateMax ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int min_sum = arr [ 0 ] + arr [ 1 ] ; int max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return ( Math . abs ( max_sum - min_sum ) ) ; }
void printMinDiffPairs ( int arr [ ] , int n ) { if ( n <= 1 ) return ; Arrays . sort ( arr ) ; int minDiff = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) minDiff = Math . min ( minDiff , arr [ i ] - arr [ i - 1 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) { System . out . print ( "(" + arr [ i - 1 ] + ", " + arr [ i ] + ")," ) ; } } }
int calculateDiff ( int i , int j , int [ ] array ) { return Math . abs ( array [ i ] - array [ j ] ) + Math . abs ( i - j ) ; }
int extrema ( int a [ ] , int n ) { int count = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) count += 1 ; if ( a [ i ] < a [ i - 1 ] && a [ i ] < a [ i + 1 ] ) count += 1 ; } return count ; }
int getClosest ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; }
int sum ( int a [ ] , int n ) { int maxVal = a [ 0 ] , maxCount = 1 ; int secondMax = Integer . MIN_VALUE , secondMaxCount = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == maxVal ) maxCount ++ ; else if ( a [ i ] > maxVal ) { secondMax = maxVal ; secondMaxCount = maxCount ; maxVal = a [ i ] ; maxCount = 1 ; } else if ( a [ i ] == secondMax ) { secondMax = a [ i ] ; secondMaxCount ++ ; } else if ( a [ i ] > secondMax ) { secondMax = a [ i ] ; secondMaxCount = 1 ; } } if ( maxCount > 1 ) return maxCount * ( maxCount - 1 ) / 2 ; return secondMaxCount ; }
void printSmall ( int arr [ ] , int asize , int n ) { int [ ] copy_arr = Arrays . copyOf ( arr , asize ) ; Arrays . sort ( copy_arr ) ; for ( int i = 0 ; i < asize ; ++ i ) { if ( Arrays . binarySearch ( copy_arr , 0 , n , arr [ i ] ) > - 1 ) System . out . print ( arr [ i ] + " " ) ; } }
void printKMissing ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; int i = 0 ; while ( i < n && arr [ i ] <= 0 ) i ++ ; int count = 0 , curr = 1 ; while ( count < k && i < n ) { if ( arr [ i ] != curr ) { System . out . print ( curr + " " ) ; count ++ ; } else i ++ ; curr ++ ; } while ( count < k ) { System . out . print ( curr + " " ) ; curr ++ ; count ++ ; } }
void printmissingk ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > d = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) d . put ( arr [ i ] , arr [ i ] ) ; int cnt = 1 ; int fl = 0 ; for ( int i = 0 ; i < ( n + k ) ; i ++ ) { if ( ! d . containsKey ( cnt ) ) { fl += 1 ; System . out . print ( cnt + " " ) ; if ( fl == k ) break ; } cnt += 1 ; } }
boolean checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; Arrays . sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
int minProductSubset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int negmax = Integer . MIN_VALUE ; int posmin = Integer . MAX_VALUE ; int count_neg = 0 , count_zero = 0 ; int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; negmax = Math . max ( negmax , a [ i ] ) ; } if ( a [ i ] > 0 && a [ i ] < posmin ) posmin = a [ i ] ; product *= a [ i ] ; } if ( count_zero == n || ( count_neg == 0 && count_zero > 0 ) ) return 0 ; if ( count_neg == 0 ) return posmin ; if ( count_neg % 2 == 0 && count_neg != 0 ) { product = product / negmax ; } return product ; }
int countPairs ( int a [ ] , int n ) { int mn = Integer . MAX_VALUE ; int mx = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { mn = Math . min ( mn , a [ i ] ) ; mx = Math . max ( mx , a [ i ] ) ; } int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == mn ) c1 ++ ; if ( a [ i ] == mx ) c2 ++ ; } if ( mn == mx ) return n * ( n - 1 ) / 2 ; else return c1 * c2 ; }
int findElement ( int a [ ] , int n , int b ) { Arrays . sort ( a ) ; int max = a [ n - 1 ] ; while ( b < max ) { if ( Arrays . binarySearch ( a , b ) > - 1 ) b *= 2 ; else return b ; } return b ; }
void printList ( Node node ) { while ( node != null ) { System . out . print ( node . data + " " ) ; node = node . next ; } System . out . println ( ) ; }
void rearrangeOddEven ( Node head ) { Stack < Node > odd = new Stack < Node > ( ) ; Stack < Node > even = new Stack < Node > ( ) ; int i = 1 ; while ( head != null ) { if ( head . data % 2 != 0 && i % 2 == 0 ) { odd . push ( head ) ; } else if ( head . data % 2 == 0 && i % 2 != 0 ) { even . push ( head ) ; } head = head . next ; i ++ ; } while ( odd . size ( ) > 0 && even . size ( ) > 0 ) { int k = odd . peek ( ) . data ; odd . peek ( ) . data = even . peek ( ) . data ; even . peek ( ) . data = k ; odd . pop ( ) ; even . pop ( ) ; } }
void printList ( Node node ) { while ( node != null ) { System . out . print ( node . data + " " ) ; node = node . next ; } }
void display ( Node head ) { Node curr = head ; while ( curr != null ) { System . out . printf ( "%d " , curr . data ) ; curr = curr . next ; } }
int addWithCarry ( Node head ) { if ( head == null ) return 1 ; int res = head . data + addWithCarry ( head . next ) ; head . data = ( res ) % 10 ; return ( res ) / 10 ; }
void populateArbit ( Node head ) { if ( head == null ) return ; if ( head . next == null ) { maxNode = head ; return ; } populateArbit ( head . next ) ; head . arbit = maxNode ; if ( head . data > maxNode . data ) maxNode = head ; return ; }
void deleteLast ( Node head , int x ) { Node temp = head , ptr = null ; while ( temp != null ) { if ( temp . data == x ) ptr = temp ; temp = temp . next ; } if ( ptr != null && ptr . next == null ) { temp = head ; while ( temp . next != ptr ) temp = temp . next ; temp . next = null ; } if ( ptr != null && ptr . next != null ) { ptr . data = ptr . next . data ; temp = ptr . next ; ptr . next = ptr . next . next ; System . gc ( ) ; } }
int getLength ( Node node ) { int size = 0 ; while ( node != null ) { node = node . next ; size ++ ; } return size ; }
boolean isPalindromeUtil ( Node head , Node loop_start ) { Node ptr = head ; Stack < Integer > s = new Stack < Integer > ( ) ; int count = 0 ; while ( ptr != loop_start count != 1 ) { s . push ( ptr . data ) ; if ( ptr == loop_start ) count = 1 ; ptr = ptr . next ; } ptr = head ; count = 0 ; while ( ptr != loop_start count != 1 ) { if ( ptr . data == s . peek ( ) ) s . pop ( ) ; else return false ; if ( ptr == loop_start ) count = 1 ; ptr = ptr . next ; } return true ; }
boolean isPalindrome ( Node head ) { Node loop_start = detectAndgetLoopstarting ( head ) ; return isPalindromeUtil ( head , loop_start ) ; }
int countCommon ( Node a , Node b ) { int count = 0 ; for ( ; a != null && b != null ; a = a . next , b = b . next ) if ( a . data == b . data ) ++ count ; else break ; return count ; }
int maxPalindrome ( Node head ) { int result = 0 ; Node prev = null , curr = head ; while ( curr != null ) { Node next = curr . next ; curr . next = prev ; result = Math . max ( result , 2 * countCommon ( prev , next ) + 1 ) ; result = Math . max ( result , 2 * countCommon ( curr , next ) ) ; prev = curr ; curr = next ; } return result ; }
void displayList ( Node head ) { Node temp = head ; while ( temp != null ) { System . out . print ( temp . data + " " ) ; temp = temp . next ; } }
int LinkedListLength ( Node head ) { while ( head != null && head . next != null ) { head = head . next . next ; } if ( head == null ) return 0 ; return 1 ; }
void push ( Node head , int info ) { Node node = new Node ( ) ; node . data = info ; node . next = ( head ) ; ( head ) = node ; }
int sumOfLastN_NodesUtil ( Node head , int n ) { if ( n <= 0 ) return 0 ; Stack < Integer > st = new Stack < Integer > ( ) ; int sum = 0 ; while ( head != null ) { st . push ( head . data ) ; head = head . next ; } while ( n -- > 0 ) { sum += st . peek ( ) ; st . pop ( ) ; } return sum ; }
void push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; head = head_ref ; }
int sumOfLastN_NodesUtil ( Node head , int n ) { if ( n <= 0 ) return 0 ; int sum = 0 , len = 0 ; Node temp = head ; while ( temp != null ) { len ++ ; temp = temp . next ; } int c = len - n ; temp = head ; while ( temp != null && c -- > 0 ) { temp = temp . next ; } while ( temp != null ) { sum += temp . data ; temp = temp . next ; } return sum ; }
void printList ( Node node ) { while ( node != null ) { System . out . printf ( "%d " , node . data ) ; node = node . next ; } }
void printList ( Node node ) { while ( node != null ) { System . out . print ( node . data + " " ) ; node = node . next ; } }
void printList ( Node head ) { while ( head != null ) { System . out . print ( head . data + " " ) ; head = head . next ; } }
void printList ( Node head ) { while ( head != null ) { System . out . print ( head . data + " " ) ; head = head . next ; } }
void insertAfterNthNode ( Node head , int n , int x ) { if ( head == null ) return ; Node newNode = getNode ( x ) ; Node slow_ptr = head ; Node fast_ptr = head ; for ( int i = 1 ; i <= n - 1 ; i ++ ) fast_ptr = fast_ptr . next ; while ( fast_ptr . next != null ) { slow_ptr = slow_ptr . next ; fast_ptr = fast_ptr . next ; } newNode . next = slow_ptr . next ; slow_ptr . next = newNode ; }
void printList ( Node head ) { while ( head != null ) { System . out . print ( head . data + " " ) ; head = head . next ; } }
void printList ( Node head ) { Node temp = head ; while ( temp . next != head ) { System . out . print ( temp . data + " " ) ; temp = temp . next ; } System . out . print ( temp . data + " " ) ; }
void printList ( Node head ) { while ( head . next != null ) { System . out . print ( head . data + " <-> " ) ; head = head . next ; } System . out . println ( head . data ) ; }
void printList ( Node head ) { while ( head != null ) { System . out . print ( head . data + " " ) ; head = head . next ; } }
boolean isPalindrome ( Node left ) { if ( left == null ) return true ; Node right = left ; while ( right . next != null ) right = right . next ; while ( left != right ) { if ( left . data != right . data ) return false ; left = left . next ; right = right . prev ; } return true ; }
void printKDistant ( Node node , int k ) { if ( node == null k < 0 ) return ; if ( k == 0 ) { System . out . print ( node . data + " " ) ; return ; } printKDistant ( node . left , k - 1 ) ; printKDistant ( node . right , k - 1 ) ; }
void kDistantFromLeafUtil ( Node node , int path [ ] , boolean visited [ ] , int pathLen , int k ) { if ( node == null ) return ; path [ pathLen ] = node . data ; visited [ pathLen ] = false ; pathLen ++ ; if ( node . left == null && node . right == null && pathLen - k - 1 >= 0 && visited [ pathLen - k - 1 ] == false ) { System . out . print ( path [ pathLen - k - 1 ] + " " ) ; visited [ pathLen - k - 1 ] = true ; return ; } kDistantFromLeafUtil ( node . left , path , visited , pathLen , k ) ; kDistantFromLeafUtil ( node . right , path , visited , pathLen , k ) ; }
void printKDistantfromLeaf ( Node node , int k ) { int path [ ] = new int [ 1000 ] ; boolean visited [ ] = new boolean [ 1000 ] ; kDistantFromLeafUtil ( node , path , visited , 0 , k ) ; }
int rotate ( int arr [ ] , int N , int X ) { long nextPower = 1 ; while ( nextPower <= N ) nextPower *= 2 ; if ( X == 1 ) return ( int ) nextPower - N ; long prevPower = nextPower / 2 ; return 2 * ( N - ( int ) prevPower ) + 1 ; }
void performSwap ( int mat [ ] [ ] , int i , int j ) { int N = mat . length ; int ei = N - 1 - i ; int ej = N - 1 - j ; int temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ ej ] [ i ] ; mat [ ej ] [ i ] = mat [ ei ] [ ej ] ; mat [ ei ] [ ej ] = mat [ j ] [ ei ] ; mat [ j ] [ ei ] = temp ; }
void rotate ( int mat [ ] [ ] , int N , int K ) { K = K % 4 ; while ( K -- > 0 ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { for ( int j = i ; j < N - i - 1 ; j ++ ) { if ( i != j && ( i + j ) != N - 1 ) { performSwap ( mat , i , j ) ; } } } } print ( mat ) ; }
void findMaximumZeros ( String str , int n ) { int c0 = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( str . charAt ( i ) == '0' ) c0 ++ ; } if ( c0 == n ) { System . out . print ( n ) ; return ; } String s = str + str ; int mx = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int cs = 0 ; int ce = 0 ; for ( int j = i ; j < i + n ; ++ j ) { if ( s . charAt ( j ) == '0' ) cs ++ ; else break ; } for ( int j = i + n - 1 ; j >= i ; -- j ) { if ( s . charAt ( j ) == '0' ) ce ++ ; else break ; } int val = cs + ce ; mx = Math . max ( val , mx ) ; } System . out . print ( mx ) ; }
void findMaximumZeros ( String str , int n ) { int c0 = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( str . charAt ( i ) == '0' ) c0 ++ ; } if ( c0 == n ) { System . out . print ( n ) ; return ; } int mx = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '0' ) cnt ++ ; else { mx = Math . max ( mx , cnt ) ; cnt = 0 ; } } mx = Math . max ( mx , cnt ) ; int start = 0 , end = n - 1 ; cnt = 0 ; while ( str . charAt ( start ) != '1' && start < n ) { cnt ++ ; start ++ ; } while ( str . charAt ( end ) != '1' && end >= 0 ) { cnt ++ ; end -- ; } mx = Math . max ( mx , cnt ) ; System . out . println ( mx ) ; }
int getLeafCount ( Node node ) { if ( node == null ) { return 0 ; } Queue < Node > q = new LinkedList < > ( ) ; int count = 0 ; q . add ( node ) ; while ( ! q . isEmpty ( ) ) { Node temp = q . peek ( ) ; q . poll ( ) ; if ( temp . left != null ) { q . add ( temp . left ) ; } if ( temp . right != null ) { q . add ( temp . right ) ; } if ( temp . left == null && temp . right == null ) { count ++ ; } } return count ; }
void rotateArray ( int [ ] arr , int N ) { int [ ] v = arr ; Arrays . sort ( v ) ; for ( int i = 1 ; i <= N ; ++ i ) { int x = arr [ N - 1 ] ; i = N - 1 ; while ( i > 0 ) { arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = x ; i -= 1 ; } if ( arr == v ) { System . out . print ( "YES" ) ; return ; } } System . out . print ( "NO" ) ; }
int numberOfDigit ( int N ) { int digit = 0 ; while ( N > 0 ) { digit ++ ; N /= 10 ; } return digit ; }
void rotateNumberByK ( int N , int K ) { int X = numberOfDigit ( N ) ; K = ( ( K % X ) + X ) % X ; int left_no = N / ( int ) ( Math . pow ( 10 , X - K ) ) ; N = N % ( int ) ( Math . pow ( 10 , X - K ) ) ; int left_digit = numberOfDigit ( left_no ) ; N = ( N * ( int ) ( Math . pow ( 10 , left_digit ) ) ) + left_no ; System . out . println ( N ) ; }
void minMovesToSort ( int arr [ ] , int N ) { int count = 0 ; int index = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] < arr [ i + 1 ] ) { count ++ ; index = i ; } } if ( count == 0 ) { System . out . print ( "0" ) ; } else if ( count == N - 1 ) { System . out . print ( N - 1 ) ; } else if ( count == 1 && arr [ 0 ] <= arr [ N - 1 ] ) { System . out . print ( index + 1 ) ; } else { System . out . print ( "-1" ) ; } }
int findMaximumDiagonalSumOMatrixf ( int A [ ] [ ] ) { int maxDiagonalSum = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { int curr = 0 ; for ( int j = 0 ; j < N ; j ++ ) { curr += A [ j ] [ ( i + j ) % N ] ; } maxDiagonalSum = Math . max ( maxDiagonalSum , curr ) ; } for ( int i = 0 ; i < N ; i ++ ) { int curr = 0 ; for ( int j = 0 ; j < N ; j ++ ) { curr += A [ ( i + j ) % N ] [ j ] ; } maxDiagonalSum = Math . max ( maxDiagonalSum , curr ) ; } return maxDiagonalSum ; }
int countLeaves ( Node node ) { if ( node == null ) return 0 ; if ( node . left == null && node . right == null ) return 1 ; return countLeaves ( node . left ) + countLeaves ( node . right ) ; }
int MaxSum ( int [ ] arr , int n , int k ) { int i , max_sum = 0 , sum = 0 ; for ( i = 0 ; i < k ; i ++ ) { sum += arr [ i ] ; } max_sum = sum ; while ( i < n ) { sum = sum - arr [ i - k ] + arr [ i ] ; if ( max_sum < sum ) { max_sum = sum ; } i ++ ; } return max_sum ; }
int gcd ( int n1 , int n2 ) { if ( n2 == 0 ) { return n1 ; } else { return gcd ( n2 , n1 % n2 ) ; } }
int [ ] RotateArr ( int [ ] arr , int n , int d ) { int i = 0 , j = 0 ; d = d % n ; int no_of_sets = gcd ( d , n ) ; for ( i = 0 ; i < no_of_sets ; i ++ ) { int temp = arr [ i ] ; j = i ; while ( true ) { int k = j + d ; if ( k >= n ) k = k - n ; if ( k == i ) break ; arr [ j ] = arr [ k ] ; j = k ; } arr [ j ] = temp ; } return arr ; }
int getMinimumRemoval ( String str ) { int n = str . length ( ) ; int ans = n ; if ( n % 2 == 0 ) { int [ ] freqEven = new int [ 128 ] ; int [ ] freqOdd = new int [ 128 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { freqEven [ str . charAt ( i ) ] ++ ; } else { freqOdd [ str . charAt ( i ) ] ++ ; } } int evenMax = 0 , oddMax = 0 ; for ( char chr = 'a' ; chr <= 'z' ; chr ++ ) { evenMax = Math . max ( evenMax , freqEven [ chr ] ) ; oddMax = Math . max ( oddMax , freqOdd [ chr ] ) ; } ans = ans - evenMax - oddMax ; } else { int [ ] freq = new int [ 128 ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str . charAt ( i ) ] ++ ; } int strMax = 0 ; for ( char chr = 'a' ; chr <= 'z' ; chr ++ ) { strMax = Math . max ( strMax , freq [ chr ] ) ; } ans = ans - strMax ; } return ans ; }
int findAltSubSeq ( String s ) { int n = s . length ( ) , ans = Integer . MIN_VALUE ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { int cur = 0 , f = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( f == 0 && s . charAt ( k ) - '0' == i ) { f = 1 ; cur ++ ; } else if ( f == 1 && s . charAt ( k ) - '0' == j ) { f = 0 ; cur ++ ; } } if ( i != j && cur % 2 == 1 ) cur -- ; ans = Math . max ( cur , ans ) ; } } return ans ; }
int getFirstElement ( int a [ ] , int N , int K , int M ) { K %= N ; int index ; if ( K >= M ) index = ( N - K ) + ( M - 1 ) ; else index = ( M - K - 1 ) ; int result = a [ index ] ; return result ; }
int getFirstElement ( int [ ] a , int N , int K , int M ) { K %= N ; int index = ( K + M - 1 ) % N ; int result = a [ index ] ; return result ; }
void left_rotate ( int [ ] arr ) { int last = arr [ 1 ] ; for ( int i = 3 ; i < arr . length ; i = i + 2 ) { arr [ i - 2 ] = arr [ i ] ; } arr [ arr . length - 1 ] = last ; }
void right_rotate ( int [ ] arr ) { int start = arr [ arr . length - 2 ] ; for ( int i = arr . length - 4 ; i >= 0 ; i = i - 2 ) { arr [ i + 2 ] = arr [ i ] ; } arr [ 0 ] = start ; }
void rotate ( int arr [ ] ) { left_rotate ( arr ) ; right_rotate ( arr ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
int maximumMatchingPairs ( int perm1 [ ] , int perm2 [ ] , int n ) { int [ ] left = new int [ n ] ; int [ ] right = new int [ n ] ; HashMap < Integer , Integer > mp1 = new HashMap < > ( ) ; HashMap < Integer , Integer > mp2 = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp1 . put ( perm1 [ i ] , i ) ; } for ( int j = 0 ; j < n ; j ++ ) { mp2 . put ( perm2 [ j ] , j ) ; } for ( int i = 0 ; i < n ; i ++ ) { int idx2 = mp2 . get ( perm1 [ i ] ) ; int idx1 = i ; if ( idx1 == idx2 ) { left [ i ] = 0 ; right [ i ] = 0 ; } else if ( idx1 < idx2 ) { left [ i ] = ( n - ( idx2 - idx1 ) ) ; right [ i ] = ( idx2 - idx1 ) ; } else { left [ i ] = ( idx1 - idx2 ) ; right [ i ] = ( n - ( idx1 - idx2 ) ) ; } } HashMap < Integer , Integer > freq1 = new HashMap < > ( ) ; HashMap < Integer , Integer > freq2 = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq1 . containsKey ( left [ i ] ) ) freq1 . put ( left [ i ] , freq1 . get ( left [ i ] ) + 1 ) ; else freq1 . put ( left [ i ] , 1 ) ; if ( freq2 . containsKey ( right [ i ] ) ) freq2 . put ( right [ i ] , freq2 . get ( right [ i ] ) + 1 ) ; else freq2 . put ( right [ i ] , 1 ) ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , Math . max ( freq1 . get ( left [ i ] ) , freq2 . get ( right [ i ] ) ) ) ; } return ans ; }
int countRotation ( int [ ] arr , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { return i ; } } return 0 ; }
int query ( int node , int l , int r , int start , int end , int a [ ] ) { if ( l > end r < start ) return 0 ; if ( start <= l && r <= end ) return seg [ node ] ; int mid = ( l + r ) / 2 ; return ( ( query ( 2 * node , l , mid , start , end , a ) ) | ( query ( 2 * node + 1 , mid + 1 , r , start , end , a ) ) ) ; }
void isConversionPossible ( String s1 , String s2 , int x ) { int diff = 0 , n ; n = s1 . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 . charAt ( i ) == s2 . charAt ( i ) ) continue ; diff = ( ( int ) ( s2 . charAt ( i ) - s1 . charAt ( i ) ) + 26 ) % 26 ; if ( diff > x ) { System . out . println ( "NO" ) ; return ; } } System . out . println ( "YES" ) ; }
int countRotation ( int n ) { int count = 0 ; do { int digit = n % 10 ; if ( digit == 0 ) count ++ ; n = n / 10 ; } while ( n != 0 ) ; return count ; }
void printList ( Node node ) { while ( node != null ) { System . out . print ( node . data + " -> " ) ; node = node . next ; } System . out . print ( "null" ) ; }
boolean isPossible ( int a [ ] , int n ) { if ( n <= 2 ) return true ; int flag = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( ! ( a [ i ] > a [ i + 1 ] && a [ i + 1 ] > a [ i + 2 ] ) ) { flag = 1 ; break ; } } if ( flag == 0 ) return true ; flag = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( ! ( a [ i ] < a [ i + 1 ] && a [ i + 1 ] < a [ i + 2 ] ) ) { flag = 1 ; break ; } } if ( flag == 0 ) return true ; int val1 = Integer . MAX_VALUE , mini = - 1 , val2 = Integer . MIN_VALUE , maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < val1 ) { mini = i ; val1 = a [ i ] ; } if ( a [ i ] > val2 ) { maxi = i ; val2 = a [ i ] ; } } flag = 1 ; for ( int i = 0 ; i < maxi ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 && maxi + 1 == mini ) { flag = 1 ; for ( int i = mini ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) return true ; } flag = 1 ; for ( int i = 0 ; i < mini ; i ++ ) { if ( a [ i ] < a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 && maxi - 1 == mini ) { flag = 1 ; for ( int i = maxi ; i < n - 1 ; i ++ ) { if ( a [ i ] < a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) return true ; } return false ; }
int cntRotations ( String s , int n ) { String str = s + s ; int pre [ ] = new int [ 2 * n ] ; for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( i != 0 ) pre [ i ] += pre [ i - 1 ] ; if ( str . charAt ( i ) == 'a' || str . charAt ( i ) == 'e' || str . charAt ( i ) == 'i' || str . charAt ( i ) == 'o' || str . charAt ( i ) == 'u' ) { pre [ i ] ++ ; } } int ans = 0 ; for ( int i = n - 1 ; i < 2 * n - 1 ; i ++ ) { int r = i , l = i - n ; int x1 = pre [ r ] ; if ( l >= 0 ) x1 -= pre [ l ] ; r = i - n / 2 ; int left = pre [ r ] ; if ( l >= 0 ) left -= pre [ l ] ; int right = x1 - left ; if ( left > right ) { ans ++ ; } } return ans ; }
int cntRotations ( char s [ ] , int n ) { int lh = 0 , rh = 0 , i , ans = 0 ; for ( i = 0 ; i < n / 2 ; ++ i ) if ( s [ i ] == 'a' s [ i ] == 'e' s [ i ] == 'i' s [ i ] == 'o' s [ i ] == 'u' ) { lh ++ ; } for ( i = n / 2 ; i < n ; ++ i ) if ( s [ i ] == 'a' s [ i ] == 'e' s [ i ] == 'i' s [ i ] == 'o' s [ i ] == 'u' ) { rh ++ ; } if ( lh > rh ) ans ++ ; for ( i = 1 ; i < n ; ++ i ) { if ( s [ i - 1 ] == 'a' s [ i - 1 ] == 'e' s [ i - 1 ] == 'i' s [ i - 1 ] == 'o' s [ i - 1 ] == 'u' ) { rh ++ ; lh -- ; } if ( s [ ( i - 1 + n / 2 ) % n ] == 'a' || s [ ( i - 1 + n / 2 ) % n ] == 'e' || s [ ( i - 1 + n / 2 ) % n ] == 'i' || s [ ( i - 1 + n / 2 ) % n ] == 'o' || s [ ( i - 1 + n / 2 ) % n ] == 'u' ) { rh -- ; lh ++ ; } if ( lh > rh ) ans ++ ; } return ans ; }
void cal ( int num ) { int digits = numberOfDigits ( num ) ; int powTen = ( int ) Math . pow ( 10 , digits - 1 ) ; for ( int i = 0 ; i < digits - 1 ; i ++ ) { int firstDigit = num / powTen ; int left = ( ( num * 10 ) + firstDigit ) - ( firstDigit * powTen * 10 ) ; System . out . print ( left + " " ) ; num = left ; } }
void CheckKCycles ( int n , String s ) { boolean ff = true ; int x = 0 ; for ( int i = 1 ; i < n ; i ++ ) { x = ( s . substring ( i ) + s . substring ( 0 , i ) ) . length ( ) ; if ( x >= s . length ( ) ) { continue ; } ff = false ; break ; } if ( ff ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } }
void populateNext ( Node node ) { if ( node != null ) { populateNext ( node . right ) ; node . next = next ; next = node ; populateNext ( node . left ) ; } }
void occurredOnce ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; if ( arr [ 0 ] != arr [ 1 ] ) System . out . println ( arr [ 0 ] + " " ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i - 1 ] ) System . out . print ( arr [ i ] + " " ) ; if ( arr [ n - 2 ] != arr [ n - 1 ] ) System . out . print ( arr [ n - 1 ] + " " ) ; }
void occurredOnce ( int [ ] arr , int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) mp . put ( arr [ i ] , 1 + mp . get ( arr [ i ] ) ) ; else mp . put ( arr [ i ] , 1 ) ; } for ( Map . Entry entry : mp . entrySet ( ) ) { if ( Integer . parseInt ( String . valueOf ( entry . getValue ( ) ) ) == 1 ) System . out . print ( entry . getKey ( ) + " " ) ; } }
void occurredOnce ( int arr [ ] , int n ) { int i = 1 , len = n ; if ( arr [ 0 ] == arr [ len - 1 ] ) { i = 2 ; len -- ; } for ( ; i < n ; i ++ ) if ( arr [ i ] == arr [ i - 1 ] ) i ++ ; else System . out . print ( arr [ i - 1 ] + " " ) ; if ( arr [ n - 1 ] != arr [ 0 ] && arr [ n - 1 ] != arr [ n - 2 ] ) System . out . print ( arr [ n - 1 ] ) ; }
void rvereseArray ( int arr [ ] , int start , int end ) { while ( start < end ) { int temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; start ++ ; end -- ; } }
void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void splitArr ( int arr [ ] , int k , int n ) { rvereseArray ( arr , 0 , n - 1 ) ; rvereseArray ( arr , 0 , n - k - 1 ) ; rvereseArray ( arr , n - k , n - 1 ) ; }
int countRotationsDivBy8 ( String n ) { int len = n . length ( ) ; int count = 0 ; if ( len == 1 ) { int oneDigit = n . charAt ( 0 ) - '0' ; if ( oneDigit % 8 == 0 ) return 1 ; return 0 ; } if ( len == 2 ) { int first = ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ; int second = ( n . charAt ( 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( first % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; return count ; } int threeDigit ; for ( int i = 0 ; i < ( len - 2 ) ; i ++ ) { threeDigit = ( n . charAt ( i ) - '0' ) * 100 + ( n . charAt ( i + 1 ) - '0' ) * 10 + ( n . charAt ( i + 2 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; } threeDigit = ( n . charAt ( len - 1 ) - '0' ) * 100 + ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; threeDigit = ( n . charAt ( len - 2 ) - '0' ) * 100 + ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; return count ; }
void restoreSortedArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { reverse ( arr , 0 , i ) ; reverse ( arr , i + 1 , n ) ; reverse ( arr , 0 , n ) ; } } }
int findStartIndexOfArray ( int arr [ ] , int low , int high ) { if ( low > high ) { return - 1 ; } if ( low == high ) { return low ; } int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] ) { return mid + 1 ; } if ( arr [ mid - 1 ] > arr [ mid ] ) { return mid ; } if ( arr [ low ] > arr [ mid ] ) { return findStartIndexOfArray ( arr , low , mid - 1 ) ; } else { return findStartIndexOfArray ( arr , mid + 1 , high ) ; } }
void restoreSortedArray ( int arr [ ] , int n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) { return ; } int start = findStartIndexOfArray ( arr , 0 , n - 1 ) ; Arrays . sort ( arr , 0 , start ) ; Arrays . sort ( arr , start , n ) ; Arrays . sort ( arr ) ; }
void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
void printList ( Node node ) { while ( node != null ) { System . out . print ( node . data + " " ) ; node = node . next ; } }
boolean isRotation ( long x , long y ) { long x64 = x | ( x << 32 ) ; while ( x64 >= y ) { if ( x64 == y ) { return true ; } x64 >>= 1 ; } return false ; }
int countRotations ( String n ) { int len = n . length ( ) ; if ( len == 1 ) { int oneDigit = n . charAt ( 0 ) - '0' ; if ( oneDigit % 4 == 0 ) return 1 ; return 0 ; } int twoDigit , count = 0 ; for ( int i = 0 ; i < ( len - 1 ) ; i ++ ) { twoDigit = ( n . charAt ( i ) - '0' ) * 10 + ( n . charAt ( i + 1 ) - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; } twoDigit = ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; return count ; }
boolean isRotated ( String str1 , String str2 ) { if ( str1 . length ( ) != str2 . length ( ) ) return false ; if ( str1 . length ( ) < 2 ) { return str1 . equals ( str2 ) ; } String clock_rot = "" ; String anticlock_rot = "" ; int len = str2 . length ( ) ; anticlock_rot = anticlock_rot + str2 . substring ( len - 2 , len ) + str2 . substring ( 0 , len - 2 ) ; clock_rot = clock_rot + str2 . substring ( 2 ) + str2 . substring ( 0 , 2 ) ; return ( str1 . equals ( clock_rot ) || str1 . equals ( anticlock_rot ) ) ; }
void printList ( Node head ) { Node temp = head ; if ( head != null ) { do { System . out . printf ( "%d " , temp . data ) ; temp = temp . next ; } while ( temp != head ) ; } }
void deleteNode ( Node head_ref , Node del ) { Node temp = head_ref ; if ( head_ref == del ) head_ref = del . next ; while ( temp . next != del ) { temp = temp . next ; } temp . next = del . next ; del = null ; return ; }
int largestElement ( Node head_ref ) { Node current ; current = head_ref ; int maxEle = Integer . MIN_VALUE ; do { if ( current . data > maxEle ) { maxEle = current . data ; } current = current . next ; } while ( current != head_ref ) ; return maxEle ; }
void deleteFibonacciNodes ( Node head ) { int maxEle = largestElement ( head ) ; HashSet < Integer > hash = new HashSet < Integer > ( ) ; createHash ( hash , maxEle ) ; Node ptr = head ; Node next ; do { if ( hash . contains ( ptr . data ) ) deleteNode ( head , ptr ) ; next = ptr . next ; ptr = next ; } while ( ptr != head ) ; }
void printList ( Node head ) { Node temp = head ; if ( head != null ) { do { System . out . printf ( "%d " , temp . data ) ; temp = temp . next ; } while ( temp != head ) ; } }
int sumOfList ( Node head ) { Node temp = head ; int sum = 0 ; if ( head != null ) { do { temp = temp . next ; sum += temp . data ; } while ( temp != head ) ; } return sum ; }
int searchList ( Node start , int search ) { Node temp = start ; int count = 0 , flag = 0 , value ; if ( temp == null ) return - 1 ; else { while ( temp . next != start ) { count ++ ; if ( temp . data == search ) { flag = 1 ; count -- ; break ; } temp = temp . next ; } if ( temp . data == search ) { count ++ ; flag = 1 ; } if ( flag == 1 ) System . out . println ( "" + search   + "foundatlocation" + count ) ; else System . out . println ( "" + search   + "notfound" ) ; } return - 1 ; }
int countList ( node start ) { node temp = start ; int count = 0 ; while ( temp . next != start ) { temp = temp . next ; count ++ ; } count ++ ; return count ; }
void display ( Node head ) { if ( head == null ) return ; Node temp = head ; System . out . print ( "Forward direction: " ) ; while ( temp . next != head ) { System . out . print ( temp . data + " " ) ; temp = temp . next ; } System . out . print ( temp . data + " " ) ; Node last = head . prev ; temp = last ; System . out . print ( "Backwarddirection:" ) ; while ( temp . prev != last ) { System . out . print ( temp . data + " " ) ; temp = temp . prev ; } System . out . print ( temp . data + " " ) ; }
int displayList ( node temp ) { node t = temp ; if ( temp == null ) return 0 ; else { System . out . print ( "The list is: " ) ; while ( temp . next != t ) { System . out . print ( temp . data + " " ) ; temp = temp . next ; } System . out . print ( temp . data ) ; return 1 ; } }
int filter ( int x , int y , int z ) { if ( x != - 1 && y != - 1 ) { return z ; } return x == - 1 ? y : x ; }
int samePathUtil ( int mtrx [ ] [ ] , int vrtx , int v1 , int v2 , int i ) { int ans = - 1 ; if ( i == v1 i == v2 ) return i ; for ( int j = 0 ; j < vrtx ; j ++ ) { if ( mtrx [ i ] [ j ] == 1 ) { ans = filter ( ans , samePathUtil ( mtrx , vrtx , v1 , v2 , j ) , i ) ; } } return ans ; }
boolean isVertexAtSamePath ( int mtrx [ ] [ ] , int vrtx , int v1 , int v2 , int i ) { int lca = samePathUtil ( mtrx , vrtx , v1 - 1 , v2 - 1 , i ) ; if ( lca == v1 - 1 lca == v2 - 1 ) return true ; return false ; }
void dfs ( int node , int parent , int h , int cost ) { lca [ node ] [ 0 ] = parent ; level [ node ] = h ; if ( parent != - 1 ) { dist [ node ] [ 0 ] = cost ; } for ( int i = 1 ; i < log ; i ++ ) { if ( lca [ node ] [ i - 1 ] != - 1 ) { lca [ node ] [ i ] = lca [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ; dist [ node ] [ i ] = dist [ node ] [ i - 1 ] + dist [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ; } } for ( int [ ] i : graph . get ( node ) ) { if ( i [ 0 ] == parent ) continue ; dfs ( i [ 0 ] , node , h + 1 , i [ 1 ] ) ; } }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
void dfs ( int node , int parent , int h ) { par [ node ] = parent ; level [ node ] = h ; for ( int child : graph [ node ] ) { if ( child == parent ) continue ; dfs ( child , node , h + 1 ) ; } }
int findPrimeOnPath ( int u , int v ) { int count = 0 ; if ( level [ u ] > level [ v ] ) { int temp = v ; v = u ; u = temp ; } int d = level [ v ] - level [ u ] ; while ( d -- > 0 ) { if ( prime [ weight [ v ] ] ) count ++ ; v = par [ v ] ; } if ( v == u ) { if ( prime [ weight [ v ] ] ) count ++ ; return count ; } while ( v != u ) { if ( prime [ weight [ v ] ] ) count ++ ; if ( prime [ weight [ u ] ] ) count ++ ; u = par [ u ] ; v = par [ v ] ; } if ( prime [ weight [ v ] ] ) count ++ ; return count ; }
void addEdge ( int u , int v ) { graph [ u ] . add ( v ) ; graph [ v ] . add ( u ) ; }
int sumOddNodes ( Node root , int n1 , int n2 ) { Vector < Integer > path1 = new Vector < Integer > ( ) ; Vector < Integer > path2 = new Vector < Integer > ( ) ; getPath ( root , path1 , n1 ) ; getPath ( root , path2 , n2 ) ; int intersection = - 1 ; int i = 0 , j = 0 ; while ( i != path1 . size ( ) || j != path2 . size ( ) ) { if ( i == j && path1 . get ( i ) == path2 . get ( j ) ) { i ++ ; j ++ ; } else { intersection = j - 1 ; break ; } } int sum = 0 ; for ( i = path1 . size ( ) - 1 ; i > intersection ; i -- ) if ( path1 . get ( i ) % 2 != 0 ) sum += path1 . get ( i ) ; for ( i = intersection ; i < path2 . size ( ) ; i ++ ) if ( path2 . get ( i ) % 2 != 0 ) sum += path2 . get ( i ) ; return sum ; }
int findLCA ( int n1 , int n2 , int parent [ ] ) { boolean [ ] visited = new boolean [ MAX ] ; visited [ n1 ] = true ; while ( parent [ n1 ] != - 1 ) { visited [ n1 ] = true ; n1 = parent [ n1 ] ; } visited [ n1 ] = true ; while ( ! visited [ n2 ] ) n2 = parent [ n2 ] ; return n2 ; }
void insertAdj ( int parent [ ] , int i , int j ) { parent [ i ] = j ; }
void addEdge ( int u , int v ) { adj [ u ] . add ( v ) ; adj [ v ] . add ( u ) ; }
void dfs ( int cur , int prev ) { parent [ cur ] = prev ; depth [ cur ] = depth [ prev ] + 1 ; for ( int i = 0 ; i < adj [ cur ] . size ( ) ; i ++ ) if ( adj [ cur ] . elementAt ( i ) != prev ) dfs ( adj [ cur ] . elementAt ( i ) , cur ) ; }
void preprocess ( ) { depth [ 0 ] = - 1 ; dfs ( 1 , 0 ) ; }
void makeSet ( subset subsets [ ] , int i ) { if ( i < 1 i > V ) return ; subsets [ i ] . color = WHITE ; subsets [ i ] . parent = i ; subsets [ i ] . rank = 0 ; return ; }
int findSet ( subset subsets [ ] , int i ) { if ( subsets [ i ] . parent != i ) subsets [ i ] . parent = findSet ( subsets , subsets [ i ] . parent ) ; return subsets [ i ] . parent ; }
void unionSet ( subset subsets [ ] , int x , int y ) { int xroot = findSet ( subsets , x ) ; int yroot = findSet ( subsets , y ) ; if ( subsets [ xroot ] . rank < subsets [ yroot ] . rank ) subsets [ xroot ] . parent = yroot ; else if ( subsets [ xroot ] . rank > subsets [ yroot ] . rank ) subsets [ yroot ] . parent = xroot ; else { subsets [ yroot ] . parent = xroot ; ( subsets [ xroot ] . rank ) ++ ; } }
boolean findPair ( int a [ ] , int n , int z ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( i != j && a [ i ] + a [ j ] == z ) return true ; return false ; }
boolean linearSearch ( int a [ ] , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == key ) return true ; } return false ; }
int maximumSum ( int arr [ ] , int N ) { int Sum = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) Sum += ( arr [ i ] - arr [ i - 1 ] ) ; } return Sum ; }
void stoogesort ( int arr [ ] , int l , int h ) { if ( l >= h ) return ; if ( arr [ l ] > arr [ h ] ) { int temp = arr [ l ] ; arr [ l ] = arr [ h ] ; arr [ h ] = temp ; } if ( h - l + 1 > 2 ) { int t = ( h - l + 1 ) / 3 ; stoogesort ( arr , l , h - t ) ; stoogesort ( arr , l + t , h ) ; stoogesort ( arr , l , h - t ) ; } }
void findWinner ( int n , int m ) { int X = 0 ; int Y = 0 ; if ( n >= m ) { X = n - 1 ; Y = m ; } else { X = m - 1 ; Y = n ; } if ( X > Y ) System . out . print ( "X" ) ; else if ( Y > X ) System . out . print ( "Y" ) ; else System . out . print ( "-1" ) ; }
void checkPascaltriangle ( int N ) { double x = ( Math . sqrt ( 8 * N + 1 ) - 1 ) / 2 ; if ( Math . ceil ( x ) - x == 0 ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
void countSubarrays ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( ( j - i ) % 2 == 0 ) sum += arr [ j ] ; else sum -= arr [ j ] ; if ( sum == 0 ) count ++ ; } } System . out . println ( count ) ; }
void findCountRooks ( int row [ ] , int col [ ] , int n , int k ) { int res = n - k ; System . out . println ( res + " " ) ; int ri = 0 , ci = 0 ; while ( res -- > 0 ) { while ( ri < k && row [ ri ] == 1 ) { ri ++ ; } while ( ci < k && col [ ci ] == 1 ) { ci ++ ; } System . out . println ( ( ri + 1 ) + " " + ( ci + 1 ) + " " ) ; ri ++ ; ci ++ ; } }
boolean checkIfDivisible ( String str , long num ) { long powerOf2 = ( int ) ( Math . log ( num ) / Math . log ( 2 ) ) ; if ( str . length ( ) < powerOf2 ) return false ; if ( powerOf2 == 0 ) return true ; long i , number = 0 ; int len = str . length ( ) ; for ( i = len - powerOf2 ; i < len ; i ++ ) { number += ( str . charAt ( ( int ) i ) - '0' ) * Math . pow ( 10 , powerOf2 - 1 ) ; powerOf2 -- ; } if ( number % num != 0 ) return false ; else return true ; }
void countNo ( int A , int N , int L , int R ) { int ans = L - 1 + N + ( int ) Math . floor ( ( N - 1 ) / ( A - 1 ) ) ; if ( ans % A == 0 ) { ans = ans + 1 ; } System . out . println ( ans ) ; }
boolean check_order ( int [ ] arr ) { int cnt = 0 ; for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { if ( Math . abs ( arr [ i + 1 ] - arr [ i ] ) > 1 ) cnt ++ ; } if ( Math . abs ( arr [ 0 ] - arr [ arr . length - 1 ] ) > 1 ) cnt ++ ; if ( cnt > 1 ) return false ; return true ; }
int getM ( int n ) { if ( n == 1 ) return - 1 ; else return n - 2 ; }
int maxProfit ( int prices [ ] , int n ) { if ( n <= 1 ) return 0 ; int rest [ ] = new int [ n ] ; int hold [ ] = new int [ 9 ] ; int sold [ ] = new int [ 9 ] ; rest [ 0 ] = 0 ; hold [ 0 ] = - prices [ 0 ] ; sold [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { rest [ i ] = Math . max ( rest [ i - 1 ] , sold [ i - 1 ] ) ; hold [ i ] = Math . max ( hold [ i - 1 ] , rest [ i - 1 ] - prices [ i ] ) ; sold [ i ] = hold [ i - 1 ] + prices [ i ] ; } return Math . max ( rest [ n - 1 ] , sold [ n - 1 ] ) ; }
int findSubarrays ( int arr [ ] , int N , int K ) { return N - K + 1 ; }
int findCount ( String s ) { int [ ] freq = new int [ 26 ] ; int [ ] [ ] dp = new int [ 26 ] [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { for ( int j = 0 ; j < 26 ; j ++ ) { dp [ j ] [ s . charAt ( i ) - 'a' ] += freq [ j ] ; } freq [ s . charAt ( i ) - 'a' ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) ans = Math . max ( freq [ i ] , ans ) ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { ans = Math . max ( dp [ i ] [ j ] , ans ) ; } } return ans ; }
BigInteger findCycles ( int N ) { BigInteger res , finalResult ; long val = 2 * N - 1 ; String st = String . valueOf ( val ) ; BigInteger str = new BigInteger ( st ) ; String n1 = String . valueOf ( ( N - 1 ) ) ; String n2 = String . valueOf ( ( N - 2 ) ) ; BigInteger a = new BigInteger ( n1 ) ; BigInteger b = new BigInteger ( n2 ) ; res = a . multiply ( b ) ; finalResult = res . add ( str ) ; return finalResult ; }
int longest_subarray ( int arr [ ] , int d ) { int i = 0 , j = 1 , e = 0 ; for ( i = 0 ; i < d - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { j = j + 1 ; } else { j = 1 ; } if ( e < j ) { e = j ; } } return e ; }
int find ( int a [ ] , int n , int k ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 1 ; i < n ; ++ i ) { v . add ( a [ i - 1 ] - a [ i ] ) ; } Collections . sort ( v ) ; int res = a [ n - 1 ] - a [ 0 ] ; for ( int i = 0 ; i < k - 1 ; ++ i ) { res += v . get ( i ) ; } return res ; }
boolean isStrong ( int N ) { String num = Integer . toString ( N ) ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { sum += factorial [ Integer . parseInt ( num . charAt ( i ) + "" ) ] ; } return sum == N ; }
void printStrongNumbers ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( isStrong ( i ) ) { System . out . print ( i + " " ) ; } } }
int countPairs ( int A , int B ) { int countY = 0 , countX = ( B - A ) + 1 , next_val = 9 ; while ( next_val <= B ) { if ( next_val >= A ) { countY += 1 ; } next_val = next_val * 10 + 9 ; } return ( countX * countY ) ; }
long power ( long a , long b , long c ) { long result = 1 ; while ( b > 0 ) { if ( ( b & 1 ) = = 1 ) { result = ( result * a ) % c ; } b / = 2 ; a = ( a * a ) % c ; } return result ; }
long calculate ( long X , long N ) { int a [ ] = new int [ 10 ] ; int cyclicity [ ] = new int [ 11 ] ; cyclicity [ 1 ] = 1 ; cyclicity [ 2 ] = 4 ; cyclicity [ 3 ] = 4 ; cyclicity [ 4 ] = 2 ; cyclicity [ 5 ] = 1 ; cyclicity [ 6 ] = 1 ; cyclicity [ 7 ] = 4 ; cyclicity [ 8 ] = 4 ; cyclicity [ 9 ] = 2 ; cyclicity [ 10 ] = 1 ; if ( N = = 0 N = = 1 ) { return ( X % 10 ) ; } else if ( N = = 2 N = = 3 N = = 4 ) { long temp = ( long ) 1e18 ; a [ 2 ] = 2 ; a [ 3 ] = 6 ; a [ 4 ] = 4 ; long v = X % 10 ; if ( v ! = 0 ) { int u = cyclicity [ ( int ) v ] ; int r = a [ ( int ) N ] % u ; if ( r = = 0 ) { if ( v = = 2 v = = 4 v = = 6 v = = 8 ) { return 6 ; } else if ( v = = 5 ) { return 5 ; } else if ( v = = 1 v = = 3 v = = 7 v = = 9 ) { return 1 ; } } else { return ( power ( v , r , temp ) % 10 ) ; } } else { return 0 ; } } return 1 ; }
void precompute ( String s , String K ) { int n = s . length ( ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { cnt [ i + 1 ] = cnt [ i ] ; if ( s . substring ( i , i + K . length ( ) ) . equals ( K ) ) { cnt [ i + 1 ] += 1 ; } } cnt [ n - 2 + 1 ] = cnt [ n - 2 ] ; }
int getXOR ( int BITree [ ] , int index ) { int ans = 0 ; index += 1 ; while ( index > 0 ) { ans ^= BITree [ index ] ; index -= index & ( - index ) ; } return ans ; }
void updateBIT ( int BITree [ ] , int n , int index , int val ) { index = index + 1 ; while ( index <= n ) { BITree [ index ] ^= val ; index += index & ( - index ) ; } }
boolean isPowerOfTwo ( int x ) { if ( x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ) return true ; return false ; }
void computePrefix ( int n , int a [ ] ) { if ( isPowerOfTwo ( a [ 0 ] ) ) prefix [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] ; if ( isPowerOfTwo ( a [ i ] ) ) prefix [ i ] ++ ; } }
int formQuadruplets ( Integer arr [ ] , int n ) { int ans = 0 , pairs = 0 ; pairs = n / 4 ; Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < n - pairs ; i += 3 ) { ans += arr [ i + 2 ] ; } return ans ; }
void count ( ) { int maxN = 1000000 , i , j ; for ( i = 0 ; i < maxN ; i ++ ) arr [ i ] = 1 ; arr [ 0 ] = 0 ; arr [ 1 ] = 0 ; for ( i = 2 ; i * i <= maxN ; i ++ ) { if ( arr [ i ] == 1 ) { for ( j = 2 * i ; j <= maxN ; j += i ) { arr [ j ] = 0 ; } } } int cnt = 0 ; for ( i = 0 ; i <= maxN ; i ++ ) { if ( arr [ i ] == 1 ) cnt ++ ; if ( arr [ cnt ] == 1 ) dp [ i ] = 1 ; else dp [ i ] = 0 ; } for ( i = 1 ; i <= maxN ; i ++ ) dp [ i ] += dp [ i - 1 ] ; }
void findUngroupedElement ( String s , int k ) { int n = s . length ( ) ; int [ ] b = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) b [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { char p = s . charAt ( i ) ; b [ p - 'a' ] += 1 ; } int sum = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( b [ i ] > k ) sum += b [ i ] - k ; } System . out . println ( sum ) ; }
void AddEdge ( int u , int v ) { adj [ u ] . add ( v ) ; adj [ v ] . add ( u ) ; }
void findFirstEnd ( int u , int p ) { lvl [ u ] = 1 + lvl [ p ] ; if ( lvl [ u ] > maxi ) { maxi = lvl [ u ] ; end1 = u ; } for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) { if ( adj [ u ] . elementAt ( i ) != p ) { findFirstEnd ( adj [ u ] . elementAt ( i ) , u ) ; } } }
void findSecondEnd ( int u , int p ) { lvl [ u ] = 1 + lvl [ p ] ; if ( lvl [ u ] > maxi ) { maxi = lvl [ u ] ; end2 = u ; } for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) { if ( adj [ u ] . elementAt ( i ) != p ) { findSecondEnd ( adj [ u ] . elementAt ( i ) , u ) ; } } }
void findDistancefromFirst ( int u , int p ) { dist1 [ u ] = 1 + dist1 [ p ] ; for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) { if ( adj [ u ] . elementAt ( i ) != p ) { findDistancefromFirst ( adj [ u ] . elementAt ( i ) , u ) ; } } }
void findDistancefromSecond ( int u , int p ) { dist2 [ u ] = 1 + dist2 [ p ] ; for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) { if ( adj [ u ] . elementAt ( i ) != p ) { findDistancefromSecond ( adj [ u ] . elementAt ( i ) , u ) ; } } }
void findNodes ( ) { int n = 5 ; AddEdge ( 1 , 2 ) ; AddEdge ( 1 , 3 ) ; AddEdge ( 3 , 4 ) ; AddEdge ( 3 , 5 ) ; findFirstEnd ( 1 , 0 ) ; clear ( n ) ; findSecondEnd ( end1 , 0 ) ; findDistancefromFirst ( end1 , 0 ) ; findDistancefromSecond ( end2 , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) { int x = dist1 [ i ] ; int y = dist2 [ i ] ; if ( x >= y ) { System . out . print ( end1 + " " ) ; } else { System . out . print ( end2 + " " ) ; } } }
int findMaxSum ( int [ ] arr , int n ) { Vector < Integer > a = new Vector < Integer > ( ) ; Vector < Integer > b = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { a . add ( arr [ i ] ) ; } else if ( arr [ i ] < 0 ) { b . add ( arr [ i ] ) ; } } Collections . sort ( a ) ; Collections . sort ( b ) ; int p = a . size ( ) - 1 ; int q = b . size ( ) - 1 ; int s = 0 ; while ( p >= 0 && q >= 0 ) { if ( a . get ( p ) + b . get ( q ) > 0 ) { s = s + a . get ( p ) + b . get ( q ) ; } else { break ; } p = p - 1 ; q = q - 1 ; } return s ; }
void countIntgralPoints ( int x1 , int y1 , int x2 , int y2 ) { System . out . println ( ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ) ; }
void SieveOfEratosthenes ( boolean prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
void PrimeDegreeNodes ( int prufer [ ] , int n ) { int nodes = n + 2 ; boolean [ ] prime = new boolean [ nodes + 1 ] ; Arrays . fill ( prime , true ) ; SieveOfEratosthenes ( prime , nodes + 1 ) ; int [ ] degree = new int [ n + 2 + 1 ] ; for ( int i = 1 ; i <= nodes ; i ++ ) degree [ i ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) degree [ prufer [ i ] ] ++ ; for ( int i = 1 ; i <= nodes ; i ++ ) { if ( prime [ degree [ i ] ] ) { System . out . print ( i + " " ) ; } } }
int countSingle ( Node node ) { countSingleRec ( node , ct ) ; return ct . count ; }
void SieveOfEratosthenes ( ) { int i , j ; Prime [ 0 ] = Prime [ 1 ] = false ; for ( i = 2 ; i * i <= 10005 ; i ++ ) { if ( Prime [ i ] ) { for ( j = 2 * i ; j < 10005 ; j += i ) { Prime [ j ] = false ; } } } }
void primeDegreeNodes ( int N , int M , int edges [ ] [ ] ) { Vector < Integer > [ ] Adj = new Vector [ N + 1 ] ; for ( int i = 0 ; i < Adj . length ; i ++ ) Adj [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < M ; i ++ ) { int x = edges [ i ] [ 0 ] ; int y = edges [ i ] [ 1 ] ; Adj [ x ] . add ( y ) ; Adj [ y ] . add ( x ) ; } SieveOfEratosthenes ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { int x = Adj [ i ] . size ( ) ; if ( Prime [ x ] ) System . out . print ( i + " " ) ; } }
int digitSum ( int num ) { int sum = 0 ; while ( num > 0 ) { sum += ( num % 10 ) ; num /= 10 ; } return sum ; }
int countWays ( int colored [ ] , int count , int n ) { if ( count == n ) { return 1 ; } int answer = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { if ( colored [ i ] == 0 ) { if ( colored [ i - 1 ] == 1 colored [ i + 1 ] == 1 ) { colored [ i ] = 1 ; answer = ( answer + countWays ( colored , count + 1 , n ) ) % mod ; colored [ i ] = 0 ; } } } return answer ; }
int waysToColor ( int arr [ ] , int n , int k ) { int colored [ ] = new int [ n + 2 ] ; for ( int i = 0 ; i < k ; i ++ ) { colored [ arr [ i ] ] = 1 ; } return countWays ( colored , k , n ) ; }
int waysToColor ( int arr [ ] , int n , int k ) { int powOf2 [ ] = new int [ 500 ] ; int [ ] [ ] c = new int [ 500 ] [ 500 ] ; for ( int i = 0 ; i <= n ; i ++ ) { c [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j <= i ; j ++ ) { c [ i ] [ j ] = ( c [ i - 1 ] [ j ] + c [ i - 1 ] [ j - 1 ] ) % mod ; } } powOf2 [ 0 ] = powOf2 [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { powOf2 [ i ] = powOf2 [ i - 1 ] * 2 % mod ; } int rem = n - k ; arr [ k ++ ] = n + 1 ; Arrays . sort ( arr ) ; int answer = 1 ; for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ i ] - ( i - 1 >= 0 ? arr [ i - 1 ] : 0 ) - 1 ; answer *= c [ rem ] [ x ] % mod * ( i != 0 && i != k - 1 ? powOf2 [ x ] : 1 ) % mod ; rem -= x ; } return answer ; }
char ShortestPalindrome ( String s ) { int n = s . length ( ) ; char ans = s . charAt ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { ans = ( char ) Math . min ( ans , s . charAt ( i ) ) ; } return ans ; }
long SumGPUtil ( long r , long n , long m ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return ( 1 + r ) % m ; long ans ; if ( n % 2 == 1 ) { ans = ( 1 + r ) * SumGPUtil ( ( r * r ) % m , ( n - 1 ) / 2 , m ) ; } else { ans = 1 + ( r * ( 1 + r ) * SumGPUtil ( ( r * r ) % m , ( n / 2 ) - 1 , m ) ) ; } return ( ans % m ) ; }
void SumGP ( long a , long r , long N , long M ) { long answer ; answer = a * SumGPUtil ( r , N , M ) ; answer = answer % M ; System . out . println ( answer ) ; }
void findLeafDown ( Node root , int lev , Distance minDist ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) { if ( lev < ( minDist . minDis ) ) minDist . minDis = lev ; return ; } findLeafDown ( root . left , lev + 1 , minDist ) ; findLeafDown ( root . right , lev + 1 , minDist ) ; }
int findThroughParent ( Node root , Node x , Distance minDist ) { if ( root == null ) return - 1 ; if ( root == x ) return 0 ; int l = findThroughParent ( root . left , x , minDist ) ; if ( l != - 1 ) { findLeafDown ( root . right , l + 2 , minDist ) ; return l + 1 ; } int r = findThroughParent ( root . right , x , minDist ) ; if ( r != - 1 ) { findLeafDown ( root . left , r + 2 , minDist ) ; return r + 1 ; } return - 1 ; }
int minimumDistance ( Node root , Node x ) { Distance d = new Distance ( ) ; findLeafDown ( x , 0 , d ) ; findThroughParent ( root , x , d ) ; return d . minDis ; }
int SmallestDiv ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return i ; } } return n ; }
int countOfNum ( int n , int a , int b ) { int cnt_of_a , cnt_of_b , cnt_of_ab , sum ; cnt_of_a = n / a ; cnt_of_b = n / b ; sum = cnt_of_b + cnt_of_a ; cnt_of_ab = n / ( a * b ) ; sum = sum - cnt_of_ab ; return sum ; }
int sumOfNum ( int n , int a , int b ) { int i ; int sum = 0 ; Set < Integer > ans = new HashSet < Integer > ( ) ; for ( i = a ; i <= n ; i = i + a ) { ans . add ( i ) ; } for ( i = b ; i <= n ; i = i + b ) { ans . add ( i ) ; } for ( Integer it : ans ) { sum = sum + it ; } return sum ; }
boolean isPalindrome ( String r ) { String p = r ; p = reverse ( p ) ; return ( r . equals ( p ) ) ; }
int minimumAdjacentDifference ( int a [ ] , int n , int k ) { int minDiff = Integer . MAX_VALUE ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int cnt = Integer . bitCount ( i ) ; if ( cnt == n - k ) { Vector < Integer > temp = new Vector < Integer > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) temp . add ( a [ j ] ) ; } int maxDiff = Integer . MIN_VALUE ; for ( int j = 0 ; j < temp . size ( ) - 1 ; j ++ ) { maxDiff = Math . max ( maxDiff , temp . get ( j + 1 ) - temp . get ( j ) ) ; } minDiff = Math . min ( minDiff , maxDiff ) ; } } return minDiff ; }
int gcdFunc ( int a , int b ) { if ( b == 0 ) return a ; return gcdFunc ( b , a % b ) ; }
int findMinimumElements ( int [ ] a , int n ) { int [ ] b = new int [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { b [ i - 1 ] = a [ i ] - a [ i - 1 ] ; } int gcd = b [ 0 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { gcd = gcdFunc ( gcd , b [ i ] ) ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans += ( b [ i ] / gcd ) - 1 ; } return ans ; }
boolean checkPermutation ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int [ ] prefix = new int [ n + 1 ] ; Arrays . fill ( prefix , 0 ) ; prefix [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix [ i ] = prefix [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int lsum = prefix [ i ] ; int rsum = sum - prefix [ i ] ; int l_len = i + 1 , r_len = n - i - 1 ; if ( ( ( 2 * lsum ) == ( l_len * ( l_len + 1 ) ) ) && ( ( 2 * rsum ) == ( r_len * ( r_len + 1 ) ) ) ) return true ; } return false ; }
void maximumArea ( int l , int b , int x , int y ) { int left , right , above , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; below = ( b - y - 1 ) * l ; System . out . print ( Math . max ( Math . max ( left , right ) , Math . max ( above , below ) ) ) ; }
void precompute ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd [ i ] = 1 ; if ( arr [ i ] % 2 == 0 ) even [ i ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { even [ i ] = even [ i ] + even [ i - 1 ] ; odd [ i ] = odd [ i ] + odd [ i - 1 ] ; } }
boolean isOdd ( int L , int R ) { int cnt = odd [ R ] ; if ( L > 0 ) cnt -= odd [ L - 1 ] ; if ( cnt == R - L + 1 ) return true ; return false ; }
void findTriplets ( int x ) { Vector < Integer > fact = new Vector < Integer > ( ) ; HashSet < Integer > factors = new HashSet < Integer > ( ) ; for ( int i = 2 ; i <= Math . sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { fact . add ( i ) ; if ( x / i != i ) fact . add ( x / i ) ; factors . add ( i ) ; factors . add ( x / i ) ; } } boolean found = false ; int k = fact . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { int a = fact . get ( i ) ; for ( int j = 0 ; j < k ; j ++ ) { int b = fact . get ( j ) ; if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) { System . out . print ( a + " " + b + " " + ( x / ( a * b ) ) ) ; found = true ; break ; } } if ( found ) break ; } if ( ! found ) System . out . print ( "-1" ) ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void findArray ( int n , int k , int s ) { int vis [ ] = new int [ n ] ; int cnt = 0 ; int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n && cnt < k ; i += 2 ) { arr [ i ] = s ; vis [ i ] = 1 ; cnt ++ ; } int val = s ; if ( s % 2 == 0 ) val ++ ; else val = val + 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] == 0 ) { arr [ i ] = val ; } } printArr ( arr , n ) ; }
int countPair ( int a , int b ) { String s = String . valueOf ( b ) ; int i ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != '9' ) break ; } int result ; if ( i == s . length ( ) ) result = a * s . length ( ) ; else result = a * ( s . length ( ) - 1 ) ; return result ; }
float getArea ( int a ) { float area = ( float ) ( Math . PI * a * a ) / 4 ; return area ; }
boolean flipsPossible ( int [ ] a , int n ) { int count_odd = 0 , count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] & 1 ) == 1 ) count_odd ++ ; else count_even ++ ; } if ( count_odd % 2 == 1 && count_even % 2 == 1 ) return false ; else return true ; }
int sumEqualProduct ( int a [ ] , int n ) { int zero = 0 , two = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { zero ++ ; } if ( a [ i ] == 2 ) { two ++ ; } } int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 ; return cnt ; }
int minSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } if ( sum == 1 ) return 10 ; return sum ; }
void initialize ( int mul [ ] , int div [ ] , int size ) { for ( int i = 1 ; i < size ; i ++ ) { mul [ i ] = ( mul [ i ] * mul [ i - 1 ] ) / div [ i ] ; } }
void update ( int l , int r , int x , int mul [ ] , int div [ ] ) { mul [ l ] *= x ; div [ r + 1 ] *= x ; }
void printArray ( int ar [ ] , int mul [ ] , int div [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { ar [ i ] = ar [ i ] * mul [ i ] ; System . out . print ( ar [ i ] + " " ) ; } }
void findTriangle ( long S ) { long X1 = 0 , Y1 = 0 ; long X2 = MAX , Y2 = 1 ; long X3 = ( MAX - S % MAX ) % MAX ; long Y3 = ( S + X3 ) / MAX ; System . out . println ( "(" + X1 + ", " + Y1 + ")" ) ; System . out . println ( "(" + X2 + ", " + Y2 + ")" ) ; System . out . println ( "(" + X3 + ", " + Y3 + ")" ) ; }
void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void findArrangement ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . print ( "-1" ) ; return ; } int minVal = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == minVal ) { swap ( arr , i , n - 1 ) ; break ; } } int andVal = arr [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { andVal &= arr [ i ] ; } if ( andVal == arr [ n - 1 ] ) printArr ( arr , n ) ; else System . out . print ( "-1" ) ; }
int maxOperations ( int X , int Y ) { if ( X > Y ) return - 1 ; int diff = Y - X ; if ( diff == 1 ) return - 1 ; if ( diff % 2 == 0 ) return ( diff / 2 ) ; return ( 1 + ( ( diff - 3 ) / 2 ) ) ; }
void precompute ( ) { for ( int i = 0 ; i < DIGITS ; i ++ ) { dp [ 1 ] [ i ] = i ; cnt [ 1 ] [ i ] = 1 ; } for ( int i = 2 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < DIGITS ; j ++ ) { for ( int k = 0 ; k < DIGITS ; k ++ ) { if ( j != k ) { dp [ i ] [ j ] = dp [ i ] [ j ] + ( dp [ i - 1 ] [ k ] + ( cnt [ i - 1 ] [ k ] * j ) % MOD ) % MOD ; dp [ i ] [ j ] %= MOD ; cnt [ i ] [ j ] += cnt [ i - 1 ] [ k ] ; cnt [ i ] [ j ] %= MOD ; } } } } }
void precompute ( ) { F [ 1 ] = 2 ; F [ 2 ] = 3 ; F [ 3 ] = 4 ; for ( int i = 4 ; i < N ; i ++ ) F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; }
double minimizedSum ( int a [ ] , int n , int K ) { int sum = maxSubArraySum ( a , n ) ; double totalSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) totalSum += a [ i ] ; if ( sum < 0 ) return totalSum ; totalSum = totalSum - sum + ( double ) sum / ( double ) K ; return totalSum ; }
double get ( double L , double R ) { double x = 1.0 / L ; double y = 1.0 / ( R + 1.0 ) ; return ( x - y ) ; }
void DivisorCount ( ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = i ; j < N ; j += i ) { divi [ j ] ++ ; } } }
void pre ( ) { for ( int i = 1 ; i < N ; i ++ ) { if ( prime [ divi [ i ] ] == 1 ) { sum [ i ] = i ; } } for ( int i = 1 ; i < N ; i ++ ) sum [ i ] += sum [ i - 1 ] ; }
int consecutiveOnes ( int x ) { int p = 0 ; while ( x > 0 ) { if ( x % 2 == 1 && p == 1 ) { return 1 ; } p = x % 2 ; x /= 2 ; } return 0 ; }
void preCompute ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) { if ( consecutiveOnes ( i ) == 0 ) { v . add ( i ) ; } } }
int nextValid ( int n ) { int it = upper_bound ( v , n ) ; int val = v . get ( it ) ; return val ; }
void randomList ( int m , int n ) { int arr [ ] = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ ( int ) ( Math . random ( ) * m ) ] ++ ; } printArr ( arr , m ) ; }
long power ( long x , int y , int p ) { long res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
long nCrModPFermat ( long n , int r , int p ) { if ( r == 0 ) return 1 ; long fac [ ] = new long [ ( int ) n + 1 ] ; fac [ 0 ] = 1 ; int i ; for ( i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ ( int ) n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ ( int ) n - r ] , p ) % p ) % p ; }
long countOdd ( long n ) { long x = n / 2 ; if ( n % 2 == 1 ) x ++ ; return x ; }
long counteEven ( long n ) { long x = n / 2 ; return x ; }
int sumPrime ( int k ) { SieveOfEratosthenes ( ) ; Vector < Integer > v = new Vector < > ( ) ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] ) v . add ( i ) ; } int sum = 0 ; int skip = ( k * ( k - 1 ) ) / 2 ; while ( k > 0 ) { sum += v . get ( skip ) ; skip ++ ; k -- ; } return sum ; }
int lcm ( int x , int y ) { int temp = ( x * y ) / __gcd ( x , y ) ; return temp ; }
void findNumbers ( int a [ ] , int n , int b [ ] , int m ) { int lcmA = 1 , gcdB = 0 ; for ( int i = 0 ; i < n ; i ++ ) lcmA = lcm ( lcmA , a [ i ] ) ; for ( int i = 0 ; i < m ; i ++ ) gcdB = __gcd ( gcdB , b [ i ] ) ; if ( gcdB % lcmA != 0 ) { System . out . print ( "-1" ) ; return ; } int num = lcmA ; while ( num <= gcdB ) { if ( gcdB % num == 0 ) System . out . print ( num + " " ) ; num += lcmA ; } }
int countSubStr ( String str , int n , char ch ) { int cnt = 0 ; int j = nextOccurrence ( str , n , 0 , ch ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( j != - 1 && j < i ) { j = nextOccurrence ( str , n , j + 1 , ch ) ; } if ( j == - 1 ) break ; cnt += ( n - j ) ; } return cnt ; }
void checkEvenOdd ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { System . out . print ( "Even" ) ; return ; } } System . out . println ( "Odd" ) ; }
int power ( int x , int y ) { int res = 1 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = res * x ; y = y >> 1 ; x = x * x ; } return res ; }
int maxPartition ( String s ) { int n = s . length ( ) , P = 0 ; String current = "" , previous = "" ; for ( int i = 0 ; i < n ; i ++ ) { current += s . charAt ( i ) ; if ( ! current . equals ( previous ) ) { previous = current ; current = "" ; P ++ ; } } return P ; }
int LongestSubarray ( int a [ ] , int n , int k ) { int [ ] pre = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > k ) pre [ i ] = 1 ; else pre [ i ] = - 1 ; } for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = pre [ i - 1 ] + pre [ i ] ; int len = 0 ; int lo = 1 , hi = n ; while ( lo <= hi ) { int mid = ( lo + hi ) / 2 ; boolean ok = false ; for ( int i = mid - 1 ; i < n ; i ++ ) { int x = pre [ i ] ; if ( i - mid >= 0 ) x -= pre [ i - mid ] ; if ( x > 0 ) { ok = true ; break ; } } if ( ok == true ) { len = mid ; lo = mid + 1 ; } else hi = mid - 1 ; } return len ; }
boolean prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; ++ i ) if ( n % i == 0 ) return false ; return true ; }
int Min_Sum ( int n ) { if ( prime ( n ) ) return 1 ; if ( n % 2 == 0 ) return 2 ; else { if ( prime ( n - 2 ) ) return 2 ; else return 3 ; } }
int MinDeletion ( int a [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( a [ i ] ) ) { mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; } else { mp . put ( a [ i ] , 1 ) ; } } int ans = 0 ; for ( Map . Entry < Integer , Integer > i : mp . entrySet ( ) ) { int x = i . getKey ( ) ; int frequency = i . getValue ( ) ; if ( x <= frequency ) { ans += ( frequency - x ) ; } else ans += frequency ; } return ans ; }
int find_maximum_value ( int a [ ] , int n ) { int sum = 0 ; int minimum = Integer . MAX_VALUE ; int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { minimum = Math . min ( minimum , Math . abs ( a [ i ] ) ) ; sum += Math . abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) pos += 1 ; else neg += 1 ; } if ( pos > 0 && neg > 0 ) return sum ; return ( sum - 2 * minimum ) ; }
int maxCountAB ( String s [ ] , int n ) { int A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String S = s [ i ] ; int L = S . length ( ) ; for ( int j = 0 ; j < L - 1 ; j ++ ) { if ( S . charAt ( j ) == 'A' && S . charAt ( j + 1 ) == 'B' ) { ans ++ ; } } if ( S . charAt ( 0 ) == 'B' && S . charAt ( L - 1 ) == 'A' ) BA ++ ; else if ( S . charAt ( 0 ) == 'B' ) B ++ ; else if ( S . charAt ( L - 1 ) == 'A' ) A ++ ; } if ( BA == 0 ) ans += Math . min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + Math . min ( B , A ) ; return ans ; }
int MinOperations ( int n , int x , int [ ] arr ) { int total = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] > x ) { int difference = arr [ i ] - x ; total = total + difference ; arr [ i ] = x ; } } for ( int i = 1 ; i < n ; ++ i ) { int LeftNeigbouringSum = arr [ i ] + arr [ i - 1 ] ; if ( LeftNeigbouringSum > x ) { int current_diff = LeftNeigbouringSum - x ; arr [ i ] = Math . max ( 0 , arr [ i ] - current_diff ) ; total = total + current_diff ; } } return total ; }
int countPairs ( String s ) { Set < Character > st = new HashSet < Character > ( ) ; st . add ( 'a' ) ; st . add ( 'e' ) ; st . add ( 'i' ) ; st . add ( 'o' ) ; st . add ( 'u' ) ; int count = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( st . contains ( s . charAt ( i ) ) && ! st . contains ( s . charAt ( i + 1 ) ) ) count ++ ; } return count ; }
int maxSize ( Vector < Integer > v , int n ) { v . add ( 0 ) ; v . add ( 100001 ) ; n += 2 ; Collections . sort ( v ) ; int mx = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int L = v . get ( i - 1 ) + 1 ; int R = v . get ( i + 1 ) - 1 ; int cnt = R - L + 1 ; mx = max ( mx , cnt ) ; } return mx ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; }
int maxLength ( int a [ ] , int n ) { int sum = 0 , len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } { return n ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) { len = Math . max ( len , Math . max ( n - i - 1 , i ) ) ; } } return len ; }
int countMaxLength ( int N ) { int res ; int pre [ ] = new int [ MAXN ] ; int p = 1 ; pre [ 0 ] = 0 ; for ( int i = 1 ; i < MAXN ; i ++ ) { p *= 2 ; pre [ i ] = pre [ i - 1 ] + i * p ; } int ind = 0 ; for ( int i = 1 ; i < MAXN ; i ++ ) { if ( pre [ i ] >= N ) { ind = i ; break ; } } int x = N - pre [ ind - 1 ] ; int y = 2 * ind - 1 ; if ( x >= y ) res = Math . min ( x , y ) ; else res = Math . max ( x , 2 * ( ind - 2 ) + 1 ) ; return res ; }
int getMinVal ( int p , int q ) { if ( q % p == 0 ) return p ; return - 1 ; }
void findPoints ( int l1 , int r1 , int l2 , int r2 ) { int x = ( l1 != l2 ) ? Math . min ( l1 , l2 ) : - 1 ; int y = ( r1 != r2 ) ? Math . max ( r1 , r2 ) : - 1 ; System . out . println ( x + " " + y ) ; }
int countPrimePalindrome ( String str , int len ) { boolean [ ] prime = new boolean [ len + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= len ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * p ; i <= len ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int j = 2 ; j <= len ; j ++ ) { if ( prime [ j ] ) { for ( int i = 0 ; i + j - 1 < len ; i ++ ) { if ( isPalindrome ( str , i , i + j - 1 ) ) count ++ ; } } } return count ; }
int minOperations ( int N ) { double x = Math . log ( N ) / Math . log ( 2 ) ; int ans = ( int ) ( Math . ceil ( x ) ) ; return ans ; }
int find_greatest_divisor ( int l , int r ) { if ( l == r ) { return l ; } return 1 ; }
void findNumbers ( int arr [ ] , int n ) { int sumN = ( n * ( n + 1 ) ) / 2 ; int sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sum = 0 , sumSq = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq += Math . pow ( arr [ i ] , 2 ) ; } int B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; int A = sum - sumN + B ; System . out . println ( "A = " + A + "B=" + B ) ; }
int factorialUsingRecursion ( int n ) { if ( n == 0 ) return 1 ; return n * factorialUsingRecursion ( n - 1 ) ; }
int factorialUsingIteration ( int n ) { int res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
boolean checkPerfectSquare ( double n ) { double d = Math . sqrt ( n ) ; if ( d * d == n ) return true ; return false ; }
int largestPerfectSquareNumber ( int a [ ] , double n ) { int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkPerfectSquare ( a [ i ] ) ) maxi = Math . max ( a [ i ] , maxi ) ; } return maxi ; }
void convert ( int n , int a [ ] ) { int z = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] > z ) z = a [ i ] ; } z = z + 1 ; int ff [ ] = new int [ z ] ; for ( int i = 0 ; i < n ; i ++ ) { ff [ a [ i ] ] += 1 ; } int cc = 0 ; for ( int i = 0 ; i < z ; i ++ ) { cc += ( ff [ i ] / 4 ) ; ff [ i ] = ff [ i ] % 4 ; } int vv = 0 ; for ( int i = 0 ; i < z ; i ++ ) { if ( ff [ i ] >= 2 ) vv += 1 ; } cc += ( vv / 2 ) ; System . out . println ( cc ) ; }
double getProbability ( double p , double q ) { p /= 100 ; q /= 100 ; double probability = ( p * p + q * q ) / ( p + q ) ; return probability ; }
boolean check ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { return true ; } } return false ; }
int find_LCM ( int x , int y ) { return ( x * y ) / gcd ( x , y ) ; }
int CountPairs ( int n , int m , int A , int B ) { int cnt = 0 ; int lcm = find_LCM ( A , B ) ; for ( int i = 1 ; i <= n ; i ++ ) cnt += ( m + ( i % lcm ) ) / lcm ; return cnt ; }
void sortArr ( int arr [ ] , int n , int min , int max ) { int m = max - min + 1 ; int [ ] c = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ arr [ i ] - min ] ++ ; } for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < c [ i ] ; j ++ ) { System . out . print ( ( i + min ) + " " ) ; } } }
void revereseArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n / 2 ; i ++ ) arr [ i ] = __ ( arr [ n - i - 1 ] , arr [ n - i - 1 ] = arr [ i ] ) ; }
double recursiveLogStar ( double n , double b ) { if ( n > 1.0 ) return 1.0 + recursiveLogStar ( _log ( n , b ) , b ) ; else return 0 ; }
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
double maxKth ( int arr [ ] , int N , int C , int K ) { if ( N + C < K ) { return - 1 ; } int iter = 300 ; double l = 0 , r = 1000000000.0 ; while ( iter -- > 0 ) { double mid = ( l + r ) * 0.5 ; double a = 0 ; double b = 0 ; for ( int i = 0 ; i < N ; i ++ ) { a += ( int ) ( ( double ) arr [ i ] / mid ) ; if ( ( double ) arr [ i ] >= mid ) { b ++ ; } } if ( a >= K && b + C >= K ) { l = mid ; } else { r = mid ; } } return l ; }
boolean isPossibleToSelect ( int [ ] arr , int N , int dif , int K ) { int count = 1 ; int prev = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] >= ( prev + dif ) ) { count ++ ; if ( count == K ) return true ; prev = arr [ i ] ; } } return false ; }
int binarySearch ( int [ ] arr , int left , int right , int K , int N ) { int ans = 1 ; while ( left <= right ) { int dif = left + ( right - left ) / 2 ; if ( isPossibleToSelect ( arr , N , dif , K ) ) { ans = Math . max ( ans , dif ) ; left = dif + 1 ; } else right = dif - 1 ; } return ans ; }
int cal ( int arr [ ] , int mid ) { int chocolate = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] >= mid ) chocolate += arr [ i ] - mid ; } return chocolate ; }
boolean check ( int [ ] bananas , int mid_val , int H ) { int time = 0 ; for ( int i = 0 ; i < bananas . length ; i ++ ) { if ( bananas [ i ] % mid_val != 0 ) { time += ( ( bananas [ i ] / mid_val ) + 1 ) ; } else { time += ( bananas [ i ] / mid_val ) ; } } if ( time <= H ) { return true ; } else { return false ; } }
int minEatingSpeed ( int [ ] piles , int H ) { int start = 1 ; int end = Arrays . stream ( piles ) . max ( ) . getAsInt ( ) ; while ( start < end ) { int mid = start + ( end - start ) / 2 ; if ( ( check ( piles , mid , H ) ) == true ) { end = mid ; } else { start = mid + 1 ; } } return end ; }
boolean is_prefix ( String temp , String str ) { if ( temp . length ( ) < str . length ( ) ) return false ; else { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) != temp . charAt ( i ) ) return false ; } return true ; } }
String lexicographicallyString ( String [ ] input , int n , String str ) { Arrays . sort ( input ) ; for ( int i = 0 ; i < n ; i ++ ) { String temp = input [ i ] ; if ( is_prefix ( temp , str ) ) { return temp ; } } return "-1" ; }
int minSumPair ( int arr [ ] , int N ) { if ( N < 5 ) { return - 1 ; } int [ ] prefixMin = new int [ N ] ; prefixMin [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N - 1 ; i ++ ) { prefixMin [ i ] = Math . min ( arr [ i ] , prefixMin [ i - 1 ] ) ; } int ans = Integer . MAX_VALUE ; for ( int i = 3 ; i < N - 1 ; i ++ ) { ans = Math . min ( ans , arr [ i ] + prefixMin [ i - 2 ] ) ; } return ans ; }
long check ( long H [ ] , long A [ ] , long mid , long N , long M , long L ) { long sum = 0 ; for ( long i = 0 ; i < N ; i ++ ) { long speed = mid * A [ ( int ) i ] + H [ ( int ) i ] ; if ( speed >= L ) { sum += speed ; } } return sum ; }
long buzzTime ( long N , long M , long L , long H [ ] , long A [ ] ) { long low = 0 , high = 100000000 ; long ans = 0 ; while ( high >= low ) { long mid = low + ( high - low ) / 2 ; if ( check ( H , A , mid , N , M , L ) >= M ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; }
void findCount ( String number ) { int sum = 0 ; for ( int i = 0 ; i < number . length ( ) ; ++ i ) { sum += number . charAt ( i ) - 48 ; } int count = 0 ; for ( int i = 0 ; i < number . length ( ) ; ++ i ) { int remaining_sum = sum - ( number . charAt ( i ) - 48 ) ; for ( int j = 0 ; j <= 9 ; ++ j ) { if ( ( remaining_sum + j ) % 3 == 0 && j != number . charAt ( i ) - 48 ) { ++ count ; } } } System . out . println ( count ) ; }
boolean is_possible ( int [ ] teams , int T , int k ) { int sum = 0 ; for ( int i = 0 ; i < teams . length ; i ++ ) { sum += Math . min ( T , teams [ i ] ) ; } return ( sum >= ( T * k ) ) ; }
int countOfTeams ( int [ ] teams_list , int N , int K ) { int lb = 0 ; double ub = 1e9 ; while ( lb <= ub ) { int mid = lb + ( int ) ( ub - lb ) / 2 ; if ( is_possible ( teams_list , mid , K ) ) { if ( ! is_possible ( teams_list , mid + 1 , K ) ) { return mid ; } else { lb = mid + 1 ; } } else { ub = mid - 1 ; } } return 0 ; }
void balBracketSequence ( String str ) { int n = str . length ( ) ; if ( str . charAt ( 0 ) == str . charAt ( n - 1 ) ) { System . out . println ( "No" ) ; } else { int cntForOpen = 0 , cntForClose = 0 ; int check = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( 0 ) ) cntForOpen ++ ; else if ( str . charAt ( i ) == str . charAt ( n - 1 ) ) cntForOpen -= 1 ; else cntForOpen += 1 ; if ( cntForOpen < 0 ) { check = 0 ; break ; } } if ( check != 0 && cntForOpen == 0 ) { System . out . print ( "Yes, " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( n - 1 ) ) System . out . print ( ')' ) ; else System . out . print ( '(' ) ; } return ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( 0 ) ) cntForClose ++ ; else cntForClose -- ; if ( cntForClose < 0 ) { check = 0 ; break ; } } if ( check != 0 && cntForClose == 0 ) { System . out . print ( "Yes, " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( 0 ) ) System . out . print ( '(' ) ; else System . out . print ( ')' ) ; } return ; } } System . out . print ( "No" ) ; } }
void minimumOperations ( int arr [ ] , int N ) { int mx = 0 , pos = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= mx ) { mx = arr [ i ] ; pos = i ; } } System . out . println ( ( mx - 1 ) * N + pos + 1 ) ; }
boolean check ( long v , long [ ] a ) { long tec = 0 , ans = 0 ; long [ ] b = new long [ ( int ) ( n + k + 1 ) ] ; for ( int i = 0 ; i < n ; i ++ ) { tec -= b [ i ] ; if ( a [ i ] + tec < v ) { long mov = v - a [ i ] - tec ; ans = ans + mov ; tec += mov ; b [ i + ( int ) k ] = mov ; } } return ans <= m ; }
long FindLargest ( long [ ] a ) { l = 1 ; r = ( long ) Math . pow ( 10 , 10 ) ; while ( r - l > 0 ) { long tm = ( l + r + 1 ) / 2 ; if ( check ( tm , a ) ) l = tm ; else r = tm - 1 ; } return l ; }
int largestAltitude ( int L , int B ) { if ( L > B ) { int t = L ; L = B ; B = t ; } int low = 0 , high = L ; int res = 0 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( mid <= ( B / 2 ) ) { res = mid ; low = mid + 1 ; } else high = mid - 1 ; } return res ; }
void findLargestIndex ( int arr [ ] , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] == i ) { System . out . println ( i ) ; return ; } } System . out . println ( - 1 ) ; }
boolean isMaximumMedian ( int arr [ ] [ ] , int N , int K , int mid ) { int [ ] [ ] Pre = new int [ N + 5 ] [ N + 5 ] ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) { Pre [ i + 1 ] [ j + 1 ] = Pre [ i + 1 ] [ j ] + Pre [ i ] [ j + 1 ] - Pre [ i ] [ j ] ; if ( arr [ i ] [ j ] <= mid ) Pre [ i + 1 ] [ j + 1 ] ++ ; } } int required = ( K * K + 1 ) / 2 ; boolean flag = false ; for ( int i = K ; i <= N ; ++ i ) { for ( int j = K ; j <= N ; ++ j ) { int X = Pre [ i ] [ j ] - Pre [ i - K ] [ j ] - Pre [ i ] [ j - K ] + Pre [ i - K ] [ j - K ] ; if ( X < required ) flag = true ; } } return flag ; }
int getPairsCount ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( a [ i ] * a [ j ] ) == Math . abs ( i - j ) ) count ++ ; } } return count ; }
int getPairsCount ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && ( arr [ i ] * arr [ j ] ) == Math . abs ( i - j ) ) { count ++ ; } } } return count ; }
int numberofSubsequences ( int a [ ] , int L , int R , int X , int n ) { int ans = 0 ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int cnt = 0 , sum = 0 ; int minVal = Integer . MAX_VALUE , maxVal = Integer . MIN_VALUE ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) == 0 ) { cnt += 1 ; sum += a [ j ] ; maxVal = Math . max ( maxVal , a [ j ] ) ; minVal = Math . min ( minVal , a [ j ] ) ; } } if ( cnt >= 2 && sum >= L && sum <= R && ( maxVal - minVal >= X ) ) { ans += 1 ; } } return ans ; }
void numberofBoxes ( int W , int B , int O ) { int low = 0 , high = Math . min ( W , B ) ; int ans = 0 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( ( ( W >= mid ) && ( B >= mid ) ) && ( ( W - mid ) + ( B - mid ) + O ) >= mid ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } System . out . println ( ans ) ; }
int minSwaps ( int N , int M , int A [ ] [ ] , int B [ ] [ ] ) { int count01 = 0 ; int count10 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { if ( A [ i ] [ j ] == 1 ) count10 ++ ; else count01 ++ ; } } } if ( count01 == count10 ) return count01 ; else return - 1 ; }
int Count ( int N , int K ) { if ( K == 0 ) return 0 ; int res = 0 ; int low = 1 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = ( mid * mid + mid ) / 2 ; if ( sum <= K ) { res = Math . max ( res , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } return res ; }
void createLoops ( Node root ) { preorderTraversal ( root ) ; int i ; for ( i = 1 ; i < even_ptrs . size ( ) ; i ++ ) even_ptrs . get ( i - 1 ) . abtr = even_ptrs . get ( i ) ; even_ptrs . get ( i - 1 ) . abtr = even_ptrs . get ( 0 ) ; for ( i = 1 ; i < odd_ptrs . size ( ) ; i ++ ) odd_ptrs . get ( i - 1 ) . abtr = odd_ptrs . get ( i ) ; odd_ptrs . get ( i - 1 ) . abtr = odd_ptrs . get ( 0 ) ; }
void traverseLoop ( Node start ) { Node curr = start ; do { System . out . print ( curr . data + " " ) ; curr = curr . abtr ; } while ( curr != start ) ; }
int repeatingElement ( int arr [ ] , int N ) { int M = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; M = Math . max ( M , arr [ i ] ) ; } int sum1 = M * ( M + 1 ) / 2 ; int ans = ( sum - sum1 ) / ( N - M ) ; return ans ; }
String lexicographicallyMaximum ( String S , int N ) { HashMap < Character , Integer > M = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { if ( M . containsKey ( S . charAt ( i ) ) ) M . put ( S . charAt ( i ) , M . get ( S . charAt ( i ) ) + 1 ) ; else M . put ( S . charAt ( i ) , 1 ) ; } Vector < Character > V = new Vector < Character > ( ) ; for ( char i = 'a' ; i < ( char ) ( 'a' + Math . min ( N , 25 ) ) ; ++ i ) { if ( M . containsKey ( i ) == false ) { V . add ( i ) ; } } int j = V . size ( ) - 1 ; for ( int i = 0 ; i < N ; ++ i ) { if ( S . charAt ( i ) >= ( 'a' + Math . min ( N , 25 ) ) || ( M . containsKey ( S . charAt ( i ) ) && M . get ( S . charAt ( i ) ) > 1 ) ) { if ( V . get ( j ) < S . charAt ( i ) ) continue ; M . put ( S . charAt ( i ) , M . get ( S . charAt ( i ) ) - 1 ) ; S = S . substring ( 0 , i ) + V . get ( j ) + S . substring ( i + 1 ) ; j -- ; } if ( j < 0 ) break ; } int l = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( l > j ) break ; if ( S . charAt ( i ) >= ( 'a' + Math . min ( N , 25 ) ) || M . containsKey ( S . charAt ( i ) ) && M . get ( S . charAt ( i ) ) > 1 ) { M . put ( S . charAt ( i ) , M . get ( S . charAt ( i ) ) - 1 ) ; S = S . substring ( 0 , i ) + V . get ( l ) + S . substring ( i + 1 ) ; l ++ ; } } return S ; }
void minimumK ( ArrayList < Integer > arr , int M , int N ) { int good = ( int ) ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) + 1 ; for ( int i = 1 ; i <= N ; i ++ ) { int K = i ; int candies = N ; int taken = 0 ; while ( candies > 0 ) { taken += Math . min ( K , candies ) ; candies -= Math . min ( K , candies ) ; for ( int j = 0 ; j < M ; j ++ ) { int consume = ( arr . get ( j ) * candies ) / 100 ; candies -= consume ; } } if ( taken >= good ) { System . out . print ( i ) ; return ; } } }
void minTimeToColor ( int node , int parent , int arrival_time ) { int current_time = 0 ; for ( int x = 0 ; x < edges [ node ] . size ( ) ; x ++ ) { if ( edges [ node ] . get ( x ) != parent ) { ++ current_time ; if ( current_time == arrival_time ) ++ current_time ; ans = Math . max ( ans , current_time ) ; minTimeToColor ( edges [ node ] . get ( x ) , node , current_time ) ; } } }
int countElement ( int arr [ ] , int N ) { int count = 0 ; HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } } for ( int i = 0 ; i < N ; i ++ ) { int lg = log2 ( arr [ i ] ) ; int p = ( int ) Math . pow ( 2 , lg ) ; if ( m . containsKey ( p ) ) { count ++ ; } } return count ; }
void findLarger ( int arr [ ] , int n ) { int mid = ( n + 1 ) / 2 ; int mx = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int count [ ] = new int [ mx + 1 ] ; for ( int i = 0 ; i < mx + 1 ; i ++ ) { count [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { count [ arr [ i ] ] ++ ; } for ( int i = mx ; i >= 0 ; i -- ) { while ( count [ i ] > 0 ) { count [ i ] -- ; mid -- ; System . out . print ( i + " " ) ; if ( mid == 0 ) break ; } if ( mid == 0 ) break ; } }
int maximizeMangoes ( int n , int m , int x , int y ) { int l = 0 , r = n ; int ans = 0 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( check ( n , m , x , y , mid ) ) { ans = mid ; l = mid + 1 ; } else r = mid - 1 ; } return ans ; }
double probability ( int [ ] arr1 , int [ ] arr2 ) { int N = arr1 . length ; int M = arr2 . length ; double res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int y = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( arr2 [ j ] > arr1 [ i ] ) y ++ ; } res += y ; } res = ( double ) res / ( double ) ( N * M ) ; return res ; }
double probability ( int [ ] arr1 , int [ ] arr2 ) { int N = arr1 . length ; int M = arr2 . length ; double res = 0 ; Arrays . sort ( arr2 ) ; for ( int i = 0 ; i < N ; i ++ ) { int y = countGreater ( arr2 , arr1 [ i ] ) ; res += y ; } res = ( double ) res / ( double ) ( N * M ) ; return res ; }
int countGreater ( int [ ] arr , int k ) { int n = arr . length ; int l = 0 ; int r = n - 1 ; int leftGreater = n ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; }
int findkthElement ( int arr [ ] , int n , int K ) { int l = 0 ; int h = n - 1 , r ; while ( l + 1 < h ) { int mid = ( l + h ) / 2 ; if ( arr [ l ] >= arr [ mid ] ) l = mid ; else h = mid ; } if ( arr [ l ] < arr [ h ] ) r = l ; else r = h ; if ( K <= r + 1 ) return arr [ r + 1 - K ] ; else return arr [ n - ( K - ( r + 1 ) ) ] ; }
int find ( Vector < Integer > arr , int N , int key ) { int l = 0 ; int h = N - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr . get ( mid ) == key ) return mid ; if ( arr . get ( l ) >= arr . get ( mid ) ) { if ( arr . get ( l ) >= key && key >= arr . get ( mid ) ) h = mid - 1 ; else l = mid + 1 ; } else { if ( arr . get ( mid ) >= key && key >= arr . get ( h ) ) l = mid + 1 ; else h = mid - 1 ; } } return - 1 ; }
void countInversions ( int arr [ ] , int n ) { Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { v . add ( i ) ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int itr = v . indexOf ( arr [ i ] ) ; ans += itr ; v . remove ( itr ) ; } System . out . println ( ans ) ; }
void countDistinct ( int arr [ ] , int L , int R ) { int count = 0 ; int pref [ ] = new int [ arr . length + 1 ] ; for ( int i = 1 ; i <= arr . length ; ++ i ) { count += arr [ i - 1 ] ; pref [ i ] = count ; } int left = binarysearch ( pref , L ) ; int right = binarysearch ( pref , R ) ; System . out . println ( ( right - left ) + 1 ) ; }
boolean ischar ( char x ) { if ( ( x >= 'A' && x <= 'Z' ) || ( x >= 'a' && x <= 'z' ) ) { return true ; } return false ; }
boolean isnum ( char x ) { if ( x >= '0' && x <= '9' ) return true ; return false ; }
void maxItems ( int n , int m , int a [ ] , int b [ ] , int K ) { int count = 0 ; int A [ ] = new int [ n + 1 ] ; int B [ ] = new int [ m + 1 ] ; A [ 0 ] = 0 ; B [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { A [ i ] = a [ i - 1 ] + A [ i - 1 ] ; } for ( int i = 1 ; i <= m ; i ++ ) { B [ i ] = b [ i - 1 ] + B [ i - 1 ] ; } for ( int i = 0 ; i <= n ; i ++ ) { if ( A [ i ] > K ) break ; int rem = K - A [ i ] ; int j = 0 ; int lo = 0 , hi = m ; while ( lo <= hi ) { int mid = ( lo + hi ) / 2 ; if ( B [ mid ] <= rem ) { j = mid ; lo = mid + 1 ; } else { hi = mid - 1 ; } } count = Math . max ( j + i , count ) ; } System . out . print ( count ) ; }
boolean isValid ( int [ ] weight , int n , int D , int mx ) { int st = 1 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += weight [ i ] ; if ( sum > mx ) { st ++ ; sum = weight [ i ] ; } if ( st > D ) return false ; } return true ; }
void shipWithinDays ( int [ ] weight , int D , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += weight [ i ] ; int s = weight [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s = Math . max ( s , weight [ i ] ) ; } int e = sum ; int res = - 1 ; while ( s <= e ) { int mid = s + ( e - s ) / 2 ; if ( isValid ( weight , n , D , mid ) ) { res = mid ; e = mid - 1 ; } else s = mid + 1 ; } System . out . println ( res ) ; }
int countWays ( int index , int target ) { if ( target == 0 ) return 1 ; if ( index < 0 target < 0 ) return 0 ; int inc = countWays ( index , target - psquare . get ( index ) ) ; int exc = countWays ( index - 1 , target ) ; return inc + exc ; }
int findSum ( int arr [ ] , int N , int pt ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += Math . abs ( arr [ i ] - pt ) ; } return sum ; }
void findArray ( int arr [ ] , int n ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int ans = - 1 , old_c = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { int curr_c = 0 ; for ( int k = j ; k < n ; k ++ ) { if ( arr [ k ] == arr [ j ] ) { curr_c ++ ; } } ; if ( curr_c == old_c ) { if ( arr [ j ] < ans ) ans = arr [ j ] ; } if ( curr_c > old_c ) { ans = arr [ j ] ; old_c = curr_c ; } } } v . add ( ans ) ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) System . out . print ( v . get ( i ) + " " ) ; }
void minDays ( int [ ] P , int [ ] arr ) { for ( int i = 1 ; i < P . length ; i ++ ) { P [ i ] += P [ i ] + P [ i - 1 ] ; } for ( int i = 0 ; i < arr . length ; i ++ ) { int index = binarySeach ( P , arr [ i ] ) ; if ( index != - 1 ) { System . out . print ( index + 1 + " " ) ; } else { System . out . print ( - 1 + " " ) ; } } }
int countTriplets ( int D , int [ ] arr ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; int ans = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( freq . containsKey ( arr [ i ] - D ) && freq . containsKey ( arr [ i ] - 2 * D ) ) { ans += freq . get ( arr [ i ] - D ) * freq . get ( arr [ i ] - 2 * D ) ; } if ( freq . containsKey ( arr [ i ] ) ) { freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . put ( arr [ i ] , 1 ) ; } } return ans ; }
int find_index ( int arr [ ] , int N ) { int max_value = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { max_value = Math . max ( max_value , arr [ i ] ) ; } Map < Integer , Integer > store = new HashMap < > ( ) ; for ( int i = 1 ; i <= max_value ; i ++ ) { store . put ( i , store . getOrDefault ( i , 0 ) + 1 ) ; } if ( store . containsKey ( 1 ) ) { store . remove ( 1 ) ; } for ( int i = 2 ; i <= Math . sqrt ( max_value ) ; i ++ ) { int multiple = 2 ; while ( ( i * multiple ) <= max_value ) { if ( store . containsKey ( i * multiple ) ) { store . remove ( i * multiple ) ; } multiple ++ ; } } int prime_sum_from_left = 0 ; int [ ] first_array = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { first_array [ i ] = prime_sum_from_left ; if ( store . containsKey ( arr [ i ] ) ) { prime_sum_from_left += arr [ i ] ; } } int prime_sum_from_right = 0 ; int [ ] second_array = new int [ N ] ; for ( int i = N - 1 ; i >= 0 ; i -- ) { second_array [ i ] = prime_sum_from_right ; if ( store . containsKey ( arr [ i ] ) ) { prime_sum_from_right += arr [ i ] ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( first_array [ i ] == second_array [ i ] ) { return i ; } } return - 1 ; }
void convert ( int arr [ ] , int n ) { int brr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; Arrays . sort ( brr ) ; for ( int i = 0 ; i < n ; i ++ ) { int l = 0 , r = n - 1 , mid ; while ( l <= r ) { mid = ( l + r ) / 2 ; if ( brr [ mid ] == arr [ i ] ) { System . out . print ( mid + " " ) ; break ; } else if ( brr [ mid ] < arr [ i ] ) { l = mid + 1 ; } else { r = mid - 1 ; } } } }
int findIndex ( int arr [ ] , int N ) { int maxValue = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { maxValue = Math . max ( maxValue , arr [ i ] ) ; } HashMap < Integer , Integer > St = new HashMap < > ( ) ; for ( int i = 1 ; i <= maxValue ; i ++ ) { St . put ( i , St . getOrDefault ( i , 0 ) + 1 ) ; } if ( St . containsKey ( 1 ) ) { St . remove ( 1 ) ; } for ( int i = 2 ; i <= Math . sqrt ( maxValue ) ; i ++ ) { int j = 2 ; while ( ( i * j ) <= maxValue ) { if ( St . containsKey ( i * j ) ) { St . remove ( i * j ) ; } j ++ ; } } int LeftCount = 0 ; int Prefix [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { Prefix [ i ] = LeftCount ; if ( St . containsKey ( arr [ i ] ) ) { LeftCount ++ ; } } int RightCount = 0 ; int Suffix [ ] = new int [ N ] ; for ( int i = N - 1 ; i >= 0 ; i -- ) { Suffix [ i ] = RightCount ; if ( St . containsKey ( arr [ i ] ) ) { RightCount ++ ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( Prefix [ i ] == Suffix [ i ] ) { return i ; } } return - 1 ; }
int getCountPairs ( int arr [ ] , int N , int S ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = i + 1 ; j < arr . length ; j ++ ) { if ( ( arr [ i ] + arr [ j ] ) == S ) count ++ ; } } return count ; }
boolean isPrime ( int N ) { if ( N == 1 ) return false ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; }
int findCoPrime ( int L , int R ) { int coPrime ; for ( int i = R + 1 ; ; i ++ ) { if ( isPrime ( i ) ) { coPrime = i ; break ; } } return coPrime ; }
void replaceCharacters ( String s , char [ ] [ ] p ) { int n = s . length ( ) , k = p . length ; char [ ] arr = new char [ 26 ] ; char [ ] brr = new char [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ s . charAt ( i ) - 'a' ] = s . charAt ( i ) ; brr [ s . charAt ( i ) - 'a' ] = s . charAt ( i ) ; } for ( int j = 0 ; j < k ; j ++ ) { char a = p [ j ] [ 0 ] , b = p [ j ] [ 1 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( arr [ i ] == a ) { brr [ i ] = b ; } } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( brr [ s . charAt ( i ) - 'a' ] ) ; } }
void maximumValue ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { ans = Math . max ( ans , arr [ i ] + arr [ j ] + i - j ) ; } } System . out . println ( ans ) ; }
void maximumValue ( int arr [ ] , int n ) { int maxvalue = arr [ 0 ] ; int result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { result = Math . max ( result , maxvalue + arr [ i ] - i ) ; maxvalue = Math . max ( maxvalue , arr [ i ] + i ) ; } System . out . println ( result ) ; }
void smallestSemiPrime ( int n ) { boolean [ ] prime = new boolean [ MAX ] ; for ( int i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } SieveOfEratosthenes ( prime ) ; int num1 = n + 1 ; while ( prime [ num1 ] != true ) { num1 ++ ; } int num2 = num1 + n ; while ( prime [ num2 ] != true ) { num2 ++ ; } System . out . print ( num1 * num2 ) ; }
void productOfTwoPerfectCubes ( int N ) { Map < Integer , Integer > cubes = new HashMap < > ( ) ; for ( int i = 1 ; i * i * i <= N ; i ++ ) cubes . put ( i * i * i , i ) ; for ( Map . Entry < Integer , Integer > itr : cubes . entrySet ( ) ) { int firstNumber = itr . getKey ( ) ; if ( N % itr . getKey ( ) == 0 ) { int secondNumber = N / itr . getKey ( ) ; if ( cubes . containsKey ( secondNumber ) ) { System . out . println ( "Yes" ) ; return ; } } } System . out . println ( "No" ) ; }
void productOfTwoPerfectCubes ( double N ) { double cube_root ; cube_root = Math . round ( Math . cbrt ( N ) ) ; if ( cube_root * cube_root * cube_root == N ) { System . out . println ( "Yes" ) ; return ; } else { System . out . println ( "No" ) ; return ; } }
boolean bound ( int w , int h , int N , int x ) { int val = ( x / w ) * ( x / h ) ; if ( val >= N ) return true ; else return false ; }
int FindSquare ( int N , int W , int H ) { int i = 1 ; int j = W * H * N ; while ( i < j ) { int mid = i + ( j - i ) / 2 ; if ( bound ( W , H , N , mid ) ) j = mid ; else i = mid + 1 ; } return j ; }
void printNumberOfPairs ( int N ) { HashSet < Integer > st = new HashSet < Integer > ( ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { int x = i ; while ( x <= N ) { x *= i ; if ( x <= N ) { st . add ( x ) ; } } } System . out . println ( st . size ( ) ) ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
void maximumProduct ( String [ ] words ) { int [ ] bits = new int [ words . length ] ; for ( int i = 0 ; i < words . length ; i ++ ) { for ( int j = 0 ; j < words [ i ] . length ( ) ; j ++ ) { bits [ i ] = bits [ i ] | 1 << ( words [ i ] . charAt ( j ) - 'a' ) ; } } int result = 0 ; for ( int i = 0 ; i < bits . length ; i ++ ) { for ( int j = i + 1 ; j < bits . length ; j ++ ) { if ( ( bits [ i ] & bits [ j ] ) == 0 ) { int L = countSetBits ( bits [ i ] ) ; int R = countSetBits ( bits [ j ] ) ; result = Math . max ( L * R , result ) ; } } } System . out . println ( result ) ; }
int closestValue ( int A [ ] , int k ) { int close = A [ A . length - 1 ] ; int it = lower_bound ( A , k ) ; if ( it != A . length ) { close = A [ it ] ; if ( it != 0 ) { if ( ( k - A [ it - 1 ] ) < ( close - k ) ) { close = A [ it - 1 ] ; } } } return close ; }
void minPossible ( int arr [ ] , int brr [ ] , int crr [ ] ) { Arrays . sort ( arr ) ; Arrays . sort ( crr ) ; int minimum = Integer . MAX_VALUE ; for ( int val : brr ) { int arr_close = closestValue ( arr , val ) ; int crr_close = closestValue ( crr , val ) ; if ( Math . abs ( val - arr_close ) + Math . abs ( val - crr_close ) < minimum ) minimum = Math . abs ( val - arr_close ) + Math . abs ( val - crr_close ) ; } System . out . println ( minimum ) ; }
int findCost ( int [ ] A , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; }
boolean palindrome ( String str ) { int st = 0 ; int ed = str . length ( ) - 1 ; while ( st < ed ) { if ( str . charAt ( st ) == str . charAt ( ed ) ) { st ++ ; ed -- ; } else return false ; } return true ; }
boolean possible ( int A [ ] , int N , int mid , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { count += ( A [ i ] - 1 ) / mid ; } return count <= K ; }
int minimumMaximum ( int A [ ] , int N , int K ) { int lo = 1 ; Arrays . sort ( A ) ; int hi = A [ N - 1 ] ; int mid ; while ( lo < hi ) { mid = ( lo + hi ) / 2 ; if ( possible ( A , N , mid , K ) ) { hi = mid ; } else { lo = mid + 1 ; } } return hi ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
void sumOfPrimeSquare ( int n ) { int i = 0 ; ArrayList < Integer > squares = new ArrayList < Integer > ( ) ; while ( i * i < n ) { squares . add ( i * i ) ; i ++ ; } boolean flag = false ; for ( i = 0 ; i < squares . size ( ) ; i ++ ) { int difference = n - squares . get ( i ) ; if ( isPrime ( difference ) ) { flag = true ; break ; } } if ( flag ) { System . out . print ( "Yes" ) ; } else System . out . print ( "No" ) ; }
void SieveOfEratosthenes ( boolean prime [ ] , int n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } }
void sumOfPrimeSquare ( int n ) { boolean flag = false ; boolean [ ] prime = new boolean [ n + 1 ] ; for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , n ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ! prime [ i ] ) continue ; int dif = n - i ; if ( Math . ceil ( ( double ) Math . sqrt ( dif ) ) == Math . floor ( ( double ) Math . sqrt ( dif ) ) ) { flag = true ; break ; } } if ( flag ) { System . out . print ( "Yes" ) ; } else System . out . print ( "No" ) ; }
int minimum_swaps ( Integer arr [ ] , int n ) { int count = 0 ; int max_el = Collections . max ( Arrays . asList ( arr ) ) ; int min_el = Collections . min ( Arrays . asList ( arr ) ) ; if ( min_el == max_el ) return 0 ; int index_max = - 1 ; int index_min = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max_el && index_max == - 1 ) { index_max = i ; } if ( arr [ i ] == min_el ) { index_min = i ; } } count += index_max ; count += ( n - 1 - index_min ) ; if ( index_min < index_max ) count -= 1 ; return count ; }
boolean check ( int arr [ ] , int M , int K , int ind ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 1 ; j < K ; j ++ ) { if ( arr [ ind + i ] != arr [ ind + i + j * M ] ) { return false ; } } } return true ; }
boolean SubarrayRepeatsKorMore ( int arr [ ] , int N , int M , int K ) { for ( int ind = 0 ; ind <= N - M * K ; ind ++ ) { if ( check ( arr , M , K , ind ) ) { return true ; } } return false ; }
boolean checkExists ( int arr [ ] , int N , int M , int K ) { int count = 0 ; for ( int i = 0 ; i < N - M ; i ++ ) { if ( arr [ i ] == arr [ i + M ] ) count ++ ; else count = 0 ; if ( count == M * ( K - 1 ) ) return true ; } return false ; }
int CommonDigits ( int N , int M ) { int count = 0 ; int freq1 [ ] = new int [ 10 ] ; int freq2 [ ] = new int [ 10 ] ; while ( N > 0 ) { freq1 [ N % 10 ] ++ ; N = N / 10 ; } while ( M > 0 ) { freq2 [ M % 10 ] ++ ; M = M / 10 ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( freq1 [ i ] > 0 & freq2 [ i ] > 0 ) { count ++ ; } } return count ; }
void minimumNumber ( int K , int X ) { if ( K > X ) { System . out . println ( "-1" ) ; return ; } int ans = 0 ; int sum = 0 ; for ( int i = K ; i <= X ; i ++ ) { sum += i ; if ( sum >= X ) { ans = i ; break ; } } System . out . println ( ans ) ; }
boolean isGreaterEqual ( int N , int K , int X ) { return ( ( N * 1L * ( N + 1 ) / 2 ) - ( ( K - 1 ) * 1L * K / 2 ) ) >= X ; }
int left_search ( ArrayList < Integer > A , int num ) { int low = 0 , high = A . size ( ) - 1 ; int ans = 0 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( A . get ( mid ) >= num ) { ans = mid ; high = mid - 1 ; } else { low = mid + 1 ; } } return ans ; }
void totalCount ( int [ ] [ ] A , int N , int M , int [ ] [ ] queries , int Q ) { int row_sum [ ] = new int [ N ] ; int col_sum [ ] = new int [ M ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { row_sum [ i ] += A [ i ] [ j ] ; col_sum [ j ] += A [ i ] [ j ] ; } } ArrayList < Integer > sum_list = new ArrayList < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) sum_list . add ( row_sum [ i ] ) ; for ( int i = 0 ; i < M ; i ++ ) sum_list . add ( col_sum [ i ] ) ; Collections . sort ( sum_list ) ; for ( int i = 0 ; i < Q ; i ++ ) { int L = queries [ i ] [ 0 ] ; int R = queries [ i ] [ 1 ] ; int l = left_search ( sum_list , L ) ; int r = right_search ( sum_list , R ) ; System . out . print ( r - l + 1 + " " ) ; } }
int search ( ArrayList < Integer > list , int num ) { int low = 0 , high = list . size ( ) - 1 ; int ans = - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( list . get ( mid ) <= num ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; }
boolean isPalindrome ( int n ) { int rev = 0 ; int temp = n ; while ( n > 0 ) { rev = rev * 10 + n % 10 ; n /= 10 ; } return rev == temp ; }
int countNumbers ( int L , int R , int K ) { ArrayList < Integer > list = new ArrayList < > ( ) ; for ( int i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) ) { list . add ( i ) ; } } int count = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { int right_index = search ( list , list . get ( i ) + K - 1 ) ; if ( right_index != - 1 ) count = Math . max ( count , right_index - i + 1 ) ; } return count ; }
int maximumLength ( int [ ] [ ] mat , int v ) { distance = 0 ; int N = mat [ 0 ] . length ; ArrayList < Boolean > visited = new ArrayList < Boolean > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { visited . add ( false ) ; } ArrayList < ArrayList < Integer > > Adj = new ArrayList < ArrayList < Integer > > ( N ) ; for ( int i = 0 ; i < N ; i ++ ) { Adj . add ( new ArrayList < Integer > ( ) ) ; } int i , j ; for ( i = 0 ; i < mat [ 0 ] . length ; i ++ ) { for ( j = 0 ; j < mat . length ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { Adj . get ( i ) . add ( j ) ; } } } dfs ( v , Adj , visited , 0 ) ; return distance ; }
void getMaximumDifference ( int Edges [ ] [ ] , int arr [ ] , int N , int M ) { ans = 0 ; ArrayList < ArrayList < Integer > > Adj = new ArrayList < > ( ) ; for ( int i = 0 ; i < N + 1 ; i ++ ) Adj . add ( new ArrayList < > ( ) ) ; for ( int i = 0 ; i < M ; i ++ ) { int u = Edges [ i ] [ 0 ] ; int v = Edges [ i ] [ 1 ] ; Adj . get ( u ) . add ( v ) ; } DFS ( 1 , Adj , arr , arr [ 0 ] , arr [ 0 ] ) ; System . out . println ( ans ) ; }
int minimumDeletions ( String S ) { int len = 0 ; int n = S . length ( ) ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = i + 1 ; j < 26 ; j ++ ) { int newLen = findLength ( S , ( char ) ( i + 97 ) , ( char ) ( j + 97 ) ) ; len = Math . max ( len , newLen ) ; } } return n - len ; }
int findMinX ( int A [ ] , int B [ ] , int N ) { int prod = 1 ; for ( int i = 0 ; i < N ; i ++ ) prod *= A [ i ] ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int pp = prod / A [ i ] ; result += B [ i ] * inv ( pp , A [ i ] ) * pp ; } return result % prod ; }
void findPairs ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = Math . abs ( arr [ i ] ) ; Arrays . sort ( arr ) ; int left = 0 ; int ans = 0 ; for ( int right = 0 ; right < N ; right ++ ) { while ( 2 * arr [ left ] < arr [ right ] ) left ++ ; ans += ( right - left ) ; } System . out . print ( ans ) ; }
int GetDiff ( int A [ ] , int N ) { int SuffMaxArr [ ] = new int [ N ] ; SuffMaxArr [ N - 1 ] = A [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; -- i ) { SuffMaxArr [ i ] = Math . max ( SuffMaxArr [ i + 1 ] , A [ i + 1 ] ) ; } int MaximumSum = Integer . MIN_VALUE ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] < SuffMaxArr [ i ] ) MaximumSum = Math . max ( MaximumSum , A [ i ] + SuffMaxArr [ i ] ) ; } int MinimumSum = Integer . MAX_VALUE ; int SuffMinArr [ ] = new int [ N ] ; SuffMinArr [ N - 1 ] = Integer . MAX_VALUE ; for ( int i = N - 2 ; i >= 0 ; -- i ) { SuffMinArr [ i ] = Math . min ( SuffMinArr [ i + 1 ] , A [ i + 1 ] ) ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] < SuffMinArr [ i ] ) { MinimumSum = Math . min ( MinimumSum , A [ i ] + SuffMinArr [ i ] ) ; } } return Math . abs ( MaximumSum - MinimumSum ) ; }
void minimumSwaps ( int arr [ ] , int N ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != i % 2 ) { if ( i % 2 == 0 ) { even ++ ; } else { odd ++ ; } } } if ( even != odd ) { System . out . println ( - 1 ) ; } else { System . out . println ( even ) ; } }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
void primeFactorSum ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( k % arr [ i ] == 0 && isPrime ( arr [ i ] ) ) { sum = sum + arr [ i ] ; } } System . out . println ( sum ) ; }
void CalculateValues ( int N ) { int A = 0 , B = 0 , C = 0 ; for ( C = 0 ; C < N / 7 ; C ++ ) { for ( B = 0 ; B < N / 5 ; B ++ ) { A = N - 7 * C - 5 * B ; if ( A >= 0 && A % 3 == 0 ) { System . out . print ( "A = " + A / 3 + ", B = " + B + ", C = " + C ) ; return ; } } } System . out . println ( - 1 ) ; }
int mininsert ( int arr [ ] , int K , int N ) { int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int a = Math . min ( arr [ i ] , arr [ i + 1 ] ) ; int b = Math . max ( arr [ i ] , arr [ i + 1 ] ) ; while ( K * a < b ) { a *= K ; ans ++ ; } } return ans ; }
void makeLexicographically ( int arr [ ] , int length ) { int index = 0 ; int temp = 0 ; int check = 0 ; int condition = 0 ; int element = 0 ; for ( int i = 0 ; i < length ; ++ i ) { if ( element == arr [ i ] ) { check = i ; break ; } else if ( arr [ i ] != i + 1 && check == 0 ) { index = i ; check = 1 ; condition = - 1 ; element = i + 1 ; } } if ( condition == - 1 ) { temp = arr [ index ] ; arr [ index ] = arr [ check ] ; arr [ check ] = temp ; } print ( arr ) ; }
void print_triplet ( int arr [ ] , int n ) { for ( int i = 1 ; i <= n - 2 ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] && arr [ i ] > arr [ i + 1 ] ) { System . out . print ( i - 1 + " " + i + " " + ( i + 1 ) ) ; return ; } } System . out . print ( - 1 ) ; }
void findConcatenatedNumbers ( int [ ] a , int [ ] b ) { boolean ans = true ; int n1 = a . length ; int n2 = b . length ; int cnt [ ] = new int [ 100000 ] ; for ( int i = 0 ; i < n1 ; i ++ ) { cnt [ a [ i ] ] = 1 ; } for ( int i = 0 ; i < n2 ; i ++ ) { int left = b [ i ] ; int right = 0 ; int mul = 1 ; while ( left > 9 ) { right += ( left % 10 ) * mul ; left /= 10 ; mul *= 10 ; if ( cnt [ left ] == 1 && cnt [ right ] == 1 ) { ans = false ; System . out . print ( b [ i ] + " " ) ; } } } if ( ans ) System . out . print ( "-1" ) ; }
void evenproduct ( int arr [ ] , int length ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { int product = 1 ; for ( int j = i ; j < arr . length ; j ++ ) { product *= arr [ j ] ; if ( product % 2 == 0 ) ++ count ; } } System . out . println ( count ) ; }
void evenproduct ( int arr [ ] , int length ) { int total_subarray = length * ( length + 1 ) / 2 ; int total_odd = 0 ; int count_odd = 0 ; for ( int i = 0 ; i < arr . length ; ++ i ) { if ( arr [ i ] % 2 == 0 ) { count_odd = 0 ; } else { ++ count_odd ; total_odd += count_odd ; } } System . out . println ( total_subarray - total_odd ) ; }
void dfsUtil ( int u , int par , int depth ) { for ( int it : adj [ u ] ) { if ( it != par ) { dfsUtil ( it , u , depth + 1 ) ; } } ans += depth ; }
Boolean isInGroupUtil ( int [ ] [ ] mat ) { for ( int i = 0 ; i < mat . length ; i ++ ) { Vector < Integer > arr = new Vector < Integer > ( ) ; for ( int j = 0 ; j < mat [ i ] . length ; j ++ ) { arr . add ( mat [ i ] [ j ] ) ; } if ( ! checkGroup ( arr ) ) return false ; } return true ; }
void isInGroup ( int [ ] [ ] mat ) { Boolean ans = isInGroupUtil ( mat ) ; if ( ans ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
int convertBinaryToDecimal ( ArrayList < Integer > arr ) { int ans = 0 ; for ( int i : arr ) ans = ( ans << 1 ) | i ; return ans ; }
void decimalEquilvalentAtEachLevel ( TreeNode root ) { int ans = 0 ; Queue < TreeNode > que = new LinkedList < > ( ) ; que . add ( root ) ; while ( true ) { int length = que . size ( ) ; if ( length == 0 ) break ; ArrayList < Integer > eachLvl = new ArrayList < > ( ) ; while ( length > 0 ) { TreeNode temp = que . poll ( ) ; eachLvl . add ( temp . val ) ; if ( temp . left != null ) que . add ( temp . left ) ; if ( temp . right != null ) que . add ( temp . right ) ; length -= 1 ; } ans += convertBinaryToDecimal ( eachLvl ) ; } System . out . println ( ans ) ; }
void countSubstrings ( String s ) { int ans = 0 ; int subs = 1 ; char pre = '0' ; for ( char i : s . toCharArray ( ) ) { if ( pre == i ) { subs += 1 ; } else { subs = 1 ; } ans += subs ; pre = i ; } System . out . println ( ans ) ; }
void longestSequence ( int arr [ ] , int N ) { if ( N == 0 ) { System . out . println ( 0 ) ; return ; } Arrays . sort ( arr ) ; int maxLen = 1 ; int len = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] arr [ i ] == arr [ i - 1 ] + 1 ) { len ++ ; maxLen = Math . max ( maxLen , len ) ; } else { len = 1 ; } } System . out . println ( maxLen ) ; }
void minimumOperations ( int [ ] arr , int N ) { int oddCnt = 0 , evenCnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { evenCnt ++ ; } else { oddCnt ++ ; } } System . out . print ( Math . min ( oddCnt , evenCnt ) ) ; }
int productOfDigits ( int N ) { int product = 1 ; while ( N != 0 ) { product = product * ( N % 10 ) ; N = N / 10 ; } return product ; }
void hasArrayTwoPairs ( int nums [ ] , int n , int target ) { Arrays . sort ( nums ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = target - nums [ i ] ; int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = low + ( ( high - low ) / 2 ) ; if ( nums [ mid ] > x ) { high = mid - 1 ; } else if ( nums [ mid ] < x ) { low = mid + 1 ; } else { if ( mid == i ) { if ( ( mid - 1 >= 0 ) && nums [ mid - 1 ] == x ) { System . out . print ( nums [ i ] + ", " ) ; System . out . print ( nums [ mid - 1 ] ) ; return ; } if ( ( mid + 1 < n ) && nums [ mid + 1 ] == x ) { System . out . print ( nums [ i ] + ", " ) ; System . out . print ( nums [ mid + 1 ] ) ; return ; } break ; } else { System . out . print ( nums [ i ] + ", " ) ; System . out . print ( nums [ mid ] ) ; return ; } } } } System . out . print ( - 1 ) ; }
void minSum ( int arr [ ] , int N , int Q [ ] , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int val = Q [ i ] ; int front = 0 , rear = 0 ; for ( int j = 0 ; j < N ; j ++ ) { front += arr [ j ] ; if ( arr [ j ] == val ) { break ; } } for ( int j = N - 1 ; j >= 0 ; j -- ) { rear += arr [ j ] ; if ( arr [ j ] == val ) { break ; } } System . out . print ( Math . min ( front , rear ) + " " ) ; } }
void minOperations ( int [ ] arr , int N , int [ ] Q , int M ) { Map < Integer , Integer > m1 = new HashMap < Integer , Integer > ( ) ; Map < Integer , Integer > m2 = new HashMap < Integer , Integer > ( ) ; int front = 0 , rear = 0 ; for ( int i = 0 ; i < N ; i ++ ) { front += arr [ i ] ; m1 . put ( arr [ i ] , front ) ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { rear += arr [ i ] ; m2 . put ( arr [ i ] , rear ) ; } for ( int i = 0 ; i < M ; i ++ ) { System . out . print ( Math . min ( m1 . get ( Q [ i ] ) , m2 . get ( Q [ i ] ) ) + " " ) ; } }
boolean checkAnagram ( String s1 , String s2 ) { int s2hash [ ] = new int [ 26 ] ; int s1hash [ ] = new int [ 26 ] ; int s1len = s1 . length ( ) ; int s2len = s2 . length ( ) ; if ( s1len > s2len ) return false ; int left = 0 , right = 0 ; while ( right < s1len ) { s1hash [ s1 . charAt ( right ) - 'a' ] += 1 ; s2hash [ s2 . charAt ( right ) - 'a' ] += 1 ; right ++ ; } right -= 1 ; while ( right < s2len ) { if ( Arrays . equals ( s1hash , s2hash ) ) return true ; right ++ ; if ( right != s2len ) s2hash [ s2 . charAt ( right ) - 'a' ] += 1 ; s2hash [ s2 . charAt ( left ) - 'a' ] -= 1 ; left ++ ; } return false ; }
void findSubstring ( String S ) { String T = "" ; String ans = "" ; int l = 0 ; T += S . charAt ( 0 ) ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { if ( Math . abs ( S . charAt ( i ) - S . charAt ( i - 1 ) ) == 1 ) { l = T . length ( ) ; if ( l > ans . length ( ) ) { ans = T ; } T = "" ; T += S . charAt ( i ) ; } else { T += S . charAt ( i ) ; } } l = T . length ( ) ; if ( l > ans . length ( ) ) { ans = T ; } System . out . println ( ans ) ; }
void DFS ( int row , int col , int [ ] [ ] grid , int M , int N ) { boolean [ ] [ ] vis = new boolean [ M + 1 ] [ N + 1 ] ; for ( int i = 0 ; i < M + 1 ; i ++ ) { for ( int j = 0 ; j < N + 1 ; j ++ ) { vis [ i ] [ j ] = false ; } } DFSUtil ( 0 , 0 , grid , vis , M , N ) ; }
void DFS_iterative ( int [ ] [ ] grid , int M , int N ) { vis = new Vector < Vector < Boolean > > ( ) ; for ( int i = 0 ; i < M + 5 ; i ++ ) { vis . add ( new Vector < Boolean > ( ) ) ; for ( int j = 0 ; j < N + 5 ; j ++ ) { vis . get ( i ) . add ( false ) ; } } Vector < Pair > st = new Vector < Pair > ( ) ; st . add ( new Pair ( 0 , 0 ) ) ; vis . get ( 0 ) . set ( 0 , true ) ; while ( st . size ( ) > 0 ) { Pair p = st . get ( st . size ( ) - 1 ) ; st . remove ( st . size ( ) - 1 ) ; int row = p . Item1 ; int col = p . Item2 ; System . out . print ( grid [ row ] [ col ] + " " ) ; for ( int i = 0 ; i < 4 ; i ++ ) { int x = row + dRow [ i ] ; int y = col + dCol [ i ] ; if ( isValid ( x , y , M , N ) ) { st . add ( new Pair ( x , y ) ) ; vis . get ( x ) . set ( y , true ) ; } } } }
void suffixArr ( int arr [ ] , int suffix [ ] [ ] , int N ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 ) { suffix [ i ] [ 0 ] = arr [ i ] ; suffix [ i ] [ 1 ] = arr [ i ] ; } else { suffix [ i ] [ 0 ] = Math . max ( suffix [ i + 1 ] [ 0 ] , arr [ i ] ) ; suffix [ i ] [ 1 ] = Math . min ( suffix [ i + 1 ] [ 1 ] , arr [ i ] ) ; } } }
void MinMaxQueries ( int a [ ] , int Q [ ] [ ] ) { int N = a . length ; int q = Q . length ; int prefix [ ] [ ] = new int [ N ] [ 2 ] ; int suffix [ ] [ ] = new int [ N ] [ 2 ] ; prefixArr ( a , prefix , N ) ; suffixArr ( a , suffix , N ) ; for ( int i = 0 ; i < q ; i ++ ) { int L = Q [ i ] [ 0 ] ; int R = Q [ i ] [ 1 ] ; maxAndmin ( prefix , suffix , N , L , R ) ; } }
boolean check ( int a [ ] , int n ) { boolean flag = false ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i + 1 ] > a [ i ] && a [ i ] < a [ i - 1 ] ) flag = true ; } if ( flag ) return false ; else return true ; }
void smallestNumber ( int arr [ ] , int len ) { int maxi = 0 ; for ( int i = 0 ; i < len ; i ++ ) { maxi = Math . max ( maxi , arr [ i ] ) ; } int ans = - 1 ; for ( int i = 2 ; i < maxi + 2 ; i ++ ) { boolean flag = true ; for ( int j = 0 ; j < len ; j ++ ) { if ( arr [ j ] % i == 0 ) { flag = false ; break ; } } if ( flag ) { ans = i ; break ; } } System . out . print ( ans ) ; }
void findDuplicate ( String str , int N ) { int first = 0 ; int second = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( first & ( 1 << ( str . charAt ( i ) - 'a' ) ) ) != 0 ) { second = second | ( 1 << ( str . charAt ( i ) - 'a' ) ) ; } else { first = first | ( 1 << ( str . charAt ( i ) - 'a' ) ) ; } } for ( int i = 0 ; i < 26 ; i ++ ) { if ( ( ( first & ( 1 << i ) ) & ( second & ( 1 << i ) ) ) != 0 ) { System . out . print ( ( char ) ( i + 'a' ) + " " ) ; } } }
void minOperations ( String S ) { int count = 0 ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { if ( S . charAt ( i ) != S . charAt ( i - 1 ) ) { count += 1 ; } } System . out . print ( count ) ; }
int check ( int N ) { if ( Integer . bitCount ( N ) == 1 ) return 1 ; else return 0 ; }
void build_seg_tree ( int ss , int se , int si , int tree [ ] , int arr [ ] ) { if ( ss == se ) { tree [ si ] = check ( arr [ ss ] ) ; return ; } int mid = ( ss + se ) / 2 ; build_seg_tree ( ss , mid , 2 * si + 1 , tree , arr ) ; build_seg_tree ( mid + 1 , se , 2 * si + 2 , tree , arr ) ; tree [ si ] = tree [ 2 * si + 1 ] + tree [ 2 * si + 2 ] ; }
int query ( int l , int r , int ss , int se , int si , int tree [ ] ) { if ( r < ss l > se ) return 0 ; if ( l <= ss && r >= se ) return tree [ si ] ; int mid = ( ss + se ) / 2 ; return query ( l , r , ss , mid , 2 * si + 1 , tree ) + query ( l , r , mid + 1 , se , 2 * si + 2 , tree ) ; }
void numberOfPairs ( int arr [ ] , int N ) { int [ ] set_bits = new int [ 31 ] ; Arrays . fill ( set_bits , 0 ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int x = arr [ i ] ; int bitpos = - 1 ; while ( x > 0 ) { bitpos ++ ; x /= 2 ; } for ( int j = 0 ; j <= bitpos ; j ++ ) { count += set_bits [ j ] ; } set_bits [ bitpos ] ++ ; } System . out . println ( count ) ; }
void calculateQuery ( int arr [ ] , int N , int query [ ] , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int X = query [ i ] ; int sum_start = 0 , sum_end = 0 ; for ( int j = 0 ; j < N ; j ++ ) { sum_start += arr [ j ] ; if ( arr [ j ] == X ) break ; } for ( int j = N - 1 ; j >= 0 ; j -- ) { sum_end += arr [ j ] ; if ( arr [ j ] == X ) break ; } System . out . print ( Math . min ( sum_end , sum_start ) + " " ) ; } }
@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) static void calculateQuery ( int arr [ ] , int N , int query [ ] , int M ) { int prefix = 0 , suffix = 0 ; HashMap < Integer , pair > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { prefix += arr [ i ] ; mp . put ( arr [ i ] , new pair ( prefix , 0 ) ) ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { suffix += arr [ i ] ; mp . put ( arr [ i ] , new pair ( mp . get ( arr [ i ] ) . first , suffix ) ) ; } for ( int i = 0 ; i < M ; i ++ ) { int X = query [ i ] ; System . out . print ( Math . min ( ( int ) mp . get ( X ) . first , ( int ) mp . get ( X ) . second ) + " " ) ; } }
void minOps ( String s , int N ) { int ans = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) ) { ans ++ ; } } if ( ans % 2 == 1 ) { System . out . print ( ( ans - 1 ) / 2 ) ; return ; } System . out . print ( ans / 2 ) ; }
void oddOneOut ( int arr [ ] , int N ) { int odd = 0 , even = 0 ; int lastOdd = 0 , lastEven = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { even ++ ; lastEven = i ; } else { odd ++ ; lastOdd = i ; } } if ( odd == 1 ) { System . out . println ( lastOdd ) ; } else { System . out . println ( lastEven ) ; } }
void mulsum ( int arr [ ] , int n , int N ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % N == 0 ) { sum = sum + arr [ i ] ; } } System . out . println ( sum ) ; }
boolean isGreaterEqual ( int N , int X ) { return ( N * ( N + 1 ) / 2 ) >= X ; }
int minimumPossible ( int X ) { for ( int i = 1 ; i <= X ; i ++ ) { if ( isGreaterEqual ( i , X ) ) return i ; } return 0 ; }
boolean isGreaterEqual ( int N , int X ) { return ( N * ( N + 1 ) / 2 ) >= X ; }
int minimumPossible ( int X ) { int low = 1 , high = X , res = - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( isGreaterEqual ( mid , X ) ) { res = mid ; high = mid - 1 ; } else low = mid + 1 ; } return res ; }
boolean CheckDivByAllDigits ( int number ) { int n = number ; while ( n > 0 ) { if ( n % 10 != 0 ) if ( number % ( n % 10 ) != 0 ) { return false ; } n /= 10 ; } return true ; }
void cntNumInRang ( int arr [ ] [ ] , int N ) { int prefCntDiv [ ] = new int [ Max + 1 ] ; for ( int i = 1 ; i <= Max ; i ++ ) { int ans = 0 ; if ( CheckDivByAllDigits ( i ) ) ans = 1 ; prefCntDiv [ i ] = prefCntDiv [ i - 1 ] + ans ; } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( ( prefCntDiv [ arr [ i ] [ 1 ] ] - prefCntDiv [ arr [ i ] [ 0 ] - 1 ] ) + " " ) ; }
int arrayNesting ( int [ ] arr ) { int res = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == i ) { res = Math . max ( res , 1 ) ; } else { int count = 0 ; int curr_index = i ; while ( arr [ curr_index ] != curr_index ) { int next_index = arr [ curr_index ] ; arr [ curr_index ] = curr_index ; curr_index = next_index ; count ++ ; } res = Math . max ( res , count ) ; } } return res ; }
void count ( int a [ ] , int n ) { if ( n == 1 ) { System . out . print ( 0 ) ; return ; } int [ ] pre = new int [ n - 1 ] ; int [ ] suf = new int [ n - 1 ] ; int max = a [ 0 ] ; int ans = 0 , i ; pre [ 0 ] = a [ 0 ] ; for ( i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i ] > max ) max = a [ i ] ; pre [ i ] = max ; } max = a [ n - 1 ] ; suf [ n - 2 ] = a [ n - 1 ] ; for ( i = n - 2 ; i >= 1 ; i -- ) { if ( a [ i ] > max ) max = a [ i ] ; suf [ i - 1 ] = max ; } for ( i = 0 ; i < n - 1 ; i ++ ) { if ( pre [ i ] < suf [ i ] ) ans ++ ; } System . out . print ( ans ) ; }
void countNumbers ( int L , int R ) { int Count = 0 ; for ( int i = 0 ; i < index ; i ++ ) { int p = prime [ i ] ; if ( p >= L && p <= R ) { Count ++ ; } } System . out . println ( Count ) ; }
int xorSubsequence ( int a [ ] , int n , int k ) { int ans = 0 ; HashMap < Integer , Integer > map = new HashMap < > ( ) ; int dp [ ] = new int [ n ] ; map . put ( a [ 0 ] , 1 ) ; dp [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { Integer dpj = map . get ( a [ i ] ^ k ) ; if ( dpj != null ) dp [ i ] = Math . max ( dp [ i ] , dpj + 1 ) ; ans = Math . max ( ans , dp [ i ] ) ; map . put ( a [ i ] , Math . max ( map . getOrDefault ( a [ i ] , 1 ) , dp [ i ] ) ) ; } return ans >= 2 ? ans : 0 ; }
void distance ( TreeNode root , int target , int distancesum , int n ) { if ( root . data == target ) { sum = distancesum ; } if ( root . left != null ) { int tempsum = distancesum - root . left . size + ( n - root . left . size ) ; distance ( root . left , target , tempsum , n ) ; } if ( root . right != null ) { int tempsum = distancesum - root . right . size + ( n - root . right . size ) ; distance ( root . right , target , tempsum , n ) ; } }
void countRemainingElements ( int [ ] L1 , int [ ] L2 , int n ) { int one = 0 ; int zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( L1 [ i ] == 1 ) one ++ ; else zero ++ ; } int ans = n ; for ( int i = 0 ; i < n ; i ++ ) { if ( L2 [ i ] == 1 ) { one -- ; if ( one < 0 ) { ans = i ; break ; } } else { zero -- ; if ( zero < 0 ) { ans = i ; break ; } } } System . out . println ( n - ans ) ; }
void minTime ( int arr [ ] , int N , int K ) { Queue < Integer > q = new LinkedList < > ( ) ; boolean vis [ ] = new boolean [ N + 1 ] ; int time = 0 ; for ( int i = 0 ; i < K ; i ++ ) { q . add ( arr [ i ] ) ; vis [ arr [ i ] ] = true ; } while ( q . size ( ) > 0 ) { for ( int i = 0 ; i < q . size ( ) ; i ++ ) { int curr = q . poll ( ) ; if ( curr - 1 >= 1 && ! vis [ curr - 1 ] ) { vis [ curr - 1 ] = true ; q . add ( curr - 1 ) ; } if ( curr + 1 <= N && ! vis [ curr + 1 ] ) { vis [ curr + 1 ] = true ; q . add ( curr + 1 ) ; } } time ++ ; } System . out . println ( time - 1 ) ; }
int getCount ( int rows , int columns , int [ ] [ ] A ) { int res = 0 ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = i + 1 ; j < rows ; j ++ ) { if ( A [ i ] [ 0 ] * A [ j ] [ 1 ] == A [ i ] [ 1 ] * A [ j ] [ 0 ] ) { res ++ ; } } } return res ; }
void Min_Score_Index ( int N , int [ ] A ) { int [ ] Score = new int [ N ] ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( A [ i ] + i < N ) Score [ i ] = A [ i ] * Score [ A [ i ] + i ] ; else Score [ i ] = A [ i ] ; } int min_value = Integer . MAX_VALUE ; for ( int i : Score ) min_value = Math . min ( i , min_value ) ; int ind = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( Score [ i ] == min_value ) ind = i ; } System . out . print ( ind ) ; }
void minLength ( String S , String T , int N , int M ) { String temp = "" ; int subtract = 0 ; for ( int i = 0 ; i < N ; ++ i ) { temp += S . charAt ( i ) ; if ( temp . length ( ) >= M ) { if ( T . equals ( temp . substring ( temp . length ( ) - M , temp . length ( ) ) ) ) { subtract += M ; int cnt = 0 ; while ( cnt != M ) { temp = temp . substring ( 0 , temp . length ( ) - 1 ) ; ++ cnt ; } } } } System . out . println ( ( N - subtract ) ) ; }
int maximumCount ( int [ ] arr1 , int [ ] arr2 , int s1 , int s2 ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < s1 ; i ++ ) { sum1 += arr1 [ i ] ; } for ( int j = 0 ; j < s2 ; j ++ ) { sum2 += arr2 [ j ] ; } int len = 0 ; if ( s1 >= s2 ) { len = s2 ; } else { len = s1 ; } Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; int j = 0 , k = s2 - 1 , count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( sum1 <= sum2 ) { if ( arr2 [ k ] >= arr1 [ i ] ) { int dif1 = arr1 [ j ] , dif2 = arr2 [ k ] ; sum1 -= dif1 ; sum1 += dif2 ; sum2 -= dif2 ; sum2 += dif1 ; j ++ ; k -- ; count ++ ; } else { break ; } } else { break ; } } return count ; }
int noOfValidKbers ( int K , int arr [ ] ) { HashSet < Integer > set = new HashSet < > ( ) ; while ( K != 0 ) { set . add ( K % 10 ) ; K = K / 10 ; } int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { int no = arr [ i ] ; boolean flag = true ; while ( no != 0 ) { int digit = no % 10 ; if ( ! set . contains ( digit ) ) { flag = false ; break ; } no = no / 10 ; } if ( flag == true ) { count ++ ; } } return count ; }
void build ( int arr [ ] , int index , int s , int e ) { if ( s == e ) Tree [ index ] = arr [ s ] ; else { int m = ( s + e ) / 2 ; build ( arr , 2 * index , s , m ) ; build ( arr , 2 * index + 1 , m + 1 , e ) ; Tree [ index ] = Math . max ( Tree [ 2 * index ] , Tree [ 2 * index + 1 ] ) ; } }
boolean isSubarrayExistUtil ( int arr [ ] , int K , int N ) { int totalXOR = 0 ; int SubarrayXOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) totalXOR ^= arr [ i ] ; for ( int i = 0 ; i < K ; i ++ ) SubarrayXOR ^= arr [ i ] ; if ( SubarrayXOR == ( totalXOR ^ SubarrayXOR ) ) return true ; for ( int i = K ; i < N ; i ++ ) { SubarrayXOR ^= arr [ i ] ; SubarrayXOR ^= arr [ i - 1 ] ; if ( SubarrayXOR == ( totalXOR ^ SubarrayXOR ) ) return true ; } return false ; }
void countPairs ( int L , int R ) { int count_even ; if ( L % 2 == 0 ) { count_even = ( R / 2 ) - ( L / 2 ) + 1 ; } else { count_even = ( R / 2 ) - ( L / 2 ) ; } int count_odd ; if ( L % 2 == 0 ) { count_odd = ( ( R + 1 ) / 2 ) - ( ( L + 1 ) / 2 ) ; } else { count_odd = ( ( R + 1 ) / 2 ) - ( ( L + 1 ) / 2 ) + 1 ; } count_even *= count_even ; count_odd *= count_odd ; System . out . println ( count_even + count_odd ) ; }
int delCost ( String s , int [ ] cost ) { int ans = 0 ; HashMap < Character , Integer > forMax = new HashMap < > ( ) ; HashMap < Character , Integer > forTot = new HashMap < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! forMax . containsKey ( s . charAt ( i ) ) ) { forMax . put ( s . charAt ( i ) , cost [ i ] ) ; } else { forMax . put ( s . charAt ( i ) , Math . max ( cost [ i ] , forMax . get ( s . charAt ( i ) ) ) ) ; } if ( ! forTot . containsKey ( s . charAt ( i ) ) ) { forTot . put ( s . charAt ( i ) , cost [ i ] ) ; } else { forTot . put ( s . charAt ( i ) , forTot . get ( s . charAt ( i ) ) + cost [ i ] ) ; } } for ( Map . Entry < Character , Integer > i : forMax . entrySet ( ) ) { ans += forTot . get ( i . getKey ( ) ) - i . getValue ( ) ; } return ans ; }
int findPeak ( ArrayList < Integer > arr ) { int left = 0 ; int right = arr . size ( ) - 1 ; while ( left < right ) { int mid = left + ( right - left ) / 2 ; if ( arr . get ( mid ) < arr . get ( mid + 1 ) ) { left = mid + 1 ; } else { right = mid ; } } return left ; }
int BS ( int X , int left , int right , ArrayList < Integer > arr ) { while ( left <= right ) { int mid = left + ( right - left ) / 2 ; if ( arr . get ( mid ) == X ) { return mid ; } else if ( X > arr . get ( mid ) ) { left = mid + 1 ; } else { right = mid - 1 ; } } return - 1 ; }
int reverseBS ( int X , int left , int right , ArrayList < Integer > arr ) { while ( left <= right ) { int mid = left + ( right - left ) / 2 ; if ( arr . get ( mid ) == X ) { return mid ; } else if ( X > arr . get ( mid ) ) { right = mid - 1 ; } else { left = mid + 1 ; } } return - 1 ; }
int getDefiniteFinds ( int [ ] arr ) { int n = arr . length ; int [ ] smallestRight = new int [ n + 1 ] ; smallestRight [ n ] = Integer . MAX_VALUE ; for ( int i = n - 1 ; i >= 0 ; i -- ) { smallestRight [ i ] = Math . min ( smallestRight [ i + 1 ] , arr [ i ] ) ; } int mn = Integer . MIN_VALUE ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mn < arr [ i ] && arr [ i ] < smallestRight [ i + 1 ] ) { ans ++ ; } mn = Math . max ( arr [ i ] , mn ) ; } return ans ; }
void Count_numbers ( int L , int R ) { int count = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) count += 1 ; System . out . print ( count ) ; }
int findIndex ( int [ ] arr , int N ) { int rightSum = 0 ; int leftSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { rightSum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { rightSum -= arr [ i ] ; if ( checkReverse ( leftSum , rightSum ) ) { return i ; } leftSum += arr [ i ] ; } return - 1 ; }
void minimumTime ( int [ ] arr , int n ) { int sum = 0 ; int T = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } System . out . println ( Math . max ( 2 * T , sum ) ) ; }
void findClosest ( int N , int target ) { int closest = - 1 ; int diff = Integer . MAX_VALUE ; for ( int i = 1 ; i <= ( int ) Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( N / i == i ) { if ( Math . abs ( target - i ) < diff ) { diff = Math . abs ( target - i ) ; closest = i ; } } else { if ( Math . abs ( target - i ) < diff ) { diff = Math . abs ( target - i ) ; closest = i ; } if ( Math . abs ( target - N / i ) < diff ) { diff = Math . abs ( target - N / i ) ; closest = N / i ; } } } } System . out . println ( closest ) ; }
void computeDivisors ( ) { for ( int i = 1 ; i <= MAX ; i ++ ) { for ( int j = i ; j <= MAX ; j += i ) { divisors [ j ] . add ( i ) ; } } }
int getClosest ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; }
int findClosest ( Vector < Integer > array , int n , int target ) { Integer [ ] arr = array . toArray ( new Integer [ array . size ( ) ] ) ; if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ; int i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) / 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ; if ( target < arr [ mid ] ) { if ( mid > 0 && target > arr [ mid - 1 ] ) return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) ; j = mid ; } else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) ; i = mid + 1 ; } } return arr [ mid ] ; }
void printClosest ( int N , int X ) { computeDivisors ( ) ; int ans = findClosest ( divisors [ N ] , divisors [ N ] . size ( ) , X ) ; System . out . print ( ans ) ; }
int LCS ( int [ ] firstArr , int [ ] secondArr ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < firstArr . length ; i ++ ) { mp . put ( firstArr [ i ] , i + 1 ) ; } Vector < Integer > tempArr = new Vector < > ( ) ; for ( int i = 0 ; i < secondArr . length ; i ++ ) { if ( mp . containsKey ( secondArr [ i ] ) ) { tempArr . add ( mp . get ( secondArr [ i ] ) ) ; } } Vector < Integer > tail = new Vector < > ( ) ; tail . add ( tempArr . get ( 0 ) ) ; for ( int i = 1 ; i < tempArr . size ( ) ; i ++ ) { if ( tempArr . get ( i ) > tail . lastElement ( ) ) tail . add ( tempArr . get ( i ) ) ; else if ( tempArr . get ( i ) < tail . get ( 0 ) ) tail . add ( 0 , tempArr . get ( i ) ) ; } return ( int ) tail . size ( ) ; }
int maxSubarrayProduct ( Vector < Integer > arr , int n ) { int max_ending_here = 1 ; int min_ending_here = 1 ; int max_so_far = 0 ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr . get ( i ) > 0 ) { max_ending_here = max_ending_here * arr . get ( i ) ; min_ending_here = Math . min ( min_ending_here * arr . get ( i ) , 1 ) ; flag = 1 ; } else if ( arr . get ( i ) == 0 ) { max_ending_here = 1 ; min_ending_here = 1 ; } else { int temp = max_ending_here ; max_ending_here = Math . max ( min_ending_here * arr . get ( i ) , 1 ) ; min_ending_here = temp * arr . get ( i ) ; } if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } if ( flag == 0 && max_so_far == 0 ) return 0 ; return max_so_far ; }
int findMaxProduct ( int [ ] a , int n ) { int i = 0 ; int maxProd = 1 ; while ( i < n ) { Vector < Integer > v = new Vector < > ( ) ; v . add ( a [ i ] ) ; if ( i < n - 1 && a [ i ] < a [ i + 1 ] ) { while ( i < n - 1 && a [ i ] < a [ i + 1 ] ) { v . add ( a [ i + 1 ] ) ; i += 1 ; } } else if ( i < n - 1 && a [ i ] > a [ i + 1 ] ) { while ( i < n - 1 && a [ i ] > a [ i + 1 ] ) { v . add ( a [ i + 1 ] ) ; i += 1 ; } } int prod = maxSubarrayProduct ( v , v . size ( ) ) ; maxProd = Math . max ( maxProd , prod ) ; i ++ ; } return maxProd ; }
void PrimeFactors ( int N ) { Stack < Integer > st = new Stack < > ( ) ; int i = 2 ; while ( N != 1 ) { if ( N % i == 0 ) { st . push ( i ) ; while ( N % i == 0 ) { N = N / i ; } } i ++ ; } while ( ! st . isEmpty ( ) ) { System . out . println ( st . peek ( ) ) ; st . pop ( ) ; } }
int power ( int A , int N ) { int count = 0 ; if ( A == 1 ) return 0 ; while ( N > 0 ) { count ++ ; N /= A ; } return count ; }
int LCM ( int A , int B ) { return ( A * B / __gcd ( A , B ) ) ; }
void findSmallestNumber ( int X ) { int lcm = 1 ; int temp = X ; while ( temp > 0 ) { int last = temp % 10 ; temp /= 10 ; if ( last == 0 ) continue ; lcm = LCM ( lcm , last ) ; } int answer = ( ( X + lcm - 1 ) / lcm ) * lcm ; System . out . print ( answer ) ; }
int findNonMultiples ( int [ ] arr , int n , int k ) { Set < Integer > multiples = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! multiples . contains ( arr [ i ] ) ) { for ( int j = 1 ; j <= k / arr [ i ] ; j ++ ) { multiples . add ( arr [ i ] * j ) ; } } } return k - multiples . size ( ) ; }
int countValues ( int [ ] arr , int N , int L , int R ) { return findNonMultiples ( arr , N , R ) - findNonMultiples ( arr , N , L - 1 ) ; }
void minSum ( int N ) { long low = 0 , high = 1000000000 ; while ( low + 1 < high ) { long mid = low + ( high - low ) / 2 ; if ( mid * mid >= N ) { high = mid ; } else { low = mid ; } } long first = high ; low = 0 ; high = 1000000000 ; while ( low + 1 < high ) { long mid = low + ( high - low ) / 2 ; if ( first * mid > N ) { high = mid ; } else { low = mid ; } } long second = high ; System . out . println ( first + second ) ; }
void minSum ( int N ) { int ans = ( int ) Math . ceil ( 2 * Math . sqrt ( N + 1 ) ) ; System . out . println ( ans ) ; }
int root ( int a ) { if ( a == parent [ a ] ) { return a ; } return parent [ a ] = root ( parent [ a ] ) ; }
void connect ( int a , int b ) { a = root ( a ) ; b = root ( b ) ; if ( a != b ) { parent [ b ] = a ; } }
int find_ht ( TreeNode root ) { if ( root == null ) return 0 ; if ( root . left == null && root . right == null ) return 1 ; return Math . max ( find_ht ( root . left ) , find_ht ( root . right ) ) + 1 ; }
int countFreq ( int N , int K ) { int count = 0 ; while ( N > 0 ) { if ( N % 10 == K ) { count ++ ; } N = N / 10 ; } return count ; }
int findElementUtil ( int arr [ ] , int N , int K ) { int c ; int max ; int ele = 0 ; max = 0 ; for ( int i = 0 ; i < N ; i ++ ) { c = countFreq ( arr [ i ] , K ) ; if ( c > max ) { max = c ; ele = arr [ i ] ; } } if ( max == 0 ) return - 1 ; else return ele ; }
void findOverlapSegement ( int N , int [ ] a , int [ ] b ) { ArrayList < pair > tup = new ArrayList < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int x , y ; x = a [ i ] ; y = b [ i ] ; tup . add ( new pair ( x , y , i ) ) ; } Collections . sort ( tup , ( aa , bb ) -> ( aa . l != bb . l ) ? aa . l - bb . l : aa . r - bb . r ) ; int curr = tup . get ( 0 ) . r ; int currPos = tup . get ( 0 ) . index ; for ( int i = 1 ; i < N ; i ++ ) { int Q = tup . get ( i - 1 ) . l ; int R = tup . get ( i ) . l ; if ( Q == R ) { if ( tup . get ( i - 1 ) . r < tup . get ( i ) . r ) System . out . print ( tup . get ( i - 1 ) . index + " " + tup . get ( i ) . index ) ; else System . out . print ( tup . get ( i ) . index + " " + tup . get ( i - 1 ) . index ) ; return ; } int T = tup . get ( i ) . r ; if ( T <= curr ) { System . out . print ( tup . get ( i ) . index + " " + currPos ) ; return ; } else { curr = T ; currPos = tup . get ( i ) . index ; } } System . out . print ( "-1 -1" ) ; }
boolean isSpiralSorted ( int [ ] arr , int n ) { int start = 0 ; int end = n - 1 ; while ( start < end ) { if ( arr [ start ] > arr [ end ] ) { return false ; } start ++ ; if ( arr [ end ] > arr [ start ] ) { return false ; } end -- ; } return true ; }
int findMinDeletions ( int [ ] [ ] v , int n ) { int minDel = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int L = v [ i ] [ 0 ] ; int R = v [ i ] [ 1 ] ; int Count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( v [ j ] [ 0 ] >= L && v [ j ] [ 1 ] <= R ) { Count += 1 ; } } minDel = Math . min ( minDel , n - Count ) ; } return minDel ; }
int maxEvenIntegers ( int arr [ ] , int N , int M ) { int ans = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i + j ] % 2 == 0 ) cnt ++ ; } ans = Math . max ( ans , cnt ) ; } return ans ; }
int MaxNonEmpSubSeq ( int a [ ] , int n ) { int sum = 0 ; int max = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( max < a [ i ] ) { max = a [ i ] ; } } if ( max <= 0 ) { return max ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) { sum += a [ i ] ; } } return sum ; }
void findMaxLengthSequence ( int N , int [ ] arr ) { int rightmost_element = - 1 ; int i = 0 ; int j = N - 1 ; Vector < Integer > sequence = new Vector < Integer > ( ) ; while ( i <= j ) { if ( arr [ i ] > arr [ j ] ) { if ( arr [ j ] > rightmost_element ) { sequence . add ( arr [ j ] ) ; rightmost_element = arr [ j ] ; j -- ; } else if ( arr [ i ] > rightmost_element ) { sequence . add ( arr [ i ] ) ; rightmost_element = arr [ i ] ; i ++ ; } else break ; } else if ( arr [ i ] < arr [ j ] ) { if ( arr [ i ] > rightmost_element ) { sequence . add ( arr [ i ] ) ; rightmost_element = arr [ i ] ; i ++ ; } else if ( arr [ j ] > rightmost_element ) { sequence . add ( arr [ j ] ) ; rightmost_element = arr [ j ] ; j -- ; } else break ; } else if ( arr [ i ] == arr [ j ] ) { if ( i == j ) { if ( arr [ i ] > rightmost_element ) { sequence . add ( arr [ i ] ) ; rightmost_element = arr [ i ] ; i ++ ; } break ; } else { sequence . add ( arr [ i ] ) ; int k = i + 1 ; Vector < Integer > max_left = new Vector < Integer > ( ) ; while ( k < j && arr [ k ] > arr [ k - 1 ] ) { max_left . add ( arr [ k ] ) ; k ++ ; } int l = j - 1 ; Vector < Integer > max_right = new Vector < Integer > ( ) ; while ( l > i && arr [ l ] > arr [ l + 1 ] ) { max_right . add ( arr [ l ] ) ; l -- ; } if ( max_left . size ( ) > max_right . size ( ) ) for ( int element : max_left ) sequence . add ( element ) ; else for ( int element : max_right ) sequence . add ( element ) ; break ; } } } for ( int element : sequence ) System . out . print ( element + " " ) ; }
long getcount ( long n , int k ) { long res = ( n >> ( k + 1 ) ) << k ; if ( ( ( n >> k ) & 1 ) != 0 ) res += n & ( ( 1 << k ) - 1 ) ; return res ; }
void countDivisors ( int n ) { int count = 0 ; int j = 0 ; int divisor [ ] = new int [ n ] ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { divisor [ j ] = i ; j += 1 ; } else { divisor [ j ] = i ; divisor [ j + 1 ] = n / i ; j += 2 ; } } } divisor [ j ] = n ; for ( int i = 0 ; i <= j ; i ++ ) { int x = divisor [ i ] ; x -= 1 ; if ( ( n / x ) == ( n % x ) ) count ++ ; } System . out . print ( count ) ; }
int smallestIndexArrayElementsFlip ( int arr [ ] , int N ) { int pos = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] *= - 1 ; int sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) { sum += arr [ j ] ; } if ( sum == 0 ) { pos = i ; break ; } else { arr [ i ] *= - 1 ; } } return pos ; }
int smallestIndexArrayElementsFlip ( int arr [ ] , int N ) { int pos = - 1 ; int ArrSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { ArrSum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( 2 * arr [ i ] == ArrSum ) { pos = i ; break ; } } return pos ; }
double [ ] MaxAverage ( TreeNode root ) { if ( root . children != null && root . children . size ( ) == 0 ) { ans = Math . max ( ans , root . val ) ; return new double [ ] { root . val , 1 } ; } double [ ] childResult = new double [ 2 ] ; for ( TreeNode child : root . children ) { double [ ] childTotal = MaxAverage ( child ) ; childResult [ 0 ] = childResult [ 0 ] + childTotal [ 0 ] ; childResult [ 1 ] = childResult [ 1 ] + childTotal [ 1 ] ; } double sum = childResult [ 0 ] + root . val ; double count = childResult [ 1 ] + 1 ; ans = Math . max ( ans , sum / count ) ; return new double [ ] { sum , count } ; }
int make_array_element_even ( int arr [ ] , int N ) { int res = 0 ; int odd_cont_seg = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd_cont_seg ++ ; } else { if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += ( odd_cont_seg / 2 ) + 2 ; } odd_cont_seg = 0 ; } } } if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += odd_cont_seg / 2 + 2 ; } } return res ; }
void findSum ( int a [ ] ) { int ans = 0 ; for ( int low = 0 ; low < a . length ; low ++ ) { for ( int high = low ; high < a . length ; high ++ ) { int count = 0 ; int maxNumber = 0 ; for ( int i = low ; i <= high ; i ++ ) { if ( a [ i ] == maxNumber ) count ++ ; else if ( a [ i ] > maxNumber ) { maxNumber = a [ i ] ; count = 1 ; } } ans += maxNumber * ( ( count % 2 == 0 ) ? 2 : 1 ) ; } } System . out . println ( ans ) ; }
void countPairs ( int [ ] arr , int n ) { HashMap < Integer , Integer > mp1 = new HashMap < Integer , Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( mp1 . containsKey ( sum ) ) { mp1 . put ( sum , mp1 . get ( sum ) + 1 ) ; } else { mp1 . put ( sum , 1 ) ; } } sum = 0 ; int ans = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { sum += arr [ i ] ; if ( mp1 . containsKey ( sum ) ) { ans += mp1 . get ( sum ) ; } } System . out . print ( ans ) ; }
void minCollectingSpeed ( int [ ] piles , int H ) { int ans = - 1 ; int low = 1 , high ; high = Arrays . stream ( piles ) . max ( ) . getAsInt ( ) ; while ( low <= high ) { int K = low + ( high - low ) / 2 ; int time = 0 ; for ( int ai : piles ) { time += ( ai + K - 1 ) / K ; } if ( time <= H ) { ans = K ; high = K - 1 ; } else { low = K + 1 ; } } System . out . print ( ans ) ; }
boolean isMagic ( int num ) { return ( num % 9 == 1 ) ; }
int findSmallestInteger ( int arr [ ] , int N , int K ) { int left = 1 ; int right = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; while ( left < right ) { int mid = ( left + right ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += ( arr [ i ] + mid - 1 ) / mid ; } if ( sum > K ) { left = mid + 1 ; } else { right = mid ; } } return left ; }
int minimum_deci_binary_number ( String s ) { int m = Integer . MIN_VALUE ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int temp = s . charAt ( i ) - '0' ; if ( temp > m ) { m = temp ; } } return m ; }
int minimumReverse ( String s , int n ) { int k = 0 , l = 0 ; int sum1 = 0 , sum0 = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) sum1 ++ ; else sum0 ++ ; if ( s . charAt ( i ) == s . charAt ( i - 1 ) && s . charAt ( i ) == '0' ) k ++ ; else if ( s . charAt ( i ) == s . charAt ( i - 1 ) && s . charAt ( i ) == '1' ) l ++ ; } if ( s . charAt ( 0 ) == '1' ) sum1 ++ ; sum0 ++ ; if ( Math . abs ( sum1 - sum0 ) > 1 ) return - 1 ; return Math . max ( k , l ) ; }
void canTransformStrings ( String A , String B ) { int n1 = A . length ( ) ; int n2 = B . length ( ) ; int count1A = 0 , count1B = 0 ; int odd1A = 0 , odd1B = 0 ; int even1A = 0 , even1B = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( A . charAt ( i ) == '1' ) count1A ++ ; else { if ( ( count1A & 1 ) == 1 ) odd1A ++ ; else even1A ++ ; } } for ( int i = 0 ; i < n2 ; i ++ ) { if ( B . charAt ( i ) == '1' ) count1B ++ ; else { if ( ( count1B & 1 ) == 1 ) odd1B ++ ; else even1B ++ ; } } if ( count1A == count1B && odd1A == odd1B && even1A == even1B ) { System . out . print ( "Yes" ) ; } else System . out . print ( "No" ) ; }
void maxPairs ( int [ ] nums , int k ) { Map < Integer , Integer > map = new HashMap < > ( ) ; int result = 0 ; for ( int i : nums ) { if ( map . containsKey ( i ) && map . get ( i ) > 0 ) { map . put ( i , map . get ( i ) - 1 ) ; result ++ ; } else { map . put ( k - i , map . getOrDefault ( k - i , 0 ) + 1 ) ; } } System . out . println ( result ) ; }
void uniqueElements ( int arr [ ] , int start , int K , Map < Integer , Integer > mp ) { Set < Integer > st = new HashSet < > ( ) ; for ( int i = 0 ; i < K ; i ++ ) st . add ( arr [ start + i ] ) ; Iterator itr = st . iterator ( ) ; while ( itr . hasNext ( ) ) { Integer t = ( Integer ) itr . next ( ) ; mp . put ( t , mp . getOrDefault ( t , 0 ) + 1 ) ; } }
void smallestPresentNumber ( int arr [ ] , int N , int K ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i <= N - K ; i ++ ) { uniqueElements ( arr , i , K , mp ) ; } checkAnswer ( mp , N , K ) ; }
void generateK ( int arr [ ] , int N ) { for ( int k = 1 ; k <= N ; k ++ ) smallestPresentNumber ( arr , N , k ) ; }
void printAnswer ( int answer [ ] , int N ) { for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( answer [ i ] + " " ) ; } }
void lengthOfSubarray ( ArrayList < ArrayList < Integer > > indices , Set < Integer > st , int N ) { int [ ] answer = new int [ N + 1 ] ; Arrays . fill ( answer , - 1 ) ; Iterator itr = st . iterator ( ) ; while ( itr . hasNext ( ) ) { int start = - 1 ; int gap = - 1 ; int t = ( int ) itr . next ( ) ; indices . get ( t ) . add ( N ) ; for ( int i = 0 ; i < indices . get ( t ) . size ( ) ; i ++ ) { gap = Math . max ( gap , indices . get ( t ) . get ( i ) - start ) ; start = indices . get ( t ) . get ( i ) ; } if ( answer [ gap ] == - 1 ) answer [ gap ] = t ; } updateAnswerArray ( answer , N ) ; printAnswer ( answer , N ) ; }
void smallestPresentNumber ( int arr [ ] , int N ) { ArrayList < ArrayList < Integer > > indices = new ArrayList < > ( ) ; for ( int i = 0 ; i <= N ; i ++ ) indices . add ( new ArrayList < Integer > ( ) ) ; Set < Integer > elements = new HashSet < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { indices . get ( arr [ i ] ) . add ( i ) ; elements . add ( arr [ i ] ) ; } lengthOfSubarray ( indices , elements , N ) ; }
void removeIndicesToMakeSumEqual ( int [ ] arr ) { int N = arr . length ; int [ ] odd = new int [ N ] ; int [ ] even = new int [ N ] ; even [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { odd [ i ] = odd [ i - 1 ] ; even [ i ] = even [ i - 1 ] ; if ( i % 2 == 0 ) { even [ i ] += arr [ i ] ; } else { odd [ i ] += arr [ i ] ; } } boolean find = false ; int p = odd [ N - 1 ] ; int q = even [ N - 1 ] - arr [ 0 ] ; if ( p == q ) { System . out . print ( "0 " ) ; find = true ; } for ( int i = 1 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { p = even [ N - 1 ] - even [ i - 1 ] - arr [ i ] + odd [ i - 1 ] ; q = odd [ N - 1 ] - odd [ i - 1 ] + even [ i - 1 ] ; } else { q = odd [ N - 1 ] - odd [ i - 1 ] - arr [ i ] + even [ i - 1 ] ; p = even [ N - 1 ] - even [ i - 1 ] + odd [ i - 1 ] ; } if ( p == q ) { find = true ; System . out . print ( i + " " ) ; } } if ( ! find ) { System . out . print ( - 1 ) ; } }
int cntDisPairs ( int arr [ ] , int N , int K ) { int cntPairs = 0 ; Arrays . sort ( arr ) ; int i = 0 ; int j = N - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] == K ) { while ( i < j && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } while ( i < j && arr [ j ] == arr [ j - 1 ] ) { j -- ; } cntPairs += 1 ; i ++ ; j -- ; } else if ( arr [ i ] + arr [ j ] < K ) { i ++ ; } else { j -- ; } } return cntPairs ; }
int maxLength ( int a [ ] , int b [ ] , int n , int c ) { if ( n == 0 ) return 0 ; int max_length = 0 ; int low = 0 , high = n ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( possible ( a , b , n , c , mid ) ) { max_length = mid ; low = mid + 1 ; } else high = mid - 1 ; } return max_length ; }
boolean possible ( int a [ ] , int b [ ] , int n , int c , int k ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { sum += a [ i ] ; } int total_cost = sum * k + getMax ( b , 0 , n - 1 , 0 , k - 1 , 0 ) ; if ( total_cost <= c ) return true ; for ( int i = k ; i < n ; i ++ ) { sum += a [ i ] ; sum -= a [ i - k ] ; total_cost = sum * k + getMax ( b , 0 , n - 1 , i - k + 1 , i , 0 ) ; if ( total_cost <= c ) return true ; } return false ; }
void build ( int b [ ] , int index , int s , int e ) { if ( s == e ) { seg [ index ] = b [ s ] ; return ; } int mid = s + ( e - s ) / 2 ; build ( b , 2 * index + 1 , s , mid ) ; build ( b , 2 * index + 2 , mid + 1 , e ) ; seg [ index ] = Math . max ( seg [ 2 * index + 1 ] , seg [ 2 * index + 2 ] ) ; }
int getMax ( int b [ ] , int ss , int se , int qs , int qe , int index ) { if ( se < qs ss > qe ) return Integer . MIN_VALUE / 2 ; if ( ss >= qs && se <= qe ) return seg [ index ] ; int mid = ss + ( se - ss ) / 2 ; return Math . max ( getMax ( b , ss , mid , qs , qe , 2 * index + 1 ) , getMax ( b , mid + 1 , se , qs , qe , 2 * index + 2 ) ) ; }
int maxLength ( int a [ ] , int b [ ] , int n , int c ) { if ( n == 0 ) return 0 ; int max_length = 0 ; int low = 0 , high = n ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( possible ( a , b , n , c , mid ) ) { max_length = mid ; low = mid + 1 ; } else high = mid - 1 ; } return max_length ; }
boolean possible ( int a [ ] , int b [ ] , int n , int c , int k ) { Deque < Integer > dq = new LinkedList < Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { sum += a [ i ] ; while ( dq . size ( ) > 0 && b [ i ] > b [ dq . peekLast ( ) ] ) dq . pollLast ( ) ; dq . addLast ( i ) ; } int total_cost = sum * k + b [ dq . peekFirst ( ) ] ; if ( total_cost <= c ) return true ; for ( int i = k ; i < n ; i ++ ) { sum += a [ i ] ; sum -= a [ i - k ] ; while ( dq . size ( ) > 0 && dq . peekFirst ( ) <= i - k ) dq . pollFirst ( ) ; while ( dq . size ( ) > 0 && b [ i ] > b [ dq . peekLast ( ) ] ) dq . pollLast ( ) ; dq . add ( i ) ; total_cost = sum * k + b [ dq . peekFirst ( ) ] ; if ( total_cost <= c ) return true ; } return false ; }
int findMaxLength ( int N , int [ ] arr ) { int [ ] dp = new int [ N + 1 ] ; Arrays . fill ( dp , 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 2 * i ; j <= N ; j += i ) { if ( arr [ i - 1 ] < arr [ j - 1 ] ) { dp [ j ] = Math . max ( dp [ j ] , dp [ i ] + 1 ) ; } } } return Arrays . stream ( dp ) . max ( ) . getAsInt ( ) ; }
void UtilSmallestElement ( int arr [ ] , int N ) { int total = 0 ; for ( int i = 0 ; i < N ; i ++ ) { total += arr [ i ] ; } int [ ] [ ] dp = new int [ N + 1 ] [ total ] ; for ( int [ ] k : dp ) Arrays . fill ( k , - 1 ) ; System . out . println ( smallestLeft ( arr , total , 0 , N , dp ) ) ; }
int SmallestElementLeft ( int arr [ ] , int N ) { int totalSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalSum += arr [ i ] ; } int req = totalSum / 2 ; boolean [ ] dp = new boolean [ req + 1 ] ; Arrays . fill ( dp , false ) ; dp [ 0 ] = true ; int reach = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = req ; j - arr [ i ] >= 0 ; j -- ) { dp [ j ] = dp [ j ] || dp [ j - arr [ i ] ] ; if ( dp [ j ] ) { reach = Math . max ( reach , j ) ; } } } return totalSum - ( 2 * reach ) ; }
int countSubArraySignChange ( int arr [ ] , int N ) { HashMap < Integer , Integer > prefixCount = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > suffixCount = new HashMap < Integer , Integer > ( ) ; int total = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { total += arr [ i ] ; if ( suffixCount . containsKey ( arr [ i ] ) ) { suffixCount . put ( arr [ i ] , suffixCount . get ( arr [ i ] ) + 1 ) ; } else { suffixCount . put ( arr [ i ] , 1 ) ; } } int prefixSum = 0 ; int suffixSum = 0 ; int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { prefixSum += arr [ i ] ; if ( prefixCount . containsKey ( arr [ i ] ) ) { prefixCount . put ( arr [ i ] , prefixCount . get ( arr [ i ] ) + 1 ) ; } else { prefixCount . put ( arr [ i ] , 1 ) ; } suffixSum = total - prefixSum ; if ( suffixCount . containsKey ( arr [ i ] ) ) { suffixCount . put ( arr [ i ] , suffixCount . get ( arr [ i ] ) - 1 ) ; } int diff = prefixSum - suffixSum ; if ( diff % 2 == 0 ) { int x = ( prefixCount . containsKey ( diff / 2 ) ? prefixCount . get ( diff / 2 ) : 0 ) + ( suffixCount . containsKey ( - diff / 2 ) ? suffixCount . get ( - diff / 2 ) : 0 ) ; count = count + x ; } } return count ; }
int countCommonChar ( int ind , String S ) { int cnt = 0 ; HashSet < Character > ls = new HashSet < Character > ( ) ; HashSet < Character > rs = new HashSet < Character > ( ) ; for ( int i = 0 ; i < ind ; ++ i ) { ls . add ( S . charAt ( i ) ) ; } for ( int i = ind ; i < S . length ( ) ; ++ i ) { rs . add ( S . charAt ( i ) ) ; } for ( char v : ls ) { if ( rs . contains ( v ) ) { ++ cnt ; } } return cnt ; }
int longestSubarray ( String s ) { s += '0' ; int i ; int res = 0 ; int prev_one = 0 ; int curr_one = 0 ; int numberOfZeros = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' ) { curr_one += 1 ; } else { numberOfZeros += 1 ; prev_one += curr_one ; res = Math . max ( res , prev_one ) ; prev_one = curr_one ; curr_one = 0 ; } } if ( numberOfZeros == 1 ) { res -= 1 ; } return res ; }
void LarUnEl ( int arr [ ] , int N ) { HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { map . put ( arr [ i ] , map . getOrDefault ( arr [ i ] , 0 ) + 1 ) ; } int LNRElem = Integer . MIN_VALUE ; int ind = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( map . get ( arr [ i ] ) == 1 && arr [ i ] > LNRElem ) { ind = i ; LNRElem = arr [ i ] ; } } if ( ind == - 1 ) { System . out . println ( ind ) ; return ; } System . out . println ( arr [ ind ] ) ; }
boolean isConsistingSubarrayUtil ( int arr [ ] , int n ) { TreeMap < Integer , Integer > mp = new TreeMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { mp . put ( arr [ i ] , mp . getOrDefault ( arr [ i ] , 0 ) + 1 ) ; } for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) { if ( it . getValue ( ) > 1 ) { return true ; } } return false ; }
void isConsistingSubarray ( int arr [ ] , int N ) { if ( isConsistingSubarrayUtil ( arr , N ) ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } }
void countShifts ( String str ) { int firstOne = - 1 ; int lastOne = - 1 ; int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == '1' ) { if ( firstOne == - 1 ) firstOne = i ; lastOne = i ; } } if ( ( firstOne == - 1 ) || ( firstOne == lastOne ) ) { System . out . print ( 0 ) ; return ; } for ( int i = firstOne ; i <= lastOne ; i ++ ) { if ( str . charAt ( i ) == '0' ) { count ++ ; } } System . out . println ( count ) ; }
boolean checkSubsequenceUtil ( int arr [ ] , int L , int R , int N ) { for ( int i = 0 ; i < L ; i ++ ) if ( arr [ i ] == arr [ L ] ) return true ; for ( int i = R + 1 ; i < N ; i ++ ) if ( arr [ i ] == arr [ R ] ) return true ; return false ; }
void largestSubarray ( int [ ] arr , int N , int K ) { int count = 0 ; int len = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < K ) { count += 1 ; } else { len = Math . max ( len , count ) ; count = 0 ; } } if ( count != 0 ) { len = Math . max ( len , count ) ; } System . out . println ( len ) ; }
void findNthNum ( int N ) { int a = 0 , b , left ; int right , mid ; int t , last_num = 0 ; left = 1 ; right = N ; while ( left <= right ) { mid = left + ( right - left ) / 2 ; t = ( mid * ( mid + 1 ) ) / 2 ; if ( t < N ) { left = mid + 1 ; } else if ( t == N ) { a = mid ; break ; } else { a = mid ; right = mid - 1 ; } } t = a - 1 ; b = N - ( t * ( t + 1 ) ) / 2 - 1 ; System . out . print ( ( 1 << a ) + ( 1 << b ) ) ; }
void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ ] ) { for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ; arr [ x - 1 ] = y ; int count = 1 ; for ( int j = 1 ; j < N ; j ++ ) { if ( arr [ j ] != arr [ j - 1 ] ) { count += 1 ; } } System . out . print ( count + " " ) ; } }
void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ ] ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count += 1 ; } } for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ; if ( x > 1 ) { if ( arr [ x - 1 ] != arr [ x - 2 ] ) { count -= 1 ; } if ( arr [ x - 2 ] != y ) { count += 1 ; } } if ( x < N ) { if ( arr [ x ] != arr [ x - 1 ] ) { count -= 1 ; } if ( y != arr [ x ] ) { count += 1 ; } } System . out . print ( count + " " ) ; arr [ x - 1 ] = y ; } }
void longestSubWithMaxSum ( int arr [ ] , int N ) { int Max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; if ( Max < 0 ) { System . out . print ( Max ) ; return ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= 0 ) { System . out . print ( arr [ i ] + " " ) ; } } }
void printNGE ( int arr [ ] , int n ) { Stack < Integer > s = new Stack < > ( ) ; int nge [ ] = new int [ n ] ; int i = 0 ; for ( i = 0 ; i < n ; i ++ ) { nge [ i ] = - 1 ; } i = 0 ; while ( i < 2 * n ) { while ( ! s . isEmpty ( ) && arr [ i % n ] > arr [ s . peek ( ) ] ) { nge [ s . peek ( ) ] = arr [ i % n ] ; s . pop ( ) ; } s . push ( i % n ) ; i ++ ; } for ( i = 0 ; i < n ; i ++ ) { System . out . print ( nge [ i ] + " " ) ; } }
boolean isPerfectSquare ( int x ) { int s = ( int ) Math . sqrt ( x ) ; return ( s * s == x ) ; }
boolean isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
void ifgcdFibonacci ( int a [ ] , int n , int k ) { Vector < Integer > compositeset = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( isComposite ( a [ i ] ) && a [ i ] % k == 0 ) { compositeset . add ( a [ i ] ) ; } } int gcd = compositeset . get ( 0 ) ; for ( int i = 1 ; i < compositeset . size ( ) ; i ++ ) { gcd = __gcd ( gcd , compositeset . get ( i ) ) ; if ( gcd == 1 ) { break ; } } if ( isFibonacci ( gcd ) ) { System . out . print ( "Yes" ) ; return ; } System . out . print ( "No" ) ; return ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void findPair ( int A [ ] , int N ) { int right_prod [ ] = new int [ N ] ; int flag = 0 ; right_prod [ N - 1 ] = A [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) right_prod [ i ] = right_prod [ i + 1 ] * A [ i ] ; int total_prod = right_prod [ 0 ] ; int product ; for ( int i = 1 ; i < N - 1 ; i ++ ) { product = 1 ; for ( int j = i ; j < N - 1 ; j ++ ) { product *= A [ j ] ; if ( gcd ( product , right_prod [ j + 1 ] ) == 1 || gcd ( product , total_prod / right_prod [ i ] ) == 1 ) { flag = 1 ; System . out . println ( "(" + ( i - 1 ) + ", " + ( j + 1 ) + ")" ) ; break ; } } if ( flag == 1 ) break ; } if ( flag == 0 ) System . out . print ( - 1 ) ; }
void countString ( String S ) { int count = 0 ; for ( char it : S . toCharArray ( ) ) { if ( it == '0' && count > 0 ) { count -- ; } else { count ++ ; } } System . out . print ( ( 1 << count ) - 1 ) ; }
void replaceDuplicates ( String [ ] names ) { HashMap < String , Integer > hash = new HashMap < > ( ) ; for ( int i = 0 ; i < names . length ; i ++ ) { if ( ! hash . containsKey ( names [ i ] ) ) hash . put ( names [ i ] , 1 ) ; else { int count = hash . get ( names [ i ] ) ; hash . put ( names [ i ] , hash . get ( names [ i ] ) + 1 ) ; names [ i ] += Integer . toString ( count ) ; } } for ( int i = 0 ; i < names . length ; i ++ ) { System . out . print ( names [ i ] + ' ' ) ; } }
int digitProduct ( int number ) { int res = 1 ; while ( number > 0 ) { res *= ( number % 10 ) ; number /= 10 ; } return res ; }
void DistinctCompositeDigitProduct ( int arr [ ] , int n ) { TreeSet < Integer > output = new TreeSet < Integer > ( ) ; boolean prime [ ] = new boolean [ N + 1 ] ; Arrays . fill ( prime , true ) ; SieveOfEratosthenes ( prime , N ) ; for ( int i = 0 ; i < n ; i ++ ) { int ans = digitProduct ( arr [ i ] ) ; if ( ans <= 1 ) { continue ; } if ( ! prime [ ans ] ) { output . add ( ans ) ; } } System . out . print ( output . size ( ) ) ; }
boolean [ ] SegmentedSieveFn ( int low , int high ) { int lmt = ( int ) ( Math . sqrt ( high ) ) + 1 ; ArrayList < Integer > prime = new ArrayList < Integer > ( ) ; prime = simpleSieve ( lmt , prime ) ; int n = high - low + 1 ; boolean [ ] segmentedSieve = new boolean [ n + 1 ] ; Arrays . fill ( segmentedSieve , true ) ; for ( int i = 0 ; i < prime . size ( ) ; i ++ ) { int lowLim = ( int ) ( low / prime . get ( i ) ) * prime . get ( i ) ; if ( lowLim < low ) { lowLim += prime . get ( i ) ; } for ( int j = lowLim ; j <= high ; j += prime . get ( i ) ) { if ( j != prime . get ( i ) ) { segmentedSieve [ j - low ] = false ; } } } return segmentedSieve ; }
int countPairsWhoseSumPrimeL_R ( int L , int R ) { boolean [ ] segmentedSieve = SegmentedSieveFn ( L , R ) ; int cntPairs = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( segmentedSieve [ i - L ] ) { cntPairs += i / 2 ; } } return cntPairs ; }
int count_zeroes ( int n , String str ) { int cnt = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == '0' ) cnt ++ ; } return cnt ; }
String kReducingString ( int n , int k , String str ) { int no_of_zeroes = count_zeroes ( n , str ) ; int no_of_ones = n - no_of_zeroes ; if ( no_of_zeroes == 0 no_of_zeroes == n ) { return str ; } if ( k == 1 ) { if ( no_of_zeroes == 0 no_of_zeroes == n ) { return str ; } else { return "Not Possible" ; } } boolean check = false ; for ( int i = ( n / k ) ; i < n ; i += ( n / k ) ) { if ( no_of_zeroes == i no_of_ones == i ) { check = true ; break ; } } if ( check == false ) { return "Not Possible" ; } return kReducingStringUtil ( n , k , str , no_of_zeroes ) ; }
void convert_to_allzeroes ( String str , int a , int b ) { int len = str . length ( ) ; int left_1 , i = 0 ; while ( i < len && str . charAt ( i ) == '0' ) i ++ ; left_1 = i ; int right_1 ; i = len - 1 ; while ( i >= 0 && str . charAt ( i ) == '0' ) i -- ; right_1 = i ; if ( left_1 == len && right_1 == - 1 ) { System . out . print ( 0 ) ; return ; } int cost = a , zeroes ; for ( i = left_1 ; i <= right_1 ; i ++ ) { zeroes = 0 ; while ( i < len && str . charAt ( i ) == '0' ) { zeroes ++ ; i ++ ; } if ( zeroes != 0 ) cost += Math . min ( zeroes * b , a ) ; } System . out . print ( cost ) ; }
int MinDistK ( int arr [ ] , int N , int K ) { int res = Integer . MAX_VALUE ; int dist = 0 ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { if ( arr [ i ] >= 0 && arr [ i + K - 1 ] >= 0 ) { dist = Math . max ( arr [ i ] , arr [ i + K - 1 ] ) ; } else { dist = Math . abs ( arr [ i ] ) + Math . abs ( arr [ i + K - 1 ] ) + Math . min ( Math . abs ( arr [ i ] ) , Math . abs ( arr [ i + K - 1 ] ) ) ; } res = Math . min ( res , dist ) ; } return res ; }
int maximizeMin ( int A [ ] , int N , int S , int M ) { int minIndex , left , right , i , j ; for ( i = 0 ; i < M ; i ++ ) { minIndex = min1 ( A , N ) ; A [ minIndex ] ++ ; left = minIndex - 1 ; right = minIndex + 1 ; for ( j = 0 ; j < S - 1 ; j ++ ) { if ( left == - 1 ) A [ right ++ ] ++ ; else if ( right == N ) A [ left -- ] ++ ; else { if ( A [ left ] < A [ right ] ) A [ left -- ] ++ ; else A [ right ++ ] ++ ; } } } minIndex = min1 ( A , N ) ; return A [ minIndex ] ; }
int sumOfPathNodes ( int N ) { if ( N == 1 ) { return 1 ; } else if ( N == 2 N == 3 ) { return N + 1 ; } Vector < Integer > arr = new Vector < > ( ) ; arr . add ( 1 ) ; int k = 1 ; boolean flag = true ; while ( k < N ) { if ( flag == true ) { k *= 2 ; flag = false ; } else { k *= 4 ; flag = true ; } if ( k > N ) { break ; } arr . add ( k ) ; } int len = arr . size ( ) ; int [ ] prefix = new int [ len ] ; prefix [ 0 ] = 1 ; for ( int i = 1 ; i < len ; ++ i ) { prefix [ i ] = arr . get ( i ) + prefix [ i - 1 ] ; } int it = lowerBound ( prefix , 0 , len , N ) + 1 ; int ind = it - prefix [ 0 ] ; int final_ans = 0 ; int temp = N ; while ( ind > 1 ) { int val = temp - prefix [ ind - 1 ] ; if ( ind % 2 != 0 ) { temp = prefix [ ind - 2 ] + ( val + 1 ) / 2 ; } else { temp = prefix [ ind - 2 ] + ( val + 3 ) / 4 ; } -- ind ; final_ans += temp ; } final_ans += ( N + 1 ) ; return final_ans ; }
void fill_counts ( int a [ ] , int n ) { int i , j ; int maxA = a [ 0 ] ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > maxA ) { maxA = a [ i ] ; } } for ( i = 0 ; i < n ; i ++ ) { lcount [ a [ i ] ] [ i ] = 1 ; rcount [ a [ i ] ] [ i ] = 1 ; } for ( i = 0 ; i <= maxA ; i ++ ) { for ( j = 1 ; j < n ; j ++ ) { lcount [ i ] [ j ] = lcount [ i ] [ j - 1 ] + lcount [ i ] [ j ] ; } for ( j = n - 2 ; j >= 0 ; j -- ) { rcount [ i ] [ j ] = rcount [ i ] [ j + 1 ] + rcount [ i ] [ j ] ; } } }
boolean checkPointRange ( int arr [ ] [ ] , int X , int Y , int N ) { for ( int i = 0 ; i < N ; i ++ ) { double dist = Math . sqrt ( ( arr [ i ] [ 0 ] - X ) * ( arr [ i ] [ 0 ] - X ) + ( arr [ i ] [ 1 ] - Y ) * ( arr [ i ] [ 1 ] - Y ) ) ; if ( dist <= arr [ i ] [ 2 ] ) { return true ; } } return false ; }
void findWinner ( int arr [ ] , int N ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd ++ ; } else { even ++ ; } } if ( even == 0 ) { if ( odd % 2 == 0 ) { System . out . println ( "Player 2" ) ; } else if ( odd % 2 == 1 ) { System . out . println ( "Player 1" ) ; } } else if ( even == 1 && odd % 2 == 1 ) { System . out . println ( "Player 1" ) ; } else { System . out . println ( - 1 ) ; } }
HashSet < Integer > createhashmap ( int Max ) { HashSet < Integer > hashmap = new HashSet < > ( ) ; int curr = 1 ; int prev = 0 ; hashmap . add ( prev ) ; while ( curr < Max ) { hashmap . add ( curr ) ; int temp = curr ; curr = curr + prev ; prev = temp ; } return hashmap ; }
void SieveOfEratosthenes ( int Max ) { isPrime = new boolean [ Max ] ; Arrays . fill ( isPrime , true ) ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; for ( int p = 2 ; p * p <= Max ; p ++ ) { if ( isPrime [ p ] ) { for ( int i = p * p ; i <= Max ; i += p ) { isPrime [ i ] = false ; } } } }
void cntFibonacciPrime ( int arr [ ] , int N ) { int Max = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { Max = Math . max ( Max , arr [ i ] ) ; } SieveOfEratosthenes ( Max ) ; HashSet < Integer > hashmap = createhashmap ( Max ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) continue ; if ( ( hashmap . contains ( arr [ i ] ) ) && ! isPrime [ arr [ i ] ] ) { System . out . print ( arr [ i ] + " " ) ; } } }
int minJumps ( String seats ) { Vector < Integer > position = new Vector < > ( ) ; int count = 0 ; int len = seats . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( seats . charAt ( i ) == 'x' ) { position . add ( i - count ) ; count ++ ; } } if ( count == len count == 0 ) return 0 ; int med_index = ( count - 1 ) / 2 ; int med_val = position . get ( med_index ) ; int ans = 0 ; for ( int i = 0 ; i < position . size ( ) ; i ++ ) { ans = ( ans % MOD + Math . abs ( position . get ( i ) - med_val ) % MOD ) % MOD ; } return ans % MOD ; }
int singlePrimeFactor ( int N ) { HashSet < Integer > disPrimeFact = new HashSet < > ( ) ; for ( int i = 2 ; i * i <= N ; ++ i ) { while ( N % i == 0 ) { disPrimeFact . add ( i ) ; N /= i ; } } if ( N != 1 ) { disPrimeFact . add ( N ) ; } if ( disPrimeFact . size ( ) == 1 ) { for ( int i : disPrimeFact ) return i ; } return - 1 ; }
int cntsingleFactorPair ( int arr [ ] , int N ) { int countOf1 = 0 ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) { countOf1 ++ ; continue ; } int factorValue = singlePrimeFactor ( arr [ i ] ) ; if ( factorValue == - 1 ) { continue ; } else { if ( mp . containsKey ( factorValue ) ) mp . put ( factorValue , mp . get ( factorValue ) + 1 ) ; else mp . put ( factorValue , 1 ) ; } } int res = 0 ; for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) { int X = it . getValue ( ) ; res += countOf1 * X + ( X * ( X - 1 ) ) / 2 ; } return res ; }
int countPairs ( int v1 [ ] , int v2 [ ] , int n , int m , int k ) { int count = 0 ; if ( n <= m ) { Arrays . sort ( v1 ) ; for ( int j = 0 ; j < m ; j ++ ) { int index = lowerBound ( v1 , 0 , n , v2 [ j ] - k ) ; count += index ; } } else { Arrays . sort ( v2 ) ; for ( int i = 0 ; i < n ; i ++ ) { int index = upperBound ( v2 , 0 , m , v1 [ i ] + k ) ; count += m - index ; } } return count ; }
void maxSumSubarr ( int A [ ] , int N , int K , int X ) { int sum_K = 0 ; for ( int i = 0 ; i < K ; i ++ ) { sum_K += A [ i ] ; } int Max_Sum = 0 ; if ( sum_K < X ) { Max_Sum = sum_K ; } for ( int i = K ; i < N ; i ++ ) { sum_K -= ( A [ i - K ] - A [ i ] ) ; if ( sum_K < X ) { Max_Sum = Math . max ( Max_Sum , sum_K ) ; } } System . out . println ( Max_Sum ) ; }
void removeSmallestSubarray ( int arr [ ] , int n , int k ) { int [ ] mod_arr = new int [ n ] ; int total_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mod_arr [ i ] = ( arr [ i ] + k ) % k ; total_sum += arr [ i ] ; } int target_remainder = total_sum % k ; if ( target_remainder == 0 ) { System . out . print ( "0" ) ; return ; } HashMap < Integer , Integer > map1 = new HashMap < > ( ) ; map1 . put ( 0 , - 1 ) ; int curr_remainder = 0 ; int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { curr_remainder = ( curr_remainder + arr [ i ] + k ) % k ; map1 . put ( curr_remainder , i ) ; int mod = ( curr_remainder - target_remainder + k ) % k ; if ( map1 . containsKey ( mod ) ) res = Math . min ( res , i - map1 . get ( mod ) ) ; } if ( res == Integer . MAX_VALUE res == n ) { res = - 1 ; } System . out . print ( res ) ; }
int findMaxLen ( int wood [ ] , int N , int K ) { int left = 1 ; int right = Arrays . stream ( wood ) . max ( ) . getAsInt ( ) ; while ( left <= right ) { int mid = left + ( right - left ) / 2 ; if ( isValid ( wood , N , mid , K ) ) { left = mid + 1 ; } else { right = mid - 1 ; } } return right ; }
int countFactors ( int spf [ ] , int num ) { int count = 0 ; while ( num > 1 ) { count ++ ; num = num / spf [ num ] ; } return count ; }
int [ ] precalculateSum ( int spf [ ] ) { int sum [ ] = new int [ MAX ] ; sum [ 0 ] = 0 ; for ( int i = 1 ; i < MAX ; i ++ ) { int prime_factor = countFactors ( spf , i ) ; if ( spf [ prime_factor ] == prime_factor ) { sum [ i ] = sum [ i - 1 ] + 1 ; } else { sum [ i ] = sum [ i - 1 ] ; } } return sum ; }
int countSum ( int a [ ] , int n , int sum ) { int i , j , k , l ; int count = 0 ; for ( i = 0 ; i < n - 3 ; i ++ ) { for ( j = i + 1 ; j < n - 2 ; j ++ ) { for ( k = j + 1 ; k < n - 1 ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ i ] + a [ j ] + a [ k ] + a [ l ] == sum ) count ++ ; } } } } return count ; }
int countSum ( int a [ ] , int n , int sum ) { int i , j , k , l ; int count = 0 ; for ( i = 0 ; i < n - 3 ; i ++ ) { for ( j = i + 1 ; j < n - 2 ; j ++ ) { int req = sum - a [ i ] - a [ j ] ; HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( k = j + 1 ; k < n ; k ++ ) if ( m . containsKey ( a [ k ] ) ) { m . put ( a [ k ] , m . get ( a [ k ] ) + 1 ) ; } else { m . put ( a [ k ] , 1 ) ; } int twice_count = 0 ; for ( k = j + 1 ; k < n ; k ++ ) { if ( m . containsKey ( req - a [ k ] ) ) twice_count += m . get ( req - a [ k ] ) ; if ( req - a [ k ] == a [ k ] ) twice_count -- ; } count += twice_count / 2 ; } } return count ; }
int countSum ( int a [ ] , int n , int sum ) { int i , j , k ; int count = 0 ; HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { int temp = a [ i ] + a [ j ] ; if ( temp < sum && m . containsKey ( sum - temp ) ) count += m . get ( sum - temp ) ; } for ( j = 0 ; j < i ; j ++ ) { int temp = a [ i ] + a [ j ] ; if ( temp < sum ) if ( m . containsKey ( temp ) ) m . put ( temp , m . get ( temp ) + 1 ) ; else m . put ( temp , 1 ) ; } } return count ; }
int minSwaps ( String S , int n ) { int swaps = 0 ; @ SuppressWarnings ( "unchecked" ) Vector < Integer > [ ] arr = new Vector [ 26 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) arr [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int pos = S . charAt ( i ) - 'a' ; arr [ pos ] . add ( i ) ; } for ( char ch = 'a' ; ch <= 'z' ; ++ ch ) { int pos = ch - 'a' ; for ( int i = 1 ; i < arr [ pos ] . size ( ) ; ++ i ) { swaps += Math . abs ( arr [ pos ] . get ( i ) - arr [ pos ] . get ( i - 1 ) - 1 ) ; } } return swaps ; }
int isValid ( int arr [ ] , int n , int m , int d ) { for ( int i = 0 ; i < m ; i ++ ) { if ( Math . abs ( arr [ n - m + i ] - arr [ i ] ) < d ) { return 0 ; } } return 1 ; }
void max_distance ( int a [ ] , int temp [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { temp [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mp . get ( a [ i ] ) == null ) temp [ a [ i ] ] = i + 1 ; else temp [ a [ i ] ] = Math . max ( temp [ a [ i ] ] , i - mp . getOrDefault ( a [ i ] , 0 ) ) ; mp . put ( a [ i ] , i ) ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( temp [ i ] != - 1 ) temp [ i ] = Math . max ( temp [ i ] , n - mp . getOrDefault ( i , 0 ) ) ; } }
void min_comm_ele ( int a [ ] , int ans [ ] , int temp [ ] , int n ) { max_distance ( a , temp , n ) ; for ( int i = 1 ; i <= n ; i ++ ) { ans [ i ] = - 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( temp [ i ] >= 0 && ans [ temp [ i ] ] == - 1 ) ans [ temp [ i ] ] = i ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( i > 1 && ans [ i - 1 ] != - 1 ) { if ( ans [ i ] == - 1 ) ans [ i ] = ans [ i - 1 ] ; else ans [ i ] = Math . min ( ans [ i ] , ans [ i - 1 ] ) ; } System . out . print ( ans [ i ] + " " ) ; } }
int maxiConsecutiveSubarray ( int arr [ ] , int N ) { int maxi = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int cnt = 1 , j ; for ( j = i ; j < N - 1 ; j ++ ) { if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; } else { break ; } } maxi = Math . max ( maxi , cnt ) ; i = j ; } return maxi ; }
void FindTrip ( int arr [ ] , int N ) { for ( int i = 1 ; i < N - 1 ; i ++ ) { int p = arr [ i - 1 ] ; int q = arr [ i ] ; int r = arr [ i + 1 ] ; if ( p < q && q > r ) { System . out . println ( ( i - 1 ) + " " + ( i ) + " " + ( i + 1 ) ) ; return ; } } System . out . println ( - 1 ) ; }
int cntSubarrays ( int arr [ ] , int N ) { int cntSub = 0 ; int cntUnique = 0 ; Map < Integer , Integer > cntFreq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i ; j < N ; j ++ ) { cntFreq . put ( arr [ j ] , cntFreq . getOrDefault ( arr [ j ] , 0 ) + 1 ) ; if ( cntFreq . get ( arr [ j ] ) == 1 ) { cntUnique ++ ; } else if ( cntFreq . get ( arr [ j ] ) == 2 ) { cntUnique -- ; } if ( cntUnique == 0 ) { cntSub ++ ; } } cntFreq . clear ( ) ; cntUnique = 0 ; } return cntSub ; }
boolean checkPalinK ( String str , int K ) { int N = str . length ( ) ; int cntFreq [ ] = new int [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { cntFreq [ str . charAt ( i ) ] ++ ; } int cntOddFreq = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( cntFreq [ i ] % 2 == 1 ) { cntOddFreq ++ ; } } if ( cntOddFreq <= ( K + 1 ) ) { return true ; } return false ; }
void printIndexes ( char [ ] str ) { int N = str . length ; int [ ] cntFreq = new int [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { cntFreq [ str [ i ] ] ++ ; } int [ ] cntLeftFreq = new int [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { int cntLeft = 0 ; int cntRight = 0 ; for ( int j = str [ i ] - 1 ; j >= 0 ; j -- ) { cntLeft += cntLeftFreq [ j ] ; cntRight += cntFreq [ j ] - cntLeftFreq [ j ] ; } cntLeftFreq [ str [ i ] ] ++ ; if ( cntLeft == cntRight && cntLeft != 0 ) { System . out . print ( i + " " ) ; } } }
int digiSum ( int a ) { int sum = 0 ; while ( a != 0 ) { sum += a % 10 ; a = a / 10 ; } return sum ; }
boolean isPrime ( int r ) { boolean s = true ; for ( int i = 2 ; i * i <= r ; i ++ ) { if ( r % i == 0 ) { s = false ; break ; } } return s ; }
int Count_Number ( int x ) { int ans = 0 ; if ( x % 99 != 0 ) { ans = - 1 ; } else { int diff = x / 99 ; for ( int i = 1 ; i < 10 ; i ++ ) { for ( int j = 1 ; j < 10 ; j ++ ) { if ( ( i - j ) == diff ) { ans += 10 ; } } } } return ans ; }
int find_index ( int [ ] arr , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == K ) return i ; else if ( arr [ i ] > K ) return i ; return n ; }
int find_index ( int [ ] arr , int n , int K ) { int start = 0 ; int end = n - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] == K ) return mid ; else if ( arr [ mid ] < K ) start = mid + 1 ; else end = mid - 1 ; } return end + 1 ; }
boolean isinRange ( int [ ] [ ] board ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( board [ i ] [ j ] <= 0 board [ i ] [ j ] > 9 ) { return false ; } } } return true ; }
boolean isValidSudoku ( int board [ ] [ ] ) { if ( isinRange ( board ) == false ) { return false ; } boolean [ ] unique = new boolean [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { Arrays . fill ( unique , false ) ; for ( int j = 0 ; j < N ; j ++ ) { int Z = board [ i ] [ j ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } for ( int i = 0 ; i < N ; i ++ ) { Arrays . fill ( unique , false ) ; for ( int j = 0 ; j < N ; j ++ ) { int Z = board [ j ] [ i ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } for ( int i = 0 ; i < N - 2 ; i += 3 ) { for ( int j = 0 ; j < N - 2 ; j += 3 ) { Arrays . fill ( unique , false ) ; for ( int k = 0 ; k < 3 ; k ++ ) { for ( int l = 0 ; l < 3 ; l ++ ) { int X = i + k ; int Y = j + l ; int Z = board [ X ] [ Y ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } } } return true ; }
void minSubarray ( int [ ] arr , int N ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int mini = Integer . MAX_VALUE ; for ( int j = i ; j < N ; j ++ ) { mini = Math . min ( mini , arr [ j ] ) ; if ( mp . containsKey ( mini ) ) { mp . put ( mini , mp . get ( mini ) + 1 ) ; } else { mp . put ( mini , 1 ) ; } } } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( mp . get ( arr [ i ] ) + " " ) ; } }
void minSubarray ( int [ ] arr , int N ) { int [ ] result = new int [ N ] ; Stack < pair > l = new Stack < > ( ) ; Stack < pair > r = new Stack < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int count = 1 ; while ( ! l . isEmpty ( ) && l . peek ( ) . first > arr [ i ] ) { count += l . peek ( ) . second ; l . pop ( ) ; } l . add ( new pair ( arr [ i ] , count ) ) ; result [ i ] = count ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { int count = 1 ; while ( ! r . isEmpty ( ) && r . peek ( ) . first >= arr [ i ] ) { count += r . peek ( ) . second ; r . pop ( ) ; } r . add ( new pair ( arr [ i ] , count ) ) ; result [ i ] *= count ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( result [ i ] + " " ) ; } }
boolean isPrime ( int num ) { if ( num <= 1 ) return false ; for ( int i = 2 ; i * i <= num ; i ++ ) if ( num % i == 0 ) return false ; return true ; }
boolean isFulPrime ( int n ) { if ( ! isPrime ( n ) ) return false ; else { while ( n > 0 ) { int rem = n % 10 ; if ( ! ( rem == 2 rem == 3 rem == 5 rem == 7 ) ) return false ; n = n / 10 ; } } return true ; }
int countFulPrime ( int L , int R ) { int cnt = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( ( i % 2 ) != 0 && isFulPrime ( i ) ) { cnt ++ ; } } return cnt ; }
int computePos ( int arr [ ] , int n , int value ) { if ( value < arr [ 0 ] ) return 0 ; if ( value > arr [ n - 1 ] ) return n - 1 ; int start = 0 ; int end = n - 1 ; while ( start < end ) { int mid = ( start + end + 1 ) / 2 ; if ( arr [ mid ] >= value ) end = mid - 1 ; else start = mid ; } return start ; }
void countShift ( int arr [ ] , int n , Vector < Vector < Integer > > queries ) { for ( Vector < Integer > q : queries ) { int index = q . get ( 0 ) ; int update = q . get ( 1 ) ; int newElement = arr [ index ] + update ; int newIndex = computePos ( arr , n , newElement ) ; System . out . print ( Math . abs ( newIndex - index ) + " " ) ; } }
void printAlter ( int [ ] arr , int N ) { for ( int currIndex = 0 ; currIndex < N ; currIndex ++ ) { if ( currIndex % 2 == 0 ) { System . out . print ( arr [ currIndex ] + " " ) ; } } }
void printAlter ( int [ ] arr , int N ) { for ( int currIndex = 0 ; currIndex < N ; currIndex += 2 ) { System . out . print ( arr [ currIndex ] + " " ) ; } }
int findmin ( String s ) { int n = s . length ( ) ; int i , j , maximum = 0 ; int [ ] incr = new int [ n + 1 ] ; for ( i = 0 ; i < n ; i ++ ) { incr [ i + 1 ] = incr [ i ] ; if ( s . charAt ( i ) == '0' ) { incr [ i + 1 ] ++ ; } } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { maximum = Math . max ( maximum , incr [ i ] + j - i + 1 - ( incr [ j + 1 ] - incr [ i ] ) + incr [ n ] - incr [ j + 1 ] ) ; } } return n - maximum ; }
void SieveOfEratosthenes ( boolean [ ] prime , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
int digitSum ( int number ) { int sum = 0 ; while ( number > 0 ) { sum += ( number % 10 ) ; number /= 10 ; } return sum ; }
void longestCompositeDigitSumSubsequence ( int [ ] arr , int n ) { int count = 0 ; boolean [ ] prime = new boolean [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , N ) ; for ( int i = 0 ; i < n ; i ++ ) { int res = digitSum ( arr [ i ] ) ; if ( res == 1 ) { continue ; } if ( prime [ res ] == false ) { count ++ ; } } System . out . println ( count ) ; }
boolean isPower ( int x ) { if ( x != 0 && ( x & ( x - 1 ) ) == 0 ) return true ; return false ; }
void maximumlength ( int arr [ ] , int N ) { int max_length = 0 ; int max_len_subarray = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( isPower ( arr [ i ] ) ) { max_length ++ ; max_len_subarray = Math . max ( max_length , max_len_subarray ) ; } else { max_length = 0 ; } } System . out . println ( max_len_subarray ) ; }
void minSub ( int N ) { int count = 0 ; while ( N >= 0 ) { int num = N ; int rev = 0 ; while ( num != 0 ) { int digit = num % 10 ; rev = ( rev * 10 ) + digit ; num = num / 10 ; } if ( N == rev ) { break ; } count ++ ; N -- ; } System . out . print ( count ) ; }
boolean isPalindrome ( String str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str . charAt ( i ) != str . charAt ( j ) ) return false ; i ++ ; j -- ; } return true ; }
int isPerfect ( int N ) { int sum = 1 ; for ( int i = 2 ; i < Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { sum += i ; } else { sum += i + N / i ; } } } if ( sum == N && N != 1 ) return 1 ; return 0 ; }
int maxSum ( int arr [ ] , int N , int K ) { if ( N < K ) { System . out . print ( "Invalid" ) ; return - 1 ; } int res = 0 ; for ( int i = 0 ; i < K ; i ++ ) { res += arr [ i ] ; } int curr_sum = res ; for ( int i = K ; i < N ; i ++ ) { curr_sum += arr [ i ] - arr [ i - K ] ; res = Math . max ( res , curr_sum ) ; } return res ; }
int max_PerfectNumbers ( int arr [ ] , int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = isPerfect ( arr [ i ] ) == 1 ? 1 : 0 ; } return maxSum ( arr , N , K ) ; }
int minElements ( int [ ] A , int [ ] B , int N , int M ) { Map < Integer , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < A . length ; i ++ ) { map . put ( A [ i ] , i ) ; } ArrayList < Integer > subseq = new ArrayList < > ( ) ; int l = 0 , r = - 1 ; for ( int i = 0 ; i < M ; i ++ ) { if ( map . containsKey ( B [ i ] ) ) { int e = map . get ( B [ i ] ) ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( subseq . get ( m ) < e ) l = m + 1 ; else r = m - 1 ; } if ( r + 1 < subseq . size ( ) ) { subseq . set ( r + 1 , e ) ; } else { subseq . add ( e ) ; } l = 0 ; r = subseq . size ( ) - 1 ; } } return N - subseq . size ( ) ; }
int cntSubarr ( int arr [ ] , int N ) { int res = 0 ; int prefixXor = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { prefixXor = arr [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { prefixXor ^= arr [ j ] ; if ( prefixXor == 0 && ( j - i + 1 ) % 2 == 0 ) { res ++ ; } } } return res ; }
int cntSubXor ( int arr [ ] , int N ) { int prefixXor = 0 ; int [ ] Even = new int [ M ] ; int [ ] Odd = new int [ M ] ; int cntSub = 0 ; Odd [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { prefixXor ^= arr [ i ] ; if ( i % 2 == 1 ) { cntSub += Odd [ prefixXor ] ; Odd [ prefixXor ] ++ ; } else { cntSub += Even [ prefixXor ] ; Even [ prefixXor ] ++ ; } } return cntSub ; }
int zvalue ( int [ ] nums ) { int m = max_element ( nums ) ; int cnt = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { cnt = 0 ; for ( int j = 0 ; j < nums . length ; j ++ ) { if ( nums [ j ] >= i ) cnt ++ ; } if ( cnt == i ) return i ; } return - 1 ; }
boolean isEvenOddBinaryTree ( Node root ) { if ( root == null ) return true ; Queue < Node > q = new LinkedList < > ( ) ; q . add ( root ) ; int level = 0 ; while ( ! q . isEmpty ( ) ) { int size = q . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Node node = q . poll ( ) ; if ( level % 2 == 0 ) { if ( node . val % 2 == 1 ) return false ; } else if ( level % 2 == 1 ) { if ( node . val % 2 == 0 ) return false ; } if ( node . left != null ) { q . add ( node . left ) ; } if ( node . right != null ) { q . add ( node . right ) ; } } level ++ ; } return true ; }
boolean is_prime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
void countSmallerPrimes ( int ar [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = i + 1 ; j < N ; j ++ ) { if ( ar [ j ] <= ar [ i ] && is_prime ( ar [ j ] ) ) { count ++ ; } } System . out . print ( count + " " ) ; } }
boolean is_prime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
boolean checkConcat ( String str1 , String str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; if ( N % M != 0 ) { return false ; } for ( int i = 0 ; i < N ; i ++ ) { if ( str1 . charAt ( i ) != str2 . charAt ( i % M ) ) { return false ; } } return true ; }
int MinLen ( String str , int K ) { int N = str . length ( ) ; int i = 0 ; while ( i < N - 1 ) { if ( str . charAt ( i ) != str . charAt ( i + 1 ) ) { break ; } i ++ ; } if ( i == N - 1 ) { return N ; } return Math . max ( 1 , N - K ) ; }
int findSubArray ( int [ ] arr , int k ) { int n = arr . length ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( palindrome ( arr , i , i + k - 1 ) ) return i ; } return - 1 ; }
boolean helper ( int mid ) { int cnt = 0 ; for ( Map . Entry < Integer , Integer > i : mp . entrySet ( ) ) { int temp = i . getValue ( ) ; while ( temp >= mid ) { temp -= mid ; cnt ++ ; } } return cnt >= N ; }
int findMaximumDays ( int arr [ ] ) { for ( int i = 0 ; i < P ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int start = 0 , end = P , ans = 0 ; while ( start <= end ) { int mid = start + ( ( end - start ) / 2 ) ; if ( mid != 0 && helper ( mid ) ) { ans = mid ; start = mid + 1 ; } else if ( mid == 0 ) { start = mid + 1 ; } else { end = mid - 1 ; } } return ans ; }
double temp ( int n , int x ) { return Math . pow ( x * 1.0 / n , n ) ; }
boolean check ( int n , int y , int x ) { double v = temp ( n , x ) ; return ( v >= y ) ; }
void speciallyBalancedNodes ( int R , int N , String str [ ] , int values [ ] ) { Node root = build_tree ( R , N , str , values ) ; sum = 0 ; SBTUtil ( root ) ; System . out . print ( sum + " " ) ; }
void display ( int countLeftGreater [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( countLeftGreater [ i ] + " " ) ; } }
int minLength ( int arr [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return 1 ; } } return N ; }
void PrintIndexes ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int currSubSum = 0 ; for ( int j = i ; j < N ; j ++ ) { currSubSum += arr [ j ] ; int sq = ( int ) Math . sqrt ( currSubSum ) ; if ( sq * sq == currSubSum ) { System . out . print ( "(" + i + "," + j + ")" + " " ) ; } } } }
boolean check ( int [ ] pSum , int len , int k , int [ ] a ) { int i = 0 ; int j = len ; while ( j <= a . length ) { int maxSize = a [ j - 1 ] ; int totalNumbers = maxSize * len ; int currNumbers = pSum [ j ] - pSum [ i ] ; if ( currNumbers + k >= totalNumbers ) { return true ; } else { i ++ ; j ++ ; } } return false ; }
int countPosition ( int [ ] [ ] mat ) { int n = mat . length ; int m = mat [ 0 ] . length ; int [ ] row = new int [ n ] ; int [ ] col = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { col [ j ] ++ ; row [ i ] ++ ; } } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( row [ i ] == col [ j ] ) { count ++ ; } } } return count ; }
void position ( int arr [ ] [ ] , int N ) { int pos = - 1 ; int count ; for ( int i = 0 ; i < N ; i ++ ) { count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ 0 ] <= arr [ j ] [ 0 ] && arr [ i ] [ 1 ] >= arr [ j ] [ 1 ] ) { count ++ ; } } if ( count == N ) { pos = i ; } } if ( pos == - 1 ) { System . out . print ( pos ) ; } else { System . out . print ( pos + 1 ) ; } }
void maxAtLevel ( int N , int M , int [ ] Value , int Edges [ ] [ ] ) { Vector < Integer > [ ] adj = new Vector [ N ] ; for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < M ; i ++ ) { int u = Edges [ i ] [ 0 ] ; int v = Edges [ i ] [ 1 ] ; adj [ u ] . add ( v ) ; } Queue < Integer > q = new LinkedList < > ( ) ; q . add ( 0 ) ; while ( ! q . isEmpty ( ) ) { int count = q . size ( ) ; int maxVal = 0 ; while ( count -- > 0 ) { int temp = q . peek ( ) ; q . remove ( ) ; maxVal = Math . max ( maxVal , Value [ temp ] ) ; for ( int i = 0 ; i < adj [ temp ] . size ( ) ; i ++ ) { q . add ( adj [ temp ] . get ( i ) ) ; } } System . out . print ( maxVal + " " ) ; } }
int floyd_warshall ( int [ ] [ ] graph , int V ) { int [ ] [ ] dist = new int [ V ] [ V ] ; int i , j , k ; for ( i = 0 ; i < V ; i ++ ) { for ( j = 0 ; j < V ; j ++ ) { dist [ i ] [ j ] = graph [ i ] [ j ] ; } } for ( k = 0 ; k < V ; k ++ ) { for ( i = 0 ; i < V ; i ++ ) { for ( j = 0 ; j < V ; j ++ ) { if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) { dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; } } } } int sum = 0 ; for ( i = 0 ; i < V ; i ++ ) { for ( j = i + 1 ; j < V ; j ++ ) { sum += dist [ i ] [ j ] ; } } return sum ; }
int sumOfshortestPath ( int N , int E , int edges [ ] [ ] ) { int [ ] [ ] g = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { g [ i ] [ j ] = INF ; } } for ( int i = 0 ; i < E ; i ++ ) { int u = edges [ i ] [ 0 ] ; int v = edges [ i ] [ 1 ] ; int w = edges [ i ] [ 2 ] ; g [ u ] [ v ] = w ; g [ v ] [ u ] = w ; } return floyd_warshall ( g , N ) ; }
int minCost ( String A , String B ) { int n = A . length ( ) ; int i = 0 ; int maxlen = 0 ; while ( i < n ) { int length = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( A . charAt ( i ) == B . charAt ( j ) ) { ++ i ; ++ length ; if ( i == n ) break ; } } maxlen = Math . max ( maxlen , length ) ; } return n - maxlen ; }
int binarySearch ( int arr [ ] , int N , int X ) { int start = 0 ; int end = N ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( X == arr [ mid ] ) { return mid ; } else if ( X < arr [ mid ] ) { start = mid + 1 ; } else { end = mid - 1 ; } } return - 1 ; }
boolean check ( int [ ] a , int n ) { int [ ] b = new int [ n ] ; int minElement = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = a [ i ] ; minElement = Math . min ( minElement , a [ i ] ) ; } Arrays . sort ( b ) ; int k = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] && a [ i ] % minElement != 0 ) { k = 0 ; break ; } } return k == 1 ? true : false ; }
boolean check_both_present ( int [ ] arr , int N , int a , int b ) { boolean f1 = false , f2 = false ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == a ) { f1 = true ; } if ( arr [ i ] == b ) { f2 = true ; } } if ( f1 && f2 ) { return true ; } else { return false ; } }
void print_array ( int [ ] ans , int N ) { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( ans [ i ] + " " ) ; } }
void build_AP ( int N , int a , int b ) { int [ ] arr = new int [ N ] ; int [ ] ans = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) ans [ i ] = Integer . MAX_VALUE ; int flag = 0 ; if ( a > b ) { a += ( b - ( b = a ) ) ; } int diff = b - a ; for ( int start = 1 ; start <= a ; start ++ ) { for ( int d = 1 ; d <= diff ; d ++ ) { arr [ 0 ] = start ; for ( int i = 1 ; i < N ; i ++ ) { arr [ i ] = arr [ i - 1 ] + d ; } if ( check_both_present ( arr , N , a , b ) && arr [ N - 1 ] < ans [ N - 1 ] ) { for ( int i = 0 ; i < N ; i ++ ) { ans [ i ] = arr [ i ] ; } } } } print_array ( ans , N ) ; }
int numSpecial ( int [ ] [ ] mat ) { int m = mat . length ; int n = mat [ 0 ] . length ; int [ ] rows = new int [ m ] ; int [ ] cols = new int [ n ] ; int i , j ; for ( i = 0 ; i < m ; i ++ ) { rows [ i ] = 0 ; for ( j = 0 ; j < n ; j ++ ) rows [ i ] += mat [ i ] [ j ] ; } for ( i = 0 ; i < n ; i ++ ) { cols [ i ] = 0 ; for ( j = 0 ; j < m ; j ++ ) cols [ i ] += mat [ j ] [ i ] ; } int cnt = 0 ; for ( i = 0 ; i < m ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 && rows [ i ] == 1 && cols [ j ] == 1 ) cnt ++ ; } } return cnt ; }
int ctMinEdits ( String str1 , String str2 ) { int N1 = str1 . length ( ) ; int N2 = str2 . length ( ) ; int freq1 [ ] = new int [ 256 ] ; Arrays . fill ( freq1 , 0 ) ; for ( int i = 0 ; i < N1 ; i ++ ) { freq1 [ str1 . charAt ( i ) ] ++ ; } int freq2 [ ] = new int [ 256 ] ; Arrays . fill ( freq2 , 0 ) ; for ( int i = 0 ; i < N2 ; i ++ ) { freq2 [ str2 . charAt ( i ) ] ++ ; } for ( int i = 0 ; i < 256 ; i ++ ) { if ( freq1 [ i ] > freq2 [ i ] ) { freq1 [ i ] = freq1 [ i ] - freq2 [ i ] ; freq2 [ i ] = 0 ; } else { freq2 [ i ] = freq2 [ i ] - freq1 [ i ] ; freq1 [ i ] = 0 ; } } int sum1 = 0 ; int sum2 = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { sum1 += freq1 [ i ] ; sum2 += freq2 [ i ] ; } return Math . max ( sum1 , sum2 ) ; }
void create_graph ( ) { g [ 1 ] . add ( 2 ) ; g [ 2 ] . add ( 1 ) ; g [ 1 ] . add ( 3 ) ; g [ 3 ] . add ( 1 ) ; g [ 1 ] . add ( 4 ) ; g [ 4 ] . add ( 1 ) ; g [ 2 ] . add ( 5 ) ; g [ 5 ] . add ( 2 ) ; g [ 2 ] . add ( 6 ) ; g [ 6 ] . add ( 2 ) ; }
void dfs ( int node , int parent ) { size [ node ] = 1 ; int mx = 0 ; for ( int y : g [ node ] ) { if ( y == parent ) continue ; dfs ( y , node ) ; size [ node ] += size [ y ] ; mx = Math . max ( mx , size [ y ] ) ; } mx = Math . max ( mx , n - size [ node ] ) ; if ( mx < mini ) { mini = mx ; ans = node ; } }
int countPrecedingK ( int a [ ] , int n , int K ) { int [ ] prefix = new int [ n ] ; prefix [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + a [ i ] ; } int ctr = 0 ; if ( prefix [ K - 1 ] < a [ K ] ) ctr ++ ; for ( int i = K + 1 ; i < n ; i ++ ) { if ( prefix [ i - 1 ] - prefix [ i - K - 1 ] < a [ i ] ) ctr ++ ; } return ctr ; }
int minDigits ( int N , int K ) { int digits_num = ( int ) Math . floor ( Math . log ( N ) + 1 ) ; int temp_sum = 0 ; int temp = digits_num ; int result = 0 ; int X , var ; int sum = 0 ; int num2 = N ; while ( num2 != 0 ) { sum += num2 % 10 ; num2 /= 10 ; } if ( sum <= K ) { X = 0 ; } else { while ( temp > 0 ) { var = ( N / ( ( int ) Math . pow ( 10 , temp - 1 ) ) ) ; temp_sum += var % 10 ; if ( temp_sum >= K ) { var /= 10 ; var ++ ; result = var * ( int ) Math . pow ( 10 , temp ) ; break ; } temp -- ; } X = result - N ; return X ; } return - 1 ; }
void CountPairs ( int a [ ] , int b [ ] , int n ) { int C [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { C [ i ] = a [ i ] + b [ i ] ; } HashMap < Integer , Integer > freqCount = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! freqCount . containsKey ( C [ i ] ) ) freqCount . put ( C [ i ] , 1 ) ; else freqCount . put ( C [ i ] , freqCount . get ( C [ i ] ) + 1 ) ; } int NoOfPairs = 0 ; for ( Map . Entry < Integer , Integer > x : freqCount . entrySet ( ) ) { int y = x . getValue ( ) ; NoOfPairs = NoOfPairs + y * ( y - 1 ) / 2 ; } System . out . println ( NoOfPairs ) ; }
void convertBfromA ( int a , int b ) { int moves = 0 ; int x = Math . abs ( a - b ) ; for ( int i = 10 ; i > 0 ; i -- ) { moves += x / i ; x = x % i ; } System . out . print ( moves + " " ) ; }
int smallestNth ( int A , int B , int N ) { int res = Integer . MAX_VALUE ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = N ; j > i ; j -- ) { if ( ( B - A ) % ( j - i ) == 0 ) { int D = ( B - A ) / ( j - i ) ; int FirstTerm = A - ( i - 1 ) * D ; int NthTerm = FirstTerm + ( N - 1 ) * D ; if ( FirstTerm > 0 ) res = Math . min ( res , NthTerm ) ; } } } return res ; }
void sieve ( boolean prime [ ] ) { for ( int i = 0 ; i < 1000000 ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = prime [ 1 ] = false ; for ( int i = 2 ; i * i <= 1000000 ; i ++ ) { if ( prime [ i ] ) { for ( int j = i * i ; j < 1000000 ; j += i ) { prime [ j ] = false ; } } } }
void subPrimeSum ( int N , int K , int arr [ ] , boolean prime [ ] ) { int currSum = 0 ; for ( int i = 0 ; i < K ; i ++ ) { currSum += arr [ i ] ; } if ( prime [ currSum ] ) { for ( int i = 0 ; i < K ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } return ; } int st = 1 , en = K ; while ( en < N ) { currSum += arr [ en ] - arr [ st - 1 ] ; if ( prime [ currSum ] ) { for ( int i = st ; i <= en ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } return ; } en ++ ; st ++ ; } }
int minDeletion ( String str ) { int n = str . length ( ) ; int firstIdx1 = - 1 ; int lastIdx0 = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '1' ) { firstIdx1 = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == '0' ) { lastIdx0 = i ; break ; } } if ( firstIdx1 == - 1 lastIdx0 == - 1 ) return 0 ; int count1 = 0 , count0 = 0 ; for ( int i = 0 ; i < lastIdx0 ; i ++ ) { if ( str . charAt ( i ) == '1' ) { count1 ++ ; } } for ( int i = firstIdx1 + 1 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '1' ) { count0 ++ ; } } return Math . min ( count0 , count1 ) ; }
int maximumSum ( int [ ] a , int [ ] b , int n , int index , int lastpicked ) { if ( index == n ) return 0 ; int option1 = 0 , option2 = 0 ; if ( lastpicked == - 1 a [ lastpicked ] != a [ index ] ) option1 = b [ index ] + maximumSum ( a , b , n , index + 1 , index ) ; option2 = maximumSum ( a , b , n , index + 1 , lastpicked ) ; return Math . max ( option1 , option2 ) ; }
int maximumSum ( int [ ] a , int [ ] b , int n , int index , int lastpicked , int [ ] [ ] dp ) { if ( index == n ) return 0 ; if ( dp [ index ] [ lastpicked + 1 ] != - 1 ) return dp [ index ] [ lastpicked + 1 ] ; int option1 = 0 , option2 = 0 ; if ( lastpicked == - 1 a [ lastpicked ] != a [ index ] ) { option1 = b [ index ] + maximumSum ( a , b , n , index + 1 , index , dp ) ; } option2 = maximumSum ( a , b , n , index + 1 , lastpicked , dp ) ; return dp [ index ] [ lastpicked + 1 ] = Math . max ( option1 , option2 ) ; }
void sumOfKElements ( int arr [ ] , int n , int k ) { boolean rev = false ; if ( k < 0 ) { rev = true ; k *= - 1 ; int l = 0 , r = n - 1 ; while ( l < r ) { int tmp = arr [ l ] ; arr [ l ] = arr [ r ] ; arr [ r ] = tmp ; l ++ ; r -- ; } } int dp [ ] = new int [ n ] ; dp [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] += dp [ i - 1 ] + arr [ i ] ; } int ans [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i + k < n ) ans [ i ] = dp [ i + k ] - dp [ i ] ; else { int x = k - ( n - 1 - i ) ; int y = x / n ; int rem = x % n ; ans [ i ] = dp [ n - 1 ] - dp [ i ] + y * dp [ n - 1 ] + ( rem - 1 >= 0 ? dp [ rem - 1 ] : 0 ) ; } } if ( rev ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { System . out . print ( ans [ i ] + " " ) ; } } else { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + " " ) ; } } }
int [ ] countingSubarray ( int arr [ ] , int n ) { int a [ ] = new int [ n ] ; int nsml [ ] = new int [ n ] ; Arrays . fill ( nsml , - 1 ) ; int nsmr [ ] = new int [ n ] ; Arrays . fill ( nsmr , n ) ; Stack < Integer > st = new Stack < Integer > ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( st . size ( ) > 0 && arr [ ( int ) st . peek ( ) ] >= arr [ i ] ) st . pop ( ) ; nsmr [ i ] = ( st . size ( ) > 0 ) ? ( int ) st . peek ( ) : n ; st . push ( i ) ; } while ( st . size ( ) > 0 ) st . pop ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( st . size ( ) > 0 && arr [ ( int ) st . peek ( ) ] >= arr [ i ] ) st . pop ( ) ; nsml [ i ] = ( st . size ( ) > 0 ) ? ( int ) st . peek ( ) : - 1 ; st . push ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { nsml [ i ] ++ ; nsmr [ i ] -- ; int r = nsmr [ i ] - i + 1 ; int l = i - nsml [ i ] + 1 ; a [ i ] = r * l ; } return a ; }
int countTuples ( int arr [ ] , int N ) { int ans = 0 , val = 0 ; HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int j = 0 ; j < N - 2 ; j ++ ) { val = 0 ; for ( int l = j + 1 ; l < N ; l ++ ) { if ( arr [ j ] == arr [ l ] ) { ans += val ; } if ( freq . containsKey ( arr [ l ] ) ) val += freq . get ( arr [ l ] ) ; } if ( freq . containsKey ( arr [ j ] ) ) { freq . put ( arr [ j ] , freq . get ( arr [ j ] ) + 1 ) ; } else { freq . put ( arr [ j ] , 1 ) ; } } return ans ; }
void isCrossed ( String path ) { if ( path . length ( ) == 0 ) return ; boolean ans = false ; HashSet < Point > set = new HashSet < Point > ( ) ; int x = 0 , y = 0 ; set . add ( new Point ( x , y ) ) ; for ( int i = 0 ; i < path . length ( ) ; i ++ ) { if ( path . charAt ( i ) == 'N' ) set . add ( new Point ( x , y ++ ) ) ; if ( path . charAt ( i ) == 'S' ) set . add ( new Point ( x , y -- ) ) ; if ( path . charAt ( i ) == 'E' ) set . add ( new Point ( x ++ , y ) ) ; if ( path . charAt ( i ) == 'W' ) set . add ( new Point ( x -- , y ) ) ; if ( set . contains ( new Point ( x , y ) ) ) { ans = true ; break ; } } if ( ans ) System . out . print ( "Crossed" ) ; else System . out . print ( "Not Crossed" ) ; }
int GCD ( int a , int b ) { if ( b == 0 ) { return a ; } return GCD ( b , a % b ) ; }
void GcdPair ( int [ ] [ ] arr , int k ) { int lo = 0 , hi = arr . length - 1 , mid ; int [ ] ans = { - 1 , 0 } ; while ( lo <= hi ) { mid = lo + ( hi - lo ) / 2 ; if ( GCD ( arr [ mid ] [ 0 ] , arr [ mid ] [ 1 ] ) > k ) { ans = arr [ mid ] ; hi = mid - 1 ; } else lo = mid + 1 ; } if ( ans [ 0 ] == - 1 ) System . out . print ( "-1" ) ; else System . out . print ( "( " + ans [ 0 ] + ", " + ans [ 1 ] + " )" ) ; return ; }
void isPossible ( int arr [ ] , int N ) { int mn = Integer . MAX_VALUE ; int [ ] B = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { mn = Math . min ( mn , arr [ i ] ) ; B [ i ] = arr [ i ] ; } Arrays . sort ( arr ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != B [ i ] ) { if ( B [ i ] % mn != 0 ) { System . out . print ( "No" ) ; return ; } } } System . out . print ( "Yes" ) ; return ; }
int func ( int n ) { int count = 0 ; if ( n == 2 n == 1 ) return 1 ; if ( n % 2 == 0 ) count = 1 + func ( n / 2 ) ; if ( n % 2 != 0 ) count = 1 + func ( n * 3 + 1 ) ; return count ; }
void findKthElement ( int l , int r , int k ) { ArrayList < Integer > arr = new ArrayList < > ( ) ; for ( int i = l ; i <= r ; i ++ ) arr . add ( i ) ; ArrayList < List < Integer > > result = new ArrayList < > ( ) ; for ( int i : arr ) result . add ( Arrays . asList ( i , func ( i ) ) ) ; Collections . sort ( result , ( s1 , s2 ) -> s1 . get ( 1 ) - s2 . get ( 1 ) ) ; System . out . println ( result . get ( k - 1 ) . get ( 0 ) ) ; }
void checkHex ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { char ch = s . charAt ( i ) ; if ( ( ch < '0' ch > '9' ) && ( ch < 'A' ch > 'F' ) ) { System . out . println ( "No" ) ; return ; } } System . out . println ( "Yes" ) ; }
int maxWidth ( int N , int M , ArrayList < Integer > cost , ArrayList < ArrayList < Integer > > s ) { ArrayList < ArrayList < Integer > > adj = new ArrayList < ArrayList < Integer > > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { adj . add ( new ArrayList < Integer > ( ) ) ; } for ( int i = 0 ; i < M ; i ++ ) { adj . get ( s . get ( i ) . get ( 0 ) ) . add ( s . get ( i ) . get ( 1 ) ) ; } int result = 0 ; Queue < Integer > q = new LinkedList < > ( ) ; q . add ( 0 ) ; while ( q . size ( ) != 0 ) { int count = q . size ( ) ; result = Math . max ( count , result ) ; while ( count -- > 0 ) { int temp = q . remove ( ) ; for ( int i = 0 ; i < adj . get ( temp ) . size ( ) ; i ++ ) { q . add ( adj . get ( temp ) . get ( i ) ) ; } } } return result ; }
void addEdge ( ArrayList < ArrayList < Integer > > adj , int u , int v ) { adj . get ( u ) . add ( v ) ; adj . get ( v ) . add ( u ) ; }
void DFSUtil ( int u , ArrayList < ArrayList < Integer > > adj , boolean [ ] visited , int componentMin , int componentMax ) { visited [ u ] = true ; componentMax = Math . max ( componentMax , u ) ; componentMin = Math . min ( componentMin , u ) ; for ( int i = 0 ; i < adj . get ( u ) . size ( ) ; i ++ ) if ( visited [ adj . get ( u ) . get ( i ) ] == false ) DFSUtil ( adj . get ( u ) . get ( i ) , adj , visited , componentMin , componentMax ) ; }
boolean isValid ( ArrayList < pair > v ) { int MAX = - 1 ; boolean ans = false ; for ( pair i : v ) { if ( i . first <= MAX ) { ans = true ; } MAX = Math . max ( MAX , i . second ) ; } return ( ans == false ? true : false ) ; }
void DFS ( ArrayList < ArrayList < Integer > > adj , int V ) { ArrayList < pair > v = new ArrayList < > ( ) ; boolean [ ] visited = new boolean [ V + 1 ] ; for ( int u = 1 ; u <= V ; u ++ ) { if ( visited [ u ] == false ) { int componentMax = u ; int componentMin = u ; DFSUtil ( u , adj , visited , componentMin , componentMax ) ; v . add ( new pair ( componentMin , componentMax ) ) ; } } boolean check = isValid ( v ) ; if ( check ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; return ; }
boolean checkEqual ( String arr [ ] , int N ) { int hash [ ] = new int [ 256 ] ; int M = arr [ 0 ] . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { hash [ arr [ i ] . charAt ( j ) ] ++ ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( hash [ i ] % N != 0 ) { return false ; } } return true ; }
void print_substring ( String s ) { int n = s . length ( ) ; String str = "" ; Vector < Integer > ans = new Vector < Integer > ( ) ; if ( n == 0 ) { System . out . print ( "-1" ) ; return ; } int [ ] last_pos = new int [ 26 ] ; Arrays . fill ( last_pos , - 1 ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( last_pos [ s . charAt ( i ) - 'a' ] == - 1 ) { last_pos [ s . charAt ( i ) - 'a' ] = i ; } } int minp = - 1 ; for ( int i = 0 ; i < n ; ++ i ) { int lp = last_pos [ s . charAt ( i ) - 'a' ] ; minp = Math . max ( minp , lp ) ; if ( i == minp ) { str += s . charAt ( i ) ; System . out . print ( str + ' ' ) ; minp = - 1 ; str = "" ; } else { str += s . charAt ( i ) ; } } }
void partitionString ( String s ) { int n = s . length ( ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; if ( n == 0 ) { System . out . print ( "-1" ) ; return ; } int [ ] last_pos = new int [ 26 ] ; Arrays . fill ( last_pos , - 1 ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( last_pos [ s . charAt ( i ) - 'a' ] == - 1 ) { last_pos [ s . charAt ( i ) - 'a' ] = i ; } } int minp = - 1 , plen = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int lp = last_pos [ s . charAt ( i ) - 'a' ] ; minp = Math . max ( minp , lp ) ; ++ plen ; if ( i == minp ) { ans . add ( plen ) ; minp = - 1 ; plen = 0 ; } } for ( int i = 0 ; i < ( int ) ans . size ( ) ; i ++ ) { System . out . print ( ans . get ( i ) + " " ) ; } }
int lenghtOfLongestAP ( int A [ ] , int n ) { Map < Integer , Map < Integer , Integer > > dp = new HashMap < Integer , Map < Integer , Integer > > ( ) ; int res = 2 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int d = A [ j ] - A [ i ] ; Map < Integer , Integer > temp ; if ( dp . containsKey ( d ) ) { temp = dp . get ( d ) ; if ( temp . containsKey ( i ) ) temp . put ( j , temp . get ( i ) + 1 ) ; else temp . put ( j , 2 ) ; } else { temp = new HashMap < Integer , Integer > ( ) ; temp . put ( j , 2 ) ; } dp . put ( d , temp ) ; res = Math . max ( res , temp . get ( j ) ) ; } } return res ; }
void numDifferenceUtil ( int N , int K ) { ArrayList res = new ArrayList ( ) ; res = numDifference ( N , K ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) { System . out . print ( res . get ( i ) + " " ) ; } }
int minFirstTerm ( int X , int diff , int N ) { int first_term = Integer . MAX_VALUE ; int low = 0 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( X - mid * diff > 0 ) { first_term = X - mid * diff ; low = mid + 1 ; } else high = mid - 1 ; } return first_term ; }
boolean isCubeSum ( int n ) { for ( int i = 1 ; i * i * i <= n ; i ++ ) { if ( i * i * i + ( i + 1 ) * ( i + 1 ) * ( i + 1 ) == n ) return true ; } return false ; }
boolean isSumCube ( int N ) { int a = ( int ) Math . cbrt ( N ) ; int b = a - 1 ; return ( ( a * a * a + b * b * b ) == N ) ; }
int maxweight ( int s , int e , Map < Integer , Integer > pre ) { if ( s == e ) return 0 ; int ans = 0 ; for ( int i = s ; i < e ; i ++ ) { int left = pre . get ( i ) - pre . get ( s - 1 ) ; int right = pre . get ( e ) - pre . get ( i ) ; if ( left < right ) ans = Math . max ( ans , left + maxweight ( s , i , pre ) ) ; if ( left == right ) { ans = Math . max ( ans , Math . max ( left + maxweight ( s , i , pre ) , right + maxweight ( i + 1 , e , pre ) ) ) ; } if ( left > right ) ans = Math . max ( ans , right + maxweight ( i + 1 , e , pre ) ) ; } return ans ; }
void maxSum ( List < Integer > arr ) { Map < Integer , Integer > pre = new HashMap < > ( ) ; pre . put ( - 1 , 0 ) ; pre . put ( 0 , arr . get ( 0 ) ) ; for ( int i = 1 ; i < arr . size ( ) ; i ++ ) { pre . put ( i , pre . getOrDefault ( i - 1 , 0 ) + arr . get ( i ) ) ; } System . out . println ( maxweight ( 0 , arr . size ( ) - 1 , pre ) ) ; }
void SieveOfEratosthenes ( boolean prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
int LISPrime ( int arr [ ] , int n ) { int [ ] lisp = new int [ n ] ; boolean [ ] prime = new boolean [ N + 1 ] ; for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , N ) ; lisp [ 0 ] = prime [ arr [ 0 ] ] ? 1 : 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ! prime [ arr [ i ] ] ) { lisp [ i ] = 0 ; continue ; } lisp [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( prime [ arr [ j ] ] && arr [ i ] > arr [ j ] && lisp [ i ] < lisp [ j ] + 1 ) { lisp [ i ] = lisp [ j ] + 1 ; } } } return Arrays . stream ( lisp ) . max ( ) . getAsInt ( ) ; }
void checkSumOfNatural ( int n ) { int i = 1 ; boolean flag = false ; while ( i * ( i + 1 ) < n * 2 ) { int X = i * ( i + 1 ) ; int t = n * 2 - X ; int k = ( int ) Math . sqrt ( t ) ; if ( k * ( k + 1 ) == t ) { flag = true ; break ; } i += 1 ; } if ( flag ) System . out . println ( "YES" ) ; else System . out . println ( "NO" ) ; }
void countNumEnds ( int A , int L , int R ) { int temp , count = 0 , digits ; int cycle ; digits = ( int ) ( Math . log10 ( A ) + 1 ) ; temp = ( int ) Math . pow ( 10 , digits ) ; cycle = temp ; while ( temp <= R ) { if ( temp >= L ) count ++ ; temp += cycle ; } System . out . print ( count ) ; }
int minOperations ( String s ) { int len = s . length ( ) ; int result = 0 ; for ( int i = 0 ; i < len / 2 ; i ++ ) { int D1 = Math . max ( s . charAt ( i ) , s . charAt ( len - 1 - i ) ) - Math . min ( s . charAt ( i ) , s . charAt ( len - 1 - i ) ) ; int D2 = 26 - D1 ; result += Math . min ( D1 , D2 ) ; } return result ; }
void countMaximum ( Integer [ ] a , int n ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; int count = 0 ; int mark = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ( a [ i ] + n >= mark ) ) { count += 1 ; } mark = Math . max ( mark , a [ i ] + i + 1 ) ; } System . out . print ( count ) ; }
boolean allCoprime ( int A [ ] , int n ) { boolean all_coprime = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( gcd ( A [ i ] , A [ j ] ) != 1 ) { all_coprime = false ; break ; } } } return all_coprime ; }
long binomialCoeff ( int n , int k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
long findWays ( int n ) { if ( ( n & 1 ) == 1 ) return 0 ; return catalan ( n / 2 ) ; }
void countNonNPeriodic ( int N ) { System . out . println ( findWays ( 2 * N ) - findWays ( N ) ) ; }
int isValid ( int n , int m , int k ) { int step2 = n - m ; int cnt = ( step2 * ( step2 + 1 ) ) / 2 ; if ( cnt - m == k ) return 0 ; if ( cnt - m > k ) return 1 ; return - 1 ; }
void countOfOperations ( int n , int k ) { int start = 0 , end = n ; boolean ok = true ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int temp = isValid ( n , mid , k ) ; if ( temp == 0 ) { ok = false ; System . out . print ( mid ) ; break ; } else if ( temp == 1 ) { start = mid + 1 ; } else { end = mid - 1 ; } } if ( ok ) System . out . print ( "-1" ) ; }
boolean nonLower ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! Character . isLowerCase ( s . charAt ( i ) ) ) { return true ; } } return false ; }
char getChar ( int n ) { return ( char ) ( n + 96 ) ; }
String [ ] getCode ( String str ) { if ( str . length ( ) == 0 ) { String ans [ ] = { "" } ; return ans ; } String output1 [ ] = getCode ( str . substring ( 1 ) ) ; String output2 [ ] = new String [ 0 ] ; int firstDigit = ( str . charAt ( 0 ) - '0' ) ; int firstTwoDigit = 0 ; if ( str . length ( ) >= 2 ) { firstTwoDigit = ( str . charAt ( 0 ) - '0' ) * 10 + ( str . charAt ( 1 ) - '0' ) ; if ( firstTwoDigit >= 10 && firstTwoDigit <= 26 ) { output2 = getCode ( str . substring ( 2 ) ) ; } } String output [ ] = new String [ output1 . length + output2 . length ] ; int k = 0 ; for ( int i = 0 ; i < output1 . length ; i ++ ) { char ch = getChar ( firstDigit ) ; output [ i ] = ch + output1 [ i ] ; k ++ ; } for ( int i = 0 ; i < output2 . length ; i ++ ) { char ch = getChar ( firstTwoDigit ) ; output [ k ] = ch + output2 [ i ] ; k ++ ; } return output ; }
int smallestNum ( int n ) { double power = log2 ( 10 ) ; return ( int ) Math . ceil ( ( n - 1 ) * power ) ; }
double countSubSequence ( int [ ] arr , int n ) { int maximum = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int minimum = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; if ( maximum == minimum ) return Math . pow ( 2 , n ) - 1 ; int i = count ( arr , maximum ) ; int j = count ( arr , minimum ) ; double res = ( Math . pow ( 2 , i ) - 1 ) * ( Math . pow ( 2 , j ) - 1 ) * Math . pow ( 2 , n - i - j ) ; return res ; }
int transformSubsequence ( int n , int m , int [ ] A , int [ ] B ) { if ( B . length == 0 ) return n ; int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < m + 1 ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 0 ; else if ( A [ i - 1 ] == B [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return n - dp [ n ] [ m ] ; }
void SieveOfEratosthenes ( ) { Arrays . fill ( isPrime , true ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= MAX ; p ++ ) if ( isPrime [ p ] ) primes . add ( p ) ; }
int prime_search ( Vector < Integer > primes , int diff ) { int low = 0 ; int high = primes . size ( ) - 1 ; int res = - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( primes . get ( mid ) == diff ) { return primes . get ( mid ) ; } else if ( primes . get ( mid ) < diff ) { low = mid + 1 ; } else { res = primes . get ( mid ) ; high = mid - 1 ; } } return res ; }
int minCost ( int arr [ ] , int n ) { SieveOfEratosthenes ( ) ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { int diff = arr [ i - 1 ] - arr [ i ] ; int closest_prime = prime_search ( primes , diff ) ; res += closest_prime ; arr [ i ] += closest_prime ; } } return res ; }
int isprm ( int n ) { if ( n <= 1 ) return 0 ; if ( n <= 3 ) return 1 ; if ( n % 2 == 0 n % 3 == 0 ) return 0 ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) return 0 ; } return 1 ; }
int countprime ( int n ) { int count = 0 ; Vector < Integer > primevector = new Vector < > ( ) ; for ( int i = 2 ; i <= n ; i ++ ) { if ( isprm ( i ) == 1 ) { primevector . add ( i ) ; } } int sum = primevector . elementAt ( 0 ) ; for ( int i = 1 ; i < primevector . size ( ) ; i ++ ) { sum += primevector . elementAt ( i ) ; if ( sum > n ) break ; if ( isprm ( sum ) == 1 ) { count ++ ; } } return count ; }
void addEdge ( Vector < Integer > v [ ] , int x , int y ) { v [ x ] . add ( y ) ; v [ y ] . add ( x ) ; }
void dfs ( Vector < Integer > tree [ ] , Vector < Integer > temp , int ancestor [ ] , int u , int parent , int k ) { temp . add ( u ) ; for ( int i : tree [ u ] ) { if ( i == parent ) continue ; dfs ( tree , temp , ancestor , i , u , k ) ; } temp . remove ( temp . size ( ) - 1 ) ; if ( temp . size ( ) < k ) { ancestor [ u ] = - 1 ; } else { ancestor [ u ] = temp . get ( temp . size ( ) - k ) ; } }
void KthAncestor ( int N , int K , int E , int edges [ ] [ ] ) { @ SuppressWarnings ( "unchecked" ) Vector < Integer > [ ] tree = new Vector [ N + 1 ] ; for ( int i = 0 ; i < tree . length ; i ++ ) tree [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < E ; i ++ ) { addEdge ( tree , edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) ; } Vector < Integer > temp = new Vector < Integer > ( ) ; int [ ] ancestor = new int [ N + 1 ] ; dfs ( tree , temp , ancestor , 1 , 0 , K ) ; for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( ancestor [ i ] + " " ) ; } }
int [ ] dfs ( Node root , int distance ) { if ( root == null ) return new int [ distance + 1 ] ; if ( root . left == null && root . right == null ) { int res [ ] = new int [ distance + 1 ] ; res [ 1 ] ++ ; return res ; } int [ ] left = dfs ( root . left , distance ) ; int [ ] right = dfs ( root . right , distance ) ; int res [ ] = new int [ distance + 1 ] ; for ( int i = res . length - 2 ; i >= 1 ; i -- ) { res [ i + 1 ] = left [ i ] + right [ i ] ; } for ( int l = 1 ; l < left . length ; l ++ ) { for ( int r = 0 ; r < right . length ; r ++ ) { if ( l + r <= distance ) { result += left [ l ] * right [ r ] ; } } } return res ; }
void build ( Vector < Integer > sum , Vector < Integer > a , int l , int r , int rt ) { if ( l == r ) { sum . set ( rt , a . get ( l - 1 ) ) ; return ; } int m = ( l + r ) >> 1 ; build ( sum , a , l , m , rt << 1 ) ; build ( sum , a , m + 1 , r , rt << 1 1 ) ; }
void pushDown ( Vector < Integer > sum , Vector < Integer > add , int rt , int ln , int rn ) { if ( add . get ( rt ) != 0 ) { add . set ( rt << 1 , add . get ( rt ) ) ; add . set ( rt << 1 | 1 , add . get ( rt ) ) ; sum . set ( rt << 1 , sum . get ( rt << 1 ) + add . get ( rt ) * ln ) ; sum . set ( rt << 1 | 1 , sum . get ( rt << 1 1 ) + add . get ( rt ) * rn ) ; add . set ( rt , 0 ) ; } }
void update ( Vector < Integer > sum , Vector < Integer > add , int L , int R , int C , int l , int r , int rt ) { if ( L <= l && r <= R ) { sum . set ( rt , sum . get ( rt ) + C * ( r - l + 1 ) ) ; add . set ( rt , add . get ( rt ) + C ) ; return ; } int m = ( l + r ) >> 1 ; pushDown ( sum , add , rt , m - l + 1 , r - m ) ; if ( L <= m ) { update ( sum , add , L , R , C , l , m , rt << 1 ) ; } if ( R > m ) { update ( sum , add , L , R , C , m + 1 , r , rt << 1 1 ) ; } }
void sequenceMaintenance ( int n , int q , Vector < Integer > a , Vector < Integer > b , int m ) { Collections . sort ( a ) ; Vector < Integer > sum = new Vector < Integer > ( ) ; Vector < Integer > ad = new Vector < Integer > ( ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < ( n << 2 ) ; i ++ ) { sum . add ( 0 ) ; ad . add ( 0 ) ; } build ( sum , a , 1 , n , 1 ) ; for ( int i = 0 ; i < q ; i ++ ) { int l = 1 , r = n , pos = - 1 ; while ( l <= r ) { m = ( l + r ) >> 1 ; if ( query ( sum , ad , m , m , 1 , n , 1 ) >= b . get ( i ) ) { r = m - 1 ; pos = m ; } else { l = m + 1 ; } } if ( pos == - 1 ) { ans . add ( 0 ) ; } else { ans . add ( n - pos + 1 ) ; update ( sum , ad , pos , n , - m , 1 , n , 1 ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( ans . get ( i ) + " " ) ; } }
int MaximumPath ( int [ ] [ ] grid ) { int N = grid . length ; int M = grid [ 0 ] . length ; int [ ] [ ] sum = new int [ N + 1 ] [ M + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { sum [ i ] [ j ] = Math . max ( sum [ i - 1 ] [ j ] , sum [ i ] [ j - 1 ] ) + grid [ i - 1 ] [ j - 1 ] ; } } return sum [ N ] [ M ] ; }
void SubarrayHavingPerfectSquare ( int [ ] arr , int k ) { pair ans = new pair ( ) ; int sum = 0 , i ; for ( i = 0 ; i < k ; i ++ ) { sum += arr [ i ] ; } boolean found = false ; if ( isPerfectSquare ( sum ) ) { ans . first = 0 ; ans . second = i - 1 ; } else { for ( int j = i ; j < arr . length ; j ++ ) { sum = sum + arr [ j ] - arr [ j - k ] ; if ( isPerfectSquare ( sum ) ) { found = true ; ans . first = j - k + 1 ; ans . second = j ; } } for ( int k1 = ans . first ; k1 <= ans . second ; k1 ++ ) { System . out . print ( arr [ k1 ] + " " ) ; } } if ( found == false ) { System . out . print ( "-1" ) ; } }
int calcSubarray ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { boolean flag = true ; int comm_diff = A [ i + 1 ] - A [ i ] ; for ( int k = i ; k < j ; k ++ ) { if ( A [ k + 1 ] - A [ k ] == comm_diff ) { continue ; } else { flag = false ; break ; } } if ( flag ) { count ++ ; } } } return count ; }
char findKthChar ( int n , int k ) { String prev = "A" ; String cur = "" ; if ( n == 1 ) { return 'A' ; } for ( int j = 2 ; j <= n ; j ++ ) { cur = prev + "B" ; for ( int i = 0 ; i < prev . length ( ) ; i ++ ) { if ( prev . charAt ( i ) == 'A' ) { prev . replace ( prev . charAt ( i ) , 'B' ) ; } else { prev . replace ( prev . charAt ( i ) , 'A' ) ; } } prev = reverse ( prev ) ; cur += prev ; prev = cur ; } return cur . charAt ( k ) ; }
boolean areAnagrams ( int a , int b ) { int freqA [ ] = new int [ TEN ] ; int freqB [ ] = new int [ TEN ] ; updateFreq ( a , freqA ) ; updateFreq ( b , freqB ) ; for ( int i = 0 ; i < TEN ; i ++ ) { if ( freqA [ i ] != freqB [ i ] ) return false ; } return true ; }
boolean isPowerOf2 ( int N ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( areAnagrams ( 1 << i , N ) ) { System . out . print ( ( 1 << i ) ) ; return true ; } } return false ; }
int right_angled ( int n ) { int count = 0 ; for ( int z = 1 ; z <= n ; z ++ ) { for ( int y = 1 ; y <= z ; y ++ ) { for ( int x = 1 ; x <= y ; x ++ ) { if ( ( x * x ) + ( y * y ) == ( z * z ) ) { count ++ ; } } } } return count ; }
void mirrorMatrix ( int mat1 [ ] [ ] , int mat2 [ ] [ ] , int N ) { int row = 0 ; int col = 0 ; boolean isMirrorImage = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( mat2 [ row ] [ col ] != mat1 [ i ] [ j ] ) { isMirrorImage = false ; } col ++ ; } col = 0 ; row ++ ; } if ( isMirrorImage ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
void maxAbsDiffLevelSum ( int N , int M , int [ ] cost , int Edges [ ] [ ] ) { @ SuppressWarnings ( "unchecked" ) Vector < Integer > [ ] adj = new Vector [ N ] ; for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < M ; i ++ ) { int u = Edges [ i ] [ 0 ] ; int v = Edges [ i ] [ 1 ] ; adj [ u ] . add ( v ) ; } int maxSum = cost [ 0 ] , minSum = cost [ 0 ] ; Queue < Integer > q = new LinkedList < Integer > ( ) ; q . add ( 0 ) ; while ( ! q . isEmpty ( ) ) { int count = q . size ( ) ; int sum = 0 ; while ( count -- > 0 ) { int temp = q . peek ( ) ; q . remove ( ) ; sum = sum + cost [ temp ] ; for ( int i = 0 ; i < adj [ temp ] . size ( ) ; i ++ ) { q . add ( adj [ temp ] . get ( i ) ) ; } } maxSum = Math . max ( sum , maxSum ) ; minSum = Math . min ( sum , minSum ) ; } System . out . print ( Math . abs ( maxSum - minSum ) ) ; }
int dfs ( int src , int dest , int [ ] vis , Vector < Integer > [ ] adj ) { vis [ src ] = 1 ; if ( src == dest ) { return 1 ; } for ( int u : adj [ src ] ) { if ( vis [ u ] == 0 ) { int temp = dfs ( u , dest , vis , adj ) ; if ( temp != 0 ) { return temp + 1 ; } } } return 0 ; }
int countMagicNumbers ( int idx , int sum , int [ ] a , int n , int m , int l , int r ) { if ( idx == n ) { int Temp = sum % m ; if ( Temp == l || Temp == r || ( Temp > l && Temp < r ) ) { dp . put ( new Point ( idx , sum ) , 1 ) ; return dp . get ( new Point ( idx , sum ) ) ; } else { dp . put ( new Point ( idx , sum ) , 0 ) ; return dp . get ( new Point ( idx , sum ) ) ; } } Point curr = new Point ( idx , sum ) ; if ( dp . containsKey ( curr ) ) return dp . get ( curr ) ; int ls = countMagicNumbers ( idx + 1 , sum + a [ idx ] , a , n , m , l , r ) ; int rs = countMagicNumbers ( idx + 1 , sum + ( a [ idx ] - 1 ) , a , n , m , l , r ) ; int temp1 = Math . max ( ls , rs ) ; int temp = sum % m ; if ( ( temp == l || temp == r || ( temp > l && temp < r ) ) && idx != 0 ) { temp1 += 1 ; } dp . put ( new Point ( idx , sum ) , temp1 ) ; return dp . get ( new Point ( idx , sum ) ) ; }
int count_numbers ( int L , int R ) { int ans = 0 ; for ( int n = L ; n <= R ; n ++ ) { int no_of_bits = ( int ) ( Math . log ( n ) + 1 ) ; int no_of_set_bits = Integer . bitCount ( n ) ; if ( no_of_bits - no_of_set_bits == 1 ) { ans ++ ; } } return ans ; }
boolean check ( String s , int k ) { int n = s . length ( ) ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i ; j < n ; j += k ) { if ( s . charAt ( i ) != s . charAt ( j ) ) return false ; } } int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( s . charAt ( i ) == '0' ) c ++ ; else c -- ; } if ( c == 0 ) return true ; else return false ; }
int findSum ( String s ) { int sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { sum += ( j - i ) ; } } } return sum ; }
int countElements ( int [ ] a , int n ) { int [ ] cnt = new int [ n + 1 ] ; int ans = 0 ; for ( int k : a ) { ++ cnt [ k ] ; } for ( int l = 0 ; l < n ; ++ l ) { int sum = 0 ; for ( int r = l ; r < n ; ++ r ) { sum += a [ r ] ; if ( l == r ) continue ; if ( sum <= n ) { ans += cnt [ sum ] ; cnt [ sum ] = 0 ; } } } return ans ; }
int maxGCD ( int n ) { int maxHcf = Integer . MIN_VALUE ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { maxHcf = Math . max ( maxHcf , __gcd ( i , j ) ) ; } } return maxHcf ; }
void addEdge ( int a , int b ) { tree [ a ] . add ( b ) ; tree [ b ] . add ( a ) ; }
void dfs ( int x ) { vis [ x ] = true ; subtreeSize [ x ] = 1 ; for ( int i : tree [ x ] ) { if ( ! vis [ i ] ) { dfs ( i ) ; subtreeSize [ x ] += subtreeSize [ i ] ; } } }
int [ ] [ ] matrixMinimum ( int [ ] [ ] nums , int K ) { int N = nums . length ; int M = nums [ 0 ] . length ; int [ ] [ ] res = new int [ N - K + 1 ] [ M - K + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M - K + 1 ; j ++ ) { int min = Integer . MAX_VALUE ; for ( int k = j ; k < j + K ; k ++ ) { min = Math . min ( min , nums [ i ] [ k ] ) ; } nums [ i ] [ j ] = min ; } } for ( int j = 0 ; j < M ; j ++ ) { for ( int i = 0 ; i < N - K + 1 ; i ++ ) { int min = Integer . MAX_VALUE ; for ( int k = i ; k < i + K ; k ++ ) { min = Math . min ( min , nums [ k ] [ j ] ) ; } nums [ i ] [ j ] = min ; } } for ( int i = 0 ; i < N - K + 1 ; i ++ ) for ( int j = 0 ; j < M - K + 1 ; j ++ ) res [ i ] [ j ] = nums [ i ] [ j ] ; return res ; }
int uncrossedLines ( int [ ] a , int [ ] b , int n , int m ) { int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 0 ; else if ( a [ i - 1 ] == b [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ n ] [ m ] ; }
char find_kth_largest ( char [ ] str , int k ) { Arrays . sort ( str ) ; reverse ( str ) ; return str [ k - 1 ] ; }
void updateString ( char [ ] str , int pos , char s ) { int index = pos - 1 ; char c = s ; str [ index ] = c ; }
void update_BITree ( int index , char C , int val ) { while ( index <= N ) { BITree [ C - 'a' ] [ index ] += val ; index += ( index & - index ) ; } }
int sum_BITree ( int index , char C ) { int s = 0 ; while ( index > 0 ) { s += BITree [ C - 'a' ] [ index ] ; index -= ( index & - index ) ; } return s ; }
int revNum ( int N ) { int x = 0 ; while ( N != 0 ) { x = x * 10 + N % 10 ; N = N / 10 ; } return x ; }
int ctNonPalin ( int arr [ ] , int N ) { int Res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int x = revNum ( arr [ i ] ) ; if ( x == arr [ i ] ) { continue ; } else { if ( arr [ i ] % 10 == x % 10 ) Res += 1 ; } } return Res ; }
int smallSumSubset ( List < Integer > data , int target , int maxVal ) { int sum = 0 ; for ( Integer i : data ) sum += i ; if ( target <= 0 ) return 0 ; else if ( sum < target ) return maxVal ; else if ( sum == target ) return data . size ( ) ; else if ( data . get ( 0 ) >= target ) return 1 ; else if ( data . get ( 0 ) < target ) { List < Integer > temp = new ArrayList < > ( ) ; for ( int i = 1 ; i < data . size ( ) ; i ++ ) temp . add ( data . get ( i ) ) ; return Math . min ( smallSumSubset ( temp , target , maxVal ) , 1 + smallSumSubset ( temp , target - data . get ( 0 ) , maxVal ) ) ; } return - 1 ; }
int minlt ( int [ ] arr , int target , int n ) { int [ ] [ ] dp = new int [ arr . length + 1 ] [ target + 1 ] ; for ( int [ ] row : dp ) Arrays . fill ( row , - 1 ) ; for ( int i = 0 ; i < arr . length + 1 ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j < target + 1 ; j ++ ) dp [ 0 ] [ j ] = Integer . MAX_VALUE ; for ( int i = 1 ; i <= arr . length ; i ++ ) { for ( int j = 1 ; j <= target ; j ++ ) { if ( arr [ i - 1 ] > j ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else { dp [ i ] [ j ] = Math . min ( dp [ i - 1 ] [ j ] , ( dp [ i ] [ j - arr [ i - 1 ] ] ) != Integer . MAX_VALUE ? ( dp [ i ] [ j - arr [ i - 1 ] ] + 1 ) : Integer . MAX_VALUE ) ; } } } if ( dp [ arr . length ] [ target ] == Integer . MAX_VALUE ) { return - 1 ; } else { return dp [ arr . length ] [ target ] ; } }
long GCD ( long a , long b ) { if ( a == 0 ) return b ; return GCD ( b % a , a ) ; }
long LCM ( long a , long b ) { return ( a * b ) / GCD ( a , b ) ; }
void checkPairwiseCoPrime ( int A [ ] , int n ) { long prod = 1 ; long lcm = 1 ; for ( int i = 0 ; i < n ; i ++ ) { prod *= A [ i ] ; lcm = LCM ( A [ i ] , lcm ) ; } if ( prod == lcm ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
int minDiffSubArray ( int arr [ ] , int n ) { int [ ] prefix_sum = new int [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; int [ ] suffix_sum = new int [ n ] ; suffix_sum [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffix_sum [ i ] = suffix_sum [ i + 1 ] + arr [ i ] ; int minDiff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int diff = Math . abs ( prefix_sum [ i ] - suffix_sum [ i + 1 ] ) ; if ( diff < minDiff ) minDiff = diff ; } return minDiff ; }
int minDiffSubArray ( int arr [ ] , int n ) { int total_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) total_sum += arr [ i ] ; int prefix_sum = 0 ; int minDiff = Integer . MAX_VALUE ; for ( int i = 0 ; i < n - 1 ; i ++ ) { prefix_sum += arr [ i ] ; int diff = Math . abs ( ( total_sum - prefix_sum ) - prefix_sum ) ; if ( diff < minDiff ) minDiff = diff ; } return minDiff ; }
int maxLenSub ( int arr [ ] , int N ) { int Pos = 0 ; int Neg = 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { Pos = Neg = 0 ; } else if ( arr [ i ] > 0 ) { Pos += 1 ; if ( Neg != 0 ) { Neg += 1 ; } res = Math . max ( res , Pos ) ; } else { Pos = Pos + Neg ; Neg = Pos - Neg ; Neg = Pos - Neg ; Neg += 1 ; if ( Pos != 0 ) { Pos += 1 ; } res = Math . max ( res , Pos ) ; } } return res ; }
void maxStrings ( String [ ] arr , int len ) { int N = arr . length ; Vector < String > ans = new Vector < String > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( len == arr [ i ] . length ( ) ) { ans . add ( arr [ i ] ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( ans . get ( i ) + " " ) ; } }
void printStrings ( String [ ] arr ) { int max = maxLength ( arr ) ; maxStrings ( arr , max ) ; }
void addEdge ( int u , int v ) { vec [ u ] . add ( v ) ; vec [ v ] . add ( u ) ; }
boolean swapXandY ( char [ ] str , int X , int Y ) { int N = str . length ; X = X + Y ; Y = X - Y ; X = X - Y ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == 'p' ) { str [ i ] = 'r' ; } else if ( str [ i ] == 'r' ) { str [ i ] = 'p' ; } } return true ; }
boolean canTransform ( String str1 , String str2 ) { String s1 = "" ; String s2 = "" ; for ( char c : str1 . toCharArray ( ) ) { if ( c != 'C' ) { s1 += c ; } } for ( char c : str2 . toCharArray ( ) ) { if ( c != 'C' ) { s2 += c ; } } if ( ! s1 . equals ( s2 ) ) return false ; int i = 0 ; int j = 0 ; int n = str1 . length ( ) ; while ( i < n && j < n ) { if ( str1 . charAt ( i ) == 'C' ) { i ++ ; } else if ( str2 . charAt ( j ) == 'C' ) { j ++ ; } else { if ( ( str1 . charAt ( i ) == 'A' && i < j ) || ( str1 . charAt ( i ) == 'B' && i > j ) ) { return false ; } i ++ ; j ++ ; } } return true ; }
void dailyTemperatures ( int [ ] T ) { int n = T . length ; int [ ] daysOfWait = new int [ n ] ; Arrays . fill ( daysOfWait , - 1 ) ; Stack < Integer > s = new Stack < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! s . isEmpty ( ) && T [ s . peek ( ) ] < T [ i ] ) { daysOfWait [ s . peek ( ) ] = i - s . peek ( ) ; s . pop ( ) ; } s . push ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( daysOfWait [ i ] + " " ) ; } }
int CtSubarr ( int [ ] arr , int N , int K ) { Set < Integer > st = new HashSet < Integer > ( ) ; int prefixSum = 0 ; st . add ( prefixSum ) ; int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { prefixSum += arr [ i ] ; if ( st . contains ( prefixSum - K ) ) { res += 1 ; prefixSum = 0 ; st . clear ( ) ; st . add ( 0 ) ; } st . add ( prefixSum ) ; } return res ; }
int getMaxLength ( int arr [ ] , int N ) { int res = 2 ; int dist = 2 ; int curradj = ( arr [ 1 ] - arr [ 0 ] ) ; int prevadj = ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < N ; i ++ ) { curradj = arr [ i ] - arr [ i - 1 ] ; if ( curradj == prevadj ) { dist ++ ; } else { prevadj = curradj ; res = Math . max ( res , dist ) ; dist = 2 ; } } res = Math . max ( res , dist ) ; return res ; }
double func ( double a , double b , double c , double x ) { return a * x * x + b * x + c ; }
double findRoot ( double a , double b , double c , double low , double high ) { double x = - 1 ; while ( Math . abs ( high - low ) > eps ) { x = ( low + high ) / 2 ; if ( func ( a , b , c , low ) * func ( a , b , c , x ) <= 0 ) { high = x ; } else { low = x ; } } return x ; }
int minSteps ( String str , int N ) { int smaller , cost = 0 ; int f [ ] = new int [ 26 ] ; for ( int i = 0 ; i < N ; i ++ ) { int curr_ele = str . charAt ( i ) - 'a' ; smaller = 0 ; for ( int j = 0 ; j <= curr_ele ; j ++ ) { if ( f [ j ] != 0 ) smaller += f [ j ] ; } if ( smaller == 0 ) cost += ( i + 1 ) ; else cost += ( i - smaller + 1 ) ; f [ str . charAt ( i ) - 'a' ] ++ ; } return cost ; }
void dfs ( int u , int p , int dis , int vis [ ] , int distance [ ] , int parent [ ] , int preTime [ ] , int postTime [ ] , ArrayList < ArrayList < Integer > > Adj ) { distance [ u ] = dis ; parent [ u ] = p ; vis [ u ] = 1 ; timeT ++ ; preTime [ u ] = timeT ; for ( int i = 0 ; i < Adj . get ( u ) . size ( ) ; i ++ ) { if ( vis [ Adj . get ( u ) . get ( i ) ] == 0 ) { dfs ( Adj . get ( u ) . get ( i ) , u , dis + 1 , vis , distance , parent , preTime , postTime , Adj ) ; } } timeT ++ ; postTime [ u ] = timeT ; }
void addEdge ( ArrayList < ArrayList < Integer > > Adj , int u , int v ) { Adj . get ( u ) . add ( v ) ; Adj . get ( v ) . add ( u ) ; }
void findNodeU ( int N , int V , int Vertices [ ] , int Edges [ ] [ ] ) { int vis [ ] = new int [ N + 1 ] ; int distance [ ] = new int [ N + 1 ] ; int parent [ ] = new int [ N + 1 ] ; int preTime [ ] = new int [ N + 1 ] ; int postTime [ ] = new int [ N + 1 ] ; ArrayList < ArrayList < Integer > > Adj = new ArrayList < > ( ) ; for ( int i = 0 ; i < N + 1 ; i ++ ) Adj . add ( new ArrayList < Integer > ( ) ) ; int u = 0 , v ; for ( int i = 0 ; i < N - 1 ; i ++ ) { addEdge ( Adj , Edges [ i ] [ 0 ] , Edges [ i ] [ 1 ] ) ; } dfs ( 1 , 0 , 0 , vis , distance , parent , preTime , postTime , Adj ) ; int maximumDistance = 0 ; maximumDistance = 0 ; for ( int k = 0 ; k < V ; k ++ ) { if ( maximumDistance < distance [ Vertices [ k ] ] ) { maximumDistance = distance [ Vertices [ k ] ] ; u = Vertices [ k ] ; } if ( parent [ Vertices [ k ] ] != 0 ) { Vertices [ k ] = parent [ Vertices [ k ] ] ; } } boolean ans = true ; boolean flag ; for ( int k = 0 ; k < V ; k ++ ) { if ( preTime [ Vertices [ k ] ] <= preTime [ u ] && postTime [ Vertices [ k ] ] >= postTime [ u ] ) flag = true ; else flag = false ; ans = ans & flag ; } if ( ans ) System . out . println ( u ) ; else System . out . println ( "NO" ) ; }
void countRectangles ( int [ ] a , int [ ] b , int K ) { int n = a . length ; int m = b . length ; int [ ] subA = findSubarrays ( a ) ; int [ ] subB = findSubarrays ( b ) ; int total = 0 ; for ( int i = 1 ; i < subA . length ; i ++ ) { if ( K % i == 0 && ( K / i ) <= m ) { total = total + subA [ i ] * subB [ K / i ] ; } } System . out . print ( total ) ; }
void addedge ( int a , int b ) { edges [ a ] . add ( b ) ; edges [ b ] . add ( a ) ; }
void findCost ( int r , int p , int arr [ ] ) { int i , cur ; for ( i = 0 ; i < edges [ r ] . size ( ) ; i ++ ) { cur = edges [ r ] . get ( i ) ; if ( cur == p ) continue ; findCost ( cur , r , arr ) ; arr [ r ] += arr [ cur ] ; } int t1 = arr [ r ] ; int t2 = allsum - t1 ; if ( t1 * t2 > ans ) { ans = t1 * t2 ; } }
void maximumCost ( int r , int p , int N , int M , int arr [ ] , int Edges [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { allsum += arr [ i ] ; } for ( int i = 0 ; i < M ; i ++ ) { addedge ( Edges [ i ] [ 0 ] , Edges [ i ] [ 1 ] ) ; } findCost ( r , p , arr ) ; }
void printRes ( Vector < Integer > res ) { Enumeration enu = res . elements ( ) ; while ( enu . hasMoreElements ( ) ) { System . out . print ( enu . nextElement ( ) + " " ) ; } }
void printLBS ( int arr [ ] , int N ) { int lis [ ] = new int [ N ] ; int lds [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { lis [ i ] = lds [ i ] = 1 ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { if ( lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } } for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = N - 1 ; j > i ; j -- ) { if ( arr [ j ] < arr [ i ] ) { if ( lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; } } } int MaxVal = arr [ 0 ] , inx = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( MaxVal < lis [ i ] + lds [ i ] - 1 ) { MaxVal = lis [ i ] + lds [ i ] - 1 ; inx = i ; } } int ct1 = lis [ inx ] ; Vector < Integer > res = new Vector < Integer > ( ) ; for ( int i = inx ; i >= 0 && ct1 > 0 ; i -- ) { if ( lis [ i ] == ct1 ) { res . add ( arr [ i ] ) ; ct1 -- ; } } Collections . reverse ( res ) ; int ct2 = lds [ inx ] - 1 ; for ( int i = inx ; i < N && ct2 > 0 ; i ++ ) { if ( lds [ i ] == ct2 ) { res . add ( arr [ i ] ) ; ct2 -- ; } } printRes ( res ) ; }
void dfs ( int current_node , int prev_node , int len , boolean add_to_map , Vector < Integer > [ ] adj ) { if ( len > diameter ) { diameter = len ; X = current_node ; } if ( add_to_map && len == diameter ) { mp . put ( current_node , true ) ; } for ( int it : adj [ current_node ] ) { if ( it != prev_node ) dfs ( it , current_node , len + 1 , add_to_map , adj ) ; } }
void dfsUtility ( Vector < Integer > [ ] adj ) { dfs ( 1 , - 1 , 0 , false , adj ) ; int farthest_node = X ; dfs ( farthest_node , - 1 , 0 , false , adj ) ; dfs ( farthest_node , - 1 , 0 , true , adj ) ; dfs ( X , - 1 , 0 , true , adj ) ; }
void printDiameters ( Vector < Integer > [ ] adj ) { dfsUtility ( adj ) ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( mp . containsKey ( i ) && mp . get ( i ) == true ) System . out . print ( diameter + 1 + ", " ) ; else System . out . print ( diameter + ", " ) ; } }
boolean is_prime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
int count_prime_subarrays ( int ar [ ] , int n ) { int ans = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( is_prime ( ar [ i ] ) ) count ++ ; else { if ( count != 0 ) { ans += count * ( count + 1 ) / 2 ; count = 0 ; } } } if ( count != 0 ) ans += count * ( count + 1 ) / 2 ; return ans ; }
boolean hasCoprimePair ( int [ ] arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( __gcd ( arr [ i ] , arr [ j ] ) ) == 1 ) { return true ; } } } return false ; }
boolean check ( String ans , String [ ] s , int n , int m ) { for ( int i = 1 ; i < n ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < m ; ++ j ) { if ( ans . charAt ( j ) != s [ i ] . charAt ( j ) ) count ++ ; } if ( count > 1 ) return false ; } return true ; }
boolean possible ( int T , int arr [ ] , int n , int d ) { int partition = 1 ; int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total = total + arr [ i ] ; if ( total > T ) { partition = partition + 1 ; total = arr [ i ] ; if ( partition > d ) { return false ; } } } return true ; }
void calcT ( int n , int d , int arr [ ] ) { int mx = - 1 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mx = Math . max ( mx , arr [ i ] ) ; sum = sum + arr [ i ] ; } int lb = mx ; int ub = sum ; while ( lb < ub ) { int T_mid = lb + ( ub - lb ) / 2 ; if ( possible ( T_mid , arr , n , d ) == true ) { ub = T_mid ; } else { lb = T_mid + 1 ; } } System . out . println ( lb ) ; }
int minReqSubstring ( String s , int n ) { char ongoing = 'N' ; int count = 0 , l = s . length ( ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( ongoing == 'N' ) { if ( s . charAt ( i ) < s . charAt ( i - 1 ) ) { ongoing = 'D' ; } else if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) { ongoing = 'N' ; } else { ongoing = 'I' ; } } else if ( ongoing == 'I' ) { if ( s . charAt ( i ) > s . charAt ( i - 1 ) ) { ongoing = 'I' ; } else if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) { ongoing = 'I' ; } else { ongoing = 'N' ; count += 1 ; } } else { if ( s . charAt ( i ) < s . charAt ( i - 1 ) ) { ongoing = 'D' ; } else if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) { ongoing = 'D' ; } else { ongoing = 'N' ; count += 1 ; } } } return count + 1 ; }
int findPermutation ( Set < Integer > arr , int N ) { int pos = arr . size ( ) + 1 ; if ( pos > N ) return 1 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( ! arr . contains ( i ) ) { if ( i % pos == 0 pos % i == 0 ) { arr . add ( i ) ; res += findPermutation ( arr , N ) ; arr . remove ( i ) ; } } } return res ; }
int minimum_required_operations ( int arr [ ] , int n , int k ) { int answer = 0 ; long mod = 1000000007 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + arr [ i + 1 ] > k ) { if ( arr [ i ] > k ) { answer += ( arr [ i ] - k ) ; arr [ i ] = k ; } answer += ( arr [ i ] + arr [ i + 1 ] ) - k ; arr [ i + 1 ] = ( k - arr [ i ] ) ; answer %= mod ; } } return answer ; }
int minSteps ( int arr [ ] , int n , int k ) { int i , cnt = 0 ; int flag ; if ( k == 1 ) flag = 0 ; else flag = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == flag ) { cnt ++ ; flag = ( flag + 1 ) % 2 ; } } return cnt ; }
void solve ( int arr [ ] , int n , int X , int Y ) { int diff = Y - X ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
int minSum ( int a [ ] , int n , int k ) { PriorityQueue < Integer > maxheap = new PriorityQueue < > ( ( one , two ) -> two - one ) ; for ( int i = 0 ; i < n ; i ++ ) maxheap . add ( a [ i ] ) ; while ( maxheap . size ( ) > 0 && k > 0 ) { int max_ele = maxheap . poll ( ) ; maxheap . add ( max_ele / 2 ) ; k -= 1 ; } int sum = 0 ; while ( maxheap . size ( ) > 0 ) sum += maxheap . poll ( ) ; return sum ; }
void determineWinner ( String str ) { int [ ] A = new int [ 10 ] ; int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { A [ ( int ) str . charAt ( i ) - 48 ] ++ ; } for ( int i = 0 ; i <= 9 ; i ++ ) { if ( i % 2 != 0 ) { sum1 = sum1 + A [ i ] ; } else { sum2 = sum2 + A [ i ] ; } } if ( sum1 == sum2 ) { System . out . print ( "-1" ) ; } else if ( sum1 > sum2 ) { System . out . print ( "Player 1" ) ; } else { System . out . print ( "Player 2" ) ; } }
void manipulateStrings ( String P , String Q ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < P . length ( ) ; i ++ ) { freq [ P . charAt ( i ) - 'a' ] ++ ; } for ( int i = 0 ; i < Q . length ( ) ; i ++ ) { freq [ Q . charAt ( i ) - 'a' ] -- ; } StringBuilder sb = new StringBuilder ( ) ; int pos = Q . charAt ( 0 ) - 'a' ; for ( int i = 0 ; i <= pos ; i ++ ) { while ( freq [ i ] > 0 ) { char c = ( char ) ( 'a' + i ) ; sb . append ( c ) ; freq [ i ] -- ; } } sb . append ( Q ) ; for ( int i = pos + 1 ; i < 26 ; i ++ ) { while ( freq [ i ] > 0 ) { char c = ( char ) ( 'a' + i ) ; sb . append ( c ) ; freq [ i ] -- ; } } System . out . println ( sb ) ; }
int deleted ( int seg [ ] , int l , int r , int start , int end , int current ) { if ( end < l start > r ) return 0 ; if ( start >= l && end <= r ) return seg [ current ] ; int mid = ( start + end ) / 2 ; return deleted ( seg , l , r , start , mid , 2 * current + 1 ) + deleted ( seg , l , r , mid + 1 , end , 2 * current + 2 ) ; }
boolean deleteNode ( int nodeVal ) { return mp . containsKey ( nodeVal ) ; }
void printInorderTree ( Node root ) { if ( root == null ) return ; printInorderTree ( root . left ) ; System . out . print ( root . key + " " ) ; printInorderTree ( root . right ) ; }
void sieve ( ) { prime [ 0 ] = prime [ 1 ] = false ; for ( int i = 2 ; i < 100005 ; i ++ ) prime [ i ] = true ; for ( int i = 2 ; i * i < 100005 ; i ++ ) { if ( prime [ i ] ) { for ( int j = i * i ; j < 100005 ; j += i ) { prime [ j ] = false ; } } } }
void smallestPrimeFactors ( ) { for ( int i = 0 ; i < 100005 ; i ++ ) spf [ i ] = - 1 ; for ( int i = 2 ; i * i < 100005 ; i ++ ) { for ( int j = i ; j < 100005 ; j += i ) { if ( spf [ j ] == - 1 ) { spf [ j ] = i ; } } } }
int sumOfPrimeFactors ( int n ) { int ans = 0 ; while ( n > 1 ) { ans += spf [ n ] ; n /= spf [ n ] ; } return ans ; }
int findLength ( int n ) { if ( prime [ n ] ) { return 1 ; } if ( dp [ n ] != 0 ) { return dp [ n ] ; } int sum = sumOfPrimeFactors ( n ) ; return dp [ n ] = 1 + findLength ( sum ) ; }
void solve ( int n , int arr [ ] ) { int i , ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { int left = Math . max ( i - 1 , 0 ) ; int right = Math . min ( n - 1 , i + 1 ) ; while ( left >= 0 ) { if ( arr [ left ] > arr [ i ] ) { left ++ ; break ; } left -- ; } if ( left < 0 ) left ++ ; while ( right < n ) { if ( arr [ right ] > arr [ i ] ) { right -- ; break ; } right ++ ; } if ( right >= n ) right -- ; ans = 1 + right - left ; System . out . print ( ans + " " ) ; } }
int countofPairs ( int [ ] a ) { int n = a . length ; int [ ] freq = new int [ n + 1 ] ; int maxi = - 1 ; int mini = n + 1 ; for ( int i = 0 ; i < n ; i ++ ) { maxi = Math . max ( maxi , a [ i ] ) ; mini = Math . min ( mini , a [ i ] ) ; } for ( int i = 0 ; i < n ; ++ i ) freq [ a [ i ] ] ++ ; return maxCount ( freq , maxi , mini ) ; }
int largest_subarray ( int a [ ] , int n ) { HashMap < Integer , Integer > index = new HashMap < Integer , Integer > ( ) ; int ans = 0 ; for ( int i = 0 , j = 0 ; i < n ; i ++ ) { j = Math . max ( index . containsKey ( a [ i ] ) ? index . get ( a [ i ] ) : 0 , j ) ; ans = Math . max ( ans , i - j + 1 ) ; index . put ( a [ i ] , i + 1 ) ; } return ans ; }
int getMaxSum ( int a [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ 2 ] ; dp [ 0 ] [ 0 ] = a [ 0 ] ; dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 0 ] ; int max_sum = Math . max ( dp [ 0 ] [ 0 ] , dp [ 0 ] [ 1 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( a [ i ] , dp [ i - 1 ] [ 0 ] + a [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 1 ] + a [ i ] , a [ i ] * a [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 0 ] + a [ i ] * a [ i ] ) ; max_sum = Math . max ( max_sum , dp [ i ] [ 1 ] ) ; max_sum = Math . max ( max_sum , dp [ i ] [ 0 ] ) ; } return max_sum ; }
int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; }
int MaxUtil ( int [ ] st , int ss , int se , int l , int r , int node ) { if ( l <= ss && r >= se ) return st [ node ] ; if ( se < l ss > r ) return - 1 ; int mid = getMid ( ss , se ) ; return Math . max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) ; }
int constructSTUtil ( int arr [ ] , int ss , int se , int [ ] st , int si ) { if ( ss == se ) { st [ si ] = arr [ ss ] ; return arr [ ss ] ; } int mid = getMid ( ss , se ) ; st [ si ] = Math . max ( constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ) ; return st [ si ] ; }
int [ ] findPrevious ( int [ ] a , int n ) { int ps [ ] = new int [ n ] ; ps [ 0 ] = - 1 ; Stack < Integer > stack = new Stack < > ( ) ; stack . push ( 0 ) ; for ( int i = 1 ; i < a . length ; i ++ ) { while ( stack . size ( ) > 0 && a [ stack . peek ( ) ] >= a [ i ] ) stack . pop ( ) ; ps [ i ] = stack . size ( ) > 0 ? stack . peek ( ) : - 1 ; stack . push ( i ) ; } return ps ; }
int [ ] findNext ( int [ ] a , int n ) { int ns [ ] = new int [ n ] ; ns [ n - 1 ] = n ; Stack < Integer > stack = new Stack < > ( ) ; stack . push ( n - 1 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { while ( stack . size ( ) > 0 && a [ stack . peek ( ) ] >= a [ i ] ) stack . pop ( ) ; ns [ i ] = stack . size ( ) > 0 ? stack . peek ( ) : a . length ; stack . push ( i ) ; } return ns ; }
int findMaximumSum ( int [ ] a , int n ) { int prev_smaller [ ] = findPrevious ( a , n ) ; int next_smaller [ ] = findNext ( a , n ) ; int max_value = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_value = Math . max ( max_value , a [ i ] * ( next_smaller [ i ] - prev_smaller [ i ] - 1 ) ) ; } return max_value ; }
int findCount ( int arr [ ] , int n ) { int [ ] prefix_sum = new int [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; int [ ] suffix_sum = new int [ n ] ; suffix_sum [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffix_sum [ i ] = suffix_sum [ i + 1 ] + arr [ i ] ; int s = 1 , e = 1 ; int curr_subarray_sum = 0 , count = 0 ; while ( s < n - 1 && e < n - 1 ) { while ( e < n - 1 && curr_subarray_sum < prefix_sum [ s - 1 ] ) { curr_subarray_sum += arr [ e ++ ] ; } if ( curr_subarray_sum <= suffix_sum [ e ] ) { count ++ ; } curr_subarray_sum -= arr [ s ++ ] ; } return count ; }
int minOperation ( String s , int n ) { int ans = 0 ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( s . charAt ( i ) == '0' && s . charAt ( j ) == '1' ) { ans ++ ; i ++ ; j -- ; continue ; } if ( s . charAt ( i ) == '1' ) { i ++ ; } if ( s . charAt ( j ) == '0' ) { j -- ; } } return ans ; }
void solve ( int n ) { int ans = 0 ; for ( int y = n + 1 ; y <= n * n + n ; y ++ ) { if ( ( n * n ) % ( y - n ) == 0 ) { ans += 1 ; } } System . out . print ( ans ) ; }
int power ( int x , int y , int mod ) { int res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
void count ( int N ) { if ( N == 1 ) { System . out . println ( 10 ) ; return ; } System . out . println ( power ( 9 , N , 1000000007 ) ) ; }
boolean possible ( long mid , int [ ] a ) { long n = a . length ; long total = ( n * ( n - 1 ) ) / 2 ; long need = ( total + 1 ) / 2 ; long count = 0 ; long start = 0 , end = 1 ; while ( end < n ) { if ( a [ ( int ) end ] - a [ ( int ) start ] <= mid ) { end ++ ; } else { count += ( end - start - 1 ) ; start ++ ; } } if ( end == n && start < end && a [ ( int ) end - 1 ] - a [ ( int ) start ] <= mid ) { long t = end - start - 1 ; count += ( t * ( t + 1 ) / 2 ) ; } if ( count >= need ) return true ; else return false ; }
long findMedian ( int [ ] a ) { long n = a . length ; long low = 0 , high = a [ ( int ) n - 1 ] - a [ 0 ] ; while ( low <= high ) { long mid = ( low + high ) / 2 ; if ( possible ( mid , a ) ) high = mid - 1 ; else low = mid + 1 ; } return high + 1 ; }
int computeDistance ( Node root , int value ) { if ( root == null ) { return - 1 ; } int left = computeDistance ( root . left , value ) ; int right = computeDistance ( root . right , value ) ; if ( left == - 1 && right == - 1 ) { if ( root . key == value ) { return 1 ; } else return - 1 ; } if ( left == - 1 ) { return right + 1 ; } if ( right == - 1 ) { return left + 1 ; } else { return 1 + Math . max ( left , right ) ; } }
void dfs ( int node , int count , int m , int arr [ ] , int k ) { visited [ node ] = 1 ; if ( arr [ node - 1 ] == k ) { count ++ ; } else { count = 0 ; } if ( count > m ) { return ; } if ( adj [ node ] . size ( ) == 1 && node != 1 ) { ans ++ ; } for ( int x : adj [ node ] ) { if ( visited [ x ] == 0 ) { dfs ( x , count , m , arr , k ) ; } } }
int find ( int [ ] parent , int x ) { if ( parent [ x ] == x ) return x ; parent [ x ] = find ( parent , parent [ x ] ) ; return parent [ x ] ; }
void setUnion ( int [ ] parent , int [ ] rank , int x , int y ) { int parentx = find ( parent , x ) ; int parenty = find ( parent , y ) ; if ( parenty == parentx ) return ; ctr -- ; if ( rank [ parentx ] < rank [ parenty ] ) { parent [ parentx ] = parenty ; } else if ( rank [ parentx ] > rank [ parenty ] ) { parent [ parenty ] = parentx ; } else { parent [ parentx ] = parenty ; rank [ parenty ] ++ ; } }
int [ ] solve ( int n , int m , int [ ] [ ] query ) { int [ ] result = new int [ query . length ] ; int [ ] parent = new int [ n * m ] ; for ( int i = 0 ; i < n * m ; i ++ ) parent [ i ] = i ; int [ ] rank = new int [ n * m ] ; Arrays . fill ( rank , 1 ) ; boolean [ ] grid = new boolean [ n * m ] ; for ( int i = 0 ; i < query . length ; i ++ ) { int x = query [ i ] [ 0 ] ; int y = query [ i ] [ 1 ] ; if ( grid [ m * x + y ] == true ) { result [ i ] = ctr ; continue ; } grid [ m * x + y ] = true ; ctr ++ ; if ( x > 0 && grid [ m * ( x - 1 ) + y ] == true ) setUnion ( parent , rank , m * x + y , m * ( x - 1 ) + y ) ; if ( y > 0 && grid [ m * ( x ) + y - 1 ] == true ) setUnion ( parent , rank , m * x + y , m * ( x ) + y - 1 ) ; if ( x < n - 1 && grid [ m * ( x + 1 ) + y ] == true ) setUnion ( parent , rank , m * x + y , m * ( x + 1 ) + y ) ; if ( y < m - 1 && grid [ m * ( x ) + y + 1 ] == true ) setUnion ( parent , rank , m * x + y , m * ( x ) + y + 1 ) ; result [ i ] = ctr ; } return result ; }
void FindMinimumDistance ( ) { Queue < pair > q = new LinkedList < > ( ) ; q . add ( new pair ( x , y ) ) ; mat [ x ] [ y ] = 0 ; while ( ! q . isEmpty ( ) ) { x = q . peek ( ) . first ; y = q . peek ( ) . second ; q . remove ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) { int a = x + dx [ i ] ; int b = y + dy [ i ] ; if ( a < 0 a >= r b >= c b < 0 ) continue ; if ( mat [ a ] [ b ] == 0 ) { mat [ a ] [ b ] = mat [ x ] [ y ] + 1 ; q . add ( new pair ( a , b ) ) ; } } } }
void make_set ( int v ) { parent [ v ] = v ; size_set [ v ] = 1 ; }
int find_set ( int v ) { if ( v == parent [ v ] ) return v ; return parent [ v ] = find_set ( parent [ v ] ) ; }
void union_set ( int a , int b ) { a = find_set ( a ) ; b = find_set ( b ) ; if ( a != b ) { if ( size_set [ a ] < size_set [ b ] ) { a = a + b ; b = a - b ; a = a - b ; } parent [ b ] = a ; size_set [ a ] += size_set [ b ] ; } }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < 100001 ; i ++ ) prime [ i ] = 1 ; int p = 2 ; while ( p * p <= 100000 ) { if ( prime [ p ] == 1 ) { for ( int i = p * p ; i < 100001 ; i += p ) prime [ i ] = 0 ; } p += 1 ; } }
void fibonacciOfPrime ( int n1 , int n2 ) { SieveOfEratosthenes ( ) ; Vector < Integer > initial = new Vector < > ( ) ; for ( int i = n1 ; i <= n2 ; i ++ ) if ( prime [ i ] == 1 ) initial . add ( i ) ; Vector < Integer > now = new Vector < > ( ) ; for ( int i = 0 ; i < initial . size ( ) ; i ++ ) { for ( int j = 0 ; j < initial . size ( ) ; j ++ ) { int a = ( int ) initial . get ( i ) ; int b = ( int ) initial . get ( j ) ; if ( a != b ) { int c = join ( a , b ) ; now . add ( c ) ; } } } Vector < Integer > current = new Vector < > ( ) ; for ( int i = 0 ; i < now . size ( ) ; i ++ ) if ( prime [ ( int ) now . get ( i ) ] == 1 ) current . add ( ( int ) now . get ( i ) ) ; int cnt [ ] = new int [ 1000009 ] ; for ( int i = 0 ; i < 1000001 ; i ++ ) cnt [ i ] = 0 ; Vector < Integer > current_set = new Vector < > ( ) ; for ( int i = 0 ; i < current . size ( ) ; i ++ ) { cnt [ ( int ) current . get ( i ) ] ++ ; if ( cnt [ ( int ) current . get ( i ) ] == 1 ) current_set . add ( ( int ) current . get ( i ) ) ; } long first = 1000000000 ; for ( int i = 0 ; i < current_set . size ( ) ; i ++ ) first = Math . min ( first , ( int ) current_set . get ( i ) ) ; long second = 0 ; for ( int i = 0 ; i < current_set . size ( ) ; i ++ ) second = Math . max ( second , ( int ) current_set . get ( i ) ) ; int count = current_set . size ( ) - 1 ; long curr = 1 ; long c = 0 ; while ( curr < count ) { c = first + second ; first = second ; second = c ; curr += 1 ; } System . out . println ( c ) ; }
long reverse ( long num ) { long rev = 0 ; while ( num > 0 ) { int r = ( int ) ( num % 10 ) ; rev = rev * 10 + r ; num /= 10 ; } return rev ; }
long count ( int N , int A , int B ) { long l = ( long ) Math . pow ( 10 , N - 1 ) , r = ( long ) Math . pow ( 10 , N ) - 1 ; if ( l == 1 ) l = 0 ; long ans = 0 ; for ( long i = l ; i <= r ; i ++ ) { int even_sum = 0 , odd_sum = 0 ; long itr = 0 , num = reverse ( i ) ; while ( num > 0 ) { if ( itr % 2 == 0 ) odd_sum += num % 10 ; else even_sum += num % 10 ; num /= 10 ; itr ++ ; } if ( even_sum % A == 0 && odd_sum % B == 0 ) ans ++ ; } return ans ; }
long count ( int N , int A , int B ) { if ( N == 1 ) { return 9 / B + 1 ; } int max_sum = 9 * N ; int odd_count = N / 2 + N % 2 ; int even_count = N - odd_count ; long dp [ ] [ ] = new long [ even_count ] [ max_sum + 1 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) dp [ 0 ] [ i % A ] ++ ; for ( int i = 1 ; i < even_count ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { for ( int k = 0 ; k <= max_sum ; k ++ ) { if ( dp [ i - 1 ] [ k ] > 0 ) dp [ i ] [ ( j + k ) % A ] += dp [ i - 1 ] [ k ] ; } } } long dp1 [ ] [ ] = new long [ odd_count ] [ max_sum + 1 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) dp1 [ 0 ] [ i % B ] ++ ; for ( int i = 1 ; i < odd_count ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { for ( int k = 0 ; k <= max_sum ; k ++ ) { if ( dp1 [ i - 1 ] [ k ] > 0 ) dp1 [ i ] [ ( j + k ) % B ] += dp1 [ i - 1 ] [ k ] ; } } } return dp [ even_count - 1 ] [ 0 ] * dp1 [ odd_count - 1 ] [ 0 ] ; }
int calc_distance ( int A [ ] , int B [ ] , int n ) { int distance_traveled_A = 0 ; int distance_traveled_B = 0 ; int answer = 0 ; for ( int i = 0 ; i < 5 ; i ++ ) { distance_traveled_A += A [ i ] ; distance_traveled_B += B [ i ] ; if ( ( distance_traveled_A == distance_traveled_B ) && ( A [ i ] == B [ i ] ) ) { answer += A [ i ] ; } } return answer ; }
int dfs ( int node , int A , int [ ] subtree_size , int [ ] visited , int [ ] check_subtree ) { visited [ node ] = 1 ; subtree_size [ node ] = 1 ; if ( node == A ) { check_subtree [ node ] = 1 ; } else check_subtree [ node ] = 0 ; for ( int v : G [ node ] ) { if ( visited [ v ] == 0 ) { subtree_size [ node ] += dfs ( v , A , subtree_size , visited , check_subtree ) ; check_subtree [ node ] = check_subtree [ node ] | check_subtree [ v ] ; } } return subtree_size [ node ] ; }
int numberOfPairs ( int N , int B , int A ) { int [ ] subtree_size = new int [ N + 1 ] ; int [ ] visited = new int [ N + 1 ] ; int [ ] check_subtree = new int [ N + 1 ] ; dfs ( B , A , subtree_size , visited , check_subtree ) ; int difference = 0 ; for ( int v : G [ B ] ) { if ( check_subtree [ v ] > 0 ) { difference = N - subtree_size [ v ] ; break ; } } return ( N * ( N - 1 ) ) - difference * ( subtree_size [ A ] ) ; }
int equalXORandOR ( int n ) { int m = 0 ; int MSB = ( int ) Math . log ( n ) ; for ( int i = 0 ; i <= MSB ; i ++ ) { if ( ( n & ( 1 << i ) ) <= 0 ) { m += ( 1 << i ) ; } } return m ; }
int findMinSoln ( int n , int k ) { int minSoln = Integer . MAX_VALUE ; for ( int i = 1 ; i < k ; i ++ ) { if ( n % i == 0 ) minSoln = Math . min ( minSoln , ( n / i ) * k + i ) ; } return minSoln ; }
int getSum ( int BITree [ ] , int index ) { int ans = 0 ; index += 1 ; while ( index > 0 ) { ans += BITree [ index ] ; index -= index & ( - index ) ; } return ans ; }
void updateBIT ( int BITree [ ] , int n , int index , int val ) { index = index + 1 ; while ( index <= n ) { BITree [ index ] += val ; index += index & ( - index ) ; } }
int getLowerBound ( int BITree [ ] , int [ ] arr , int n , int k ) { int lb = - 1 ; int l = 0 , r = n - 1 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( getSum ( BITree , mid ) >= k ) { r = mid - 1 ; lb = mid ; } else l = mid + 1 ; } return lb ; }
void dfs ( int [ ] val , int [ ] cost , Vector < Integer > [ ] tr , int u , int s ) { s = s + cost [ u ] ; if ( s < 0 ) s = 0 ; if ( s > val [ u ] ) return ; cnt ++ ; for ( int i = 0 ; i < tr [ u ] . size ( ) ; i ++ ) { dfs ( val , cost , tr , tr [ u ] . get ( i ) , s ) ; } }
void dfs1 ( int cur , int par ) { for ( int u : adj [ cur ] ) { if ( u != par ) { dfs1 ( u , cur ) ; height [ cur ] = Math . max ( height [ cur ] , height [ u ] ) ; } } height [ cur ] += 1 ; }
void dfs2 ( int cur , int par ) { int max1 = 0 ; int max2 = 0 ; for ( int u : adj [ cur ] ) { if ( u != par ) { if ( height [ u ] >= max1 ) { max2 = max1 ; max1 = height [ u ] ; } else if ( height [ u ] > max2 ) { max2 = height [ u ] ; } } } int sum = 0 ; for ( int u : adj [ cur ] ) { if ( u != par ) { sum = ( ( max1 == height [ u ] ) ? max2 : max1 ) ; if ( max1 == height [ u ] ) dist [ u ] = 1 + Math . max ( 1 + max2 , dist [ cur ] ) ; else dist [ u ] = 1 + Math . max ( 1 + max1 , dist [ cur ] ) ; dfs2 ( u , cur ) ; } } }
void displaySteppingNumbers ( int n , int m ) { for ( int i = n ; i <= m ; i ++ ) if ( isStepNum ( i ) ) System . out . print ( i + " " ) ; }
int BFS ( int [ ] [ ] mat , int row , int col ) { int area = 0 ; Queue < pair > Q = new LinkedList < > ( ) ; Q . add ( new pair ( row , col ) ) ; while ( ! Q . isEmpty ( ) ) { pair it = Q . peek ( ) ; Q . poll ( ) ; int r = it . first , c = it . second ; if ( r < 0 c < 0 r > 4 c > 4 ) continue ; if ( mat [ r ] == 0 ) continue ; if ( mat [ r ] == 1 ) { mat [ r ] = 0 ; area ++ ; } Q . add ( new pair ( r + 1 , c ) ) ; Q . add ( new pair ( r - 1 , c ) ) ; Q . add ( new pair ( r , c + 1 ) ) ; Q . add ( new pair ( r , c - 1 ) ) ; } return area ; }
void sizeOfConnections ( int [ ] [ ] mat ) { ArrayList < Integer > result = new ArrayList < > ( ) ; for ( int row = 0 ; row < 5 ; ++ row ) { for ( int col = 0 ; col < 5 ; ++ col ) { if ( mat [ row ] [ col ] == 1 ) { int area = BFS ( mat , row , col ) ; result . add ( area ) ; } } } for ( int val : result ) System . out . print ( val + " " ) ; }
void DFS ( List < List < Integer > > adjl , int [ ] parent , int u , int p ) { parent [ u ] = p ; for ( int v : adjl . get ( u ) ) { if ( v != p ) { DFS ( adjl , parent , v , u ) ; } } }
int [ ] valuesFromChildren ( int [ ] parent , int [ ] values ) { int [ ] valuesChildren = new int [ parent . length ] ; for ( int i = 0 ; i < parent . length ; i ++ ) { if ( parent [ i ] == - 1 ) continue ; else { int p = parent [ i ] ; valuesChildren [ p ] += values [ i ] ; } } return valuesChildren ; }
void maxProduct ( int arr [ ] , int N ) { if ( N < 3 ) { return ; } int a = arr [ 0 ] , b = arr [ 1 ] ; int c = 0 , d = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N - 1 ; j ++ ) { if ( arr [ i ] * arr [ j ] > a * b ) { c = a ; d = b ; a = arr [ i ] ; b = arr [ j ] ; } if ( arr [ i ] * arr [ j ] < a * b && arr [ i ] * arr [ j ] > c * d ) c = arr [ i ] ; d = arr [ j ] ; } System . out . println ( c + " " + d ) ; }
void maxProduct ( int arr [ ] , int N ) { if ( N < 3 ) { return ; } Arrays . sort ( arr ) ; int smallest1 = arr [ 0 ] ; int smallest3 = arr [ 2 ] ; int largest1 = arr [ N - 1 ] ; int largest3 = arr [ N - 3 ] ; if ( smallest1 * smallest3 >= largest1 * largest3 ) { System . out . print ( smallest1 + " " + smallest3 ) ; } else { System . out . print ( largest1 + " " + largest3 ) ; } }
int maxLen ( int A [ ] , int N ) { List < List < Integer > > v = new ArrayList < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 1 ) { int s = i , len ; while ( i < N && A [ i ] == 1 ) { i ++ ; } len = i - s ; v . add ( Arrays . asList ( len , s , i - 1 ) ) ; } } if ( v . size ( ) == 0 ) { return - 1 ; } int ans = 0 ; for ( int i = 0 ; i < v . size ( ) - 1 ; i ++ ) { ans = Math . max ( ans , v . get ( i ) . get ( 0 ) ) ; if ( v . get ( i + 1 ) . get ( 1 ) - v . get ( i ) . get ( 2 ) - 1 == 2 ) { ans = Math . max ( ans , v . get ( i ) . get ( 0 ) + v . get ( i + 1 ) . get ( 0 ) ) ; } if ( v . get ( i + 1 ) . get ( 1 ) - v . get ( i ) . get ( 2 ) - 1 == 1 ) { ans = Math . max ( ans , v . get ( i ) . get ( 0 ) + v . get ( i + 1 ) . get ( 0 ) - 1 ) ; } } ans = Math . max ( v . get ( v . size ( ) - 1 ) . get ( 0 ) , ans ) ; return ans ; }
void maxLengthOf1s ( int arr [ ] , int n ) { int prefix [ ] = new int [ n ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i - 2 ] == 1 ) prefix [ i ] = prefix [ i - 1 ] + 1 ; else prefix [ i ] = 0 ; } int suffix [ ] = new int [ n ] ; for ( int i = n - 3 ; i >= 0 ; i -- ) { if ( arr [ i + 2 ] == 1 ) suffix [ i ] = suffix [ i + 1 ] + 1 ; else suffix [ i ] = 0 ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans = Math . max ( ans , prefix [ i + 1 ] + suffix [ i ] ) ; } System . out . println ( ans ) ; }
void dfs ( int u ) { visited [ u ] = 1 ; for ( Integer it : adj . get ( u ) ) { if ( visited [ it ] == 0 ) dfs ( it ) ; } s . push ( u ) ; }
boolean check_cycle ( ) { Map < Integer , Integer > pos = new HashMap < > ( ) ; int ind = 0 ; while ( ! s . isEmpty ( ) ) { pos . put ( s . peek ( ) , ind ) ; tsort . add ( s . peek ( ) ) ; ind += 1 ; s . pop ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( Integer it : adj . get ( i ) ) { if ( pos . get ( i ) > pos . get ( it ) ) { return true ; } } } return false ; }
void addEdge ( int u , int v ) { adj . get ( u ) . add ( v ) ; }
void printNewArray ( List < Integer > a , int n ) { List < pair > v = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { v . add ( new pair ( a . get ( i ) , i ) ) ; } Collections . sort ( v , ( pair s1 , pair s2 ) -> { return s1 . first - s2 . first ; } ) ; int ans [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ans [ v . get ( ( i + 1 ) % n ) . second ] = v . get ( i ) . first ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + " " ) ; } }
void bfs ( int n , int m , int num ) { Queue < Integer > q = new LinkedList < Integer > ( ) ; q . add ( num ) ; while ( ! q . isEmpty ( ) ) { int stepNum = q . poll ( ) ; if ( stepNum <= m && stepNum >= n ) { System . out . print ( stepNum + " " ) ; } if ( stepNum == 0 stepNum > m ) continue ; int lastDigit = stepNum % 10 ; int stepNumA = stepNum * 10 + ( lastDigit - 1 ) ; int stepNumB = stepNum * 10 + ( lastDigit + 1 ) ; if ( lastDigit == 0 ) q . add ( stepNumB ) ; else if ( lastDigit == 9 ) q . add ( stepNumA ) ; else { q . add ( stepNumA ) ; q . add ( stepNumB ) ; } } }
void displaySteppingNumbers ( int n , int m ) { for ( int i = 0 ; i <= 9 ; i ++ ) bfs ( n , m , i ) ; }
void solve ( int arr [ ] , int n ) { int countzeroes = 0 ; int countones = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) countzeroes ++ ; else countones ++ ; } if ( Math . abs ( countzeroes - countones ) == 1 ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
char bs ( char ar [ ] , int n , int ele ) { int start = 0 ; int end = n - 1 ; char ch = '@' ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( ar [ mid ] == ele ) end = mid - 1 ; else if ( ar [ mid ] < ele ) { ch = ar [ mid ] ; start = mid + 1 ; } else end = mid - 1 ; } return ch ; }
void countPairs ( int N , int [ ] arr ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) { count ++ ; } } System . out . println ( count / 2 ) ; }
int findMaxLen ( int [ ] a , int k ) { int n = a . length ; Arrays . sort ( a ) ; boolean [ ] vis = new boolean [ n ] ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp . put ( a [ i ] , i ) ; } int c = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( vis [ i ] == false ) { int check = a [ i ] * k ; if ( mp . containsKey ( check ) ) { c ++ ; vis [ mp . get ( check ) ] = true ; } } } return n - c ; }
boolean isVowel ( char c ) { if ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) return true ; return false ; }
void countSubstrings ( String s , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( isVowel ( s . charAt ( j ) ) ) { count ++ ; } if ( count % 2 == 0 ) result ++ ; } } System . out . println ( result ) ; }
void addEdge ( int u , int v ) { adj [ u ] . add ( v ) ; adj [ v ] . add ( u ) ; }
int minimumCost ( int V , int cost [ ] ) { boolean [ ] vis = new boolean [ V + 1 ] ; Arrays . fill ( vis , false ) ; int min_cost = 0 ; for ( int i = 1 ; i <= V ; i ++ ) { if ( ! vis [ i ] ) { min_cost_node = Integer . MAX_VALUE ; dfs ( i , cost , vis ) ; min_cost += min_cost_node ; } } return min_cost ; }
boolean check ( char [ ] str , int mid , char a ) { int n = str . length ; int previous = - 1 , i ; for ( i = 0 ; i < n ; ++ i ) { if ( str [ i ] == a ) { if ( i - previous > mid ) { return false ; } previous = i ; } } if ( i - previous > mid ) return false ; else return true ; }
boolean possible ( char [ ] str , int mid ) { for ( int i = 0 ; i < 26 ; ++ i ) { if ( check ( str , mid , ( char ) ( i + 'a' ) ) ) return true ; } return false ; }
int findMinLength ( char [ ] str ) { int low = 1 , high = str . length ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( possible ( str , mid ) ) high = mid - 1 ; else low = mid + 1 ; } return high + 1 ; }
int solve ( int A [ ] , int N ) { int i = 0 ; int k = 0 ; for ( int j = 1 ; j < N ; j ++ ) { int tempK = Math . min ( A [ i ] , A [ j ] ) / ( j - i ) ; if ( tempK > k ) { k = tempK ; } if ( A [ j ] >= A [ i ] / ( j - i ) ) i = j ; } return k ; }
boolean possible ( int arr [ ] , int N , int mid , int K ) { int add = 0 ; for ( int i = N / 2 - ( N + 1 ) % 2 ; i < N ; ++ i ) { if ( mid - arr [ i ] > 0 ) { add += ( mid - arr [ i ] ) ; if ( add > K ) return false ; } } if ( add <= K ) return true ; else return false ; }
int findMaxMedian ( int arr [ ] , int N , int K ) { int low = 1 ; int mx = 0 ; for ( int i = 0 ; i < N ; ++ i ) { mx = Math . max ( mx , arr [ i ] ) ; } int high = K + mx ; while ( low <= high ) { int mid = ( high + low ) / 2 ; if ( possible ( arr , N , mid , K ) ) { low = mid + 1 ; } else { high = mid - 1 ; } } if ( N % 2 == 0 ) { if ( low - 1 < arr [ N / 2 ] ) { return ( arr [ N / 2 ] + low - 1 ) / 2 ; } } return low - 1 ; }
void split ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] == 1 ) { count = 2 ; break ; } } System . out . print ( count ) ; }
boolean check ( String str1 , String str2 ) { boolean [ ] mark = new boolean [ 26 ] ; Arrays . fill ( mark , false ) ; int n = str1 . length ( ) , m = str2 . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mark [ str1 . charAt ( i ) - 'a' ] = true ; } for ( int i = 0 ; i < m ; i ++ ) { if ( mark [ str2 . charAt ( i ) - 'a' ] ) return true ; } return false ; }
boolean countLessThanMid ( int mid , int N , int M , int K ) { int count = 0 ; for ( int i = 1 ; i <= Math . min ( N , mid ) ; ++ i ) { count = count + Math . min ( mid / i , M ) ; } if ( count >= K ) return false ; else return true ; }
int findKthElement ( int N , int M , int K ) { int low = 1 , high = N * M ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( countLessThanMid ( mid , N , M , K ) ) low = mid + 1 ; else high = mid - 1 ; } return high + 1 ; }
int PermuteTheArray ( int A [ ] , int n ) { int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ A [ i ] - 1 ] = i ; } int mini = n , maxi = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mini = Math . min ( mini , arr [ i ] ) ; maxi = Math . max ( maxi , arr [ i ] ) ; if ( maxi - mini == i ) count ++ ; } return count ; }
int [ ] findLargest ( int beg , int end , int [ ] arr , int n ) { if ( beg == end ) { int [ ] compared = new int [ n ] ; compared [ 0 ] = 1 ; compared [ 1 ] = arr [ beg ] ; return compared ; } int [ ] compared1 = findLargest ( beg , ( beg + end ) / 2 , arr , n ) ; int [ ] compared2 = findLargest ( ( beg + end ) / 2 + 1 , end , arr , n ) ; if ( compared1 [ 1 ] > compared2 [ 1 ] ) { int k = compared1 [ 0 ] + 1 ; compared1 [ 0 ] = k ; compared1 [ k ] = compared2 [ 1 ] ; return compared1 ; } else { int k = compared2 [ 0 ] + 1 ; compared2 [ 0 ] = k ; compared2 [ k ] = compared1 [ 1 ] ; return compared2 ; } }
void findSecondLargest ( int end , int [ ] arr ) { int [ ] compared1 = findLargest ( 0 , end - 1 , arr , end ) ; int [ ] compared2 = findLargest ( 2 , compared1 [ 0 ] + 2 , compared1 , compared1 [ 0 ] ) ; System . out . print ( compared2 [ 1 ] ) ; }
int CountsubString ( char [ ] str , int n ) { int c = 0 ; for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; char temp = str [ i ] , f = 0 ; if ( j == i ) { c ++ ; continue ; } int k = i + 1 ; while ( temp > str [ k ] && k <= j ) { temp = str [ k ] ; k ++ ; } if ( k > j ) { c ++ ; f = 2 ; } while ( k <= j && temp < str [ k ] && f != 2 ) { temp = str [ k ] ; k ++ ; } if ( k > j && f != 2 ) { c ++ ; f = 0 ; } } } return c ; }
void countSubString ( String S , char C ) { int count = 0 ; int conCount = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { char ch = S . charAt ( i ) ; if ( ch == C ) conCount ++ ; else { count += ( conCount * ( conCount + 1 ) ) / 2 ; conCount = 0 ; } } count += ( conCount * ( conCount + 1 ) ) / 2 ; System . out . println ( count ) ; }
void checkPalindrome ( String S ) { int N = S . length ( ) ; boolean first_half = true ; boolean second_half = true ; int cnt = ( N / 2 ) - 1 ; for ( int i = 0 ; i < ( N / 2 ) ; i ++ ) { if ( S . charAt ( i ) != S . charAt ( cnt ) ) { first_half = false ; break ; } if ( S . charAt ( N / 2 + i ) != S . charAt ( N / 2 + cnt ) ) { second_half = false ; break ; } cnt -- ; } if ( first_half && second_half ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } }
boolean isSubsetSum ( int arr [ ] , int n , int sum ) { boolean [ ] [ ] subset = new boolean [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < arr [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= arr [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } return subset [ n ] [ sum ] ; }
int findSum ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int val = ( int ) Math . sqrt ( sum ) ; for ( int i = val ; i >= 0 ; i -- ) { if ( isSubsetSum ( arr , n , i * i ) ) { return i * i ; } } return 0 ; }
int findsubArray ( int arr [ ] , int N , int K ) { int res = N + 1 ; for ( int i = 0 ; i < N ; i ++ ) { int curr_prod = 1 ; for ( int j = i ; j < N ; j ++ ) { curr_prod = curr_prod * arr [ j ] ; if ( curr_prod % N == K && res > ( j - i + 1 ) ) { res = Math . min ( res , j - i + 1 ) ; break ; } } } return ( res == N + 1 ) ? 0 : res ; }
void check ( int arr [ ] [ ] ) { int f = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! checkBitonic ( arr [ i ] , M ) ) { System . out . println ( "NO" ) ; return ; } } for ( int i = 0 ; i < N ; i ++ ) { int temp [ ] = new int [ N ] ; for ( int j = 0 ; j < N ; j ++ ) { temp [ j ] = arr [ j ] [ i ] ; } if ( ! checkBitonic ( temp , N ) ) { System . out . println ( "NO" ) ; return ; } } System . out . println ( "YES" ) ; }
int getMaxGcd ( int N ) { int maxGcd = Integer . MIN_VALUE , A , B ; for ( int i = 1 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { A = i ; B = N / i ; maxGcd = Math . max ( maxGcd , gcd ( A , B ) ) ; } } return maxGcd ; }
boolean can_place ( int A [ ] , int n , int B , int mid ) { int count = 1 ; int last_position = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] - last_position >= mid ) { last_position = A [ i ] ; count ++ ; if ( count == B ) { return true ; } } } return false ; }
int find_min_difference ( int A [ ] , int n , int B ) { Arrays . sort ( A ) ; int s = 0 ; int e = A [ n - 1 ] - A [ 0 ] ; int ans = 0 ; while ( s <= e ) { int mid = ( s + e ) / 2 ; if ( can_place ( A , n , B , mid ) ) { ans = mid ; s = mid + 1 ; } else { e = mid - 1 ; } } return ans ; }
void UniversalSubset ( List < String > A , List < String > B ) { int n1 = A . size ( ) ; int n2 = B . size ( ) ; List < String > res = new ArrayList < > ( ) ; int [ ] [ ] A_fre = new int [ n1 ] [ 26 ] ; for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) A_fre [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < A . get ( i ) . length ( ) ; j ++ ) { A_fre [ i ] [ A . get ( i ) . charAt ( j ) - 'a' ] ++ ; } } int [ ] B_fre = new int [ 26 ] ; for ( int i = 0 ; i < n2 ; i ++ ) { int [ ] arr = new int [ 26 ] ; for ( int j = 0 ; j < B . get ( i ) . length ( ) ; j ++ ) { arr [ B . get ( i ) . charAt ( j ) - 'a' ] ++ ; B_fre [ B . get ( i ) . charAt ( j ) - 'a' ] = Math . max ( B_fre [ B . get ( i ) . charAt ( j ) - 'a' ] , arr [ B . get ( i ) . charAt ( j ) - 'a' ] ) ; } } for ( int i = 0 ; i < n1 ; i ++ ) { int flag = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( A_fre [ i ] [ j ] < B_fre [ j ] ) { flag = 1 ; break ; } } if ( flag == 0 ) res . add ( A . get ( i ) ) ; } if ( res . size ( ) != 0 ) { for ( int i = 0 ; i < res . size ( ) ; i ++ ) { for ( int j = 0 ; j < res . get ( i ) . length ( ) ; j ++ ) System . out . print ( res . get ( i ) . charAt ( j ) ) ; } System . out . print ( " " ) ; } else System . out . print ( "-1" ) ; }
int countTriplets ( int A [ ] , int N ) { int ans = 0 ; HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int j = N - 2 ; j >= 1 ; j -- ) { if ( map . containsKey ( A [ j + 1 ] ) ) map . put ( A [ j + 1 ] , map . get ( A [ j + 1 ] ) + 1 ) ; else map . put ( A [ j + 1 ] , 1 ) ; for ( int i = 0 ; i < j ; i ++ ) { int target = A [ i ] * A [ j ] ; if ( map . containsKey ( target ) ) ans += map . get ( target ) ; } } return ans ; }
int minDistance ( int a [ ] , int n ) { int max = - 1 , min = Integer . MAX_VALUE ; int min_index = - 1 , max_index = - 1 ; int min_dist = n + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max ) max = a [ i ] ; if ( a [ i ] < min ) min = a [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == min ) min_index = i ; if ( a [ i ] == max ) max_index = i ; if ( min_index != - 1 && max_index != - 1 ) min_dist = Math . min ( min_dist , Math . abs ( min_index - max_index ) ) ; } return min_dist ; }
int sign ( int x ) { if ( x > 0 ) return 1 ; else return - 1 ; }
int findMaxSum ( int arr [ ] , int size ) { int max_sum = 0 , pres , i , j ; for ( i = 0 ; i < size ; i ++ ) { pres = arr [ i ] ; j = i ; while ( j < size && sign ( arr [ i ] ) == sign ( arr [ j ] ) ) { pres = Math . max ( pres , arr [ j ] ) ; j ++ ; } max_sum = max_sum + pres ; i = j - 1 ; } return max_sum ; }
boolean groupInKConsecutive ( int [ ] arr , int K ) { HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ; for ( int h : arr ) { if ( count . containsKey ( h ) ) count . put ( h , count . get ( h ) + 1 ) ; else count . put ( h , 1 ) ; } for ( Map . Entry < Integer , Integer > c : count . entrySet ( ) ) { int cur = c . getKey ( ) ; int n = c . getValue ( ) ; if ( n > 0 ) { for ( int i = 1 ; i < K ; ++ i ) { if ( ! count . containsKey ( cur + i ) ) { return false ; } count . put ( cur + i , count . get ( cur + i ) - n ) ; if ( count . get ( cur + i ) < 0 ) return false ; } } } return true ; }
boolean checkrules ( String s ) { if ( s . length ( ) == 0 ) return true ; if ( s . charAt ( 0 ) != '1' ) return false ; if ( s . length ( ) > 2 ) { if ( s . charAt ( 1 ) == '0' && s . charAt ( 2 ) == '0' ) return checkrules ( s . substring ( 3 ) ) ; } return checkrules ( s . substring ( 1 ) ) ; }
int countSubAllOnes ( String s ) { int l = 0 , r = 0 , ans = 0 ; while ( l <= r ) { if ( r == s . length ( ) ) { ans += ( ( r - l ) * ( r - l + 1 ) ) / 2 ; break ; } if ( s . charAt ( r ) == '1' ) r ++ ; else { ans += ( ( r - l ) * ( r - l + 1 ) ) / 2 ; l = r + 1 ; r ++ ; } } return ans ; }
int countOfPrimes ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( isPrime ( i ) ) { if ( sumSquare ( i ) ) count ++ ; } } return count ; }
int Maxlen ( int arr [ ] , int n ) { int ans = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count = 0 ; else count ++ ; ans = Math . max ( ans , count ) ; } return ans ; }
void findPair ( int a [ ] , int n ) { int min_dist = Integer . MAX_VALUE ; int index_a = - 1 , index_b = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( j - i < min_dist ) { if ( a [ i ] % a [ j ] == 0 a [ j ] % a [ i ] == 0 ) { min_dist = j - i ; index_a = i ; index_b = j ; } } } } if ( index_a == - 1 ) { System . out . println ( "-1" ) ; } else { System . out . print ( "(" + a [ index_a ] + ", " + a [ index_b ] + ")" ) ; } }
int findNumberDivByPowerofTwo ( int [ ] ar , int k , int n ) { int found = - 1 , m = k ; while ( m > 0 ) { int l = 0 ; int r = n - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( ar [ mid ] == m ) { found = m ; break ; } else if ( ar [ mid ] > m ) { r = mid - 1 ; } else if ( ar [ mid ] < m ) { l = mid + 1 ; } } if ( found != - 1 ) { break ; } m = m / 2 ; } return found ; }
int longestNudeSubseq ( int arr [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isNudeNum ( arr [ i ] ) ) answer ++ ; } return answer ; }
int findSubset ( int [ ] a , int n ) { int sum = 0 ; int cnt = 0 ; Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i - 1 ] - i <= 0 ) { sum += a [ i - 1 ] - i ; cnt += 1 ; } else { v . add ( a [ i - 1 ] - i ) ; } } Collections . sort ( v ) ; int ptr = 0 ; while ( ptr < v . size ( ) && sum + v . get ( ptr ) <= 0 ) { cnt += 1 ; ptr += 1 ; sum += v . get ( ptr ) ; } return cnt ; }
Vector < Integer > get_submaxarr ( int [ ] arr , int n , int y ) { int j = 0 ; Stack < Integer > stk = new Stack < Integer > ( ) ; int [ ] maxarr = new int [ n ] ; Arrays . fill ( maxarr , 0 ) ; stk . push ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( stk . size ( ) != 0 && arr [ i ] > arr [ stk . peek ( ) ] ) { maxarr [ stk . peek ( ) ] = i - 1 ; stk . pop ( ) ; } stk . push ( i ) ; } while ( stk . size ( ) != 0 ) { maxarr [ stk . size ( ) ] = n - 1 ; stk . pop ( ) ; } Vector < Integer > submax = new Vector < Integer > ( ) ; for ( int i = 0 ; i <= n - y ; i ++ ) { while ( maxarr [ j ] < i + y - 1 j < i ) { j ++ ; } submax . add ( arr [ j ] ) ; } return submax ; }
int findMinx ( int A , int B , int C , int K ) { int start = 1 ; int end = ( int ) Math . ceil ( Math . sqrt ( K ) ) ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; int x = func ( A , B , C , mid ) ; int Y = func ( A , B , C , mid - 1 ) ; if ( x >= K && Y < K ) { return mid ; } else if ( x < K ) { start = mid + 1 ; } else { end = mid - 1 ; } } return - 1 ; }
int longestSubarray ( int arr [ ] , int n , int k ) { int i , j , Max = 1 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( i = 0 ; i < n - 1 ; i ++ ) { s . add ( arr [ i ] ) ; for ( j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] - arr [ j ] ) == 0 || Math . abs ( arr [ i ] - arr [ j ] ) == k ) { if ( ! s . contains ( arr [ j ] ) ) { if ( s . size ( ) == 2 ) break ; else s . add ( arr [ j ] ) ; } } else break ; } if ( s . size ( ) == 2 ) { Max = Math . max ( Max , j - i ) ; s . clear ( ) ; } else s . clear ( ) ; } return Max ; }
void printDiagonal ( int K , int N , int [ ] [ ] M ) { int startrow , startcol ; if ( K - 1 < N ) { startrow = K - 1 ; startcol = 0 ; } else { startrow = N - 1 ; startcol = K - N ; } for ( ; startrow >= 0 && startcol < N ; startrow -- , startcol ++ ) { System . out . print ( M [ startrow ] [ startcol ] + " " ) ; } }
Vector < Integer > generateSequence ( int [ ] freq , int n ) { HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { m . put ( i , freq [ i ] ) ; total += freq [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( i ) ) { Vector < Integer > sequence = new Vector < Integer > ( ) ; @ SuppressWarnings ( "unchecked" ) HashMap < Integer , Integer > mcopy = ( HashMap < Integer , Integer > ) m . clone ( ) ; if ( mcopy . containsKey ( i ) && mcopy . get ( i ) > 0 ) mcopy . put ( i , mcopy . get ( i ) - 1 ) ; sequence . add ( i ) ; int last = i ; for ( int i1 = 0 ; i1 < total - 1 ; i1 ++ ) { if ( mcopy . containsKey ( last - 1 ) && mcopy . get ( last - 1 ) > 0 ) { mcopy . put ( last - 1 , mcopy . get ( last - 1 ) - 1 ) ; sequence . add ( last - 1 ) ; last -- ; } else if ( mcopy . containsKey ( last + 1 ) ) { mcopy . put ( last + 1 , mcopy . get ( last + 1 ) - 1 ) ; sequence . add ( last + 1 ) ; last ++ ; } else break ; } if ( sequence . size ( ) == total ) { return sequence ; } } } Vector < Integer > empty = new Vector < Integer > ( ) ; return empty ; }
void getMinimumDistance ( int a [ ] , int n ) { Set < Integer > min_set = new HashSet < > ( ) ; Set < Integer > max_set = new HashSet < > ( ) ; int max = 0 , min = Integer . MAX_VALUE ; HashMap < Integer , Integer > frequency = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { frequency . put ( a [ i ] , frequency . getOrDefault ( a [ i ] , 0 ) + 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { int count = frequency . get ( a [ i ] ) ; if ( count == max ) { max_set . add ( a [ i ] ) ; } else if ( count > max ) { max_set . clear ( ) ; max = count ; max_set . add ( a [ i ] ) ; } if ( count == min ) { min_set . add ( a [ i ] ) ; } else if ( count < min ) { min_set . clear ( ) ; min = count ; min_set . add ( a [ i ] ) ; } } int min_dist = Integer . MAX_VALUE ; int last_min_found = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_set . contains ( a [ i ] ) ) last_min_found = i ; if ( max_set . contains ( a [ i ] ) && last_min_found != - 1 ) { min_dist = Math . min ( min_dist , i - last_min_found ) ; } } last_min_found = - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( min_set . contains ( a [ i ] ) ) last_min_found = i ; if ( max_set . contains ( a [ i ] ) && last_min_found != - 1 ) { min_dist = Math . min ( min_dist , last_min_found - i ) ; } } System . out . println ( min_dist ) ; }
void printNum ( int L , int R ) { for ( int i = L ; i <= R ; i ++ ) { int temp = i ; int c = 10 ; int flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) System . out . print ( i + " " ) ; } }
void findPair ( int [ ] arr , int n ) { int i , j ; if ( n < 2 ) { System . out . println ( "-1" ) ; } HashSet < Integer > hashMap = new HashSet < Integer > ( ) ; for ( Integer k : arr ) { hashMap . add ( k ) ; } for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( ! hashMap . contains ( sum ) ) { System . out . println ( "(" + arr [ i ] + ", " + arr [ j ] + ")" ) ; } } } }
int findLengthOfMaxSubset ( int arr [ ] , int n , int m ) { Set < Integer > s = new HashSet < > ( ) ; int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int tmp = arr [ i ] ; if ( tmp != m ) { s . add ( tmp ) ; answer ++ ; } } int min = 1 ; while ( s . contains ( min ) ) { min ++ ; } if ( min != m ) { answer = - 1 ; } return answer ; }
boolean getDiameterPath ( int vertex , int targetVertex , int parent , ArrayList < Integer > path ) { if ( vertex == targetVertex ) { path . add ( vertex ) ; return true ; } for ( Integer i : tree . get ( vertex ) ) { if ( i == parent ) continue ; if ( getDiameterPath ( i , targetVertex , vertex , path ) ) { path . add ( vertex ) ; return true ; } } return false ; }
void addedge ( int a , int b ) { if ( tree . get ( a ) == null ) tree . put ( a , new ArrayList < > ( ) ) ; tree . get ( a ) . add ( b ) ; if ( tree . get ( b ) == null ) tree . put ( b , new ArrayList < > ( ) ) ; tree . get ( b ) . add ( a ) ; }
void FindCenter ( int n ) { maxHeight = - 1 ; maxHeightNode = - 1 ; farthestNode ( 0 , - 1 , 0 ) ; int leaf1 = maxHeightNode ; maxHeight = - 1 ; farthestNode ( maxHeightNode , - 1 , 0 ) ; int leaf2 = maxHeightNode ; path = new ArrayList < > ( ) ; getDiameterPath ( leaf1 , leaf2 , - 1 , path ) ; int pathSize = path . size ( ) ; if ( pathSize % 2 == 1 ) { System . out . println ( path . get ( pathSize / 2 ) ) ; } else { System . out . println ( path . get ( pathSize / 2 ) + ", " + path . get ( ( pathSize - 1 ) / 2 ) ) ; } }
int countSubsquare ( int arr [ ] [ ] , int n , int X ) { int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { dp [ i + 1 ] [ j + 1 ] = arr [ i ] [ j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; } } int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { int lo = 1 ; int hi = Math . min ( n - i , m - j ) + 1 ; boolean found = false ; while ( lo <= hi ) { int mid = ( lo + hi ) / 2 ; int ni = i + mid - 1 ; int nj = j + mid - 1 ; int sum = dp [ ni ] [ nj ] - dp [ ni ] [ j - 1 ] - dp [ i - 1 ] [ nj ] + dp [ i - 1 ] [ j - 1 ] ; if ( sum >= X ) { if ( sum == X ) { found = true ; } hi = mid - 1 ; } else { lo = mid + 1 ; } } if ( found == true ) { cnt ++ ; } } } return cnt ; }
int countSub ( String str ) { int n = ( int ) str . length ( ) ; int ans = 0 ; int [ ] cnt = new int [ 26 ] ; int i = 0 , j = 0 ; while ( i < n ) { if ( j < n && ( cnt [ str . charAt ( j ) - 'a' ] == 0 ) ) { cnt [ str . charAt ( j ) - 'a' ] ++ ; ans += ( j - i + 1 ) ; j ++ ; } else { cnt [ str . charAt ( i ) - 'a' ] -- ; i ++ ; } } return ans ; }
void findMaxValue ( int N , int K ) { int packages ; int maxi = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( N % i == 0 ) maxi = Math . max ( maxi , i ) ; } packages = N / maxi ; System . out . println ( packages ) ; }
void max_sum_subarray ( List < Integer > arr , int L , int R ) { int n = arr . size ( ) ; int [ ] pre = new int [ n ] ; pre [ 0 ] = arr . get ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr . get ( i ) ; } List < Integer > s1 = new ArrayList < > ( ) ; s1 . add ( 0 ) ; int ans = Integer . MIN_VALUE ; ans = Math . max ( ans , pre [ L - 1 ] ) ; int flag = 0 ; for ( int i = L ; i < n ; i ++ ) { if ( i - R >= 0 ) { if ( flag == 0 ) { int it = s1 . indexOf ( 0 ) ; s1 . remove ( it ) ; flag = 1 ; } } if ( i - L >= 0 ) s1 . add ( pre [ i - L ] ) ; ans = Math . max ( ans , pre [ i ] - s1 . get ( 0 ) ) ; if ( i - R >= 0 ) { int it = s1 . indexOf ( pre [ i - R ] ) ; s1 . remove ( it ) ; } } System . out . println ( ans ) ; }
int rowWise ( char [ ] [ ] v , int n , int m , int k ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int countcons = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( v [ i ] [ j ] == '1' ) { countcons = 0 ; } else { countcons ++ ; } if ( countcons >= k ) { ans ++ ; } } } return ans ; }
int colWise ( char [ ] [ ] v , int n , int m , int k ) { int ans = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int countcons = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( v [ j ] [ i ] == '1' ) { countcons = 0 ; } else { countcons ++ ; } if ( countcons >= k ) { ans ++ ; } } } return ans ; }
boolean solve ( int a [ ] , int n ) { int mx = Integer . MIN_VALUE ; for ( int j = 1 ; j < n ; j ++ ) { if ( mx > a [ j ] ) return false ; mx = Math . max ( mx , a [ j - 1 ] ) ; } return true ; }
int count ( int [ ] v , int n ) { int i , odd = 0 , even = 0 ; int j , d , count ; int t = ( int ) 1 << v . length ; int size = v . length ; for ( i = 1 ; i < t ; i ++ ) { d = 1 ; count = 0 ; for ( j = 0 ; j < size ; j ++ ) { if ( ( i & ( 1 << j ) ) > 0 ) { d *= v [ j ] ; count ++ ; } } if ( count % 2 == 1 ) odd += n / d ; else even += n / d ; } return ( odd - even ) ; }
int BinarySearch ( int l , int r , int [ ] v , int key ) { int mid ; while ( r - l > 1 ) { mid = ( l + r ) / 2 ; if ( key <= count ( v , mid ) ) { r = mid ; } else { l = mid ; } } if ( key == count ( v , l ) ) return l ; else return r ; }
void sieve ( ) { for ( int i = 0 ; i < 100005 ; i ++ ) spf [ i ] = - 1 ; for ( int i = 2 ; i * i <= 100005 ; i ++ ) { for ( int j = i ; j <= 100005 ; j += i ) { if ( spf [ j ] == - 1 ) { spf [ j ] = i ; } } } }
HashSet < Integer > findPrimeFactors ( HashSet < Integer > s , int n ) { while ( n > 1 ) { s . add ( spf [ n ] ) ; n /= spf [ n ] ; } return s ; }
int MinimumSteps ( int n , int m ) { Queue < pair > q = new LinkedList < > ( ) ; HashSet < Integer > s = new HashSet < Integer > ( ) ; q . add ( new pair ( n , 0 ) ) ; while ( ! q . isEmpty ( ) ) { int newNum = q . peek ( ) . first ; int distance = q . peek ( ) . second ; q . remove ( ) ; HashSet < Integer > k = findPrimeFactors ( s , newNum ) ; for ( int i : k ) { if ( newNum == m ) { return distance ; } else if ( newNum > m ) { break ; } else { q . add ( new pair ( newNum + i , distance + 1 ) ) ; } } } return - 1 ; }
void maxSide ( int a [ ] , int n ) { int sideLength = 0 ; Arrays . sort ( a ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] > sideLength ) { sideLength ++ ; } else { break ; } } System . out . println ( sideLength ) ; }
void medianChange ( List < Integer > arr1 , List < Integer > arr2 ) { int N = arr1 . size ( ) ; List < Integer > median = new ArrayList < > ( ) ; if ( ( N & 1 ) != 0 ) median . add ( arr1 . get ( N / 2 ) * 1 ) ; else median . add ( ( arr1 . get ( N / 2 ) + arr1 . get ( ( N - 1 ) / 2 ) ) / 2 ) ; for ( int x = 0 ; x < arr2 . size ( ) ; x ++ ) { int it = arr1 . indexOf ( arr2 . get ( x ) ) ; arr1 . remove ( it ) ; N -- ; if ( ( N & 1 ) != 0 ) { median . add ( arr1 . get ( N / 2 ) * 1 ) ; } else { median . add ( ( arr1 . get ( N / 2 ) + arr1 . get ( ( N - 1 ) / 2 ) ) / 2 ) ; } } for ( int i = 0 ; i < median . size ( ) - 1 ; i ++ ) { System . out . print ( median . get ( i + 1 ) - median . get ( i ) + " " ) ; } }
int countPairs ( int X [ ] , int Y [ ] , int m , int n ) { int [ ] suffix = new int [ 1005 ] ; long total_pairs = 0 ; for ( int i = 0 ; i < n ; i ++ ) suffix [ Y [ i ] ] ++ ; for ( int i = ( int ) 1e3 ; i >= 3 ; i -- ) suffix [ i ] += suffix [ i + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { if ( X [ i ] == 0 ) continue ; else if ( X [ i ] == 1 ) { total_pairs += suffix [ 0 ] ; continue ; } else if ( X [ i ] == 2 ) total_pairs += suffix [ 5 ] ; else if ( X [ i ] == 3 ) total_pairs += suffix [ 2 ] + suffix [ 4 ] ; else total_pairs += suffix [ X [ i ] + 1 ] ; total_pairs += suffix [ 0 ] + suffix [ 1 ] ; } return ( int ) total_pairs ; }
int solve ( int A [ ] [ ] , int N , int M ) { int [ ] [ ] B = new int [ N ] [ M ] ; int c = 1 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = c ++ ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( i != 0 ) { if ( A [ i - 1 ] [ j ] == A [ i ] [ j ] ) B [ i - 1 ] [ j ] = B [ i ] [ j ] ; } if ( i != N - 1 ) { if ( A [ i + 1 ] [ j ] == A [ i ] [ j ] ) B [ i + 1 ] [ j ] = B [ i ] [ j ] ; } if ( j != 0 ) { if ( A [ i ] [ j - 1 ] == A [ i ] [ j ] ) B [ i ] [ j - 1 ] = B [ i ] [ j ] ; } if ( j != M - 1 ) { if ( A [ i ] [ j + 1 ] == A [ i ] [ j ] ) B [ i ] [ j + 1 ] = B [ i ] [ j ] ; } } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) s . add ( B [ i ] [ j ] ) ; } return s . size ( ) ; }
int splitArray ( int start , int end , int [ ] arr , int [ ] prefix_sum ) { if ( start >= end ) return 0 ; for ( int k = start ; k < end ; ++ k ) { if ( ( prefix_sum [ k ] - prefix_sum [ start - 1 ] ) == ( prefix_sum [ end ] - prefix_sum [ k ] ) ) { return 1 + splitArray ( start , k , arr , prefix_sum ) + splitArray ( k + 1 , end , arr , prefix_sum ) ; } } return 0 ; }
void solve ( int arr [ ] , int n ) { int [ ] prefix_sum = new int [ n + 1 ] ; prefix_sum [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i - 1 ] ; } System . out . print ( splitArray ( 1 , n , arr , prefix_sum ) ) ; }
void minDiff ( long [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) a [ i ] *= 2 ; } Arrays . sort ( a ) ; long mindifference = a [ 1 ] - a [ 0 ] ; for ( int i = 1 ; i < a . length ; i ++ ) { mindifference = Math . min ( mindifference , a [ i ] - a [ i - 1 ] ) ; } System . out . println ( mindifference ) ; }
int countFac ( int n ) { int m = n ; int count = 0 ; for ( int i = 2 ; ( i * i ) <= m ; ++ i ) { int total = 0 ; while ( n % i == 0 ) { n /= i ; ++ total ; } int temp = 0 ; for ( int j = 1 ; ( temp + j ) <= total ; ++ j ) { temp += j ; ++ count ; } } if ( n != 1 ) ++ count ; return count ; }
int findMissing ( int arr [ ] , int left , int right , int diff ) { if ( right <= left ) return 0 ; int mid = left + ( right - left ) / 2 ; if ( arr [ mid + 1 ] - arr [ mid ] != diff ) return ( arr [ mid ] + diff ) ; if ( mid > 0 && arr [ mid ] - arr [ mid - 1 ] != diff ) return ( arr [ mid - 1 ] + diff ) ; if ( arr [ mid ] == arr [ 0 ] + mid * diff ) return findMissing ( arr , mid + 1 , right , diff ) ; return findMissing ( arr , left , mid - 1 , diff ) ; }
int missingElement ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int diff = ( arr [ n - 1 ] - arr [ 0 ] ) / n ; return findMissing ( arr , 0 , n - 1 , diff ) ; }
long check ( int A , int B , int C , int D , long x ) { long ans ; ans = ( A * x * x * x + B * x * x + C * x + D ) ; return ans ; }
void findSolution ( int A , int B , int C , int D , int E ) { long start = 0 , end = 100000 ; long mid , ans ; while ( start <= end ) { mid = start + ( end - start ) / 2 ; ans = check ( A , B , C , D , mid ) ; if ( ans == E ) { System . out . println ( mid ) ; return ; } if ( ans < E ) start = mid + 1 ; else end = mid - 1 ; } System . out . println ( "NA" ) ; }
int findParent ( int height , int node ) { int start = 1 ; int end = ( int ) Math . pow ( 2 , height ) - 1 ; if ( end == node ) return - 1 ; while ( node >= 1 ) { end = end - 1 ; int mid = start + ( end - start ) / 2 ; if ( mid == node end == node ) { return ( end + 1 ) ; } else if ( node < mid ) { end = mid ; } else { start = mid ; } } return - 1 ; }
int findValue ( int R , int C ) { int k = ( R * ( R - 1 ) ) / 2 + 1 ; int diff = R + 1 ; for ( int i = 1 ; i < C ; i ++ ) { k = ( k + diff ) ; diff ++ ; } return k ; }
int power ( int x , int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }
int nthRootSearch ( int low , int high , int N , int K ) { if ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( power ( mid , K ) <= N ) && ( power ( mid + 1 , K ) > N ) ) { return mid ; } else if ( power ( mid , K ) < N ) { return nthRootSearch ( mid + 1 , high , N , K ) ; } else { return nthRootSearch ( low , mid - 1 , N , K ) ; } } return low ; }
int get_subset_count ( int arr [ ] , int K , int N ) { Arrays . sort ( arr ) ; int left , right ; left = 0 ; right = N - 1 ; int ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; }
int naive_find_x ( int N ) { int c = 0 , i ; for ( i = 1 ; i < N ; i ++ ) { c += i * i * i ; if ( c >= N ) break ; } return i ; }
int binary_searched_find_x ( int k ) { int l = 0 ; int r = k ; int ans = 0 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( Math . pow ( ( ( mid * ( mid + 1 ) ) / 2 ) , 2 ) >= k ) { ans = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return ans ; }
int checkPerfectSquare ( long N , long start , long last ) { long mid = ( start + last ) / 2 ; if ( start > last ) { return - 1 ; } if ( mid * mid == N ) { return ( int ) mid ; } else if ( mid * mid > N ) { return checkPerfectSquare ( N , start , mid - 1 ) ; } else { return checkPerfectSquare ( N , mid + 1 , last ) ; } }
void minDistancePoints ( int A [ ] , int K , int n ) { Map < Integer , Boolean > m = new HashMap < Integer , Boolean > ( ) ; Queue < Integer > q = new LinkedList < Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { m . put ( A [ i ] , true ) ; q . add ( A [ i ] ) ; } LinkedList < Integer > ans = new LinkedList < Integer > ( ) ; while ( K > 0 ) { int x = q . poll ( ) ; if ( ! m . containsKey ( x - 1 ) && K > 0 ) { m . put ( x - 1 , true ) ; q . add ( x - 1 ) ; ans . add ( x - 1 ) ; K -- ; } if ( ! m . containsKey ( x + 1 ) && K > 0 ) { m . put ( x + 1 , true ) ; q . add ( x + 1 ) ; ans . add ( x + 1 ) ; K -- ; } } for ( Integer i : ans ) System . out . print ( i + " " ) ; }
int search ( int mat [ ] [ ] , int n , int m ) { int i , a = Integer . MAX_VALUE ; for ( i = 0 ; i < n ; i ++ ) { int low = 0 ; int high = m - 1 ; int mid ; int ans = Integer . MAX_VALUE ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( mat [ i ] [ mid ] == 1 ) { if ( mid == 0 ) { ans = 0 ; break ; } else if ( mat [ i ] [ mid - 1 ] == 0 ) { ans = mid ; break ; } } if ( mat [ i ] [ mid ] == 1 ) high = mid - 1 ; else low = mid + 1 ; } if ( ans < a ) a = ans ; } if ( a == Integer . MAX_VALUE ) return - 1 ; return a + 1 ; }
void findNumbers ( int N , int M ) { int m = M ; Map < Integer , Integer > remLen = new HashMap < > ( ) ; int len , remainder = 0 ; for ( len = 1 ; len <= N + 1 ; ++ len ) { remainder = M % N ; if ( ! remLen . containsKey ( remainder ) ) { remLen . put ( remainder , len ) ; } else { break ; } M = M * 10 + m ; M = M % N ; } int LenA = len ; int LenB = remLen . getOrDefault ( remainder , 0 ) ; for ( int i = 0 ; i < LenB ; ++ i ) System . out . print ( m ) ; System . out . print ( " " ) ; for ( int i = 0 ; i < LenA ; ++ i ) System . out . print ( m ) ; }
int subMatrixSum ( int i , int j , int len ) { return prefix_2D [ i ] [ j ] - prefix_2D [ i ] [ j - len ] - prefix_2D [ i - len ] [ j ] + prefix_2D [ i - len ] [ j - len ] ; }
int numberOfWays ( int a [ ] , int b [ ] , int n , int m , int k ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) prefix_2D [ i ] [ j ] = 1 ; else prefix_2D [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { prefix_2D [ i ] [ j ] += prefix_2D [ i ] [ j - 1 ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { prefix_2D [ i ] [ j ] += prefix_2D [ i - 1 ] [ j ] ; } } int answer = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { int low = 1 ; int high = Math . min ( i , j ) ; while ( low < high ) { int mid = ( low + high ) >> 1 ; if ( subMatrixSum ( i , j , mid ) >= k ) { high = mid ; } else { low = mid + 1 ; } } if ( subMatrixSum ( i , j , low ) >= k ) { answer += ( Math . min ( i , j ) - low + 1 ) ; } } } return answer ; }
void minpoint ( int arr [ ] , int n , int k ) { int min_point = 0 ; for ( int i = 1 ; i < k - 1 ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) min_point += 1 ; } int final_point = min_point ; for ( int i = k ; i < n ; i ++ ) { if ( arr [ i - ( k - 1 ) ] < arr [ i - ( k - 1 ) + 1 ] && arr [ i - ( k - 1 ) ] < arr [ i - ( k - 1 ) - 1 ] ) min_point -= 1 ; if ( arr [ i - 1 ] < arr [ i ] && arr [ i - 1 ] < arr [ i - 2 ] ) min_point += 1 ; if ( min_point > final_point ) final_point = min_point ; } System . out . println ( final_point ) ; }
void checkMin ( int arr [ ] , int len ) { int smallest = Integer . MAX_VALUE ; int secondSmallest = Integer . MAX_VALUE ; for ( int i = 0 ; i < len ; i ++ ) { if ( arr [ i ] < smallest ) { secondSmallest = smallest ; smallest = arr [ i ] ; } else if ( arr [ i ] < secondSmallest ) { secondSmallest = arr [ i ] ; } } if ( 2 * smallest <= secondSmallest ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
int [ ] find ( int dividend , int divisor , int start , int end ) { if ( start > end ) return new int [ ] { 0 , dividend } ; int mid = start + ( end - start ) / 2 ; int n = dividend - divisor * mid ; if ( n > divisor ) start = mid + 1 ; else if ( n < 0 ) end = mid - 1 ; else { if ( n == divisor ) { ++ mid ; n = 0 ; } return new int [ ] { mid , n } ; } return find ( dividend , divisor , start , end ) ; }
int [ ] divide ( int dividend , int divisor ) { return find ( dividend , divisor , 1 , dividend ) ; }
int get ( int a , int b , int n ) { int lo = 0 , hi = ( int ) 1e6 ; int ans = 0 ; while ( lo <= hi ) { int mid = ( lo + hi ) / 2 ; int dig = ( int ) Math . ceil ( ( mid * log ( mid , b ) + log ( a , b ) ) ) ; if ( dig > n ) { hi = mid - 1 ; } else { ans = mid ; lo = mid + 1 ; } } return ans ; }
void FindRank ( int arr [ ] , int length ) { System . out . print ( "1" + " " ) ; for ( int i = 1 ; i < arr . length ; i ++ ) { int rank = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) rank ++ ; } System . out . print ( rank + " " ) ; } }
void findFibonacci ( int N ) { for ( int i = N / 2 ; i > 1 ; i -- ) { if ( fib . contains ( i ) && fib . contains ( N - i ) ) { System . out . println ( i + " " + ( N - i ) ) ; return ; } } System . out . println ( "-1" ) ; }
void createHash ( ) { int prev = 0 , curr = 1 ; fibonacci . add ( prev ) ; fibonacci . add ( curr ) ; while ( curr <= MAX ) { int temp = curr + prev ; fibonacci . add ( temp ) ; prev = curr ; curr = temp ; } }
boolean checkArray ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( fibonacci . contains ( arr [ i ] ) ) sum += arr [ i ] ; if ( fibonacci . contains ( sum ) ) return true ; return false ; }
void compute ( int sz ) { boolean [ ] isFib = new boolean [ sz + 1 ] ; int prev = 0 , curr = 1 ; isFib [ prev ] = isFib [ curr ] = true ; while ( curr <= sz ) { int temp = curr + prev ; if ( temp <= sz ) isFib [ temp ] = true ; prev = curr ; curr = temp ; } fibUpto [ 0 ] = 1 ; for ( int i = 1 ; i <= sz ; i ++ ) { fibUpto [ i ] = fibUpto [ i - 1 ] ; if ( isFib [ i ] ) fibUpto [ i ] ++ ; } }
int countOfNumbers ( int N , int K ) { compute ( N ) ; int low = 1 , high = N , ans = 0 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( mid - fibUpto [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ( ans > 0 ? N - ans + 1 : 0 ) ; }
void precompute ( String s , int n ) { for ( int i = 0 ; i < n ; i ++ ) { f [ s . charAt ( i ) - 'a' ] [ i ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { f [ i ] [ j ] += f [ i ] [ j - 1 ] ; } } }
int palindromicSubsequencesUtil ( int L , int R ) { int c = 0 , ok = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { int cnt = f [ i ] [ R ] ; if ( L > 0 ) cnt -= f [ i ] [ L - 1 ] ; if ( cnt > 1 ) { ok = 1 ; c = i ; break ; } } if ( ok == 0 ) { return - 1 ; } return c ; }
void createHash ( HashSet < Integer > hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } }
int longestFibSubarray ( int arr [ ] , int n ) { int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; HashSet < Integer > hash = new HashSet < Integer > ( ) ; createHash ( hash , max_val ) ; int [ ] left = new int [ n ] ; int [ ] right = new int [ n ] ; int fibcount = 0 , res = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = fibcount ; if ( hash . contains ( arr [ i ] ) ) { fibcount ++ ; } else fibcount = 0 ; } fibcount = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { right [ i ] = fibcount ; if ( hash . contains ( arr [ i ] ) ) { fibcount ++ ; } else fibcount = 0 ; } for ( int i = 0 ; i < n ; i ++ ) res = Math . max ( res , left [ i ] + right [ i ] ) ; return res ; }
boolean isPrime ( int N ) { if ( N < 2 ) return false ; if ( N < 4 ) return true ; if ( ( N & 1 ) == 0 ) return false ; if ( N % 3 == 0 ) return false ; int curr = 5 , s = ( int ) Math . sqrt ( N ) ; while ( curr <= s ) { if ( N % curr == 0 ) return false ; curr += 2 ; if ( N % curr == 0 ) return false ; curr += 4 ; } return true ; }
boolean check ( int s , int p , int prefix_sum [ ] , int n ) { boolean satisfies = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( i + s - 1 >= n ) break ; if ( prefix_sum [ i + s - 1 ] - ( i - 1 >= 0 ? prefix_sum [ i - 1 ] : 0 ) < p ) satisfies = false ; } return satisfies ; }
int minimumWindowSize ( int x , int y , int p ) { int [ ] prefix_sum = new int [ y - x + 1 ] ; for ( int i = x ; i <= y ; i ++ ) { if ( isPrime ( i ) ) prefix_sum [ i - x ] = 1 ; } for ( int i = 1 ; i < y - x + 1 ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] ; int low = 1 , high = y - x + 1 ; int mid ; while ( high - low > 1 ) { mid = ( low + high ) / 2 ; if ( check ( mid , p , prefix_sum , y - x + 1 ) ) { high = mid ; } else low = mid ; } if ( check ( low , p , prefix_sum , y - x + 1 ) ) return low ; return high ; }
void preProcess ( int [ ] [ ] mat , int [ ] [ ] aux ) { for ( int i = 0 ; i < M ; i ++ ) aux [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) aux [ i ] [ j ] = mat [ i ] [ j ] + aux [ i - 1 ] [ j ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 1 ; j < M ; j ++ ) aux [ i ] [ j ] += aux [ i ] [ j - 1 ] ; }
int sumQuery ( int [ ] [ ] aux , int tli , int tlj , int rbi , int rbj ) { int res = aux [ rbi ] [ rbj ] ; if ( tli > 0 ) res = res - aux [ tli - 1 ] [ rbj ] ; if ( tlj > 0 ) res = res - aux [ rbi ] [ tlj - 1 ] ; if ( tli > 0 && tlj > 0 ) res = res + aux [ tli - 1 ] [ tlj - 1 ] ; return res ; }
int maximumSquareSize ( int [ ] [ ] mat , int K ) { int [ ] [ ] aux = new int [ N ] [ M ] ; preProcess ( mat , aux ) ; for ( int i = Math . min ( N , M ) ; i >= 1 ; i -- ) { boolean satisfies = true ; for ( int x = 0 ; x < N ; x ++ ) { for ( int y = 0 ; y < M ; y ++ ) { if ( x + i - 1 <= N - 1 && y + i - 1 <= M - 1 ) { if ( sumQuery ( aux , x , y , x + i - 1 , y + i - 1 ) > K ) satisfies = false ; } } } if ( satisfies == true ) return ( i ) ; } return 0 ; }
void preProcess ( int [ ] [ ] mat , int [ ] [ ] aux ) { for ( int i = 0 ; i < M ; i ++ ) aux [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) aux [ i ] [ j ] = mat [ i ] [ j ] + aux [ i - 1 ] [ j ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 1 ; j < M ; j ++ ) aux [ i ] [ j ] += aux [ i ] [ j - 1 ] ; }
int sumQuery ( int [ ] [ ] aux , int tli , int tlj , int rbi , int rbj ) { int res = aux [ rbi ] [ rbj ] ; if ( tli > 0 ) res = res - aux [ tli - 1 ] [ rbj ] ; if ( tlj > 0 ) res = res - aux [ rbi ] [ tlj - 1 ] ; if ( tli > 0 && tlj > 0 ) res = res + aux [ tli - 1 ] [ tlj - 1 ] ; return res ; }
boolean check ( int mid , int [ ] [ ] aux , int K ) { boolean satisfies = true ; for ( int x = 0 ; x < N ; x ++ ) { for ( int y = 0 ; y < M ; y ++ ) { if ( x + mid - 1 <= N - 1 && y + mid - 1 <= M - 1 ) { if ( sumQuery ( aux , x , y , x + mid - 1 , y + mid - 1 ) > K ) satisfies = false ; } } } return ( satisfies == true ) ; }
int maximumSquareSize ( int [ ] [ ] mat , int K ) { int [ ] [ ] aux = new int [ N ] [ M ] ; preProcess ( mat , aux ) ; int low = 1 , high = Math . min ( N , M ) ; int mid ; while ( high - low > 1 ) { mid = ( low + high ) / 2 ; if ( check ( mid , aux , K ) ) { low = mid ; } else high = mid ; } if ( check ( high , aux , K ) ) return high ; return low ; }
void createHash ( HashSet < Integer > hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } }
void add_factors ( int n , HashMap < Integer , Integer > mp ) { for ( int i = 1 ; i <= ( Math . sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { if ( mp . containsKey ( i ) ) mp . put ( i , mp . get ( i ) + 1 ) ; else mp . put ( i , 1 ) ; } else { if ( mp . containsKey ( i ) ) mp . put ( i , mp . get ( i ) + 1 ) ; else mp . put ( i , 1 ) ; if ( mp . containsKey ( n / i ) ) mp . put ( n / i , mp . get ( n / i ) + 1 ) ; else mp . put ( n / i , 1 ) ; } } } }
void removeDuplicates ( int arr [ ] , int n ) { int st = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 2 && arr [ i ] == arr [ i + 1 ] && arr [ i ] == arr [ i + 2 ] ) continue ; else { arr [ st ] = arr [ i ] ; st ++ ; } } System . out . print ( "{" ) ; for ( int i = 0 ; i < st ; i ++ ) { System . out . print ( arr [ i ] ) ; if ( i != st - 1 ) System . out . print ( ", " ) ; } System . out . print ( "}" ) ; }
boolean permutation ( int [ ] arr , int n ) { Set < Integer > hash = new HashSet < Integer > ( ) ; int maxEle = 0 ; for ( int i = 0 ; i < n ; i ++ ) { hash . add ( arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } if ( maxEle != n ) return false ; if ( hash . size ( ) == n ) return true ; return false ; }
int findPivot ( int arr [ ] , int low , int high ) { if ( high < low ) return - 1 ; if ( high == low ) return low ; int mid = ( low + high ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) { return mid ; } if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) { return mid - 1 ; } if ( arr [ low ] > arr [ mid ] ) { return findPivot ( arr , low , mid - 1 ) ; } else { return findPivot ( arr , mid + 1 , high ) ; } }
boolean isRotated ( int arr [ ] , int n ) { int l = 0 ; int r = n - 1 ; int pivot = - 1 ; if ( arr [ l ] > arr [ r ] ) { pivot = findPivot ( arr , l , r ) ; int temp = pivot ; if ( l < pivot ) { while ( pivot > l ) { if ( arr [ pivot ] < arr [ pivot - 1 ] ) { return false ; } pivot -- ; } } pivot = temp ; else  { pivot ++ ; while ( pivot < r ) { if ( arr [ pivot ] > arr [ pivot + 1 ] ) { return false ; } pivot ++ ; } } return true ; } else { return false ; } }
void state1 ( char c ) { if ( c == 'a' ) nfa = 2 ; else if ( c == 'b' c == 'c' ) nfa = 1 ; else flag = 1 ; }
void state2 ( char c ) { if ( c == 'a' ) nfa = 3 ; else if ( c == 'b' c == 'c' ) nfa = 2 ; else flag = 1 ; }
void state3 ( char c ) { if ( c == 'a' ) nfa = 1 ; else if ( c == 'b' c == 'c' ) nfa = 3 ; else flag = 1 ; }
void state4 ( char c ) { if ( c == 'b' ) nfa = 5 ; else if ( c == 'a' c == 'c' ) nfa = 4 ; else flag = 1 ; }
void state5 ( char c ) { if ( c == 'b' ) nfa = 6 ; else if ( c == 'a' c == 'c' ) nfa = 5 ; else flag = 1 ; }
void state6 ( char c ) { if ( c == 'b' ) nfa = 4 ; else if ( c == 'a' c == 'c' ) nfa = 6 ; else flag = 1 ; }
void state7 ( char c ) { if ( c == 'c' ) nfa = 8 ; else if ( c == 'b' c == 'a' ) nfa = 7 ; else flag = 1 ; }
void state9 ( char c ) { if ( c == 'c' ) nfa = 7 ; else if ( c == 'b' c == 'a' ) nfa = 9 ; else flag = 1 ; }
boolean checkA ( String s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 1 ) state1 ( s . charAt ( i ) ) ; else if ( nfa == 2 ) state2 ( s . charAt ( i ) ) ; else if ( nfa == 3 ) state3 ( s . charAt ( i ) ) ; } if ( nfa == 1 ) { return true ; } else { nfa = 4 ; } return false ; }
boolean checkB ( String s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 4 ) state4 ( s . charAt ( i ) ) ; else if ( nfa == 5 ) state5 ( s . charAt ( i ) ) ; else if ( nfa == 6 ) state6 ( s . charAt ( i ) ) ; } if ( nfa == 4 ) { return true ; } else { nfa = 7 ; } return false ; }
boolean checkC ( String s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 7 ) state7 ( s . charAt ( i ) ) ; else if ( nfa == 8 ) state8 ( s . charAt ( i ) ) ; else if ( nfa == 9 ) state9 ( s . charAt ( i ) ) ; } if ( nfa == 7 ) { return true ; } return false ; }
int getPositionCount ( int a [ ] , int n ) { int count = 1 ; int min = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; }
int CountSubSet ( int arr [ ] , int n , int X ) { int N = ( int ) Math . pow ( 2 , n ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) if ( arr [ j ] == X ) count += 1 ; } } return count ; }
int calculatePower ( int b , int e ) { int ans = 1 ; while ( e > 0 ) { if ( e % 2 == 1 ) ans = ans * b ; e = e / 2 ; b = b * b ; } return ans ; }
int CountSubSet ( int arr [ ] , int n , int X ) { int count = 0 , checkX = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == X ) { checkX = 1 ; break ; } } if ( checkX == 1 ) count = calculatePower ( 2 , n - 1 ) ; else count = 0 ; return count ; }
int build ( int A [ ] , int start , int end , int node ) { if ( start == end ) segment_tree [ node ] = A [ start ] ; else { int mid = ( start + end ) / 2 ; segment_tree [ node ] = Math . max ( build ( A , start , mid , 2 * node + 1 ) , build ( A , mid + 1 , end , 2 * node + 2 ) ) ; } return segment_tree [ node ] ; }
int query ( int start , int end , int l , int r , int node ) { if ( start > r end < l ) return - 1 ; if ( start >= l && end <= r ) return segment_tree [ node ] ; int mid = ( start + end ) / 2 ; return Math . max ( query ( start , mid , l , r , 2 * node + 1 ) , query ( mid + 1 , end , l , r , 2 * node + 2 ) ) ; }
int longestSubArray ( int A [ ] , int N , int K ) { int res = 1 ; int preSum [ ] = new int [ N + 1 ] ; preSum [ 0 ] = A [ 0 ] ; for ( int i = 0 ; i < N ; i ++ ) preSum [ i + 1 ] = preSum [ i ] + A [ i ] ; build ( A , 0 , N - 1 , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { int start = i , end = N - 1 , mid , max_index = i ; while ( start <= end ) { mid = ( start + end ) / 2 ; int max_element = query ( 0 , N - 1 , i , mid , 0 ) ; int expected_sum = ( mid - i + 1 ) * max_element ; int actual_sum = preSum [ mid + 1 ] - preSum [ i ] ; if ( expected_sum - actual_sum <= K ) { start = mid + 1 ; max_index = Math . max ( max_index , mid ) ; } else { end = mid - 1 ; } } res = Math . max ( res , max_index - i + 1 ) ; } return res ; }
int solve ( int arr [ ] , int n , int k ) { int max_len = 0 , l = 0 , r = n , m ; while ( l <= r ) { m = ( l + r ) / 2 ; if ( maxSum ( arr , n , m ) > k ) r = m - 1 ; else { l = m + 1 ; max_len = m ; } } return max_len ; }
int countNums ( int l , int r ) { int cnt = 0 ; for ( int i = l ; i <= r ; i ++ ) { int lastDigit = ( i % 10 ) ; if ( ( lastDigit % 10 ) == 2 || ( lastDigit % 10 ) == 3 || ( lastDigit % 10 ) == 9 ) { cnt ++ ; } } return cnt ; }
int findMinimumK ( int a [ ] , int n , int s ) { int maximum = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { maximum = Math . max ( maximum , a [ i ] ) ; } int low = 1 , high = maximum + 1 ; int ans = high ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ( int ) ( a [ i ] / mid ) ; } if ( sum > s ) low = mid + 1 ; else { ans = Math . min ( ans , mid ) ; high = mid - 1 ; } } return ans ; }
boolean allDigits ( String str , int len ) { boolean [ ] present = new boolean [ MAX ] ; for ( int i = 0 ; i < len ; i ++ ) { if ( isDigit ( str . charAt ( i ) ) ) { int digit = str . charAt ( i ) - '0' ; present [ digit ] = true ; } } for ( int i = 0 ; i < MAX ; i ++ ) { if ( ! present [ i ] ) return false ; } return true ; }
boolean isPlusPossible ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } boolean foundModOne = false ; for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) { int element = x . getKey ( ) ; int frequency = x . getValue ( ) ; if ( frequency % 4 == 0 ) continue ; if ( frequency % 4 == 1 ) { if ( foundModOne ) return false ; foundModOne = true ; } else return false ; } return true ; }
Vector < Integer > merge ( Vector < Integer > v1 , Vector < Integer > v2 ) { int i = 0 , j = 0 ; Vector < Integer > v = new Vector < > ( ) ; while ( i < v1 . size ( ) && j < v2 . size ( ) ) { if ( v1 . elementAt ( i ) <= v2 . elementAt ( j ) ) { v . add ( v1 . elementAt ( i ) ) ; i ++ ; } else { v . add ( v2 . elementAt ( j ) ) ; j ++ ; } } for ( int k = i ; k < v1 . size ( ) ; k ++ ) v . add ( v1 . elementAt ( k ) ) ; for ( int k = j ; k < v2 . size ( ) ; k ++ ) v . add ( v2 . elementAt ( k ) ) ; return v ; }
void buildTree ( Vector < Integer > [ ] tree , int [ ] arr , int index , int s , int e ) { if ( s == e ) { tree [ index ] . add ( arr [ s ] ) ; return ; } int mid = ( s + e ) / 2 ; buildTree ( tree , arr , 2 * index , s , mid ) ; buildTree ( tree , arr , 2 * index + 1 , mid + 1 , e ) ; tree [ index ] = merge ( tree [ 2 * index ] , tree [ 2 * index + 1 ] ) ; }
int query ( Vector < Integer > [ ] tree , int index , int s , int e , int l , int r , int k ) { if ( r < s l > e ) return 0 ; if ( s >= l && e <= r ) { return ( tree [ index ] . size ( ) - lowerBound ( tree [ index ] , tree [ index ] . size ( ) , k ) ) ; } int mid = ( s + e ) / 2 ; return ( query ( tree , 2 * index , s , mid , l , r , k ) + query ( tree , 2 * index + 1 , mid + 1 , e , l , r , k ) ) ; }
int findGCDSum ( int n , int a [ ] ) { int GCDSum = 0 ; int tempGCD = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { tempGCD = 0 ; for ( int k = i ; k <= j ; k ++ ) { tempGCD = __gcd ( tempGCD , a [ k ] ) ; } GCDSum += tempGCD ; } } return GCDSum ; }
void buildSparseTable ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { SparseTable [ i ] [ 0 ] = a [ i ] ; } for ( int j = 1 ; j <= 19 ; j ++ ) { for ( int i = 0 ; i <= n - ( 1 << j ) ; i ++ ) { SparseTable [ i ] [ j ] = __gcd ( SparseTable [ i ] [ j - 1 ] , SparseTable [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) ; } } }
int queryForGCD ( int L , int R ) { int returnValue ; int j = ( int ) ( Math . log ( R - L + 1 ) ) ; returnValue = __gcd ( SparseTable [ L ] [ j ] , SparseTable [ R - ( 1 << j ) + 1 ] [ j ] ) ; return returnValue ; }
int calculateSum ( int a [ ] , int n ) { buildSparseTable ( a , n ) ; int endPointer , startPointer , prevEndPointer , tempGCD ; int tempAns = 0 ; for ( int i = 0 ; i < n ; i ++ ) { endPointer = i ; startPointer = i ; prevEndPointer = i ; tempGCD = a [ i ] ; while ( endPointer < n ) { endPointer = nextPosition ( tempGCD , startPointer , prevEndPointer , n ) ; tempAns += ( ( endPointer - prevEndPointer ) * tempGCD ) ; prevEndPointer = endPointer ; if ( endPointer < n ) { tempGCD = __gcd ( tempGCD , a [ endPointer ] ) ; } } } return tempAns ; }
boolean isSquarePossible ( int arr [ ] , int n , int l ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= l ) cnt ++ ; if ( cnt >= l ) return true ; } return false ; }
int maxArea ( int arr [ ] , int n ) { int l = 0 , r = n ; int len = 0 ; while ( l <= r ) { int m = l + ( ( r - l ) / 2 ) ; if ( isSquarePossible ( arr , n , m ) ) { len = m ; l = m + 1 ; } else r = m - 1 ; } return ( len * len ) ; }
int find_triplet ( int array [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { indices [ i ] = new Vector < > ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { indices [ array [ i ] ] . add ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { int y = array [ i ] ; for ( int j = 0 ; j < ROW ; j ++ ) { int s = test [ j ] [ 1 ] * y ; if ( s % test [ j ] [ 0 ] != 0 ) continue ; if ( s % test [ j ] [ 2 ] != 0 ) continue ; int x = s / test [ j ] [ 0 ] ; int z = s / test [ j ] [ 2 ] ; if ( x > MAX z > MAX ) continue ; int l = 0 ; int r = indices [ x ] . size ( ) - 1 ; int first = - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( indices [ x ] . get ( m ) < i ) { first = m ; l = m + 1 ; } else { r = m - 1 ; } } l = 0 ; r = indices [ z ] . size ( ) - 1 ; int third = - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( indices [ z ] . get ( m ) > i ) { third = m ; r = m - 1 ; } else { l = m + 1 ; } } if ( first != - 1 && third != - 1 ) { answer += ( first + 1 ) * ( indices [ z ] . size ( ) - third ) ; } } } return answer ; }
int lcm ( int A , int B ) { return ( A * B ) / gcd ( A , B ) ; }
int checkA ( int A , int B , int C , int K ) { int start = 1 ; int end = K ; int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = A * mid ; int divA = mid - 1 ; int divB = ( value % B == 0 ) ? value / B - 1 : value / B ; int divC = ( value % C == 0 ) ? value / C - 1 : value / C ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ; int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; } else if ( elem > ( K - 1 ) ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; }
int checkB ( int A , int B , int C , int K ) { int start = 1 ; int end = K ; int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = B * mid ; int divB = mid - 1 ; int divA = ( value % A == 0 ) ? value / A - 1 : value / A ; int divC = ( value % C == 0 ) ? value / C - 1 : value / C ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ; int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; } else if ( elem > ( K - 1 ) ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; }
int checkC ( int A , int B , int C , int K ) { int start = 1 ; int end = K ; int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = C * mid ; int divC = mid - 1 ; int divB = ( value % B == 0 ) ? value / B - 1 : value / B ; int divA = ( value % A == 0 ) ? value / A - 1 : value / A ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ; int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; } else if ( elem > ( K - 1 ) ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; }
int findKthMultiple ( int A , int B , int C , int K ) { int res = checkA ( A , B , C , K ) ; if ( res == - 1 ) res = checkB ( A , B , C , K ) ; if ( res == - 1 ) res = checkC ( A , B , C , K ) ; return res ; }
int kthSmallest ( int a [ ] , int left , int right , int k ) { while ( left <= right ) { int pivotIndex = partition ( a , left , right ) ; if ( pivotIndex == k - 1 ) return a [ pivotIndex ] ; else if ( pivotIndex > k - 1 ) right = pivotIndex - 1 ; else left = pivotIndex + 1 ; } return - 1 ; }
int calculateDifference ( int [ ] arr , int n ) { int max_val = max_element ( arr ) ; boolean [ ] prime = new boolean [ max_val + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int x1 = 1 , x2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) x1 ^= arr [ i ] ; else if ( arr [ i ] != 1 ) x2 ^= arr [ i ] ; } return Math . abs ( x1 - x2 ) ; }
boolean containsElement ( int [ ] arr , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; ++ i ) xorArr ^= arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { int x = xorArr ^ arr [ i ] ; if ( arr [ i ] == x ) return true ; } return false ; }
double Square ( double n , double i , double j ) { double mid = ( i + j ) / 2 ; double mul = mid * mid ; if ( ( mul == n ) || ( Math . abs ( mul - n ) < 0.00001 ) ) return mid ; else if ( mul < n ) return Square ( n , mid , j ) ; else return Square ( n , i , mid ) ; }
int length_substring ( String S , char K ) { int curr_cnt = 0 , prev_cnt = 0 , max_len ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( S . charAt ( i ) == K ) { curr_cnt += 1 ; } else { prev_cnt = Math . max ( prev_cnt , curr_cnt ) ; curr_cnt = 0 ; } } prev_cnt = Math . max ( prev_cnt , curr_cnt ) ; max_len = prev_cnt ; return max_len ; }
int Xor_Sum ( int [ ] arr , int n ) { int sum = 0 , index = - 1 ; int left_xor = 0 , right_xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { left_xor = left_xor ^ arr [ i ] ; right_xor = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { right_xor = right_xor ^ arr [ j ] ; } if ( left_xor + right_xor > sum ) { sum = left_xor + right_xor ; index = i ; } } return index + 1 ; }
void ComputePrefixXor ( int arr [ ] , int PrefixXor [ ] , int n ) { PrefixXor [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) PrefixXor [ i ] = PrefixXor [ i - 1 ] ^ arr [ i ] ; }
int Xor_Sum ( int arr [ ] , int n ) { int [ ] PrefixXor = new int [ n ] ; ComputePrefixXor ( arr , PrefixXor , n ) ; int sum = 0 , index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( PrefixXor [ i ] + ( PrefixXor [ n - 1 ] ^ PrefixXor [ i ] ) > sum ) { sum = PrefixXor [ i ] + ( PrefixXor [ n - 1 ] ^ PrefixXor [ i ] ) ; index = i ; } } return index + 1 ; }
HashMap < Integer , Integer > buildMapWithColor ( int arr [ ] , int n ) { HashMap < Integer , Integer > mapWithColor = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mapWithColor . put ( arr [ i ] , i + 1 ) ; } return mapWithColor ; }
boolean isPalindrome ( String str , int i , int j ) { while ( i < j ) { if ( str . charAt ( i ) != str . charAt ( j ) ) { return false ; } i ++ ; j -- ; } return true ; }
int maxLenPalindrome ( String str , int n , char ch ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == ch ) { for ( int j = n - 1 ; j >= i ; j -- ) { if ( str . charAt ( j ) == ch ) { if ( isPalindrome ( str , i , j ) ) { maxLen = Math . max ( maxLen , j - i + 1 ) ; break ; } } } } } return maxLen ; }
Vector < Integer > findCount ( String a [ ] , String b [ ] , int n , int m ) { int [ ] freq = new int [ MAX ] ; Vector < Integer > smallestFreq = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String s = a [ i ] ; Arrays . fill ( freq , 0 ) ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { freq [ s . charAt ( j ) - 'a' ] ++ ; } for ( int j = 0 ; j < MAX ; j ++ ) { if ( freq [ j ] > 0 ) { smallestFreq . add ( freq [ j ] ) ; break ; } } } Collections . sort ( smallestFreq ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { String s = b [ i ] ; Arrays . fill ( freq , 0 ) ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { freq [ s . charAt ( j ) - 'a' ] ++ ; } int frequency = 0 ; for ( int j = 0 ; j < MAX ; j ++ ) { if ( freq [ j ] > 0 ) { frequency = freq [ j ] ; break ; } } int [ ] array = new int [ smallestFreq . size ( ) ] ; int k = 0 ; for ( Integer val : smallestFreq ) { array [ k ] = val ; k ++ ; } int ind = lower_bound ( array , 0 , smallestFreq . size ( ) , frequency ) ; ans . add ( ind ) ; } return ans ; }
void printAnswer ( String a [ ] , String b [ ] , int n , int m ) { Vector < Integer > ans = findCount ( a , b , n , m ) ; for ( Integer it : ans ) { System . out . print ( it + " " ) ; } }
int linearCheck ( int ar [ ] [ ] , int arr [ ] ) { for ( int i = 0 ; i < m ; i ++ ) { boolean matched = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( ar [ i ] [ j ] != arr [ j ] ) { matched = false ; break ; } } if ( matched ) return i + 1 ; } return - 1 ; }
int compareRow ( int a1 [ ] , int a2 [ ] ) { for ( int i = 0 ; i < n ; i ++ ) { if ( a1 [ i ] < a2 [ i ] ) return 1 ; else if ( a1 [ i ] > a2 [ i ] ) return - 1 ; } return 0 ; }
int binaryCheck ( int ar [ ] [ ] , int arr [ ] ) { int l = 0 , r = m - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; int temp = compareRow ( ar [ mid ] , arr ) ; if ( temp == 0 ) return mid + 1 ; else if ( temp == 1 ) l = mid + 1 ; else r = mid - 1 ; } return - 1 ; }
int findCnt ( int arr [ ] , int n , int k ) { int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { arr [ i ] += arr [ i - 1 ] ; if ( arr [ i ] > k arr [ i ] < - 1 * k ) ans ++ ; } if ( arr [ 0 ] > k arr [ 0 ] < - 1 * k ) ans ++ ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) ans += n - upper_bound ( arr , 0 , n , arr [ i ] + k ) ; return ans ; }
int FindIntersection ( ArrayList < ArrayList < Integer > > type1 , int n , ArrayList < ArrayList < Integer > > type2 , int m ) { int ans = n * m ; ArrayList < Integer > start = new ArrayList < Integer > ( ) ; ArrayList < Integer > end = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { start . add ( type1 . get ( i ) . get ( 0 ) ) ; end . add ( type1 . get ( i ) . get ( 1 ) ) ; } Collections . sort ( start ) ; Collections . sort ( end ) ; for ( int i = 0 ; i < m ; i ++ ) { int L = type2 . get ( i ) . get ( 0 ) ; int R = type2 . get ( i ) . get ( 1 ) ; ans -= start . size ( ) - upperBound ( start , 0 , start . size ( ) , R ) ; ans -= upperBound ( end , 0 , end . size ( ) , L - 1 ) ; } return ans ; }
int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; }
int divTermCount ( int a , int b , int c , int num ) { return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / lcm ( a , b ) ) - ( num / lcm ( b , c ) ) - ( num / lcm ( a , c ) ) + ( num / lcm ( a , lcm ( b , c ) ) ) ) ; }
int findNthTerm ( int a , int b , int c , int n ) { int low = 1 , high = Integer . MAX_VALUE , mid ; while ( low < high ) { mid = low + ( high - low ) / 2 ; if ( divTermCount ( a , b , c , mid ) < n ) low = mid + 1 ; else high = mid ; } return low ; }
void setZero ( int freq [ ] ) { for ( int i = 0 ; i < MAX ; i ++ ) freq [ i ] = 0 ; }
void preCalculate ( String str , int n ) { freq [ ( int ) str . charAt ( 0 ) ] [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { char ch = str . charAt ( i ) ; for ( int j = 0 ; j < MAX ; j ++ ) { char charToUpdate = ( char ) j ; if ( charToUpdate == ch ) freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 ; else freq [ j ] [ i ] = freq [ j ] [ i - 1 ] ; } } }
int getFrequency ( char ch , int l , int r ) { if ( l == 0 ) return freq [ ( int ) ch ] [ r ] ; else return ( freq [ ( int ) ch ] [ r ] - freq [ ( int ) ch ] [ l - 1 ] ) ; }
String firstNonRepeating ( String str , int n , int l , int r ) { for ( int i = l ; i < r ; i ++ ) { char ch = str . charAt ( i ) ; if ( getFrequency ( ch , l , r ) == 1 ) return ( "" + ch ) ; } return "-1" ; }
int maxLength ( String s , int n ) { int ans = Integer . MIN_VALUE ; Vector < Integer > A = new Vector < Integer > ( ) ; Vector < Integer > L = new Vector < Integer > ( ) ; Vector < Integer > R = new Vector < Integer > ( ) ; int [ ] freq = new int [ n + 5 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( s . charAt ( j ) - 'a' == i ) count ++ ; freq [ j ] = count ; } for ( int j = 1 ; j < n ; j ++ ) { L . add ( ( 2 * freq [ j - 1 ] ) - j ) ; R . add ( ( 2 * freq [ j ] ) - j ) ; } int max_len = Integer . MIN_VALUE ; int min_val = Integer . MAX_VALUE ; for ( int j = 0 ; j < L . size ( ) ; j ++ ) { min_val = Math . min ( min_val , L . get ( j ) ) ; A . add ( min_val ) ; int l = 0 , r = j ; while ( l <= r ) { int mid = ( l + r ) >> 1 ; if ( A . get ( mid ) <= R . get ( j ) ) { max_len = Math . max ( max_len , j - mid + 1 ) ; r = mid - 1 ; } else { l = mid + 1 ; } } } ans = Math . max ( ans , max_len ) ; A . clear ( ) ; R . clear ( ) ; L . clear ( ) ; } return ans ; }
int minOperations ( int arr [ ] , int n ) { int start = ( int ) arr [ n - 1 ] ; int end = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) + n ; int max_arr = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( check ( mid , n , arr ) ) { max_arr = mid ; end = mid - 1 ; } else { start = mid + 1 ; } } int [ ] desired = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { desired [ i ] = max_arr ; max_arr -- ; } int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { operations += ( desired [ i ] - arr [ i ] ) ; } return operations ; }
int countNode ( Node head ) { int count = 0 ; while ( head . next != null ) { Node ptr = head . next ; while ( ptr != null ) { if ( head . data == ptr . data ) { count ++ ; break ; } ptr = ptr . next ; } head = head . next ; } return count ; }
void insert ( Node ref_head , int item ) { Node temp = new Node ( ) ; temp . data = item ; temp . next = ref_head ; head = temp ; }
int countNode ( Node head ) { if ( head == null ) return 0 ; ; HashSet < Integer > s = new HashSet < > ( ) ; s . add ( head . data ) ; int count = 0 ; for ( Node curr = head . next ; curr != null ; curr = curr . next ) { if ( s . contains ( curr . data ) ) count ++ ; s . add ( curr . data ) ; } return count ; }
int countLessThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] < key ) { l = m + 1 ; index = m ; } else { r = m - 1 ; } } return ( index + 1 ) ; }
int countGreaterThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] <= key ) { l = m + 1 ; } else { r = m - 1 ; index = m ; } } if ( index == - 1 ) return 0 ; return ( n - index ) ; }
int countTriplets ( int n , int a [ ] , int b [ ] , int c [ ] ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; Arrays . sort ( c ) ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int current = b [ i ] ; int low = countLessThan ( a , n , current ) ; int high = countGreaterThan ( c , n , current ) ; count += ( low * high ) ; } return count ; }
int maximum_middle_value ( int n , int k , int arr [ ] ) { int ans = - 1 ; int low = ( n + 1 - k ) / 2 ; int high = ( n + 1 - k ) / 2 + k ; for ( int i = low ; i <= high ; i ++ ) { ans = Math . max ( ans , arr [ i - 1 ] ) ; } return ans ; }
int firstRepeating ( String str ) { boolean [ ] visited = new boolean [ NO_OF_CHARS ] ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) visited [ i ] = false ; int res = - 1 ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { if ( visited [ str . charAt ( i ) ] == false ) visited [ str . charAt ( i ) ] = true ; else res = i ; } return res ; }
int minSteps ( int arr [ ] [ ] ) { boolean v [ ] [ ] = new boolean [ n ] [ n ] ; Queue < Pair > q = new LinkedList < Pair > ( ) ; q . add ( new Pair ( 0 , 0 ) ) ; int depth = 0 ; while ( q . size ( ) != 0 ) { int x = q . size ( ) ; while ( x -- > 0 ) { Pair y = q . peek ( ) ; int i = y . first , j = y . second ; q . remove ( ) ; if ( v [ i ] [ j ] ) continue ; if ( i == n - 1 && j == n - 1 ) return depth ; v [ i ] [ j ] = true ; if ( i + arr [ i ] [ j ] < n ) q . add ( new Pair ( i + arr [ i ] [ j ] , j ) ) ; if ( j + arr [ i ] [ j ] < n ) q . add ( new Pair ( i , j + arr [ i ] [ j ] ) ) ; } depth ++ ; } return - 1 ; }
int minSteps ( int arr [ ] , int n ) { boolean [ ] v = new boolean [ n ] ; Queue < Integer > q = new LinkedList < > ( ) ; q . add ( 0 ) ; int depth = 0 ; while ( q . size ( ) > 0 ) { int x = q . size ( ) ; while ( x -- > 0 ) { int i = q . peek ( ) ; q . poll ( ) ; if ( v [ i ] ) continue ; if ( i == n - 1 ) return depth ; v [ i ] = true ; if ( i + arr [ i ] < n ) q . add ( i + arr [ i ] ) ; if ( i - arr [ i ] >= 0 ) q . add ( i - arr [ i ] ) ; } depth ++ ; } return - 1 ; }
int divisorcount ( int elem ) { int ans = 0 ; for ( int i = 1 ; i <= Math . sqrt ( elem ) ; i ++ ) { if ( elem % i == 0 ) { if ( i * i == elem ) ans ++ ; else ans += 2 ; } } return ans ; }
String findwinner ( int A [ ] , int B [ ] , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = divisorcount ( A [ i ] ) ; } for ( int i = 0 ; i < M ; i ++ ) { B [ i ] = divisorcount ( B [ i ] ) ; } Arrays . sort ( A ) ; Arrays . sort ( B ) ; int winA = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int val = A [ i ] ; int start = 0 ; int end = M - 1 ; int index = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( B [ mid ] <= val ) { index = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } winA += ( index + 1 ) ; } int winB = N * M - winA ; if ( winA > winB ) { return "A" ; } else if ( winB > winA ) { return "B" ; } return "Draw" ; }
int minTime ( int box [ ] , int truck [ ] , int n , int m ) { Arrays . sort ( box ) ; Arrays . sort ( truck ) ; int l = 0 ; int h = 2 * n ; int min_time = 0 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( isPossible ( box , truck , n , m , mid ) ) { min_time = mid ; h = mid - 1 ; } else l = mid + 1 ; } return min_time ; }
boolean isPossible ( int arr [ ] , int n , int dist , int k ) { int req = 0 ; int curr = 0 ; int prev = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( curr != n && arr [ curr ] - arr [ prev ] <= dist ) { curr ++ ; } req ++ ; if ( curr == n ) { break ; } prev = curr - 1 ; } if ( curr != n ) { return false ; } if ( req <= k ) { return true ; } return false ; }
int minDistance ( int arr [ ] , int n , int k ) { int l = 0 ; int h = arr [ n - 1 ] ; int ans = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( isPossible ( arr , n , m , k ) ) { ans = m ; h = m - 1 ; } else { l = m + 1 ; } } return ans ; }
int getKthElement ( int n , int k , int L [ ] , int R [ ] ) { int l = 1 ; int h = n ; int total [ ] = new int [ n + 1 ] ; total [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total [ i + 1 ] = total [ i ] + ( R [ i ] - L [ i ] ) + 1 ; } int index = - 1 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( total [ m ] > k ) { index = m ; h = m - 1 ; } else if ( total [ m ] < k ) l = m + 1 ; else { index = m ; break ; } } l = L [ index - 1 ] ; h = R [ index - 1 ] ; int x = k - total [ index - 1 ] ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( m - L [ index - 1 ] ) + 1 == x ) { return m ; } else if ( ( m - L [ index - 1 ] ) + 1 > x ) h = m - 1 ; else l = m + 1 ; } return k ; }
int MinimumX ( int a , int b , int c , int k ) { int x = Integer . MAX_VALUE ; if ( k <= c ) return 0 ; int h = k - c ; int l = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = Math . min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; }
void preCalculate ( int binary [ ] , int n , pair left [ ] ) { int count1 = 0 , count0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] . first = count1 ; left [ i ] . second = count0 ; if ( binary [ i ] != 0 ) count1 ++ ; else count0 ++ ; } }
int findMissing ( int arr [ ] , int n ) { int l = 0 , h = n - 1 ; int mid ; while ( h > l ) { mid = l + ( h - l ) / 2 ; if ( arr [ mid ] - mid == arr [ 0 ] ) { if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) return arr [ mid ] + 1 ; else { l = mid + 1 ; } } else { if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) return arr [ mid ] - 1 ; else { h = mid - 1 ; } } } return - 1 ; }
int maxSum ( int arr [ ] , int n , int K ) { int maximum = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int sumk = 0 ; for ( int j = i ; j < n ; j += K ) sumk = sumk + arr [ j ] ; maximum = Math . max ( maximum , sumk ) ; } return maximum ; }
int operations ( int op [ ] , int n , int k ) { int i , count = 0 ; int nVal = 0 ; int min = Integer . MAX_VALUE ; for ( i = 0 ; i < n ; i ++ ) { nVal += op [ i ] ; min = Math . min ( min , nVal ) ; if ( ( k + nVal ) <= 0 ) return ( i + 1 ) ; } if ( nVal >= 0 ) return - 1 ; int times = ( k - Math . abs ( min ) ) / Math . abs ( nVal ) ; k = ( k - ( times * Math . abs ( nVal ) ) ) ; count = ( times * n ) ; while ( k > 0 ) { for ( i = 0 ; i < n ; i ++ ) { k = k + op [ i ] ; count ++ ; if ( k <= 0 ) break ; } } return count ; }
int findMax ( int arr [ ] , int low , int high ) { if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid == 0 && arr [ mid ] > arr [ mid + 1 ] ) { return arr [ mid ] ; } if ( arr [ low ] > arr [ mid ] ) { return findMax ( arr , low , mid - 1 ) ; } else { return findMax ( arr , mid + 1 , high ) ; } }
void cal_prefix ( int n , int arr [ ] ) { int i , j ; for ( i = 0 ; i < n ; i ++ ) ar [ i + 1 ] = arr [ i ] ; for ( i = 1 ; i <= 1000 ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) prefix [ i ] [ j ] = 0 ; for ( j = 1 ; j <= n ; j ++ ) { prefix [ i ] [ j ] = prefix [ i ] [ j - 1 ] + ( int ) ( ar [ j ] <= i ? 1 : 0 ) ; } } }
int ksub ( int l , int r , int n , int k ) { int lo , hi , mid ; lo = 1 ; hi = 1000 ; while ( lo + 1 < hi ) { mid = ( lo + hi ) / 2 ; if ( prefix [ mid ] [ r ] - prefix [ mid ] [ l - 1 ] >= k ) hi = mid ; else lo = mid + 1 ; } if ( prefix [ lo ] [ r ] - prefix [ lo ] [ l - 1 ] >= k ) hi = lo ; return hi ; }
int binary ( int arr [ ] , int v ) { int index = lookup_table [ 0 ] - 1 ; int co = 0 ; while ( lookup_table [ co ] != 0 ) { if ( v == arr [ index ] ) return index ; else if ( v < arr [ index ] ) { index -= lookup_table [ ++ co ] ; return index ; } else { index += lookup_table [ ++ co ] ; return index ; } } return index ; }
int countPairs ( String s1 , int n1 , String s2 , int n2 ) { int [ ] freq1 = new int [ 26 ] ; int [ ] freq2 = new int [ 26 ] ; Arrays . fill ( freq1 , 0 ) ; Arrays . fill ( freq2 , 0 ) ; int i , count = 0 ; for ( i = 0 ; i < n1 ; i ++ ) freq1 [ s1 . charAt ( i ) - 'a' ] ++ ; for ( i = 0 ; i < n2 ; i ++ ) freq2 [ s2 . charAt ( i ) - 'a' ] ++ ; for ( i = 0 ; i < 26 ; i ++ ) count += ( Math . min ( freq1 [ i ] , freq2 [ i ] ) ) ; return count ; }
int findSmallestX ( int Y ) { int low = 0 , high = 5 * Y ; int N = 0 ; while ( low <= high ) { int mid = ( high + low ) / 2 ; if ( countFactor ( 5 , mid ) < Y ) { low = mid + 1 ; } else { N = mid ; high = mid - 1 ; } } return N ; }
void findpair ( int l , int r ) { int ans1 = l ; int ans2 = 2 * l ; System . out . println ( ans1 + ", " + ans2 ) ; }
boolean check ( int arr [ ] , int N , int K ) { HashSet < Integer > unique = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) unique . add ( arr [ i ] ) ; if ( unique . size ( ) == K ) return true ; return false ; }
long squareSum ( long N ) { long sum = ( long ) ( N * ( N + 1 ) * ( 2 * N + 1 ) ) / 6 ; return sum ; }
long findMaxN ( long X ) { long N = ( long ) Math . sqrt ( X ) ; for ( long i = 1 ; i <= N ; i ++ ) { if ( squareSum ( i ) > X ) return i - 1 ; } return - 1 ; }
long findMaxN ( long X ) { long low = 1 , high = 100000 ; int N = 0 ; while ( low <= high ) { long mid = ( high + low ) / 2 ; if ( squareSum ( mid ) <= X ) { N = ( int ) mid ; low = mid + 1 ; } else high = mid - 1 ; } return N ; }
int findNumber ( pair a [ ] , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) { if ( K >= a [ i ] . first && K <= a [ i ] . second ) return i ; } return - 1 ; }
int findNumber ( pair a [ ] , int n , int K ) { int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( K >= a [ mid ] . first && K <= a [ mid ] . second ) return mid ; else if ( K < a [ mid ] . first ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; }
void prefixSum ( int [ ] p_arr , int [ ] arr , int n ) { p_arr [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) p_arr [ i ] = arr [ i ] + p_arr [ i - 1 ] ; }
void canDivide ( int [ ] p_arr , int n , HashSet < Integer > q , int l , int r ) { int sum ; if ( l == 0 ) sum = p_arr [ r ] ; else sum = p_arr [ r ] - p_arr [ l - 1 ] ; if ( sum % 2 == 1 ) { System . out . println ( "No" ) ; return ; } int beg = 0 ; if ( l != 0 ) beg = p_arr [ l - 1 ] ; if ( q . contains ( beg + sum / 2 ) && ( beg + sum / 2 ) != ( int ) q . toArray ( ) [ q . size ( ) - 1 ] ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
int findRing ( int arr [ ] [ ] , int x ) { if ( arr [ 0 ] [ 0 ] > x ) return - 1 ; int l = 0 , r = ( n + 1 ) / 2 - 1 ; if ( n % 2 == 1 && arr [ r ] [ r ] < x ) return - 1 ; if ( n % 2 == 0 && arr [ r + 1 ] [ r ] < x ) return - 1 ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( arr [ mid ] [ mid ] <= x ) if ( mid == ( n + 1 ) / 2 - 1 arr [ mid + 1 ] [ mid + 1 ] > x ) return mid ; else l = mid + 1 ; else r = mid - 1 ; } return r ; }
int binarySearchRowInc ( int arr [ ] [ ] , int row , int l , int r , int x ) { while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( arr [ row ] [ mid ] == x ) return mid ; if ( arr [ row ] [ mid ] < x ) l = mid + 1 ; else r = mid - 1 ; } return - 1 ; }
int binarySearchColumnInc ( int arr [ ] [ ] , int col , int t , int b , int x ) { while ( t <= b ) { int mid = ( t + b ) / 2 ; if ( arr [ mid ] [ col ] == x ) return mid ; if ( arr [ mid ] [ col ] < x ) t = mid + 1 ; else b = mid - 1 ; } return - 1 ; }
int binarySearchRowDec ( int arr [ ] [ ] , int row , int l , int r , int x ) { while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( arr [ row ] [ mid ] == x ) return mid ; if ( arr [ row ] [ mid ] < x ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; }
int binarySearchColumnDec ( int arr [ ] [ ] , int col , int t , int b , int x ) { while ( t <= b ) { int mid = ( t + b ) / 2 ; if ( arr [ mid ] [ col ] == x ) return mid ; if ( arr [ mid ] [ col ] < x ) b = mid - 1 ; else t = mid + 1 ; } return - 1 ; }
int minIndex ( int arr [ ] , int n , int pos ) { int num = arr [ pos ] ; int i = pos - 1 ; while ( i >= 0 ) { if ( arr [ i ] != num ) break ; i -- ; } return i + 1 ; }
int minIndex ( int arr [ ] , int pos ) { int low = 0 ; int high = pos ; int i = pos ; while ( low < high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] != arr [ pos ] ) { low = mid + 1 ; } else { high = mid - 1 ; i = mid ; if ( mid > 0 && arr [ mid - 1 ] != arr [ pos ] ) { break ; } } } return arr [ low ] == arr [ pos ] ? low : i ; }
int findAnswer ( String str1 , String str2 , int n ) { int l = 0 , r = 0 ; int ans = 2 ; for ( int i = 0 ; i < n ; ++ i ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) { l = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) { r = i ; break ; } } if ( r < l ) return 26 * ( n + 1 ) ; else if ( l == r ) return ans ; else { for ( int i = l + 1 ; i <= r ; i ++ ) { if ( str1 . charAt ( i ) != str2 . charAt ( i - 1 ) ) { ans -- ; break ; } } for ( int i = l + 1 ; i <= r ; i ++ ) { if ( str1 . charAt ( i - 1 ) != str2 . charAt ( i ) ) { ans -- ; break ; } } return ans ; } }
int ternarySearch ( int l , int r , int key , int ar [ ] ) { if ( r >= l ) { int mid1 = l + ( r - l ) / 3 ; int mid2 = r - ( r - l ) / 3 ; if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; } if ( key < ar [ mid1 ] ) { return ternarySearch ( l , mid1 - 1 , key , ar ) ; } else if ( key > ar [ mid2 ] ) { return ternarySearch ( mid2 + 1 , r , key , ar ) ; } else { return ternarySearch ( mid1 + 1 , mid2 - 1 , key , ar ) ; } } return - 1 ; }
int ternarySearch ( int l , int r , int key , int ar [ ] ) { while ( r >= l ) { int mid1 = l + ( r - l ) / 3 ; int mid2 = r - ( r - l ) / 3 ; if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; } if ( key < ar [ mid1 ] ) { r = mid1 - 1 ; } else if ( key > ar [ mid2 ] ) { l = mid2 + 1 ; } else { l = mid1 + 1 ; r = mid2 - 1 ; } } return - 1 ; }
int countSubArrays ( int arr [ ] , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = 0 ; for ( int k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; }
void build ( int arr [ ] , int node , int start , int end ) { if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } int mid = ( start + end ) >> 1 ; build ( arr , 2 * node , start , mid ) ; build ( arr , 2 * node + 1 , mid + 1 , end ) ; tree [ node ] = tree [ 2 * node ] | tree [ 2 * node + 1 ] ; }
int query ( int node , int start , int end , int l , int r ) { if ( start > end start > r end < l ) { return 0 ; } if ( start >= l && end <= r ) { return tree [ node ] ; } int mid = ( start + end ) >> 1 ; int q1 = query ( 2 * node , start , mid , l , r ) ; int q2 = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return q1 | q2 ; }
int countSubArrays ( int arr [ ] , int n , int K ) { build ( arr , 1 , 0 , n - 1 ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = query ( 1 , 0 , n - 1 , i , j ) ; if ( bitwise_or >= K ) count ++ ; } } return count ; }
void build ( int [ ] arr , int node , int start , int end ) { if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } int mid = ( start + end ) >> 1 ; build ( arr , 2 * node , start , mid ) ; build ( arr , 2 * node + 1 , mid + 1 , end ) ; tree [ node ] = tree [ 2 * node ] | tree [ 2 * node + 1 ] ; }
int query ( int node , int start , int end , int l , int r ) { if ( start > end start > r end < l ) { return 0 ; } if ( start >= l && end <= r ) { return tree [ node ] ; } int mid = ( start + end ) >> 1 ; int q1 = query ( 2 * node , start , mid , l , r ) ; int q2 = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return q1 | q2 ; }
int countSubArrays ( int [ ] arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int low = i , high = n - 1 , index = Integer . MAX_VALUE ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( query ( 1 , 0 , n - 1 , i , mid ) >= K ) { index = Math . min ( index , mid ) ; high = mid - 1 ; } else { low = mid + 1 ; } } if ( index != Integer . MAX_VALUE ) { count += n - index ; } } return count ; }
int max_min ( int a [ ] , int n ) { Arrays . sort ( a ) ; return Math . min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; }
int max_min ( int a [ ] , int n ) { if ( n <= 1 ) return Integer . MAX_VALUE ; int f_min = a [ 0 ] , s_min = Integer . MAX_VALUE ; int f_max = a [ 0 ] , s_max = Integer . MIN_VALUE ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= f_min ) { s_min = f_min ; f_min = a [ i ] ; } else if ( a [ i ] < s_min ) { s_min = a [ i ] ; } if ( a [ i ] >= f_max ) { s_max = f_max ; f_max = a [ i ] ; } else if ( a [ i ] > s_max ) { s_max = a [ i ] ; } } return Math . min ( ( f_max - s_min ) , ( s_max - f_min ) ) ; }
int findMinDifference ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int diff1 = arr [ n - 1 ] - arr [ 1 ] ; int diff2 = arr [ n - 2 ] - arr [ 0 ] ; return Math . min ( diff1 , diff2 ) ; }
int findMinDifference ( int arr [ ] , int n ) { int min , secondMin , max , secondMax ; min = secondMax = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 0 ] : arr [ 1 ] ; max = secondMin = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 1 ] : arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { secondMax = max ; max = arr [ i ] ; } else if ( arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } else if ( arr [ i ] < min ) { secondMin = min ; min = arr [ i ] ; } else if ( arr [ i ] < secondMin ) { secondMin = arr [ i ] ; } } int diff = Math . min ( max - secondMin , secondMax - min ) ; return diff ; }
int minimal ( int a [ ] , int n ) { int lo = 0 , hi = n - 1 ; while ( lo < hi ) { int mid = ( lo + hi ) >> 1 ; if ( a [ mid ] < a [ mid + 1 ] ) { hi = mid ; } else { lo = mid + 1 ; } } return lo ; }
int findCount ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( checkDistinct ( i ) ) count += 1 ; } return count ; }
int countDigits ( int n ) { int count = 0 ; while ( n > 0 ) { count += 1 ; n /= 10 ; } return count ; }
int findCount ( int L , int R ) { int count = 0 ; int countDigitsL = countDigits ( L ) ; int countDigitsR = countDigits ( R ) ; int firstDigitL = ( L / ( int ) Math . pow ( 10 , countDigitsL - 1 ) ) ; int firstDigitR = ( R / ( int ) Math . pow ( 10 , countDigitsR - 1 ) ) ; if ( countDigitsL < countDigitsR ) { count += ( 9 * ( countDigitsR - countDigitsL - 1 ) ) ; if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) count += ( 9 - firstDigitL + 1 ) ; else count += ( 9 - firstDigitL ) ; if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) count += firstDigitR ; else count += ( firstDigitR - 1 ) ; } else { if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) count += ( 9 - firstDigitL + 1 ) ; else count += ( 9 - firstDigitL ) ; if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) count -= ( 9 - firstDigitR ) ; else count -= ( 9 - firstDigitR + 1 ) ; } return count ; }
int LowerInsertionPoint ( int arr [ ] , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; }
int getRightMin ( int arr [ ] , int n ) { int min = arr [ 0 ] ; int rightMin = 0 ; int i = 1 ; while ( i < n ) { if ( arr [ i ] == min ) rightMin = i ; i *= 2 ; } i = rightMin + 1 ; while ( i < n && arr [ i ] == min ) { rightMin = i ; i ++ ; } return rightMin ; }
int getLeftMax ( int arr [ ] , int n ) { int max = arr [ n - 1 ] ; int leftMax = n - 1 ; int i = n - 2 ; while ( i > 0 ) { if ( arr [ i ] == max ) leftMax = i ; i /= 2 ; } i = leftMax - 1 ; while ( i >= 0 && arr [ i ] == max ) { leftMax = i ; i -- ; } return leftMax ; }
void SieveOfEratosthenes ( ) { int isPrime [ ] = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) isPrime [ i ] = 1 ; isPrime [ 0 ] = isPrime [ 1 ] = 0 ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( isPrime [ i ] == 1 ) { for ( int j = i * 2 ; j < MAX ; j += i ) isPrime [ j ] = 0 ; } } for ( int i = 1 ; i < MAX ; i ++ ) { primeUpto [ i ] = primeUpto [ i - 1 ] ; if ( isPrime [ i ] == 1 ) primeUpto [ i ] ++ ; } }
int countOfNumbers ( int N , int K ) { SieveOfEratosthenes ( ) ; int low = 1 , high = N , ans = 0 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( mid - primeUpto [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } ans = ans != 0 ? N - ans + 1 : 0 ; return ans ; }
int minIndex ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( 2 * arr [ i ] == sum ) return ( i + 1 ) ; } return - 1 ; }
int smallest_pair ( int [ ] a , int n ) { int min = Integer . MAX_VALUE , secondMin = Integer . MAX_VALUE ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] < min ) { secondMin = min ; min = a [ j ] ; } else if ( ( a [ j ] < secondMin ) && a [ j ] != min ) secondMin = a [ j ] ; } return ( secondMin + min ) ; }
boolean checkSorted ( int n , int arr [ ] ) { int first = 0 , second = 0 ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { count ++ ; if ( first == 0 ) first = i ; else second = i ; } } if ( count > 2 ) return false ; if ( count == 0 ) return true ; if ( count == 2 ) swap ( arr , first - 1 , second ) ; else if ( count == 1 ) swap ( arr , first - 1 , first ) ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] < arr [ i - 1 ] ) return false ; return true ; }
int countWays ( int [ ] arr , int n ) { int max_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) max_val = Math . max ( max_val , arr [ i ] ) ; int [ ] freq = new int [ max_val + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; ans += freq [ 0 ] * ( freq [ 0 ] - 1 ) * ( freq [ 0 ] - 2 ) / 6 ; for ( int i = 1 ; i <= max_val ; i ++ ) ans += freq [ 0 ] * freq [ i ] * ( freq [ i ] - 1 ) / 2 ; for ( int i = 1 ; 2 * i <= max_val ; i ++ ) ans += freq [ i ] * ( freq [ i ] - 1 ) / 2 * freq [ 2 * i ] ; for ( int i = 1 ; i <= max_val ; i ++ ) { for ( int j = i + 1 ; i + j <= max_val ; j ++ ) ans += freq [ i ] * freq [ j ] * freq [ i + j ] ; } return ans ; }
boolean checkIndices ( int Arr [ ] , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] != Arr [ j ] ) { if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) return true ; } } } return false ; }
public int LongestSubarray ( int arr [ ] , int n , int k ) { int count = 1 ; int max_length = 1 ; int prev_mod = arr [ 0 ] % k ; for ( int i = 1 ; i < n ; i ++ ) { int curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = Math . max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return Math . max ( max_length , count ) ; }
int getCount ( int [ ] v , int n ) { Arrays . sort ( v ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int tmp = n - 1 - upperBound ( v , n , v [ i ] - 1 ) ; if ( tmp == v [ i ] ) cnt ++ ; } return cnt ; }
boolean binarySearch1D ( int arr [ ] , int K ) { int low = 0 ; int high = N - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == K ) { return true ; } if ( arr [ mid ] < K ) { low = mid + 1 ; } else { high = mid - 1 ; } } return false ; }
boolean searchMatrix ( int matrix [ ] [ ] , int K ) { int low = 0 ; int high = M - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( K >= matrix [ mid ] [ 0 ] && K <= matrix [ mid ] [ N - 1 ] ) { return binarySearch1D ( matrix [ mid ] , K ) ; } if ( K < matrix [ mid ] [ 0 ] ) { high = mid - 1 ; } else { low = mid + 1 ; } } return false ; }
int longestsubarray ( int arr [ ] , int n , int k ) { int current_count = 0 ; int max_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) current_count ++ ; else current_count = 0 ; max_count = Math . max ( current_count , max_count ) ; } return max_count ; }
int countSegments ( int a [ ] , int n , int x ) { boolean flag = false ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { flag = true ; } else { if ( flag ) count += 1 ; flag = false ; } } if ( flag ) count += 1 ; return count ; }
void findElements ( int arr [ ] , int n , int l , int r ) { Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { int a = 0 ; if ( mp . get ( arr [ i ] ) == null ) { a = 1 ; } else { a = mp . get ( arr [ i ] ) + 1 ; } mp . put ( arr [ i ] , a ) ; } for ( int i = 0 ; i < n ; ++ i ) { if ( l <= mp . get ( arr [ i ] ) && ( mp . get ( arr [ i ] ) <= r ) ) { System . out . print ( arr [ i ] + " " ) ; } } }
void findElementsAfterDel ( int [ ] arr , int m , int [ ] del , int n , int k ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( mp . containsKey ( del [ i ] ) ) { mp . put ( del [ i ] , mp . get ( del [ i ] ) + 1 ) ; } else { mp . put ( del [ i ] , 1 ) ; } } Vector < Integer > heap = new Vector < Integer > ( ) ; for ( int i = 0 ; i < m ; ++ i ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) - 1 ) ; if ( mp . get ( arr [ i ] ) == 0 ) mp . remove ( arr [ i ] ) ; } else heap . add ( arr [ i ] ) ; } Collections . sort ( heap ) ; for ( int i = 0 ; i < k ; ++ i ) { System . out . print ( heap . get ( 0 ) + " " ) ; heap . remove ( 0 ) ; } }
void removeElements ( int [ ] arr , int n , int k ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! mp . containsKey ( arr [ i ] ) ) mp . put ( arr [ i ] , 1 ) ; else { int x = mp . get ( arr [ i ] ) ; mp . put ( arr [ i ] , ++ x ) ; } } for ( int i = 0 ; i < n ; ++ i ) { if ( mp . get ( arr [ i ] ) >= k ) System . out . print ( arr [ i ] + " " ) ; } }
boolean check ( String s ) { for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) return true ; return false ; }
void RemoveElements ( int arr [ ] , int n , int k ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; } for ( int i = 0 ; i < n ; ++ i ) { if ( mp . containsKey ( arr [ i ] ) && mp . get ( arr [ i ] ) <= k ) { System . out . print ( arr [ i ] + " " ) ; } } }
int findSmallestAfterDel ( int arr [ ] , int m , int del [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( mp . containsKey ( del [ i ] ) ) { mp . put ( del [ i ] , mp . get ( del [ i ] ) + 1 ) ; } else { mp . put ( del [ i ] , 1 ) ; } } int smallestElement = Integer . MAX_VALUE ; for ( int i = 0 ; i < m ; ++ i ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) - 1 ) ; if ( mp . get ( arr [ i ] ) == 0 ) mp . remove ( arr [ i ] ) ; } else smallestElement = Math . min ( smallestElement , arr [ i ] ) ; } return smallestElement ; }
int findlargestAfterDel ( int arr [ ] , int m , int del [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( mp . containsKey ( del [ i ] ) ) { mp . put ( del [ i ] , mp . get ( del [ i ] ) + 1 ) ; } else { mp . put ( del [ i ] , 1 ) ; } } int largestElement = Integer . MIN_VALUE ; for ( int i = 0 ; i < m ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) - 1 ) ; if ( mp . get ( arr [ i ] ) == 0 ) mp . remove ( arr [ i ] ) ; } else largestElement = Math . max ( largestElement , arr [ i ] ) ; } return largestElement ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int divTermCount ( int a , int b , int lcm , int num ) { return num / a + num / b - num / lcm ; }
int findNthTerm ( int a , int b , int n ) { int low = 1 , high = Integer . MAX_VALUE , mid ; int lcm = ( a * b ) / gcd ( a , b ) ; while ( low < high ) { mid = low + ( high - low ) / 2 ; if ( divTermCount ( a , b , lcm , mid ) < n ) low = mid + 1 ; else high = mid ; } return low ; }
int LongestFibSubseq ( int A [ ] , int n ) { TreeSet < Integer > S = new TreeSet < > ( ) ; for ( int t : A ) { S . add ( t ) ; } int maxLen = 0 , x , y ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { x = A [ j ] ; y = A [ i ] + A [ j ] ; int length = 3 ; while ( S . contains ( y ) && ( y != S . last ( ) ) ) { int z = x + y ; x = y ; y = z ; maxLen = Math . max ( maxLen , ++ length ) ; } } } return maxLen >= 3 ? maxLen : 0 ; }
int numberOfElements ( int height [ ] , int n ) { int max_so_far = 0 ; int coun = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( height [ i ] > max_so_far ) { max_so_far = height [ i ] ; coun ++ ; } } return coun ; }
boolean isPossible ( int [ ] A , int n , int H , int K ) { int time = 0 ; for ( int i = 0 ; i < n ; ++ i ) time += ( A [ i ] - 1 ) / K + 1 ; return time <= H ; }
int minJobSpeed ( int [ ] A , int n , int H ) { if ( H < n ) return - 1 ; int max = findmax ( A ) ; int lo = 1 , hi = max ; while ( lo < hi ) { int mi = lo + ( hi - lo ) / 2 ; if ( ! isPossible ( A , n , H , mi ) ) lo = mi + 1 ; else hi = mi ; } return lo ; }
int kthSmallestLargest ( int [ ] arr , int n , int k ) { int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int hash [ ] = new int [ max_val + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } int count = 0 ; for ( int i = 0 ; i <= max_val ; i ++ ) { while ( hash [ i ] > 0 ) { count ++ ; if ( count == k ) { return i ; } hash [ i ] -- ; } } return - 1 ; }
int countAnomalies ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && Math . abs ( arr [ i ] - arr [ j ] ) <= k ) break ; if ( j == n ) res ++ ; } return res ; }
int countAnomalies ( int a [ ] , int n , int k ) { Arrays . sort ( a ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int u = upper_bound ( a , 0 , n , a [ i ] ) ; if ( u < n && a [ u ] - a [ i ] <= k ) continue ; int s = lower_bound ( a , 0 , n , a [ i ] ) ; if ( u - s > 1 ) continue ; if ( s > 0 && a [ s - 1 ] - a [ i ] <= k ) continue ; res ++ ; } return res ; }
void solve ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! m . containsKey ( arr [ i ] ) ) m . put ( arr [ i ] , 0 ) ; m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . get ( arr [ i ] ) == k && max == Integer . MIN_VALUE ) { max = arr [ i ] ; } else if ( m . get ( arr [ i ] ) == k && max < arr [ i ] ) { max = arr [ i ] ; } } if ( max == Integer . MIN_VALUE ) System . out . println ( "No such element" ) ; else System . out . println ( max ) ; }
int majorityInMatrix ( int arr [ ] [ ] ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( mp . containsKey ( arr [ i ] [ j ] ) ) mp . put ( arr [ i ] [ j ] , mp . get ( arr [ i ] [ j ] ) + 1 ) ; else mp . put ( arr [ i ] [ j ] , 1 ) ; } } int countMajority = 0 ; Iterator < HashMap . Entry < Integer , Integer > > itr = mp . entrySet ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { HashMap . Entry < Integer , Integer > entry = itr . next ( ) ; if ( entry . getValue ( ) >= ( ( N * M ) / 2 ) ) { countMajority ++ ; } } return countMajority ; }
int getMin ( int arr [ ] , int n ) { int res = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) res = Math . min ( res , arr [ i ] ) ; return res ; }
int findSum ( int arr [ ] , int n ) { int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; return min + max ; }
int findProduct ( int arr [ ] , int n ) { int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; return min * max ; }
void countEle ( Stack < Integer > s , int [ ] a , int N ) { HashMap < Integer , Boolean > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { int num = a [ i ] ; if ( mp . containsKey ( num ) ) System . out . print ( "0 " ) ; else { int cnt = 0 ; while ( s . peek ( ) != num ) { mp . put ( s . peek ( ) , true ) ; s . pop ( ) ; cnt ++ ; } s . pop ( ) ; cnt ++ ; System . out . print ( cnt + " " ) ; } } }
int bsearch ( Vector < Integer > A , int key_to_search ) { int n = ( int ) A . size ( ) ; int lg = BigIntegerMath . log2 ( BigInteger . valueOf ( n - 1 ) , RoundingMode . UNNECESSARY ) + 1 ; int pos = 0 ; for ( int i = lg - 1 ; i >= 0 ; i -- ) { if ( A . get ( pos ) == key_to_search ) { return pos ; } int new_pos = pos | ( 1 << i ) ; if ( ( new_pos < n ) && ( A . get ( new_pos ) <= key_to_search ) ) { pos = new_pos ; } } return ( ( A . get ( pos ) == key_to_search ) ? pos : - 1 ) ; }
int colMaxDiff ( int mat [ ] [ ] ) { int max_diff = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { int max_val = mat [ 0 ] [ i ] , min_val = mat [ 0 ] [ i ] ; for ( int j = 1 ; j < N ; j ++ ) { max_val = Math . max ( max_val , mat [ j ] [ i ] ) ; min_val = Math . min ( min_val , mat [ j ] [ i ] ) ; } max_diff = Math . max ( max_diff , max_val - min_val ) ; } return max_diff ; }
int countChar ( String str ) { int n = str . length ( ) ; if ( n <= 2 ) return n ; int count = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( str . charAt ( i - 1 ) == str . charAt ( i + 1 ) ) count ++ ; return count ; }
float findmedian ( int a [ ] , int n1 , int b [ ] , int n2 ) { int i = 0 ; int j = 0 ; int k ; int m1 = - 1 , m2 = - 1 ; for ( k = 0 ; k <= ( n1 + n2 ) / 2 ; k ++ ) { if ( i < n1 && j < n2 ) { if ( a [ i ] < b [ j ] ) { m2 = m1 ; m1 = a [ i ] ; i ++ ; } else { m2 = m1 ; m1 = b [ j ] ; j ++ ; } } else if ( i == n1 ) { m2 = m1 ; m1 = b [ j ] ; j ++ ; } else if ( j == n2 ) { m2 = m1 ; m1 = a [ i ] ; i ++ ; } } if ( ( n1 + n2 ) % 2 == 0 ) { return ( m1 + m2 ) * ( float ) 1.0 / 2 ; } return m1 ; }
int search ( int ar [ ] , int size ) { int a = 0 , b = size - 1 ; int mid = 0 ; while ( ( b - a ) > 1 ) { mid = ( a + b ) / 2 ; if ( ( ar [ a ] - a ) != ( ar [ mid ] - mid ) ) b = mid ; else if ( ( ar [ b ] - b ) != ( ar [ mid ] - mid ) ) a = mid ; } return ( ar [ a ] + 1 ) ; }
int deleteElement ( int A [ ] , int L , int R , int N ) { int i , j = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i <= L i >= R ) { A [ j ] = A [ i ] ; j ++ ; } } return j ; }
boolean search ( int [ ] arr , int n , int x ) { int res = - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res = i ; if ( res == - 1 ) return false ; int temp = arr [ res ] ; for ( int i = res ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = temp ; return true ; }
float kPresentProbability ( int a [ ] , int n , int k ) { float count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == k ) count ++ ; return count / n ; }
int binarySearch ( int [ ] searchSpace , int s , int e , int num ) { int ans = 0 ; while ( s <= e ) { int mid = ( s + e ) / 2 ; if ( searchSpace [ mid ] >= num ) { ans = mid ; e = mid - 1 ; } else s = mid + 1 ; } return ans ; }
int longestSubArr ( int [ ] arr , int n ) { int [ ] searchSpace = new int [ n ] ; int [ ] index = new int [ n ] ; int j = 0 ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( j == 0 searchSpace [ j - 1 ] < arr [ i ] ) { searchSpace [ j ] = arr [ i ] ; index [ j ] = i ; j ++ ; } int idx = binarySearch ( searchSpace , 0 , j - 1 , arr [ i ] ) ; ans = Math . max ( ans , i - index [ idx ] + 1 ) ; } return ans ; }
int findmissing ( int [ ] ar , int N ) { int l = 0 , r = N - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( ar [ mid ] != mid + 1 && ar [ mid - 1 ] == mid ) return ( mid + 1 ) ; if ( ar [ mid ] != mid + 1 ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; }
int findFirst ( int arr [ ] , int n , int x ) { Arrays . sort ( arr ) ; int ptr = lowerBound ( arr , 0 , n , x ) ; return ( arr [ ptr ] != x ) ? - 1 : ( ptr ) ; }
int findFirst ( int arr [ ] , int n , int x ) { int count = 0 ; boolean isX = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) { isX = true ; } else if ( arr [ i ] < x ) { count ++ ; } } return ( isX == false ) ? - 1 : count ; }
int findDuplicate ( int [ ] arr ) { int slow = arr [ 0 ] ; int fast = arr [ 0 ] ; do { slow = arr [ slow ] ; fast = arr [ arr [ fast ] ] ; } while ( slow != fast ) ; int ptr1 = arr [ 0 ] ; int ptr2 = slow ; while ( ptr1 != ptr2 ) { ptr1 = arr [ ptr1 ] ; ptr2 = arr [ ptr2 ] ; } return ptr1 ; }
boolean isSafe ( int x , int y , int sol [ ] [ ] ) { return ( x >= 0 && x < N && y >= 0 && y < N && sol [ x ] [ y ] == - 1 ) ; }
void prevGreater ( int arr [ ] , int n ) { System . out . print ( "-1, " ) ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { System . out . print ( arr [ j ] + ", " ) ; break ; } } if ( j == - 1 ) System . out . print ( "-1, " ) ; } }
void prevGreater ( int arr [ ] , int n ) { Stack < Integer > s = new Stack < Integer > ( ) ; s . push ( arr [ 0 ] ) ; System . out . print ( "-1, " ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( s . empty ( ) == false && s . peek ( ) < arr [ i ] ) s . pop ( ) ; if ( s . empty ( ) == true ) System . out . print ( "-1, " ) ; else System . out . print ( s . peek ( ) + ", " ) ; s . push ( arr [ i ] ) ; } }
void printGreaterCount ( String str ) { int len = str . length ( ) , right [ ] = new int [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = i + 1 ; j < len ; j ++ ) { if ( str . charAt ( i ) < str . charAt ( j ) ) { right [ i ] ++ ; } } } for ( int i = 0 ; i < len ; i ++ ) { System . out . print ( right [ i ] + " " ) ; } }
void printGreaterCount ( String str ) { int len = str . length ( ) ; int ans [ ] = new int [ len ] , count [ ] = new int [ MAX_CHAR ] ; for ( int i = len - 1 ; i >= 0 ; i -- ) { count [ str . charAt ( i ) - 'a' ] ++ ; for ( int j = str . charAt ( i ) - 'a' + 1 ; j < MAX_CHAR ; j ++ ) { ans [ i ] += count [ j ] ; } } for ( int i = 0 ; i < len ; i ++ ) { System . out . print ( ans [ i ] + " " ) ; } }
int findMissingNo ( int [ ] arr , int n ) { int val ; int nextval ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= 0 arr [ i ] > n ) continue ; val = arr [ i ] ; while ( arr [ val - 1 ] != val ) { nextval = arr [ val - 1 ] ; arr [ val - 1 ] = val ; val = nextval ; if ( val <= 0 val > n ) break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != i + 1 ) { return i + 1 ; } } return n + 1 ; }
int solve ( int [ ] a , int n ) { int max1 = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( Math . abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = Math . abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; }
int solve ( int a [ ] , int n ) { int min1 = a [ 0 ] ; int max1 = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return Math . abs ( min1 - max1 ) ; }
int maxProduct ( int arr [ ] , int n ) { if ( n < 4 ) return - 1 ; int max_product = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 3 ; i ++ ) for ( int j = i + 1 ; j < n - 2 ; j ++ ) for ( int k = j + 1 ; k < n - 1 ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] * arr [ l ] ) ; return max_product ; }
int maxSum ( int arr [ ] , int n ) { if ( n < 2 ) return - 1 ; int ans = arr [ 0 ] + arr [ 1 ] ; for ( int i = 1 ; i + 1 < n ; i ++ ) ans = Math . min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) ; return ans ; }
int getCount ( int M , int N ) { int count = 0 ; if ( M == 1 ) return N ; if ( N == 1 ) return M ; if ( N > M ) { for ( int i = 1 ; i <= M ; i ++ ) { int numerator = N * i - N + M - i ; int denominator = M - 1 ; if ( numerator % denominator == 0 ) { int j = numerator / denominator ; if ( j >= 1 && j <= N ) count ++ ; } } } else { for ( int j = 1 ; j <= N ; j ++ ) { int numerator = M * j - M + N - j ; int denominator = N - 1 ; if ( numerator % denominator == 0 ) { int i = numerator / denominator ; if ( i >= 1 && i <= M ) count ++ ; } } } return count ; }
int countTripletsLessThanL ( int n , int L , int [ ] arr ) { Arrays . sort ( arr ) ; int ways = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { int mostDistantDistance = arr [ k ] - arr [ i ] ; if ( mostDistantDistance <= L ) { ways ++ ; } } } } return ways ; }
int appearsNBy3 ( int arr [ ] , int n ) { int count1 = 0 , count2 = 0 ; int first = Integer . MIN_VALUE ; ; int second = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( first == arr [ i ] ) count1 ++ ; else if ( second == arr [ i ] ) count2 ++ ; else if ( count1 == 0 ) { count1 ++ ; first = arr [ i ] ; } else if ( count2 == 0 ) { count2 ++ ; second = arr [ i ] ; } else { count1 -- ; count2 -- ; } } count1 = 0 ; count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == first ) count1 ++ ; else if ( arr [ i ] == second ) count2 ++ ; } if ( count1 > n / 3 ) return first ; if ( count2 > n / 3 ) return second ; return - 1 ; }
int binary_lower ( int value , int arr [ ] , int n ) { int start = 0 ; int end = n - 1 ; int ans = - 1 ; int mid ; while ( start <= end ) { mid = ( start + end ) / 2 ; if ( arr [ mid ] >= value ) { end = mid - 1 ; ans = mid ; } else { start = mid + 1 ; } } return ans ; }
int countTriplet ( int arr [ ] , int n , int k ) { int count = 0 ; Arrays . sort ( arr ) ; for ( int i = 2 ; i < n ; i ++ ) { int cur = binary_lower ( arr [ i ] - k , arr , n ) ; if ( cur <= i - 2 ) { count += ( ( i - cur ) * ( i - cur - 1 ) ) / 2 ; } } return count ; }
boolean isSuffix ( String s1 , String s2 ) { int n1 = s1 . length ( ) , n2 = s2 . length ( ) ; if ( n1 > n2 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( s1 . charAt ( n1 - i - 1 ) != s2 . charAt ( n2 - i - 1 ) ) return false ; return true ; }
void replaceOriginal ( String s , int n ) { char r [ ] = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s . charAt ( n - 1 - i ) ; if ( s . charAt ( i ) != 'a' && s . charAt ( i ) != 'e' && s . charAt ( i ) != 'i' && s . charAt ( i ) != 'o' && s . charAt ( i ) != 'u' ) { System . out . print ( r [ i ] ) ; } } System . out . println ( "" ) ; }
boolean swapElement ( int [ ] arr1 , int [ ] arr2 , int n ) { int wrongIdx = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr1 [ i ] < arr1 [ i - 1 ] ) { wrongIdx = i ; } } int maximum = Integer . MIN_VALUE ; int maxIdx = - 1 ; boolean res = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr2 [ i ] > maximum && arr2 [ i ] >= arr1 [ wrongIdx - 1 ] ) { if ( wrongIdx + 1 <= n - 1 && arr2 [ i ] <= arr1 [ wrongIdx + 1 ] ) { maximum = arr2 [ i ] ; maxIdx = i ; res = true ; } } } if ( res ) { swap ( arr1 , wrongIdx , arr2 , maxIdx ) ; } return res ; }
boolean ElementsCalculationFunc ( int pre [ ] , int maxx [ ] , int x , int k , int n ) { for ( int i = 0 , j = x ; j <= n ; j ++ , i ++ ) { if ( x * maxx [ j ] - ( pre [ j ] - pre [ i ] ) <= k ) return true ; } return false ; }
int costToBalance ( String s ) { if ( s . length ( ) == 0 ) System . out . println ( 0 ) ; int ans = 0 ; int o = 0 , c = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '(' ) o ++ ; if ( s . charAt ( i ) == ')' ) c ++ ; } if ( o != c ) return - 1 ; int [ ] a = new int [ s . length ( ) ] ; if ( s . charAt ( 0 ) == '(' ) a [ 0 ] = 1 ; else a [ 0 ] = - 1 ; if ( a [ 0 ] < 0 ) ans += Math . abs ( a [ 0 ] ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '(' ) a [ i ] = a [ i - 1 ] + 1 ; else a [ i ] = a [ i - 1 ] - 1 ; if ( a [ i ] < 0 ) ans += Math . abs ( a [ i ] ) ; } return ans ; }
boolean checkIfAllTogether ( String s , char c ) { boolean oneSeen = false ; int i = 0 , n = s . length ( ) ; while ( i < n ) { if ( s . charAt ( i ) == c ) { if ( oneSeen == true ) return false ; while ( i < n && s . charAt ( i ) == c ) i ++ ; oneSeen = true ; } else i ++ ; } return true ; }
int f ( int n ) { return n * ( 2 * n * n - 1 ) ; }
boolean binarySearch ( int low , int high , int x ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( f ( mid ) < x ) low = mid + 1 ; else if ( f ( mid ) > x ) high = mid - 1 ; else return true ; } return false ; }
boolean isStellaOctangula ( int x ) { if ( x == 0 ) return true ; int i = 1 ; while ( f ( i ) < x ) i = i * 2 ; if ( f ( i ) == x ) return true ; return binarySearch ( i / 2 , i , x ) ; }
boolean search ( int arr [ ] , int n , int x ) { int front = 0 , back = n - 1 ; while ( front <= back ) { if ( arr [ front ] == x arr [ back ] == x ) return true ; front ++ ; back -- ; } return false ; }
boolean isSafe ( boolean [ ] [ ] graph , int [ ] color ) { for ( int i = 0 ; i < V ; i ++ ) for ( int j = i + 1 ; j < V ; j ++ ) if ( graph [ i ] [ j ] && color [ j ] == color [ i ] ) return false ; return true ; }
boolean graphColoring ( boolean [ ] [ ] graph , int m , int i , int [ ] color ) { if ( i == V ) { if ( isSafe ( graph , color ) ) { printSolution ( color ) ; return true ; } return false ; } for ( int j = 1 ; j <= m ; j ++ ) { color [ i ] = j ; if ( graphColoring ( graph , m , i + 1 , color ) ) return true ; color [ i ] = 0 ; } return false ; }
int getGreatestSum ( int a [ ] [ ] ) { int prev_max = 0 ; for ( int j = 0 ; j < N ; j ++ ) if ( prev_max < a [ N - 1 ] [ j ] ) prev_max = a [ N - 1 ] [ j ] ; int sum = prev_max ; for ( int i = N - 2 ; i >= 0 ; i -- ) { int curr_max = - 2147483648 ; for ( int j = 0 ; j < N ; j ++ ) if ( prev_max > a [ i ] [ j ] && a [ i ] [ j ] > curr_max ) curr_max = a [ i ] [ j ] ; if ( curr_max == - 2147483648 ) return - 1 ; prev_max = curr_max ; sum += prev_max ; } return sum ; }
int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
int missingNum ( int arr [ ] , int n ) { List < Integer > list = new ArrayList < > ( arr . length ) ; for ( int i : arr ) { list . add ( Integer . valueOf ( i ) ) ; } int minvalue = Collections . min ( list ) ; ; int xornum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xornum ^= ( minvalue ) ^ arr [ i ] ; minvalue ++ ; } return xornum ^ minvalue ; }
void findElement ( int n , int k ) { int ans = n ; int left = 1 ; int right = ( int ) ( Math . pow ( 2 , n ) - 1 ) ; while ( true ) { int mid = ( left + right ) / 2 ; if ( k == mid ) { System . out . println ( ans ) ; break ; } ans -- ; if ( k < mid ) { right = mid - 1 ; } else { left = mid + 1 ; } } }
int firstCommon ( Node head1 , Node head2 ) { for ( ; head1 != null ; head1 = head1 . next ) for ( Node p = head2 ; p != null ; p = p . next ) if ( p . data == head1 . data ) return head1 . data ; return 0 ; }
int findmin ( Point p [ ] , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] . x <= 0 ) a ++ ; else if ( p [ i ] . x >= 0 ) b ++ ; if ( p [ i ] . y >= 0 ) c ++ ; else if ( p [ i ] . y <= 0 ) d ++ ; } return Math . min ( Math . min ( a , b ) , Math . min ( c , d ) ) ; }
int findLastIndex ( String str , Character x ) { int index = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) == x ) index = i ; return index ; }
int findLastIndex ( String str , Character x ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == x ) return i ; return - 1 ; }
int checkBit ( int pattern , int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( ( pattern & arr [ i ] ) == pattern ) count ++ ; return count ; }
int countMaxSumPairs ( int a [ ] , int n ) { int first = Integer . MIN_VALUE , second = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > first ) { second = first ; first = a [ i ] ; } else if ( a [ i ] > second && a [ i ] != first ) second = a [ i ] ; } int cnt1 = 0 , cnt2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == first ) cnt1 ++ ; if ( a [ i ] == second ) cnt2 ++ ; } if ( cnt1 == 1 ) return cnt2 ; if ( cnt1 > 1 ) return cnt1 * ( cnt1 - 1 ) / 2 ; return 0 ; }
int middleOfThree ( int a , int b , int c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; }
int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }
int findValue ( int X , int Y , int P ) { if ( P % 2 == 0 ) return ( Math . max ( X , Y ) / Math . min ( X , Y ) ) ; else return ( Math . max ( 2 * X , Y ) / Math . min ( 2 * X , Y ) ) ; }
int countMaxSetBits ( int left , int right ) { int max_count = - 1 , num = 0 ; for ( int i = left ; i <= right ; ++ i ) { int temp = i , cnt = 0 ; while ( temp > 0 ) { if ( temp % 2 == 1 ) ++ cnt ; temp >>= 1 ; } if ( cnt > max_count ) { max_count = cnt ; num = i ; } } return num ; }
int sum ( int arr [ ] , int from , int to ) { int total = 0 ; for ( int i = from ; i <= to ; i ++ ) total += arr [ i ] ; return total ; }
int findMax ( int arr [ ] , int n , int k ) { int dp [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) dp [ 1 ] [ i ] = sum ( arr , 0 , i - 1 ) ; for ( int i = 1 ; i <= k ; i ++ ) dp [ i ] [ 1 ] = arr [ 0 ] ; for ( int j = 2 ; j <= n ; j ++ ) { int best = Integer . MAX_VALUE ; for ( int p = 1 ; p <= j ; p ++ ) best = Math . min ( best , Math . max ( dp [ i - 1 ] [ p ] , sum ( arr , p , j - 1 ) ) ) ; dp [ i ] [ j ] = best ; } }
int findFloor ( Node root , int key ) { Node curr = root , ans = null ; while ( curr != null ) { if ( curr . key <= key ) { ans = curr ; curr = curr . right ; } else curr = curr . left ; } if ( ans != null ) return ans . key ; return - 1 ; }
int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n ; if ( sum == s ) return n ; } return - 1 ; }
int isvalid ( int s ) { double k = ( - 1.0 + Math . sqrt ( 1 + 8 * s ) ) / 2 ; if ( Math . ceil ( k ) == Math . floor ( k ) ) return ( int ) k ; else return - 1 ; }
int calcSafe ( int pos ) { int j = pos % 10 ; int i = pos / 10 ; int dis_11 = Math . min ( Math . abs ( 1 - i ) , Math . abs ( 1 - j ) ) ; int dis_18 = Math . min ( Math . abs ( 1 - i ) , Math . abs ( 8 - j ) ) ; int dis_81 = Math . min ( Math . abs ( 8 - i ) , Math . abs ( 1 - j ) ) ; int dis_88 = Math . min ( Math . abs ( 8 - i ) , Math . abs ( 8 - j ) ) ; int sum = dis_11 + dis_18 + dis_81 + dis_88 + 1 ; return ( 64 - sum ) ; }
int countCrossLine ( int arr [ ] , int n ) { int count_crossline = 0 ; int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; count_crossline ++ ; } arr [ j + 1 ] = key ; } return count_crossline ; }
int getCount ( int arr [ ] , int n , int num1 , int num2 ) { int i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; int j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; }
boolean check_elements ( int arr [ ] , int n , int A , int B ) { int range = B - A ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . abs ( arr [ i ] ) >= A && Math . abs ( arr [ i ] ) <= B ) { int z = Math . abs ( arr [ i ] ) - A ; if ( arr [ z ] > 0 ) { arr [ z ] = arr [ z ] * - 1 ; } } } int count = 0 ; for ( int i = 0 ; i <= range && i < n ; i ++ ) { if ( arr [ i ] > 0 ) return false ; else count ++ ; } if ( count != ( range + 1 ) ) return false ; return true ; }
int sumOfDigit ( int K ) { int sod = 0 ; while ( K != 0 ) { sod += K % 10 ; K /= 10 ; } return sod ; }
int findMinRec ( int A [ ] , int n ) { if ( n == 1 ) return A [ 0 ] ; return Math . min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) ; }
int findMaxRec ( int A [ ] , int n ) { if ( n == 1 ) return A [ 0 ] ; return Math . max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) ) ; }
int getRandom ( int x , int y ) { return ( int ) ( x + Math . random ( ) * 10 % ( y - x + 1 ) ) ; }
int randomizedBinarySearch ( int arr [ ] , int l , int r , int x ) { while ( l <= r ) { int m = getRandom ( l , r ) ; if ( arr [ m ] == x ) return m ; if ( arr [ m ] < x ) l = m + 1 ; else r = m - 1 ; } return - 1 ; }
int countBuildings ( int arr [ ] , int n ) { int count = 1 ; int curr_max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > curr_max arr [ i ] == curr_max ) { count ++ ; curr_max = arr [ i ] ; } } return count ; }
int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; }
int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { int index = n ; int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }
int findPages ( int arr [ ] , int n , int m ) { long sum = 0 ; if ( n < m ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int start = 0 , end = ( int ) sum ; int result = Integer . MAX_VALUE ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( isPossible ( arr , n , m , mid ) ) { result = mid ; end = mid - 1 ; } else start = mid + 1 ; } return result ; }
int minCostToMakeElementEqual ( int arr [ ] , int N ) { int low , high ; low = high = arr [ 0 ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( low > arr [ i ] ) low = arr [ i ] ; if ( high < arr [ i ] ) high = arr [ i ] ; } while ( ( high - low ) > 2 ) { int mid1 = low + ( high - low ) / 3 ; int mid2 = high - ( high - low ) / 3 ; int cost1 = computeCost ( arr , N , mid1 ) ; int cost2 = computeCost ( arr , N , mid2 ) ; if ( cost1 < cost2 ) high = mid2 ; else low = mid1 ; } return computeCost ( arr , N , ( low + high ) / 2 ) ; }
void minJumps ( int [ ] w , int [ ] l , int n ) { if ( n == 1 ) { System . out . print ( 0 ) ; return ; } int ans = 0 ; HashMap < Integer , Integer > pos = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > jump = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Boolean > filled = new HashMap < Integer , Boolean > ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( pos . containsKey ( w [ i ] ) ) pos . put ( w [ i ] , i ) ; else pos . put ( w [ i ] , i ) ; if ( filled . containsKey ( w [ i ] ) ) filled . put ( i , true ) ; else filled . put ( i , true ) ; if ( jump . containsKey ( w [ i ] ) ) jump . put ( w [ i ] , l [ i ] ) ; else jump . put ( w [ i ] , l [ i ] ) ; a [ i ] = w [ i ] ; } Arrays . sort ( a ) ; for ( int curr = 1 ; curr < n ; curr ++ ) { int currElementPos = pos . get ( a [ curr ] ) ; int prevElementPos = pos . get ( a [ curr - 1 ] ) ; if ( currElementPos > prevElementPos ) continue ; while ( currElementPos <= prevElementPos || filled . containsKey ( currElementPos ) && filled . containsKey ( currElementPos ) ) { currElementPos += jump . get ( a [ curr ] ) ; ans ++ ; } if ( pos . containsKey ( a [ curr ] ) ) pos . put ( a [ curr ] , currElementPos ) ; else pos . put ( a [ curr ] , currElementPos ) ; if ( filled . containsKey ( currElementPos ) ) filled . put ( currElementPos , true ) ; else filled . put ( currElementPos , true ) ; } System . out . print ( ans ) ; }
void check ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] >= ( i - 1 ) ) { int p = arr [ i - 1 ] - ( i - 1 ) ; arr [ i ] += p ; arr [ i - 1 ] -= p ; } } for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= arr [ i - 1 ] ) { System . out . println ( "No" ) ; return ; } } System . out . println ( "Yes" ) ; }
void minimumSize ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; reverse ( arr ) ; if ( count ( arr , 0 ) == N ) System . out . println ( 0 ) ; else if ( K >= N ) System . out . println ( 1 ) ; else System . out . println ( arr [ K ] ) ; }
void isPossibleToSort ( int arr [ ] , int N ) { int idx = - 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == 1 && arr [ i - 1 ] == 1 ) { idx = i ; break ; } } if ( idx == - 1 ) { System . out . println ( "YES" ) ; return ; } for ( int i = idx + 1 ; i < N ; i ++ ) { if ( arr [ i ] == 0 && arr [ i - 1 ] == 0 ) { System . out . println ( "NO" ) ; return ; } } System . out . println ( "YES" ) ; }
boolean check ( int arr [ ] , int n ) { int count = 0 ; int index = - 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] ) { count ++ ; index = i ; } } if ( count > 1 ) return false ; if ( count == 0 ) return true ; if ( index == n - 1 index == 1 ) return true ; if ( arr [ index - 1 ] < arr [ index + 1 ] ) return true ; if ( index - 2 >= 0 && arr [ index - 2 ] < arr [ index ] ) return true ; if ( index < 0 ) return true ; return false ; }
String isPossibleToSort ( int [ ] [ ] arr , int N ) { int group = arr [ 0 ] [ 1 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] [ 1 ] != group ) { return "Yes" ; } } if ( isSorted ( arr , N ) ) { return "Yes" ; } else { return "No" ; } }
int maximumSum ( int arr [ ] , int S [ ] , int N , int K ) { int ans = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < N / 2 ; i ++ ) { int temp = arr [ i ] ; arr [ i ] = arr [ N - 1 - i ] ; arr [ N - 1 - i ] = temp ; } for ( int i = 0 ; i < K ; i ++ ) ans += arr [ i ] ; Arrays . sort ( S ) ; for ( int i = 0 ; i < K ; i ++ ) { if ( S [ i ] == 1 ) ans += arr [ i ] ; S [ i ] -- ; } int counter = K - 1 ; for ( int i = 0 ; i < K ; i ++ ) { counter = counter + S [ i ] ; if ( S [ i ] != 0 ) ans += arr [ counter ] ; } return ans ; }
int minimumDeletion ( String s , int n ) { HashMap < Character , Integer > countMap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { char ch = s . charAt ( i ) ; countMap . put ( ch , countMap . getOrDefault ( ch , 0 ) + 1 ) ; } ArrayList < Integer > countMultiset = new ArrayList < > ( countMap . values ( ) ) ; Collections . sort ( countMultiset ) ; int ans = Integer . MAX_VALUE ; int i = 0 ; int m = countMultiset . size ( ) ; for ( int j : countMultiset ) { ans = Math . min ( ans , n - ( m - i ) * j ) ; i ++ ; } return ans ; }
void maxLenSubset ( int a [ ] , int n ) { Arrays . sort ( a ) ; int index = 0 , maxlen = - 1 ; int i = 0 ; while ( i < n ) { int j = i ; int len = 1 ; while ( j < n - 1 ) { if ( 2 * a [ j ] >= a [ j + 1 ] ) { len ++ ; } else break ; j ++ ; } if ( maxlen < len ) { maxlen = len ; index = i ; } j ++ ; i = j ; } i = index ; while ( maxlen > 0 ) { System . out . print ( a [ i ] + " " ) ; maxlen -- ; i ++ ; } }
void maximumMex ( int arr [ ] , int N ) { int ans [ ] = new int [ 2 * N ] ; Arrays . sort ( ans ) ; int j = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 arr [ i ] != arr [ i - 1 ] ) { j += 1 ; ans [ j ] = arr [ i ] ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( i > 0 && arr [ i ] == arr [ i - 1 ] ) { j += 1 ; ans [ j ] = arr [ i ] ; } } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( ans [ i ] + " " ) ; }
void canReduceArray ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int b [ ] = new int [ N ] ; int j = N ; for ( int i = 0 ; i < N ; i ++ ) { b [ j - 1 ] = arr [ i ] ; j = j - 1 ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] - arr [ i + 1 ] > K ) { System . out . print ( "No" ) ; return ; } } System . out . print ( "Yes" ) ; }
void mergeStrings ( String s1 , String s2 ) { int len1 = s1 . length ( ) ; int len2 = s2 . length ( ) ; int pntr1 = 0 ; int pntr2 = 0 ; String ans = "" ; while ( pntr1 < len1 && pntr2 < len2 ) { if ( s1 . charAt ( pntr1 ) < s2 . charAt ( pntr2 ) ) { ans += s1 . charAt ( pntr1 ) ; pntr1 ++ ; } else { ans += s2 . charAt ( pntr2 ) ; pntr2 ++ ; } } if ( pntr1 < len1 ) { ans += s1 . substring ( pntr1 , len1 ) ; } if ( pntr2 < len2 ) { ans += s2 . substring ( pntr2 , len2 ) ; } System . out . println ( ans ) ; }
ArrayList < Integer > bubble_sort ( ArrayList < Integer > ar ) { if ( ar . size ( ) <= 1 ) return ar ; if ( ar . size ( ) == 2 ) { if ( ar . get ( 0 ) < ar . get ( 1 ) ) return ar ; else return new ArrayList < Integer > ( Arrays . asList ( ar . get ( 1 ) , ar . get ( 0 ) ) ) ; } int a = ar . get ( 0 ) ; int b = ar . get ( 1 ) ; ArrayList < Integer > bs = new ArrayList < > ( ) ; for ( int i = 2 ; i < ar . size ( ) ; i ++ ) bs . add ( ar . get ( i ) ) ; ArrayList < Integer > res = new ArrayList < > ( ) ; if ( a < b ) { ArrayList < Integer > temp1 = new ArrayList < > ( ) ; temp1 . add ( b ) ; for ( int i = 0 ; i < bs . size ( ) ; i ++ ) temp1 . add ( bs . get ( i ) ) ; ArrayList < Integer > v = bubble_sort ( temp1 ) ; v . add ( 0 , a ) ; res = v ; } else { ArrayList < Integer > temp1 = new ArrayList < > ( ) ; temp1 . add ( a ) ; for ( int i = 0 ; i < bs . size ( ) ; i ++ ) temp1 . add ( bs . get ( i ) ) ; ArrayList < Integer > v = bubble_sort ( temp1 ) ; v . add ( 0 , b ) ; res = v ; } ArrayList < Integer > pass = new ArrayList < > ( ) ; for ( int i = 0 ; i < res . size ( ) - 1 ; i ++ ) pass . add ( res . get ( i ) ) ; ArrayList < Integer > ans = bubble_sort ( pass ) ; ans . add ( res . get ( res . size ( ) - 1 ) ) ; return ans ; }
void sortBoundaryWise ( ArrayList < ArrayList < Integer > > a ) { int i , k = 0 , l = 0 ; int m = a . size ( ) , n = a . get ( 0 ) . size ( ) ; int n_i , n_k = 0 , n_l = 0 , n_m = m , n_n = n ; while ( k < m && l < n ) { ArrayList < Integer > boundary = new ArrayList < Integer > ( ) ; for ( i = l ; i < n ; ++ i ) { boundary . add ( a . get ( k ) . get ( i ) ) ; } k ++ ; for ( i = k ; i < m ; ++ i ) { boundary . add ( a . get ( i ) . get ( n - 1 ) ) ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { boundary . add ( a . get ( m - 1 ) . get ( i ) ) ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { boundary . add ( a . get ( i ) . get ( l ) ) ; } l ++ ; } Collections . sort ( boundary ) ; int ind = 0 ; for ( i = n_l ; i < n_n ; ++ i ) { a . get ( n_k ) . set ( i , boundary . get ( ind ) ) ; ind ++ ; } n_k += 1 ; for ( i = n_k ; i < n_m ; ++ i ) { a . get ( i ) . set ( n_n - 1 , boundary . get ( ind ) ) ; ind ++ ; } n_n -- ; if ( n_k < n_m ) { for ( i = n_n - 1 ; i >= n_l ; -- i ) { a . get ( n_m - 1 ) . set ( i , boundary . get ( ind ) ) ; ind ++ ; } n_m -- ; } if ( n_l < n_n ) { for ( i = n_m - 1 ; i >= n_k ; -- i ) { a . get ( i ) . set ( n_l , boundary . get ( ind ) ) ; ind ++ ; } n_l ++ ; } } printMatrix ( a ) ; }
void countPairs ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int high = upper_bound ( arr , k * arr [ i ] ) ; ans += high - i - 1 ; } System . out . println ( ans ) ; }
void findXOR ( int [ ] [ ] mat , int K ) { int N = mat . length ; int M = mat [ 0 ] . length ; ArrayList < Integer > digXOR = new ArrayList < Integer > ( ) ; for ( int l = 1 ; l <= ( N + M - 1 ) ; l ++ ) { int s_col = Math . max ( 0 , l - N ) ; int count = Math . min ( l , Math . min ( ( M - s_col ) , N ) ) ; int currXOR = 0 ; for ( int j = 0 ; j < count ; j ++ ) { currXOR = ( currXOR ^ mat [ Math . min ( N , l ) - j - 1 ] [ s_col + j ] ) ; } digXOR . add ( currXOR ) ; } Collections . sort ( digXOR ) ; System . out . print ( digXOR . get ( N + M - 1 - K ) ) ; }
void countArraysUtil ( ArrayList < Integer > arr , int X , int K , int xorVal ) { if ( X == 0 ) { int cnt = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( arr . get ( i ) > xorVal ) cnt ++ ; } if ( cnt >= K ) ans ++ ; return ; } int temp = arr . get ( 0 ) ; arr . remove ( 0 ) ; countArraysUtil ( arr , X - 1 , K , xorVal ) ; arr . add ( 0 , temp ) ; temp = arr . get ( arr . size ( ) - 1 ) ; arr . remove ( arr . size ( ) - 1 ) ; countArraysUtil ( arr , X - 1 , K , xorVal ) ; arr . add ( temp ) ; arr . set ( 0 , arr . get ( 0 ) + 1 ) ; countArraysUtil ( arr , X - 1 , K , xorVal ) ; arr . set ( 0 , arr . get ( 0 ) - 1 ) ; arr . set ( arr . size ( ) - 1 , arr . get ( arr . size ( ) - 1 ) + 1 ) ; countArraysUtil ( arr , X - 1 , K , xorVal ) ; arr . set ( arr . size ( ) - 1 , arr . get ( arr . size ( ) - 1 ) - 1 ) ; }
void countArrays ( ArrayList < Integer > arr , int X , int K ) { int xorVal = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) xorVal = xorVal ^ arr . get ( i ) ; countArraysUtil ( arr , X , K , xorVal ) ; System . out . println ( ans ) ; }
void maximumSum ( int [ ] arr , int N ) { int sum ; Arrays . sort ( arr ) ; sum = ( arr [ N - 1 ] - arr [ 0 ] ) + ( arr [ N - 2 ] - arr [ 0 ] ) + ( arr [ N - 1 ] - arr [ N - 2 ] ) ; System . out . println ( sum ) ; }
void getBuckets ( int [ ] arr , int N ) { int availableWater = N * ( N - 1 ) / 2 ; Arrays . sort ( arr ) ; int i = 0 , sum = 0 ; while ( sum <= availableWater ) { sum += arr [ i ] ; i ++ ; } System . out . println ( i - 1 ) ; }
int minimum_sum ( int [ ] A , int N ) { Arrays . sort ( A ) ; int sum = 2147483647 ; for ( int i = 0 ; i <= N - 3 ; i ++ ) { sum = Math . min ( sum , Math . abs ( A [ i ] - A [ i + 1 ] ) + Math . abs ( A [ i + 1 ] - A [ i + 2 ] ) ) ; } return sum ; }
void minimumIncreasingSubsequences ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; int count = 0 ; int i = 0 ; while ( i < N ) { int x = arr [ i ] ; int freqX = 0 ; while ( i < N && arr [ i ] == x ) { freqX ++ ; i ++ ; } count = Math . max ( count , freqX ) ; } System . out . print ( count ) ; }
void maxOps ( int a , int b , int c ) { int arr [ ] = { a , b , c } ; int count = 0 ; while ( 1 != 0 ) { Arrays . sort ( arr ) ; if ( arr [ 0 ] == 0 && arr [ 1 ] == 0 ) break ; arr [ 1 ] -= 1 ; arr [ 2 ] -= 1 ; count += 1 ; } System . out . print ( count ) ; }
int hashFunction ( int N ) { int [ ] prime = { 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 } ; int value = 1 , r ; while ( N != 0 ) { r = N % 10 ; value = value * prime [ r ] ; N = N / 10 ; } return value ; }
void findDiff ( int [ ] arr , int n ) { HashMap < Integer , Vector < Integer > > m = new HashMap < > ( ) ; int h , min , max ; for ( int i = 0 ; i < n ; i ++ ) { h = hashFunction ( arr [ i ] ) ; if ( ! m . containsKey ( h ) ) { m . put ( h , new Vector < Integer > ( ) ) ; } m . get ( h ) . add ( arr [ i ] ) ; } for ( Map . Entry < Integer , Vector < Integer > > i : m . entrySet ( ) ) { if ( i . getValue ( ) . size ( ) > 1 ) { min = Integer . MAX_VALUE ; max = - ( Integer . MAX_VALUE ) ; for ( int j = 0 ; j < i . getValue ( ) . size ( ) ; j ++ ) { if ( m . get ( i . getKey ( ) ) . get ( j ) < min ) { min = m . get ( i . getKey ( ) ) . get ( j ) ; } if ( m . get ( i . getKey ( ) ) . get ( j ) > max ) { max = m . get ( i . getKey ( ) ) . get ( j ) ; } } System . out . print ( max - min ) ; break ; } else if ( m . get ( i . getKey ( ) ) == m . values ( ) . toArray ( ) [ m . size ( ) - 1 ] ) System . out . print ( - 1 ) ; } }
int maxScore ( int i , int A [ ] , int K , int N , int dp [ ] ) { if ( i >= N - 1 ) return A [ N - 1 ] ; if ( dp [ i ] != - 1 ) return dp [ i ] ; int score = Integer . MIN_VALUE ; for ( int j = 1 ; j <= K ; j ++ ) { score = Math . max ( score , maxScore ( i + j , A , K , N , dp ) ) ; } return dp [ i ] = score + A [ i ] ; }
void getScore ( int A [ ] , int N , int K ) { int dp [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] = - 1 ; System . out . println ( maxScore ( 0 , A , K , N , dp ) ) ; }
boolean checkifSorted ( int A [ ] , int B [ ] , int N ) { boolean flag = false ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { flag = true ; break ; } } if ( ! flag ) { return true ; } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 0 ) { count ++ ; break ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 1 ) { count ++ ; break ; } } if ( count == 2 ) { return true ; } return false ; }
void minOperation ( int a [ ] , int N ) { int totOps = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { totOps += Math . abs ( a [ i ] - a [ i + 1 ] ) ; } int maxOps = Math . max ( Math . abs ( a [ 0 ] - a [ 1 ] ) , Math . abs ( a [ N - 1 ] - a [ N - 2 ] ) ) ; for ( int i = 1 ; i < N - 1 ; i ++ ) { maxOps = Math . max ( maxOps , Math . abs ( a [ i ] - a [ i - 1 ] ) + Math . abs ( a [ i ] - a [ i + 1 ] ) - Math . abs ( a [ i - 1 ] - a [ i + 1 ] ) ) ; } System . out . println ( totOps - maxOps ) ; }
void maxPossibleSum ( int [ ] arr , int N ) { Arrays . sort ( arr ) ; int sum = 0 ; int j = N - 3 ; while ( j >= 0 ) { sum += arr [ j ] ; j -= 3 ; } System . out . println ( sum ) ; }
void findMaxDifference ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int Leftsum = 0 ; int Totalsum = 0 ; int Min = Integer . MAX_VALUE , Max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) Totalsum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int leftNumbers = i ; int rightNumbers = n - i - 1 ; Totalsum = Totalsum - arr [ i ] ; int sum = ( leftNumbers * arr [ i ] ) - Leftsum + Totalsum - ( rightNumbers * arr [ i ] ) ; Min = Math . min ( Min , sum ) ; Max = Math . max ( Max , sum ) ; Leftsum += arr [ i ] ; } System . out . print ( Max - Min ) ; }
boolean sameStrings ( String str1 , String str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; if ( N != M ) { return false ; } int [ ] a = new int [ 256 ] ; int [ ] b = new int [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { a [ str1 . charAt ( i ) - 'a' ] ++ ; b [ str2 . charAt ( i ) - 'a' ] ++ ; } int i = 0 ; while ( i < 256 ) { if ( ( a [ i ] == 0 && b [ i ] == 0 ) || ( a [ i ] != 0 && b [ i ] != 0 ) ) { i ++ ; } else { return false ; } } Arrays . sort ( a ) ; Arrays . sort ( b ) ; for ( i = 0 ; i < 256 ; i ++ ) { if ( a [ i ] != b [ i ] ) return false ; } return true ; }
int minSteps ( StringBuilder A , StringBuilder B , int M , int N ) { if ( A . charAt ( 0 ) > B . charAt ( 0 ) ) return 0 ; if ( B . charAt ( 0 ) > A . charAt ( 0 ) ) { return 1 ; } if ( M <= N && A . charAt ( 0 ) == B . charAt ( 0 ) && count ( A , A . charAt ( 0 ) ) == M && count ( B , B . charAt ( 0 ) ) == N ) return - 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( B . charAt ( i ) > B . charAt ( 0 ) ) return 1 ; } for ( int i = 1 ; i < M ; i ++ ) { if ( A . charAt ( i ) < A . charAt ( 0 ) ) return 1 ; } for ( int i = 1 ; i < M ; i ++ ) { if ( A . charAt ( i ) > A . charAt ( 0 ) ) { swap ( A , i , B , 0 ) ; swap ( A , 0 , B , 0 ) ; return 2 ; } } for ( int i = 1 ; i < N ; i ++ ) { if ( B . charAt ( i ) < B . charAt ( 0 ) ) { swap ( A , 0 , B , i ) ; swap ( A , 0 , B , 0 ) ; return 2 ; } } return 0 ; }
int merge ( int A [ ] , int left , int mid , int right ) { int swaps = 0 ; int i = left , j = mid , k = left ; while ( i < mid && j <= right ) { if ( A [ i ] <= A [ j ] ) { temp [ k ] = A [ i ] ; k ++ ; i ++ ; } else { temp [ k ] = A [ j ] ; k ++ ; j ++ ; swaps += mid - i ; } } while ( i < mid ) { temp [ k ] = A [ i ] ; k ++ ; i ++ ; } while ( j <= right ) { temp [ k ] = A [ j ] ; k ++ ; j ++ ; } while ( left <= right ) { A [ left ] = temp [ left ] ; left ++ ; } return swaps ; }
int mergeInsertionSwap ( int A [ ] , int left , int right ) { int swaps = 0 ; if ( left < right ) { int mid = left + ( right - left ) / 2 ; swaps += mergeInsertionSwap ( A , left , mid ) ; swaps += mergeInsertionSwap ( A , mid + 1 , right ) ; swaps += merge ( A , left , mid + 1 , right ) ; } return swaps ; }
boolean findAns ( int [ ] A , int N , int X ) { if ( check ( A , X ) ) { return true ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int gcd = gcd ( A [ i ] , A [ j ] ) ; if ( gcd != 1 ) { if ( gcd <= X ) { return true ; } } } } return false ; }
String check ( int [ ] a , int [ ] b , int Na , int Nb , int k , int m ) { if ( Na < k Nb < m ) return "No" ; Arrays . sort ( a ) ; Arrays . sort ( b ) ; if ( a [ k - 1 ] < b [ Nb - m ] ) { return "Yes" ; } return "No" ; }
int splitArray ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; int result = Integer . MAX_VALUE ; for ( int i = 1 ; i < N ; i ++ ) { result = Math . min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; }
int maxCntRemovedfromArray ( int [ ] arr , int N , int [ ] brr , int M ) { Arrays . sort ( arr ) ; int i = 0 ; int sumArr = 0 ; for ( i = 0 ; i < N ; i ++ ) { sumArr += arr [ i ] ; } int sumBrr = 0 ; for ( i = 0 ; i < M ; i ++ ) { sumBrr += brr [ i ] ; } int cntRemElem = 0 ; while ( i < N && sumArr >= sumBrr ) { sumArr -= arr [ i ] ; i += 1 ; if ( sumArr >= sumBrr ) { cntRemElem += 1 ; } } return cntRemElem ; }
void findPair ( pair arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int a = arr [ i ] . first , b = arr [ i ] . second ; for ( int j = i + 1 ; j < N ; j ++ ) { int c = arr [ j ] . first , d = arr [ j ] . second ; if ( a < c && b > d ) { System . out . println ( "(" + a + " " + b + "), (" + c + " " + d + ")" ) ; return ; } } } System . out . println ( "NO SUCH PAIR EXIST" ) ; }
void printOrder ( int order [ ] , int N , int X ) { ArrayList < int [ ] > vect = new ArrayList < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( order [ i ] % X == 0 ) { vect . add ( new int [ ] { order [ i ] / X , i + 1 } ) ; } else { vect . add ( new int [ ] { order [ i ] / X + 1 , i + 1 } ) ; } } Collections . sort ( vect , ( a , b ) -> a [ 0 ] - b [ 0 ] ) ; for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( vect . get ( i ) [ 1 ] + " " ) ; } System . out . println ( ) ; }
int CountMaximum ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
int CountMaximum ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
void numOperation ( int arr [ ] , int N , int D ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( ( arr [ i + 1 ] - arr [ i ] ) % D != 0 ) { System . out . println ( "-1" ) ; return ; } } int count = 0 ; int mid = arr [ N / 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { count += Math . abs ( mid - arr [ i ] ) / D ; } System . out . println ( count ) ; }
void findSum ( int A [ ] , int N , int K ) { Arrays . sort ( A ) ; int sum = 0 ; for ( int i = N / K ; i < N ; i += K - 1 ) { sum += A [ i ] ; } System . out . print ( sum ) ; }
int maxcntPairsSumKRemoved ( int [ ] arr , int k ) { int cntPairs = 0 ; if ( arr . length <= 1 ) return cntPairs ; Arrays . sort ( arr ) ; int left = 0 ; int right = arr . length - 1 ; while ( left < right ) { int s = arr [ left ] + arr [ right ] ; if ( s == k ) { cntPairs += 1 ; left += 1 ; right -= 1 ; } else if ( s > k ) right -= 1 ; else left += 1 ; } return cntPairs ; }
void selectionSort ( int arr [ ] , int n ) { int i , j , min_idx ; for ( i = 0 ; i < n - 1 ; i ++ ) { min_idx = i ; for ( j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ] ) min_idx = j ; int temp = arr [ min_idx ] ; arr [ min_idx ] = arr [ i ] ; arr [ i ] = temp ; } }
int findSmallestNumLeft ( int arr [ ] , int N ) { PriorityQueue < Integer > PQ = new PriorityQueue < Integer > ( ( a , b ) -> b - a ) ; for ( int i = 0 ; i < N ; i ++ ) { PQ . add ( arr [ i ] ) ; } while ( PQ . size ( ) > 1 ) { int top1 = PQ . peek ( ) ; PQ . remove ( ) ; int top2 = PQ . peek ( ) ; PQ . remove ( ) ; PQ . add ( ( top1 + top2 + 1 ) / 2 ) ; } return PQ . peek ( ) ; }
int digitProduct ( int number ) { int product = 1 ; while ( number > 0 ) { product *= ( number % 10 ) ; number /= 10 ; } return product ; }
boolean compositedigitProduct ( int num ) { int res = digitProduct ( num ) ; if ( res == 1 ) { return false ; } if ( isComposite ( res ) ) { return true ; } return false ; }
int largestCompositeDigitProduct ( int a [ ] , int n , int k ) { Vector < pair > pq = new Vector < pair > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i % k ) == 0 ) { continue ; } if ( compositedigitProduct ( a [ i ] ) ) { int b = digitProduct ( a [ i ] ) ; pq . add ( new pair ( b , a [ i ] ) ) ; } } Collections . sort ( pq , ( x , y ) -> x . first - y . first ) ; return pq . get ( pq . size ( ) - 1 ) . second ; }
void maxSum ( int arr [ ] , int brr [ ] , int N , int K ) { Vector < Integer > crr = new Vector < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { crr . add ( arr [ i ] ) ; } for ( int i = 0 ; i < K ; i ++ ) { crr . add ( brr [ i ] ) ; } Collections . sort ( crr ) ; Collections . reverse ( crr ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( crr . get ( i ) > 0 ) { sum += crr . get ( i ) ; } else { break ; } } System . out . println ( sum ) ; }
void findMinimum ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int ans = 0 ; for ( int i = 1 ; i < 2 * ( N / K ) ; i += 2 ) { ans += arr [ i ] ; } System . out . println ( ans ) ; }
void findSubarrays ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; int i = 0 ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { System . out . println ( "YES" ) ; return ; } } System . out . println ( "NO" ) ; }
void maxFreqElements ( int arr [ ] , int N , int K ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } while ( K > 0 ) { int max = 0 ; int element = 0 ; for ( Map . Entry < Integer , Integer > i : mp . entrySet ( ) ) { if ( i . getValue ( ) > max ) { max = i . getValue ( ) ; element = i . getKey ( ) ; } } System . out . print ( element + " " ) ; if ( mp . containsKey ( element ) ) { mp . put ( element , mp . get ( element ) + 1 ) ; } else { mp . put ( element , 1 ) ; } K -- ; } }
void getPairs ( int arr [ ] , int N , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] > K * arr [ i + 1 ] ) count ++ ; } } System . out . print ( count ) ; }
int merge ( int arr [ ] , int temp [ ] , int l , int m , int r , int K ) { int i = l ; int j = m + 1 ; int cnt = 0 ; for ( i = l ; i <= m ; i ++ ) { boolean found = false ; while ( j <= r ) { if ( arr [ i ] >= K * arr [ j ] ) { found = true ; } else break ; j ++ ; } if ( found == true ) { cnt += j - ( m + 1 ) ; j -- ; } } int k = l ; i = l ; j = m + 1 ; while ( i <= m && j <= r ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else temp [ k ++ ] = arr [ j ++ ] ; } while ( i <= m ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= r ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = l ; i <= r ; i ++ ) arr [ i ] = temp [ i ] ; return cnt ; }
void mergeSort ( int arr [ ] , int N , int K ) { int temp [ ] = new int [ N ] ; System . out . print ( mergeSortUtil ( arr , temp , 0 , N - 1 , K ) ) ; }
void Selection_Sort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; ++ i ) { int min_index = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( arr [ j ] < arr [ min_index ] ) min_index = j ; } int temp = arr [ i ] ; arr [ i ] = arr [ min_index ] ; arr [ min_index ] = temp ; } }
void Bubble_Sort ( int [ ] arr , int n ) { boolean flag ; for ( int i = 1 ; i < n ; ++ i ) { flag = false ; for ( int j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; flag = true ; } } if ( flag == false ) break ; } }
void NDivKWithFreq ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < N ; ) { int cnt = 1 ; while ( ( i + 1 ) < N && arr [ i ] == arr [ i + 1 ] ) { cnt ++ ; i ++ ; } if ( cnt > ( N / K ) ) { System . out . print ( arr [ i ] + " " ) ; } i ++ ; } }
int upperBound ( int arr [ ] , int N , int K ) { int l = 0 ; int r = N ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( arr [ mid ] <= K ) { l = mid + 1 ; } else { r = mid ; } } return l ; }
void NDivKWithFreq ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int i = 0 ; while ( i < N ) { int X = upperBound ( arr , N , arr [ i ] ) ; if ( ( X - i ) > N / 4 ) { System . out . print ( arr [ i ] + " " ) ; } i = X ; } }
boolean checkSubsetSum ( int A [ ] , int B [ ] , int N , int K ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; reverse ( B ) ; int sum1 = 0 ; int sum2 = 0 ; for ( int i = 0 ; i < K ; i ++ ) { sum1 += A [ i ] ; sum2 += B [ i ] ; } if ( sum1 > sum2 ) { return true ; } return false ; }
void printCircularArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
void sortCircularArray ( int arr [ ] , int n , int k , int m ) { for ( int i = 0 ; i < m ; i ++ ) { for ( int j = k ; j < k + m - 1 ; j ++ ) { if ( arr [ j % n ] > arr [ ( j + 1 ) % n ] ) { int t = arr [ j % n ] ; arr [ j % n ] = arr [ ( j + 1 ) % n ] ; arr [ ( j + 1 ) % n ] = t ; } } } printCircularArray ( arr , n ) ; }
void rearrangeArray ( int a [ ] , int n ) { Arrays . sort ( a ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] == i + 1 ) { int temp = a [ i ] ; a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = temp ; } } if ( a [ n - 1 ] == n ) { int temp = a [ n - 1 ] ; a [ n - 1 ] = a [ n - 2 ] ; a [ n - 2 ] = temp ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( a [ i ] + " " ) ; } }
int maximumKthLargestsumPart ( int [ ] arr , int N , int M , int K ) { int maxSum = 0 ; if ( N % M != 0 ) return - 1 ; int sz = ( N / M ) ; if ( K > sz ) return - 1 ; Arrays . sort ( arr ) ; int i , k , t ; for ( i = 0 ; i < N / 2 ; i ++ ) { t = arr [ i ] ; arr [ i ] = arr [ N - i - 1 ] ; arr [ N - i - 1 ] = t ; } for ( i = 1 ; i <= M ; i ++ ) { maxSum += arr [ i * K - 1 ] ; } return maxSum ; }
void splitArray ( int arr [ ] , int n , int K ) { Arrays . sort ( arr ) ; int i = n - 1 ; int result = 0 ; while ( K -- != 0 ) { result += arr [ i - 1 ] ; i -= 2 ; } System . out . print ( result ) ; }
void merge ( int [ ] indices , int [ ] a , int l , int mid , int r ) { int [ ] temp_ind = new int [ r - l + 1 ] ; int j = mid + 1 ; int i = 0 , temp_l = l , k ; while ( l <= mid && j <= r ) { if ( a [ indices [ l ] ] < a [ indices [ j ] ] ) temp_ind [ i ++ ] = indices [ l ++ ] ; else temp_ind [ i ++ ] = indices [ j ++ ] ; } while ( l <= mid ) temp_ind [ i ++ ] = indices [ l ++ ] ; while ( j <= r ) temp_ind [ i ++ ] = indices [ j ++ ] ; for ( k = 0 ; k < i ; k ++ ) indices [ temp_l ++ ] = temp_ind [ k ] ; }
void divide ( int [ ] indices , int [ ] a , int l , int r ) { if ( l >= r ) return ; int mid = l / 2 + r / 2 ; divide ( indices , a , l , mid ) ; divide ( indices , a , mid + 1 , r ) ; merge ( indices , a , l , mid , r ) ; }
void noOfSubsequences ( int arr [ ] , int N ) { int [ ] indices = new int [ N ] ; int i ; for ( i = 0 ; i < N ; i ++ ) indices [ i ] = i ; divide ( indices , arr , 0 , N - 1 ) ; int [ ] B = new int [ N ] ; int subseq = 1 ; for ( i = 0 ; i < N ; i ++ ) { B [ indices [ i ] ] = subseq ; subseq *= 2 ; } for ( i = 0 ; i < N ; i ++ ) System . out . print ( B [ i ] + " " ) ; }
boolean checkStr1CanConStr2 ( String str1 , String str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; HashSet < Integer > st1 = new HashSet < > ( ) ; HashSet < Integer > st2 = new HashSet < > ( ) ; int hash1 [ ] = new int [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { hash1 [ str1 . charAt ( i ) ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { st1 . add ( ( int ) str1 . charAt ( i ) ) ; } for ( int i = 0 ; i < M ; i ++ ) { st2 . add ( ( int ) str2 . charAt ( i ) ) ; } if ( ! st1 . equals ( st2 ) ) { return false ; } int hash2 [ ] = new int [ 256 ] ; for ( int i = 0 ; i < M ; i ++ ) { hash2 [ str2 . charAt ( i ) ] ++ ; } Arrays . sort ( hash1 ) ; Arrays . sort ( hash2 ) ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( hash1 [ i ] != hash2 [ i ] ) { return false ; } } return true ; }
void sortArrayInDescAsc ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; for ( int i = 0 , j = N - 1 ; i < N / 2 ; i ++ ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; j -- ; } Arrays . sort ( arr , K , N ) ; for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
int maxCostToRemove ( int arr [ ] , int N , int K ) { int maxCost = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < N ; i += K ) { maxCost += arr [ i + 1 ] ; } return maxCost ; }
void lexNumbers ( int n ) { Vector < String > s = new Vector < String > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { s . add ( convert_to_words ( i ) ) ; } Collections . sort ( s ) ; Vector < String > ans = new Vector < String > ( ) ; for ( int i = 0 ; i < n ; i ++ ) ans . add ( s . get ( i ) ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) System . out . print ( ans . get ( i ) + ", " ) ; System . out . print ( ans . get ( n - 1 ) ) ; }
void minimumCost ( int [ ] binary , int n , int a , int b ) { List < Integer > groupOfZeros = new ArrayList < Integer > ( ) ; int len = 0 , i = 0 ; boolean increment_need = true ; while ( i < n ) { increment_need = true ; while ( i < n && binary [ i ] == 0 ) { len ++ ; i ++ ; increment_need = false ; } if ( increment_need == true ) { i ++ ; } if ( len != 0 ) { groupOfZeros . add ( len ) ; } len = 0 ; } Collections . sort ( groupOfZeros ) ; i = 0 ; boolean found_ones = false ; int NumOfOnes = 0 ; while ( i < n ) { found_ones = false ; while ( i < n && binary [ i ] == 1 ) { i ++ ; found_ones = true ; } if ( found_ones == false ) i ++ ; else NumOfOnes ++ ; } int ans = Integer . MAX_VALUE ; for ( int i1 = 0 ; i1 < n ; i1 ++ ) { int curr = 0 , totalOnes = NumOfOnes ; if ( i1 == 0 ) { curr = totalOnes * a ; } else { int mark = i1 , num_of_changes = 0 ; for ( int x : groupOfZeros ) { if ( mark >= x ) { totalOnes -- ; mark -= x ; num_of_changes += x ; } else { break ; } } curr = ( num_of_changes * b ) + ( totalOnes * a ) ; } ans = Math . min ( ans , curr ) ; } System . out . println ( ans ) ; }
int isSortedparitions ( int arr [ ] , int i , int j ) { for ( int k = i + 1 ; k <= j ; k ++ ) { if ( arr [ k ] < arr [ k - 1 ] ) { return 0 ; } } return 1 ; }
int partitionsArr ( int arr [ ] , int i , int j ) { if ( i >= j ) return 1 ; int flag = ( int ) isSortedparitions ( arr , i , j ) ; if ( flag != 0 ) { return ( j - i + 1 ) ; } int mid = ( i + j ) / 2 ; int X = partitionsArr ( arr , i , mid ) ; int Y = partitionsArr ( arr , mid + 1 , j ) ; return Math . max ( X , Y ) ; }
boolean checkIfPossibleMerge ( int [ ] A , int [ ] B , int N ) { int i = 0 ; int j = 0 ; int prev = - 1 ; boolean flag = true ; while ( i < N && j < N ) { if ( A [ i ] < B [ j ] && prev != 0 ) { prev = 0 ; i ++ ; } else if ( B [ j ] < A [ i ] && prev != 1 ) { prev = 1 ; j ++ ; } else if ( A [ i ] == B [ j ] ) { if ( prev != 1 ) { prev = 1 ; j ++ ; } else { prev = 0 ; i ++ ; } } else { flag = false ; break ; } } return flag ; }
int maxSum ( int n , int a [ ] , int [ ] [ ] l , int q ) { Vector < Integer > v = new Vector < > ( ) ; int [ ] d = new int [ n ] ; for ( int i = 0 ; i < q ; i ++ ) { for ( int x = l [ i ] [ 0 ] ; x <= l [ i ] [ 1 ] ; x ++ ) { if ( d [ x ] == 0 ) { d [ x ] = 1 ; } } } HashSet < Integer > st = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] == 0 ) { v . add ( a [ i ] ) ; st . add ( i ) ; } } Collections . sort ( v ) ; Collections . reverse ( v ) ; int c = 0 ; for ( int it : st ) { a [ it ] = v . get ( c ) ; c ++ ; } int pref_sum = 0 ; int temp_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp_sum += a [ i ] ; pref_sum += temp_sum ; } return pref_sum ; }
void countPairs ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int xo = ( A [ i ] ^ A [ j ] ) ; int mx = Math . max ( A [ i ] , A [ j ] ) ; if ( xo > mx ) { count ++ ; } } } System . out . println ( count ) ; }
int findMedianOfsubSum ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } Arrays . sort ( arr ) ; int [ ] [ ] dp = new int [ N ] [ sum + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < sum + 1 ; j ++ ) dp [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } dp [ 0 ] [ arr [ 0 ] ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j >= arr [ i ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - arr [ i ] ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } } Vector < Integer > sumSub = new Vector < Integer > ( ) ; for ( int j = 1 ; j <= sum ; j ++ ) { int M = dp [ N - 1 ] [ j ] ; for ( int i = 1 ; i <= M ; i ++ ) { sumSub . add ( j ) ; } } int mid = sumSub . get ( sumSub . size ( ) / 2 ) ; return mid ; }
int maxDiffLargSmallOper ( int arr [ ] , int N , int K ) { int maxDiff = 0 ; Arrays . sort ( arr ) ; arr = reverse ( arr ) ; for ( int i = 0 ; i <= Math . min ( K , N - 1 ) ; i ++ ) { maxDiff += arr [ i ] ; } return maxDiff ; }
void findTheOrder ( int arr [ ] , String s , int N ) { List < Integer > ans = new ArrayList < Integer > ( ) ; List < Pair > A = new ArrayList < Pair > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { Pair p = new Pair ( arr [ i ] , i + 1 ) ; A . add ( p ) ; } Collections . sort ( A , ( p1 , p2 ) -> p1 . first - p2 . first ) ; PriorityQueue < Pair > q = new PriorityQueue < Pair > ( N , ( p1 , p2 ) -> p2 . first - p1 . first ) ; int index = 0 ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( s . charAt ( i ) == '0' ) { ans . add ( A . get ( index ) . second ) ; q . add ( A . get ( index ) ) ; index ++ ; } else { ans . add ( q . peek ( ) . second ) ; q . poll ( ) ; } } for ( int i : ans ) { System . out . print ( i + " " ) ; } }
void checkArrangement ( Integer [ ] A1 , Integer [ ] A2 , int n , int k ) { Arrays . sort ( A1 ) ; Arrays . sort ( A2 , Collections . reverseOrder ( ) ) ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( A1 [ i ] + A2 [ i ] > k ) || ( A1 [ i ] + A2 [ i ] < k / 2 ) ) { flag = 1 ; break ; } } if ( flag == 1 ) System . out . println ( "No" ) ; else System . out . println ( "Yes" ) ; }
int MaxRearrngeSum ( Integer A [ ] , Integer B [ ] , int N ) { Arrays . sort ( A ) ; Arrays . sort ( B , Collections . reverseOrder ( ) ) ; int maxSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { maxSum += Math . abs ( A [ i ] - B [ i ] ) ; } return maxSum ; }
int largestArea ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int end = 0 , start = 0 , i = 0 , j = 0 ; Arrays . sort ( arr1 ) ; Arrays . sort ( arr1 ) ; while ( i < n && j < m ) { if ( arr1 [ i ] == arr2 [ j ] ) { if ( start == 0 ) start = arr1 [ i ] ; else end = arr1 [ i ] ; i ++ ; j ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) j ++ ; else i ++ ; } if ( end == 0 start == 0 ) return 0 ; else return ( end - start ) ; }
int count_pairs ( int arr [ ] , int brr [ ] , int N , int M , int K ) { int i = 0 ; int j = 0 ; int cntPairs = 0 ; Arrays . sort ( arr ) ; Arrays . sort ( brr ) ; while ( i < N && j < M ) { if ( brr [ j ] - arr [ i ] > K ) { cntPairs += ( M - j ) ; i ++ ; } else { j ++ ; } } return cntPairs ; }
void firstSubsequence ( String s ) { Vector < String > allsubseq = new Vector < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String k = "" ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( i != j ) { k += s . charAt ( j ) ; } } allsubseq . add ( k ) ; } Collections . sort ( allsubseq ) ; System . out . print ( allsubseq . get ( 0 ) ) ; }
void firstSubsequence ( String s ) { int isMax = - 1 ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( s . charAt ( i ) > s . charAt ( i + 1 ) ) { isMax = i ; break ; } } if ( isMax >= 0 ) { s = s . substring ( 0 , isMax ) + s . substring ( isMax + 1 ) ; s . rerase ( isMax , 1 ) ; } else { s . erase ( s . length ( ) - 1 , 1 ) ; s = s . substring ( 0 , s . length ( ) - 1 ) ; } System . out . print ( s ) ; }
void minHeapify ( int brr [ ] , int i , int M ) { int left = 2 * i + 1 ; int right = 2 * i + 2 ; int smallest = i ; if ( left < M && brr [ left ] < brr [ smallest ] ) { smallest = left ; } if ( right < M && brr [ right ] < brr [ smallest ] ) { smallest = right ; } if ( smallest != i ) { int temp = brr [ i ] ; brr [ i ] = brr [ smallest ] ; brr [ smallest ] = temp ; minHeapify ( brr , smallest , M ) ; } }
void merge ( int arr [ ] , int brr [ ] , int N , int M ) { for ( int i = 0 ; i < N ; ++ i ) { if ( arr [ i ] > brr [ 0 ] ) { int temp = arr [ i ] ; arr [ i ] = brr [ 0 ] ; brr [ 0 ] = temp ; minHeapify ( brr , 0 , M ) ; } } Arrays . sort ( brr ) ; }
void printArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
int rankLessThanK ( int [ ] arr , int k , int n ) { int rank = 1 ; int position = 1 ; Arrays . sort ( arr ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i == n - 1 arr [ i ] != arr [ i + 1 ] ) { rank = position ; if ( rank > k ) return position - 1 ; } position ++ ; } return n ; }
void calculateFib ( int fib [ ] , int n ) { fib [ 0 ] = fib [ 1 ] = 1 ; for ( int x = 2 ; x < n ; x ++ ) { fib [ x ] = fib [ x - 1 ] + fib [ x - 2 ] ; } }
int find_mth_bit ( int n , int m , int fib [ ] ) { if ( n <= 1 ) { return n ; } int len_left = fib [ n - 2 ] ; int len_right = fib [ n - 1 ] ; if ( m <= len_left ) { return find_mth_bit ( n - 2 , len_left + 1 - m , fib ) ; } else { return find_mth_bit ( n - 1 , len_right + 1 - ( m - len_left ) , fib ) ; } }
int KthSmallestNum ( int arr [ ] [ ] , int n , int k ) { PriorityQueue < int [ ] > pq = new PriorityQueue < > ( ( a , b ) -> a [ 0 ] - b [ 0 ] ) ; for ( int i = 0 ; i < n ; i ++ ) { pq . add ( new int [ ] { arr [ i ] [ 0 ] , arr [ i ] [ 1 ] } ) ; } int cnt = 1 ; while ( cnt < k ) { int [ ] interval = pq . poll ( ) ; if ( interval [ 0 ] < interval [ 1 ] ) { pq . add ( new int [ ] { interval [ 0 ] + 1 , interval [ 1 ] } ) ; } cnt ++ ; } return pq . peek ( ) [ 0 ] ; }
void maxArea ( int [ ] point_x , int [ ] point_y , int n , int length , int width ) { Arrays . sort ( point_x ) ; Arrays . sort ( point_y ) ; int dx = point_x [ 0 ] ; int dy = point_y [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dx = Math . max ( dx , point_x [ i ] - point_x [ i - 1 ] ) ; dy = Math . max ( dy , point_y [ i ] - point_y [ i - 1 ] ) ; } dx = Math . max ( dx , ( length + 1 ) - point_x [ n - 1 ] ) ; dy = Math . max ( dy , ( width + 1 ) - point_y [ n - 1 ] ) ; System . out . println ( ( dx - 1 ) * ( dy - 1 ) ) ; }
int LongestSequence ( int a [ ] , int n ) { HashMap < Integer , Integer > m = new HashMap < > ( ) ; int ar [ ] = new int [ n + 1 ] ; int i = 0 ; int j = 0 ; for ( i = 1 ; i <= n ; i ++ ) { ar [ i ] = a [ i - 1 ] ; } Arrays . sort ( a ) ; int c = 1 ; m . put ( a [ 0 ] , c ) ; for ( i = 1 ; i < n ; i ++ ) { if ( a [ i ] != a [ i - 1 ] ) { c ++ ; m . put ( a [ i ] , c ) ; } } HashMap < Integer , Integer > cnt = new HashMap < > ( ) ; int dp [ ] [ ] = new int [ n + 1 ] [ 3 ] ; cnt . put ( 0 , 0 ) ; for ( i = 1 ; i <= n ; i ++ ) { ar [ i ] = m . get ( ar [ i ] ) ; if ( cnt . containsKey ( ar [ i ] ) ) cnt . put ( ar [ i ] , cnt . get ( ar [ i ] ) + 1 ) ; else cnt . put ( ar [ i ] , 1 ) ; } int ans = 0 , x ; for ( i = 1 ; i <= n ; i ++ ) { x = ar [ i ] ; if ( dp [ x ] [ 0 ] == 0 ) { if ( dp [ x - 1 ] [ 0 ] == cnt . get ( x - 1 ) ) { dp [ x ] [ 1 ] = dp [ x - 1 ] [ 1 ] ; dp [ x ] [ 2 ] = dp [ x - 1 ] [ 1 ] ; } else { dp [ x ] [ 1 ] = dp [ x - 1 ] [ 0 ] ; } } dp [ x ] [ 2 ] = Math . max ( dp [ x - 1 ] [ 0 ] , dp [ x ] [ 2 ] ) ; if ( dp [ x - 1 ] [ 0 ] == cnt . get ( x - 1 ) ) { dp [ x ] [ 2 ] = Math . max ( dp [ x ] [ 2 ] , dp [ x - 1 ] [ 1 ] ) ; } for ( j = 0 ; j < 3 ; j ++ ) { dp [ x ] [ j ] ++ ; ans = Math . max ( ans , dp [ x ] [ j ] ) ; } } return ans ; }
int solve ( Vector < Integer > values , Vector < Integer > salary ) { int ret = 1 ; int amt = 0 ; Collections . sort ( values ) ; Collections . sort ( salary ) ; while ( salary . size ( ) > 0 ) { while ( values . size ( ) > 0 && values . get ( values . size ( ) - 1 ) >= salary . get ( salary . size ( ) - 1 ) ) { amt ++ ; values . remove ( values . size ( ) - 1 ) ; } if ( amt == 0 ) return 0 ; ret *= amt -- ; ret %= MOD ; salary . remove ( salary . size ( ) - 1 ) ; } return ret ; }
void precompute_sum ( int [ ] arr , int [ ] brr ) { int N = ( int ) arr . length ; for ( int i = 1 ; i < N ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; brr [ i ] = brr [ i ] + brr [ i - 1 ] ; } }
void find_sum ( int [ ] arr , int q , int Queries [ ] [ ] ) { int [ ] brr = arr . clone ( ) ; int N = ( int ) arr . length ; Arrays . sort ( brr ) ; precompute_sum ( arr , brr ) ; for ( int i = 0 ; i < q ; i ++ ) { int m = Queries [ i ] [ 0 ] ; int a = Queries [ i ] [ 1 ] ; int b = Queries [ i ] [ 2 ] ; if ( m == 1 ) { System . out . print ( range_sum ( arr , a , b ) + " " ) ; } else if ( m == 2 ) { System . out . print ( range_sum ( brr , a , b ) + " " ) ; } } }
int minsteps ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += Math . abs ( arr [ i ] - Math . pow ( 2 , i ) ) ; } return ans ; }
int findCost ( Integer [ ] a , int n ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int p = a [ j ] - j ; a [ j ] = 0 ; if ( p < 0 ) { p = 0 ; continue ; } count += p ; } return count ; }
int make_cuts ( int arr [ ] , int n , int K ) { int ans = 0 ; Vector < Integer > poss = new Vector < Integer > ( ) ; int ce = 0 ; int co = 0 ; for ( int x = 0 ; x < n - 1 ; x ++ ) { if ( arr [ x ] % 2 == 0 ) ce ++ ; else co ++ ; if ( ce == co && co > 0 && ce > 0 ) { poss . add ( Math . abs ( arr [ x ] - arr [ x + 1 ] ) ) ; } } Collections . sort ( poss ) ; for ( int x : poss ) { if ( K >= x ) { ans ++ ; K -= x ; } else break ; } return ans ; }
void Arrange ( int arr [ ] , int n ) { int cost = 0 ; HashMap < Integer , Integer > index = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { index . put ( arr [ i ] , i ) ; } Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { if ( arr [ i ] > arr [ i + 1 ] + arr [ n - 1 ] ) { System . out . print ( "-1" ) ; return ; } else { cost += Math . abs ( index . get ( arr [ i ] ) - i ) ; } } else if ( i == n - 1 ) { if ( arr [ i ] > arr [ i - 1 ] + arr [ 0 ] ) { System . out . print ( "-1" ) ; return ; } else { cost += Math . abs ( index . get ( arr [ i ] ) - i ) ; } } else { if ( arr [ i ] > arr [ i - 1 ] + arr [ i + 1 ] ) { System . out . print ( "-1" ) ; return ; } else { cost += Math . abs ( index . get ( arr [ i ] ) - i ) ; } } } System . out . print ( cost ) ; return ; }
int maxDistinctChar ( char [ ] s , int n , int k ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . containsKey ( ( int ) s [ i ] ) ) { freq . put ( ( int ) s [ i ] , freq . get ( ( int ) s [ i ] ) + 1 ) ; } else { freq . put ( ( int ) s [ i ] , 1 ) ; } } Vector < Integer > v = new Vector < Integer > ( ) ; for ( Map . Entry < Integer , Integer > it : freq . entrySet ( ) ) { v . add ( it . getValue ( ) ) ; } Collections . sort ( v ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int mn = Math . min ( v . get ( i ) - 1 , k ) ; v . set ( i , v . get ( i ) - mn ) ; k -= mn ; } if ( k > 0 ) { for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int mn = Math . min ( v . get ( i ) , k ) ; v . set ( i , v . get ( i ) - mn ) ; k -= mn ; } } int res = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) if ( v . get ( i ) == 1 ) res ++ ; return res ; }
int getMaxSum ( int i , int j , int k , int arr1 [ ] , int arr2 [ ] , int arr3 [ ] ) { int cnt = 0 ; if ( i >= n1 ) cnt ++ ; if ( j >= n2 ) cnt ++ ; if ( k >= n3 ) cnt ++ ; if ( cnt >= 2 ) return 0 ; if ( dp [ i ] [ j ] [ k ] != - 1 ) return dp [ i ] [ j ] [ k ] ; int ans = 0 ; if ( i < n1 && j < n2 ) ans = Math . max ( ans , getMaxSum ( i + 1 , j + 1 , k , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr2 [ j ] ) ; if ( i < n1 && k < n3 ) ans = Math . max ( ans , getMaxSum ( i + 1 , j , k + 1 , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr3 [ k ] ) ; if ( j < n2 && k < n3 ) ans = Math . max ( ans , getMaxSum ( i , j + 1 , k + 1 , arr1 , arr2 , arr3 ) + arr2 [ j ] * arr3 [ k ] ) ; dp [ i ] [ j ] [ k ] = ans ; return dp [ i ] [ j ] [ k ] ; }
int maxProductSum ( int arr1 [ ] , int arr2 [ ] , int arr3 [ ] ) { for ( int i = 0 ; i < dp . length ; i ++ ) for ( int j = 0 ; j < dp [ 0 ] . length ; j ++ ) for ( int k = 0 ; k < dp [ j ] [ 0 ] . length ; k ++ ) dp [ i ] [ j ] [ k ] = - 1 ; Arrays . sort ( arr1 ) ; reverse ( arr1 ) ; Arrays . sort ( arr2 ) ; reverse ( arr2 ) ; Arrays . sort ( arr3 ) ; reverse ( arr3 ) ; return getMaxSum ( 0 , 0 , 0 , arr1 , arr2 , arr3 ) ; }
void SieveOfEratosthenes ( ) { boolean [ ] prime = new boolean [ 10005 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= 1000 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= 1000 ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= 1000 ; p ++ ) if ( prime [ p ] ) primes . add ( p ) ; }
int findMaxValue ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int ans = arr [ n - 1 ] ; int maxPossible = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( maxPossible > 0 ) { if ( arr [ i ] >= maxPossible ) { ans += ( maxPossible - 1 ) ; maxPossible = maxPossible - 1 ; } else { maxPossible = arr [ i ] ; ans += maxPossible ; } } } return ans ; }
int countPairs ( int arr [ ] , int n ) { int ans = 0 ; Arrays . sort ( arr ) ; int left = 0 , right = 1 ; while ( right < n ) { if ( arr [ left ] == arr [ right ] ) ans += right - left ; else left = right ; right ++ ; } return ans ; }
int maximizeFinalElement ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; if ( arr [ 0 ] != 1 ) arr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 1 ) { arr [ i ] = arr [ i - 1 ] + 1 ; } } return arr [ n - 1 ] ; }
int findLeastDist ( int A [ ] , int N ) { Arrays . sort ( A ) ; if ( N % 2 == 0 ) { return A [ ( N - 1 ) / 2 ] ; } else { return A [ N / 2 ] ; } }
int maxSubMatSum ( int [ ] [ ] mat ) { int n = mat . length ; int m = mat [ 0 ] . length ; int i , j ; int [ ] [ ] dp = new int [ n ] [ m ] ; dp [ n - 1 ] [ m - 1 ] = mat [ n - 1 ] [ m - 1 ] ; int res = dp [ n - 1 ] [ m - 1 ] ; for ( i = m - 2 ; i >= 0 ; i -- ) { dp [ n - 1 ] [ i ] = mat [ n - 1 ] [ i ] + dp [ n - 1 ] [ i + 1 ] ; res = Math . max ( res , dp [ n - 1 ] [ i ] ) ; } for ( i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] [ m - 1 ] = mat [ i ] [ m - 1 ] + dp [ i + 1 ] [ m - 1 ] ; res = Math . max ( res , dp [ i ] [ m - 1 ] ) ; } for ( i = n - 2 ; i >= 0 ; i -- ) { for ( j = m - 2 ; j >= 0 ; j -- ) { dp [ i ] [ j ] = mat [ i ] [ j ] + dp [ i ] [ j + 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j + 1 ] ; res = Math . max ( res , dp [ i ] [ j ] ) ; } } return res ; }
int solution ( int A , int B , int C ) { int arr [ ] = new int [ 3 ] ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; Arrays . sort ( arr ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; }
long removeElements ( long arr [ ] , int n ) { Arrays . sort ( arr ) ; arr = reverse ( arr ) ; long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += arr [ i ] * Math . pow ( 2 , i ) ; } return ans ; }
boolean canMadeEqual ( int [ ] A , int [ ] B , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != B [ i ] ) { return false ; } } return true ; }
int maxMinDifference ( int arr [ ] , int n , int k ) { if ( k >= n - 1 ) return 0 ; Arrays . sort ( arr ) ; int ans = arr [ n - 1 ] - arr [ 0 ] ; for ( int i = k , j = n - 1 ; i >= 0 ; -- i , -- j ) { ans = Math . min ( arr [ j ] - arr [ i ] , ans ) ; } return ans ; }
int inversionCount ( String s ) { int [ ] freq = new int [ 26 ] ; int inv = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int temp = 0 ; for ( int j = 0 ; j < ( int ) ( s . charAt ( i ) - 'a' ) ; j ++ ) temp += freq [ j ] ; inv += ( i - temp ) ; freq [ s . charAt ( i ) - 'a' ] ++ ; } return inv ; }
int numberofpairs ( int [ ] arr , int N ) { int answer = 0 ; Arrays . sort ( arr ) ; int minDiff = 10000000 ; for ( int i = 0 ; i < N - 1 ; i ++ ) minDiff = Math . min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff ) answer ++ ; } return answer ; }
long dist ( Point p1 , Point p2 ) { long x0 = p1 . x - p2 . x ; long y0 = p1 . y - p2 . y ; return x0 * x0 + y0 * y0 ; }
void maximumSum ( int arr [ ] , int n , int k ) { int elt = n / k ; int sum = 0 ; Arrays . sort ( arr ) ; int count = 0 ; int i = n - 1 ; while ( count < k ) { sum += arr [ i ] ; i -- ; count ++ ; } count = 0 ; i = 0 ; while ( count < k ) { sum += arr [ i ] ; i += elt - 1 ; count ++ ; } System . out . println ( sum ) ; }
int countMinSteps ( int arr [ ] , int target , int n ) { Arrays . sort ( arr ) ; int minimumSteps = 0 ; int i = 0 ; int j = n - 1 ; while ( i <= j ) { if ( arr [ i ] + arr [ j ] <= target ) { i += 1 ; j -= 1 ; } else { j -= 1 ; } minimumSteps += 1 ; } return minimumSteps ; }
int build_num ( int [ ] bit ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) if ( bit [ i ] == 1 ) ans += ( 1 << i ) ; ans += 32 ; return ans ; }
int maximumOR ( int [ ] arr , int n , int k ) { int bit [ ] = new int [ 32 ] ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( bit [ i ] == 0 && k > 0 ) { int temp = build_num ( bit ) ; int temp1 = temp ; int val = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( temp1 < ( temp arr [ j ] ) ) { temp1 = temp | arr [ j ] ; val = arr [ j ] ; } } if ( val != - 1 ) { k -- ; for ( int j = 0 ; j < 32 ; j ++ ) { bit [ j ] ++ ; } } } } return build_num ( bit ) ; }
int findMinSum ( int [ ] arr , int K , int L , int size ) { if ( K * L > size ) return - 1 ; int minsum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ; return minsum ; }
void find_max_length ( int [ ] arr , int index , int sum , int k ) { sum = sum + arr [ index ] ; store . add ( arr [ index ] ) ; if ( sum == k ) { if ( max_length < store . size ( ) ) { max_length = store . size ( ) ; ans = store ; } } for ( int i = index + 1 ; i < arr . length ; i ++ ) { if ( sum + arr [ i ] <= k ) { find_max_length ( arr , i , sum , k ) ; store . remove ( store . size ( ) - 1 ) ; } else return ; } return ; }
int longestSubsequence ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_length >= n - i ) break ; store . clear ( ) ; find_max_length ( arr , i , 0 , k ) ; } return max_length ; }
void minBox ( int arr [ ] , int n ) { int box = n ; Arrays . sort ( arr ) ; int curr_box = 0 , next_box = 1 ; while ( curr_box < n && next_box < n ) { if ( arr [ curr_box ] < arr [ next_box ] ) { box -- ; curr_box ++ ; next_box ++ ; } else if ( arr [ curr_box ] == arr [ next_box ] ) next_box ++ ; } System . out . println ( box ) ; }
void setData ( node head ) { node tmp ; tmp = head ; while ( tmp != null ) { System . out . print ( tmp . data + " -> " ) ; tmp = tmp . next ; } }
double findMedian ( int a [ ] , int n ) { if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; }
void kStrongest ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; double median = findMedian ( arr , n ) ; int [ ] diff = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { diff [ i ] = ( int ) Math . abs ( median - arr [ i ] ) ; } int i = 0 , j = n - 1 ; while ( k > 0 ) { if ( diff [ i ] > diff [ j ] ) { System . out . print ( arr [ i ] + " " ) ; i ++ ; } else { System . out . print ( arr [ j ] + " " ) ; j -- ; } k -- ; } }
boolean sorting_possible ( int a [ ] , int b [ ] , int n ) { boolean sorted = true ; int type1 = 0 , type0 = 0 , i ; for ( i = 1 ; i < n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] ) { sorted = false ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( b [ i ] == 0 ) type0 ++ ; else type1 ++ ; } if ( sorted ) return true ; else if ( type1 == n type0 == n ) return false ; else return true ; }
void lexNumbers ( int n ) { Vector < String > s = new Vector < String > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { s . add ( String . valueOf ( i ) ) ; } Collections . sort ( s ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) ans . add ( Integer . valueOf ( s . get ( i ) ) ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans . get ( i ) + " " ) ; }
void dfs ( int temp , int n , List < Integer > sol ) { if ( temp > n ) return ; sol . add ( temp ) ; dfs ( temp * 10 , n , sol ) ; if ( temp % 10 != 9 ) dfs ( temp + 1 , n , sol ) ; }
int findMinDif ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; return ( arr [ N - 1 ] - arr [ N - 2 ] ) ; }
int partition ( int arr [ ] , int l , int h ) { int pivot = arr [ l ] ; int i = l + 1 ; int j = h ; while ( i <= j ) { while ( i <= h && arr [ i ] < pivot ) { i ++ ; } while ( j > l && arr [ j ] > pivot ) { j -- ; } if ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; i ++ ; j -- ; } else i ++ ; } arr [ l ] = arr [ j ] ; arr [ j ] = pivot ; return j ; }
void sortArray ( int arr [ ] , int l , int h ) { if ( l >= h ) return ; int pivot = partition ( arr , l , h ) ; sortArray ( arr , l , pivot - 1 ) ; sortArray ( arr , pivot + 1 , h ) ; }
int findMaxIntervals ( int start [ ] , int end [ ] , int n , int R ) { int ans = 0 ; int prev = 0 ; int currActive = 0 ; int i = 0 ; int j = 0 ; if ( start [ 0 ] > 0 ) ans ++ ; while ( i < n && j < n ) { if ( start [ i ] < end [ j ] ) { i ++ ; currActive ++ ; } else if ( start [ i ] > end [ j ] ) { j ++ ; currActive -- ; } else { i ++ ; j ++ ; } if ( currActive == 0 ) { ans ++ ; } } if ( end [ n - 1 ] < R ) ans ++ ; return ans ; }
void sortArray ( int A [ ] , int N ) { int x = 0 , y = 0 , z = 0 ; if ( N % 4 == 0 N % 4 == 1 ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } System . out . print ( "Sorted Array: " ) ; for ( int i = 0 ; i < N ; i ++ ) System . out . print ( A [ i ] + " " ) ; } else { System . out . print ( "-1" ) ; } }
void check_vector ( int [ ] A , int n , int [ ] p ) { int [ ] pos = new int [ A . length ] ; for ( int i = 0 ; i < p . length ; i ++ ) { pos [ p [ i ] - 1 ] = 1 ; } int flag = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( pos [ i ] == 0 ) continue ; int j = i ; while ( j < n && pos [ j ] != 0 ) ++ j ; Arrays . sort ( A , i , j + 1 ) ; i = j ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
void dfs ( int x ) { Vector < Integer > v = new Vector < > ( ) ; v . clear ( ) ; ns . clear ( ) ; for ( int it : s ) { if ( g [ x ] . get ( it ) != null ) { v . add ( it ) ; } else { ns . add ( it ) ; } } s = ns ; for ( int i : v ) { dfs ( i ) ; } }
void weightOfMST ( int N ) { int cnt = 0 ; for ( int i = 1 ; i <= N ; ++ i ) { s . add ( i ) ; } Vector < Integer > qt = new Vector < > ( ) ; for ( int t : s ) qt . add ( t ) ; while ( ! qt . isEmpty ( ) ) { ++ cnt ; int t = qt . get ( 0 ) ; qt . remove ( 0 ) ; dfs ( t ) ; } System . out . print ( cnt - 4 ) ; }
void sortDiff ( Vector < Integer > arr , int n ) { Collections . sort ( arr ) ; Vector < Integer > out = new Vector < Integer > ( ) ; while ( n > 0 ) { out . add ( arr . get ( n / 2 ) ) ; arr . remove ( n / 2 ) ; n = n - 1 ; } for ( int i : out ) System . out . print ( i + " " ) ; }
void minimumCost ( int arr [ ] , int N , int M ) { Arrays . sort ( arr ) ; int [ ] pref = new int [ N ] ; pref [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { pref [ i ] = arr [ i ] + pref [ i - 1 ] ; } for ( int i = M ; i < N ; i ++ ) { pref [ i ] += pref [ i - M ] ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( pref [ i ] + " " ) ; } }
int countPairs ( int [ ] A , int [ ] B ) { int n = A . length ; int ans = 0 ; Arrays . sort ( A ) ; Arrays . sort ( B ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; }
int uniqueSum ( int A [ ] , int R [ ] [ ] , int N , int M ) { for ( int i = 0 ; i < M ; ++ i ) { int l = R [ i ] [ 0 ] , r = R [ i ] [ 1 ] + 1 ; l -- ; r -- ; A [ l ] ++ ; if ( r < N ) A [ r ] -- ; } for ( int i = 1 ; i < N ; ++ i ) { A [ i ] += A [ i - 1 ] ; } int ans = 0 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { if ( ! s . contains ( A [ i ] ) ) ans += A [ i ] ; s . add ( A [ i ] ) ; } return ans ; }
void kthpair ( int n , int k , int arr [ ] ) { int i , t = 0 ; Arrays . sort ( arr ) ; -- k ; for ( i = 0 ; i < n ; i += t ) { for ( t = 1 ; arr [ i ] == arr [ i + t ] ; ++ t ) ; if ( t * n > k ) break ; k = k - t * n ; } System . out . print ( arr [ i ] + " " + arr [ k / t ] ) ; }
int minOperations ( String s ) { Integer freq [ ] = new Integer [ 26 ] ; Arrays . fill ( freq , 0 ) ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { freq [ s . charAt ( i ) - 'A' ] ++ ; } Arrays . sort ( freq , Collections . reverseOrder ( ) ) ; int answer = n ; for ( int i = 1 ; i <= 26 ; i ++ ) { if ( n % i == 0 ) { int x = n / i ; int y = 0 ; for ( int j = 0 ; j < i ; j ++ ) { y += Math . min ( freq [ j ] , x ) ; } answer = Math . min ( answer , n - y ) ; } } return answer ; }
void printArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
void sortArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; ) { if ( arr [ i ] == i + 1 ) { i ++ ; } else { int temp1 = arr [ i ] ; int temp2 = arr [ arr [ i ] - 1 ] ; arr [ i ] = temp2 ; arr [ temp1 - 1 ] = temp1 ; } } }
boolean fun ( int [ ] arr , int n , int k ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i ; j < n ; j += k ) { v . add ( arr [ j ] ) ; } Collections . sort ( v ) ; int x = 0 ; for ( int j = i ; j < n ; j += k ) { arr [ j ] = v . get ( x ) ; x ++ ; } v . clear ( ) ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { return false ; } } return true ; }
void CheckSort ( Vector < Integer > arr , int k , int n ) { Vector < Integer > sortarr = new Vector < Integer > ( ) ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { sortarr . add ( arr . get ( i ) ) ; } Collections . sort ( sortarr ) ; if ( k == 1 ) System . out . println ( "yes" ) ; else { int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { flag = 0 ; for ( int j = i ; j < n ; j += k ) { if ( sortarr . get ( i ) == arr . get ( j ) ) { Collections . swap ( arr , i , j ) ; flag = 1 ; break ; } if ( j + k >= n ) break ; } if ( flag == 0 ) break ; } if ( flag == 0 ) System . out . println ( "Not possible to sort" ) ; else System . out . println ( "Possible to sort" ) ; } }
void sortedAdjacentDifferences ( int arr [ ] , int n ) { int [ ] ans = new int [ n ] ; Arrays . sort ( arr ) ; int l = 0 , r = n - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 == 1 ) { ans [ i ] = arr [ l ] ; l ++ ; } else { ans [ i ] = arr [ r ] ; r -- ; } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + " " ) ; } }
int get_permutation ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { result += Math . abs ( arr [ i ] - ( i + 1 ) ) ; } return result ; }
int minimumIncDec ( int arr [ ] , int N , int maxE , int minE ) { if ( N == 0 ) { return 0 ; } if ( dp [ N ] [ maxE ] != 0 ) return dp [ N ] [ maxE ] ; int ans = Integer . MAX_VALUE ; for ( int k = minE ; k <= maxE ; k ++ ) { int x = minimumIncDec ( arr , N - 1 , k , minE ) ; ans = Math . min ( ans , x + Math . abs ( arr [ N - 1 ] - k ) ) ; } dp [ N ] [ maxE ] = ans ; return dp [ N ] [ maxE ] ; }
int maxSumArrangement ( int A [ ] , int R [ ] [ ] , int N , int M ) { int count [ ] = new int [ N ] ; int i ; for ( i = 0 ; i < M ; ++ i ) { int l = R [ i ] [ 0 ] , r = R [ i ] [ 1 ] + 1 ; l -- ; r -- ; count [ l ] ++ ; if ( r < N ) count [ r ] -- ; } for ( i = 1 ; i < N ; ++ i ) { count [ i ] += count [ i - 1 ] ; } int ans = 0 ; Arrays . sort ( count ) ; Arrays . sort ( A ) ; for ( i = N - 1 ; i >= 0 ; -- i ) { ans += A [ i ] * count [ i ] ; } return ans ; }
int make_permutation ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += Math . abs ( i + 1 - arr [ i ] ) ; return ans ; }
int maxSum ( int [ ] [ ] V , int n , int m ) { int ans = 0 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { ArrayList < int [ ] > aux = new ArrayList < > ( ) ; for ( int j = 0 ; j < m ; ++ j ) { aux . add ( new int [ ] { V [ i + 1 ] [ j ] , j } ) ; } Collections . sort ( aux , ( a , b ) -> b [ 0 ] - a [ 0 ] ) ; for ( int j = 0 ; j < m ; ++ j ) { for ( int k = 0 ; k < m ; ++ k ) { if ( aux . get ( k ) [ 1 ] - j == 0 || Math . abs ( aux . get ( k ) [ 1 ] - j ) > 1 ) { V [ i ] [ j ] += aux . get ( k ) [ 0 ] ; break ; } } } } for ( int i = 0 ; i < m ; ++ i ) { ans = Math . max ( ans , V [ 0 ] [ i ] ) ; } return ans ; }
int minimumProduct ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int product = 1 ; for ( int i = 0 ; i < n ; i += 2 ) { product *= ( arr [ i ] + arr [ i + 1 ] ) ; } return product ; }
boolean isVowel ( char ch ) { ch = Character . toUpperCase ( ch ) ; return ( ch == 'A' ch == 'E' ch == 'I' ch == 'O' ch == 'U' ) ; }
void sortArr ( String arr [ ] , int n ) { ArrayList < pair > vp = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { vp . add ( new pair ( countVowels ( arr [ i ] ) , arr [ i ] ) ) ; } Collections . sort ( vp , ( a , b ) -> a . first - b . first ) ; for ( int i = 0 ; i < vp . size ( ) ; i ++ ) System . out . print ( vp . get ( i ) . second + " " ) ; }
boolean checkIsGP ( double arr [ ] , int n ) { if ( n == 1 ) return true ; Arrays . sort ( arr ) ; double r = arr [ 1 ] / arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] / arr [ i - 1 ] != r ) return false ; } return true ; }
boolean checkIsHP ( double arr [ ] , int n ) { if ( n == 1 ) { return true ; } double [ ] rec = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { rec [ i ] = ( ( 1 / arr [ i ] ) ) ; } if ( checkIsAP ( rec , n ) ) return true ; else return false ; }
int reversDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }
void sortArr ( int arr [ ] , int n ) { ArrayList < int [ ] > vp = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { vp . add ( new int [ ] { reversDigits ( arr [ i ] ) , arr [ i ] } ) ; } Collections . sort ( vp , ( a , b ) -> a [ 0 ] - b [ 0 ] ) ; for ( int i = 0 ; i < vp . size ( ) ; i ++ ) System . out . print ( vp . get ( i ) [ 1 ] + " " ) ; }
void sortMat ( int [ ] [ ] data , int row , int col ) { int size = row * col ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = 0 ; j < size - 1 ; j ++ ) { if ( data [ j / col ] [ j % col ] > data [ ( j + 1 ) / col ] [ ( j + 1 ) % col ] ) { int temp = data [ j / col ] [ j % col ] ; data [ j / col ] [ j % col ] = data [ ( j + 1 ) / col ] [ ( j + 1 ) % col ] ; data [ ( j + 1 ) / col ] [ ( j + 1 ) % col ] = temp ; } } } }
int minimiseMedian ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; return Math . abs ( arr [ n / 2 ] - arr [ ( n / 2 ) - 1 ] ) ; }
int sortByFreq ( Integer [ ] arr , int n ) { int maxE = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { maxE = Math . max ( maxE , arr [ i ] ) ; } int freq [ ] = new int [ maxE + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int cnt = 0 ; for ( int i = 0 ; i <= maxE ; i ++ ) { if ( freq [ i ] > 0 ) { int value = 100000 - i ; arr [ cnt ] = 100000 * freq [ i ] + value ; cnt ++ ; } } return cnt ; }
void printSortedArray ( Integer [ ] arr , int cnt ) { for ( int i = 0 ; i < cnt ; i ++ ) { int frequency = arr [ i ] / 100000 ; int value = 100000 - ( arr [ i ] % 100000 ) ; for ( int j = 0 ; j < frequency ; j ++ ) { System . out . print ( value + " " ) ; } } }
boolean canBeEqual ( int a , int b , int c , int k ) { int [ ] arr = new int [ 3 ] ; arr [ 0 ] = a ; arr [ 1 ] = b ; arr [ 2 ] = c ; Arrays . sort ( arr ) ; int diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; k = k - diff ; if ( k < 0 k % 3 != 0 ) return false ; return true ; }
int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( ( arr [ l ] == arr [ mid ] ) && ( arr [ h ] == arr [ mid ] ) ) { l ++ ; h -- ; return search ( arr , l , h , key ) ; } else if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; else return search ( arr , mid + 1 , h , key ) ; } else if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
int [ ] orgazineInOrder ( int [ ] vec , int [ ] op , int n ) { int [ ] result = new int [ n ] ; Arrays . sort ( vec ) ; int i = 0 , j = n - 1 , k = 0 ; while ( i <= j && k <= n - 2 ) { if ( op [ k ] == '<' ) { result [ k ] = vec [ i ++ ] ; } else { result [ k ] = vec [ j -- ] ; } k ++ ; } result [ n - 1 ] = vec [ i ] ; return result ; }
long minimumCost ( long price [ ] , int n ) { Arrays . sort ( price ) ; long totalCost = 0 ; for ( int i = n - 1 ; i > 1 ; i -= 2 ) { if ( i == 2 ) { totalCost += price [ 2 ] + price [ 0 ] ; } else { long price_first = price [ i ] + price [ 0 ] + 2 * price [ 1 ] ; long price_second = price [ i ] + price [ i - 1 ] + 2 * price [ 0 ] ; totalCost += Math . min ( price_first , price_second ) ; } } if ( n == 1 ) { totalCost += price [ 0 ] ; } else { totalCost += price [ 1 ] ; } return totalCost ; }
boolean checkRectangles ( int [ ] arr , int n ) { boolean ans = true ; Arrays . sort ( arr ) ; int area = arr [ 0 ] * arr [ 4 * n - 1 ] ; for ( int i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) { ans = false ; break ; } } if ( ans ) return true ; return false ; }
int findMin ( int arr [ ] , int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; ans = Math . max ( ans , j - i ) ; i = j - 1 ; } return n - ans ; }
int countSubSeq ( int a [ ] , int n , int k ) { Arrays . sort ( a ) ; List < Integer > arr = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; ) { int count = 1 , x = a [ i ] ; i ++ ; while ( i < n && a [ i ] == x ) { count ++ ; i ++ ; } arr . add ( count ) ; } int m = arr . size ( ) ; n = Math . min ( m , k ) ; int count = 1 ; int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = m ; j >= 0 ; j -- ) { if ( j > m - i ) dp [ i ] [ j ] = 0 ; else { dp [ i ] [ j ] = dp [ i ] [ j + 1 ] + arr . get ( j ) * dp [ i - 1 ] [ j + 1 ] ; } } count = count + dp [ i ] [ 0 ] ; } return count ; }
int maxMod ( int arr [ ] , int n ) { int maxVal = max_element ( arr , n ) ; int secondMax = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < maxVal && arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } } return secondMax ; }
String partOdd ( String s ) { String st = "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( i % 2 != 0 ) st += s . charAt ( i ) ; } return st ; }
String partEven ( String str ) { String s = "" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( i % 2 == 0 ) s += str . charAt ( i ) ; } return s ; }
void sortStack ( Stack < Integer > input , int k ) { Stack < Integer > tmpStack = new Stack < Integer > ( ) ; while ( ! input . isEmpty ( ) ) { int tmp = input . peek ( ) ; input . pop ( ) ; while ( ! tmpStack . isEmpty ( ) ) { int tmpStackMod = tmpStack . peek ( ) % k ; int tmpMod = tmp % k ; if ( ( tmpStackMod > tmpMod ) || ( tmpStackMod == tmpMod && tmpStack . peek ( ) > tmp ) ) { input . push ( tmpStack . peek ( ) ) ; tmpStack . pop ( ) ; } else break ; } tmpStack . push ( tmp ) ; } while ( ! tmpStack . isEmpty ( ) ) { input . push ( tmpStack . peek ( ) ) ; tmpStack . pop ( ) ; } while ( ! input . empty ( ) ) { System . out . print ( input . peek ( ) + " " ) ; input . pop ( ) ; } }
int maxLen ( int [ ] arr , int n ) { int c_sum = 0 ; Arrays . sort ( arr ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { c_sum += arr [ i ] ; if ( c_sum < 0 ) return i ; } return n ; }
boolean isPossible ( int range [ ] [ ] , int N ) { interval test [ ] = new interval [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { test [ i ] = new interval ( ) ; test [ i ] . l = range [ i ] [ 0 ] ; test [ i ] . r = range [ i ] [ 1 ] ; test [ i ] . v = range [ i ] [ 2 ] ; } Arrays . sort ( test , new Sort ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { int count [ ] = new int [ MAX ] ; int current_velocity = test [ i ] . v ; int j = i ; while ( j < N && test [ j ] . v == current_velocity ) { for ( int k = test [ j ] . l ; k <= test [ j ] . r ; k ++ ) { count [ k ] ++ ; if ( count [ k ] >= 3 ) return false ; } j ++ ; } i = j - 1 ; } return true ; }
int maxSum ( int a [ ] , int n ) { Arrays . sort ( a ) ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i += 2 ) { sum += a [ i ] ; } return sum ; }
int minSteps ( int arr [ ] , int n ) { int maxVal = getMax ( arr ) ; return maxVal ; }
boolean isPossible ( int A [ ] , int B [ ] , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; Arrays . sort ( A ) ; Arrays . sort ( B ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; }
void sortWithRemainder ( int [ ] arr , int n , int k ) { ArrayList < ArrayList < Integer > > v = new ArrayList < ArrayList < Integer > > ( k ) ; for ( int i = 0 ; i < k ; i ++ ) v . add ( new ArrayList < Integer > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int t = arr [ i ] % k ; v . get ( t ) . add ( arr [ i ] ) ; } for ( int i = 0 ; i < k ; i ++ ) { Collections . sort ( v . get ( i ) ) ; } int j = 0 ; for ( int i = 0 ; i < k ; i ++ ) { for ( int x : v . get ( i ) ) { arr [ j ] = x ; j ++ ; } } printArr ( arr , n ) ; }
int minOperations ( int ar [ ] , int k ) { Arrays . sort ( ar ) ; int opsNeeded = 0 ; for ( int i = 0 ; i < k ; i ++ ) { opsNeeded += ar [ k - 1 ] - ar [ i ] ; } int ans = opsNeeded ; for ( int i = k ; i < ar . length ; i ++ ) { opsNeeded = opsNeeded - ( ar [ i - 1 ] - ar [ i - k ] ) ; opsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) ; ans = Math . min ( ans , opsNeeded ) ; } return ans ; }
int getNumber ( int n , int k ) { int [ ] arr = new int [ n ] ; int i = 0 ; int odd = 1 ; while ( odd <= n ) { arr [ i ++ ] = odd ; odd += 2 ; } int even = 2 ; while ( even <= n ) { arr [ i ++ ] = even ; even += 2 ; } return arr [ k - 1 ] ; }
int getNumber ( int n , int k ) { int pos ; if ( ( n % 2 ) == 0 ) { pos = n / 2 ; } else { pos = ( n / 2 ) + 1 ; } if ( k <= pos ) { return ( k * 2 - 1 ) ; } else return ( ( k - pos ) * 2 ) ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
int CountPermutation ( int a [ ] , int n ) { int ways = 1 ; Arrays . sort ( a ) ; int size = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { size ++ ; } else { ways *= fact [ size ] ; size = 1 ; } } ways *= fact [ size ] ; return ways ; }
void dfs ( int num , int left , int ct ) { if ( ct >= 15 ) return ; if ( left == 0 ) ans . add ( num ) ; for ( int i = 0 ; i <= Math . min ( left , 9 ) ; i ++ ) dfs ( num * 10 + i , left - i , ct + 1 ) ; }
int getKthNum ( int m , int k ) { dfs ( 0 , m , 0 ) ; int ct = 0 ; for ( int it : ans ) { ct ++ ; if ( ct == k ) { return it ; } } return - 1 ; }
int Min_Replace ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; Integer [ ] freq = new Integer [ MAX ] ; Arrays . fill ( freq , 0 ) ; int p = 0 ; freq [ p ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } Arrays . sort ( freq , Collections . reverseOrder ( ) ) ; int ans = 0 ; for ( int i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; }
int minCost ( int cost [ ] [ ] ) { int dist [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; }
int Segment ( int x [ ] , int l [ ] , int n ) { if ( n == 1 ) return 1 ; int ans = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ; else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) { x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } } return ans ; }
int Next_greater ( int a [ ] , int n , int x ) { Arrays . sort ( a ) ; int low = 0 , high = n - 1 , ans = x + 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( a [ mid ] <= ans ) { if ( a [ mid ] == ans ) { ans ++ ; high = n - 1 ; } low = mid + 1 ; } else high = mid - 1 ; } return ans ; }
void Combination ( Vector < Integer > A , int K ) { Collections . sort ( A ) ; Vector < Integer > local = new Vector < Integer > ( ) ; unique_combination ( 0 , 0 , K , local , A ) ; }
void xorOnSortedArray ( int [ ] arr , int n , int k , int x ) { int [ ] arr1 = new int [ MAX + 1 ] ; int [ ] arr2 = new int [ MAX + 1 ] ; int [ ] xor_val = new int [ MAX + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) arr1 [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= MAX ; i ++ ) xor_val [ i ] = i ^ x ; while ( k -- > 0 ) { int count = 0 ; for ( int i = 0 ; i <= MAX ; i ++ ) { int store = arr1 [ i ] ; if ( arr1 [ i ] > 0 ) { if ( count % 2 == 0 ) { int div = ( int ) Math . ceil ( arr1 [ i ] / 2 ) ; arr1 [ i ] = arr1 [ i ] - div ; arr2 [ xor_val [ i ] ] += div ; } else if ( count % 2 != 0 ) { int div = arr1 [ i ] / 2 ; arr1 [ i ] = arr1 [ i ] - div ; arr2 [ xor_val [ i ] ] += div ; } } count = count + store ; } for ( int i = 0 ; i <= MAX ; i ++ ) { arr1 [ i ] = arr1 [ i ] + arr2 [ i ] ; arr2 [ i ] = 0 ; } } int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i <= MAX ; i ++ ) { if ( arr1 [ i ] > 0 ) { if ( min > i ) min = i ; if ( max < i ) max = i ; } } System . out . println ( min + " " + max ) ; }
int pairs_count ( int arr [ ] , int n , int sum ) { int ans = 0 ; Arrays . sort ( arr ) ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { int x = arr [ i ] , xx = i ; while ( ( i < j ) && ( arr [ i ] == x ) ) i ++ ; int y = arr [ j ] , yy = j ; while ( ( j >= i ) && ( arr [ j ] == y ) ) j -- ; if ( x == y ) { int temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; }
ArrayList < Integer > findSubarray ( int a [ ] , int k , int n ) { ArrayList < ArrayList < Integer > > vec = new ArrayList < ArrayList < Integer > > ( ) ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { ArrayList < Integer > temp = new ArrayList < Integer > ( ) ; for ( int j = i ; j < i + k ; j ++ ) { temp . add ( a [ j ] ) ; } vec . add ( temp ) ; } Collections . sort ( vec , new Comparator < ArrayList < Integer > > ( ) { @ Override public int compare ( ArrayList < Integer > o1 , ArrayList < Integer > o2 ) { return o1 . get ( 0 ) . compareTo ( o2 . get ( 0 ) ) ; } } ) ; return vec . get ( vec . size ( ) - 1 ) ; }
float knapSack ( int W , float wt [ ] , float val [ ] , int n ) { float maxratio = Integer . MIN_VALUE ; int maxindex = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( val [ i ] / wt [ i ] ) > maxratio ) { maxratio = ( val [ i ] / wt [ i ] ) ; maxindex = i ; } } return ( W * maxratio ) ; }
void sortArray ( int a [ ] , int n ) { Vector < Integer > ans = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) ans . add ( a [ i ] ) ; } Collections . sort ( ans ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) { a [ i ] = ans . get ( j ) ; j ++ ; } } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " " ) ; }
int solution ( int arr [ ] , int x ) { int closestSum = Integer . MAX_VALUE ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = i + 1 ; j < arr . length ; j ++ ) { for ( int k = j + 1 ; k < arr . length ; k ++ ) { if ( Math . abs ( x - closestSum ) > Math . abs ( x - ( arr [ i ] + arr [ j ] + arr [ k ] ) ) ) closestSum = ( arr [ i ] + arr [ j ] + arr [ k ] ) ; } } } return closestSum ; }
int solution ( Vector < Integer > arr , int x ) { Collections . sort ( arr ) ; long closestSum = Integer . MAX_VALUE ; for ( int i = 0 ; i < arr . size ( ) - 2 ; i ++ ) { int ptr1 = i + 1 , ptr2 = arr . size ( ) - 1 ; while ( ptr1 < ptr2 ) { int sum = arr . get ( i ) + arr . get ( ptr1 ) + arr . get ( ptr2 ) ; if ( abs ( x - sum ) < abs ( x - closestSum ) ) { closestSum = sum ; } if ( sum > x ) { ptr2 -- ; } else { ptr1 ++ ; } } } return ( int ) closestSum ; }
ArrayList < Integer > makearray ( ArrayList < ArrayList < Integer > > v , int V ) { ArrayList < ArrayList < Integer > > adj = new ArrayList < ArrayList < Integer > > ( ) ; for ( int i = 0 ; i < V ; i ++ ) { adj . add ( new ArrayList < Integer > ( ) ) ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { for ( int j = 0 ; j < v . get ( i ) . size ( ) - 1 ; j ++ ) { addEdge ( adj , v . get ( i ) . get ( j ) , v . get ( i ) . get ( j + 1 ) ) ; } } ArrayList < Integer > indeg = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < V ; i ++ ) { indeg . add ( 0 ) ; } getindeg ( adj , V , indeg ) ; ArrayList < Integer > res = topo ( adj , V , indeg ) ; return res ; }
boolean existsTriplet ( int a [ ] , int b [ ] , int c [ ] , int x , int l1 , int l2 , int l3 ) { if ( l2 <= l1 && l2 <= l3 ) { swap ( l2 , l1 ) ; swap ( a , b ) ; } else if ( l3 <= l1 && l3 <= l2 ) { swap ( l3 , l1 ) ; swap ( a , c ) ; } for ( int i = 0 ; i < l1 ; i ++ ) { int j = 0 , k = l3 - 1 ; while ( j < l2 && k >= 0 ) { if ( a [ i ] + b [ j ] + c [ k ] == x ) return true ; if ( a [ i ] + b [ j ] + c [ k ] < x ) j ++ ; else k -- ; } } return false ; }
void compressArr ( int arr [ ] , int n ) { int i = 0 , j = 0 ; Arrays . sort ( arr ) ; while ( i < n ) { j = i ; while ( ( j + 1 < n ) && ( arr [ j + 1 ] == arr [ j ] + 1 ) ) { j ++ ; } if ( i == j ) { System . out . print ( arr [ i ] + " " ) ; i ++ ; } else { System . out . print ( arr [ i ] + "-" + arr [ j ] + " " ) ; i = j + 1 ; } } }
int partition ( char arr [ ] , int low , int high , int mod ) { char pivot = arr [ high ] ; int i = ( low - 1 ) ; int piv = pivot % mod ; for ( int j = low ; j <= high - 1 ; j ++ ) { int a = arr [ j ] % mod ; if ( a <= piv ) { i ++ ; char t = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = t ; } } char t = arr [ i + 1 ] ; arr [ i + 1 ] = arr [ high ] ; arr [ high ] = t ; return ( i + 1 ) ; }
void printArray ( char arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
boolean check ( int [ ] arr , int n ) { int modify = 0 ; if ( arr [ n - 1 ] >= arr [ n - 2 ] ) { arr [ n - 1 ] = arr [ n - 2 ] - 1 ; modify ++ ; } if ( arr [ 0 ] <= arr [ 1 ] ) { arr [ 0 ] = arr [ 1 ] + 1 ; modify ++ ; } for ( int i = n - 2 ; i > 0 ; i -- ) { if ( ( arr [ i - 1 ] <= arr [ i ] && arr [ i + 1 ] <= arr [ i ] ) || ( arr [ i - 1 ] >= arr [ i ] && arr [ i + 1 ] >= arr [ i ] ) ) { arr [ i ] = ( arr [ i - 1 ] + arr [ i + 1 ] ) / 2 ; modify ++ ; if ( arr [ i ] == arr [ i - 1 ] arr [ i ] == arr [ i + 1 ] ) return false ; } } if ( modify > 1 ) return false ; return true ; }
void inorder ( Node root ) { if ( root != null ) { inorder ( root . left ) ; System . out . print ( root . data + " " ) ; inorder ( root . right ) ; } }
void merge ( Node root1 , Node root2 ) { if ( root1 == null && root2 == null ) return ; if ( root1 == null ) { inorder ( root2 ) ; return ; } if ( root2 == null ) { inorder ( root1 ) ; return ; } Node temp1 = root1 ; Node prev1 = null ; while ( temp1 . left != null ) { prev1 = temp1 ; temp1 = temp1 . left ; } Node temp2 = root2 ; Node prev2 = null ; while ( temp2 . left != null ) { prev2 = temp2 ; temp2 = temp2 . left ; } if ( temp1 . data <= temp2 . data ) { System . out . print ( temp1 . data + " " ) ; if ( prev1 == null ) { merge ( root1 . right , root2 ) ; } else { prev1 . left = temp1 . right ; merge ( root1 , root2 ) ; } } else { System . out . print ( temp2 . data + " " ) ; if ( prev2 == null ) { merge ( root1 , root2 . right ) ; } else { prev2 . left = temp2 . right ; merge ( root1 , root2 ) ; } } }
boolean IsSorted ( int [ ] A , int [ ] B , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int x , y ; x = Math . max ( A [ i ] , B [ i ] ) ; y = Math . min ( A [ i ] , B [ i ] ) ; A [ i ] = x ; B [ i ] = y ; } for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] <= A [ i - 1 ] B [ i ] <= B [ i - 1 ] ) return false ; } return true ; }
void removeElements ( int [ ] arr , int n ) { int [ ] brr = new int [ n ] ; int l = 1 ; brr [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( brr [ l - 1 ] <= arr [ i ] ) { brr [ l ] = arr [ i ] ; l ++ ; } } for ( int i = 0 ; i < l ; i ++ ) System . out . print ( brr [ i ] + " " ) ; }
int maxWater ( int height [ ] , int n ) { int max = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int current = ( Math . min ( height [ i ] , height [ j ] ) * ( j - i - 1 ) ) ; max = Math . max ( max , current ) ; } } return max ; }
int maxSelectionCount ( int a [ ] , int n ) { int res = 0 ; Arrays . sort ( a ) ; int select = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= select ) { res ++ ; select ++ ; } } return res ; }
void findCombinations ( int n ) { int [ ] a = new int [ n ] ; findCombinationsUtil ( a , 0 , n , n ) ; }
boolean check ( int arr [ ] , int n ) { int modify = 0 ; if ( arr [ 0 ] > arr [ 1 ] ) { arr [ 0 ] = arr [ 1 ] / 2 ; modify ++ ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( arr [ i - 1 ] < arr [ i ] && arr [ i + 1 ] < arr [ i ] ) || ( arr [ i - 1 ] > arr [ i ] && arr [ i + 1 ] > arr [ i ] ) ) { arr [ i ] = ( arr [ i - 1 ] + arr [ i + 1 ] ) / 2 ; if ( arr [ i ] == arr [ i - 1 ] arr [ i ] == arr [ i + 1 ] ) return false ; modify ++ ; } } if ( arr [ n - 1 ] < arr [ n - 2 ] ) modify ++ ; if ( modify > 1 ) return false ; return true ; }
boolean checkDivisors ( int a [ ] , int n ) { int X = max_element ( a ) ; Vector < Integer > b = new Vector < Integer > ( ) ; for ( int i = 1 ; i * i <= X ; i ++ ) { if ( X % i == 0 ) { b . add ( i ) ; if ( X / i != i ) b . add ( X / i ) ; } } if ( b . size ( ) != n ) return false ; Arrays . sort ( a ) ; Collections . sort ( b ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( b . get ( i ) != a [ i ] ) return false ; } return true ; }
int findX ( int a [ ] , int n ) { Arrays . sort ( a ) ; int x = a [ 0 ] * a [ n - 1 ] ; Vector < Integer > vec = new Vector < Integer > ( ) ; for ( int i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { vec . add ( i ) ; if ( ( x / i ) != i ) vec . add ( x / i ) ; } } Collections . sort ( vec ) ; if ( vec . size ( ) != n ) return - 1 ; else { int i = 0 ; for ( int it : vec ) { if ( a [ i ++ ] != it ) return - 1 ; } } return x ; }
void seive ( ) { for ( int i = 2 ; i < N ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i + i ; j < N ; j += i ) { prime [ j ] = 1 ; } } } prime [ 1 ] = 1 ; }
int maxSizeArr ( int arr [ ] , int n , int k ) { ArrayList < Integer > v = new ArrayList < Integer > ( ) ; ArrayList < Integer > diff = new ArrayList < Integer > ( ) ; int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == 1 ) { v . add ( i ) ; } } num = 0 ; for ( int i = 1 ; i < v . size ( ) ; i ++ ) { diff . add ( v . get ( i ) - v . get ( i - 1 ) - 1 ) ; } Collections . sort ( diff ) ; for ( int i = 1 ; i < diff . size ( ) ; i ++ ) { diff . set ( i , diff . get ( i ) + diff . get ( i - 1 ) ) ; } if ( k > n || ( k == 0 && v . size ( ) > 0 ) ) { return - 1 ; } else if ( v . size ( ) <= k ) { return ( n - k ) ; } else if ( v . size ( ) > k ) { int tt = v . size ( ) - k ; int sum = 0 ; sum += diff . get ( tt - 1 ) ; int res = n - ( v . size ( ) + sum ) ; return res ; } return 1 ; }
void pendulumArrangement ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int odd , temp , in , pos ; pos = n - 1 ; if ( n % 2 == 0 ) odd = n - 1 ; else odd = n - 2 ; while ( odd > 0 ) { temp = arr [ odd ] ; in = odd ; while ( in != pos ) { arr [ in ] = arr [ in + 1 ] ; in ++ ; } arr [ in ] = temp ; odd = odd - 2 ; pos = pos - 1 ; } int start = 0 , end = ( n - 1 ) / 2 ; for ( ; start < end ; start ++ , end -- ) { temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
long CountSubset ( int [ ] arr , int n ) { long ans = powmod ( 2 , n - 1 ) ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; ++ i ) { int j = i + 1 ; while ( j < n && arr [ j ] == arr [ i ] ) { int r = n - 1 - j ; int l = i ; ans = ( ans + nCr ( l + r , l ) ) % mod ; j ++ ; } } return ans ; }
void Preprocess ( ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= 1000 ; ++ i ) { arr [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i ; ++ j ) { arr [ i ] [ j ] = ( arr [ i - 1 ] [ j - 1 ] + arr [ i - 1 ] [ j ] ) % mod ; } arr [ i ] [ i ] = 1 ; } }
long powmod ( long a , long n ) { if ( n == 0 ) { return 1 ; } long pt = powmod ( a , n / 2 ) ; pt = ( pt * pt ) % mod ; if ( n % 2 == 1 ) { return ( pt * a ) % mod ; } else { return pt ; } }
long CountSubset ( int [ ] val , int n ) { long ans = powmod ( 2 , n - 1 ) ; Arrays . sort ( val ) ; for ( int i = 0 ; i < n ; ++ i ) { int j = i + 1 ; while ( j < n && val [ j ] == val [ i ] ) { int r = n - 1 - j ; int l = i ; ans = ( ans + arr [ l + r ] [ l ] ) % mod ; j ++ ; } } return ans ; }
void reArrange ( String words [ ] , int n ) { HashMap < String , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { freq . put ( words [ i ] , ( i + 1 ) ) ; } Arrays . sort ( words ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( freq . get ( words [ i ] ) + " " ) ; }
int findNumber ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int max = arr [ n - 1 ] ; int table [ ] = new int [ ( 2 * max ) + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) table [ i ] = Integer . MAX_VALUE ; int ans = - 1 ; for ( int i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] <= i ) { int res = table [ i - arr [ j ] ] ; if ( res != Integer . MAX_VALUE && res + 1 < table [ i ] ) table [ i ] = res + 1 ; } } if ( i > arr [ n - 1 ] && table [ i ] == Integer . MAX_VALUE ) { ans = i ; break ; } } return ans ; }
long power ( long x , long y ) { long res = 1 ; x = x % MOD ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % MOD ; } y = y >> 1 ; x = ( x * x ) % MOD ; } return res % MOD ; }
void combi ( int n , int k ) { int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] % MOD + C [ i - 1 ] [ j ] % MOD ) % MOD ; } } }
int findSumofEle ( int arr1 [ ] , int m , int arr2 [ ] , int n ) { int hash [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { hash [ arr2 [ i ] ] ++ ; } for ( int i = 1 ; i < MAX ; i ++ ) { hash [ i ] = hash [ i ] + hash [ i - 1 ] ; } int maximumFreq = 0 ; for ( int i = 0 ; i < m ; i ++ ) { maximumFreq = Math . max ( maximumFreq , hash [ arr1 [ i ] ] ) ; } int sumOfElements = 0 ; for ( int i = 0 ; i < m ; i ++ ) { sumOfElements += ( maximumFreq == hash [ arr1 [ i ] ] ) ? arr1 [ i ] : 0 ; } return sumOfElements ; }
int MinimizeleftOverSum ( int a [ ] , int n ) { Vector < Integer > v1 = new Vector < Integer > ( ) , v2 = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) v1 . add ( a [ i ] ) ; else v2 . add ( a [ i ] ) ; } if ( v1 . size ( ) > v2 . size ( ) ) { Collections . sort ( v1 ) ; Collections . sort ( v2 ) ; int x = v1 . size ( ) - v2 . size ( ) - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v1 . get ( i ++ ) ; } return sum ; } else if ( v2 . size ( ) > v1 . size ( ) ) { Collections . sort ( v1 ) ; Collections . sort ( v2 ) ; int x = v2 . size ( ) - v1 . size ( ) - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v2 . get ( i ++ ) ; } return sum ; } else return 0 ; }
void printList ( Node head ) { while ( head != null ) { System . out . print ( head . data + " " ) ; head = head . next ; } }
void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] ) ; }
int compare ( int num1 , int num2 ) { String A = Integer . toString ( num1 ) ; String B = Integer . toString ( num2 ) ; return ( A + B ) . compareTo ( B + A ) ; }
void printSmallest ( int N , int [ ] arr ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( compare ( arr [ i ] , arr [ j ] ) > 0 ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } printArr ( arr , N ) ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
boolean isUgly ( int n ) { while ( n % 2 == 0 ) n = n / 2 ; while ( n % 3 == 0 ) n = n / 3 ; while ( n % 5 == 0 ) n = n / 5 ; if ( n == 1 ) return true ; return false ; }
void sortUglyNumbers ( int arr [ ] , int n ) { ArrayList < Integer > list = new ArrayList < > ( ) ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( isUgly ( arr [ i ] ) ) { list . add ( arr [ i ] ) ; arr [ i ] = - 1 ; } } Collections . sort ( list ) ; int j = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == - 1 ) System . out . print ( list . get ( j ++ ) + " " ) ; else System . out . print ( arr [ i ] + " " ) ; } }
double getMaxMedian ( int [ ] arr , int n , int k ) { int size = n + k ; Arrays . sort ( arr ) ; if ( size % 2 == 0 ) { double median = ( double ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } double median1 = arr [ size / 2 ] ; return median1 ; }
void sortArr ( int arr [ ] , int n , int k ) { int prev = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { if ( prev != - 1 ) Arrays . sort ( arr , prev + 1 , i ) ; prev = i ; } } printArr ( arr , n ) ; }
void findSquare ( int n ) { int points [ ] [ ] = { { 1 , 2 } , { - 3 , 4 } , { 1 , 78 } , { - 3 , - 7 } } ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int x , y ; x = points [ i ] [ 0 ] ; y = points [ i ] [ 1 ] ; a [ i ] = Math . max ( mod ( x ) , mod ( y ) ) ; } Arrays . sort ( a ) ; int index = ( int ) ( Math . floor ( n / 2 ) - 1 ) ; System . out . println ( "Minimum M required is: " + a [ index ] ) ; }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void removeMin ( int arr [ ] , int n ) { int i , minVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) minVal = Math . min ( minVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] - minVal ; }
void removeFromMax ( int arr [ ] , int n ) { int i , maxVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) maxVal = Math . max ( maxVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = maxVal - arr [ i ] ; }
void modifyArray ( int arr [ ] , int n , int k ) { if ( k % 2 == 0 ) removeMin ( arr , n ) ; else removeFromMax ( arr , n ) ; printArray ( arr , n ) ; }
int findKth ( int arr [ ] , int n , int k ) { HashSet < Integer > missing = new HashSet < > ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { missing . add ( arr [ i ] ) ; } int maxm = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int minm = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; for ( int i = minm + 1 ; i < maxm ; i ++ ) { if ( ! missing . contains ( i ) ) { count ++ ; } if ( count == k ) { return i ; } } return - 1 ; }
void minOperation ( String S , int N , int K ) { if ( N % K != 0 ) { System . out . println ( "Not Possible" ) ; } else { int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < N ; i ++ ) { count [ ( S . charAt ( i ) - 97 ) ] ++ ; } int E = N / K ; Vector < Integer > greaterE = new Vector < > ( ) ; Vector < Integer > lessE = new Vector < > ( ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] < E ) lessE . add ( E - count [ i ] ) ; else greaterE . add ( count [ i ] - E ) ; } Collections . sort ( greaterE ) ; Collections . sort ( lessE ) ; int mi = Integer . MAX_VALUE ; for ( int i = 0 ; i <= K ; i ++ ) { int set1 = i ; int set2 = K - i ; if ( greaterE . size ( ) >= set1 && lessE . size ( ) >= set2 ) { int step1 = 0 ; int step2 = 0 ; for ( int j = 0 ; j < set1 ; j ++ ) step1 += greaterE . get ( j ) ; for ( int j = 0 ; j < set2 ; j ++ ) step2 += lessE . get ( j ) ; mi = Math . min ( mi , Math . max ( step1 , step2 ) ) ; } } System . out . println ( mi ) ; } }
void printPermutations ( int n , int a [ ] , int k ) { pair arr [ ] = new pair [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = new pair ( ) ; arr [ i ] . first = a [ i ] ; arr [ i ] . second = i ; } Arrays . sort ( arr , new sort ( ) ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] . first == arr [ i - 1 ] . first ) count ++ ; if ( count < k ) { System . out . print ( "-1" ) ; return ; } for ( int i = 0 ; i < k - 1 ; i ++ ) { printIndices ( n , arr ) ; for ( int j = next_pos ; j < n ; j ++ ) { if ( arr [ j ] . first == arr [ j - 1 ] . first ) { pair t = arr [ j ] ; arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = t ; next_pos = j + 1 ; break ; } } } printIndices ( n , arr ) ; }
int findAnswer ( int n , int [ ] arr ) { Arrays . sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) { sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ; } return sum ; }
void merge ( int l , int r , int [ ] output ) { int l_in = l * n , r_in = ( ( l + r ) / 2 + 1 ) * n ; int l_c = ( ( l + r ) / 2 - l + 1 ) * n ; int r_c = ( r - ( l + r ) / 2 ) * n ; int l_arr [ ] = new int [ l_c ] , r_arr [ ] = new int [ r_c ] ; for ( int i = 0 ; i < l_c ; i ++ ) l_arr [ i ] = output [ l_in + i ] ; for ( int i = 0 ; i < r_c ; i ++ ) r_arr [ i ] = output [ r_in + i ] ; int l_curr = 0 , r_curr = 0 ; int in = l_in ; while ( l_curr + r_curr < l_c + r_c ) { if ( r_curr == r_c || ( l_curr != l_c && l_arr [ l_curr ] < r_arr [ r_curr ] ) ) { output [ in ] = l_arr [ l_curr ] ; l_curr ++ ; in ++ ; } else { output [ in ] = r_arr [ r_curr ] ; r_curr ++ ; in ++ ; } } }
void divide ( int l , int r , int [ ] output , int arr [ ] [ ] ) { if ( l == r ) { for ( int i = 0 ; i < n ; i ++ ) output [ l * n + i ] = arr [ l ] [ i ] ; return ; } divide ( l , ( l + r ) / 2 , output , arr ) ; divide ( ( l + r ) / 2 + 1 , r , output , arr ) ; merge ( l , r , output ) ; }
int minSum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int x = arr [ ( int ) n / 2 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . abs ( arr [ i ] - x ) ; return sum ; }
int minOperations ( int n , int m , int k , int matrix [ ] [ ] ) { int [ ] arr = new int [ n * m ] ; int mod = matrix [ 0 ] [ 0 ] % k ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { arr [ i * m + j ] = matrix [ i ] [ j ] ; if ( matrix [ i ] [ j ] % k != mod ) { return - 1 ; } } } Arrays . sort ( arr ) ; int median = arr [ ( n * m ) / 2 ] ; int minOperations = 0 ; for ( int i = 0 ; i < n * m ; ++ i ) minOperations += Math . abs ( arr [ i ] - median ) / k ; if ( ( n * m ) % 2 == 0 ) { int median2 = arr [ ( ( n * m ) / 2 ) - 1 ] ; int minOperations2 = 0 ; for ( int i = 0 ; i < n * m ; ++ i ) minOperations2 += Math . abs ( arr [ i ] - median2 ) / k ; minOperations = Math . min ( minOperations , minOperations2 ) ; } return minOperations ; }
int minOperations ( int n , int m , int k , int matrix [ ] [ ] ) { Vector < Integer > arr = new Vector < > ( ) ; int mod ; if ( matrix [ 0 ] [ 0 ] < 0 ) { mod = k - ( Math . abs ( matrix [ 0 ] [ 0 ] ) % k ) ; } else { mod = matrix [ 0 ] [ 0 ] % k ; } for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { arr . add ( matrix [ i ] [ j ] ) ; int val = matrix [ i ] [ j ] ; if ( val < 0 ) { int res = k - ( Math . abs ( val ) % k ) ; if ( res != mod ) { return - 1 ; } } else { int foo = matrix [ i ] [ j ] ; if ( foo % k != mod ) { return - 1 ; } } } } Collections . sort ( arr ) ; int median = arr . get ( ( n * m ) / 2 ) ; int minOperations = 0 ; for ( int i = 0 ; i < n * m ; ++ i ) minOperations += Math . abs ( arr . get ( i ) - median ) / k ; if ( ( n * m ) % 2 == 0 ) { int median2 = arr . get ( ( ( n * m ) / 2 ) - 1 ) ; int minOperations2 = 0 ; for ( int i = 0 ; i < n * m ; ++ i ) minOperations2 += Math . abs ( arr . get ( i ) - median2 ) / k ; minOperations = Math . min ( minOperations , minOperations2 ) ; } return minOperations ; }
int countDistinct ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 1 ; i < n ; i ++ ) { int j = 0 ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) break ; if ( i == j ) res ++ ; } return res ; }
int countDistinct ( int arr [ ] , int n ) { HashSet < Integer > hs = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hs . add ( arr [ i ] ) ; } return hs . size ( ) ; }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void printMaxMean ( int arr [ ] , int n ) { int newArr [ ] = new int [ n ] ; Arrays . sort ( arr , 0 , 2 * n ) ; for ( int i = 0 ; i < n ; i ++ ) newArr [ i ] = arr [ i + n ] ; printArray ( newArr , n ) ; }
int Minimum_Cells ( Vector < Point > v ) { int [ ] col = new int [ 3 ] ; int i , j ; for ( i = 0 ; i < 3 ; i ++ ) { int column_number = v . get ( i ) . y ; col [ i ] = column_number ; } Arrays . sort ( col ) ; int MidRow = v . get ( 1 ) . x ; Set < Point > s = new HashSet < Point > ( ) ; int Maxcol = col [ 2 ] , MinCol = col [ 0 ] ; for ( i = MinCol ; i <= Maxcol ; i ++ ) { s . add ( new Point ( MidRow , i ) ) ; } for ( i = 0 ; i < 3 ; i ++ ) { if ( v . get ( i ) . x == MidRow ) continue ; for ( j = Math . min ( v . get ( i ) . x , MidRow ) ; j <= Math . max ( v . get ( i ) . x , MidRow ) ; j ++ ) { s . add ( new Point ( j , v . get ( i ) . x ) ) ; } } return s . size ( ) ; }
int countPairs ( int [ ] a , int n ) { TreeMap < Integer , Integer > map = new TreeMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { map . put ( a [ i ] , 1 ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . get ( a [ i ] ) < 1 ) continue ; int cur = 1 ; while ( cur <= a [ i ] ) cur <<= 1 ; if ( map . containsKey ( cur - a [ i ] ) ) { if ( cur - a [ i ] == a [ i ] && map . get ( a [ i ] ) == 1 ) continue ; count ++ ; map . put ( cur - a [ i ] , map . get ( cur - a [ i ] ) - 1 ) ; map . put ( a [ i ] , map . get ( a [ i ] ) - 1 ) ; } } return count ; }
int countSequences ( int arr [ ] , int n ) { int count = 1 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; }
double average ( int arr [ ] , int n , int k ) { double total = 0 ; if ( 2 * k >= n ) return 0 ; Arrays . sort ( arr ) ; int start = k , end = n - k - 1 ; for ( int i = start ; i <= end ; i ++ ) total += arr [ i ] ; return ( total / ( n - 2 * k ) ) ; }
void partSort ( int [ ] arr , int N , int a , int b ) { int l = Math . min ( a , b ) ; int r = Math . max ( a , b ) ; int [ ] temp = new int [ r - l + 1 ] ; int j = 0 ; for ( int i = l ; i <= r ; i ++ ) { temp [ j ] = arr [ i ] ; j ++ ; } Arrays . sort ( temp ) ; j = 0 ; for ( int i = l ; i <= r ; i ++ ) { arr [ i ] = temp [ j ] ; j ++ ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
void partSort ( int [ ] arr , int N , int a , int b ) { int l = Math . min ( a , b ) ; int r = Math . max ( a , b ) ; Arrays . sort ( arr , l , r + 1 ) ; for ( int i = 0 ; i < N ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
int minMovesToSort ( int arr [ ] , int n ) { int moves = 0 ; int i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; } return moves ; }
void transpose ( int mat [ ] [ ] , int n ) { int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ j ] [ i ] ; mat [ j ] [ i ] = temp ; } } }
void sortMatRowAndColWise ( int mat [ ] [ ] , int n ) { sortByRow ( mat , n , true ) ; transpose ( mat , n ) ; sortByRow ( mat , n , false ) ; transpose ( mat , n ) ; }
long minimumMoves ( int a [ ] , int n ) { long operations = 0 ; Arrays . sort ( a ) ; for ( int i = 0 ; i < n ; i ++ ) operations += ( long ) Math . abs ( a [ i ] - ( i + 1 ) ) ; return operations ; }
int min_sum ( int n , int k , int a [ ] ) { Arrays . sort ( a ) ; if ( a [ 0 ] < 0 ) return - 1 ; if ( k == 0 ) { if ( a [ 0 ] == a [ n - 1 ] ) return ( n * a [ 0 ] ) ; else return - 1 ; } else { int f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int p = a [ i ] - a [ 0 ] ; if ( p % k == 0 ) continue ; else { f = 1 ; break ; } } if ( f > 0 ) return - 1 ; else { if ( k == 1 ) return n ; else return ( n * ( a [ 0 ] % k ) ) ; } } }
void printCase ( int n ) { if ( n <= 2 ) { System . out . print ( - 1 ) ; return ; } for ( int i = n ; i >= 1 ; i -- ) System . out . print ( i + " " ) ; }
void merge ( int arr [ ] , int start , int mid , int end ) { int start2 = mid + 1 ; if ( arr [ mid ] <= arr [ start2 ] ) { return ; } while ( start <= mid && start2 <= end ) { if ( arr [ start ] <= arr [ start2 ] ) { start ++ ; } else { int value = arr [ start2 ] ; int index = start2 ; while ( index != start ) { arr [ index ] = arr [ index - 1 ] ; index -- ; } arr [ start ] = value ; start ++ ; mid ++ ; start2 ++ ; } } }
void mergeSort ( int arr [ ] , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; mergeSort ( arr , l , m ) ; mergeSort ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } }
int minCost ( int A [ ] , int n ) { int cost = 0 ; Arrays . sort ( A ) ; int K = A [ n / 2 ] ; for ( int i = 0 ; i < n ; ++ i ) cost += Math . abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { int tempCost = 0 ; K = A [ ( n / 2 ) - 1 ] ; for ( int i = 0 ; i < n ; ++ i ) tempCost += Math . abs ( A [ i ] - K ) ; cost = Math . min ( cost , tempCost ) ; } return cost ; }
boolean check ( int n , int k , int [ ] a , int [ ] b ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; boolean fl = false ; int ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) { if ( fl == true ) { return false ; } fl = true ; ind = i ; } } if ( ind == - 1 | Math . abs ( a [ ind ] - b [ ind ] ) <= k ) { return true ; } return false ; }
int items ( int n , int a [ ] ) { Arrays . sort ( a ) ; int z = a [ n - 1 ] ; int x = 1 ; int s = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { s += a [ i ] ; if ( s <= z ) x += 1 ; else break ; } return x ; }
void sortWithSetbits ( int arr [ ] , int n , int k ) { Vector < Integer > v1 = new Vector < > ( ) , v2 = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( Integer . bitCount ( arr [ i ] ) == k ) { v1 . add ( i ) ; v2 . add ( arr [ i ] ) ; } } Collections . sort ( v2 ) ; for ( int i = 0 ; i < v1 . size ( ) ; i ++ ) { arr [ v1 . get ( i ) ] = v2 . get ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
int findOptimalSolution ( int [ ] a , int N ) { Arrays . sort ( a ) ; int points = 0 ; for ( int i = 0 ; i < N ; i ++ ) { points += a [ i ] * i ; } return points ; }
void printArray ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int l = 0 , r = n - 1 , flag = 0 , i ; int k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) System . out . print ( arr [ i ] + " " ) ; flag = 1 ; l = i ; } { for ( i = r ; i > r - k && i >= l ; i -- ) System . out . print ( arr [ i ] + " " ) ; flag = 0 ; r = i ; } k ++ ; } }
void sortMultiples ( int arr [ ] , int n , int x ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % x == 0 ) { v . add ( arr [ i ] ) ; } } Collections . sort ( v ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % x == 0 ) { arr [ i ] = v . get ( j ++ ) ; } } }
void kThLexString ( String st , int k , int n ) { Set < String > z = new HashSet < String > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String pp = "" ; for ( int j = i ; j < i + k ; j ++ ) { if ( j >= n ) break ; pp += st . charAt ( j ) ; z . add ( pp ) ; } } Vector < String > fin = new Vector < String > ( ) ; fin . addAll ( z ) ; Collections . sort ( fin ) ; System . out . print ( fin . get ( k - 1 ) ) ; }
void SieveOfEratosthenes ( int n ) { Arrays . fill ( prime , true ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i < n ; i += p ) { prime [ i ] = false ; } } } }
void sortPrimes ( int arr [ ] , int n ) { SieveOfEratosthenes ( 100005 ) ; Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { v . add ( arr [ i ] ) ; } } Comparator comparator = Collections . reverseOrder ( ) ; Collections . sort ( v , comparator ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { arr [ i ] = v . get ( j ++ ) ; } } }
int number_of_tower ( int house [ ] , int range , int n ) { Arrays . sort ( house ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
int countPairs ( Node first , Node second , int value ) { int count = 0 ; while ( first != null && second != null && first != second && second . next != first ) { if ( ( first . data * second . data ) == value ) { count ++ ; first = first . next ; second = second . prev ; } else if ( ( first . data * second . data ) > value ) second = second . prev ; else first = first . next ; } return count ; }
int countTriplets ( Node head , int x ) { if ( head == null ) return 0 ; Node current , first , last ; int count = 0 ; last = head ; while ( last . next != null ) last = last . next ; for ( current = head ; current != null ; current = current . next ) { first = current . next ; count += countPairs ( first , last , x / current . data ) ; } return count ; }
boolean isAlphabaticOrder ( String s ) { int n = s . length ( ) ; char c [ ] = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = s . charAt ( i ) ; } Arrays . sort ( c ) ; for ( int i = 0 ; i < n ; i ++ ) if ( c [ i ] != s . charAt ( i ) ) return false ; return true ; }
boolean isAlphabaticOrder ( String s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) < s . charAt ( i - 1 ) ) { return false ; } } return true ; }
void SieveOfEratosthenes ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } }
void sortedArray ( int arr [ ] , int n ) { SieveOfEratosthenes ( 100005 ) ; Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( prime [ arr [ i ] ] == false ) v . add ( arr [ i ] ) ; } Collections . sort ( v ) ; int j = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( prime [ arr [ i ] ] == true ) System . out . print ( arr [ i ] + " " ) ; else { System . out . print ( v . get ( j ) + " " ) ; j ++ ; } } }
int findProduct ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int prod = 1 * arr [ 0 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) { prod = prod * arr [ i + 1 ] ; } } return prod ; }
int rotateRec ( int n , int L [ ] , int B [ ] ) { int m = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . max ( L [ i ] , B [ i ] ) <= m ) m = Math . max ( L [ i ] , B [ i ] ) ; else if ( Math . min ( L [ i ] , B [ i ] ) <= m ) m = Math . min ( L [ i ] , B [ i ] ) ; else { return 0 ; } } return 1 ; }
int minimumIncrease ( int a , int b , int c ) { int arr [ ] = { a , b , c } ; Arrays . sort ( arr ) ; if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; }
void sortList ( Node head ) { int startVal = 1 ; while ( head != null ) { head . data = startVal ; startVal ++ ; head = head . next ; } }
void push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; start = head_ref ; }
void push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; start = head_ref ; }
void minDistance ( int n , int k , int point [ ] [ ] ) { for ( int i = 0 ; i < k ; i ++ ) Arrays . sort ( point [ i ] ) ; for ( int i = 0 ; i < k ; i ++ ) System . out . print ( point [ i ] [ ( int ) Math . ceil ( ( double ) ( n / 2 ) - 1 ) ] + " " ) ; }
int solve ( int N , int M , int cp [ ] , int sp [ ] ) { Integer [ ] profit = new Integer [ N ] ; for ( int i = 0 ; i < N ; i ++ ) profit [ i ] = sp [ i ] - cp [ i ] ; Arrays . sort ( profit , Collections . reverseOrder ( ) ) ; int sum = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( profit [ i ] > 0 ) sum += profit [ i ] ; else break ; } return sum ; }
void printOrder ( int [ ] arr , int n , int k ) { int len1 = k , len2 = n - k ; int [ ] arr1 = new int [ k ] ; int [ ] arr2 = new int [ n - k ] ; for ( int i = 0 ; i < k ; i ++ ) arr1 [ i ] = arr [ i ] ; for ( int i = k ; i < n ; i ++ ) arr2 [ i - k ] = arr [ i ] ; Arrays . sort ( arr1 , 0 , k ) ; Arrays . sort ( arr2 , k , n - k ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) arr [ i ] = arr1 [ i ] ; else { arr [ i ] = arr2 [ len2 - 1 ] ; len2 -- ; } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
void findMaxNum ( int arr [ ] , int n ) { int [ ] hash = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( int i = 9 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) System . out . print ( i ) ; } }
void sortK ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; }
int minimumSets ( int arr [ ] , int n , int key ) { int i , j ; Arrays . sort ( arr ) ; for ( i = 0 , j = n - 1 ; i <= j ; ++ i ) if ( arr [ i ] + arr [ j ] <= key ) j -- ; return i ; }
int distribution ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return Math . min ( count , n / 2 ) ; }
int distribution ( int arr [ ] , int n ) { Set < Integer > resources = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) resources . add ( arr [ i ] ) ; return Math . min ( resources . size ( ) , n / 2 ) ; }
void merge ( int [ ] arr , int beg , int mid , int end , int maxele ) { int i = beg ; int j = mid + 1 ; int k = beg ; while ( i <= mid && j <= end ) { if ( arr [ i ] % maxele <= arr [ j ] % maxele ) { arr [ k ] = arr [ k ] + ( arr [ i ] % maxele ) * maxele ; k ++ ; i ++ ; } else { arr [ k ] = arr [ k ] + ( arr [ j ] % maxele ) * maxele ; k ++ ; j ++ ; } } while ( i <= mid ) { arr [ k ] = arr [ k ] + ( arr [ i ] % maxele ) * maxele ; k ++ ; i ++ ; } while ( j <= end ) { arr [ k ] = arr [ k ] + ( arr [ j ] % maxele ) * maxele ; k ++ ; j ++ ; } for ( i = beg ; i <= end ; i ++ ) { arr [ i ] = arr [ i ] / maxele ; } }
void mergeSortRec ( int [ ] arr , int beg , int end , int maxele ) { if ( beg < end ) { int mid = ( beg + end ) / 2 ; mergeSortRec ( arr , beg , mid , maxele ) ; mergeSortRec ( arr , mid + 1 , end , maxele ) ; merge ( arr , beg , mid , end , maxele ) ; } }
void mergeSort ( int [ ] arr , int n ) { int maxele = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) + 1 ; mergeSortRec ( arr , 0 , n - 1 , maxele ) ; }
void printSorted ( String s , int l ) { Stack < Character > stack = new Stack < Character > ( ) ; Stack < Character > tempstack = new Stack < Character > ( ) ; stack . push ( s . charAt ( 0 ) ) ; for ( int i = 1 ; i < l ; i ++ ) { int a = s . charAt ( i ) ; int b = ( int ) ( ( char ) stack . peek ( ) ) ; if ( ( a - b ) >= 1 || ( a == b ) ) { stack . push ( s . charAt ( i ) ) ; } else if ( ( b - a ) >= 1 ) { while ( ( b - a ) >= 1 ) { tempstack . push ( stack . peek ( ) ) ; stack . pop ( ) ; if ( stack . size ( ) > 0 ) { b = ( int ) ( ( char ) stack . peek ( ) ) ; } else { break ; } } stack . push ( s . charAt ( i ) ) ; while ( tempstack . size ( ) > 0 ) { stack . push ( tempstack . peek ( ) ) ; tempstack . pop ( ) ; } } } String answer = "" ; while ( stack . size ( ) > 0 ) { answer = stack . peek ( ) + answer ; stack . pop ( ) ; } System . out . println ( answer ) ; }
int countTriplets ( int [ ] arr , int n , int a , int b ) { int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= a && arr [ i ] + arr [ j ] + arr [ k ] <= b ) { ans ++ ; } } } } return ans ; }
int countTriplets ( int arr [ ] , int n , int a , int b ) { int res ; res = countTripletsLessThan ( arr , n , b ) - countTripletsLessThan ( arr , n , a - 1 ) ; return res ; }
boolean checkFittingArrays ( int [ ] A , int [ ] B , int N ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; }
int maximum_toys ( int cost [ ] , int N , int K ) { int count = 0 , sum = 0 ; Arrays . sort ( cost ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( sum + cost [ i ] <= K ) { sum = sum + cost [ i ] ; count ++ ; } } return count ; }
int findMinimumSwaps ( int [ ] arr , int n , int k ) { int pos = 0 , num_min , num_max , need_minimum , need_maximum , swaps ; num_min = num_max = need_minimum = 0 ; need_maximum = swaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < k ) { num_min ++ ; } else if ( arr [ i ] > k ) { num_max ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == k ) { pos = i ; break ; } } int left , right , mid ; left = 0 ; right = n - 1 ; while ( left <= right ) { mid = ( left + right ) / 2 ; if ( arr [ mid ] == k ) { break ; } else if ( arr [ mid ] > k ) { if ( pos > mid ) { need_minimum ++ ; } else { num_min -- ; } left = mid + 1 ; } else { if ( pos < mid ) { need_maximum ++ ; } else { num_max -- ; } right = mid - 1 ; } } if ( need_minimum > need_maximum ) { swaps = swaps + need_maximum ; num_min = num_min - need_maximum ; need_minimum = need_minimum - need_maximum ; need_maximum = 0 ; } else { swaps = swaps + need_minimum ; num_max = num_max - need_minimum ; need_maximum = need_maximum - need_minimum ; need_minimum = 0 ; } if ( need_maximum > num_max need_minimum > num_min ) { return - 1 ; } else { return ( swaps + need_maximum + need_minimum ) ; } }
void findOptimalPairs ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; for ( int i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) System . out . print ( "(" + arr [ i ] + ", " + arr [ j ] + ")" + " " ) ; }
void sortStack ( Stack < Integer > input ) { while ( input . size ( ) != 0 ) { int tmp = input . peek ( ) ; input . pop ( ) ; while ( tmpStack . size ( ) != 0 && tmpStack . peek ( ) > tmp ) { input . push ( tmpStack . peek ( ) ) ; tmpStack . pop ( ) ; } tmpStack . push ( tmp ) ; } }
void sortedMerge ( Stack < Integer > s1 , Stack < Integer > s2 ) { while ( s1 . size ( ) != 0 ) { res . push ( s1 . peek ( ) ) ; s1 . pop ( ) ; } while ( s2 . size ( ) != 0 ) { res . push ( s2 . peek ( ) ) ; s2 . pop ( ) ; } sortStack ( res ) ; }
int MaxTotalRectangleArea ( Integer [ ] a , int n ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; int sum = 0 ; boolean flag = false ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == a [ i + 1 ] a [ i ] - a [ i + 1 ] == 1 ) && ! flag ) { flag = true ; len = a [ i + 1 ] ; i ++ ; } else if ( ( a [ i ] == a [ i + 1 ] a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i ++ ; } } return sum ; }
boolean isSortedDesc ( Node head ) { if ( head == null ) return true ; for ( Node t = head ; t . next != null ; t = t . next ) if ( t . data <= t . next . data ) return false ; return true ; }
void evenOddInsertionSort ( int arr [ ] , int n ) { for ( int i = 2 ; i < n ; i ++ ) { int j = i - 2 ; int temp = arr [ i ] ; if ( ( ( i + 1 ) & 1 ) == 1 ) { while ( j >= 0 && temp >= arr [ j ] ) { arr [ j + 2 ] = arr [ j ] ; j -= 2 ; } arr [ j + 2 ] = temp ; } else { while ( j >= 0 && temp <= arr [ j ] ) { arr [ j + 2 ] = arr [ j ] ; j -= 2 ; } arr [ j + 2 ] = temp ; } } }
void sort ( ArrayList < Integer > a , int n ) { for ( int i = n ; i >= 0 ; i -- ) for ( int j = n ; j > n - i ; j -- ) if ( a . get ( j ) > a . get ( j - 1 ) ) { int tempswap = a . get ( j ) ; a . remove ( j ) ; a . add ( j , a . get ( j - 1 ) ) ; a . remove ( j - 1 ) ; a . add ( j - 1 , tempswap ) ; } print ( a , n ) ; }
void insertionSort ( Vector < Integer > V ) { int N = V . size ( ) ; int i , j , key ; for ( i = 1 ; i < N ; i ++ ) { j = i ; while ( j > 0 && V . get ( j ) < V . get ( j - 1 ) ) { int temp = V . get ( j ) ; V . set ( j , V . get ( j - 1 ) ) ; V . set ( j - 1 , temp ) ; j -= 1 ; } } }
void insertionSortRecursive ( Vector < Integer > V , int N ) { if ( N <= 1 ) return ; insertionSortRecursive ( V , N - 1 ) ; int j = N - 1 ; while ( j > 0 && V . get ( j ) < V . get ( j - 1 ) ) { int temp = V . get ( j ) ; V . set ( j , V . get ( j - 1 ) ) ; V . set ( j - 1 , temp ) ; j -= 1 ; } }
void sort012 ( int arr [ ] , int n ) { int count0 = 0 , count1 = 0 ; int count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) count0 ++ ; if ( arr [ i ] == 1 ) count1 ++ ; if ( arr [ i ] == 2 ) count2 ++ ; } for ( int i = 0 ; i < count0 ; i ++ ) arr [ i ] = 0 ; for ( int i = count0 ; i < ( count0 + count1 ) ; i ++ ) arr [ i ] = 1 ; for ( int i = ( count0 + count1 ) ; i < n ; i ++ ) arr [ i ] = 2 ; printArray ( arr , n ) ; }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; System . out . println ( ) ; }
int minElements ( int arr [ ] , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; Arrays . sort ( arr ) ; int res = 0 , curr_sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }
int distancesum ( int x [ ] , int y [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; return sum ; }
int distancesum ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int res = 0 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res += ( arr [ i ] * i - sum ) ; sum += arr [ i ] ; } return res ; }
int totaldistancesum ( int x [ ] , int y [ ] , int n ) { return distancesum ( x , n ) + distancesum ( y , n ) ; }
int minimumBox ( int [ ] arr , int n ) { Queue < Integer > q = new LinkedList < > ( ) ; Arrays . sort ( arr ) ; q . add ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q . element ( ) ; if ( arr [ i ] >= 2 * now ) q . remove ( ) ; q . add ( arr [ i ] ) ; } return q . size ( ) ; }
void sortRec ( int arr [ ] , int index , int k , int n ) { if ( k == 0 ) { for ( int i = 1 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; System . out . println ( 999 ) ; return ; } else if ( k > 0 && index == 0 ) { index = n - 2 ; for ( int i = 1 ; i <= index ; i ++ ) { arr [ i - 1 ] = arr [ i ] ; } arr [ index ] = 999 ; } if ( index - 1 >= 0 && index + 1 < n && arr [ index - 1 ] > arr [ index + 1 ] ) { swap ( arr , index , index + 1 ) ; swap ( arr , index - 1 , index + 1 ) ; } else swap ( arr , index , index - 1 ) ; sortRec ( arr , index - 1 , k - 1 , n ) ; }
void sortString ( String str ) { int charCount [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { charCount [ str . charAt ( i ) - 'a' ] ++ ; } for ( int i = MAX_CHAR - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < charCount [ i ] ; j ++ ) { System . out . print ( ( char ) ( 'a' + i ) ) ; } } }
void printMedian ( int arr [ ] , int n , int K ) { Arrays . sort ( arr ) ; System . out . print ( arr [ ( n + K ) / 2 ] ) ; }
void stableSelectionSort ( int [ ] a , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { int min = i ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ min ] > a [ j ] ) min = j ; int key = a [ min ] ; while ( min > i ) { a [ min ] = a [ min - 1 ] ; min -- ; } a [ i ] = key ; } }
void sortBinaryArray ( int a [ ] , int n ) { int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 ) { j ++ ; int temp = a [ j ] ; a [ j ] = a [ i ] ; a [ i ] = temp ; } } }
boolean almostSort ( int A [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { int temp = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = temp ; i ++ ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) if ( A [ i ] > A [ i + 1 ] ) return false ; return true ; }
void minMaxSelectionSort ( int [ ] arr , int n ) { for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { int min = arr [ i ] , max = arr [ i ] ; int min_i = i , max_i = i ; for ( int k = i ; k <= j ; k ++ ) { if ( arr [ k ] > max ) { max = arr [ k ] ; max_i = k ; } else if ( arr [ k ] < min ) { min = arr [ k ] ; min_i = k ; } } swap ( arr , i , min_i ) ; if ( arr [ min_i ] == max ) swap ( arr , j , min_i ) ; else swap ( arr , j , max_i ) ; } }
int nextGap ( int gap ) { if ( gap <= 1 ) return 0 ; return ( gap / 2 ) + ( gap % 2 ) ; }
void arrange ( int arr [ ] , int n , int x ) { for ( int i = 1 ; i < n ; i ++ ) { int diff = Math . abs ( arr [ i ] - x ) ; int j = i - 1 ; if ( Math . abs ( arr [ j ] - x ) > diff ) { int temp = arr [ i ] ; while ( j >= 0 && Math . abs ( arr [ j ] - x ) > diff ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = temp ; } } }
void printOrder ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } for ( int j = n - 1 ; j >= n / 2 ; j -- ) { System . out . print ( arr [ j ] + " " ) ; } }
int findDuplicate ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int i = 0 ; while ( i < n ) { int j , count = 1 ; for ( j = i + 1 ; j < n && arr [ j ] == arr [ i ] ; j ++ ) count ++ ; if ( count == k ) return arr [ i ] ; i = j ; } return - 1 ; }
int findDuplicate ( int arr [ ] , int n , int k ) { int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 1 && arr [ i ] > MAX ) { System . out . println ( "Out of range" ) ; return - 1 ; } freq [ arr [ i ] ] += 1 ; } for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == k ) return i ; } return - 1 ; }
int maxProductSubarrayOfSizeK ( int A [ ] , int n , int k ) { Arrays . sort ( A ) ; int product = 1 ; if ( A [ n - 1 ] == 0 && k % 2 != 0 ) return 0 ; if ( A [ n - 1 ] <= 0 && k % 2 != 0 ) { for ( int i = n - 1 ; i >= n - k ; i -- ) product *= A [ i ] ; return product ; } int i = 0 ; int j = n - 1 ; if ( k % 2 != 0 ) { product *= A [ j ] ; j -- ; k -- ; } k >>= 1 ; for ( int itr = 0 ; itr < k ; itr ++ ) { int left_product = A [ i ] * A [ i + 1 ] ; int right_product = A [ j ] * A [ j - 1 ] ; if ( left_product > right_product ) { product *= left_product ; i += 2 ; } else { product *= right_product ; j -= 2 ; } } return product ; }
int findMaximum ( int arr [ ] , int n , int k ) { int res = 0 , index = 0 ; for ( int i = n - 1 ; i >= index ; i -- ) { res += arr [ i ] ; index += k ; } return res ; }
void insertionSort ( int [ ] arr , int left , int right ) { for ( int i = left + 1 ; i <= right ; i ++ ) { int temp = arr [ i ] ; int j = i - 1 ; while ( j >= left && arr [ j ] > temp ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = temp ; } }
void merge ( int [ ] arr , int l , int m , int r ) { int len1 = m - l + 1 , len2 = r - m ; int [ ] left = new int [ len1 ] ; int [ ] right = new int [ len2 ] ; for ( int x = 0 ; x < len1 ; x ++ ) { left [ x ] = arr [ l + x ] ; } for ( int x = 0 ; x < len2 ; x ++ ) { right [ x ] = arr [ m + 1 + x ] ; } int i = 0 ; int j = 0 ; int k = l ; while ( i < len1 && j < len2 ) { if ( left [ i ] <= right [ j ] ) { arr [ k ] = left [ i ] ; i ++ ; } else { arr [ k ] = right [ j ] ; j ++ ; } k ++ ; } while ( i < len1 ) { arr [ k ] = left [ i ] ; k ++ ; i ++ ; } while ( j < len2 ) { arr [ k ] = right [ j ] ; k ++ ; j ++ ; } }
boolean checkForSorting ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { int temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } else return false ; } } return true ; }
void sort ( String [ ] s , int n ) { for ( int i = 1 ; i < n ; i ++ ) { String temp = s [ i ] ; int j = i - 1 ; while ( j >= 0 && temp . length ( ) < s [ j ] . length ( ) ) { s [ j + 1 ] = s [ j ] ; j -- ; } s [ j + 1 ] = temp ; } }
void printArraystring ( String str [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( str [ i ] + " " ) ; }
int maxLevel ( int [ ] boxes , int n ) { Arrays . sort ( boxes ) ; int prev_width = boxes [ 0 ] ; int prev_count = 1 ; int curr_count = 0 ; int curr_width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; }
void stoogesort ( int arr [ ] , int l , int h ) { if ( l >= h ) return ; if ( arr [ l ] > arr [ h ] ) { int t = arr [ l ] ; arr [ l ] = arr [ h ] ; arr [ h ] = t ; } if ( h - l + 1 > 2 ) { int t = ( h - l + 1 ) / 3 ; stoogesort ( arr , l , h - t ) ; stoogesort ( arr , l + t , h ) ; stoogesort ( arr , l , h - t ) ; } }
int merge ( int arr [ ] , int temp [ ] , int left , int mid , int right ) { int inv_count = 0 ; int i = left ; int j = mid ; int k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) { temp [ k ++ ] = arr [ i ++ ] ; } else { temp [ k ++ ] = arr [ j ++ ] ; inv_count = inv_count + ( mid - i ) ; } } while ( i <= mid - 1 ) { temp [ k ++ ] = arr [ i ++ ] ; } while ( j <= right ) { temp [ k ++ ] = arr [ j ++ ] ; } for ( i = left ; i <= right ; i ++ ) { arr [ i ] = temp [ i ] ; } return inv_count ; }
int mergeSort ( int arr [ ] , int array_size ) { int [ ] temp = new int [ array_size ] ; return _mergeSort ( arr , temp , 0 , array_size - 1 ) ; }
int minDifferenceAmongMaxMin ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int res = 2147483647 ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { int curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = Math . min ( res , curSeqDiff ) ; } return res ; }
void insertionSortRecursive ( int arr [ ] , int n ) { if ( n <= 1 ) return ; insertionSortRecursive ( arr , n - 1 ) ; int last = arr [ n - 1 ] ; int j = n - 2 ; while ( j >= 0 && arr [ j ] > last ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = last ; }
void twoWaySort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] *= - 1 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; }
int partition ( int [ ] arr , int low , int high ) { int pivot = arr [ low ] ; int i = low - 1 , j = high + 1 ; while ( true ) { do { i ++ ; } while ( arr [ i ] < pivot ) ; do { j -- ; } while ( arr [ j ] > pivot ) ; if ( i >= j ) return j ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } }
void quickSort ( int [ ] arr , int low , int high ) { if ( low < high ) { int pi = partition ( arr , low , high ) ; quickSort ( arr , low , pi ) ; quickSort ( arr , pi + 1 , high ) ; } }
int ksmallest ( int arr [ ] , int n , int k ) { int b [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( int j = 1 ; j < MAX ; j ++ ) { if ( b [ j ] != 1 ) { k -- ; } if ( k != 1 ) { return j ; } } return Integer . MAX_VALUE ; }
int ksmallest ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; if ( k < arr [ 0 ] ) return k ; if ( k == arr [ 0 ] ) return arr [ 0 ] + 1 ; if ( k > arr [ n - 1 ] ) return k + n ; if ( arr [ 0 ] == 1 ) k -- ; else k -= ( arr [ 0 ] - 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { int c = arr [ i ] - arr [ i - 1 ] - 1 ; if ( k <= c ) return arr [ i - 1 ] + k ; else k -= c ; } return arr [ n - 1 ] + k ; }
void multiply ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { C [ i ] [ j ] = 0 ; for ( int k = 0 ; k < V ; k ++ ) { C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] ; } } } }
int getTrace ( int graph [ ] [ ] ) { int trace = 0 ; for ( int i = 0 ; i < V ; i ++ ) { trace += graph [ i ] [ i ] ; } return trace ; }
int triangleInGraph ( int graph [ ] [ ] ) { int [ ] [ ] aux2 = new int [ V ] [ V ] ; int [ ] [ ] aux3 = new int [ V ] [ V ] ; for ( int i = 0 ; i < V ; ++ i ) { for ( int j = 0 ; j < V ; ++ j ) { aux2 [ i ] [ j ] = aux3 [ i ] [ j ] = 0 ; } } multiply ( graph , graph , aux2 ) ; multiply ( graph , aux2 , aux3 ) ; int trace = getTrace ( aux3 ) ; return trace / 6 ; }
int minSum ( int arr [ ] , int n ) { Vector < Integer > evenArr = new Vector < > ( ) ; Vector < Integer > oddArr = new Vector < > ( ) ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) { oddArr . add ( arr [ i ] ) ; } else { evenArr . add ( arr [ i ] ) ; } } Comparator comparator = Collections . reverseOrder ( ) ; Collections . sort ( evenArr , comparator ) ; int i = 0 , sum = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) { arr [ i ++ ] = evenArr . get ( j ) ; arr [ i ++ ] = oddArr . get ( j ) ; sum += evenArr . get ( j ) * oddArr . get ( j ) ; } return sum ; }
void mergeTwoHalf ( int [ ] A , int n ) { Arrays . sort ( A ) ; }
int minDiff ( int arr [ ] , int n , int k ) { int result = Integer . MAX_VALUE ; Arrays . sort ( arr ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
boolean isPossible ( Integer a [ ] , int b [ ] , int n , int k ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; Arrays . sort ( b ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }
void bitonicGenerator ( int arr [ ] , int n ) { Vector < Integer > evenArr = new Vector < Integer > ( ) ; Vector < Integer > oddArr = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 1 ) { evenArr . add ( arr [ i ] ) ; } else { oddArr . add ( arr [ i ] ) ; } } Collections . sort ( evenArr ) ; Collections . sort ( oddArr , Collections . reverseOrder ( ) ) ; int i = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) { arr [ i ++ ] = evenArr . get ( j ) ; } for ( int j = 0 ; j < oddArr . size ( ) ; j ++ ) { arr [ i ++ ] = oddArr . get ( j ) ; } }
int findMinDiff ( int arr [ ] , int n , int m ) { if ( m == 0 n == 0 ) return 0 ; Arrays . sort ( arr ) ; if ( n < m ) return - 1 ; int min_diff = Integer . MAX_VALUE ; for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) min_diff = diff ; } return min_diff ; }
long minValue ( int A [ ] , int B [ ] , int n ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; long result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }
int merge ( int arr [ ] , int temp [ ] , int left , int mid , int right ) { int inv_count = 0 ; int i = left ; int j = mid ; int k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else { temp [ k ++ ] = arr [ j ++ ] ; inv_count = inv_count + ( mid - i ) ; } } while ( i <= mid - 1 ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= right ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = left ; i <= right ; i ++ ) arr [ i ] = temp [ i ] ; return inv_count ; }
int _mergeSort ( int arr [ ] , int temp [ ] , int left , int right ) { int mid , inv_count = 0 ; if ( right > left ) { mid = ( right + left ) / 2 ; inv_count = _mergeSort ( arr , temp , left , mid ) ; inv_count += _mergeSort ( arr , temp , mid + 1 , right ) ; inv_count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_count ; }
boolean isEven ( int n ) { return ( n % 2 == 0 ) ; }
boolean isEven ( int n ) { if ( ( n & 1 ) == 0 ) return true ; else return false ; }
int findSubsequenceCount ( String S , String T ) { int m = T . length ( ) ; int n = S . length ( ) ; if ( m > n ) return 0 ; int mat [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( T . charAt ( i - 1 ) != S . charAt ( j - 1 ) ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; }
int countBits ( int a ) { int count = 0 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) count += 1 ; a = a >> 1 ; } return count ; }
void insertionSort ( int arr [ ] , int aux [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { int key1 = aux [ i ] ; int key2 = arr [ i ] ; int j = i - 1 ; while ( j >= 0 && aux [ j ] < key1 ) { aux [ j + 1 ] = aux [ j ] ; arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } aux [ j + 1 ] = key1 ; arr [ j + 1 ] = key2 ; } }
void sortBySetBitCount ( int arr [ ] , int n ) { int aux [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) aux [ i ] = countBits ( arr [ i ] ) ; insertionSort ( arr , aux , n ) ; }
int countBits ( int a ) { int count = 0 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) count += 1 ; a = a >> 1 ; } return count ; }
void sortBySetBitCount ( int arr [ ] , int n ) { Vector < Integer > [ ] count = new Vector [ 32 ] ; for ( int i = 0 ; i < count . length ; i ++ ) count [ i ] = new Vector < Integer > ( ) ; int setbitcount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { setbitcount = countBits ( arr [ i ] ) ; count [ setbitcount ] . add ( arr [ i ] ) ; } int j = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { Vector < Integer > v1 = count [ i ] ; for ( int p = 0 ; p < v1 . size ( ) ; p ++ ) arr [ j ++ ] = v1 . get ( p ) ; } }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void findSurpasser ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; System . out . print ( count + " " ) ; } }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; System . out . println ( ) ; }
int solve ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }
int maxProduct ( int [ ] arr , int n ) { if ( n < 3 ) return - 1 ; int max_product = Integer . MIN_VALUE ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }
int maxProduct ( int [ ] arr , int n ) { if ( n < 3 ) return - 1 ; int [ ] leftMin = new int [ n ] ; int [ ] rightMin = new int [ n ] ; int [ ] leftMax = new int [ n ] ; int [ ] rightMax = new int [ n ] ; Arrays . fill ( leftMin , - 1 ) ; Arrays . fill ( leftMax , - 1 ) ; Arrays . fill ( rightMax , - 1 ) ; Arrays . fill ( rightMin , - 1 ) ; int max_product = Integer . MIN_VALUE ; int max_sum = arr [ 0 ] ; int min_sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { leftMax [ i ] = max_sum ; if ( arr [ i ] > max_sum ) max_sum = arr [ i ] ; leftMin [ i ] = min_sum ; if ( arr [ i ] < min_sum ) min_sum = arr [ i ] ; } max_sum = arr [ n - 1 ] ; min_sum = arr [ n - 1 ] ; for ( int j = n - 2 ; j >= 0 ; j -- ) { rightMax [ j ] = max_sum ; if ( arr [ j ] > max_sum ) max_sum = arr [ j ] ; rightMin [ j ] = min_sum ; if ( arr [ j ] < min_sum ) min_sum = arr [ j ] ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { int max1 = Math . max ( arr [ i ] * leftMax [ i ] * rightMax [ i ] , arr [ i ] * leftMin [ i ] * rightMin [ i ] ) ; int max2 = Math . max ( arr [ i ] * leftMax [ i ] * rightMin [ i ] , arr [ i ] * leftMin [ i ] * rightMax [ i ] ) ; max_product = Math . max ( max_product , Math . max ( max1 , max2 ) ) ; } return max_product ; }
int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) { return - 1 ; } Arrays . sort ( arr ) ; return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; }
int maxProduct ( int [ ] arr , int n ) { if ( n < 3 ) return - 1 ; int maxA = Integer . MIN_VALUE , maxB = Integer . MIN_VALUE , maxC = Integer . MIN_VALUE ; int minA = Integer . MAX_VALUE , minB = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; if ( arr [ i ] < minA ) { minB = minA ; minA = arr [ i ] ; } else if ( arr [ i ] < minB ) minB = arr [ i ] ; } return Math . max ( minA * minB * maxA , maxA * maxB * maxC ) ; }
int distinctCount ( int arr [ ] , int n ) { Set < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . add ( Math . abs ( arr [ i ] ) ) ; return s . size ( ) ; }
int distinctCount ( int arr [ ] , int n ) { int count = n ; int i = 0 , j = n - 1 , sum = 0 ; while ( i < j ) { while ( i != j && arr [ i ] == arr [ i + 1 ] ) { count -- ; i ++ ; } while ( i != j && arr [ j ] == arr [ j - 1 ] ) { count -- ; j -- ; } if ( i == j ) break ; sum = arr [ i ] + arr [ j ] ; if ( sum == 0 ) { count -- ; i ++ ; j -- ; } else if ( sum < 0 ) i ++ ; else j -- ; } return count ; }
void findMaxGuests ( int arrl [ ] , int exit [ ] , int n ) { Arrays . sort ( arrl ) ; Arrays . sort ( exit ) ; int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } System . out . println ( "Maximum Number of Guests = " + max_guests + " at time " + time ) ; }
int binarySearch ( int a [ ] , int item , int low , int high ) { while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( item == a [ mid ] ) return mid + 1 ; else if ( item > a [ mid ] ) low = mid + 1 ; else high = mid - 1 ; } return low ; }
void insertionSort ( int a [ ] , int n ) { int i , loc , j , k , selected ; for ( i = 1 ; i < n ; ++ i ) { j = i - 1 ; selected = a [ i ] ; loc = binarySearch ( a , selected , 0 , j ) ; while ( j >= loc ) { a [ j + 1 ] = a [ j ] ; j -- ; } a [ j + 1 ] = selected ; } }
int findMax ( int arr [ ] , int n ) { int mi , i ; for ( mi = 0 , i = 0 ; i < n ; ++ i ) if ( arr [ i ] > arr [ mi ] ) mi = i ; return mi ; }
void printArray ( int arr [ ] , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) System . out . print ( arr [ i ] + " " ) ; System . out . println ( "" ) ; }
int minMoves ( char a [ ] [ ] , char b [ ] [ ] , int K ) { int n = a . length ; int m = a [ 0 ] . length ; int cntOperations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( a [ i ] [ j ] != b [ i ] [ j ] ) { cntOperations ++ ; if ( i + K - 1 >= n j + K - 1 >= m ) { return - 1 ; } for ( int p = 0 ; p <= K - 1 ; p ++ ) { for ( int q = 0 ; q <= K - 1 ; q ++ ) { if ( a [ i + p ] [ j + q ] == '0' ) { a [ i + p ] [ j + q ] = '1' ; } else { a [ i + p ] [ j + q ] = '0' ; } } } } } } return cntOperations ; }
int maxConsecutiveCnt ( int [ ] arr ) { int X = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] <= ( X + 1 ) ) { X = X + arr [ i ] ; } else { break ; } } return X + 1 ; }
void findPermutation ( int N , int L , int R , int S ) { int x = R - L + 1 ; if ( ! possible ( x , S , N ) ) { System . out . print ( - 1 ) ; return ; } else { ArrayList < Integer > v = new ArrayList < > ( ) ; for ( int i = N ; i >= 1 ; -- i ) { if ( ( S - i ) >= 0 && possible ( x - 1 , S - i , i - 1 ) ) { S = S - i ; x -- ; v . add ( i ) ; } if ( S == 0 ) { break ; } } if ( S != 0 ) { System . out . print ( - 1 ) ; return ; } ArrayList < Integer > v1 = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= N ; ++ i ) { boolean it = v . contains ( i ) ; if ( ! it ) { v1 . add ( i ) ; } } int j = 0 , f = 0 ; for ( int i = 1 ; i < L ; ++ i ) { System . out . print ( v1 . get ( j ) + " " ) ; j ++ ; } for ( int i = L ; i <= R ; ++ i ) { System . out . print ( v . get ( f ) + " " ) ; f ++ ; } for ( int i = R + 1 ; i <= N ; ++ i ) { System . out . print ( v1 . get ( j ) + " " ) ; j ++ ; } } return ; }
int maxShiftArrayValue ( int arr [ ] , int cap [ ] , int N ) { int sumVals = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sumVals += arr [ i ] ; } int maxCapacity = 0 ; for ( int i = 0 ; i < N ; i ++ ) { maxCapacity = Math . max ( cap [ i ] , maxCapacity ) ; } return Math . min ( maxCapacity , sumVals ) ; }
int minimumSizeArray ( int S , int P ) { if ( S == P ) { return 1 ; } for ( int i = 2 ; i <= S ; i ++ ) { double d = i ; if ( ( S / d ) >= Math . pow ( P , 1.0 / d ) ) { return i ; } } return - 1 ; }
int countPoints ( int D ) { int count = 0 ; for ( int x = 1 ; x * x < D * D ; x ++ ) { int y = ( int ) Math . sqrt ( ( D * D - x * x ) ) ; if ( x * x + y * y == D * D ) { count += 4 ; } } count += 4 ; return count ; }
int minimizeCost ( int A , int B , int C ) { int ans = A + B + C ; for ( int i = 1 ; i <= 2 * C ; i ++ ) { int j = 0 ; while ( i * j <= 2 * C ) { ans = Math . min ( ans , Math . abs ( A - i ) + Math . abs ( B - j ) + Math . abs ( i * j - C ) ) ; j ++ ; } } return ans ; }
double averageSetBits ( int N , int K , int arr [ ] ) { double p = N ; double q = 0 ; for ( int i = 0 ; i < K ; i ++ ) { double _p = p , _q = q ; p = _p - _p * arr [ i ] / N + _q * arr [ i ] / N ; q = _q - _q * arr [ i ] / N + _p * arr [ i ] / N ; } return p ; }
long KthSolution ( long X , long K ) { long ans = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( X & ( 1 << i ) ) == 0 ) { if ( ( K & 1 ) > 0 ) { ans |= ( 1 << i ) ; } K >>= 1 ; if ( K == 0 ) { break ; } } } return ans ; }
int minimumcoins ( int arr [ ] , int N ) { int coins = 0 ; int j = 0 ; if ( arr [ 0 ] == 1 ) coins ++ ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == 2 ) continue ; j = i ; while ( j < N && arr [ j ] == 1 ) { j ++ ; } int x = ( j - i ) ; coins += x / 3 ; i = j - 1 ; } return coins ; }
int maximumUniqueSquares ( int N ) { int ans = 0 ; if ( N < 4 ) { return 0 ; } int len = ( int ) ( Math . sqrt ( N ) ) ; N -= len * len ; for ( int i = 1 ; i < len ; i ++ ) { ans += i * i ; } if ( N >= len ) { N -= len ; for ( int i = 1 ; i < len ; i ++ ) { ans += i ; } } for ( int i = 1 ; i < N ; i ++ ) { ans += i ; } return ans ; }
void rearrange ( int arr [ ] , int N ) { if ( ( N & 1 ) != 0 ) N -- ; int odd_idx = 1 , even_idx = 0 ; int i , max_elem = arr [ N - 1 ] + 1 ; for ( i = 0 ; i < N / 2 ; i ++ ) { arr [ i ] += ( arr [ odd_idx ] % max_elem ) * max_elem ; odd_idx += 2 ; } for ( ; i < N ; i ++ ) { arr [ i ] += ( arr [ even_idx ] % max_elem ) * max_elem ; even_idx += 2 ; } for ( i = 0 ; i < N ; i ++ ) { arr [ i ] = arr [ i ] / max_elem ; } }
void generateString ( int k1 , int k2 , char [ ] s ) { int C1s = 0 , C0s = 0 ; int flag = 0 ; Vector < Integer > pos = new Vector < Integer > ( ) ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == '0' ) { C0s ++ ; if ( ( i + 1 ) % k1 != 0 && ( i + 1 ) % k2 != 0 ) { pos . add ( i ) ; } } else { C1s ++ ; } if ( C0s >= C1s ) { if ( pos . size ( ) == 0 ) { System . out . print ( - 1 ) ; flag = 1 ; break ; } else { int k = pos . get ( pos . size ( ) - 1 ) ; s [ k ] = '1' ; C0s -- ; C1s ++ ; pos . remove ( pos . size ( ) - 1 ) ; } } } if ( flag == 0 ) { System . out . print ( s ) ; } }
void findRange ( int arr [ ] , int N , int K ) { int L = Integer . MIN_VALUE ; int R = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { int l = ( int ) Math . ceil ( 1.0 * arr [ i ] * K / ( i + 1 ) ) ; int r = ( int ) Math . ceil ( ( 1.0 + arr [ i ] ) * K / ( i + 1 ) ) - 1 ; L = Math . max ( L , l ) ; R = Math . min ( R , r ) ; } System . out . println ( L + " " + R ) ; }
void findAnagram ( String s ) { String check = s ; int i = 0 , j = s . length ( ) - 1 ; while ( i < s . length ( ) && j >= 0 ) { if ( s . charAt ( i ) != s . charAt ( j ) && check . charAt ( i ) != s . charAt ( j ) && check . charAt ( j ) != s . charAt ( i ) ) { char temp = s . charAt ( i ) ; s = s . substring ( 0 , i ) + s . charAt ( j ) + s . substring ( i + 1 ) ; s = s . substring ( 0 , j ) + temp + s . substring ( j + 1 ) ; i ++ ; j = s . length ( ) - 1 ; } else { j -- ; } } if ( s . length ( ) % 2 != 0 ) { int mid = s . length ( ) / 2 ; if ( check . charAt ( mid ) == s . charAt ( mid ) ) { for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( check . charAt ( i ) != s . charAt ( mid ) && s . charAt ( i ) != s . charAt ( mid ) ) { char temp = s . charAt ( i ) ; s = s . substring ( 0 , i ) + s . charAt ( mid ) + s . substring ( i + 1 ) ; s = s . substring ( 0 , mid ) + temp + s . substring ( mid + 1 ) ; break ; } } } } boolean ok = true ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( check . charAt ( i ) == s . charAt ( i ) ) { ok = false ; break ; } } if ( ok ) System . out . println ( s ) ; else System . out . println ( - 1 ) ; }
void maximizeProduct ( int N ) { int MSB = ( int ) ( Math . log ( N ) / Math . log ( 2 ) ) ; int X = 1 << MSB ; int Y = N - ( 1 << MSB ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ( N & ( 1 << i ) ) == 0 ) { X += 1 << i ; Y += 1 << i ; } } System . out . println ( X + " " + Y ) ; }
void constructPermutation ( String S , int N ) { int [ ] ans = new int [ N ] ; ans [ 0 ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) { if ( S . charAt ( i - 1 ) == '0' ) { ans [ i ] = i + 1 ; } else { ans [ i ] = ans [ i - 1 ] ; } for ( int j = 0 ; j < i ; ++ j ) { if ( ans [ j ] >= ans [ i ] ) { ans [ j ] ++ ; } } } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( ans [ i ] ) ; if ( i != N - 1 ) { System . out . print ( " " ) ; } } }
int findRemainingIndex ( int N ) { int ans = N ; while ( N > 1 ) { int discard = ( int ) ( Math . sqrt ( N ) ) ; if ( discard * discard == N ) { ans -- ; } N -= discard ; } return ans ; }
void findRemainingElement ( int arr [ ] , int N ) { int remainingIndex = findRemainingIndex ( N ) ; System . out . print ( arr [ remainingIndex - 1 ] ) ; }
boolean check ( int num ) { int sm = 0 ; int num2 = num * num ; while ( num > 0 ) { sm += num % 10 ; num /= 10 ; } int sm2 = 0 ; while ( num2 > 0 ) { sm2 += num2 % 10 ; num2 /= 10 ; } return ( ( sm * sm ) == sm2 ) ; }
void generate ( String s , int len , HashSet < Integer > uniq ) { if ( s . length ( ) == len ) { if ( check ( convert ( s ) ) ) { uniq . add ( convert ( s ) ) ; } return ; } for ( int i = 0 ; i <= 3 ; i ++ ) { generate ( s + ( char ) ( i + '0' ) , len , uniq ) ; } }
int totalNumbers ( int L , int R ) { int ans = 0 ; int max_len = ( int ) ( Math . log10 ( R ) + 1 ) ; HashSet < Integer > uniq = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= max_len ; i ++ ) { generate ( "" , i , uniq ) ; } for ( int x : uniq ) { if ( x >= L && x <= R ) { ans ++ ; } } return ans ; }
void findMaximumSumWithMflips ( int arr [ ] , int N , int M ) { PriorityQueue < Integer > minHeap = new PriorityQueue < Integer > ( ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { minHeap . add ( arr [ i ] ) ; sum += arr [ i ] ; } while ( M -- > 0 ) { sum -= minHeap . peek ( ) ; int temp = - 1 * minHeap . peek ( ) ; minHeap . remove ( ) ; sum += temp ; minHeap . add ( temp ) ; } System . out . println ( sum ) ; }
boolean check ( int x , int N ) { while ( true ) { N -= x ; if ( x < 10 ) break ; int temp2 = 0 ; while ( x > 0 ) { temp2 += ( x % 10 ) ; x = ( int ) x / 10 ; } x = temp2 ; } if ( ( x < 10 ) && ( N == 0 ) ) { return true ; } return false ; }
int minimumMoves ( int A [ ] , int B [ ] , int N ) { int ans = 0 ; int sum_A = 0 , sum_B = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum_A += A [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { sum_B += B [ i ] ; } if ( sum_A != sum_B ) { return - 1 ; } int i = 0 ; while ( i < N ) { if ( A [ i ] > B [ i ] ) { int temp = A [ i ] - B [ i ] ; int j = i - 1 ; while ( j >= 0 && temp > 0 ) { if ( B [ j ] > A [ j ] ) { int cnt = Math . min ( temp , ( B [ j ] - A [ j ] ) ) ; A [ j ] += cnt ; temp -= cnt ; ans += ( cnt * Math . abs ( j - i ) ) ; } j -- ; } if ( temp > 0 ) { j = i + 1 ; while ( j < N && temp > 0 ) { if ( B [ j ] > A [ j ] ) { int cnt = Math . min ( temp , ( B [ j ] - A [ j ] ) ) ; A [ j ] += cnt ; temp -= cnt ; ans += ( cnt * Math . abs ( j - i ) ) ; } j ++ ; } } } i ++ ; } return ans ; }
int possibleReachingSequence ( int X , int D , int T ) { if ( X < T ) { System . out . println ( "NO" ) ; return 0 ; } if ( T * D < X ) { System . out . println ( "NO" ) ; return 0 ; } if ( ( X - T ) % ( D - 1 ) == 0 ) { System . out . println ( "YES" ) ; } else { System . out . println ( "NO" ) ; } return 0 ; }
int maxSumAfterPartition ( int arr [ ] , int n ) { ArrayList < Integer > pos = new ArrayList < Integer > ( ) ; ArrayList < Integer > neg = new ArrayList < Integer > ( ) ; int zero = 0 ; int pos_sum = 0 ; int neg_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { pos . add ( arr [ i ] ) ; pos_sum += arr [ i ] ; } else if ( arr [ i ] < 0 ) { neg . add ( arr [ i ] ) ; neg_sum += arr [ i ] ; } else { zero ++ ; } } int ans = 0 ; Collections . sort ( pos ) ; Collections . sort ( neg ) ; if ( pos . size ( ) > 0 && neg . size ( ) > 0 ) { ans = ( pos_sum - neg_sum ) ; } else if ( pos . size ( ) > 0 ) { if ( zero > 0 ) { ans = ( pos_sum ) ; } else { ans = ( pos_sum - 2 * pos . get ( 0 ) ) ; } } else { if ( zero > 0 ) { ans = ( - 1 * neg_sum ) ; } else { ans = ( neg . get ( 0 ) - ( neg_sum - neg . get ( 0 ) ) ) ; } } return ans ; }
int arrayDivisionByTwo ( int arr [ ] , int n ) { int cnt = 0 ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { cnt = 0 ; while ( arr [ i ] % 2 == 0 ) { arr [ i ] = arr [ i ] / 2 ; cnt ++ ; } ans = Math . min ( ans , cnt ) ; } return ans ; }
int minPushes ( int N , int K , int [ ] arr ) { int [ ] dp = new int [ 100000 ] ; for ( int i = 0 ; i < dp . length ; i ++ ) dp [ i ] = - 1 ; dp [ N ] = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int xx = 0 ; xx < 100000 ; xx ++ ) { int x = xx ; if ( dp [ x ] == - 1 ) continue ; int next = ( x + arr [ i ] ) % 100000 ; while ( dp [ next ] == - 1 dp [ next ] > dp [ x ] + 1 ) { dp [ next ] = dp [ x ] + 1 ; x = next ; next = ( next + arr [ i ] ) % 100000 ; } } } return dp [ K ] ; }
int minimumOperations ( int A [ ] , int N ) { int cur_prefix_1 = 0 ; int parity = - 1 ; int minOperationsCase1 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { cur_prefix_1 += A [ i ] ; if ( cur_prefix_1 == 0 parity * cur_prefix_1 < 0 ) { minOperationsCase1 += Math . abs ( parity - cur_prefix_1 ) ; cur_prefix_1 = parity ; } parity *= - 1 ; } int cur_prefix_2 = 0 ; parity = 1 ; int minOperationsCase2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { cur_prefix_2 += A [ i ] ; if ( cur_prefix_2 == 0 parity * cur_prefix_2 < 0 ) { minOperationsCase2 += Math . abs ( parity - cur_prefix_2 ) ; cur_prefix_2 = parity ; } parity *= - 1 ; } return Math . min ( minOperationsCase1 , minOperationsCase2 ) ; }
void maximumSumArray ( int arr [ ] , int N ) { int [ ] arrA = new int [ ( N ) ] ; int [ ] ans = new int [ ( N ) ] ; int maxSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) arrA [ i ] = arr [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { int [ ] arrB = new int [ ( N ) ] ; int maximum = arrA [ i ] ; arrB [ i ] = maximum ; for ( int j = i - 1 ; j >= 0 ; j -- ) { arrB [ j ] = Math . min ( maximum , arrA [ j ] ) ; maximum = arrB [ j ] ; } maximum = arrA [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { arrB [ j ] = Math . min ( maximum , arrA [ j ] ) ; maximum = arrB [ j ] ; } int sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) sum += arrB [ j ] ; if ( sum > maxSum ) { maxSum = sum ; ans = arrB ; } } for ( int val : ans ) { System . out . print ( val + " " ) ; } }
int minProductUtil ( int R1 , int B1 , int R2 , int B2 , int M ) { int x = Math . min ( R1 - B1 , M ) ; M -= x ; R1 -= x ; if ( M > 0 ) { int y = Math . min ( R2 - B2 , M ) ; M -= y ; R2 -= y ; } return R1 * R2 ; }
int minProduct ( int R1 , int B1 , int R2 , int B2 , int M ) { int res1 = minProductUtil ( R1 , B1 , R2 , B2 , M ) ; int res2 = minProductUtil ( R2 , B2 , R1 , B1 , M ) ; return Math . min ( res1 , res2 ) ; }
int maxAmount ( int n , int k , int arr [ ] ) { int A [ ] = new int [ 1000001 ] ; for ( int i = 0 ; i < n ; i ++ ) { A [ arr [ i ] ] ++ ; } int j = 0 ; for ( int i = 0 ; i < 1000001 ; i ++ ) { while ( A [ i ] != 0 ) { arr [ j ++ ] = i ; A [ i ] -- ; } } int ans = 0 ; int mod = ( int ) ( 1e9 + 7 ) ; int i = n - 1 ; j = n - 2 ; while ( k > 0 && j >= 0 ) { if ( arr [ i ] > arr [ j ] ) { ans = ans + Math . min ( k , ( i - j ) ) * arr [ i ] ; k = k - ( i - j ) ; arr [ i ] -- ; } else { while ( j >= 0 && arr [ j ] == arr [ i ] ) j -- ; if ( j < 0 ) break ; ans = ans + Math . min ( k , ( i - j ) ) * arr [ i ] ; k = k - ( i - j ) ; arr [ i ] -- ; } } while ( k > 0 && arr [ i ] != 0 ) { ans = ans + Math . min ( n , k ) * arr [ i ] ; k -= n ; arr [ i ] -- ; } ans = ans % mod ; int x = ans ; return x ; }
int validPermutations ( String str ) { HashMap < Character , Integer > m = new HashMap < Character , Integer > ( ) ; int count = str . length ( ) , ans = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { m . put ( str . charAt ( i ) , m . getOrDefault ( str . charAt ( i ) , 0 ) + 1 ) ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { ans += count - m . get ( str . charAt ( i ) ) ; m . put ( str . charAt ( i ) , m . get ( str . charAt ( i ) ) - 1 ) ; count -- ; } return ans + 1 ; }
void maxAverage ( int A [ ] , int N , int X , int Y ) { Arrays . sort ( A ) ; int sum = 0 ; double res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; count ++ ; if ( count == X ) { if ( N - i - 1 < X ) { i ++ ; int cnt = 0 ; while ( i < N ) { cnt ++ ; sum += A [ i ] ; i ++ ; } X = X + cnt ; res += ( double ) sum / ( double ) ( X ) ; break ; } res += ( double ) sum / ( double ) ( X ) ; sum = 0 ; count = 0 ; } } System . out . println ( res ) ; }
int maxSum ( int [ ] [ ] arr ) { int m = ( int ) arr . length ; int n = ( int ) arr [ 0 ] . length - 1 ; int [ ] [ ] dp = new int [ m + 1 ] [ n + 2 ] ; memset ( arr , 0 , sizeof ( arr ) ) ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i < m ; ++ i ) dp [ i ] [ 1 ] = arr [ i ] [ 1 ] ; for ( int i = 1 ; i < n + 1 ; ++ i ) { for ( int j = 1 ; j < m ; ++ j ) { int mx = 0 ; for ( int k = 1 ; k < m ; ++ k ) { if ( k != j ) { if ( dp [ k ] [ i - 1 ] > mx ) { mx = dp [ k ] [ i - 1 ] ; } } } if ( mx != 0 && arr [ j ] [ i ] != 0 ) { dp [ j ] [ i ] = arr [ j ] [ i ] + mx ; } } } int ans = - 1 ; for ( int i = 1 ; i <= m ; ++ i ) { if ( ( dp [ i ] [ n ] ) != 0 ) ans = Math . max ( ans , dp [ i ] [ n ] ) ; } return ans ; }
int findMaximumPoints ( int N , int X [ ] , int H [ ] ) { int ans = 0 ; int prev = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; ++ i ) { if ( prev < ( X [ i ] - H [ i ] ) ) { ++ ans ; prev = X [ i ] ; } else if ( i == N - 1 || ( X [ i ] + H [ i ] ) < X [ i + 1 ] ) { ++ ans ; prev = X [ i ] + H [ i ] ; } else { prev = X [ i ] ; } } return ans ; }
void maxGcd ( int a , int b ) { System . out . println ( Math . abs ( a - b ) ) ; }
void sumOfCombinationOf4OR5 ( int [ ] arr , int N ) { int [ ] ans = new int [ N ] ; Arrays . fill ( ans , - 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 4 ) { continue ; } int sum = Integer . MAX_VALUE ; int cnt = 0 ; for ( int j = 0 ; j <= arr [ i ] ; j += 4 ) { if ( ( arr [ i ] - j ) % 5 == 0 ) { sum = Math . min ( sum , cnt + ( arr [ i ] - j ) / 5 ) ; } cnt ++ ; } if ( sum != Integer . MAX_VALUE ) ans [ i ] = sum ; } for ( int num : ans ) System . out . printf ( num + " " ) ; }
int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
void printBinaryString ( int arr [ ] [ ] , int N ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) { System . out . print ( 0 ) ; } else { System . out . print ( 1 ) ; } } }
int MinCost ( int days [ ] , int cost [ ] , int N ) { int size = days [ N - 1 ] + 1 ; int [ ] dp = new int [ size ] ; dp [ size - 1 ] = Math . min ( cost [ 0 ] , Math . min ( cost [ 1 ] , cost [ 2 ] ) ) ; int ptr = N - 2 ; for ( int i = size - 2 ; i > 0 ; i -- ) { if ( ptr >= 0 && days [ ptr ] == i ) { int val1 = dp [ i + 1 ] + cost [ 0 ] ; int val2 = cost [ 1 ] + ( ( i + 7 >= size ) ? 0 : dp [ i + 7 ] ) ; int val3 = cost [ 2 ] + ( ( i + 30 >= size ) ? 0 : dp [ i + 30 ] ) ; dp [ i ] = Math . min ( val1 , Math . min ( val2 , val3 ) ) ; ptr -- ; } else { dp [ i ] = dp [ i + 1 ] ; } } return dp [ 1 ] ; }
int minElements ( int arr [ ] , int N , int K ) { int count = 0 ; long requiredNum = 1 ; int i = 0 ; while ( requiredNum <= K ) { if ( i < N && requiredNum >= arr [ i ] ) { requiredNum += arr [ i ] ; i ++ ; } else { count ++ ; requiredNum += requiredNum ; } } return count ; }
int minimumSteps ( int a , int b ) { int cnt = 0 ; a = Math . abs ( a - b ) ; cnt = ( a / 5 ) + ( a % 5 ) / 2 + ( a % 5 ) % 2 ; return cnt ; }
int maximumCount ( int arr [ ] , int N ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd > 0 && even > 0 ) return N - 2 ; else return N - 1 ; }
void miniOperToMakeAllEleEqual ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } if ( sum % n != 0 ) { System . out . println ( - 1 ) ; return ; } int valueAfterDivision = sum / n ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . abs ( valueAfterDivision - arr [ i ] ) % k != 0 ) { System . out . println ( - 1 ) ; return ; } count += Math . abs ( valueAfterDivision - arr [ i ] ) / k ; } System . out . println ( ( int ) count / 2 ) ; }
int countOpenDoors ( int N ) { int doorsOpen = ( int ) Math . sqrt ( N ) ; return doorsOpen ; }
int minPossibleValue ( int N , int K , int X ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( X <= K ) { X = X * 2 ; } else { X = X + K ; } } return X ; }
void findMissingValue ( int arr [ ] , int N ) { int minE = Integer . MAX_VALUE , maxE = Integer . MIN_VALUE ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == - 1 && arr [ i + 1 ] != - 1 ) { minE = Math . min ( minE , arr [ i + 1 ] ) ; maxE = Math . max ( maxE , arr [ i + 1 ] ) ; } if ( arr [ i ] != - 1 && arr [ i + 1 ] == - 1 ) { minE = Math . min ( minE , arr [ i ] ) ; maxE = Math . max ( maxE , arr [ i ] ) ; } } if ( minE == Integer . MAX_VALUE && maxE == Integer . MIN_VALUE ) { System . out . println ( "0" ) ; } else { System . out . println ( ( minE + maxE ) / 2 ) ; } }
void findLastElement ( int N , int [ ] A ) { int l = A . length ; int j = 0 ; while ( N > l * ( int ) ( Math . pow ( 2 , j ) ) ) { N = N - l * ( int ) Math . pow ( 2 , j ) ; j += 1 ; } int k = 1 ; int r = ( int ) Math . pow ( 2 , j ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( N > r * i ) k += 1 ; } for ( int i = 0 ; i < l ; i ++ ) { if ( i + 1 == k ) { System . out . print ( A [ i ] ) ; return ; } } }
int findMaxD ( int arr [ ] , int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = Math . abs ( arr [ i ] - K ) ; } int D = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { D = gcd ( D , arr [ i ] ) ; } return D ; }
void minOperations ( ArrayList < Integer > a ) { int res = Integer . MAX_VALUE ; int N = a . size ( ) ; for ( int r = 0 ; r < 2 ; r ++ ) { int sum = 0 , ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a . get ( i ) ; if ( ( i + r ) % 2 == 1 ) { if ( sum <= 0 ) { ans += - sum + 1 ; sum = 1 ; } } else { if ( sum >= 0 ) { ans += sum + 1 ; sum = - 1 ; } } } res = Math . min ( res , ans ) ; } System . out . print ( res ) ; }
int maxOperations ( String S , int N ) { int X = 0 ; int Y = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . charAt ( i ) == '0' ) break ; Y ++ ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( S . charAt ( i ) == '1' ) break ; X ++ ; } if ( N == X + Y ) return 0 ; return N - ( X + Y ) - 1 ; }
int maximumSum ( String S , int N , int K ) { int sum = 0 ; Integer [ ] freq = new Integer [ 256 ] ; Arrays . fill ( freq , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { freq [ ( int ) S . charAt ( i ) ] += 1 ; } Arrays . sort ( freq , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( K > freq [ i ] ) { sum += freq [ i ] * freq [ i ] ; K -= freq [ i ] ; } else { sum += freq [ i ] * K ; break ; } } return sum ; }
void possibleNumbers ( Set < Integer > numbers , int N , int M , int A , int B ) { if ( M == 0 ) { numbers . add ( N ) ; return ; } possibleNumbers ( numbers , N + A , M - 1 , A , B ) ; possibleNumbers ( numbers , N + B , M - 1 , A , B ) ; }
void possibleNumbers ( int N , int M , int A , int B ) { if ( A > B ) { int temp = A ; A = B ; B = temp ; } int number = N + M * A ; System . out . print ( number + " " ) ; if ( A != B ) { for ( int i = 0 ; i < M ; i ++ ) { number = number - A + B ; System . out . print ( number + " " ) ; } } }
void maxSum ( int arr [ ] , int n ) { int sum = 0 ; int max_neg = Integer . MAX_VALUE ; int tempsum = 0 ; int small = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; small = Math . min ( small , arr [ i ] ) ; if ( arr [ i ] > 0 ) { tempsum = 0 ; } else { tempsum += arr [ i ] ; } max_neg = Math . min ( max_neg , tempsum ) ; } if ( max_neg == 0 ) { max_neg = small ; } System . out . println ( sum - max_neg ) ; }
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
int findVertices ( int n ) { return fib ( n + 2 ) ; }
int MaxBuildingsCovered ( int arr [ ] , int N , int L ) { double curr_sum = 0 ; int start = 0 , curr_count = 0 , max_count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { curr_sum = curr_sum + ( ( double ) arr [ i ] * Pi ) ; if ( i != 0 ) curr_sum += 1 ; if ( curr_sum <= L ) { curr_count ++ ; } else if ( curr_sum > L ) { curr_sum = curr_sum - ( ( double ) arr [ start ] * Pi ) ; curr_sum -= 1 ; start ++ ; curr_count -- ; } max_count = Math . max ( curr_count , max_count ) ; } return max_count ; }
int num_candyTypes ( int [ ] candies ) { Dictionary < Integer , Integer > s = new Hashtable < Integer , Integer > ( ) ; for ( int i = 0 ; i < candies . length ; i ++ ) { s . put ( candies [ i ] , 1 ) ; } return s . size ( ) ; }
void distribute_candies ( int [ ] candies ) { int allowed = candies . length / 2 ; int types = num_candyTypes ( candies ) ; if ( types < allowed ) System . out . println ( types ) ; else System . out . println ( allowed ) ; }
int countUnsetBits ( int N ) { int c = 0 ; while ( N != 0 ) { if ( N % 2 == 0 ) { c += 1 ; } N = N >> 1 ; } return c ; }
void countBitwiseZero ( int N ) { int unsetBits = countUnsetBits ( N ) ; System . out . print ( 1 << unsetBits ) ; }
boolean isPossible ( String s ) { int n = s . length ( ) ; int count_0 = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' ) ++ count_0 ; else ++ count_1 ; if ( count_1 > count_0 ) return false ; } if ( count_0 != ( 2 * count_1 ) ) return false ; count_0 = 0 ; count_1 = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s . charAt ( i ) == '0' ) ++ count_0 ; else ++ count_1 ; if ( count_1 > count_0 ) return false ; } return true ; }
void minimumOperation ( String a , String b ) { int n = a . length ( ) ; int i = 0 ; int minoperation = 0 ; while ( i < n ) { if ( a . charAt ( i ) == b . charAt ( i ) ) { i = i + 1 ; continue ; } else if ( a . charAt ( i ) == b . charAt ( i + 1 ) && a . charAt ( i + 1 ) == b . charAt ( i ) && i < n - 1 ) { minoperation ++ ; i = i + 2 ; } else if ( a . charAt ( i ) != b . charAt ( i ) ) { minoperation ++ ; i = i + 1 ; } else { ++ i ; } } System . out . println ( minoperation ) ; }
void leastBricks ( ArrayList < ArrayList < Integer > > wall ) { HashMap < Integer , Integer > map = new HashMap < > ( ) ; int res = 0 ; for ( ArrayList < Integer > list : wall ) { int width = 0 ; for ( int i = 0 ; i < list . size ( ) - 1 ; i ++ ) { width += list . get ( i ) ; map . put ( width , map . getOrDefault ( width , 0 ) + 1 ) ; res = Math . max ( res , map . getOrDefault ( width , 0 ) ) ; } } System . out . println ( wall . size ( ) - res ) ; }
void minimumProdArray ( long a [ ] , long b [ ] , int l ) { long total = 0 ; for ( int i = 0 ; i < a . length ; ++ i ) { total += a [ i ] * b [ i ] ; } long min = Integer . MAX_VALUE ; int first = 0 ; int second = 0 ; for ( int i = 0 ; i < a . length ; ++ i ) { int left = i - 1 ; int right = i + 1 ; long total1 = total ; while ( left >= 0 && right < a . length ) { total1 -= a [ left ] * b [ left ] + a [ right ] * b [ right ] ; total1 += a [ left ] * b [ right ] + a [ right ] * b [ left ] ; if ( min >= total1 ) { min = total1 ; first = left ; second = right ; } -- left ; ++ right ; } } for ( int i = 0 ; i < a . length ; ++ i ) { int left = i ; int right = i + 1 ; long total1 = total ; while ( left >= 0 && right < a . length ) { total1 -= a [ left ] * b [ left ] + a [ right ] * b [ right ] ; total1 += a [ left ] * b [ right ] + a [ right ] * b [ left ] ; if ( min >= total1 ) { min = total1 ; first = left ; second = right ; } -- left ; ++ right ; } } if ( min < total ) { reverse ( first , second , a ) ; print ( a , b ) ; } else { print ( a , b ) ; } }
int numberOfWays ( int N , int X , int Y ) { int S1 = ( N - 1 ) * X + Y ; int S2 = ( N - 1 ) * Y + X ; return ( S2 - S1 + 1 ) ; }
int countPermutations ( int N ) { ArrayList < ArrayList < Integer > > adj = new ArrayList < ArrayList < Integer > > ( 105 ) ; for ( int i = 0 ; i < 105 ; i ++ ) adj . add ( new ArrayList < Integer > ( ) ) ; int indeg = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i == j ) continue ; int sum = i + j ; if ( Math . ceil ( Math . sqrt ( sum ) ) == Math . floor ( Math . sqrt ( sum ) ) ) { adj . get ( i ) . add ( j ) ; } } if ( adj . get ( i ) . size ( ) == 1 ) indeg ++ ; } if ( indeg == 0 ) return N ; else if ( indeg <= 2 ) return 2 ; else return 0 ; }
int reduceToOne ( long N ) { int cnt = 0 ; while ( N != 1 ) { if ( N == 2 || ( N % 2 == 1 ) ) { N = N - 1 ; cnt ++ ; } else if ( N % 2 == 0 ) { N = N / ( N / 2 ) ; cnt ++ ; } } return cnt ; }
void getDate ( int d , String m ) { int [ ] days = { 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; String [ ] month = { "January" , "February" , "March" , "April" , "May" , "June" , "July" , "August" , "September" , "October" , "November" , "December" } ; int cnt = 183 ; int cur_month = 0 ; for ( int i = 0 ; i < 12 ; i ++ ) if ( m == month [ i ] ) cur_month = i ; int cur_date = d ; while ( true ) { while ( cnt > 0 && cur_date <= days [ cur_month ] ) { cnt -= 1 ; cur_date += 1 ; } if ( cnt == 0 ) break ; cur_month = ( cur_month + 1 ) % 12 ; cur_date = 1 ; } System . out . println ( cur_date + " " + month [ cur_month ] ) ; }
void maxDiamonds ( int A [ ] , int N , int K ) { PriorityQueue < Integer > pq = new PriorityQueue < > ( ( a , b ) -> b - a ) ; for ( int i = 0 ; i < N ; i ++ ) { pq . add ( A [ i ] ) ; } int ans = 0 ; while ( ! pq . isEmpty ( ) && K -- > 0 ) { int top = pq . peek ( ) ; pq . remove ( ) ; ans += top ; top = top / 2 ; pq . add ( top ) ; } System . out . print ( ans ) ; }
void findMaximumProfit ( int [ ] arr , int M , int N ) { PriorityQueue < Integer > max_heap = new PriorityQueue < > ( ( a , b ) -> b - a ) ; int maxProfit = 0 ; for ( int i = 0 ; i < N ; i ++ ) max_heap . add ( arr [ i ] ) ; while ( M > 0 ) { M -- ; int X = max_heap . poll ( ) ; maxProfit += X ; max_heap . add ( X - 1 ) ; } System . out . println ( maxProfit ) ; }
long largestNumber ( int N ) { if ( N > 45 ) return - 1 ; int num = 0 , digit = 9 ; while ( N > 0 && digit > 0 ) { if ( digit <= N ) { num *= 10 ; num += digit ; N -= digit ; } digit -= 1 ; } return num * 10 ; }
int minimumSum ( int A [ ] , int N , String S ) { int mul = 0 ; for ( int i = 0 ; i < ( int ) S . length ( ) ; i ++ ) { if ( S . charAt ( i ) == '*' ) mul += 1 ; } int ans = 1000000 ; for ( int i = 0 ; i < ( 1 << ( N - 1 ) ) ; i ++ ) { int cnt = 0 ; Vector < Character > v = new Vector < Character > ( ) ; for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( ( ( 1 << j ) & ( i ) ) > 0 ) { cnt += 1 ; v . add ( '*' ) ; } else { v . add ( '+' ) ; } } if ( cnt == mul ) { LinkedList < Integer > d = new LinkedList < Integer > ( ) ; d . add ( A [ 0 ] ) ; for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( v . get ( j ) == '*' ) { int x = d . getLast ( ) ; d . removeLast ( ) ; x = x * A [ j + 1 ] ; d . add ( x ) ; } else { d . add ( A [ j + 1 ] ) ; } } int sum = 0 ; while ( d . size ( ) > 0 ) { int x = d . peek ( ) ; sum += x ; d . removeFirst ( ) ; } ans = Math . min ( ans , sum ) ; } } return ans ; }
int MinimumOperations ( int [ ] A , int N , int K ) { int Count = 0 ; int i = 0 ; while ( i < N - 1 ) { i = i + K - 1 ; Count ++ ; } return Count ; }
void findSequence ( int n , int k ) { int [ ] arr = new int [ n ] ; int sumPos = 0 , sumNeg = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { arr [ i ] = - ( i + 1 ) ; sumNeg += arr [ i ] ; } for ( int i = n - k ; i < n ; i ++ ) { arr [ i ] = i + 1 ; sumPos += arr [ i ] ; } if ( Math . abs ( sumNeg ) >= sumPos ) { System . out . print ( - 1 ) ; return ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void sumOfMedians ( int arr [ ] , int N , int K ) { int selectMedian = ( K + 1 ) / 2 ; int totalArrays = N / K ; int minSum = 0 ; int i = selectMedian - 1 ; while ( i < N && totalArrays != 0 ) { minSum = minSum + arr [ i ] ; i = i + selectMedian ; totalArrays -- ; } System . out . println ( minSum ) ; }
void generateString ( int K ) { String s = "" ; for ( int i = 97 ; i < 97 + K ; i ++ ) { s = s + ( char ) ( i ) ; for ( int j = i + 1 ; j < 97 + K ; j ++ ) { s += ( char ) ( i ) ; s += ( char ) ( j ) ; } } s += ( char ) ( 97 ) ; System . out . println ( s ) ; }
int countEqual ( int A [ ] , int B [ ] , int N ) { int first = 0 ; int second = N - 1 ; int count = 0 ; while ( first < N && second >= 0 ) { if ( A [ first ] < B [ second ] ) { first ++ ; } else if ( B [ second ] < A [ first ] ) { second -- ; } else { count ++ ; first ++ ; second -- ; } } return count ; }
int minimumValue ( int N , int K ) { return ( int ) Math . ceil ( ( double ) K / ( double ) N ) ; }
void minSizeArr ( int A [ ] , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += A [ i ] ; if ( K > sum ) { System . out . print ( - 1 ) ; return ; } if ( K == sum ) { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( A [ i ] + " " ) ; } return ; } int tar = sum - K ; HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; um . put ( 0 , - 1 ) ; int left = 0 , right = 0 ; int cur = 0 , maxi = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { cur += A [ i ] ; if ( um . containsKey ( cur - tar ) && i - um . get ( cur - tar ) > maxi ) { maxi = i - um . get ( cur - tar ) ; right = i ; left = um . get ( cur - tar ) ; } if ( ! um . containsKey ( cur ) ) um . put ( cur , i ) ; } if ( maxi == - 1 ) System . out . println ( - 1 ) ; else { for ( int i = 0 ; i <= left ; i ++ ) System . out . print ( A [ i ] + " " ) ; for ( int i = 0 ; i < right ; i ++ ) System . out . print ( A [ N - i - 1 ] + " " ) ; } }
void findPath ( int [ ] [ ] arr , int M , int N ) { for ( int row = 0 ; row < M ; row ++ ) { char dir = 'L' ; int i = row ; int j = 0 ; while ( j < N ) { if ( arr [ i ] [ j ] == 1 ) { if ( dir == 'L' ) { i -- ; dir = 'D' ; } else if ( dir == 'U' ) { j -- ; dir = 'R' ; } else if ( dir == 'R' ) { i ++ ; dir = 'U' ; } else if ( dir == 'D' ) { j ++ ; dir = 'L' ; } } else { if ( dir == 'L' ) { i ++ ; dir = 'U' ; } else if ( dir == 'U' ) { j ++ ; dir = 'L' ; } else if ( dir == 'R' ) { i -- ; dir = 'D' ; } else if ( dir == 'D' ) { j -- ; dir = 'R' ; } } if ( i < 0 i == M j < 0 j == N ) break ; } if ( j == N ) System . out . print ( i + " " ) ; else System . out . print ( - 1 + " " ) ; } }
int getSum ( int n ) { int ans = 0 ; char [ ] arr = ( String . valueOf ( n ) ) . toCharArray ( ) ; for ( char ch : arr ) { ans += Character . getNumericValue ( ch ) ; } return ans ; }
void minModulo ( int L , int R , int N ) { if ( R - L < N ) { int ans = Integer . MAX_VALUE ; for ( int i = L ; i <= R ; i ++ ) for ( int j = L ; j <= R ; j ++ ) if ( i != j ) ans = Math . min ( ans , ( i * j ) % N ) ; System . out . println ( ans ) ; } else { System . out . println ( 0 ) ; } }
int countNumbers ( int N ) { int count = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { count ++ ; if ( N / i != i ) { count ++ ; } } } return count ; }
void findEquation ( int A , int B , int C , int K ) { System . out . print ( A + " " + K * B + " " + K * K * C ) ; }
int calc ( int a , int b ) { return a * b + ( b - a ) ; }
int findMaximum ( int [ ] arr , int N ) { Arrays . sort ( arr ) ; int ans = ( int ) - 1e9 ; ans = Math . max ( ans , calc ( arr [ 0 ] , arr [ 1 ] ) ) ; ans = Math . max ( ans , calc ( arr [ N - 2 ] , arr [ N - 1 ] ) ) ; return ans ; }
int findMin ( int [ ] arr , int N , int k ) { int pairs = 0 ; for ( int i = 0 ; i < N ; i ++ ) { pairs += arr [ i ] / 2 ; } if ( k > pairs ) return - 1 ; else return 2 * k + N - 1 ; }
int minOperations ( int arr [ ] , int n ) { int oddcount = 0 , evencount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) oddcount ++ ; else evencount ++ ; } return Math . min ( oddcount , evencount ) ; }
int minimumFlips ( int A , int B , int C ) { int res = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { int x = 0 , y = 0 , z = 0 ; if ( ( A & ( 1 << i ) ) != 0 ) { x = 1 ; } if ( ( B & ( 1 << i ) ) != 0 ) { y = 1 ; } if ( ( C & ( 1 << i ) ) != 0 ) { z = 1 ; } if ( z == 0 ) { if ( x == 1 ) { res ++ ; } if ( y == 1 ) { res ++ ; } } if ( z == 1 ) { if ( x == 0 && y == 0 ) { res ++ ; } } } return res ; }
long gcd ( long a , long b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void countDistinctNumbers ( long A , long B , long C ) { long g = gcd ( A , B ) ; long count = C / g ; System . out . println ( count ) ; }
void printLastElement ( int arr [ ] , int N ) { boolean leftTurn = true ; int remainElements = N ; int step = 1 ; int head = 1 ; while ( remainElements > 1 ) { if ( leftTurn ) { head = head + step ; } else { if ( remainElements % 2 == 1 ) head = head + step ; } remainElements = remainElements / 2 ; step = step * 2 ; leftTurn = ! leftTurn ; } System . out . print ( arr [ head - 1 ] ) ; }
void findPrefixCount ( int arr [ ] , int size ) { for ( int i = 0 ; i < 32 ; i ++ ) { prefixCount [ i ] [ 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) ; for ( int j = 1 ; j < size ; j ++ ) { prefixCount [ i ] [ j ] = ( ( arr [ j ] >> i ) & 1 ) ; prefixCount [ i ] [ j ] += prefixCount [ i ] [ j - 1 ] ; } } }
void applyQuery ( int currentVal , int newVal , int size ) { for ( int i = 0 ; i < 32 ; i ++ ) { int bit1 = ( ( currentVal >> i ) & 1 ) ; int bit2 = ( ( newVal >> i ) & 1 ) ; if ( bit2 > 0 && bit1 == 0 ) prefixCount [ i ] [ size - 1 ] ++ ; else if ( bit1 > 0 && bit2 == 0 ) prefixCount [ i ] [ size - 1 ] -- ; } }
void shortestSubarray ( int A [ ] , int N ) { int i ; int left_index ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] + 1 != A [ i + 1 ] ) break ; } left_index = i ; int right_index ; for ( i = N - 1 ; i >= 1 ; i -- ) { if ( A [ i ] != A [ i - 1 ] + 1 ) break ; } right_index = i ; int updated_right ; int minLength = Math . min ( N - left_index - 1 , right_index ) ; if ( A [ right_index ] <= A [ left_index ] + 1 ) { updated_right = right_index + A [ left_index ] - A [ right_index ] + 1 ; if ( updated_right < N ) minLength = Math . min ( minLength , updated_right - left_index - 1 ) ; } System . out . println ( minLength ) ; }
String freqCheck ( String S , int N ) { int hash [ ] = new int [ 26 ] ; for ( int i = 0 ; i < N ; i ++ ) { hash [ S . charAt ( i ) - 'a' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( hash [ i ] > 2 ) { return "Yes" ; } } return "No" ; }
int countTriplets ( int N , int K ) { if ( K % 2 == 0 ) { int x = N / K ; int y = ( N + ( K / 2 ) ) / K ; return x * x * x + y * y * y ; } else { int x = N / K ; return x * x * x ; } }
int minLength ( String s ) { int i = 0 , j = s . length ( ) - 1 ; for ( ; i < j && s . charAt ( i ) == s . charAt ( j ) ; ) { char d = s . charAt ( i ) ; while ( i <= j && s . charAt ( i ) == d ) i ++ ; while ( i <= j && s . charAt ( j ) == d ) j -- ; } return j - i + 1 ; }
long power ( long x , int y ) { long res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
long CountBST ( int H ) { return power ( 2 , H ) ; }
void canBeEmptied ( int A , int B ) { if ( Math . max ( A , B ) > 2 * Math . min ( A , B ) ) { System . out . println ( "No" ) ; return ; } if ( ( A + B ) % 3 == 0 ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
int Check ( int A [ ] [ ] , int B [ ] [ ] , int M , int N , int X ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j <= N - X ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { int diff = B [ i ] [ j ] - A [ i ] [ j ] ; for ( int k = 0 ; k < X ; k ++ ) { A [ i ] [ j + k ] = A [ i ] [ j + k ] + diff ; } } } } for ( int i = 0 ; i <= M - X ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { int diff = B [ i ] [ j ] - A [ i ] [ j ] ; for ( int k = 0 ; k < X ; k ++ ) { A [ i + k ] [ j ] = A [ i + k ] [ j ] + diff ; } } } } for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { return 0 ; } } } return 1 ; }
void check ( int X , int Y ) { if ( X > 3 ) { System . out . print ( "Yes" ) ; } else if ( X == 1 && Y == 1 ) { System . out . print ( "Yes" ) ; } else if ( X == 2 && Y <= 3 ) { System . out . print ( "Yes" ) ; } else if ( X == 3 && Y <= 3 ) { System . out . print ( "Yes" ) ; } else { System . out . print ( "No" ) ; } }
boolean isPrime ( int n ) { if ( n <= 1 ) { return false ; } for ( int i = 2 ; i <= n / 2 ; ++ i ) { if ( n % i == 0 ) return false ; } return true ; }
void precompute ( ) { for ( int i = 1 ; i <= 100000 ; i ++ ) { if ( isPalindrome ( i ) ) { int sum = sumOfDigits ( i ) ; if ( isPrime ( sum ) ) arr [ i ] = 1 ; else arr [ i ] = 0 ; } else arr [ i ] = 0 ; } for ( int i = 1 ; i <= 100000 ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; } }
void minimumOperations ( int [ ] A , int K ) { int [ ] isflipped = new int [ A . length + 1 ] ; int ans = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( i > 0 ) { isflipped [ i ] += isflipped [ i - 1 ] ; isflipped [ i ] %= 2 ; } if ( A [ i ] == 0 && isflipped [ i ] == 0 ) { if ( ( A . length - i + 1 ) <= K ) { System . out . println ( - 1 ) ; return ; } ans ++ ; isflipped [ i ] ++ ; isflipped [ i + K ] -- ; } else if ( A [ i ] == 1 && isflipped [ i ] != 0 ) { if ( ( A . length - i + 1 ) <= K ) { System . out . println ( - 1 ) ; return ; } ans ++ ; isflipped [ i ] ++ ; isflipped [ i + K ] -- ; } } System . out . println ( ans ) ; }
void findScoreSum ( int n ) { int total = 0 ; int prev_monday = 0 , curr_day = 0 ; for ( int day = 1 ; day <= n ; day ++ ) { if ( day % 7 == 1 ) { prev_monday ++ ; curr_day = prev_monday ; } total += curr_day ++ ; } System . out . println ( total ) ; }
void findScoreSum ( int n ) { int F = n / 7 ; int D = n % 7 ; int fullWeekScore = ( 49 + 7 * F ) * F / 2 ; int lastNonFullWeekScore = ( 2 * F + D + 1 ) * D / 2 ; System . out . println ( fullWeekScore + lastNonFullWeekScore ) ; }
void evenXorSubarray ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int XOR = 0 ; for ( int j = i ; j < n ; j ++ ) { XOR = XOR ^ arr [ j ] ; if ( ( XOR & 1 ) == 0 ) ans ++ ; } } System . out . println ( ans ) ; }
void evenXorSubarray ( int arr [ ] , int n ) { int ans = 0 ; int freq [ ] = { 0 , 0 } ; int XOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { XOR = XOR ^ arr [ i ] ; if ( XOR % 2 == 0 ) { ans += freq [ 0 ] + 1 ; freq [ 0 ] ++ ; } else { ans += freq [ 1 ] ; freq [ 1 ] ++ ; } } System . out . println ( ans ) ; }
int getArea ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return Math . abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2 ) ; }
int isInside ( ArrayList < ArrayList < Integer > > triangle , ArrayList < Integer > point ) { ArrayList < Integer > A = triangle . get ( 0 ) ; ArrayList < Integer > B = triangle . get ( 1 ) ; ArrayList < Integer > C = triangle . get ( 2 ) ; int x = point . get ( 0 ) ; int y = point . get ( 1 ) ; int ABC = getArea ( A . get ( 0 ) , A . get ( 1 ) , B . get ( 0 ) , B . get ( 1 ) , C . get ( 0 ) , C . get ( 1 ) ) ; int BPC = getArea ( x , y , B . get ( 0 ) , B . get ( 1 ) , C . get ( 0 ) , C . get ( 1 ) ) ; int APC = getArea ( A . get ( 0 ) , A . get ( 1 ) , x , y , C . get ( 0 ) , C . get ( 1 ) ) ; int APB = getArea ( A . get ( 0 ) , A . get ( 1 ) , B . get ( 0 ) , B . get ( 1 ) , x , y ) ; return ABC == ( APC + APB + BPC ) ? 1 : 0 ; }
int GCD ( int a , int b ) { if ( b < 1 ) return a ; return GCD ( b , a % b ) ; }
int GCDArr ( ArrayList < Integer > a ) { int ans = a . get ( 0 ) ; for ( int i : a ) ans = GCD ( ans , i ) ; return ans ; }
boolean findSubseqUtil ( ArrayList < Integer > a , ArrayList < Integer > b , ArrayList < Integer > ans , int k , int i ) { if ( ans . size ( ) == a . size ( ) ) { if ( GCDArr ( ans ) == k ) { System . out . print ( "[" ) ; int m = ans . size ( ) ; for ( int j = 0 ; j < m - 1 ; j ++ ) System . out . print ( ans . get ( j ) + ", " ) ; System . out . print ( ans . get ( m - 1 ) + "]" ) ; return true ; } else return false ; } ans . add ( a . get ( i ) ) ; boolean temp = findSubseqUtil ( a , b , ans , k , i + 1 ) ; if ( temp ) return true ; ans . remove ( ans . size ( ) - 1 ) ; ans . add ( b . get ( i ) ) ; temp = findSubseqUtil ( a , b , ans , k , i + 1 ) ; if ( temp ) return true ; ans . remove ( ans . size ( ) - 1 ) ; return false ; }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
int GCDArr ( ArrayList < Integer > a ) { int ans = a . get ( 0 ) ; for ( int val : a ) { ans = GCD ( ans , val ) ; } return ans ; }
void findString ( char S [ ] , int N ) { int strLen = 4 * N ; for ( int i = 1 ; i <= N ; i ++ ) { S [ strLen - 1 ] = '1' ; strLen -= 2 ; } System . out . println ( S ) ; }
void minimumOperations ( int A [ ] , int n ) { int cnt = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( A [ i ] != ( i + 1 ) ) { if ( ( ( i - 1 ) >= 0 ) && A [ i - 1 ] == ( i + 1 ) ) { cnt ++ ; int t = A [ i ] ; A [ i ] = A [ i - 1 ] ; A [ i - 1 ] = t ; } else if ( ( ( i - 2 ) >= 0 ) && A [ i - 2 ] == ( i + 1 ) ) { cnt += 2 ; A [ i - 2 ] = A [ i - 1 ] ; A [ i - 1 ] = A [ i ] ; A [ i ] = i + 1 ; } else { System . out . println ( - 1 ) ; return ; } } } System . out . println ( cnt ) ; }
void countOccurrences ( int n , int x ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( x % i == 0 ) { if ( x / i <= n ) count ++ ; } } System . out . print ( count ) ; }
int countOccurrences ( int N , int X ) { int count = 0 ; for ( int i = 1 ; i < Math . sqrt ( X ) ; i ++ ) { if ( X % i == 0 ) { int a = i ; int b = X / i ; if ( a <= N && b <= N ) { if ( a == b ) count += 1 ; else count += 2 ; } } } return count ; }
void countOfPrimefactors ( int [ ] CountDistinct ) { boolean [ ] prime = new boolean [ MAX + 1 ] ; for ( int i = 0 ; i <= MAX ; i ++ ) { CountDistinct [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) { CountDistinct [ i ] = 1 ; for ( int j = i * 2 ; j <= MAX ; j += i ) { CountDistinct [ j ] ++ ; prime [ j ] = false ; } } } }
int CountEvenPair ( int A [ ] , int B [ ] , int N , int M ) { int [ ] countDistinct = new int [ ( MAX + 1 ) ] ; countOfPrimefactors ( countDistinct ) ; int evenCount = 0 ; int oddCount = 0 ; int evenPairs = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( countDistinct [ B [ i ] ] == 0 ) continue ; if ( ( countDistinct [ B [ i ] ] & 1 ) != 0 ) { oddCount ++ ; } else { evenCount ++ ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( countDistinct [ A [ i ] ] == 0 ) continue ; if ( ( countDistinct [ A [ i ] ] & 1 ) != 0 ) { evenPairs += ( evenCount ) ; } else { evenPairs += evenCount + oddCount ; } } return evenPairs ; }
void maxOccuringCharacter ( String s ) { int count0 = 0 , count1 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' ) { count1 ++ ; } else if ( s . charAt ( i ) == '0' ) { count0 ++ ; } } int prev = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' ) { prev = i ; break ; } } for ( int i = prev + 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != 'X' ) { if ( s . charAt ( i ) == '1' ) { count1 += i - prev - 1 ; prev = i ; } else { boolean flag = true ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) == '1' ) { flag = false ; prev = j ; break ; } } if ( ! flag ) { i = prev ; } else { i = s . length ( ) ; } } } } prev = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '0' ) { prev = i ; break ; } } for ( int i = prev + 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != 'X' ) { if ( s . charAt ( i ) == '0' ) { count0 += i - prev - 1 ; prev = i ; } else { boolean flag = true ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) == '0' ) { prev = j ; flag = false ; break ; } } if ( ! flag ) { i = prev ; } else { i = s . length ( ) ; } } } } if ( s . charAt ( 0 ) == 'X' ) { int count = 0 ; int i = 0 ; while ( s . charAt ( i ) == 'X' ) { count ++ ; i ++ ; } if ( s . charAt ( i ) == '1' ) { count1 += count ; } } if ( s . charAt ( s . length ( ) - 1 ) == 'X' ) { int count = 0 ; int i = s . length ( ) - 1 ; while ( s . charAt ( i ) == 'X' ) { count ++ ; i -- ; } if ( s . charAt ( i ) == '0' ) { count0 += count ; } } if ( count0 == count1 ) { System . out . println ( "X" ) ; } else if ( count0 > count1 ) { System . out . println ( 0 ) ; } else System . out . println ( 1 ) ; }
void minRequiredOperation ( int [ ] arr , int N , int K ) { int TotalSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) TotalSum += arr [ i ] ; int maxLen = longestSubarray ( arr , N , TotalSum - K ) ; if ( maxLen == - 1 ) { System . out . println ( - 1 ) ; } else System . out . println ( N - maxLen ) ; }
void minimumDeletions ( String s ) { int n = s . length ( ) ; int ans = n ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int t = s . charAt ( i ) - '0' ; if ( t % 2 == 0 ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { int num = ( s . charAt ( j ) - '0' ) * 10 + t ; if ( num % 4 == 0 ) { int k1 = i - j - 1 ; int k2 = n - i - 1 ; ans = Math . min ( ans , k1 + k2 ) ; } } } } if ( ans == n ) { for ( int i = 0 ; i < n ; i ++ ) { int num = s . charAt ( i ) - '0' ; if ( num % 4 == 0 ) { ans = n - 1 ; } } } System . out . println ( ans ) ; }
boolean isVowel ( char ch ) { if ( ch == 'a' ch == 'e' ch == 'i' ch == 'o' ch == 'u' ) return true ; if ( ch == 'A' ch == 'E' ch == 'I' ch == 'O' ch == 'U' ) return true ; return false ; }
void winner ( int arr [ ] , int N ) { if ( N % 2 == 1 ) { System . out . print ( "A" ) ; } else { System . out . print ( "B" ) ; } }
void LCMPairs ( int arr [ ] , int N ) { int total_pairs = ( N * ( N - 1 ) ) / 2 ; int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; } odd = ( odd * ( odd - 1 ) ) / 2 ; System . out . println ( "Even = " + ( total_pairs - odd ) + ", Odd = " + odd ) ; }
void getMaxSum ( int [ ] [ ] A , int M , int N ) { int sum = 0 ; int negative = 0 ; int minVal = Integer . MAX_VALUE ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { sum += Math . abs ( A [ i ] [ j ] ) ; if ( A [ i ] [ j ] < 0 ) { negative ++ ; } minVal = Math . min ( minVal , Math . abs ( A [ i ] [ j ] ) ) ; } } if ( negative % 2 != 0 ) { sum -= 2 * minVal ; } System . out . println ( sum ) ; }
int printNumber ( int N , int K , int M ) { int sum = K * ( M * ( M + 1 ) / 2 ) ; return sum - N ; }
void countEvenOdd ( int L , int R ) { int range = R - L + 1 ; int even = ( range / 4 ) * 2 ; if ( ( L & 1 ) != 0 && ( range % 4 == 3 ) ) { even ++ ; } else if ( ( L & 1 ) == 0 && ( range % 4 != 0 ) ) { even ++ ; } System . out . print ( "Even = " + even + ", Odd = " + ( range - even ) ) ; }
void findPerfectIndex ( int N , int K ) { int i = 0 ; for ( ; i < K ; i ++ ) { System . out . print ( ( N - K + 1 ) + i + " " ) ; } for ( ; i < N ; i ++ ) { System . out . print ( i - K + 1 + " " ) ; } }
boolean isPrime ( int N ) { if ( N <= 1 ) return false ; for ( int i = 2 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; }
void countPrimeTuples ( int N ) { int count = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( isPrime ( i ) && isPrime ( i - 2 ) ) count ++ ; } System . out . println ( count ) ; }
void countPairs ( int A [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( A [ i ] A [ j ] ) > ( A [ i ] & A [ j ] ) ) { count ++ ; } } System . out . println ( count ) ; }
void checkArrays ( int arr1 [ ] , int arr2 [ ] , int N ) { int count = 0 ; boolean flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) { if ( arr1 [ i ] == 0 ) count ++ ; else { count -- ; if ( count < 0 ) { flag = false ; break ; } } } } if ( ( flag && ( count == 0 ) ) == true ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
void construct_Array ( int N , int K ) { for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( K * i + " " ) ; } }
void maxSumOfDistinctPrimeFactors ( int [ ] arr , int N , int K ) { int [ ] CountDistinct = new int [ MAX + 1 ] ; boolean [ ] prime = new boolean [ MAX + 1 ] ; for ( int i = 0 ; i <= MAX ; i ++ ) { CountDistinct [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) { CountDistinct [ i ] = 1 ; for ( int j = i * 2 ; j <= MAX ; j += i ) { CountDistinct [ j ] ++ ; prime [ j ] = false ; } } } int sum = 0 ; int [ ] PrimeFactor = new int [ 20 ] ; for ( int i = 0 ; i < N ; i ++ ) { PrimeFactor [ CountDistinct [ arr [ i ] ] ] ++ ; } for ( int i = 19 ; i >= 1 ; i -- ) { while ( PrimeFactor [ i ] > 0 ) { sum += i ; PrimeFactor [ i ] -- ; K -- ; if ( K == 0 ) break ; } if ( K == 0 ) break ; } System . out . print ( sum ) ; }
void Print ( int N ) { if ( ( N / 2 ) % 2 == 1 || ( N % 2 == 1 ) ) { System . out . print ( - 1 ) ; return ; } int CurEven = 2 , CurOdd = 1 ; int SumOdd = 0 , SumEven = 0 ; for ( int i = 0 ; i < ( N / 2 ) ; i ++ ) { System . out . print ( CurEven + " " ) ; SumEven += CurEven ; CurEven += 2 ; } for ( int i = 0 ; i < N / 2 - 1 ; i ++ ) { System . out . print ( CurOdd + " " ) ; SumOdd += CurOdd ; CurOdd += 2 ; } CurOdd = SumEven - SumOdd ; System . out . println ( CurOdd ) ; }
int minimize ( int n ) { int optEle = n ; String strEle = Integer . toString ( n ) ; for ( int idx = 0 ; idx < strEle . length ( ) ; idx ++ ) { int temp = Integer . parseInt ( strEle . substring ( idx ) + strEle . substring ( 0 , idx ) ) ; optEle = Math . min ( optEle , temp ) ; } return optEle ; }
int maximize ( int n ) { int optEle = n ; String strEle = Integer . toString ( n ) ; for ( int idx = 0 ; idx < strEle . length ( ) ; idx ++ ) { int temp = Integer . parseInt ( strEle . substring ( idx ) + strEle . substring ( 0 , idx ) ) ; optEle = Math . max ( optEle , temp ) ; } return optEle ; }
void minOperations ( int [ ] arr , int N ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int res = arr [ i ] ; if ( mp . containsKey ( res ) ) mp . put ( res , mp . get ( res ) + 1 ) ; else mp . put ( res , 1 ) ; res /= 2 ; } int mx = 1 ; for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) { if ( it . getValue ( ) == N ) { mx = it . getKey ( ) ; } } int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int res = arr [ i ] ; while ( res != mx ) { ans ++ ; res /= 2 ; } } System . out . println ( ans ) ; }
int MinimumMoves ( int A [ ] , int B [ ] , int N ) { int totalOperations = 0 ; int carry = 0 ; int K = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { int nearestMultiple = ( int ) ( Math . ceil ( ( double ) ( A [ i ] + carry ) / ( double ) ( B [ i ] ) ) * B [ i ] ) ; K = nearestMultiple - ( A [ i ] + carry ) ; totalOperations += K ; carry += K ; } return totalOperations ; }
int maxSheets ( int A , int B ) { int area = A * B ; int count = 1 ; while ( area % 2 == 0 ) { area /= 2 ; count *= 2 ; } return count ; }
void minimumDeviation ( int A [ ] , int N ) { TreeSet < Integer > s = new TreeSet < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) s . add ( A [ i ] ) ; else s . add ( 2 * A [ i ] ) ; } int diff = s . last ( ) - s . first ( ) ; while ( ( s . last ( ) % 2 == 0 ) ) { int maxEl = s . last ( ) ; s . remove ( maxEl ) ; s . add ( maxEl / 2 ) ; diff = Math . min ( diff , s . last ( ) - s . first ( ) ) ; } System . out . print ( diff ) ; }
int findMaxNum ( int num ) { String binaryNumber = Integer . toBinaryString ( num ) ; String maxBinaryNumber = "" ; int count0 = 0 , count1 = 0 ; int N = binaryNumber . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( binaryNumber . charAt ( i ) == '1' ) { count1 ++ ; } else { count0 ++ ; } } for ( int i = 0 ; i < count1 ; i ++ ) { maxBinaryNumber += '1' ; } for ( int i = 0 ; i < count0 ; i ++ ) { maxBinaryNumber += '0' ; } return Integer . parseInt ( maxBinaryNumber , 2 ) ; }
void findMinMoves ( int a , int b ) { int ans = 0 ; if ( a == b || Math . abs ( a - b ) == 1 ) { ans = a + b ; } else { int k = Math . min ( a , b ) ; int j = Math . max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; } System . out . print ( ans ) ; }
void FindwinnerOfGame ( String S ) { int cntZero = 0 ; int cntConOne = 0 ; int nimSum = 0 ; int N = S . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . charAt ( i ) == '1' ) { cntConOne += 1 ; } else { nimSum ^= cntConOne ; cntConOne = 0 ; cntZero ++ ; } } nimSum ^= cntConOne ; if ( cntZero % 2 == 0 ) { System . out . print ( "Tie" ) ; } else if ( nimSum != 0 ) { System . out . print ( "player 1" ) ; } else { System . out . print ( "player 2" ) ; } }
String check ( int current_row , int current_col , int destination_row , int destination_col ) { if ( current_row == destination_row ) return "POSSIBLE" ; else if ( current_col == destination_col ) return "POSSIBLE" ; else return "NOT POSSIBLE" ; }
int maxChange ( char [ ] str ) { if ( str . length <= 1 ) { return 0 ; } int minChanges = 0 ; for ( int i = 0 ; i < str . length - 1 ; i ++ ) { if ( str [ i ] == str [ i + 1 ] ) { str [ i + 1 ] = 'N' ; minChanges += 1 ; } else if ( i > 0 && str [ i - 1 ] == str [ i + 1 ] ) { str [ i + 1 ] = 'N' ; minChanges += 1 ; } } return minChanges ; }
void generatepermutation ( int N ) { Vector < Integer > answer = new Vector < Integer > ( ) ; answer . add ( N ) ; for ( int i = 1 ; i < N ; i ++ ) { answer . add ( i ) ; } for ( int i : answer ) System . out . print ( i + " " ) ; }
int maxNumPalindrome ( String S ) { int i = 0 ; int [ ] freq = new int [ 26 ] ; int freqPair = 0 ; int len = S . length ( ) / 3 ; while ( i < S . length ( ) ) { freq [ S . charAt ( i ) - 'a' ] ++ ; i ++ ; } for ( i = 0 ; i < 26 ; i ++ ) { freqPair += ( freq [ i ] / 2 ) ; } return Math . min ( freqPair , len ) ; }
long cntEvenSumPairs ( long X , long Y ) { long cntXEvenNums = X / 2 ; long cntXOddNums = ( X + 1 ) / 2 ; long cntYEvenNums = Y / 2 ; long cntYOddNums = ( Y + 1 ) / 2 ; long cntPairs = ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) ; return cntPairs ; }
void farthestCellDistance ( int N , int M , int R , int C ) { int d1 = N + M - R - C ; int d2 = R + C - 2 ; int d3 = N - R + C - 1 ; int d4 = M - C + R - 1 ; int maxDistance = Math . max ( d1 , Math . max ( d2 , Math . max ( d3 , d4 ) ) ) ; System . out . println ( maxDistance ) ; }
void maxSum ( int [ ] arr , int N ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { int t = i ; if ( t + arr [ i ] < N ) { arr [ i ] += arr [ t + arr [ i ] ] ; } } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
void constructArray ( int arr [ ] , int N ) { int brr [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int K = ( int ) ( Math . log ( arr [ i ] ) / Math . log ( 2 ) ) ; int R = ( int ) Math . pow ( 2 , K ) ; brr [ i ] = R ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( brr [ i ] + " " ) ; } }
void findMinKToMakeAllEqual ( int N , int A [ ] ) { Set < Integer > B = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { B . add ( A [ i ] ) ; } ArrayList < Integer > b = new ArrayList < Integer > ( B ) ; int M = b . size ( ) ; int i = 0 ; if ( M > 3 ) { System . out . print ( "-1" ) ; } else if ( M == 3 ) { int B_1 = b . get ( i ++ ) ; int B_2 = b . get ( i ++ ) ; int B_3 = b . get ( i ++ ) ; if ( B_2 - B_1 == B_3 - B_2 ) { System . out . print ( B_2 - B_1 ) ; } else { System . out . print ( "-1" ) ; } } else if ( M == 2 ) { int B_1 = b . get ( i ++ ) ; int B_2 = b . get ( i ++ ) ; if ( ( B_2 - B_1 ) % 2 == 0 ) { System . out . print ( ( B_2 - B_1 ) / 2 ) ; } else { System . out . print ( B_2 - B_1 ) ; } } else { System . out . print ( 0 ) ; } }
void minOpsToTurnArrToZero ( int [ ] arr , int N ) { Set < Integer > st = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( st . contains ( arr [ i ] ) arr [ i ] == 0 ) { continue ; } else { st . add ( arr [ i ] ) ; } } System . out . println ( st . size ( ) ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void splitArray ( int arr [ ] , int N ) { TreeMap < Integer , Integer > mp = new TreeMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int G = 0 ; for ( Map . Entry < Integer , Integer > m : mp . entrySet ( ) ) { Integer i = m . getValue ( ) ; G = gcd ( G , i . intValue ( ) ) ; } if ( G > 1 ) System . out . print ( "YES" ) ; else System . out . print ( "NO" ) ; }
int minMoves ( int [ ] arr ) { int N = arr . length ; if ( N <= 2 ) return 0 ; int ans = Integer . MAX_VALUE ; for ( int i = - 1 ; i <= 1 ; i ++ ) { for ( int j = - 1 ; j <= 1 ; j ++ ) { int num1 = arr [ 0 ] + i ; int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = Math . abs ( i ) + Math . abs ( j ) ; for ( int idx = 2 ; idx < N ; idx ++ ) { int num = num1 + num2 ; if ( Math . abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += Math . abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag > 0 ) ans = Math . min ( ans , moves ) ; } } if ( ans == Integer . MAX_VALUE ) return - 1 ; return ans ; }
void querySum ( int arr [ ] , int N , int Q [ ] [ ] , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ; int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } System . out . print ( sum + " " ) ; } }
boolean CheckAllEqual ( int arr [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return false ; } } return true ; }
int minCntOperations ( int arr [ ] , int N ) { int Max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; boolean isPower2 ; if ( ( int ) ( Math . ceil ( ( Math . log ( N ) / Math . log ( N ) ) ) ) == ( int ) ( Math . floor ( ( ( Math . log ( N ) / Math . log ( 2 ) ) ) ) ) ) { isPower2 = true ; } else { isPower2 = false ; } if ( isPower2 && CheckAllEqual ( arr , N ) ) { return ( int ) ( Math . log ( Max ) / Math . log ( 2 ) ) ; } else { return ( int ) Math . ceil ( Math . log ( Max ) / Math . log ( 2 ) ) + 1 ; } }
String greatestReducedNumber ( String num , String s ) { Boolean [ ] vis_s = new Boolean [ 10 ] ; Arrays . fill ( vis_s , Boolean . FALSE ) ; for ( int i = 0 ; i < ( int ) s . length ( ) ; i ++ ) { vis_s [ ( int ) ( s . charAt ( i ) ) - 48 ] = true ; } int n = num . length ( ) ; int in = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis_s [ ( int ) num . charAt ( i ) - '0' ] ) { in = i ; break ; } } if ( in == - 1 ) { return num ; } for ( char dig = num . charAt ( in ) ; dig >= '0' ; dig -- ) { if ( vis_s [ ( int ) dig - '0' ] == false ) { num = num . substring ( 0 , in ) + dig + num . substring ( in + 1 , n ) ; break ; } } char LargestDig = '0' ; for ( char dig = '9' ; dig >= '0' ; dig -- ) { if ( vis_s [ dig - '0' ] == false ) { LargestDig = dig ; break ; } } for ( int i = in + 1 ; i < n ; i ++ ) { num = num . substring ( 0 , i ) + LargestDig ; } int Count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( num . charAt ( i ) == '0' ) Count ++ ; else break ; } num = num . substring ( Count , n ) ; if ( ( int ) num . length ( ) == 0 ) return "0" ; return num ; }
void minXOR ( int Arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( Arr [ i ] == 2 ) { System . out . print ( ( Arr [ i ] ^ 3 ) + " " ) ; } else { System . out . print ( ( Arr [ i ] ^ 2 ) + " " ) ; } } }
int [ ] findArray ( int n ) { int Arr [ ] = new int [ n + 1 ] ; Arr [ 0 ] = 0 ; Arr [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { Arr [ i ] = Arr [ i / 2 ] ; } else { Arr [ i ] = Arr [ ( i - 1 ) / 2 ] + Arr [ ( i - 1 ) / 2 + 1 ] ; } } return Arr ; }
int maxElement ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; int [ ] Arr = findArray ( n ) ; int ans = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , Arr [ i ] ) ; } return ans ; }
int findMaxValByRearrArr ( int arr [ ] , int N ) { int res = 0 ; res = ( N * ( N + 1 ) ) / 2 ; return res ; }
int min_steps_required ( int n , int m , int r , int c ) { int i , j ; int corner_steps_req = Integer . MAX_VALUE ; i = 1 ; j = 1 ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; i = n ; j = 1 ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; i = 1 ; j = m ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; i = n ; j = m ; corner_steps_req = Math . min ( corner_steps_req , Math . abs ( r - i ) + Math . abs ( j - c ) ) ; int minimum_steps = Math . min ( 2 * ( n - 1 ) + m - 1 , 2 * ( m - 1 ) + n - 1 ) ; return minimum_steps + corner_steps_req ; }
int min_elements ( int arr [ ] , int N , int K ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } Vector < Integer > Freq = new Vector < Integer > ( ) ; for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) { int i = it . getKey ( ) ; Freq . add ( mp . get ( i ) ) ; } Collections . sort ( Freq , Collections . reverseOrder ( ) ) ; int len = Freq . size ( ) ; if ( len <= K ) { return 0 ; } int cntMin = 0 ; for ( int i = K ; i < len ; i ++ ) { cntMin += Freq . get ( i ) ; } return cntMin ; }
int sumzero ( int arr [ ] , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum == 0 ) System . out . print ( "Yes" ) ; else if ( sum > 0 ) { if ( sum % K == 0 ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; } else System . out . print ( "No" ) ; return 0 ; }
int cntOnesArrWithGivenOp ( int arr [ ] , int N ) { int cntOnes = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i - 1 ; j < N ; j += i ) { arr [ j ] = arr [ j ] == 0 ? 1 : 0 ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) { cntOnes += 1 ; } } return cntOnes ; }
int cntOnesArrWithGivenOp ( int arr [ ] , int N ) { int cntOnes = 0 ; cntOnes = ( int ) Math . sqrt ( N ) ; return cntOnes ; }
void minimumMoves ( int [ ] arr , int N ) { int sum = 0 ; int maxelement = - 1 ; if ( N == 2 ) { System . out . print ( "0" ) ; return ; } for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; maxelement = Math . max ( maxelement , arr [ i ] ) ; } int k = ( sum + N - 2 ) / ( N - 1 ) ; k = Math . max ( maxelement , k ) ; int ans = k * ( N - 1 ) - sum ; System . out . println ( ans ) ; }
void minimumSwaps ( int arr1 [ ] , int arr2 [ ] , int n ) { int sumArr1 = 0 , sumArr2 = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sumArr1 += arr1 [ i ] ; sumArr2 += arr2 [ i ] ; } if ( sumArr1 % 2 == 0 && sumArr2 % 2 == 0 ) { System . out . print ( 0 ) ; return ; } if ( sumArr1 % 2 != 0 && sumArr2 % 2 != 0 ) { int flag = - 1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ( arr1 [ i ] + arr2 [ i ] ) % 2 == 1 ) { flag = 1 ; break ; } } System . out . print ( flag ) ; return ; } System . out . print ( - 1 ) ; }
void corpFlightBookings ( int [ ] [ ] Bookings , int N ) { int res [ ] = new int [ N ] ; for ( int i = 0 ; i < Bookings . length ; i ++ ) { int l = Bookings [ i ] [ 0 ] ; int r = Bookings [ i ] [ 1 ] ; int K = Bookings [ i ] [ 2 ] ; res [ l - 1 ] = res [ l - 1 ] + K ; if ( r <= res . length - 1 ) res [ r ] = ( - K ) + res [ r ] ; } for ( int i = 1 ; i < res . length ; i ++ ) res [ i ] = res [ i ] + res [ i - 1 ] ; for ( int i = 0 ; i < res . length ; i ++ ) { System . out . print ( res [ i ] + " " ) ; } }
void findOddXOR ( int n ) { if ( n % 2 == 0 ) System . out . print ( ( ( findXOR ( n ) ) ^ ( 2 * findXOR ( n / 2 ) ) ) ) ; else System . out . print ( ( ( findXOR ( n ) ) ^ ( 2 * findXOR ( ( n - 1 ) / 2 ) ) ) ) ; }
void findSmallestNumber ( int n ) { for ( int i = n ; i <= ( n + 2520 ) ; ++ i ) { int possible = 1 ; int temp = i ; while ( temp != 0 ) { if ( temp % 10 != 0 ) { int digit = temp % 10 ; if ( i % digit != 0 ) { possible = 0 ; break ; } } temp /= 10 ; } if ( possible == 1 ) { System . out . println ( i ) ; return ; } } }
void path_to_root ( int node ) { while ( node >= 1 ) { System . out . print ( node + " " ) ; node /= 2 ; } }
int minValue ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int minimum = arr [ 0 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] - minimum ) ; } return sum ; }
void computeLPSArray ( String pat , int M , int [ ] lps ) { int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < M ) { if ( pat . charAt ( i ) == pat . charAt ( len ) ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } }
char lastRemovedCharacter ( char [ ] str ) { int n = str . length ; if ( n == 1 ) return str [ 0 ] ; if ( str [ n - 2 ] == '0' ) { return ( char ) ( '1' - str [ n - 1 ] + '0' ) ; } else return str [ n - 1 ] ; }
void findNumbers ( int aXORb , int aANDb , int aXORc , int aANDc , int bXORc , int bANDc ) { int a , b , c ; int aSUMb ; int aSUMc ; int bSUMc ; aSUMb = aXORb + aANDb * 2 ; aSUMc = aXORc + aANDc * 2 ; bSUMc = bXORc + bANDc * 2 ; a = ( aSUMb - bSUMc + aSUMc ) / 2 ; b = aSUMb - a ; c = aSUMc - a ; System . out . print ( "a = " + a ) ; System . out . print ( ", b = " + b ) ; System . out . print ( ", c = " + c ) ; }
void findArray ( int N , int K ) { if ( N == 1 ) { System . out . print ( K + " " ) ; return ; } if ( N == 2 ) { System . out . print ( 0 + " " + K ) ; return ; } int P = N - 2 ; int Q = N - 1 ; int VAL = 0 ; for ( int i = 1 ; i <= ( N - 3 ) ; i ++ ) { System . out . print ( i + " " ) ; VAL ^= i ; } if ( VAL == K ) { System . out . print ( P + " " + Q + " " + ( P ^ Q ) ) ; } else { System . out . print ( 0 + " " + P + " " + ( P ^ K ^ VAL ) ) ; } }
int findNumber ( int N ) { int count = 0 ; while ( ( N & 1 ) == 1 ) { N = N >> 1 ; count ++ ; } return N << count ; }
int findNumber ( int N ) { return N & ( N + 1 ) ; }
void array_divisbleby_k ( int N , int K ) { boolean flag = false ; int d1 = 0 , d2 = 0 ; for ( int i = 2 ; i * i <= K ; i ++ ) { if ( K % i == 0 ) { flag = true ; d1 = i ; d2 = K / i ; break ; } } if ( flag ) { for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 1 ) { System . out . print ( d2 + " " ) ; } else { System . out . print ( d1 + " " ) ; } } } else { System . out . print ( - 1 ) ; } }
int min_elements ( int arr [ ] , int N ) { Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { mp . put ( arr [ i ] , mp . getOrDefault ( arr [ i ] , 0 ) + 1 ) ; } int cntMinRem = 0 ; for ( int key : mp . keySet ( ) ) { int i = key ; int val = mp . get ( i ) ; if ( val < i ) { cntMinRem += val ; } else if ( val > i ) { cntMinRem += ( val - i ) ; } } return cntMinRem ; }
boolean CheckAllarrayEqual ( int [ ] arr , int N ) { if ( N == 1 ) { return true ; } int totalSum = arr [ 0 ] ; int secMax = Integer . MIN_VALUE ; int Max = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] >= Max ) { secMax = Max ; Max = arr [ i ] ; } else if ( arr [ i ] > secMax ) { secMax = arr [ i ] ; } totalSum += arr [ i ] ; } if ( ( secMax * ( N - 1 ) ) > totalSum ) { return false ; } if ( totalSum % ( N - 1 ) != 0 ) { return false ; } return true ; }
int getSum ( int [ ] ar ) { int sum = 0 ; for ( int i : ar ) { sum += i ; } return sum ; }
int getMinSum ( int pos , int [ ] arr , Vector < Integer > primePow ) { if ( pos == primePow . size ( ) ) { return getSum ( arr ) ; } int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] *= primePow . get ( pos ) ; res = Math . min ( res , getMinSum ( pos + 1 , arr , primePow ) ) ; arr [ i ] /= primePow . get ( pos ) ; } return res ; }
int minimumSumWithGivenLCM ( int k , int x ) { Vector < Integer > primePow = primePower ( x ) ; int n = primePow . size ( ) ; int sum = 0 ; if ( n <= k ) { for ( int i : primePow ) { sum += i ; } sum += k - n ; } else { int [ ] arr = new int [ k ] ; Arrays . fill ( arr , 1 ) ; sum = getMinSum ( 0 , arr , primePow ) ; } return sum ; }
int IsPresent ( String str , String target ) { if ( str . contains ( target ) ) { return 1 ; } return - 1 ; }
int findBitwiseORGivenXORAND ( int X , int Y ) { return X + Y ; }
void minOperation ( int X [ ] , int Y [ ] , int n ) { int C = 0 ; int count = 0 ; for ( int i = 1 ; i < n ; i = i + 2 ) { if ( X [ i ] != Y [ i ] ) { count ++ ; } else { if ( count != 0 ) C ++ ; count = 0 ; } } if ( count != 0 ) C ++ ; count = 0 ; for ( int i = 0 ; i < n ; i = i + 2 ) { if ( X [ i ] != Y [ i ] ) { count ++ ; } else { if ( count != 0 ) C ++ ; count = 0 ; } } if ( count != 0 ) C ++ ; System . out . print ( C ) ; }
int minimumcntOperationReq ( int arr [ ] , int N ) { int cntOp = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { cntOp ++ ; } } return ( cntOp + 1 ) / 2 ; }
void ConstArrayAdjacentCoprime ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( i + " " ) ; } }
int cntIndexesToMakeBalance ( int arr [ ] , int n ) { if ( n == 1 ) { return 1 ; } if ( n == 2 ) return 0 ; int sumEven = 0 ; int sumOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { sumEven += arr [ i ] ; } else { sumOdd += arr [ i ] ; } } int currOdd = 0 ; int currEven = arr [ 0 ] ; int res = 0 ; int newEvenSum = 0 ; int newOddSum = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( i % 2 != 0 ) { currOdd += arr [ i ] ; newEvenSum = currEven + sumOdd - currOdd ; newOddSum = currOdd + sumEven - currEven - arr [ i ] ; } else { currEven += arr [ i ] ; newOddSum = currOdd + sumEven - currEven ; newEvenSum = currEven + sumOdd - currOdd - arr [ i ] ; } if ( newEvenSum == newOddSum ) { res ++ ; } } if ( sumOdd == sumEven - arr [ 0 ] ) { res ++ ; } if ( n % 2 == 1 ) { if ( sumOdd == sumEven - arr [ n - 1 ] ) { res ++ ; } } else { if ( sumEven == sumOdd - arr [ n - 1 ] ) { res ++ ; } } return res ; }
int findMinOperationsReqEmpStr ( String str ) { int cntOne = 0 ; int cntZero = 0 ; int N = str . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( str . charAt ( i ) == '0' ) { if ( cntOne != 0 ) { cntOne -- ; } cntZero ++ ; } else { if ( cntZero != 0 ) { cntZero -- ; } cntOne ++ ; } } return ( cntOne + cntZero ) ; }
void minimumOperations ( String S , int m ) { int V = 100 ; @ SuppressWarnings ( "unchecked" ) Vector < Integer > [ ] adj = new Vector [ V ] ; int total = 0 , N = S . length ( ) ; for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { addEdge ( adj , i , N - i - 1 ) ; addEdge ( adj , N - i - 1 , i ) ; } for ( int i = 0 ; i < N - m ; i ++ ) { addEdge ( adj , i , i + m ) ; addEdge ( adj , i + m , i ) ; } visited = new boolean [ V ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! visited [ i ] ) { int fre [ ] = new int [ 26 ] ; cnt = 0 ; int maxx = - 1 ; DFS ( i , adj , fre , S ) ; for ( int j = 0 ; j < 26 ; j ++ ) maxx = Math . max ( maxx , fre [ j ] ) ; total += cnt - maxx ; } } System . out . print ( total ) ; }
int countChanges ( char mat [ ] [ ] ) { int n = mat . length ; int m = mat [ 0 ] . length ; int ans = 0 ; for ( int j = 0 ; j < m - 1 ; j ++ ) { if ( mat [ n - 1 ] [ j ] != 'R' ) ans ++ ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( mat [ i ] [ m - 1 ] != 'D' ) ans ++ ; } return ans ; }
int findMaxSumByAlternatingSign ( int arr [ ] , int N ) { int cntNeg = 0 ; int MaxAltSum = 0 ; int SmValue = 0 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 0 ) { cntNeg += 1 ; } sum += Math . abs ( arr [ i ] ) ; SmValue = Math . min ( SmValue , Math . abs ( arr [ i ] ) ) ; } MaxAltSum = sum ; if ( cntNeg % 2 == 1 ) { MaxAltSum -= 2 * SmValue ; } return MaxAltSum ; }
int minCntCharDeletionsfrequency ( char [ ] str , int N ) { HashMap < Character , Integer > mp = new HashMap < > ( ) ; PriorityQueue < Integer > pq = new PriorityQueue < > ( ( x , y ) -> Integer . compare ( y , x ) ) ; int cntChar = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . containsKey ( str [ i ] ) ) { mp . put ( str [ i ] , mp . get ( str [ i ] ) + 1 ) ; } else { mp . put ( str [ i ] , 1 ) ; } } for ( Map . Entry < Character , Integer > it : mp . entrySet ( ) ) { pq . add ( it . getValue ( ) ) ; } while ( ! pq . isEmpty ( ) ) { int frequent = pq . peek ( ) ; pq . remove ( ) ; if ( pq . isEmpty ( ) ) { return cntChar ; } if ( frequent == pq . peek ( ) ) { if ( frequent > 1 ) { pq . add ( frequent - 1 ) ; } cntChar ++ ; } } return cntChar ; }
void constructNewArraySumZero ( int arr [ ] , int N ) { int newArr [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { newArr [ i ] = arr [ i + 1 ] ; } else { newArr [ i ] = - arr [ i - 1 ] ; } } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( newArr [ i ] + " " ) ; } }
int minimumCntOfFlipsRequired ( String str ) { int n = str . length ( ) ; int zeros = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '0' ) { zeros ++ ; } } if ( zeros == 0 zeros == n ) { return 0 ; } int minFlips = Integer . MAX_VALUE ; int currOnes = 0 ; int flips ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '1' ) { currOnes ++ ; } flips = currOnes + ( zeros - ( i + 1 - currOnes ) ) ; minFlips = Math . min ( minFlips , flips ) ; } return minFlips ; }
void constructMEX ( int arr [ ] , int N ) { int hash [ ] = new int [ MAXN ] ; for ( int i = 0 ; i < N ; i ++ ) { hash [ i ] = 0 ; } for ( int i = 0 ; i < N ; i ++ ) { hash [ arr [ i ] ] = 1 ; } int MexOfArr = 0 ; for ( int i = 1 ; i < MAXN ; i ++ ) { if ( hash [ i ] == 0 ) { MexOfArr = i ; break ; } } int B [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < MexOfArr ) B [ i ] = arr [ i ] ; else B [ i ] = MexOfArr ; } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( B [ i ] + " " ) ; }
void smallestNumberLeftInPQ ( int arr [ ] , int N ) { PriorityQueue < Integer > pq = new PriorityQueue < > ( ( x , y ) -> Integer . compare ( y , x ) ) ; Vector < pair > pairsArr = new Vector < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { pq . add ( arr [ i ] ) ; } while ( pq . size ( ) > 1 ) { int X = pq . peek ( ) ; pq . remove ( ) ; int Y = pq . peek ( ) ; pq . remove ( ) ; pq . add ( ( X + Y + 1 ) / 2 ) ; pairsArr . add ( new pair ( X , Y ) ) ; } System . out . print ( "{" + pq . peek ( ) + "}, " ) ; int sz = pairsArr . size ( ) ; for ( int i = 0 ; i < sz ; i ++ ) { if ( i == 0 ) { System . out . print ( "{ " ) ; } System . out . print ( "(" + pairsArr . get ( i ) . first + ", " + pairsArr . get ( i ) . second + ")" ) ; if ( i != sz - 1 ) { System . out . print ( ", " ) ; } if ( i == sz - 1 ) { System . out . print ( " }" ) ; } } }
void findPairs ( int N ) { for ( int i = 0 ; i <= N ; i ++ ) { System . out . print ( "(" + i + ", " + ( N - i ) + "), " ) ; } }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
void canReach ( int N , int A , int B , int K ) { int gcd = GCD ( N , K ) ; if ( Math . abs ( A - B ) % gcd == 0 ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } }
int sum ( int n ) { int res = 0 ; while ( n > 0 ) { res += n % 10 ; n /= 10 ; } return res ; }
int smallestNumber ( int n , int s ) { if ( sum ( n ) <= s ) { return n ; } int ans = n , k = 1 ; for ( int i = 0 ; i < 9 ; ++ i ) { int digit = ( ans / k ) % 10 ; int add = k * ( ( 10 - digit ) % 10 ) ; ans += add ; if ( sum ( ans ) <= s ) { break ; } k *= 10 ; } return ans ; }
int separate ( int arr [ ] , int n , int parity ) { int count = 1 , res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( ( arr [ i ] + parity ) & 1 ) != 0 && ( ( arr [ i - 1 ] + parity ) & 1 ) != 0 ) count ++ ; else { if ( count > 1 ) res += count - 1 ; count = 1 ; } } return res ; }
void requiredOps ( int arr [ ] , int N ) { int res1 = separate ( arr , N , 0 ) ; int res2 = separate ( arr , N , 1 ) ; System . out . print ( Math . max ( res1 , res2 ) ) ; }
boolean [ ] SieveOfEratosthenes ( int N ) { boolean [ ] isPrime = new boolean [ N + 1 ] ; Arrays . fill ( isPrime , true ) ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( isPrime [ p ] ) { for ( int i = p * p ; i <= N ; i += p ) { isPrime [ i ] = false ; } } } return isPrime ; }
int cntPairsdiffOfPrimeisPrime ( int N ) { int cntPairs = 0 ; boolean [ ] isPrime = SieveOfEratosthenes ( N ) ; for ( int i = 2 ; i <= N ; i ++ ) { if ( isPrime [ i ] && isPrime [ i - 2 ] ) { cntPairs += 2 ; } } return cntPairs ; }
void longestSubsequence ( int arr [ ] , int N ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count ++ ; } } System . out . println ( count ) ; }
int substringCount ( String s ) { int [ ] freq = new int [ 26 ] ; char max_char = '#' ; int maxfreq = Integer . MIN_VALUE ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { freq [ s . charAt ( i ) - 'a' ] ++ ; if ( maxfreq < freq [ s . charAt ( i ) - 'a' ] ) maxfreq = freq [ s . charAt ( i ) - 'a' ] ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( maxfreq == freq [ i ] ) { max_char = ( char ) ( i + 'a' ) ; break ; } } int ans = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char ch = s . charAt ( i ) ; if ( max_char == ch ) { ans += ( s . length ( ) - i ) ; } } return ans ; }
int findSum ( int [ ] S , int n , int x ) { int [ ] [ ] table = new int [ n + 1 ] [ x + 1 ] ; for ( int i = 1 ; i <= x ; i ++ ) { table [ 0 ] [ i ] = Integer . MAX_VALUE - 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= x ; j ++ ) { if ( S [ i - 1 ] > j ) { table [ i ] [ j ] = table [ i - 1 ] [ j ] ; } else { table [ i ] [ j ] = Math . min ( table [ i - 1 ] [ j ] , table [ i ] [ j - S [ i - 1 ] ] + 1 ) ; } } } return ( table [ n ] [ x ] > n ) ? - 1 : table [ n ] [ x ] ; }
void minRemovals ( int [ ] arr , int n , int m , int x ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int requied_Sum = 0 ; if ( sum % m < x ) requied_Sum = m + sum % m - x ; else requied_Sum = sum % m - x ; System . out . print ( findSum ( arr , n , requied_Sum ) ) ; }
void findXandYwithminABSX_Y ( int N ) { if ( N % 2 == 1 ) { System . out . print ( ( N / 2 ) + " " + ( N / 2 + 1 ) ) ; } else { System . out . print ( ( N / 2 - 1 ) + " " + ( N / 2 + 1 ) ) ; } }
String removeDuplicateLetters ( String s ) { int [ ] cnt = new int [ 26 ] ; int [ ] vis = new int [ 26 ] ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) cnt [ s . charAt ( i ) - 'a' ] ++ ; String res = "" ; for ( int i = 0 ; i < n ; i ++ ) { cnt [ s . charAt ( i ) - 'a' ] -- ; if ( vis [ s . charAt ( i ) - 'a' ] == 0 ) { int size = res . length ( ) ; while ( size > 0 && res . charAt ( size - 1 ) > s . charAt ( i ) && cnt [ res . charAt ( size - 1 ) - 'a' ] > 0 ) { vis [ res . charAt ( size - 1 ) - 'a' ] = 0 ; res = res . substring ( 0 , size - 1 ) ; size -- ; } res += s . charAt ( i ) ; vis [ s . charAt ( i ) - 'a' ] = 1 ; } } return res ; }
int minChange ( String s , int n ) { int L [ ] = new int [ 26 ] ; int R [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n / 2 ; i ++ ) { char ch = s . charAt ( i ) ; L [ ch - 'a' ] ++ ; } for ( int i = n / 2 ; i < n ; i ++ ) { char ch = s . charAt ( i ) ; R [ ch - 'a' ] ++ ; } int count = n ; for ( char ch = 'a' ; ch <= 'z' ; ch ++ ) { count = Math . min ( count , n - L [ ch - 'a' ] - R [ ch - 'a' ] ) ; } int change = n / 2 ; for ( int d = 0 ; d + 1 < 26 ; d ++ ) { change -= L [ d ] ; change += R [ d ] ; count = Math . min ( count , change ) ; } change = n / 2 ; for ( int d = 0 ; d + 1 < 26 ; d ++ ) { change -= R [ d ] ; change += L [ d ] ; count = Math . min ( change , count ) ; } return count ; }
void minSteps ( String S ) { String new_str = "" ; int N = S . length ( ) ; int i = 0 ; while ( i < N ) { new_str += S . charAt ( i ) ; int j = i ; while ( i < N && S . charAt ( i ) == S . charAt ( j ) ) ++ i ; } System . out . print ( ( int ) Math . ceil ( ( new_str . length ( ) + 1 ) / 2.0 ) ) ; }
int MaximumSides ( int n ) { if ( n < 4 ) return - 1 ; return n % 2 == 0 ? n / 2 : - 1 ; }
int minimumMoves ( int n ) { int cnt2 = 0 , cnt5 = 0 ; while ( n % 2 == 0 ) { n /= 2 ; cnt2 ++ ; } while ( n % 5 == 0 ) { n /= 5 ; cnt5 ++ ; } if ( n == 1 && cnt2 <= cnt5 ) { return 2 * cnt5 - cnt2 ; } else return - 1 ; }
void check ( int n ) { if ( ( n & n - 1 ) != 0 ) System . out . println ( "YES" ) ; else System . out . println ( "NO" ) ; }
void rearrangeArrayUtil ( ArrayList < Integer > A , ArrayList < Integer > B , int N ) { ArrayList < Integer > ans = rearrangeArray ( A , B , N ) ; if ( ans . size ( ) != 0 ) { for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( ans . get ( i ) + " " ) ; } } else { System . out . println ( "-1" ) ; } }
void countOfSubarray ( int arr [ ] , int N ) { Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int answer = 0 ; int sum = 0 ; if ( mp . get ( 1 ) != null ) mp . put ( 1 , mp . get ( 1 ) + 1 ) ; else mp . put ( 1 , 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; if ( mp . get ( sum - i ) != null ) answer += mp . get ( sum - i ) ; if ( mp . get ( sum - i ) != null ) mp . put ( sum - i , mp . get ( sum - i ) + 1 ) ; else mp . put ( sum - i , 1 ) ; } System . out . print ( answer ) ; }
void countInverse ( int [ ] arr , int N , int M ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int gcdOfMandelement = gcd ( M , arr [ i ] ) ; if ( gcdOfMandelement == 1 ) { XOR ^= arr [ i ] ; } } System . out . println ( XOR ) ; }
int Moves_Calculator ( int x , int y , int row , int col ) { int total_moves = 0 ; if ( ( row - x ) > 0 && ( col - y ) > 0 ) total_moves += Math . min ( ( row - x ) , ( col - y ) ) ; if ( ( y - 1 ) > 0 && ( x - 1 ) > 0 ) total_moves += Math . min ( ( y - 1 ) , ( x - 1 ) ) ; if ( ( x - 1 ) > 0 && ( col - y ) > 0 ) total_moves += Math . min ( ( x - 1 ) , ( col - y ) ) ; if ( ( row - x ) > 0 && ( y - 1 ) > 0 ) total_moves += Math . min ( ( row - x ) , ( y - 1 ) ) ; total_moves += ( row - 1 ) + ( col - 1 ) ; int king_moves = 0 ; if ( x + 1 <= row ) king_moves += 1 ; if ( x - 1 > 0 ) king_moves += 1 ; if ( y + 1 <= col ) king_moves += 1 ; if ( y - 1 > 0 ) king_moves += 1 ; if ( x + 1 <= row && y + 1 <= col ) king_moves += 1 ; if ( x + 1 <= row && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y + 1 <= col ) king_moves += 1 ; return total_moves - king_moves ; }
int clstNum ( int N ) { return ( N - 1 ) ; }
int findMax ( int [ ] a , int dp [ ] [ ] , int i , int flag ) { if ( i == ( int ) a . length ) { return 0 ; } if ( dp [ i ] [ flag ] != - 1 ) { return dp [ i ] [ flag ] ; } int ans ; if ( flag == 0 ) { ans = Math . max ( findMax ( a , dp , i + 1 , 0 ) , a [ i ] + findMax ( a , dp , i + 1 , 1 ) ) ; } else { ans = Math . max ( findMax ( a , dp , i + 1 , 1 ) , - 1 * a [ i ] + findMax ( a , dp , i + 1 , 0 ) ) ; } return dp [ i ] [ flag ] = ans ; }
void findMaxSumUtil ( int [ ] arr , int N ) { int dp [ ] [ ] = new int [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } System . out . println ( findMax ( arr , dp , 0 , 0 ) ) ; }
int equvInverse ( int [ ] arr , int N , int P ) { int cntElem = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] * arr [ i ] ) % P == 1 ) { cntElem ++ ; } } return cntElem ; }
int power ( int K , int M ) { int res = 1 ; while ( M > 0 ) { if ( ( M & 1 ) == 1 ) { res = ( res * K ) ; } M = M >> 1 ; K = ( K * K ) ; } return res ; }
int cntWays ( int arr [ ] , int N , int K ) { int cntways = 0 ; int M = 0 ; Set < Integer > st = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { st . add ( arr [ i ] ) ; } M = st . size ( ) ; cntways = power ( K , M ) ; return cntways ; }
void minCost ( String s , int k ) { int n = s . length ( ) ; int ans = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int [ ] a = new int [ 26 ] ; for ( int j = i ; j < n ; j += k ) { a [ s . charAt ( j ) - 'a' ] ++ ; } int min_cost = Integer . MAX_VALUE ; for ( int ch = 0 ; ch < 26 ; ch ++ ) { int cost = 0 ; for ( int tr = 0 ; tr < 26 ; tr ++ ) cost += Math . abs ( ch - tr ) * a [ tr ] ; min_cost = Math . min ( min_cost , cost ) ; } ans += min_cost ; } System . out . println ( ans ) ; }
double pairProductMean ( int arr [ ] , int N ) { Vector < Integer > pairArray = new Vector < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int pairProduct = arr [ i ] * arr [ j ] ; pairArray . add ( pairProduct ) ; } } int length = pairArray . size ( ) ; float sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) sum += pairArray . get ( i ) ; float mean ; if ( length != 0 ) mean = sum / length ; else mean = 0 ; return mean ; }
float pairProductMean ( int arr [ ] , int N ) { int suffixSumArray [ ] = new int [ N ] ; suffixSumArray [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { suffixSumArray [ i ] = suffixSumArray [ i + 1 ] + arr [ i ] ; } int length = ( N * ( N - 1 ) ) / 2 ; float res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { res += arr [ i ] * suffixSumArray [ i + 1 ] ; } float mean ; if ( length != 0 ) mean = res / length ; else mean = 0 ; return mean ; }
int TotalXorPair ( int arr [ ] , int N ) { int totalXOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { totalXOR ^= arr [ i ] ^ arr [ j ] ; } } return totalXOR ; }
int minAbsDiff ( int N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; }
void findWinner ( char [ ] s ) { int vowels_count = 0 , consonants_count = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == 'a' s [ i ] == 'e' s [ i ] == 'i' s [ i ] == 'o' s [ i ] == 'u' ) { vowels_count ++ ; } else { consonants_count ++ ; } } if ( vowels_count == 0 ) { if ( consonants_count % 2 == 0 ) { System . out . print ( "Player B" ) ; } else { System . out . print ( "Player A" ) ; } } else if ( vowels_count == 1 && consonants_count % 2 != 0 ) { System . out . print ( "Player A" ) ; } else { System . out . print ( "D" ) ; } }
void possibleAcyclicGraph ( int N ) { System . out . print ( ( int ) Math . pow ( 2 , N - 1 ) ) ; return ; }
int minProd ( int X , int Y , int N ) { if ( X <= Y ) { if ( N < X ) return ( X - N ) * Y ; else { return Math . max ( Y - ( N - X + 1 ) , 1 ) ; } } if ( Y >= N ) return ( Y - N ) * X ; return Math . max ( X - ( N - Y + 1 ) , 1 ) ; }
void sieve ( ) { is_prime = new int [ MAXN ] ; count_of_primes = new int [ MAXN ] ; Arrays . fill ( is_prime , 0 ) ; Arrays . fill ( count_of_primes , 0 ) ; for ( int i = 3 ; i < MAXN ; i += 2 ) { is_prime [ i ] = 1 ; } for ( int i = 3 ; i * i < MAXN ; i += 2 ) { if ( is_prime [ i ] == 1 ) { for ( int j = i * i ; j < MAXN ; j += i ) { is_prime [ j ] = 0 ; } } } is_prime [ 2 ] = 1 ; for ( int i = 1 ; i < MAXN ; i ++ ) count_of_primes [ i ] = count_of_primes [ i - 1 ] + is_prime [ i ] ; }
long power ( long x , long y , long p ) { long result = 1 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) result = ( result * x ) % p ; x = ( x * x ) % p ; y >>= 1 ; } return result ; }
void maxSumOfSquares ( int N , int S ) { int res = 0 ; if ( S < N S > 9 * N ) { System . out . println ( - 1 ) ; return ; } S = S - N ; int c = 0 ; while ( S > 0 ) { c ++ ; if ( S / 8 > 0 ) { res += 9 * 9 ; S -= 8 ; } else { res += ( S + 1 ) * ( S + 1 ) ; break ; } } res = res + ( N - c ) ; System . out . println ( res ) ; }
int cntMinSub ( int arr [ ] , int N , int K ) { int res = 0 ; int start = 0 ; int end = N - 1 ; Arrays . sort ( arr ) ; while ( end - start > 1 ) { if ( arr [ start ] + arr [ end ] <= K ) { start ++ ; } else { res ++ ; end -- ; } } if ( end - start == 1 ) { if ( arr [ start ] + arr [ end ] <= K ) { res ++ ; start ++ ; end -- ; } else { res ++ ; end -- ; } } if ( start == end ) { res ++ ; } return res ; }
int condition ( int a , int b ) { int d = Math . abs ( a - b ) , count = 0 ; for ( int i = 1 ; i <= Math . sqrt ( d ) ; i ++ ) { if ( d % i == 0 ) { if ( d / i == i ) count += 1 ; else count += 2 ; } } return count ; }
boolean isComposite ( int N ) { for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return true ; } } return false ; }
int compositePair ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int prod = arr [ i ] * arr [ j ] ; if ( isComposite ( prod ) ) { res ++ ; } } } return res ; }
boolean [ ] getPrimeNum ( ) { boolean isPrime [ ] = new boolean [ X ] ; Arrays . fill ( isPrime , true ) ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= X ; i ++ ) { if ( isPrime [ i ] == true ) { for ( int j = i * i ; j < X ; j += i ) { isPrime [ j ] = false ; } } } return isPrime ; }
long power ( int x , int y ) { if ( y == 0 ) return 1 ; int p = ( int ) ( power ( x , y / 2 ) % mod ) ; p = ( p * p ) % mod ; if ( y % 2 == 1 ) { p = ( x * p ) % mod ; } return p ; }
boolean checkDigits ( int n ) { do { int r = n % 10 ; if ( r == 3 r == 4 r == 6 r == 7 r == 9 ) return false ; n /= 10 ; } while ( n != 0 ) ; return true ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
boolean isAllPrime ( int n ) { return isPrime ( n ) && checkDigits ( n ) ; }
void generateArray ( int arr [ ] , int n ) { Deque < Integer > ans = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i & 1 ) != 0 ) ans . addFirst ( arr [ i ] ) ; else ans . add ( arr [ i ] ) ; } if ( ( n & 1 ) != 0 ) { Collections . reverse ( Arrays . asList ( ans ) ) ; } for ( int x : ans ) { System . out . print ( x + " " ) ; } System . out . println ( ) ; }
int No_Of_subsequences ( HashMap < Integer , Integer > mp ) { int count = 0 ; int left = 0 ; for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) { mp . replace ( x . getKey ( ) , x . getValue ( ) + left ) ; count += ( x . getValue ( ) / x . getKey ( ) ) ; left = x . getValue ( ) % x . getKey ( ) ; } return count ; }
void maximumsubsequences ( int [ ] arr , int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . replace ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } System . out . println ( No_Of_subsequences ( mp ) ) ; }
int power ( int X , int n ) { int res = 1 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 ) res = res * X ; X = X * X ; n = n >> 1 ; } return res ; }
int closestgtNum ( int N ) { int n = ( int ) Math . log10 ( N ) + 1 ; int P = power ( 10 , n - 1 ) ; int Y = N % P ; int res = N + ( P - Y ) ; return res ; }
String closestgtNum ( String str ) { String res = "" ; int n = str . length ( ) ; if ( str . charAt ( 0 ) < '9' ) { res += ( char ) ( str . charAt ( 0 ) + 1 ) ; } else { res += ( char ) ( '1' ) ; res += ( char ) ( '0' ) ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { res += ( char ) ( '0' ) ; } return res ; }
int find_next ( int n , int k ) { int M = n + 1 ; while ( true ) { if ( ( M & ( 1L << k ) ) > 0 ) break ; M ++ ; } return M ; }
boolean check ( List < Integer > arr , ArrayList < List < Integer > > pieces ) { Map < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) m . put ( arr . get ( i ) , i ) ; for ( int i = 0 ; i < pieces . size ( ) ; i ++ ) { if ( pieces . get ( i ) . size ( ) == 1 && m . containsKey ( pieces . get ( i ) . get ( 0 ) ) ) { continue ; } else if ( pieces . get ( i ) . size ( ) > 1 && m . containsKey ( pieces . get ( i ) . get ( 0 ) ) ) { int idx = m . get ( pieces . get ( i ) . get ( 0 ) ) ; idx ++ ; if ( idx >= arr . size ( ) ) return false ; for ( int j = 1 ; j < pieces . get ( i ) . size ( ) ; j ++ ) { if ( arr . get ( idx ) . equals ( pieces . get ( i ) . get ( j ) ) ) { idx ++ ; if ( idx >= arr . size ( ) && j < pieces . get ( i ) . size ( ) - 1 ) return false ; } else { return false ; } } } else { return false ; } } return true ; }
int maximumSubarrays ( int arr [ ] , int N , int target ) { int ans = 0 ; int availIdx = - 1 ; int cur_sum = 0 ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; mp . put ( 0 , 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { cur_sum += arr [ i ] ; if ( mp . containsKey ( cur_sum - target ) && mp . get ( cur_sum - target ) >= availIdx ) { ans ++ ; availIdx = i ; } mp . put ( cur_sum , i ) ; } return ans ; }
int power ( int x , int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }
void maximumPossibleSum ( int N , int X ) { System . out . println ( X * ( power ( 2 , N ) - 1 ) ) ; }
int countOfPairs ( int x , int y ) { int counter = 1 ; while ( x > 0 y > 0 ) { int bit1 = x % 2 ; int bit2 = y % 2 ; x >>= 1 ; y >>= 1 ; if ( bit1 == 1 && bit2 == 0 ) { counter *= 2 ; continue ; } if ( ( bit1 & bit2 ) > 0 ) { counter = 0 ; break ; } } return counter ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findGCD ( int arr [ ] , int N ) { int result = 0 ; for ( int element : arr ) { result = gcd ( result , element ) ; if ( result == 1 ) { return 1 ; } } return result ; }
boolean check_digits ( long N ) { while ( N > 0 ) { int n = ( int ) ( N % 10 ) ; if ( ( n != 0 ) && ( n != 1 ) && ( n != 4 ) && ( n != 9 ) ) { return false ; } N = N / 10 ; } return true ; }
void isFullSquare ( long N ) { if ( is_perfect ( N ) && check_digits ( N ) ) { System . out . print ( "Yes" ) ; } else { System . out . print ( "No" ) ; } }
int maxBottles ( int n , int e ) { int s = 0 , b = 0 ; int a = n ; while ( a != 0 ) { s = s + a ; a = ( a + b ) / e ; b = n - ( a * e ) ; n = a + b ; } return s ; }
int power ( int x , int n ) { int temp ; if ( n == 0 ) return 1 ; temp = power ( x , n / 2 ) ; if ( n % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }
int count_Total_Numbers ( int n , int x ) { int total , multiples = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( i % x == 0 ) multiples ++ ; } if ( n == 1 ) return multiples ; total = ( multiples - 1 ) * power ( multiples , n - 1 ) ; return total ; }
int getPosition ( int N , int M ) { if ( M > ( N / 2 ) ) { return ( M - ( N / 2 ) ) ; } return ( M + ( N / 2 ) ) ; }
void number_of_strings ( int N , int M ) { int ans = 0 ; while ( N > 0 && M > 0 ) { if ( N > M ) { if ( N >= 2 ) { N -= 2 ; -- M ; ++ ans ; } else { break ; } } else { if ( M >= 2 ) { M -= 2 ; -- N ; ++ ans ; } else { break ; } } } System . out . println ( ans ) ; }
int clearLastBit ( int N , int K ) { int mask = ( - 1 << K + 1 ) ; return N = N & mask ; }
void SieveOfEratosthenes ( ) { Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p < maxm ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i < maxm ; i += p ) prime [ i ] = false ; } } prime [ 0 ] = false ; prime [ 1 ] = false ; }
void num_prime ( ) { prime_number [ 0 ] = 0 ; for ( int i = 1 ; i <= maxm ; i ++ ) { int tmp ; if ( prime [ i ] == true ) { tmp = 1 ; } else { tmp = 0 ; } prime_number [ i ] = prime_number [ i - 1 ] + tmp ; } }
void min_steps ( int arr [ ] , int n ) { SieveOfEratosthenes ( ) ; num_prime ( ) ; if ( n == 1 ) { System . out . println ( "0" ) ; } else if ( n == 2 ) { System . out . println ( "1" ) ; } else { System . out . println ( prime_number [ n ] - 1 + ( n - 2 ) ) ; } }
void findWinner ( int a [ ] , int n ) { int win = 0 ; if ( n % 2 == 0 ) win = 1 ; else win = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( i % 2 == 1 ) { if ( win == 0 && a [ i ] > 1 ) win = 1 ; } else { if ( win == 1 && a [ i ] > 1 ) win = 0 ; } } if ( win == 0 ) System . out . print ( "A" ) ; else System . out . print ( "B" ) ; }
boolean isPossible ( int r , int b , int g ) { r = r % 3 ; b = b % 3 ; g = g % 3 ; if ( r == b b == g g == r ) { return true ; } else { return false ; } }
void checkWinner ( int N , int K ) { if ( N % ( K + 1 ) > 0 ) { System . out . print ( "A" ) ; } else { System . out . print ( "B" ) ; } }
int ncr ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
int countPath ( int N , int M , int K ) { int answer ; if ( K >= 2 ) answer = 0 ; else if ( K == 0 ) answer = ncr ( N + M - 2 , N - 1 ) ; else { answer = ncr ( N + M - 2 , N - 1 ) ; int X = ( N - 1 ) / 2 + ( M - 1 ) / 2 ; int Y = ( N - 1 ) / 2 ; int midCount = ncr ( X , Y ) ; X = ( ( N - 1 ) - ( N - 1 ) / 2 ) + ( ( M - 1 ) - ( M - 1 ) / 2 ) ; Y = ( ( N - 1 ) - ( N - 1 ) / 2 ) ; midCount *= ncr ( X , Y ) ; answer -= midCount ; } return answer ; }
int calculate_steps ( Integer arr [ ] , int n , int minimum ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int val = arr [ i ] ; if ( arr [ i ] > minimum ) { arr [ i ] = arr [ i ] - minimum ; count += arr [ i ] / 5 ; arr [ i ] = arr [ i ] % 5 ; count += arr [ i ] / 2 ; arr [ i ] = arr [ i ] % 2 ; if ( arr [ i ] > 0 ) { count ++ ; } } arr [ i ] = val ; } return count ; }
int solve ( Integer arr [ ] , int n ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; int minimum = arr [ n - 1 ] ; int count1 = 0 , count2 = 0 , count3 = 0 ; count1 = calculate_steps ( arr , n , minimum ) ; count2 = calculate_steps ( arr , n , minimum - 1 ) ; count3 = calculate_steps ( arr , n , minimum - 2 ) ; return Math . min ( count1 , Math . min ( count2 , count3 ) ) ; }
int maxSubset ( Integer arr [ ] , int N , int X ) { Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; int counter = 0 ; int sz = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sz ++ ; if ( arr [ i ] * sz >= X ) { counter ++ ; sz = 0 ; } } return counter ; }
int getCount ( int N , int M ) { int total_count = 0 ; total_count += ( N / 10 ) ; int x = ( N / 10 ) * 10 ; if ( ( N - x ) >= M ) { total_count = total_count + 1 ; } return total_count ; }
int maximumModuloValue ( int A [ ] , int n ) { int mn = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { mn = Math . min ( A [ i ] , mn ) ; } return mn ; }
int RightAngled ( int a [ ] [ ] , int n ) { HashMap < Integer , Integer > xpoints = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > ypoints = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( xpoints . containsKey ( a [ i ] [ 0 ] ) ) { xpoints . put ( a [ i ] [ 0 ] , xpoints . get ( a [ i ] [ 0 ] ) + 1 ) ; } else { xpoints . put ( a [ i ] [ 0 ] , 1 ) ; } if ( ypoints . containsKey ( a [ i ] [ 1 ] ) ) { ypoints . put ( a [ i ] [ 1 ] , ypoints . get ( a [ i ] [ 1 ] ) + 1 ) ; } else { ypoints . put ( a [ i ] [ 1 ] , 1 ) ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( xpoints . get ( a [ i ] [ 0 ] ) >= 1 && ypoints . get ( a [ i ] [ 1 ] ) >= 1 ) { count += ( xpoints . get ( a [ i ] [ 0 ] ) - 1 ) * ( ypoints . get ( a [ i ] [ 1 ] ) - 1 ) ; } } return count ; }
void updateQuery ( int from_x , int from_y , int to_x , int to_y , int k , int aux [ ] [ ] ) { aux [ from_x ] [ from_y ] += k ; if ( to_x + 1 < N ) aux [ to_x + 1 ] [ from_y ] -= k ; if ( to_x + 1 < N && to_y + 1 < M ) aux [ to_x + 1 ] [ to_y + 1 ] += k ; if ( to_y + 1 < M ) aux [ from_x ] [ to_y + 1 ] -= k ; }
void RepeatingSubarray ( int arr [ ] , int N ) { if ( N < 2 ) { System . out . print ( "-1" ) ; } Vector < Integer > brr = new Vector < Integer > ( ) ; brr . add ( arr [ 0 ] ) ; brr . add ( arr [ 1 ] ) ; for ( int i = 2 ; i < N / 2 + 1 ; i ++ ) { if ( N % i == 0 ) { boolean a = false ; int n = brr . size ( ) ; int j = i ; while ( j < N ) { int K = j % i ; if ( arr [ j ] == brr . get ( K ) ) { j ++ ; } else { a = true ; break ; } } if ( ! a && j == N ) { printArray ( brr ) ; return ; } } brr . add ( arr [ i ] ) ; } System . out . print ( "-1" ) ; return ; }
void SieveOfEratosthenes ( int n ) { Arrays . fill ( isprime , true ) ; isprime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isprime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) isprime [ i ] = false ; } } }
int KDistinctPrime ( int arr [ ] , int n , int k ) { SieveOfEratosthenes ( 2000000 ) ; Map < Integer , Integer > cnt = new HashMap < > ( ) ; int result = - 1 ; for ( int i = 0 , j = - 1 ; i < n ; ++ i ) { int x = arr [ i ] ; if ( isprime [ x ] ) { cnt . put ( x , cnt . getOrDefault ( x , 0 ) + 1 ) ; if ( cnt . get ( x ) == 1 ) { -- k ; } } while ( k < 0 ) { x = arr [ ++ j ] ; if ( isprime [ x ] ) { cnt . put ( x , cnt . getOrDefault ( x , 0 ) - 1 ) ; if ( cnt . get ( x ) == 0 ) { ++ k ; } } } if ( k == 0 ) result = Math . max ( result , i - j ) ; } return result ; }
void printMissingElements ( int arr [ ] , int N ) { int [ ] b = new int [ arr [ N - 1 ] + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( int i = arr [ 0 ] ; i <= arr [ N - 1 ] ; i ++ ) { if ( b [ i ] == 0 ) { System . out . print ( i + " " ) ; } } }
void SieveOfEratosthenes ( Vector < Integer > StorePrimes ) { boolean [ ] IsPrime = new boolean [ MAX_SIZE ] ; Arrays . fill ( IsPrime , true ) ; for ( int p = 2 ; p * p < MAX_SIZE ; p ++ ) { if ( IsPrime [ p ] == true ) { for ( int i = p * p ; i < MAX_SIZE ; i += p ) IsPrime [ i ] = false ; } } for ( int p = 2 ; p < MAX_SIZE ; p ++ ) if ( IsPrime [ p ] ) StorePrimes . add ( p ) ; }
int Smallest_non_Prime ( Vector < Integer > StorePrimes , int N ) { int x = StorePrimes . get ( N ) ; return x * x ; }
int countNestedPolygons ( int sides ) { int count = 0 ; while ( sides > 5 ) { sides /= 2 ; count += 1 ; } return count ; }
int smallestCommon ( int a , int b , int c , int d ) { if ( a == c ) return a ; if ( a > c ) { swap ( a , c ) ; swap ( b , d ) ; } int first_term_diff = ( c - a ) ; int possible_y ; for ( possible_y = 0 ; possible_y < b ; possible_y ++ ) { if ( ( first_term_diff % b + possible_y * d ) % b == 0 ) { break ; } } if ( possible_y != b ) { return c + possible_y * d ; } return - 1 ; }
int isprm ( int n ) { if ( n <= 1 ) return 0 ; if ( n <= 3 ) return 1 ; if ( n % 2 == 0 n % 3 == 0 ) return 0 ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return 0 ; return 1 ; }
int NumberOfTrees ( int arr [ ] , int N ) { int maxElement = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int level [ ] = new int [ maxElement + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { level [ arr [ i ] ] ++ ; } if ( arr [ 0 ] != 0 level [ 0 ] != 1 ) { return 0 ; } int ans = 1 ; for ( int i = 0 ; i < maxElement ; i ++ ) { for ( int j = 0 ; j < level [ i + 1 ] ; j ++ ) { ans = ( ans * level [ i ] ) % mod ; } } return ans ; }
int power ( int x , int y ) { if ( y == 0 ) return 1 ; int p = power ( x , y / 2 ) % mod ; p = ( p * p ) % mod ; if ( ( y & 1 ) != 0 ) p = ( x * p ) % mod ; return p ; }
int NumberOfTrees ( int arr [ ] , int N ) { int maxElement = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int [ ] level = new int [ maxElement + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { level [ arr [ i ] ] ++ ; } if ( arr [ 0 ] != 0 level [ 0 ] != 1 ) { return 0 ; } int ans = 1 ; for ( int i = 0 ; i < maxElement ; i ++ ) { ans = ( ans * power ( level [ i ] , level [ i + 1 ] ) ) % mod ; } return ans ; }
int carryCount ( int num1 , int num2 ) { int count = 0 ; while ( num2 != 0 ) { int carry = num1 & num2 ; num1 = num1 ^ num2 ; num2 = carry << 1 ; count += Integer . bitCount ( num2 ) ; } return count ; }
int power ( int X , int Y , int Mod ) { if ( Y == 0 ) return 1 ; int p = power ( X , Y / 2 , Mod ) % Mod ; p = ( p * p ) % Mod ; if ( ( Y & 1 ) != 0 ) { p = ( X * p ) % Mod ; } return p ; }
int Inversefactorial ( int N ) { if ( N <= 0 ) return 1 ; int fact = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = ( fact * i ) % Mod ; } return power ( fact , Mod - 2 , Mod ) ; }
int nck ( int N , int K ) { int factN = factorial ( N ) ; int inv = Inversefactorial ( K ) ; int invFact = Inversefactorial ( N - K ) ; return ( ( ( factN * inv ) % Mod ) * invFact ) % Mod ; }
boolean checkEvenSum ( int arr [ ] , int N , int size ) { int even_freq = 0 , odd_freq = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd_freq ++ ; else even_freq ++ ; } if ( even_freq >= N ) return true ; else { if ( odd_freq % 2 == 1 ) { int taken = odd_freq - 1 ; int req = N - taken ; if ( even_freq < req ) { return false ; } else return true ; } else { int taken = odd_freq ; int req = N - taken ; if ( even_freq < req ) { return false ; } else return true ; } } }
int digitsOf ( int num ) { return Integer . toString ( num ) . length ( ) ; }
int count ( int a , int tn ) { int diff = ( int ) Math . pow ( 10 , digitsOf ( a ) ) ; return ( ( tn - a ) / diff ) + 1 ; }
int countOfSubarray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) arr [ i ] -- ; int [ ] pref = new int [ N ] ; pref [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) pref [ i ] = pref [ i - 1 ] + arr [ i ] ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int answer = 0 ; mp . put ( 0 , 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . containsKey ( pref [ i ] ) ) { answer += mp . get ( pref [ i ] ) ; mp . put ( pref [ i ] , mp . get ( pref [ i ] ) + 1 ) ; } else { mp . put ( pref [ i ] , 1 ) ; } } return answer ; }
int minOperations ( int a [ ] , int N ) { int num_of_ops1 , num_of_ops2 , sum ; num_of_ops1 = num_of_ops2 = sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( i % 2 == 0 && sum >= 0 ) { num_of_ops1 += ( 1 + Math . abs ( sum ) ) ; sum = - 1 ; } else if ( i % 2 == 1 && sum <= 0 ) { num_of_ops1 += ( 1 + Math . abs ( sum ) ) ; sum = 1 ; } } sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( i % 2 == 1 && sum >= 0 ) { num_of_ops2 += ( 1 + Math . abs ( sum ) ) ; sum = - 1 ; } else if ( i % 2 == 0 && sum <= 0 ) { num_of_ops2 += ( 1 + Math . abs ( sum ) ) ; sum = 1 ; } } return Math . min ( num_of_ops1 , num_of_ops2 ) ; }
void printSubset ( long n , int k ) { ArrayList < Long > answer = new ArrayList < > ( ) ; while ( n > 0 ) { long p = ( long ) ( Math . log ( n ) / Math . log ( 2 ) ) ; ; answer . add ( ( long ) ( Math . pow ( k , p ) ) ) ; n %= ( int ) Math . pow ( 2 , p ) ; } Collections . sort ( answer ) ; for ( Long x : answer ) { System . out . print ( x + " " ) ; } }
void printsubset ( int n , int k ) { int count = 0 , x = 0 ; ArrayList < Integer > vec = new ArrayList < > ( ) ; while ( n != 0 ) { x = n & 1 ; if ( x != 0 ) { vec . add ( ( int ) Math . pow ( k , count ) ) ; } n = n >> 1 ; count ++ ; } for ( int i = 0 ; i < vec . size ( ) ; i ++ ) System . out . print ( vec . get ( i ) + " " ) ; }
boolean checkEquall ( int arr [ ] , int N ) { int sumEven = 0 , sumOdd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 1 ) sumOdd += arr [ i ] ; else sumEven += arr [ i ] ; } if ( sumEven == sumOdd ) return true ; else return false ; }
boolean isSumOfPower ( int n ) { boolean [ ] isSum = new boolean [ n + 1 ] ; Vector < Integer > perfectPowers = new Vector < Integer > ( ) ; perfectPowers . add ( 1 ) ; for ( int i = 0 ; i < ( n + 1 ) ; i ++ ) { isSum [ i ] = false ; } for ( int i = 2 ; i < ( n + 1 ) ; i ++ ) { if ( isSum [ i ] == true ) { perfectPowers . add ( i ) ; continue ; } for ( int j = i * i ; j > 0 && j < ( n + 1 ) ; j *= i ) { isSum [ j ] = true ; } } for ( int i = 0 ; i < perfectPowers . size ( ) ; i ++ ) { isSum [ perfectPowers . get ( i ) ] = false ; } for ( int i = 0 ; i < perfectPowers . size ( ) ; i ++ ) { for ( int j = i ; j < perfectPowers . size ( ) ; j ++ ) { int sum = perfectPowers . get ( i ) + perfectPowers . get ( j ) ; if ( sum < ( n + 1 ) ) isSum [ sum ] = true ; } } return isSum [ n ] ; }
void countEvenSum ( int low , int high , int k ) { int even_count = high / 2 - ( low - 1 ) / 2 ; int odd_count = ( high + 1 ) / 2 - low / 2 ; long even_sum = 1 ; long odd_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { long prev_even = even_sum ; long prev_odd = odd_sum ; even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ; odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; } System . out . println ( even_sum ) ; }
void update ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] += ( i + 1 ) ; } }
void incrementCount ( int arr [ ] , int N ) { int min = 0 ; while ( check ( arr , N ) != true ) { update ( arr , N ) ; min ++ ; } System . out . println ( min ) ; }
void incrementCount ( int arr [ ] , int N ) { int mini = arr [ 0 ] - arr [ 1 ] ; for ( int i = 2 ; i < N ; i ++ ) { mini = Math . min ( mini , arr [ i - 1 ] - arr [ i ] ) ; } System . out . println ( mini ) ; }
double [ ] Length_Diagonals ( int a , double theta ) { double p = a * Math . sqrt ( 2 + ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; double q = a * Math . sqrt ( 2 - ( 2 * Math . cos ( theta * ( Math . PI / 180 ) ) ) ) ; return new double [ ] { p , q } ; }
int solve ( String s , int x , int y ) { int res = 0 ; for ( char c : s . toCharArray ( ) ) { if ( c - '0' == x ) { res ++ ; x = x + y ; y = x - y ; x = x - y ; } } if ( x != y && res % 2 == 1 ) -- res ; return res ; }
int find_min ( String s ) { int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { count = Math . max ( count , solve ( s , i , j ) ) ; } } return count ; }
int maxORminusXOR ( int N ) { int MSB = ( int ) Math . ceil ( Math . log ( N ) ) ; int M = 0 ; for ( int i = 0 ; i <= MSB ; i ++ ) M += ( 1 << i ) ; return M ; }
int No_of_Triangle ( int N , int K ) { if ( N < K ) return - 1 ; else { int Tri_up = 0 ; Tri_up = ( ( N - K + 1 ) * ( N - K + 2 ) ) / 2 ; int Tri_down = 0 ; Tri_down = ( ( N - 2 * K + 1 ) * ( N - 2 * K + 2 ) ) / 2 ; return Tri_up + Tri_down ; } }
void AddEdge ( int u , int v ) { adj [ u ] . add ( v ) ; adj [ v ] . add ( u ) ; }
void Matching_dfs ( int u , int p ) { for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) { if ( adj [ u ] . get ( i ) != p ) { Matching_dfs ( adj [ u ] . get ( i ) , u ) ; } } if ( used [ u ] == 0 && used [ p ] == 0 && p != 0 ) { max_matching ++ ; used [ u ] = used [ p ] = 1 ; } }
boolean canMake ( int n , int ar [ ] ) { if ( n == 1 ) return true ; else { if ( ar [ 0 ] < ar [ 1 ] ) { int i = 1 ; while ( i < n && ar [ i - 1 ] < ar [ i ] ) { i ++ ; } while ( i + 1 < n && ar [ i ] > ar [ i + 1 ] ) { i ++ ; } if ( i >= n - 1 ) return true ; else return false ; } else if ( ar [ 0 ] > ar [ 1 ] ) { int i = 1 ; while ( i < n && ar [ i - 1 ] > ar [ i ] ) { i ++ ; } while ( i + 1 < n && ar [ i ] < ar [ i + 1 ] ) { i ++ ; } if ( i >= n - 1 ) return true ; else return false ; } else { for ( int i = 2 ; i < n ; i ++ ) { if ( ar [ i - 1 ] <= ar [ i ] ) return false ; } return true ; } } }
int check_length ( int n ) { int ans = 0 ; while ( n != 0 ) { n = n >> 1 ; ans ++ ; } return ans ; }
boolean check_ith_bit ( int n , int i ) { return ( n & ( 1 << ( i - 1 ) ) ) != 0 ? true : false ; }
void findPair ( int A , int B , int N ) { int X , Y ; X = N - B + A ; if ( X % 2 != 0 ) { System . out . print ( "-1" ) ; } else { X = X / 2 ; Y = N - X ; System . out . print ( X + " " + Y ) ; } }
int countSetBitsUtil ( int x ) { if ( x <= 0 ) return 0 ; return ( ( x % 2 == 0 ? 0 : 1 ) + countSetBitsUtil ( x / 2 ) ) ; }
int countSetBits ( int L , int R ) { int bitCount = 0 ; for ( int i = L ; i <= R ; i ++ ) { bitCount += countSetBitsUtil ( i ) ; } return bitCount ; }
int countSetBit ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { boolean k = true ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { ans += k == true ? 0 : 1 ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
int countSetBits ( int L , int R ) { return Math . abs ( countSetBit ( R ) - countSetBit ( L - 1 ) ) ; }
int countSetBits ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { int n = i ; while ( n > 0 ) { count += ( n & 1 ) ; n = n >> 1 ; } } return count ; }
void countElement ( int A [ ] , int N , int B [ ] , int M , int K ) { int cnt = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int currentElement = B [ i ] ; for ( int j = 0 ; j < N ; j ++ ) { int diff = Math . abs ( currentElement - A [ j ] ) ; if ( diff <= K ) { cnt ++ ; break ; } } } System . out . print ( cnt ) ; }
double AreaofRectangle ( int L , int W ) { double area = ( W + L ) * ( W + L ) / 2 ; return area ; }
int downToZero ( int n ) { if ( n <= 3 ) return n ; int [ ] dp = new int [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; int sqr ; for ( int i = 4 ; i <= n ; i ++ ) { sqr = ( int ) Math . sqrt ( i ) ; int best = Integer . MAX_VALUE ; while ( sqr > 1 ) { if ( i % sqr == 0 ) { best = Math . min ( best , 1 + dp [ sqr ] ) ; } sqr -- ; } best = Math . min ( best , 1 + dp [ i - 1 ] ) ; dp [ i ] = best ; } return dp [ n ] ; }
int downToZero ( int n ) { if ( n <= 3 ) return n ; return n % 2 == 0 ? 3 : 4 ; }
int maxSubset ( int [ ] A , boolean flag ) { int n = A . length ; int sum = 0 ; if ( flag ) { for ( int i = 1 ; i < n ; i ++ ) A [ i ] = - A [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] > 0 ) { sum += A [ i ] ; } } return sum ; }
int findBest ( int [ ] A ) { int x = maxSubset ( A , false ) ; int y = maxSubset ( A , true ) ; y = - y ; y += A [ 0 ] ; y = - y ; return Math . max ( x , y ) ; }
int getMinCost ( int [ ] A , int [ ] B , int N ) { int mini = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { mini = Math . min ( mini , Math . min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; }
int countSwaps ( int A [ ] , int n ) { Arrays . sort ( A ) ; int ind = 1 , res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( ind < n && A [ ind ] == A [ i ] ) ind ++ ; if ( ind < n && A [ ind ] > A [ i ] ) { res ++ ; ind ++ ; } if ( ind >= n ) break ; } return res ; }
int countSwaps ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int max_frequency = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } max_frequency = Math . max ( max_frequency , mp . get ( arr [ i ] ) ) ; } return n - max_frequency ; }
int min_operation ( int a [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 ) ans += Math . abs ( a [ i ] - a [ i - 1 ] ) ; else ans += Math . abs ( a [ i ] ) ; } return ans ; }
int minimumrequired ( int A [ ] , int N ) { int K = N ; int ans = 0 ; while ( K > 0 ) { if ( K % 2 == 1 ) { ans = K ; break ; } int ispalindrome = 1 ; for ( int i = 0 ; i < K / 2 ; i ++ ) { if ( A [ i ] != A [ K - 1 - i ] ) ispalindrome = 0 ; } if ( ispalindrome == 1 ) { ans = K / 2 ; K /= 2 ; } else { ans = K ; break ; } } return ans ; }
void count ( int n , int k ) { long count = ( long ) ( Math . pow ( 10 , k ) - Math . pow ( 10 , k - 1 ) ) ; System . out . print ( count ) ; }
int maxSelections ( int A [ ] , int n , int k ) { Arrays . sort ( A ) ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + A [ i ] ; if ( sum > k ) { break ; } count ++ ; } return count ; }
int getMaxDifference ( int N ) { int M = - 1 ; int maxDiff = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int diff = ( N ^ i ) - ( N & i ) ; if ( diff >= maxDiff ) { maxDiff = diff ; M = i ; } } return M ; }
int findM ( int N ) { int M = 0 ; int MSB = ( int ) Math . log ( N ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ( N & ( 1 << i ) ) == 0 ) M += ( 1 << i ) ; } return M ; }
int func ( int N , int P ) { int sumUptoN = ( N * ( N + 1 ) / 2 ) ; int sumOfMultiplesOfP ; if ( N < P ) { return sumUptoN ; } else if ( ( N / P ) == 1 ) { return sumUptoN - P + 1 ; } sumOfMultiplesOfP = ( ( N / P ) * ( 2 * P + ( N / P - 1 ) * P ) ) / 2 ; return ( sumUptoN + func ( N / P , P ) - sumOfMultiplesOfP ) ; }
long countStrings ( long A , long B , long K ) { long X = ( A + B ) / ( K + 1 ) ; return ( Math . min ( A , Math . min ( B , X ) ) * ( K + 1 ) ) ; }
int countPairs ( int [ ] a , int n , int k ) { int [ ] len = new int [ n ] ; int [ ] p = new int [ 11 ] ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= 10 ; i ++ ) { p [ i ] = ( p [ i - 1 ] * 10 ) % k ; } for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; while ( x > 0 ) { len [ i ] ++ ; x /= 10 ; } rem [ len [ i ] ] [ a [ i ] % k ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= 10 ; j ++ ) { int r = ( a [ i ] * p [ j ] ) % k ; int xr = ( k - r ) % k ; ans += rem [ j ] [ xr ] ; if ( len [ i ] == j && ( r + a [ i ] % k ) % k == 0 ) ans -- ; } } return ans ; }
boolean isDivisible ( int N ) { return ( N - 1 ) % 3 != 0 ; }
void maxLengthSubArray ( int A [ ] , int N ) { int forward [ ] = new int [ N ] ; int backward [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 A [ i ] != A [ i - 1 ] ) { forward [ i ] = 1 ; } else forward [ i ] = forward [ i - 1 ] + 1 ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 A [ i ] != A [ i + 1 ] ) { backward [ i ] = 1 ; } else backward [ i ] = backward [ i + 1 ] + 1 ; } int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) ans = Math . max ( ans , Math . min ( forward [ i ] , backward [ i + 1 ] ) * 2 ) ; } System . out . println ( ans ) ; }
int countDigitSum ( int N , int K ) { int l = ( int ) Math . pow ( 10 , N - 1 ) , r = ( int ) Math . pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; int digits [ ] = new int [ N ] ; for ( int j = N - 1 ; j >= 0 ; j -- ) { digits [ j ] = num % 10 ; num /= 10 ; } int sum = 0 , flag = 0 ; for ( int j = 0 ; j < K ; j ++ ) sum += digits [ j ] ; for ( int j = 1 ; j < N - K + 1 ; j ++ ) { int curr_sum = 0 ; for ( int m = j ; m < j + K ; m ++ ) { curr_sum += digits [ m ] ; } if ( sum != curr_sum ) { flag = 1 ; break ; } } if ( flag == 0 ) { count ++ ; } } return count ; }
int countDigitSum ( int N , int K ) { int l = ( int ) Math . pow ( 10 , N - 1 ) , r = ( int ) Math . pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; int digits [ ] = new int [ N ] ; for ( int j = N - 1 ; j >= 0 ; j -- ) { digits [ j ] = num % 10 ; num /= 10 ; } int sum = 0 , flag = 0 ; for ( int j = 0 ; j < K ; j ++ ) sum += digits [ j ] ; for ( int j = K ; j < N ; j ++ ) { if ( sum - digits [ j - K ] + digits [ j ] != sum ) { flag = 1 ; break ; } } if ( flag == 0 ) { count ++ ; } } return count ; }
int nth_angle ( int N , int a , int b , int n ) { int nth = 0 ; nth = a + ( n - 1 ) * b ; return nth ; }
boolean findTriplet ( int [ ] arr ) { int n = arr . length ; Stack < Integer > st = new Stack < > ( ) ; int h3 = Integer . MIN_VALUE ; int h1 = Integer . MAX_VALUE ; for ( int i = n - 1 ; i >= 0 ; i -- ) { h1 = arr [ i ] ; while ( ! st . empty ( ) && st . peek ( ) < arr [ i ] ) { h3 = st . peek ( ) ; st . pop ( ) ; } st . push ( arr [ i ] ) ; if ( h1 < h3 ) { return true ; } } return false ; }
void findWays ( ArrayList < Integer > arr , int i , int n ) { if ( n == 0 ) printVector ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . add ( j ) ; findWays ( arr , j , n - j ) ; arr . remove ( arr . size ( ) - 1 ) ; } }
int distinctNumbers ( int arr [ ] , int m , int n ) { Map < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) count . put ( arr [ i ] , count . getOrDefault ( arr [ i ] , 0 ) + 1 ) ; int [ ] fre_arr = new int [ n + 1 ] ; for ( Integer it : count . values ( ) ) { fre_arr [ it ] ++ ; } int ans = count . size ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { int temp = fre_arr [ i ] ; if ( temp == 0 ) continue ; int t = Math . min ( temp , m / i ) ; ans -= t ; m -= i * t ; } return ans ; }
void no_of_moves ( int [ ] [ ] Matrix , int x , int y ) { int moves = 0 ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( Matrix [ i ] [ j ] != 0 ) { moves += Math . abs ( x - i ) ; moves += Math . abs ( y - j ) ; } } } System . out . println ( moves ) ; }
boolean is_linear ( String s ) { int tmp = 0 ; char first = s . charAt ( 0 ) ; for ( int pos = 0 ; pos < s . length ( ) ; pos += tmp ) { if ( s . charAt ( pos ) != first ) { return false ; } tmp ++ ; } return true ; }
void DFS ( int U , int [ ] vis , ArrayList < ArrayList < Integer > > adj ) { vis [ U ] = 1 ; for ( Integer V : adj . get ( U ) ) { if ( vis [ V ] == 0 ) DFS ( V , vis , adj ) ; } }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int find_gcd ( Vector < Integer > arr ) { if ( arr . size ( ) == 1 ) return arr . get ( 0 ) ; int g = arr . get ( 0 ) ; for ( int i = 1 ; i < arr . size ( ) ; i ++ ) { g = gcd ( g , arr . get ( 1 ) ) ; } return g ; }
void maxm_gcd ( Node root , Vector < Integer > ans ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) { ans . add ( root . val ) ; maxm = Math . max ( find_gcd ( ans ) , maxm ) ; return ; } ans . add ( root . val ) ; maxm_gcd ( root . left , ans ) ; maxm_gcd ( root . right , ans ) ; }
void checkInfinite ( String s ) { boolean flag = true ; int N = s . length ( ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( s . charAt ( i ) == ( char ) ( ( int ) ( s . charAt ( i + 1 ) ) + 1 ) ) { continue ; } else if ( s . charAt ( i ) == 'a' && s . charAt ( i + 1 ) == 'z' ) { continue ; } else { flag = false ; break ; } } if ( ! flag ) System . out . print ( "NO" ) ; else System . out . print ( "YES" ) ; }
int calculateWays ( int arr1 [ ] , int arr2 [ ] , int N ) { int A = arr2 [ 0 ] , B = arr2 [ 1 ] ; int C = arr2 [ 2 ] , D = arr2 [ 3 ] ; int ans = 0 ; for ( int b = 0 ; b <= B && b * 5 <= ( N ) ; b ++ ) for ( int c = 0 ; c <= C && b * 5 + c * 10 <= ( N ) ; c ++ ) for ( int d = 0 ; d <= D && b * 5 + c * 10 + d * 20 <= ( N ) ; d ++ ) if ( ( b * 5 ) + ( c * 10 ) + ( d * 20 ) >= ( N - A ) ) ans ++ ; return ans ; }
int calculateWays ( int arr1 [ ] , int arr2 [ ] , int N ) { int A = arr2 [ 0 ] , B = arr2 [ 1 ] ; int C = arr2 [ 2 ] , D = arr2 [ 3 ] ; int ans = 0 ; for ( int b = 0 ; b <= B && b * 5 <= N ; b ++ ) { for ( int a = 0 ; a <= A && a * 1 + b * 5 <= N ; a ++ ) { ways [ a + b * 5 ] ++ ; } } for ( int c = 0 ; c <= C && c * 10 <= ( N ) ; c ++ ) { for ( int d = 0 ; d <= D && c * 10 + d * 20 <= ( N ) ; d ++ ) { ans += ways [ N - c * 10 - d * 20 ] ; } } return ans ; }
void removeAll ( int arr [ ] , int n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) System . out . print ( "YES" ) ; else System . out . print ( "NO" ) ; }
void minNum ( int n ) { if ( n < 3 ) System . out . println ( - 1 ) ; else System . out . println ( 210 * ( ( int ) ( Math . pow ( 10 , n - 1 ) / 210 ) + 1 ) ) ; }
void findMinimum ( String s ) { int n = s . length ( ) ; int [ ] x = new int [ n + 1 ] ; StringBuilder s2 = new StringBuilder ( s ) ; s2 . reverse ( ) ; String s3 = s2 . toString ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s3 . charAt ( i ) == '1' ) { if ( x [ i ] == 1 ) { x [ i + 1 ] = 1 ; x [ i ] = 0 ; } else if ( 1 <= i && ( i & x [ i - 1 ] ) == 1 ) { x [ i + 1 ] = 1 ; x [ i - 1 ] = - 1 ; } else x [ i ] = 1 ; } } int c = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( x [ i ] != 0 ) c ++ ; } System . out . println ( c ) ; }
void splitIntoFibonacci ( String S ) { ArrayList < Long > seq = new ArrayList < > ( ) ; splitIntoFibonacciHelper ( 0 , S , seq ) ; if ( seq . size ( ) >= 3 ) { for ( int i = 0 ; i < seq . size ( ) ; i ++ ) System . out . print ( seq . get ( i ) + " " ) ; } else { System . out . print ( "-1" ) ; } }
int countChanges ( int matrix [ ] [ ] , int n , int m ) { int dist = n + m - 1 ; int [ ] [ ] freq = new int [ dist ] [ 10 ] ; for ( int i = 0 ; i < dist ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) freq [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { freq [ i + j ] [ matrix [ i ] [ j ] ] ++ ; } } int min_changes_sum = 0 ; for ( int i = 0 ; i < dist / 2 ; i ++ ) { int maximum = 0 ; int total_values = 0 ; for ( int j = 0 ; j < 10 ; j ++ ) { maximum = Math . max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; } min_changes_sum += ( total_values - maximum ) ; } return min_changes_sum ; }
int numberOfPairs ( int n ) { if ( n % 2 == 0 ) return n / 2 - 1 ; else return n / 2 ; }
int good_pair ( String str [ ] , int N ) { int countStr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { String res = str [ i ] + str [ j ] ; int vowel [ ] = new int [ 5 ] ; for ( int k = 0 ; k < res . length ( ) ; k ++ ) { if ( res . charAt ( k ) == 'a' ) vowel [ 0 ] = 1 ; else if ( res . charAt ( k ) == 'e' ) vowel [ 1 ] = 1 ; else if ( res . charAt ( k ) == 'i' ) vowel [ 2 ] = 1 ; else if ( res . charAt ( k ) == 'o' ) vowel [ 3 ] = 1 ; else if ( res . charAt ( k ) == 'u' ) vowel [ 4 ] = 1 ; } int temp = 0 ; for ( int ind = 0 ; ind < 5 ; ind ++ ) { if ( vowel [ ind ] == 1 ) temp ++ ; } if ( temp == 5 ) countStr ++ ; } } return countStr ; }
void sieveOfEratosthenes ( int N , int s [ ] ) { boolean [ ] prime = new boolean [ N + 1 ] ; for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= N ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } }
int generatePrimeFactors ( int N ) { int [ ] s = new int [ N + 1 ] ; int sum = 0 ; sieveOfEratosthenes ( N , s ) ; int curr = s [ N ] ; int cnt = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( curr == s [ N ] ) { cnt ++ ; continue ; } sum = sum + cnt ; curr = s [ N ] ; cnt = 1 ; } return sum ; }
int LCM ( int a , int b ) { int lcm = a > b ? a : b ; while ( true ) { if ( lcm % a == 0 && lcm % b == 0 ) break ; else lcm ++ ; } return lcm ; }
int countSubstrings ( String s ) { int n = s . length ( ) ; int answer = ( n * ( n - 1 ) ) / 2 ; int cnt = 1 ; Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) cnt ++ ; else { v . add ( cnt ) ; cnt = 1 ; } } if ( cnt > 0 ) v . add ( cnt ) ; for ( int i = 0 ; i < v . size ( ) - 1 ; i ++ ) { answer -= ( v . get ( i ) + v . get ( i + 1 ) - 1 ) ; } return answer ; }
int find_max ( int n , int k ) { int [ ] X = new int [ 32 ] ; int cnt = 0 ; for ( int i = 31 ; i >= 0 && cnt != k ; i -- ) { if ( ( n & ( 1 << i ) ) != 0 ) { X [ i ] = 1 ; cnt ++ ; } } String s = "" ; for ( int i = 31 ; i >= 0 ; i -- ) s += X [ i ] == 0 ? '0' : '1' ; return Integer . parseInt ( s , 2 ) ; }
int get_palindrome_time ( String str ) { int hh , mm ; hh = ( str . charAt ( 0 ) - 48 ) * 10 + ( str . charAt ( 1 ) - 48 ) ; mm = ( str . charAt ( 3 ) - 48 ) * 10 + ( str . charAt ( 4 ) - 48 ) ; int requiredTime = 0 ; while ( hh % 10 != mm / 10 hh / 10 != mm % 10 ) { ++ mm ; if ( mm == 60 ) { mm = 0 ; ++ hh ; } if ( hh == 24 ) hh = 0 ; ++ requiredTime ; } return requiredTime ; }
int maximumSubarraySum ( int a [ ] , int n , ArrayList < List < Integer > > subarrays ) { int i , maxsum = 0 ; int [ ] prefixArray = new int [ n ] ; for ( i = 0 ; i < subarrays . size ( ) ; ++ i ) { prefixArray [ subarrays . get ( i ) . get ( 0 ) - 1 ] ++ ; prefixArray [ subarrays . get ( i ) . get ( 1 ) ] -- ; } for ( i = 1 ; i < n ; i ++ ) { prefixArray [ i ] += prefixArray [ i - 1 ] ; } Arrays . sort ( prefixArray ) ; Arrays . sort ( a ) ; for ( i = 0 ; i < n ; i ++ ) maxsum += a [ i ] * prefixArray [ i ] ; return maxsum ; }
int maxProfit ( int [ ] value , int N , int K ) { Arrays . sort ( value ) ; int maxval = value [ N - 1 ] ; int maxProfit = 0 ; int curr_val ; do { curr_val = 0 ; for ( int i = 0 ; i < N ; i ++ ) { curr_val += value [ i ] ; if ( curr_val <= K ) { maxProfit = Math . max ( curr_val + maxval * ( i + 1 ) , maxProfit ) ; } } } while ( next_permutation ( value ) ) ; return maxProfit ; }
int findways ( String s , int x ) { if ( x > s . length ( ) ) return 0 ; int n = s . length ( ) ; int [ ] freq = new int [ 26 ] ; Arrays . fill ( freq , 0 ) ; for ( int i = 0 ; i < n ; ++ i ) freq [ s . charAt ( i ) - 'a' ] ++ ; multiset < int > se ; Set < Integer > se = new HashSet < > ( ) ; for ( int i = 0 ; i < 26 ; ++ i ) if ( freq [ i ] > 0 ) se . add ( freq [ i ] ) ; int ans = 1 ; for ( int i = 0 ; i < x / 2 ; ++ i ) { int count = 0 ; for ( int u : se ) { if ( u >= 2 ) count ++ ; } if ( count == 0 ) return 0 ; else ans = ans * count ; int p = ( int ) se . toArray ( ) [ se . size ( ) - 1 ] ; int val = p ; se . remove ( p ) ; if ( val > 2 ) se . add ( val - 2 ) ; } if ( x % 2 != 0 ) { int count = 0 ; for ( int u : se ) if ( u > 0 ) count ++ ; ans = ans * count ; } return ans ; }
boolean checkUniqueFrequency ( int arr [ ] , int n ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . containsKey ( arr [ i ] ) ) { freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . put ( arr [ i ] , 1 ) ; } } HashSet < Integer > uniqueFreq = new HashSet < Integer > ( ) ; for ( Map . Entry < Integer , Integer > i : freq . entrySet ( ) ) { if ( uniqueFreq . contains ( i . getValue ( ) ) ) return false ; else uniqueFreq . add ( i . getValue ( ) ) ; } return true ; }
double specialSum ( int n ) { double sum = n * ( n + 1 ) / 2 ; int a = log2 ( n ) ; sum = sum + power ( 2 , a + 1 ) - 1 ; return sum ; }
String findMin ( int x , int Y ) { String y = Integer . toString ( Y ) ; int n = y . length ( ) ; ArrayList p = new ArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { p . add ( 0 ) ; } for ( int i = 0 ; i < n ; i ++ ) { p . add ( i , ( int ) ( ( int ) y . charAt ( i ) - ( int ) '0' ) ) ; if ( i > 0 ) { p . add ( i , ( int ) p . get ( i ) + ( int ) p . get ( i - 1 ) ) ; } } for ( int i = n - 1 , k = 0 ; ; i -- , k ++ ) { int d = 0 ; if ( i >= 0 ) { d = ( int ) y . charAt ( i ) - ( int ) '0' ; } for ( int j = d + 1 ; j <= 9 ; j ++ ) { int r = j ; if ( i > 0 ) { r += ( int ) p . get ( i - 1 ) ; } if ( x - r >= 0 && x - r <= 9 * k ) { String suf = helper ( k , x - r ) ; String pre = "" ; if ( i > 0 ) pre = y . substring ( 0 , i ) ; char cur = ( char ) ( j + ( int ) '0' ) ; pre += cur ; return pre + suf ; } } } }
void largestNumber ( int n , int X , int Y ) { int maxm = Math . max ( X , Y ) ; Y = X + Y - maxm ; X = maxm ; int Xs = 0 ; int Ys = 0 ; while ( n > 0 ) { if ( n % Y == 0 ) { Xs += n ; n = 0 ; } else { n -= X ; Ys += X ; } } if ( n == 0 ) { while ( Xs -- > 0 ) System . out . print ( X ) ; while ( Ys -- > 0 ) System . out . print ( Y ) ; } else System . out . print ( "-1" ) ; }
int check ( int unit_digit , int X ) { int times , digit ; for ( times = 1 ; times <= 10 ; times ++ ) { digit = ( X * times ) % 10 ; if ( digit == unit_digit ) return times ; } return - 1 ; }
int getNum ( int N , int X ) { int unit_digit ; unit_digit = N % 10 ; int times = check ( unit_digit , X ) ; if ( times == - 1 ) return times ; else { if ( N >= ( times * X ) ) return times ; else return - 1 ; } }
boolean dfs ( Vector < Integer > [ ] g , int [ ] cost , int u , int pre ) { vis [ u ] = true ; dp [ u ] = cost [ u ] ; boolean check = true ; int cur = cost [ u ] ; for ( int x : g [ u ] ) { if ( vis [ x ] && x != pre ) { check = false ; } else if ( ! vis [ x ] ) { check = dfs ( g , cost , x , u ) ? false : true ; cur = Math . max ( cur , cost [ u ] + dp [ x ] ) ; } } dp [ u ] = cur ; if ( ! check ) { canTake += cost [ u ] ; } else { best = Math . max ( best , dp [ u ] ) ; } return check ; }
void FindMaxCost ( Vector < Integer > [ ] g , int [ ] cost , int source ) { dfs ( g , cost , source , - 1 ) ; System . out . print ( canTake + best ) ; }
int after_rev ( Vector < Integer > v ) { int mini = 0 , count = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { count += v . get ( i ) ; if ( count > 0 ) count = 0 ; if ( mini > count ) mini = count ; } return mini ; }
int moduloEquality ( int A [ ] , int B [ ] , int n , int m ) { HashMap < Integer , Integer > mapA = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > mapB = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mapA . containsKey ( A [ i ] ) ) { mapA . put ( A [ i ] , mapA . get ( A [ i ] ) + 1 ) ; } else { mapA . put ( A [ i ] , 1 ) ; } if ( mapB . containsKey ( B [ i ] ) ) { mapB . put ( B [ i ] , mapB . get ( B [ i ] ) + 1 ) ; } else { mapB . put ( B [ i ] , 1 ) ; } } HashSet < Integer > possibleValues = new HashSet < Integer > ( ) ; int FirstElement = B [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { int cur = A [ i ] ; possibleValues . add ( cur > FirstElement ? m - cur + FirstElement : FirstElement - cur ) ; } int ans = Integer . MAX_VALUE ; for ( int it : possibleValues ) { boolean possible = true ; for ( Map . Entry < Integer , Integer > it2 : mapA . entrySet ( ) ) { if ( it2 . getValue ( ) != mapB . get ( ( it2 . getKey ( ) + it ) % m ) ) { possible = false ; break ; } } if ( possible ) { ans = Math . min ( ans , it ) ; } } return ans ; }
int countCyclicShifts ( String S , int n ) { int [ ] aux = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { if ( S . charAt ( i ) == '(' ) aux [ i ] = 1 ; else aux [ i ] = - 1 ; } int mn = aux [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { aux [ i ] += aux [ i - 1 ] ; mn = Math . min ( mn , aux [ i ] ) ; } if ( aux [ n - 1 ] != 0 ) return 0 ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( aux [ i ] == mn ) count ++ ; } return count ; }
int count ( int k , String s ) { int ar [ ] = new int [ s . length ( ) ] ; int end = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' ) { for ( int j = i ; j < s . length ( ) && j <= i + k ; j ++ ) { ar [ j ] = - 1 ; end = j ; } i = end ; } } end = 0 ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '1' ) { for ( int j = i ; j >= 0 && j >= i - k ; j -- ) { ar [ j ] = - 1 ; end = j ; } i = end ; } } int ans = 0 ; end = 0 ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( ar [ j ] == 0 ) { ans ++ ; for ( int g = j ; g <= j + k && g < s . length ( ) ; g ++ ) { ar [ g ] = - 1 ; end = g ; } j = end - 1 ; } } return ans ; }
int find_set ( int a ) { if ( parent [ a ] == a ) return a ; return parent [ a ] = find_set ( parent [ a ] ) ; }
void union_set ( int a , int b ) { int x = find_set ( a ) , y = find_set ( b ) ; if ( x == y ) return ; if ( rnk [ x ] == rnk [ y ] ) rnk [ x ] ++ ; if ( rnk [ y ] > rnk [ x ] ) swap ( x , y ) ; parent [ y ] = x ; }
void dfsBridges ( int a , int par ) { vis [ a ] = true ; in [ a ] = low [ a ] = timer ++ ; for ( int i : v [ a ] ) { if ( i == par ) continue ; if ( vis [ i ] ) low [ a ] = Math . min ( low [ a ] , in [ i ] ) ; else { dfsBridges ( i , a ) ; low [ a ] = Math . min ( low [ a ] , low [ i ] ) ; if ( in [ a ] < low [ i ] ) bridges . add ( new pair ( i , a ) ) ; else union_set ( i , a ) ; } } }
boolean isPalindrome ( int l , int r , String s ) { while ( l <= r ) { if ( s . charAt ( l ) != s . charAt ( r ) ) return false ; l ++ ; r -- ; } return true ; }
int numWays ( String s ) { int n = s . length ( ) ; int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( isPalindrome ( 0 , i , s ) && isPalindrome ( i + 1 , n - 1 , s ) ) { ans ++ ; } } return ans ; }
int maxProfit ( int [ ] prices , int n ) { int profit = 0 , currentDay = n - 1 ; while ( currentDay > 0 ) { int day = currentDay - 1 ; while ( day >= 0 && ( prices [ currentDay ] > prices [ day ] ) ) { profit += ( prices [ currentDay ] - prices [ day ] ) ; day -- ; } currentDay = day ; } return profit ; }
void numberofsubstrings ( String str , int k , char charArray [ ] ) { int N = str . length ( ) ; int available [ ] = new int [ 26 ] ; Arrays . fill ( available , 0 ) ; for ( int i = 0 ; i < k ; i ++ ) { available [ charArray [ i ] - 'a' ] = 1 ; } int lastPos = - 1 ; int ans = ( N * ( N + 1 ) ) / 2 ; for ( int i = 0 ; i < N ; i ++ ) { if ( available [ str . charAt ( i ) - 'a' ] == 0 ) { ans -= ( ( i - lastPos ) * ( N - i ) ) ; lastPos = i ; } } System . out . println ( ans ) ; }
boolean isOddStringPalindrome ( String str , int n ) { int oddStringSize = n / 2 ; boolean lengthOdd = ( ( oddStringSize % 2 == 1 ) ? true : false ) ; Stack < Character > s = new Stack < Character > ( ) ; int i = 1 ; int c = 0 ; while ( i < n && c < oddStringSize / 2 ) { s . add ( str . charAt ( i ) ) ; i += 2 ; c ++ ; } if ( lengthOdd ) i = i + 2 ; while ( i < n && s . size ( ) > 0 ) { if ( s . peek ( ) == str . charAt ( i ) ) s . pop ( ) ; else break ; i = i + 2 ; } if ( s . size ( ) == 0 ) return true ; return false ; }
boolean isOddStringPalindrome ( String str , int n ) { int left , right ; if ( n % 2 == 0 ) { left = 1 ; right = n - 1 ; } else { left = 1 ; right = n - 2 ; } while ( left < n && right >= 0 && left < right ) { if ( str . charAt ( left ) != str . charAt ( right ) ) return false ; left += 2 ; right -= 2 ; } return true ; }
void min_remove ( String str ) { int N = str . length ( ) ; int [ ] prefix_a = new int [ N + 1 ] ; int [ ] prefix_b = new int [ N + 1 ] ; int [ ] prefix_c = new int [ N + 1 ] ; prefix_a [ 0 ] = 0 ; prefix_b [ 0 ] = 0 ; prefix_c [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix_a [ i ] = prefix_a [ i - 1 ] + ( int ) ( ( str . charAt ( i - 1 ) == 'a' ) ? 1 : 0 ) ; prefix_b [ i ] = prefix_b [ i - 1 ] + ( int ) ( ( str . charAt ( i - 1 ) == 'b' ) ? 1 : 0 ) ; prefix_c [ i ] = prefix_c [ i - 1 ] + ( int ) ( ( str . charAt ( i - 1 ) == 'c' ) ? 1 : 0 ) ; } int maxi = Integer . MIN_VALUE ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = i ; j <= N ; j ++ ) { maxi = Math . max ( maxi , ( prefix_a [ i ] + ( prefix_b [ j ] - prefix_b [ i ] ) + ( prefix_c [ N ] - prefix_c [ j ] ) ) ) ; } } System . out . println ( ( N - maxi ) ) ; }
int maximum_partition ( String str ) { int i = 0 , j = 0 , k = 0 ; int c = 0 , r = 0 ; HashMap < Character , Integer > m = new HashMap < > ( ) ; for ( i = str . length ( ) - 1 ; i >= 0 ; i -- ) { if ( ! m . containsKey ( str . charAt ( i ) ) ) { m . put ( str . charAt ( i ) , i ) ; } } i = 0 ; k = m . get ( str . charAt ( i ) ) ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( i <= k ) { c = c + 1 ; k = Math . max ( k , m . get ( str . charAt ( i ) ) ) ; } else { r = r + 1 ; c = 1 ; k = Math . max ( k , m . get ( str . charAt ( i ) ) ) ; } } if ( c != 0 ) { r = r + 1 ; } return r ; }
int findAns ( int [ ] [ ] mat , int x , int y , int n , int m ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { ans += Math . abs ( x - i ) + Math . abs ( y - j ) ; } } } return ans ; }
void solve ( int P [ ] , int n ) { int arr [ ] = new int [ n + 1 ] ; arr [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) arr [ i + 1 ] = P [ i ] ; int cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == i ) { int t = arr [ i + 1 ] ; arr [ i + 1 ] = arr [ i ] ; arr [ i ] = t ; cnt ++ ; } } if ( arr [ n ] == n ) { int t = arr [ n - 1 ] ; arr [ n - 1 ] = arr [ n ] ; arr [ n ] = t ; cnt ++ ; } System . out . println ( cnt ) ; }
int longestSequence ( int n , int arr [ ] ) { int l = 0 , r = n - 1 ; int prev = Integer . MIN_VALUE ; int ans = 0 ; while ( l <= r ) { if ( arr [ l ] > prev && arr [ r ] > prev ) { if ( arr [ l ] < arr [ r ] ) { ans += 1 ; prev = arr [ l ] ; l += 1 ; } else { ans += 1 ; prev = arr [ r ] ; r -= 1 ; } } else if ( arr [ l ] > prev ) { ans += 1 ; prev = arr [ l ] ; l += 1 ; } else if ( arr [ r ] > prev ) { ans += 1 ; prev = arr [ r ] ; r -= 1 ; } else { break ; } } return ans ; }
int solve ( int n , int m , int x , int y , int d ) { int top = Math . min ( d , x - 1 ) ; int down = Math . min ( d , n - x ) ; int left = Math . min ( d , y - 1 ) ; int right = Math . min ( d , m - y ) ; int quad1 = top * left ; int quad2 = left * down ; int quad3 = down * right ; int quad4 = right * top ; int totalsq = quad1 + quad2 + quad3 + quad4 ; int singleBlocks = top + down + left + right + 1 ; return totalsq + singleBlocks ; }
int minchanges ( int [ ] [ ] mat ) { int count = 0 ; int left = 0 , right = N + M - 2 ; while ( left < right ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; int totalsize = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( i + j == left ) { mp . put ( mat [ i ] [ j ] , mp . getOrDefault ( mat [ i ] [ j ] , 0 ) + 1 ) ; totalsize ++ ; } else if ( i + j == right ) { mp . put ( mat [ i ] [ j ] , mp . getOrDefault ( mat [ i ] [ j ] , 0 ) + 1 ) ; totalsize ++ ; } } } int changes = 0 ; for ( Map . Entry < Integer , Integer > itr : mp . entrySet ( ) ) changes = Math . max ( changes , itr . getValue ( ) ) ; count += totalsize - changes ; left ++ ; right -- ; } return count ; }
int CountLongestSubarrays ( int arr [ ] , int n , int k ) { int i , s = 0 ; for ( i = 0 ; i < n ; ++ i ) { s += arr [ i ] ; } if ( ( s % k ) != 0 ) { return 1 ; } else { int ini = 0 ; while ( ini < n && arr [ ini ] % k == 0 ) { ++ ini ; } int fin = n - 1 ; while ( fin >= 0 && arr [ fin ] % k == 0 ) { -- fin ; } int len , sum = 0 , count = 0 ; if ( ini == n ) { return - 1 ; } else { len = Math . max ( n - 1 - ini , fin ) ; } for ( i = 0 ; i < len ; i ++ ) { sum += arr [ i ] ; } if ( sum % k != 0 ) { count ++ ; } for ( i = len ; i < n ; i ++ ) { sum = sum + arr [ i ] ; sum = sum - arr [ i - len ] ; if ( sum % k != 0 ) { count ++ ; } } return count ; } }
int nC3 ( int n ) { if ( n < 3 ) return 0 ; return ( n * ( n - 1 ) * ( n - 2 ) ) / 6 ; }
void count_triplet ( int [ ] arr , int N , int K ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } for ( i = 1 ; i <= 1000000 ; i ++ ) { for ( j = i ; j <= 1000000 ; j += i ) { mul [ i ] += freq [ j ] ; } cnt [ i ] = nC3 ( mul [ i ] ) ; } for ( i = 1000000 ; i >= 1 ; i -- ) { for ( j = 2 * i ; j <= 1000000 ; j += i ) { cnt [ i ] -= cnt [ j ] ; } } System . out . print ( "Number of triplets " + "with GCD " + K ) ; System . out . print ( " are " + cnt [ K ] ) ; }
int getMinJumps ( String s ) { Vector < Integer > ones = new Vector < Integer > ( ) ; int jumps = 0 , median = 0 , ind = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' ) ones . add ( i ) ; } if ( ones . size ( ) == 0 ) return jumps ; median = ( int ) ones . get ( ones . size ( ) / 2 ) ; ind = median ; for ( int i = ind ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '1' ) { jumps += ind - i ; ind -- ; } } ind = median ; for ( int i = ind ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' ) { jumps += i - ind ; ind ++ ; } } return jumps ; }
void getSubsequence ( int [ ] ar ) { int N = ar . length ; Vector < Integer > ans = new Vector < Integer > ( ) ; ans . add ( ar [ 0 ] ) ; for ( int i = 1 ; i < N - 1 ; i ++ ) { if ( ar [ i ] > ar [ i - 1 ] ) { if ( i < N - 1 && ar [ i ] <= ar [ i + 1 ] ) { continue ; } else { ans . add ( ar [ i ] ) ; } } else { if ( i < N - 1 && ar [ i + 1 ] < ar [ i ] ) { continue ; } else { ans . add ( ar [ i ] ) ; } } } ans . add ( ar [ N - 1 ] ) ; for ( int it : ans ) System . out . print ( it + " " ) ; }
boolean isSubseqPossible ( int [ ] arr , int N , int K ) { int i ; int odd = 0 , even = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 || ( even == 0 && K % 2 == 0 ) ) return false ; return true ; }
void print_path ( int N , int jump , int coin ) { if ( jump > coin || jump * ( N - 1 ) < coin ) { System . out . println ( "-1" ) ; } else { int pos = 1 ; while ( jump > 0 ) { int tmp = Math . min ( N - 1 , coin - ( jump - 1 ) ) ; if ( pos + tmp <= N ) { pos += tmp ; } else { pos -= tmp ; } System . out . print ( pos + " " ) ; ; coin -= tmp ; jump -= 1 ; } } }
void countEvenOdd ( int arr [ ] , int n , int K ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ; y = __builtin_popcount ( K ) ; if ( ( y & 1 ) != 0 ) { System . out . println ( "Even = " + odd + ", Odd = " + even ) ; } else { System . out . println ( "Even = " + even + ", Odd = " + odd ) ; } }
void findMinHike ( Vector < Integer > arr , int n ) { arr . add ( 0 , INF ) ; arr . add ( INF ) ; int [ ] hike = new int [ n + 2 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr . get ( i - 1 ) >= arr . get ( i ) && arr . get ( i ) <= arr . get ( i + 1 ) ) { hike [ i ] = 1 ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( arr . get ( i - 1 ) < arr . get ( i ) && arr . get ( i ) <= arr . get ( i + 1 ) ) { hike [ i ] = hike [ i - 1 ] + 1 ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( arr . get ( i - 1 ) >= arr . get ( i ) && arr . get ( i ) > arr . get ( i + 1 ) ) { hike [ i ] = hike [ i + 1 ] + 1 ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( arr . get ( i - 1 ) < arr . get ( i ) && arr . get ( i ) > arr . get ( i + 1 ) ) { hike [ i ] = Math . max ( hike [ i - 1 ] , hike [ i + 1 ] ) + 1 ; } } for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( hike [ i ] + " " ) ; } }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void preprocess ( ) { DFS ( 1 , - 1 ) ; }
void maximumSumSubarray ( int arr [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= 0 ) mp . put ( arr [ i ] , 1 ) ; } int first = 0 ; int last = 0 ; int ans = 0 ; int INF = ( int ) 1e6 ; for ( Map . Entry < Integer , Integer > i : mp . entrySet ( ) ) { int mx = i . getKey ( ) ; int curr = 0 ; int curr_start = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( curr == 0 ) curr_start = j ; int val = arr [ j ] > mx ? - INF : arr [ j ] ; curr += val ; if ( curr < 0 ) curr = 0 ; if ( curr > ans ) { ans = curr ; first = curr_start ; last = j ; } } } System . out . print ( ( first + 1 ) + " " + ( last + 1 ) ) ; }
int make_xor_half ( ArrayList < Integer > arr ) { int sum = 0 , xr = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { int a = arr . get ( i ) ; sum += a ; xr ^= a ; } if ( 2 * xr == sum ) return - 1 ; if ( xr == 0 ) { arr . add ( sum ) ; return 1 ; } arr . add ( xr ) ; arr . add ( sum + xr ) ; return 2 ; }
void makeZero ( int x , int y , int a , int b ) { if ( x > y ) { int temp = x ; x = y ; y = temp ; } int tot_cost = ( y - x ) * a ; int cost1 = 2 * x * a ; int cost2 = x * b ; tot_cost += Math . min ( cost1 , cost2 ) ; System . out . print ( tot_cost ) ; }
void splitFraction ( int n , int d ) { long ar [ ] = new long [ n ] ; long first = d + n - 1 ; ar [ 0 ] = first ; for ( int i = 1 ; i < n ; i ++ ) { ar [ i ] = first * ( -- first ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ar [ i ] % n == 0 ) { System . out . print ( "1/" + ar [ i ] / n + ", " ) ; } else { System . out . print ( n + "/" + ar [ i ] + ", " ) ; } } }
int numPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) ans ++ ; } } return ans ; }
int minOperations ( String s , int len ) { int operationCnt = 0 ; Stack < Character > st = new Stack < Character > ( ) ; int cntClosing = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( s . charAt ( i ) == '{' ) { if ( cntClosing > 0 ) { operationCnt ++ ; st . pop ( ) ; } st . add ( s . charAt ( i ) ) ; cntClosing = 0 ; } else if ( st . isEmpty ( ) ) { st . add ( '{' ) ; operationCnt ++ ; cntClosing = 1 ; } else { cntClosing = ( cntClosing + 1 ) % 2 ; if ( cntClosing == 0 ) { st . pop ( ) ; } } } operationCnt += st . size ( ) * 2 - cntClosing ; return operationCnt ; }
int longestSubsequence ( String s ) { int n = s . length ( ) ; int answer = 0 ; char prev = '-' ; for ( int i = 0 ; i < n ; i ++ ) { if ( prev != s . charAt ( i ) ) { prev = s . charAt ( i ) ; answer ++ ; } } return answer ; }
int calculate ( int pos , int prev , String s ) { if ( pos == s . length ( ) ) { return 0 ; } if ( dp [ pos ] [ prev ] != - 1 ) return dp [ pos ] [ prev ] ; int val = 0 ; if ( s . charAt ( pos ) - 'a' + 1 != prev ) { val = Math . max ( val , 1 + calculate ( pos + 1 , s . charAt ( pos ) - 'a' + 1 , s ) ) ; } val = Math . max ( val , calculate ( pos + 1 , prev , s ) ) ; return dp [ pos ] [ prev ] = val ; }
int longestSubsequence ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < 100005 ; i ++ ) { for ( int j = 0 ; j < 27 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return calculate ( 0 , 0 , s ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void MinDiff ( int n ) { int val = ( int ) Math . pow ( 2 , n ) ; int sep = n / 2 ; int grp1 = 0 ; int grp2 = 0 ; grp1 = grp1 + val ; for ( int i = 1 ; i < sep ; i ++ ) grp1 = grp1 + ( int ) Math . pow ( 2 , i ) ; for ( int i = sep ; i < n ; i ++ ) grp2 = grp2 + ( int ) Math . pow ( 2 , i ) ; System . out . println ( Math . abs ( grp1 - grp2 ) ) ; }
int minOccupiedPosition ( int A [ ] , int n ) { int minPos = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] > 0 ) { ++ minPos ; i += 2 ; } } return minPos ; }
int missingnumber ( int n , int arr [ ] ) { int mn = Integer . MAX_VALUE , mx = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 && arr [ i ] == - 1 && arr [ i - 1 ] != - 1 ) { mn = Math . min ( mn , arr [ i - 1 ] ) ; mx = Math . max ( mx , arr [ i - 1 ] ) ; } if ( i < ( n - 1 ) && arr [ i ] == - 1 && arr [ i + 1 ] != - 1 ) { mn = Math . min ( mn , arr [ i + 1 ] ) ; mx = Math . max ( mx , arr [ i + 1 ] ) ; } } int res = ( mx + mn ) / 2 ; return res ; }
int Minsteps ( int n ) { int ans = 0 ; while ( n > 1 ) { if ( n % 5 == 0 ) { ans ++ ; n = n / 5 ; continue ; } else if ( n % 4 == 0 ) { ans ++ ; n = n / 4 ; continue ; } else if ( n % 3 == 0 ) { ans ++ ; n = n / 3 ; continue ; } else if ( n % 2 == 0 ) { ans ++ ; n = n / 2 ; continue ; } return - 1 ; } return ans ; }
void countDist ( int arr1 [ ] , int n , int arr2 [ ] , int m , int k ) { int count = 0 ; int smallest = arr2 [ 0 ] ; int largest = arr2 [ 0 ] ; for ( int i = 0 ; i < m ; i ++ ) { smallest = Math . max ( smallest , arr2 [ i ] ) ; largest = Math . min ( largest , arr1 [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( Math . abs ( arr1 [ i ] - smallest ) > k || Math . abs ( arr1 [ i ] - largest ) > k ) count ++ ; } System . out . print ( count ) ; }
int palindromeWinner ( String S ) { int freq [ ] = new int [ 26 ] ; Arrays . fill ( freq , 0 ) ; int count = 0 ; for ( int i = 0 ; i < ( int ) S . length ( ) ; ++ i ) { if ( freq [ S . charAt ( i ) - 'a' ] == 0 ) count ++ ; freq [ S . charAt ( i ) - 'a' ] ++ ; } int unique = 0 ; int duplicate = 0 ; for ( int i = 0 ; i < 26 ; ++ i ) { if ( freq [ i ] == 1 ) unique ++ ; else if ( freq [ i ] >= 2 ) duplicate ++ ; } if ( unique == 1 && ( unique + duplicate ) == count ) return 1 ; return 2 ; }
int findMinimumK ( int a [ ] , int n , int S ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return ( int ) Math . ceil ( ( ( S + 1 ) * 1.0 ) / ( sum * 1.0 ) ) ; }
int MinimumValue ( int a [ ] , int n ) { int answer = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { answer = Math . min ( answer , ( ( a [ i ] & a [ j ] ) ^ ( a [ i ] a [ j ] ) ) ) ; } } return answer ; }
int MinimumValue ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int minXor = Integer . MAX_VALUE ; int val = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = Math . min ( minXor , val ) ; } return minXor ; }
int count_element ( int N , int K , int [ ] arr ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; ++ i ) if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } int answer = 0 ; for ( Map . Entry < Integer , Integer > i : mp . entrySet ( ) ) { if ( mp . containsKey ( i . getKey ( ) + K ) ) answer += i . getValue ( ) ; } return answer ; }
int largestNum ( int n ) { int num = 0 ; int max_setBits = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { int setBits = countSetBits ( i ) ; if ( setBits >= max_setBits ) { num = i ; max_setBits = setBits ; } } return num ; }
int find_count ( int n ) { HashMap < Integer , Integer > mpp = new HashMap < Integer , Integer > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( mpp . containsKey ( digit_xor ( i ) ) ) mpp . put ( digit_xor ( i ) , mpp . get ( digit_xor ( i ) ) + 1 ) ; else mpp . put ( digit_xor ( i ) , 1 ) ; } int maxm = 0 ; for ( Map . Entry < Integer , Integer > x : mpp . entrySet ( ) ) { if ( x . getValue ( ) > maxm ) maxm = x . getValue ( ) ; } return maxm ; }
void findString ( int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( ( char ) ( 'A' + i % K ) ) ; } }
int digit_prod ( int x ) { int prod = 1 ; while ( x != 0 ) { prod *= x % 10 ; x = x / 10 ; } return prod ; }
int find_count ( int n ) { Map < Integer , Integer > mpp = new HashMap < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { int t = digit_prod ( i ) ; mpp . put ( t , mpp . getOrDefault ( t , 0 ) + 1 ) ; } int ans = 1 ; int maxm = 0 ; for ( Integer x : mpp . values ( ) ) { if ( x > maxm ) { maxm = x ; ans = 1 ; } else if ( x == maxm ) { ans ++ ; } } return ans ; }
boolean isPrime ( int n ) { int i ; if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) { return false ; } for ( i = 5 ; i * i <= n ; i += 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
int findSubarraySum ( int arr [ ] , int n , int K ) { HashMap < Integer , Integer > prevSum = new HashMap < Integer , Integer > ( ) ; int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == K ) { res ++ ; } if ( prevSum . containsKey ( currsum - K ) ) { res += ( prevSum . get ( currsum - K ) ) ; } if ( prevSum . containsKey ( currsum ) ) prevSum . put ( currsum , prevSum . get ( currsum ) + 1 ) ; else prevSum . put ( currsum , 1 ) ; } return res ; }
void countSubarray ( int arr [ ] , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime ( arr [ i ] ) ) { arr [ i ] = 1 ; } else { arr [ i ] = 0 ; } } System . out . print ( findSubarraySum ( arr , n , K ) ) ; }
int find_maxm ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int ans = 0 ; for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) { int value = x . getKey ( ) ; int freq = x . getValue ( ) ; if ( value == freq ) { ans ++ ; } } return ans ; }
int pow ( int x , int y ) { if ( y == 1 ) return x ; if ( y == 0 ) return 1 ; int temp = pow ( x , y / 2 ) ; temp *= temp ; if ( y % 2 == 1 ) temp *= x ; return temp ; }
int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = Math . max ( max_sum , i + j ) ; } } return max_sum ; }
int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { for ( int j = i + 1 ; j * j <= N ; j ++ ) { int k = N / j ; int a = k * i ; int b = k * j ; if ( a <= N && b <= N && a * b % ( a + b ) == 0 ) max_sum = Math . max ( max_sum , a + b ) ; } } return max_sum ; }
int findSum ( int L , int R ) { ArrayList < Integer > arr = new ArrayList < > ( ) ; int i = 0 ; int x = 2 ; while ( i <= R ) { arr . add ( i + x ) ; if ( i + 1 <= R ) arr . add ( i + 1 + x ) ; x *= - 1 ; i += 2 ; } int sum = 0 ; for ( i = L ; i <= R ; ++ i ) sum += arr . get ( i ) ; return sum ; }
int GetMinSubarrayLength ( int a [ ] , int n ) { int ans = Math . max ( a [ 0 ] , a [ n - 1 ] ) ; int lo = 0 , hi = n - 1 ; while ( lo < n && a [ lo ] % ans == 0 ) lo ++ ; while ( hi > lo && a [ hi ] % ans == 0 ) hi -- ; return ( hi - lo + 1 ) ; }
int count ( String s ) { int N , i , cnt = 0 , ans = 0 ; N = s . length ( ) ; for ( i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == 'R' ) cnt ++ ; if ( s . charAt ( i ) == 'L' ) ans += cnt ; } return ans ; }
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } return max_so_far ; }
int minimumValue ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int answer = 0 ; for ( int i = 0 ; i < k ; i ++ ) answer += arr [ i ] * arr [ i ] ; return answer * ( 2 * k - 2 ) ; }
int sumOfDigits ( int n ) { String s = String . valueOf ( n ) ; int sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum += ( s . charAt ( i ) - '0' ) ; } return sum ; }
int height ( int s , Vector < Integer > adj [ ] , int [ ] visited ) { visited [ s ] = 1 ; int h = 0 ; for ( int child : adj [ s ] ) { if ( visited [ child ] == 0 ) { h = Math . max ( h , 1 + height ( child , adj , visited ) ) ; } } return h ; }
int minimumGroups ( Vector < Integer > adj [ ] , int N ) { int [ ] visited = new int [ N + 1 ] ; int groups = Integer . MIN_VALUE ; for ( int i = 1 ; i <= N ; i ++ ) { if ( visited [ i ] == 0 ) { int comHeight ; comHeight = height ( i , adj , visited ) ; groups = Math . max ( groups , comHeight ) ; } } return groups ; }
boolean isPrime ( int n ) { int flag = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { flag = 0 ; break ; } } return ( flag == 1 ? true : false ) ; }
boolean isPerfectSquare ( int x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
int countInterestingPrimes ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( isPrime ( i ) ) { for ( int j = 1 ; j * j * j * j <= i ; j ++ ) { if ( isPerfectSquare ( i - j * j * j * j ) ) { answer ++ ; break ; } } } } return answer ; }
int sumDivisibles ( int A , int B , int M ) { int sum = 0 ; for ( int i = A ; i <= B ; i ++ ) if ( i % M == 0 ) sum += i ; return sum ; }
int findSmallNum ( int N , int K ) { int rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
int findLargeNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }
int sumDivisibles ( int A , int B , int M ) { int first = findSmallNum ( A , M ) ; int last = findLargeNum ( B , M ) ; if ( first < A ) first += M ; if ( last > B ) first -= M ; int n = ( B / M ) - ( A - 1 ) / M ; return n * ( first + last ) / 2 ; }
int check ( int A [ ] , int B [ ] , int N ) { PriorityQueue < Integer > pq1 = new PriorityQueue < Integer > ( Collections . reverseOrder ( ) ) ; PriorityQueue < Integer > pq2 = new PriorityQueue < Integer > ( Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { pq1 . add ( A [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { pq2 . add ( B [ i ] ) ; } int c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( pq1 . peek ( ) . compareTo ( pq2 . peek ( ) ) == 1 ) { c ++ ; pq1 . poll ( ) ; pq2 . poll ( ) ; } else { if ( pq2 . size ( ) == 0 ) { break ; } pq2 . poll ( ) ; } } return ( c ) ; }
void calcSum ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i <= n - k ; i ++ ) { int sum = 0 ; for ( int j = i ; j < k + i ; j ++ ) sum += arr [ j ] ; System . out . print ( sum + " " ) ; } }
void calcSum ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += arr [ i ] ; System . out . print ( sum + " " ) ; for ( int i = k ; i < n ; i ++ ) { sum = ( sum - arr [ i - k ] ) + arr [ i ] ; System . out . print ( sum + " " ) ; } }
long getPairs ( Vector < Integer > A , Vector < Integer > B , int n ) { int [ ] D = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { D [ i ] = A . get ( i ) - B . get ( i ) ; } Arrays . sort ( D ) ; long total = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( D [ i ] > 0 ) { total += n - i - 1 ; } else { int k = upper_bound ( D , 0 , D . length , - D [ i ] ) ; total += n - k ; } } return total ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; }
int countPairs ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( lcm ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) ) ans ++ ; return ans ; }
int countPairs ( int arr [ ] , int n ) { HashMap < Integer , Integer > frequency = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( frequency . containsKey ( arr [ i ] ) ) { frequency . put ( arr [ i ] , frequency . get ( arr [ i ] ) + 1 ) ; } else { frequency . put ( arr [ i ] , 1 ) ; } } int count = 0 ; for ( Map . Entry < Integer , Integer > x : frequency . entrySet ( ) ) { int f = x . getValue ( ) ; count += f * ( f - 1 ) / 2 ; } return count ; }
void preCompute ( int N ) { fact [ 0 ] = 1 ; for ( int i = 1 ; fact [ i - 1 ] <= N ; i ++ ) { fact [ i ] = ( fact [ i - 1 ] * i ) ; size ++ ; } }
int findLCS ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } return mp . size ( ) ; }
void segments ( int n ) { if ( n == 1 n == 0 ) { return ; } if ( n % 2 == 0 ) { System . out . print ( "1" ) ; segments ( n - 2 ) ; } else if ( n % 2 == 1 ) { System . out . print ( "7" ) ; segments ( n - 3 ) ; } }
int countOperations ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { arr [ i ] ++ ; arr [ i + 1 ] ++ ; count += 2 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) return - 1 ; } return count ; }
int findMinimumSubsequences ( String A , String B ) { int numberOfSubsequences = 1 ; int sizeOfB = B . length ( ) ; int sizeOfA = A . length ( ) ; int inf = 1000000 ; int [ ] [ ] next = new int [ 26 ] [ sizeOfB ] ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < sizeOfB ; j ++ ) { next [ i ] [ j ] = inf ; } } for ( int i = 0 ; i < sizeOfB ; i ++ ) { next [ B . charAt ( i ) - 'a' ] [ i ] = i ; } for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = sizeOfB - 2 ; j >= 0 ; j -- ) { if ( next [ i ] [ j ] == inf ) { next [ i ] [ j ] = next [ i ] [ j + 1 ] ; } } } int pos = 0 ; int i = 0 ; while ( i < sizeOfA ) { if ( pos == 0 && next [ A . charAt ( i ) - 'a' ] [ pos ] == inf ) { numberOfSubsequences = - 1 ; break ; } else if ( pos < sizeOfB && next [ A . charAt ( i ) - 'a' ] [ pos ] < inf ) { int nextIndex = next [ A . charAt ( i ) - 'a' ] [ pos ] + 1 ; pos = nextIndex ; i ++ ; } else { numberOfSubsequences ++ ; pos = 0 ; } } return numberOfSubsequences ; }
void convolution ( int [ ] x , int [ ] h , int n , int m ) { int row_vec [ ] = new int [ MAX_SIZE ] ; int col_vec [ ] = new int [ MAX_SIZE ] ; int out [ ] = new int [ MAX_SIZE ] ; int circular_shift_mat [ ] [ ] = new int [ MAX_SIZE ] [ MAX_SIZE ] ; int maxSize = n > m ? n : m ; for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i >= n ) { row_vec [ i ] = 0 ; } else { row_vec [ i ] = x [ i ] ; } } for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i >= m ) { col_vec [ i ] = 0 ; } else { col_vec [ i ] = h [ i ] ; } } int k = 0 , d = 0 ; for ( int i = 0 ; i < maxSize ; i ++ ) { int curIndex = k - d ; for ( int j = 0 ; j < maxSize ; j ++ ) { circular_shift_mat [ j ] [ i ] = row_vec [ curIndex % maxSize ] ; curIndex ++ ; } k = maxSize ; d ++ ; } for ( int i = 0 ; i < maxSize ; i ++ ) { for ( int j = 0 ; j < maxSize ; j ++ ) { out [ i ] += circular_shift_mat [ i ] [ j ] * col_vec [ j ] ; } System . out . print ( out [ i ] + " " ) ; } }
int maxLength ( String str , int len ) { int res = 0 ; int lastPos [ ] = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { lastPos [ i ] = - 1 ; } for ( int i = 0 ; i < len ; i ++ ) { int C = str . charAt ( i ) - 'a' ; if ( lastPos [ C ] != - 1 ) { res = Math . max ( len - ( i - lastPos [ C ] - 1 ) - 1 , res ) ; } lastPos [ C ] = i ; } return res ; }
int maxProfit ( int profitA [ ] , int profitB [ ] , int n ) { int preSum [ ] = new int [ n ] ; preSum [ 0 ] = profitA [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { preSum [ i ] = preSum [ i - 1 ] + profitA [ i ] ; } int suffSum [ ] = new int [ n ] ; suffSum [ n - 1 ] = profitB [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + profitB [ i ] ; } int res = preSum [ n - 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { res = Math . max ( res , preSum [ i ] + suffSum [ i + 1 ] ) ; } res = Math . max ( res , suffSum [ 0 ] ) ; return res ; }
int countPartitions ( int [ ] A , int N ) { int count = 0 ; int i , j ; for ( i = 0 ; i < N ; i ++ ) { int min_elem = min_element ( A , N ) ; if ( min_elem == INT_MAX ) break ; count ++ ; for ( j = 0 ; j < N ; j ++ ) { if ( A [ j ] % min_elem == 0 ) A [ j ] = INT_MAX ; } } return count ; }
int max_palindrome ( String [ ] s , int n ) { int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] . length ( ) % 2 != 0 ) { flag = 1 ; } } if ( flag == 1 ) { return n ; } int z = 0 ; int o = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < s [ i ] . length ( ) ; j ++ ) { if ( s [ i ] . charAt ( j ) == '0' ) z += 1 ; else o += 1 ; } } if ( o % 2 == 0 && z % 2 == 0 ) { return n ; } else { return n - 1 ; } }
int minChanges ( int arr [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int maxElem = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { maxElem = Math . max ( maxElem , entry . getValue ( ) ) ; } return n - maxElem ; }
int minOperations ( int n , int m ) { int a = 0 , k = 1 ; int p = Math . max ( n , m ) ; while ( n != m ) { float s = ( float ) ( p - n + p - m ) ; float q = ( float ) ( ( - 1 + Math . sqrt ( 8 * s + 1 ) ) / 2 ) ; if ( q - Math . floor ( q ) == 0 ) { a = ( int ) q ; n = m ; } p = p + 1 ; } return a ; }
void decBinary ( int arr [ ] , int n ) { int k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } }
int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; }
int maxNum ( int n , int k ) { int l = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; int a [ ] = new int [ l ] ; decBinary ( a , n ) ; int cn = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == 0 && cn < k ) { a [ i ] = 1 ; cn ++ ; } } return binaryDec ( a , l ) ; }
int minFlipsSub ( String mat [ ] , int i , int j ) { int cnt0 = 0 , cnt1 = 0 ; if ( mat [ i ] . charAt ( j ) == '1' ) cnt1 ++ ; else cnt0 ++ ; if ( mat [ i ] . charAt ( j + 1 ) == '1' ) cnt1 ++ ; else cnt0 ++ ; if ( mat [ i + 1 ] . charAt ( j ) == '1' ) cnt1 ++ ; else cnt0 ++ ; if ( mat [ i + 1 ] . charAt ( j + 1 ) == '1' ) cnt1 ++ ; else cnt0 ++ ; return Math . min ( cnt0 , cnt1 ) ; }
int minFlips ( String mat [ ] , int r , int c ) { int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < r - 1 ; i ++ ) { for ( int j = 0 ; j < c - 1 ; j ++ ) { res = Math . min ( res , minFlipsSub ( mat , i , j ) ) ; } } return res ; }
void findSubSeq ( int arr [ ] , int n , int sum ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( sum < arr [ i ] ) arr [ i ] = - 1 ; else sum -= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != - 1 ) System . out . print ( arr [ i ] + " " ) ; } }
int k_sum ( int a [ ] , int n , int k ) { int r = 0 , sum = 0 ; int ans = 0 ; for ( int l = 0 ; l < n ; l ++ ) { while ( sum < k ) { if ( r == n ) break ; else { sum += a [ r ] ; r ++ ; } } if ( sum < k ) break ; ans += n - r + 1 ; sum -= a [ l ] ; } return ans ; }
void balBracketSequence ( String str ) { int n = str . length ( ) ; if ( str . charAt ( 0 ) == str . charAt ( n - 1 ) ) { System . out . println ( "No" ) ; } else { int cntForOpen = 0 , cntForClose = 0 ; int check = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( 0 ) ) cntForOpen ++ ; else if ( str . charAt ( i ) == str . charAt ( n - 1 ) ) cntForOpen -= 1 ; else cntForOpen += 1 ; if ( cntForOpen < 0 ) { check = 0 ; break ; } } if ( check != 0 && cntForOpen == 0 ) { System . out . print ( "Yes, " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( n - 1 ) ) System . out . print ( ')' ) ; else System . out . print ( '(' ) ; } return ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( 0 ) ) cntForClose ++ ; else cntForClose -- ; if ( cntForClose < 0 ) { check = 0 ; break ; } } if ( check != 0 && cntForClose == 0 ) { System . out . print ( "Yes, " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( 0 ) ) System . out . print ( '(' ) ; else System . out . print ( ')' ) ; } return ; } } System . out . print ( "No" ) ; } }
int countSetBits ( int n , int k ) { int kth = findK ( n , k ) ; int count = 0 ; while ( kth > 0 ) { count += kth & 1 ; kth >>= 1 ; } return count ; }
char maxAlpha ( String str , int len ) { int [ ] first = new int [ MAX ] ; int [ ] last = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { first [ i ] = - 1 ; last [ i ] = - 1 ; } for ( int i = 0 ; i < len ; i ++ ) { int index = ( str . charAt ( i ) - 'a' ) ; if ( first [ index ] == - 1 ) first [ index ] = i ; last [ index ] = i ; } int ans = - 1 , maxVal = - 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] == - 1 ) continue ; if ( ( last [ i ] - first [ i ] ) > maxVal ) { maxVal = last [ i ] - first [ i ] ; ans = i ; } } return ( char ) ( ans + 'a' ) ; }
int maxSum ( int arr1 [ ] , int arr2 [ ] , int n ) { int initialParity = 0 , finalParity = 0 ; int sum = 0 , minPositive = Integer . MAX_VALUE , maxNegative = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { initialParity += arr2 [ i ] ; if ( arr1 [ i ] >= 0 ) { finalParity += 1 ; sum += arr1 [ i ] ; minPositive = Math . min ( minPositive , arr1 [ i ] ) ; } else { maxNegative = Math . max ( maxNegative , arr1 [ i ] ) ; } } if ( initialParity % 2 == finalParity % 2 ) { return sum ; } else { if ( minPositive + maxNegative >= 0 ) { return sum + maxNegative ; } else { return sum - minPositive ; } } }
boolean IsLarger ( int [ ] X , int [ ] Y , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( X [ i ] < Y [ i ] ) { return false ; } } return true ; }
int solve ( int X [ ] , int Y [ ] , int n ) { int ans = 0 ; if ( IsLarger ( X , Y , n ) ) ans = 0 ; else { int d = Y [ 0 ] - X [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) X [ i ] += d ; if ( IsLarger ( X , Y , n ) ) ans = d ; else { ans = d + 1 ; } } return ans ; }
int valueofX ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ar [ i ] ; } if ( sum % n == 0 ) { return sum / n ; } else { int A = sum / n , B = sum / n + 1 ; int ValueA = 0 , ValueB = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) ; ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) ; } if ( ValueA < ValueB ) { return A ; } else { return B ; } } }
int minLength ( int n ) { int ans = n / 26 ; if ( n % 26 != 0 ) ans ++ ; return ans ; }
int minHalls ( int lectures [ ] [ ] , int n ) { int [ ] prefix_sum = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { prefix_sum [ lectures [ i ] [ 0 ] ] ++ ; prefix_sum [ lectures [ i ] [ 1 ] + 1 ] -- ; } int ans = prefix_sum [ 0 ] ; for ( int i = 1 ; i < MAX ; i ++ ) { prefix_sum [ i ] += prefix_sum [ i - 1 ] ; ans = Math . max ( ans , prefix_sum [ i ] ) ; } return ans ; }
int minCapacity ( int enter [ ] , int exit [ ] , int n ) { int minCap = 0 ; int currCap = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currCap = currCap + enter [ i ] - exit [ i ] ; minCap = Math . max ( minCap , currCap ) ; } return minCap ; }
void generate ( ) { Queue < String > q = new LinkedList < String > ( ) ; q . add ( "1" ) ; q . add ( "2" ) ; q . add ( "3" ) ; q . add ( "4" ) ; q . add ( "5" ) ; boolean flag = true ; ans . add ( "0" ) ; while ( ! q . isEmpty ( ) ) { String x = q . peek ( ) ; q . remove ( ) ; if ( isValidNum ( x ) ) { ans . add ( x ) ; } if ( x . length ( ) == 6 ) continue ; for ( int i = 0 ; i <= 5 ; i ++ ) { String z = String . valueOf ( i ) ; String temp = x + z ; q . add ( temp ) ; } } }
boolean comp ( String a , String b ) { if ( a . length ( ) == b . length ( ) ) { int i = a . compareTo ( b ) ; return i < 0 ? true : false ; } else return a . length ( ) < b . length ( ) ; }
int findcount ( String l , String r ) { generate ( ) ; int count = 0 ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { String a = ans . get ( i ) ; if ( comp ( l , a ) && comp ( a , r ) ) { count ++ ; } else if ( a == l a == r ) { count ++ ; } } return count ; }
int [ ] Findpermutation ( int n ) { int [ ] a = new int [ n + 1 ] ; a [ 1 ] = n ; for ( int i = 2 ; i <= n ; i ++ ) a [ i ] = i - 1 ; return a ; }
int Balanced_Substring ( String str , int n ) { int ans = 0 ; int [ ] arr = new int [ n / 2 + 1 ] ; int d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '(' ) d ++ ; else { if ( d == 1 ) { for ( int j = 2 ; j <= n / 2 + 1 && arr [ j ] != 0 ; j ++ ) arr [ j ] = 0 ; } ++ ans ; ans += arr [ d ] ; arr [ d ] ++ ; d -- ; } } return ans ; }
int power ( long x , int y , int mod ) { long res = 1 ; while ( y != 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % mod ; x = ( x * x ) % mod ; y = ( y >> 1 ) ; } return ( int ) ( res % mod ) ; }
int NoOfChords ( int A ) { int mod = ( int ) ( 1e9 + 7 ) ; long ans = ncr ( 2 * A , A , mod ) ; int inv = power ( A + 1 , mod - 2 , mod ) ; ans = ( ans * inv ) % mod ; return ( int ) ( ans % mod ) ; }
int StrictlyPositiveXor ( int [ ] A , int N ) { int allxor = 0 ; boolean checkallzero = true ; for ( int i = 0 ; i < N ; i += 1 ) { allxor ^= A [ i ] ; if ( A [ i ] > 0 ) checkallzero = false ; } if ( allxor != 0 ) return N ; if ( checkallzero ) return - 1 ; int l = N , r = - 1 ; for ( int i = 0 ; i < N ; i += 1 ) { if ( A [ i ] > 0 ) { l = i + 1 ; break ; } } for ( int i = N - 1 ; i >= 0 ; i -= 1 ) { if ( A [ i ] > 0 ) { r = i + 1 ; break ; } } return Math . max ( N - l , r - 1 ) ; }
int FindMinOperation ( int [ ] a , int n , int k ) { PriorityQueue < Integer > Q = new PriorityQueue < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) Q . add ( a [ i ] ) ; int ans = 0 ; while ( true ) { if ( Q . peek ( ) >= k ) break ; if ( Q . size ( ) < 2 ) return - 1 ; int x = Q . peek ( ) ; Q . poll ( ) ; int y = Q . peek ( ) ; Q . poll ( ) ; int z = ( x * y ) / gcd ( x , y ) ; Q . add ( z ) ; ans ++ ; } return ans ; }
void findWeights ( int X ) { int sum = 0 ; int power = 0 ; int number = 3 ; while ( sum < X ) { sum = number - 1 ; sum /= 2 ; power ++ ; number *= 3 ; } int ans = 1 ; for ( int i = 1 ; i <= power ; i ++ ) { System . out . print ( ans + " " ) ; ans = ans * 3 ; } }
int solve ( int [ ] Array , int N , int K ) { int [ ] count_Arr = new int [ N + 2 ] ; int factor = 1 ; int size = N ; while ( size > 0 ) { int start = 1 ; int end = size ; count_Arr [ 1 ] += factor * N ; count_Arr [ end + 1 ] -= factor * N ; factor ++ ; size /= 2 ; } for ( int i = 2 ; i <= N ; i ++ ) count_Arr [ i ] += count_Arr [ i - 1 ] ; Vector < Pair > element = new Vector < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { Pair x = new Pair ( Array [ i ] , count_Arr [ i + 1 ] ) ; element . add ( x ) ; } int start = 1 ; for ( int i = 0 ; i < N ; i ++ ) { int end = start + element . elementAt ( 0 ) . getSecond ( ) - 1 ; if ( K >= start && K <= end ) return element . elementAt ( i ) . getFirst ( ) ; start += element . elementAt ( i ) . getSecond ( ) ; } return - 1 ; }
void find_distinct ( int a [ ] , int n , int q , int queries [ ] ) { int [ ] check = new int [ MAX ] ; int [ ] idx = new int [ MAX ] ; int cnt = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( check [ a [ i ] ] == 0 ) { idx [ i ] = cnt ; check [ a [ i ] ] = 1 ; cnt ++ ; } else { idx [ i ] = cnt - 1 ; } } for ( int i = 0 ; i < q ; i ++ ) { int m = queries [ i ] ; System . out . print ( idx [ m ] + " " ) ; } }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int lcm ( int n , int m ) { return ( n * m ) / gcd ( n , m ) ; }
boolean matrix_exist ( int row [ ] , int column [ ] , int r , int c ) { int row_sum = 0 ; int column_sum = 0 ; int row_max = - 1 ; int column_max = - 1 ; int row_non_zero = 0 ; int column_non_zero = 0 ; for ( int i = 0 ; i < r ; i ++ ) { row_sum += row [ i ] ; row_max = Math . max ( row_max , row [ i ] ) ; if ( row [ i ] > 0 ) { row_non_zero ++ ; } } for ( int i = 0 ; i < c ; i ++ ) { column_sum += column [ i ] ; column_max = Math . max ( column_max , column [ i ] ) ; if ( column [ i ] > 0 ) { column_non_zero ++ ; } } if ( ( row_sum != column_sum ) || ( row_max > column_non_zero ) || ( column_max > row_non_zero ) ) { return false ; } return true ; }
int longestSubarray ( int arr [ ] , int n ) { int maxMean = 0 ; for ( int i = 1 ; i < n ; i ++ ) maxMean = Math . max ( maxMean , ( arr [ i ] + arr [ i - 1 ] ) / 2 ) ; int ans = 0 ; int subarrayLength = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= maxMean ) ans = Math . max ( ans , ++ subarrayLength ) ; else subarrayLength = 0 ; return ans ; }
int maxDistance ( int arr [ ] , int n ) { if ( arr [ 0 ] != arr [ n - 1 ] ) return ( n - 1 ) ; int i = n - 1 ; while ( i > 0 ) { if ( arr [ i ] != arr [ 0 ] ) break ; i -- ; } int distFirst = ( i == 0 ) ? - 1 : i ; i = 0 ; while ( i < n - 1 ) { if ( arr [ i ] != arr [ n - 1 ] ) break ; i ++ ; } int distLast = ( i == n - 1 ) ? - 1 : ( n - 1 - i ) ; int maxDist = Math . max ( distFirst , distLast ) ; return maxDist ; }
int SubarraySum ( int [ ] a , int n , int x ) { int ans = - 10000 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int curans = 0 ; ArrayList < Integer > pq = new ArrayList < Integer > ( ) ; ArrayList < Integer > pq2 = new ArrayList < Integer > ( ) ; for ( int k = 0 ; k < n ; k ++ ) { if ( k >= i && k <= j ) { curans += a [ k ] ; pq2 . add ( a [ k ] ) ; } else pq . add ( a [ k ] ) ; } Collections . sort ( pq ) ; Collections . reverse ( pq ) ; Collections . sort ( pq2 ) ; ans = Math . max ( ans , curans ) ; for ( int k = 1 ; k <= x ; k ++ ) { if ( pq . size ( ) == 0 || pq2 . size ( ) == 0 || pq2 . get ( 0 ) >= pq . get ( 0 ) ) break ; curans -= pq2 . get ( 0 ) ; pq2 . remove ( 0 ) ; curans += pq . get ( 0 ) ; pq . remove ( 0 ) ; ans = Math . max ( ans , curans ) ; } } } return ans ; }
void solve ( int n , int k ) { int mini = 0 ; int x1 = 1 ; int [ ] a = new int [ k ] ; for ( int i = 1 ; i <= k ; i ++ ) { mini += x1 ; a [ i - 1 ] = x1 ; x1 += 1 ; } if ( n < mini ) { System . out . print ( "-1" ) ; return ; } int rem = n - mini ; int cnt = rem / k ; rem = rem % k ; for ( int i = 0 ; i < k ; i ++ ) a [ i ] += cnt ; for ( int i = k - 1 ; i > 0 && rem > 0 ; i -- ) { int xx = a [ i - 1 ] * 2 ; int left = xx - a [ i ] ; if ( rem >= left ) { a [ i ] = xx ; rem -= left ; } else { a [ i ] += rem ; rem = 0 ; } } int sum = a [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) { if ( a [ i ] > 2 * a [ i - 1 ] ) { System . out . print ( "-1" ) ; return ; } sum += a [ i ] ; } if ( sum != n ) { System . out . print ( "-1" ) ; return ; } for ( int i = 0 ; i < k ; i ++ ) System . out . print ( a [ i ] + " " ) ; }
void printMaxNumber ( int n ) { if ( n % 2 != 0 ) { System . out . print ( "7" ) ; for ( int i = 0 ; i < ( n - 3 ) / 2 ; i ++ ) System . out . print ( "1" ) ; } else { for ( int i = 0 ; i < n / 2 ; i ++ ) System . out . print ( "1" ) ; } }
int minOperations ( int [ ] arr , int n ) { int maxi , result = 0 ; int [ ] freq = new int [ 1000001 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x ] ++ ; } maxi = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) { for ( int j = i * 2 ; j <= maxi ; j = j + i ) { freq [ j ] = 0 ; } result ++ ; } } return result ; }
int maxCoins ( int X , int Y ) { if ( X < Y ) { swap ( X , Y ) ; } int coins = X ; X -- ; coins += Math . max ( X , Y ) ; return coins ; }
int findElementsCrossed ( int arr [ ] , int a , int b , int n ) { int aa = a ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a == 0 && b == 0 ) break ; else if ( a == 0 ) { if ( arr [ i ] == 1 ) { b -= 1 ; a = Math . min ( aa , a + 1 ) ; } else b -= 1 ; } else if ( b == 0 ) a -- ; else if ( arr [ i ] == 1 && a < aa ) { b -= 1 ; a = Math . min ( aa , a + 1 ) ; } else a -- ; ans ++ ; } return ans ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " " ) ; }
void pushBinaryToBorder ( int arr [ ] , int n ) { int count1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 1 ) arr [ count1 ++ ] = arr [ i ] ; while ( count1 < n ) arr [ count1 ++ ] = 1 ; int lastNonOne = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] == 1 ) continue ; if ( lastNonOne == 0 ) { lastNonOne = i ; } if ( arr [ i ] != 0 ) arr [ lastNonOne -- ] = arr [ i ] ; } while ( lastNonOne >= 0 ) arr [ lastNonOne -- ] = 0 ; }
int getMaxValue ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { return 0 ; } first = second = Integer . MIN_VALUE ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) { second = arr [ i ] ; } } if ( second == Integer . MIN_VALUE ) { return 0 ; } else { return second ; } }
boolean isVowel ( char ch ) { switch ( ch ) { case 'a' : case 'e' : case 'i' : case 'o' : case 'u' : return true ; default : return false ; } }
int vowelPairs ( String s , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( isVowel ( s . charAt ( i ) ) && isVowel ( s . charAt ( i + 1 ) ) ) cnt ++ ; } return cnt ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int solve ( int health [ ] , int n ) { int currentgcd = gcd ( health [ 0 ] , health [ 1 ] ) ; for ( int i = 2 ; i < n ; ++ i ) { currentgcd = gcd ( currentgcd , health [ i ] ) ; } return currentgcd ; }
String smallestString ( int N , int [ ] A ) { char ch = 'a' ; String S = "" ; if ( N < 1 A [ 0 ] != 1 ) { S = "-1" ; return S ; } S += ch ; ch ++ ; for ( int i = 1 ; i < N ; i ++ ) { int diff = A [ i ] - A [ i - 1 ] ; if ( diff > 1 diff < 0 A [ i ] > 26 ) { S = "-1" ; return S ; } else if ( diff == 0 ) S += 'a' ; else { S += ch ; ch ++ ; } } return S ; }
int bankNotes ( int A , int B , int S , int N ) { int numerator = S - ( B * N ) ; int denominator = A - B ; if ( numerator % denominator == 0 ) return ( numerator / denominator ) ; return - 1 ; }
int countSteps ( int n ) { int steps = 0 ; while ( n > 0 ) { int largest = ( int ) Math . sqrt ( n ) ; n -= ( largest * largest ) ; steps ++ ; } return steps ; }
int longestSubstring ( String s ) { int cnt = 1 , maxi = 1 ; int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) ) cnt ++ ; else { maxi = Math . max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . max ( cnt , maxi ) ; return maxi ; }
int Minimum_Operations ( int [ ] a , int n ) { int [ ] np = new int [ n + 1 ] ; np [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { np [ i ] = np [ i + 1 ] ; if ( a [ i ] <= 0 ) np [ i ] ++ ; } int pos = 0 ; int ans = n ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] >= 0 ) pos ++ ; ans = Math . min ( ans , pos + np [ i + 1 ] ) ; } return ans ; }
int findSumofEle ( int [ ] arr1 , int m , int [ ] arr2 , int n , int k ) { float arraySum = 0 ; for ( int i = 0 ; i < n ; i ++ ) arraySum += arr2 [ i ] ; float mean = arraySum / n ; int sumOfElements = 0 ; float difference = 0 ; for ( int i = 0 ; i < m ; i ++ ) { difference = arr1 [ i ] - mean ; if ( ( difference < 0 ) && ( k > ( - 1 ) * difference ) ) { sumOfElements += arr1 [ i ] ; } if ( ( difference >= 0 ) && ( k > difference ) ) { sumOfElements += arr1 [ i ] ; } } return sumOfElements ; }
void findIntegers ( int n , int x , int y ) { ArrayList < Integer > ans = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) ans . add ( 1 ) ; if ( y - ( n - 1 ) <= 0 ) { System . out . print ( "-1" ) ; return ; } ans . add ( y - ( n - 1 ) ) ; int store = 0 ; for ( int i = 0 ; i < n ; i ++ ) store += ans . get ( i ) * ans . get ( i ) ; if ( store < x ) { System . out . print ( "-1" ) ; return ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans . get ( i ) + " " ) ; }
int Minsteps ( int n , int m ) { int ans = 0 ; while ( m > n ) { if ( m % 2 != 0 ) { m ++ ; ans ++ ; } m /= 2 ; ans ++ ; } return ans + n - m ; }
int getsum ( int x ) { return ( x * ( x + 1 ) ) / 2 ; }
int maxCandies ( int arr [ ] , int n ) { int prevBought = arr [ n - 1 ] ; int candies = prevBought ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int x = Math . min ( prevBought - 1 , arr [ i ] ) ; if ( x >= 0 ) { candies += x ; prevBought = x ; } } return candies ; }
int sumArr ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
int maxSum ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int i = 0 ; while ( i < n && k > 0 && arr [ i ] < 0 ) { arr [ i ] *= - 1 ; k -- ; i ++ ; } if ( k % 2 == 1 ) { int min = 0 ; for ( i = 1 ; i < n ; i ++ ) if ( arr [ min ] > arr [ i ] ) min = i ; arr [ min ] *= - 1 ; } return sumArr ( arr , n ) ; }
int Maxsum ( int c1 , int c2 , int c3 , int c4 ) { int sum = 0 ; int two34 = Math . min ( c2 , Math . min ( c3 , c4 ) ) ; sum = two34 * 234 ; c2 -= two34 ; sum += Math . min ( c2 , c1 ) * 12 ; return sum ; }
void replacedArray ( int N , int [ ] arr ) { int pos_sum , neg_sum , i , j , diff ; for ( i = 0 ; i < N ; i ++ ) { pos_sum = 0 ; neg_sum = 0 ; for ( j = i + 1 ; j < N ; j ++ ) { if ( arr [ j ] > 0 ) pos_sum += arr [ j ] ; else neg_sum += arr [ j ] ; } diff = Math . abs ( pos_sum ) - Math . abs ( neg_sum ) ; arr [ i ] = Math . abs ( diff ) ; } }
int maximumResult ( int a , int b , int c ) { int countOfNegative = 0 ; int sum = a + b + c ; int product = a * b * c ; int largest = ( a > b ) ? ( ( a > c ) ? a : c ) : ( ( b > c ) ? b : c ) ; int smallest = ( a < b ) ? ( ( a < c ) ? a : c ) : ( ( b < c ) ? b : c ) ; if ( a < 0 ) countOfNegative ++ ; if ( b < 0 ) countOfNegative ++ ; if ( c < 0 ) countOfNegative ++ ; switch ( countOfNegative ) { case 0 : return ( sum - largest ) * largest ; case 1 : return ( product / smallest ) + smallest ; case 2 : return ( product / largest ) + largest ; case 3 : return ( sum - smallest ) * smallest ; } return - 1 ; }
boolean isPalindrome ( String s ) { for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( s . charAt ( i ) != s . charAt ( s . length ( ) - i - 1 ) ) { return false ; } } return true ; }
boolean ans ( String s ) { String s2 = s ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { s2 = s2 . charAt ( s2 . length ( ) - 1 ) + s2 ; s2 = s2 . substring ( 0 , s2 . length ( ) - 1 ) ; if ( ( s == null ? s2 != null : ! s . equals ( s2 ) ) && isPalindrome ( s2 ) ) { return true ; } } return false ; }
int solve ( String s ) { if ( s . length ( ) <= 3 ) { return - 1 ; } int cnt [ ] = new int [ 25 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { cnt [ s . charAt ( i ) - 'a' ] ++ ; } if ( Arrays . stream ( cnt ) . max ( ) . getAsInt ( ) >= ( s . length ( ) - 1 ) ) { return - 1 ; } else { return ( ans ( s ) ? 1 : 2 ) ; } }
int solveEven ( String s ) { if ( s . length ( ) % 2 == 1 ) { return 2 ; } String ls = s . substring ( 0 , s . length ( ) / 2 ) ; String rs = s . substring ( s . length ( ) / 2 , s . length ( ) ) ; if ( ls != rs ) { return 1 ; } return solveEven ( ls ) ; }
int solveOdd ( String s ) { return 2 ; }
int solve ( String s ) { if ( s . length ( ) <= 3 ) { return - 1 ; } int cnt [ ] = new int [ 25 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { cnt [ s . charAt ( i ) - 'a' ] ++ ; } if ( Arrays . stream ( cnt ) . max ( ) . getAsInt ( ) >= s . length ( ) - 1 ) { return - 1 ; } if ( s . length ( ) % 2 == 0 ) { return solveEven ( s ) ; } if ( s . length ( ) % 2 == 1 ) { return solveOdd ( s ) ; } return Integer . MIN_VALUE ; }
int minChanges ( char [ ] str , int n ) { int count = 0 , zeros = 0 , ones = 0 ; if ( str [ 0 ] != '1' ) { count ++ ; ones ++ ; } for ( int i = 1 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) zeros ++ ; else ones ++ ; if ( zeros > ones ) { zeros -- ; ones ++ ; count ++ ; } } return count ; }
int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; for ( int i = 1 ; i <= a ; i ++ ) { ans += b / n ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; }
int findCountOfPairs ( int a , int b , int n ) { if ( a > b ) { int temp = a ; a = b ; b = temp ; } int temp = 1 , count = 0 ; for ( int i = n ; temp > 0 ; i += n ) { if ( a >= i ) { temp = i - 1 ; } else if ( b >= i ) { temp = a ; } else if ( i > b ) { temp = a - ( i - b ) + 1 ; } if ( temp > 0 ) { count += temp ; } } return count ; }
int minGCD ( int arr [ ] , int n ) { int minGCD = 0 ; for ( int i = 0 ; i < n ; i ++ ) minGCD = __gcd ( minGCD , arr [ i ] ) ; return minGCD ; }
int minLCM ( int arr [ ] , int n ) { int minLCM = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) minLCM = Math . min ( minLCM , arr [ i ] ) ; return minLCM ; }
int countSteps ( int curx , int cury , int n , int m , int [ ] [ ] moves ) { int count = 0 ; int k = moves . length ; for ( int i = 0 ; i < k ; i ++ ) { int x = moves [ i ] [ 0 ] ; int y = moves [ i ] [ 1 ] ; int stepct = Math . min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) ; count += stepct ; curx += stepct * x ; cury += stepct * y ; } return count ; }
int min_elimination ( int n , int [ ] arr ) { int count = 0 ; int prev_val = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int curr_val = arr [ i ] ; if ( curr_val % 2 == prev_val % 2 ) count ++ ; prev_val = curr_val ; } return count ; }
String getCount ( int N ) { if ( N % 2 == 1 ) return "0" ; String result = "9" ; for ( int i = 1 ; i <= N / 2 - 1 ; i ++ ) result += "0" ; return result ; }
int cmp ( int a , int b ) { if ( a > b ) return 1 ; else if ( a == b ) return 0 ; else return - 1 ; }
int maxSubStrings ( String s , int k ) { int maxSubStr = 0 , n = s . length ( ) ; for ( int c = 0 ; c < 26 ; c ++ ) { char ch = ( char ) ( ( int ) 'a' + c ) ; int curr = 0 ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( s . charAt ( i ) != ch ) continue ; int cnt = 0 ; while ( i < n && s . charAt ( i ) == ch && cnt != k ) { i ++ ; cnt ++ ; } i -- ; if ( cnt == k ) curr ++ ; } maxSubStr = Math . max ( maxSubStr , curr ) ; } return maxSubStr ; }
boolean canFormTeam ( int n , int m ) { if ( n >= 1 && m >= 2 ) return true ; if ( m >= 1 && n >= 2 ) return true ; return false ; }
int maxTeams ( int n , int m ) { int count = 0 ; while ( canFormTeam ( n , m ) ) { if ( n > m ) { n -= 2 ; m -= 1 ; } else { m -= 2 ; n -= 1 ; } count ++ ; } return count ; }
boolean canBePicked ( int digits [ ] , int num ) { int copyDigits [ ] = digits . clone ( ) ; while ( num > 0 ) { int digit = num % 10 ; if ( copyDigits [ digit ] == 0 ) return false ; else copyDigits [ digit ] -- ; num /= 10 ; } return true ; }
long max ( long a , long b ) { if ( a > b ) return a ; else return b ; }
long smallestSide ( long a [ ] ) { Arrays . sort ( a ) ; long side1 , side2 , side3 , side4 , side11 , side12 , sideOfSquare ; side1 = a [ 0 ] + a [ 3 ] ; side2 = a [ 1 ] + a [ 2 ] ; side3 = a [ 0 ] + a [ 1 ] ; side4 = a [ 2 ] + a [ 3 ] ; side11 = max ( side1 , side2 ) ; side12 = max ( side3 , side4 ) ; sideOfSquare = max ( side11 , side12 ) ; return sideOfSquare ; }
void find_rectangle ( int area ) { for ( int i = ( int ) Math . ceil ( Math . sqrt ( area ) ) ; i <= area ; i ++ ) { if ( area / i * i == area ) { System . out . println ( i + " " + ( int ) ( area / i ) ) ; return ; } } }
int sizeSubSet ( int a [ ] , int k , int n ) { Arrays . sort ( a ) ; HashMap < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % k != 0 || s . get ( a [ i ] / k ) == null ) s . put ( a [ i ] , s . get ( a [ i ] ) == null ? 1 : s . get ( a [ i ] ) + 1 ) ; } return s . size ( ) ; }
int minimumSets ( String s , int y ) { int cnt = 0 ; int num = 0 ; int l = s . length ( ) ; boolean f = false ; for ( int i = 0 ; i < l ; i ++ ) { num = num * 10 + ( s . charAt ( i ) - '0' ) ; if ( num <= y ) f = true ; { if ( f ) cnt += 1 ; num = s . charAt ( i ) - '0' ; f = false ; if ( num <= y ) f = true ; else num = 0 ; } } if ( f == true ) cnt += 1 ; return cnt ; }
void ModifiedArray ( int a [ ] , int n ) { int l = 0 , r = Integer . MAX_VALUE ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n / 2 ; i ++ ) { b [ i ] = Math . max ( l , a [ i ] - r ) ; b [ n - i - 1 ] = a [ i ] - b [ i ] ; l = b [ i ] ; r = b [ n - i - 1 ] ; } printArr ( b , n ) ; }
int greatestKBits ( int X , int K ) { int set_bit_count = Integer . bitCount ( X ) ; if ( set_bit_count <= K ) return X ; int diff = set_bit_count - K ; for ( int i = 0 ; i < diff ; i ++ ) X &= ( X - 1 ) ; return X ; }
int minItems ( int k , int r ) { for ( int i = 1 ; i < 10 ; i ++ ) if ( ( i * k - r ) % 10 == 0 || ( i * k ) % 10 == 0 ) return i ; return 10 ; }
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int maxSum ( int a [ ] , int n ) { int S = 0 ; int S1 = maxSubArraySum ( a , n ) ; for ( int i = 0 ; i < n ; i ++ ) S += a [ i ] ; return ( 2 * S1 - S ) ; }
void check_distribution ( int n , int k , int age [ ] , int candy [ ] ) { int mxage = age [ 0 ] ; for ( int i = 0 ; i < age . length ; i ++ ) { if ( mxage < age [ i ] ) { mxage = age [ i ] ; } } int mxcandy = candy [ 0 ] ; for ( int i = 0 ; i < candy . length ; i ++ ) { if ( mxcandy < candy [ i ] ) { mxcandy = candy [ i ] ; } } int fr1 [ ] = new int [ mxage + 1 ] ; Arrays . fill ( fr1 , 0 ) ; int fr2 [ ] = new int [ mxcandy + 1 ] ; Arrays . fill ( fr2 , 0 ) ; for ( int j = 0 ; j < n ; j ++ ) { fr1 [ age [ j ] ] += 1 ; } for ( int j = 0 ; j < k ; j ++ ) { fr2 [ candy [ j ] ] += 1 ; } k = 0 ; boolean Tf = true ; for ( int j = 0 ; j < mxage ; j ++ ) { if ( fr1 [ j ] == 0 ) continue ; boolean flag = false ; while ( k < mxcandy ) { if ( fr1 [ j ] <= fr2 [ k ] ) { flag = true ; break ; } k += 1 ; } k = k + 1 ; if ( flag == false ) { Tf = false ; break ; } } if ( Tf ) System . out . println ( "YES" ) ; else System . out . println ( "NO" ) ; }
int check ( int n , List < Integer > marks ) { Integer x = Collections . max ( marks ) ; int bonus = 100 - x ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( marks . get ( i ) + bonus >= 50 ) c += 1 ; } return c ; }
int find_sum ( int n , int k ) { int total_sum = ( n * ( n + 1 ) ) / 2 ; int power = k ; while ( power <= n ) { total_sum -= power ; power *= k ; } return total_sum ; }
void findTwoNumbers ( int sum , int gcd ) { if ( __gcd ( gcd , sum - gcd ) == gcd && sum != gcd ) System . out . println ( "a = " + Math . min ( gcd , sum - gcd ) + ", b = " + ( int ) ( sum - Math . min ( gcd , sum - gcd ) ) ) ; else System . out . println ( - 1 ) ; }
void maxLitres ( int budget , int plastic , int glass , int refund ) { if ( glass - refund < plastic ) { int ans = Math . max ( ( budget - refund ) / ( glass - refund ) , 0 ) ; budget -= ans * ( glass - refund ) ; ans += budget / plastic ; System . out . println ( ans ) ; } else { System . out . println ( ( budget / plastic ) ) ; } }
void smallestPermute ( int n ) { char res [ ] = new char [ n + 1 ] ; if ( n % 2 == 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = ( char ) ( 48 + i + 2 ) ; else res [ i ] = ( char ) ( 48 + i ) ; } } else { for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = ( char ) ( 48 + i + 2 ) ; else res [ i ] = ( char ) ( 48 + i ) ; } res [ n - 1 ] = ( char ) ( 48 + n - 2 ) ; res [ n - 2 ] = ( char ) ( 48 + n ) ; res [ n - 3 ] = ( char ) ( 48 + n - 1 ) ; } res [ n ] = '\0' ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( res [ i ] ) ; } }
int leastValue ( int P , int A , int N , int a [ ] ) { int ans = - 1 ; float tmp = Float . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { float t = ( float ) ( P - a [ i ] * 0.006 ) ; if ( Math . abs ( t - A ) < tmp ) { tmp = Math . abs ( t - A ) ; ans = i ; } } return a [ ans ] ; }
int minOperations ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) hashTable [ arr [ i ] ] ++ ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hashTable [ arr [ i ] ] != 0 ) { for ( int j = i ; j < n ; j ++ ) if ( arr [ j ] % arr [ i ] == 0 ) hashTable [ arr [ j ] ] = 0 ; res ++ ; } } return res ; }
int minInsertions ( int [ ] H , int n , int K ) { int inser = 0 ; for ( int i = 1 ; i < n ; ++ i ) { float diff = Math . abs ( H [ i ] - H [ i - 1 ] ) ; if ( diff <= K ) continue ; else inser += Math . ceil ( diff / K ) - 1 ; } return inser ; }
int minCost ( int N , int P , int Q ) { int cost = 0 ; while ( N > 0 ) { if ( ( N & 1 ) > 0 ) { cost += P ; N -- ; } else { int temp = N / 2 ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N /= 2 ; } } return cost ; }
int count_minimum_operations ( long n ) { int count = 0 ; while ( n > 1 ) { if ( n % 3 == 0 ) n /= 3 ; else if ( n % 3 == 1 ) n -- ; else { if ( n == 2 ) n -- ; else n ++ ; } count ++ ; } return count ; }
int count_minimum_operations ( int n ) { if ( n == 2 ) { return 1 ; } else if ( n == 1 ) { return 0 ; } if ( n % 3 == 0 ) { return 1 + count_minimum_operations ( n / 3 ) ; } else if ( n % 3 == 1 ) { return 1 + count_minimum_operations ( n - 1 ) ; } else { return 1 + count_minimum_operations ( n + 1 ) ; } }
int findPermutation ( int n ) { int len = ( int ) Math . ceil ( Math . log10 ( n ) ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( n % 2 != 0 ) { return n ; } else { n = ( n / 10 ) + ( n % 10 ) * ( int ) Math . pow ( 10 , len - i - 1 ) ; continue ; } } return - 1 ; }
int maxMatrixScore ( int A [ ] [ ] , int K ) { HashMap < Integer , Integer > update = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] [ 0 ] == 0 ) { int ans = 0 ; for ( int j = 1 ; j < m ; ++ j ) ans = ( int ) ( ans + A [ i ] [ j ] * Math . pow ( 2 , m - j - 1 ) ) ; update . put ( ans , i ) ; } } for ( Map . Entry < Integer , Integer > it : update . entrySet ( ) ) if ( K > 0 ) { int idx = it . getValue ( ) ; for ( int j = 0 ; j < m ; ++ j ) A [ idx ] [ j ] = ( A [ idx ] [ j ] + 1 ) % 2 ; K -- ; } int ans = 0 ; for ( int j = 0 ; j < m ; ++ j ) { int zero = 0 , one = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] [ j ] == 0 ) zero ++ ; else one ++ ; } if ( K > 0 && zero > one ) { ans += zero * Math . pow ( 2 , m - j - 1 ) ; K -- ; } else ans += one * Math . pow ( 2 , m - j - 1 ) ; } return ans ; }
boolean isSellingPossible ( int n , int a [ ] ) { int i , c25 = 0 , c50 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 25 ) c25 ++ ; else if ( a [ i ] == 50 ) { c50 ++ ; if ( c25 == 0 ) break ; c25 -- ; } else { if ( c50 > 0 && c25 > 0 ) { c50 -- ; c25 -- ; } else if ( c25 >= 3 ) c25 -= 3 ; else break ; } } if ( i == n ) return true ; else return false ; }
long cal_minimum_time ( long X ) { long t = 0 ; long sum = 0 ; while ( sum < X ) { t ++ ; sum = sum + t ; } return t ; }
int countMinSwaps ( String s ) { int N = s . length ( ) ; int one = 0 ; int zero = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == '1' ) one ++ ; else zero ++ ; } if ( one > zero + 1 zero > one + 1 ) return - 1 ; if ( N % 2 == 1 ) { int num = ( N + 1 ) / 2 ; int one_even = 0 , zero_even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { if ( s . charAt ( i ) == '1' ) one_even ++ ; else zero_even ++ ; } } if ( one > zero ) return num - one_even ; else return num - zero_even ; } else { int one_odd = 0 , one_even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == '1' ) { if ( i % 2 == 1 ) one_odd ++ ; else one_even ++ ; } } return Math . min ( N / 2 - one_odd , N / 2 - one_even ) ; } }
int minDiff ( int n , int x , int A [ ] ) { int mn = A [ 0 ] , mx = A [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) { mn = Math . min ( mn , A [ i ] ) ; mx = Math . max ( mx , A [ i ] ) ; } return Math . max ( 0 , mx - mn - 2 * x ) ; }
void LengthLCP ( String x , String y ) { int fr [ ] = new int [ 26 ] ; for ( int i = 0 ; i < b ; i ++ ) { fr [ y . charAt ( i ) - 97 ] += 1 ; } int c = 0 ; for ( int i = 0 ; i < a ; i ++ ) { if ( fr [ x . charAt ( i ) - 97 ] > 0 ) { c += 1 ; fr [ x . charAt ( i ) - 97 ] -= 1 ; } else break ; } System . out . println ( ( c ) ) ; }
boolean checkIfOverlap ( String str ) { int len = str . length ( ) ; int [ ] visited = new int [ len + 1 ] ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '.' ) continue ; for ( int j = Math . max ( 0 , i - str . charAt ( i ) ) ; j <= Math . min ( len , i + str . charAt ( i ) ) ; j ++ ) visited [ j ] ++ ; } for ( int i = 0 ; i < len ; i ++ ) { if ( visited [ i ] > 1 ) { return true ; } } return false ; }
boolean isWaveArray ( int arr [ ] , int n ) { boolean result = true ; if ( arr [ 1 ] > arr [ 0 ] && arr [ 1 ] > arr [ 2 ] ) { for ( int i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } } if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] <= arr [ n - 2 ] ) { result = false ; } } } else if ( arr [ 1 ] < arr [ 0 ] && arr [ 1 ] < arr [ 2 ] ) { for ( int i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } } if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] >= arr [ n - 2 ] ) { result = false ; } } } return result ; }
void printCoins ( int arr [ ] , int n ) { int oddSum = 0 ; for ( int i = 0 ; i < n ; i += 2 ) oddSum += arr [ i ] ; int evenSum = 0 ; for ( int i = 1 ; i < n ; i += 2 ) evenSum += arr [ i ] ; int start = ( ( oddSum > evenSum ) ? 0 : 1 ) ; for ( int i = start ; i < n ; i += 2 ) System . out . print ( arr [ i ] + " " ) ; }
void countSubstrings ( String s ) { int ans = 0 ; int subs = 1 ; char pre = '0' ; for ( char i : s . toCharArray ( ) ) { if ( pre == i ) { subs += 1 ; } else { subs = 1 ; } ans += subs ; pre = i ; } System . out . println ( ans ) ; }
int find ( int i ) { while ( parent [ i ] != i ) i = parent [ i ] ; return i ; }
boolean isValidEdge ( int u , int v , boolean [ ] inMST ) { if ( u == v ) return false ; if ( inMST [ u ] == false && inMST [ v ] == false ) return false ; else if ( inMST [ u ] == true && inMST [ v ] == true ) return false ; return true ; }
int smallestSumSubarr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = - arr [ i ] ; int sum_here = arr [ 0 ] , max_sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum_here = Math . max ( sum_here + arr [ i ] , arr [ i ] ) ; max_sum = Math . max ( max_sum , sum_here ) ; } return ( - 1 ) * max_sum ; }
int [ ] [ ] solve ( int [ ] [ ] arr , int n ) { int [ ] [ ] ans = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { ans [ i ] [ j ] = arr [ j ] [ ( i + j ) % n ] ; } } return ans ; }
int [ ] [ ] makeArray ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; int c = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = c ++ ; } return arr ; }
void printLargest ( int a [ ] , int n ) { int max = - 1 ; int ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; while ( num > 0 ) { int r = num % 10 ; num = num / 10 ; if ( num == 0 ) { if ( max < r ) { max = r ; ind = i ; } } } } for ( int i = ind ; i < n ; i ++ ) System . out . print ( a [ i ] ) ; for ( int i = 0 ; i < ind ; i ++ ) System . out . print ( a [ i ] ) ; }
int findMinimumAdjacentSwaps ( int arr [ ] , int N ) { boolean [ ] visited = new boolean [ N + 1 ] ; int minimumSwaps = 0 ; Arrays . fill ( visited , false ) ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ; int count = 0 ; for ( int j = i + 1 ; j < 2 * N ; j ++ ) { if ( visited [ arr [ j ] ] == false ) count ++ ; else if ( arr [ i ] == arr [ j ] ) minimumSwaps += count ; } } } return minimumSwaps ; }
int DecreasingArray ( int a [ ] , int n ) { int sum = 0 , dif = 0 ; PriorityQueue < Integer > pq = new PriorityQueue < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! pq . isEmpty ( ) && pq . element ( ) < a [ i ] ) { dif = a [ i ] - pq . element ( ) ; sum += dif ; pq . remove ( ) ; } pq . add ( a [ i ] ) ; } return sum ; }
boolean ifPossible ( int arr [ ] , int n ) { int copy [ ] = Arrays . copyOf ( arr , arr . length ) ; Arrays . sort ( copy ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == copy [ i ] ) && ! ( arr [ n - 1 - i ] == copy [ i ] ) ) return false ; } return true ; }
int findMinRooms ( String slots [ ] , int n , int m ) { int counts [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) counts [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] . charAt ( j ) == '1' ) counts [ j ] ++ ; int max = - 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ; return max ; }
int MinOperation ( int a [ ] , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + Math . min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; }
int maxProductSubset ( int a [ ] , int n ) { if ( n == 1 ) { return a [ 0 ] ; } int max_neg = Integer . MIN_VALUE ; int count_neg = 0 , count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = Math . max ( max_neg , a [ i ] ) ; } prod = prod * a [ i ] ; } if ( count_zero == n ) { return 0 ; } if ( count_neg % 2 == 1 ) { if ( count_neg == 1 && count_zero > 0 && count_zero + count_neg == n ) { return 0 ; } prod = prod / max_neg ; } return prod ; }
Vector < String > preProcess ( int n ) { Vector < String > preProcessedCubes = new Vector < > ( ) ; for ( int i = 1 ; i * i * i <= n ; i ++ ) { int iThCube = i * i * i ; String cubeString = String . valueOf ( iThCube ) ; preProcessedCubes . add ( cubeString ) ; } return preProcessedCubes ; }
int solve ( int a [ ] , int b [ ] , int n ) { int i ; int s = 0 ; for ( i = 0 ; i < n ; i ++ ) s += ( a [ i ] + b [ i ] ) ; if ( n == 1 ) return a [ 0 ] + b [ 0 ] ; if ( s % n != 0 ) return - 1 ; int x = s / n ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) return - 1 ; if ( i > 0 ) { a [ i ] += b [ i - 1 ] ; b [ i - 1 ] = 0 ; } if ( a [ i ] == x ) continue ; int y = a [ i ] + b [ i ] ; if ( i + 1 < n ) y += b [ i + 1 ] ; if ( y == x ) { a [ i ] = y ; b [ i ] = 0 ; continue ; } if ( a [ i ] + b [ i ] == x ) { a [ i ] += b [ i ] ; b [ i ] = 0 ; continue ; } if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) { a [ i ] += b [ i + 1 ] ; b [ i + 1 ] = 0 ; continue ; } return - 1 ; } for ( i = 0 ; i < n ; i ++ ) if ( b [ i ] != 0 ) return - 1 ; return x ; }
void calcFiboTerms ( ArrayList < Integer > fiboterms , int k ) { int i = 3 , nextTerm = 0 ; fiboterms . add ( 0 ) ; fiboterms . add ( 1 ) ; fiboterms . add ( 1 ) ; while ( true ) { nextTerm = fiboterms . get ( i - 1 ) + fiboterms . get ( i - 2 ) ; if ( nextTerm > k ) return ; fiboterms . add ( nextTerm ) ; i ++ ; } }
void survival ( int S , int N , int M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) M > N ) System . out . println ( "No" ) ; else { int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; System . out . println ( "Yes " + days ) ; } }
void findTwoGroup ( int n ) { int sum = n * ( n + 1 ) / 2 ; int group1Sum = sum / 2 ; Vector < Integer > group1 = new Vector < Integer > ( ) ; Vector < Integer > group2 = new Vector < Integer > ( ) ; for ( int i = n ; i > 0 ; i -- ) { if ( group1Sum - i >= 0 ) { group1 . add ( i ) ; group1Sum -= i ; } else { group2 . add ( i ) ; } } printVector ( group1 ) ; printVector ( group2 ) ; }
int cost ( int [ ] a , int n ) { int min = a [ 0 ] ; for ( int i = 1 ; i < a . length ; i ++ ) { if ( a [ i ] < min ) min = a [ i ] ; } return ( n - 1 ) * min ; }
int winner ( int a [ ] , int n , int k ) { if ( k >= n - 1 ) return n ; int best = 0 , times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i == 1 ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; }
int minproduct ( int a [ ] , int b [ ] , int n , int k ) { int diff = 0 , res = 0 ; int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; int d = Math . abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }
int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ; while ( input > 0 unlock_code > 0 ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += Math . min ( Math . abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit - code_digit ) ) ; input /= 10 ; unlock_code /= 10 ; } return rotation ; }
void findWaitingTime ( Process proc [ ] , int n , int wt [ ] ) { int rt [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) rt [ i ] = proc [ i ] . bt ; int complete = 0 , t = 0 , minm = Integer . MAX_VALUE ; int shortest = 0 , finish_time ; boolean check = false ; while ( complete != n ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( proc [ j ] . art <= t ) && ( rt [ j ] < minm ) && rt [ j ] > 0 ) { minm = rt [ j ] ; shortest = j ; check = true ; } } if ( check == false ) { t ++ ; continue ; } rt [ shortest ] -- ; minm = rt [ shortest ] ; if ( minm == 0 ) minm = Integer . MAX_VALUE ; if ( rt [ shortest ] == 0 ) { complete ++ ; check = false ; finish_time = t + 1 ; wt [ shortest ] = finish_time - proc [ shortest ] . bt - proc [ shortest ] . art ; if ( wt [ shortest ] < 0 ) wt [ shortest ] = 0 ; } t ++ ; } }
void findTurnAroundTime ( Process proc [ ] , int n , int wt [ ] , int tat [ ] ) { for ( int i = 0 ; i < n ; i ++ ) tat [ i ] = proc [ i ] . bt + wt [ i ] ; }
int minCost ( int coin [ ] , int n , int k ) { Arrays . sort ( coin ) ; int coins_needed = ( int ) Math . ceil ( 1.0 * n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }
void preprocess ( int [ ] coin , int n ) { Arrays . sort ( coin ) ; for ( int i = 1 ; i <= n - 1 ; i ++ ) coin [ i ] += coin [ i - 1 ] ; }
int minCost ( int [ ] coin , int n , int k ) { int coins_needed = ( int ) Math . ceil ( 1.0 * n / ( k + 1 ) ) ; return coin [ coins_needed - 1 ] ; }
void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } int temp ; for ( int j = pos ; j > i ; -- j ) { temp = arr [ j ] ; arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = temp ; } k -= pos - i ; } }
int minimumSquare ( int a , int b ) { int result = 0 , rem = 0 ; if ( a < b ) swap ( a , b ) ; while ( b > 0 ) { result += a / b ; rem = a % b ; a = b ; b = rem ; } return result ; }
int minimumCostOfBreaking ( Integer X [ ] , Integer Y [ ] , int m , int n ) { int res = 0 ; Arrays . sort ( X , Collections . reverseOrder ( ) ) ; Arrays . sort ( Y , Collections . reverseOrder ( ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; }
int maximumSum ( int arr [ ] , int n , int k ) { for ( int i = 1 ; i <= k ; i ++ ) { int min = + 2147483647 ; int index = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
int maximizeSum ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int i = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( k != 0 && arr [ i ] < 0 ) { arr [ i ] *= - 1 ; k -- ; continue ; } break ; } if ( i == n ) i -- ; if ( k == 0 k % 2 == 0 ) { return sumArray ( arr , n ) ; } if ( i != 0 && Math . abs ( arr [ i ] ) >= Math . abs ( arr [ i - 1 ] ) ) { i -- ; } arr [ i ] *= - 1 ; return sumArray ( arr , n ) ; }
void findLargest ( int m , int s ) { if ( s == 0 ) { System . out . print ( m == 1 ? "Largest number is 0" : "Not possible" ) ; return ; } if ( s > 9 * m ) { System . out . println ( "Not possible" ) ; return ; } int [ ] res = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { if ( s >= 9 ) { res [ i ] = 9 ; s -= 9 ; } else { res [ i ] = s ; s = 0 ; } } System . out . print ( "Largest number is " ) ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( res [ i ] ) ; }
int getMax ( int arr [ ] , int n ) { int result = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > result ) result = arr [ i ] ; return result ; }
boolean isPossible ( int time , int K , int job [ ] , int n ) { int cnt = 1 ; int curr_time = 0 ; for ( int i = 0 ; i < n ; ) { if ( curr_time + job [ i ] > time ) { curr_time = 0 ; cnt ++ ; } else { curr_time += job [ i ] ; i ++ ; } } return ( cnt <= K ) ; }
int findMinTime ( int K , int T , int job [ ] , int n ) { int end = 0 , start = 0 ; for ( int i = 0 ; i < n ; ++ i ) end += job [ i ] ; int ans = end ; int job_max = getMax ( job , n ) ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( mid >= job_max && isPossible ( mid , K , job , n ) ) { ans = Math . min ( ans , mid ) ; end = mid - 1 ; } else start = mid + 1 ; } return ( ans * T ) ; }
void findMin ( int V ) { Vector < Integer > ans = new Vector < > ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( V >= deno [ i ] ) { V -= deno [ i ] ; ans . add ( deno [ i ] ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( " " + ans . elementAt ( i ) ) ; } }
int maxDiffSum ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int maxVal = arr [ i ] , minVal = arr [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { minVal = Math . min ( minVal , arr [ j ] ) ; maxVal = Math . max ( maxVal , arr [ j ] ) ; if ( j - 1 >= 0 ) dp [ i ] = Math . max ( dp [ i ] , maxVal - minVal + dp [ j - 1 ] ) ; else dp [ i ] = Math . max ( dp [ i ] , maxVal - minVal ) ; } } return dp [ n - 1 ] ; }
long modPow ( long x , long y ) { long r = 1 , a = x ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) { r = ( r * a ) % MOD ; } a = ( a * a ) % MOD ; y /= 2 ; } return r ; }
long modInverse ( long x ) { return modPow ( x , MOD - 2 ) ; }
long modDivision ( long p , long q ) { return ( p * modInverse ( q ) ) % MOD ; }
long C ( long n , int k ) { if ( k > n ) { return 0 ; } long p = 1 , q = 1 ; for ( int i = 1 ; i <= k ; i ++ ) { q = ( q * i ) % MOD ; p = ( p * ( n - i + 1 ) ) % MOD ; } return modDivision ( p , q ) ; }
long countArrays ( int N , int K ) { long res = 1 ; for ( int p = 2 ; p <= K / p ; p ++ ) { int c = 0 ; while ( K % p == 0 ) { K /= p ; c ++ ; } res = ( res * C ( N - 1 + c , c ) ) % MOD ; } if ( N > 1 ) { res = ( res * N ) % MOD ; } return res ; }
int minSessions ( int [ ] codeTime , int [ ] [ ] dp , int ones , int n , int mask , int currTime , int WorkingSessionTime ) { if ( currTime > WorkingSessionTime ) return Integer . MAX_VALUE ; if ( mask == ones ) return 1 ; if ( dp [ mask ] [ currTime ] != - 1 ) return dp [ mask ] [ currTime ] ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( mask & ( 1 << i ) ) == 0 ) { int inc = minSessions ( codeTime , dp , ones , n , mask | ( 1 << i ) , currTime + codeTime [ i ] , WorkingSessionTime ) ; int inc_next = 1 + minSessions ( codeTime , dp , ones , n , mask | ( 1 << i ) , codeTime [ i ] , WorkingSessionTime ) ; ans = Math . min ( ans , Math . min ( inc , inc_next ) ) ; } } return dp [ mask ] [ currTime ] = ans ; }
int solve ( int [ ] codeTime , int n , int WorkingSessionTime ) { int [ ] [ ] dp = new int [ ( 1 << 14 ) ] [ ] ; for ( int i = 0 ; i < 1 << 14 ; i ++ ) { dp [ i ] = new int [ 15 ] ; Arrays . fill ( dp [ i ] , - 1 ) ; } int ones = ( 1 << n ) - 1 ; int ans = minSessions ( codeTime , dp , ones , n , 0 , 0 , WorkingSessionTime ) ; if ( WorkingSessionTime < 6 ) { if ( ans % 2 == 0 ) ans = ans / 2 ; else ans = ( ans / 2 ) + 1 ; } return ans ; }
int solve ( int len , int gap ) { if ( dp [ len ] [ gap ] != - 1 ) { return dp [ len ] [ gap ] ; } if ( len == 0 gap == 0 ) { return 1 ; } if ( gap < 0 ) { return 0 ; } int ans = 0 ; for ( int i = 0 ; i <= gap ; i ++ ) { ans += solve ( len - 1 , gap - i ) ; } return dp [ len ] [ gap ] = ans ; }
int countValidStrings ( String S ) { for ( int i = 0 ; i < MAXN ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } int N = S . length ( ) ; int L = 1 , R = 9 ; int cnt = 0 ; int ans = 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . charAt ( i ) != '?' ) { R = S . charAt ( i ) - '0' ; ans *= solve ( cnt , R - L ) ; L = R ; R = 9 ; cnt = 0 ; } else { cnt ++ ; } } ans *= solve ( cnt , R - L ) ; return ans ; }
int recBananaCnt ( int A , int B , int C ) { if ( B <= A ) { return 0 ; } if ( B <= C ) { return B - A ; } if ( A == 0 ) { return B ; } if ( dp [ A ] [ B ] != - 1 ) { return dp [ A ] [ B ] ; } int maxCount = Integer . MIN_VALUE ; int tripCount = B % C == 0 ? ( ( 2 * B ) / C ) - 1 : ( ( 2 * B ) / C ) + 1 ; for ( int i = 1 ; i <= A ; i ++ ) { int curCount = recBananaCnt ( A - i , B - tripCount * i , C ) ; if ( curCount > maxCount ) { maxCount = curCount ; dp [ A ] [ B ] = maxCount ; } } return maxCount ; }
int maxBananaCnt ( int A , int B , int C ) { for ( int i = 0 ; i < 1001 ; i ++ ) for ( int j = 0 ; j < 3001 ; j ++ ) dp [ i ] [ j ] = - 1 ; return recBananaCnt ( A , B , C ) ; }
int combinationsPossible ( int N , int idx , int prev , int val , int K , int [ ] [ ] [ ] dp ) { if ( val > K ) { return 0 ; } if ( dp [ val ] [ idx ] [ prev ] != - 1 ) { return dp [ val ] [ idx ] [ prev ] ; } if ( idx == N - 1 ) { if ( val == K ) { return 1 ; } return 0 ; } int ans = 0 ; if ( prev == 1 ) { ans += combinationsPossible ( N , idx + 1 , 1 , val + 1 , K , dp ) ; ans += combinationsPossible ( N , idx + 1 , 0 , val , K , dp ) ; } else { ans += combinationsPossible ( N , idx + 1 , 1 , val , K , dp ) ; ans += combinationsPossible ( N , idx + 1 , 0 , val , K , dp ) ; } dp [ val ] [ idx ] [ prev ] = ans ; return dp [ val ] [ idx ] [ prev ] ; }
int countArray ( int arr [ ] , int N , int M ) { int [ ] [ ] dp = new int [ N ] [ M + 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M + 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } if ( arr [ 0 ] == - 1 ) { for ( int j = 1 ; j <= M ; j ++ ) { dp [ 0 ] [ j ] = 1 ; } } else { dp [ 0 ] [ arr [ 0 ] ] = 1 ; } for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != - 1 ) { int j = arr [ i ] ; dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j + 1 ] ; } if ( arr [ i ] == - 1 ) { for ( int j = 1 ; j <= M ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j + 1 ] ; } } } int arrCount = 0 ; for ( int j = 1 ; j <= M ; j ++ ) { arrCount += dp [ N - 1 ] [ j ] ; } return arrCount ; }
int minChangeInLane ( int barrier [ ] , int n ) { int dp [ ] = { 1 , 0 , 1 } ; for ( int j = 0 ; j < n ; j ++ ) { int val = barrier [ j ] ; if ( val > 0 ) { dp [ val - 1 ] = ( int ) 1e6 ; } for ( int i = 0 ; i < 3 ; i ++ ) { if ( val != i + 1 ) { dp [ i ] = Math . min ( dp [ i ] , Math . min ( dp [ ( i + 1 ) % 3 ] , dp [ ( i + 2 ) % 3 ] ) + 1 ) ; } } } return Math . min ( dp [ 0 ] , Math . min ( dp [ 1 ] , dp [ 2 ] ) ) ; }
int calculate ( int position , int used , int unused , int P , int M , int dp [ ] [ ] [ ] ) { if ( position == P ) { return unused == 0 ? 1 : 0 ; } if ( dp [ position ] [ used ] [ unused ] != - 1 ) return dp [ position ] [ used ] [ unused ] ; int result = 0 ; if ( unused > 0 ) { result += calculate ( position + 1 , used + 1 , unused - 1 , P , M , dp ) * unused ; } if ( used > M ) { result += calculate ( position + 1 , used , unused , P , M , dp ) * ( used - M ) ; } return dp [ position ] [ used ] [ unused ] = result ; }
int solve ( int N , int P , int M ) { int [ ] [ ] [ ] dp = new int [ 101 ] [ 101 ] [ 101 ] ; for ( int i = 0 ; i < 101 ; i ++ ) { for ( int j = 0 ; j < 101 ; j ++ ) for ( int k = 0 ; k < 101 ; k ++ ) dp [ i ] [ j ] [ k ] = - 1 ; } return calculate ( 0 , 0 , N , P , M , dp ) ; }
int maxMergingScore ( int A [ ] , int N ) { int [ ] [ ] dp = new int [ 101 ] [ 101 ] ; for ( int i = 0 ; i < 101 ; i ++ ) { { for ( int j = 0 ; j < 101 ; j ++ ) dp [ i ] [ j ] = 0 ; } } for ( int len = 1 ; len < N ; ++ len ) { for ( int i = 0 ; i + len < N ; ++ i ) { int j = i + len ; dp [ i ] [ j ] = 0 ; for ( int k = i + 1 ; k < j ; ++ k ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k ] [ j ] + A [ i ] * A [ j ] ) ; } } } return dp [ 0 ] [ N - 1 ] ; }
int getMin ( int x , int y , int z ) { return Math . min ( Math . min ( x , y ) , z ) ; }
int editDistance ( String str1 , String str2 , int m , int n ) { int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else { dp [ i ] [ j ] = 1 + getMin ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } } } return dp [ m ] [ n ] ; }
void minimumSteps ( String S , int N ) { int ans = Integer . MAX_VALUE ; for ( int i = 1 ; i < N ; i ++ ) { String S1 = S . substring ( 0 , i ) ; String S2 = S . substring ( i ) ; int count = editDistance ( S1 , S2 , S1 . length ( ) , S2 . length ( ) ) ; ans = Math . min ( ans , count ) ; } System . out . print ( ans ) ; }
int countOfWays ( int arr [ ] , int N ) { int pre [ ] = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { pre [ i + 1 ] = pre [ i ] + arr [ i ] ; } int dp [ ] [ ] = new int [ N + 2 ] [ N + 2 ] ; dp [ 1 ] [ 0 ] ++ ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N ; j >= 1 ; j -- ) { dp [ j + 1 ] [ pre [ i + 1 ] % ( j + 1 ) ] += dp [ j ] [ pre [ i + 1 ] % j ] ; if ( i == N - 1 ) { ans += dp [ j ] [ pre [ i + 1 ] % j ] ; } } } return ans ; }
void minimumDifference ( int arr [ ] , Query q [ ] , int N , int m ) { int [ ] diff = new int [ N ] ; for ( int i = 0 ; i < N - 1 ; i ++ ) diff [ i ] = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; minDifference ( diff , N - 1 , q , m ) ; }
int LongestOddEvenSubarray ( int A [ ] , int N ) { int dp [ ] = new int [ N ] ; dp [ 0 ] = 1 ; int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 0 && A [ i - 1 ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ i - 1 ] % 2 != 0 ) ) { dp [ i ] = dp [ i - 1 ] + 1 ; } else dp [ i ] = 1 ; } for ( int i = 0 ; i < N ; i ++ ) ans = Math . max ( ans , dp [ i ] ) ; return ans ; }
int minimumOperations ( int N ) { int [ ] dp = new int [ N + 1 ] ; int i ; for ( i = 0 ; i <= N ; i ++ ) { dp [ i ] = ( int ) 1e9 ; } dp [ 2 ] = 0 ; for ( i = 2 ; i <= N ; i ++ ) { if ( dp [ i ] == ( int ) 1e9 ) continue ; if ( i * 5 <= N ) { dp [ i * 5 ] = Math . min ( dp [ i * 5 ] , dp [ i ] + 1 ) ; } if ( i + 3 <= N ) { dp [ i + 3 ] = Math . min ( dp [ i + 3 ] , dp [ i ] + 1 ) ; } } if ( dp [ N ] == 1e9 ) return - 1 ; return dp [ N ] ; }
long numTilings ( int N ) { if ( N < 3 ) { return N ; } long [ ] [ ] dp = new long [ N + 1 ] [ 3 ] ; for ( long [ ] row : dp ) { Arrays . fill ( row , 0 ) ; } dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = dp [ 1 ] [ 2 ] = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 2 ] [ 0 ] + dp [ i - 2 ] [ 1 ] + dp [ i - 2 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 2 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) % MOD ; } return dp [ N ] [ 0 ] ; }
void SieveOfEratosthenes ( int n ) { prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } }
int countOfNumbers ( int index , int sum , int N ) { if ( index == N + 1 ) { if ( prime [ sum ] == true ) { return 1 ; } return 0 ; } int val = dp [ index ] [ sum ] ; if ( val != - 1 ) { return val ; } val = 0 ; if ( index == 1 ) { for ( int digit = ( N == 1 ? 0 : 1 ) ; digit <= 9 ; ++ digit ) { val += countOfNumbers ( index + 1 , sum + digit , N ) ; } } else { for ( int digit = 0 ; digit <= 9 ; ++ digit ) { val += countOfNumbers ( index + 1 , sum + digit , N ) ; } } return val ; }
int countStrings ( int N ) { if ( N == 1 ) return 0 ; if ( dp . containsKey ( N ) ) return dp . get ( N ) ; int ret = 0 ; for ( int div = 1 ; div <= Math . sqrt ( N ) ; div ++ ) { if ( N % div == 0 ) { ret += ( 1 << div ) - countStrings ( div ) ; int div2 = N / div ; if ( div2 != div && div != 1 ) ret += ( 1 << div2 ) - countStrings ( div2 ) ; } } dp . put ( N , ret ) ; return ret ; }
void countOfNumbers ( int N ) { int ans = 1 ; for ( int index = 1 ; index <= N ; ++ index ) { int choices = 0 ; for ( int digit = 1 ; digit <= 9 ; ++ digit ) { if ( index % digit == 0 ) { ++ choices ; } } ans = ( ans * choices ) % mod ; } System . out . println ( ans ) ; }
int MaxProfit ( int arr [ ] , int n , int transactionFee ) { int buy = - arr [ 0 ] ; int sell = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int temp = buy ; buy = Math . max ( buy , sell - arr [ i ] ) ; sell = Math . max ( sell , temp + arr [ i ] - transactionFee ) ; } return Math . max ( sell , buy ) ; }
int dfs ( int [ ] arr , int left , int K ) { int q = 0 ; if ( left == 0 ) { for ( int i = 1 ; i < K ; ++ i ) { if ( arr [ i ] > 0 ) { arr [ i ] -- ; q = Math . max ( q , 1 + dfs ( arr , K - i , K ) ) ; arr [ i ] ++ ; } } } else { for ( int i = 1 ; i < K ; ++ i ) { if ( arr [ i ] > 0 ) { arr [ i ] -- ; int nleft = ( i <= left ? left - i : K + left - i ) ; q = Math . max ( q , dfs ( arr , nleft , K ) ) ; arr [ i ] ++ ; } } } return q ; }
int dfs ( int [ ] V , int left , int K ) { int q = 0 ; String key = Arrays . toString ( V ) ; key += Integer . toString ( left ) ; if ( memo . containsKey ( key ) ) return memo . get ( key ) ; else if ( left == 0 ) { for ( int i = 1 ; i < K ; ++ i ) if ( V [ i ] > 0 ) { V [ i ] -- ; q = Math . max ( q , 1 + dfs ( V , K - i , K ) ) ; V [ i ] ++ ; } } else { for ( int i = 1 ; i < K ; ++ i ) { if ( V [ i ] > 0 ) { V [ i ] -- ; int nleft = i <= left ? left - i : K + left - i ; q = Math . max ( q , dfs ( V , nleft , K ) ) ; V [ i ] ++ ; } } } memo . put ( key , q ) ; return q ; }
int maxGroups ( int K , int [ ] arr ) { int V [ ] = new int [ K ] ; for ( int x : arr ) V [ x % K ] ++ ; memo = new HashMap < String , Integer > ( ) ; int ans = V [ 0 ] + dfs ( V , 0 , K ) ; return ans ; }
int countMinSteps ( String A , String B , int N ) { int [ ] dp = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; } for ( int i = 1 ; i <= N ; i ++ ) { if ( A . charAt ( i - 1 ) == B . charAt ( i - 1 ) ) { dp [ i ] = dp [ i - 1 ] ; } else { dp [ i ] = dp [ i - 1 ] + 1 ; } if ( i >= 2 && A . charAt ( i - 2 ) == B . charAt ( i - 1 ) && A . charAt ( i - 1 ) == B . charAt ( i - 2 ) ) { dp [ i ] = Math . min ( dp [ i ] , dp [ i - 2 ] + 1 ) ; } } return dp [ N ] ; }
void findMaxJumps ( int arr [ ] , int N ) { int dp [ ] = new int [ N ] ; int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { dp [ i ] = arr [ i ] ; int j = i + arr [ i ] ; if ( j < N ) { dp [ i ] = dp [ i ] + dp [ j ] ; } ans = Math . max ( ans , dp [ i ] ) ; } System . out . println ( ans ) ; }
void countNDigitNumber ( int N ) { for ( int i = 0 ; i < 50 ; i ++ ) { for ( int j = 0 ; j < 1 << 10 ; j ++ ) { for ( int k = 0 ; k < 2 ; k ++ ) { dp [ i ] [ j ] [ k ] = - 1 ; } } } System . out . println ( countOfNumbers ( 1 , 0 , 0 , N ) ) ; }
String getMaximum ( String S , String T ) { if ( S . indexOf ( "0" ) > - 1 ) return T ; if ( T . indexOf ( "0" ) > - 1 ) return S ; return S . length ( ) > T . length ( ) ? S : T ; }
String recursion ( int [ ] arr , int idx , int N , int K , Vector < Vector < String > > dp ) { if ( K == 0 ) { return "" ; } if ( K < 0 idx == N ) { return "0" ; } if ( dp . get ( idx ) . get ( K ) != "-1" ) return dp . get ( idx ) . get ( K ) ; String include = String . valueOf ( idx + 1 ) + recursion ( arr , 0 , N , K - arr [ idx ] , dp ) ; String exclude = recursion ( arr , idx + 1 , N , K , dp ) ; dp . get ( idx ) . set ( K , getMaximum ( include , exclude ) ) ; return dp . get ( idx ) . get ( K ) ; }
void longestSubsequence ( int [ ] arr , int N ) { int dp [ ] [ ] = new int [ N ] [ N + 1 ] ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < N + 1 ; ++ j ) { dp [ i ] [ j ] = - 1 ; } } for ( int i = 0 ; i < N ; ++ i ) { dp [ i ] [ 0 ] = 0 ; } dp [ 0 ] [ 1 ] = ( arr [ 0 ] >= 0 ? arr [ 0 ] : - 1 ) ; for ( int i = 1 ; i < N ; ++ i ) { for ( int j = 1 ; j <= ( i + 1 ) ; ++ j ) { if ( dp [ i - 1 ] [ j ] != - 1 ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; } if ( dp [ i - 1 ] [ j - 1 ] >= 0 && dp [ i - 1 ] [ j - 1 ] + arr [ i ] >= 0 ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] + arr [ i ] ) ; } } } int ans = 0 ; for ( int j = 0 ; j <= N ; ++ j ) { if ( dp [ N - 1 ] [ j ] >= 0 ) { ans = j ; } } System . out . println ( ans ) ; }
int Count ( int N , int L , int R ) { int [ ] [ ] dp = new int [ N ] [ R - L + 1 ] ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( int i = 1 ; i < dp [ 0 ] . length ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 1 ; } ans = dp [ 0 ] [ R - L ] ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < dp [ 0 ] . length ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; } ans += dp [ i ] [ R - L ] ; } return ans ; }
int largestCommonSubarray ( int [ ] [ ] arr , int n , int m ) { int dp [ ] [ ] = new int [ n ] [ m + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { dp [ i ] [ arr [ i ] [ j ] ] = j ; } } int ans = 1 ; int len = 1 ; for ( int i = 1 ; i < m ; i ++ ) { boolean check = true ; for ( int j = 1 ; j < n ; j ++ ) { if ( dp [ j ] [ arr [ 0 ] [ i - 1 ] ] + 1 != dp [ j ] [ arr [ 0 ] [ i ] ] ) { check = false ; break ; } } if ( check ) { len ++ ; ans = Math . max ( ans , len ) ; } else { len = 1 ; } } return ans ; }
int countOfNumbers ( int digit , int prev1 , int prev2 , int n ) { if ( digit == n + 1 ) { return 1 ; } int val = dp [ digit ] [ prev1 ] [ prev2 ] ; if ( val != - 1 ) { return val ; } val = 0 ; if ( digit == 1 ) { for ( int i = ( n == 1 ? 0 : 1 ) ; i <= 9 ; ++ i ) { val += countOfNumbers ( digit + 1 , i , prev1 , n ) ; } } else if ( digit == 2 ) { for ( int i = 0 ; i <= 9 ; ++ i ) { val += countOfNumbers ( digit + 1 , i , prev1 , n ) ; } } else { int mean = prev1 ; int current = ( 2 * mean ) - prev2 ; if ( current >= 0 && current <= 9 ) val += countOfNumbers ( digit + 1 , current , prev1 , n ) ; if ( ( current + 1 ) >= 0 && ( current + 1 ) <= 9 ) val += countOfNumbers ( digit + 1 , current + 1 , prev1 , n ) ; } return val ; }
int countOfNumbers ( int digit , int prev , int n ) { if ( digit == n + 1 ) { return 1 ; } int val = dp [ digit ] [ prev ] ; if ( val != - 1 ) { return val ; } val = 0 ; if ( digit == 1 ) { for ( int i = ( n == 1 ? 0 : 1 ) ; i <= 9 ; ++ i ) { val += countOfNumbers ( digit + 1 , i , n ) ; } } else { for ( int i = 0 ; i <= 9 ; ++ i ) { if ( ( i & prev ) == 0 ) { val += countOfNumbers ( digit + 1 , i , n ) ; } } } return val ; }
int totalSubarrays ( int arr [ ] , int n , int k ) { int ans = 0 , i = 0 ; while ( i < n ) { if ( arr [ i ] > k ) { i ++ ; continue ; } int count = 0 ; while ( i < n && arr [ i ] <= k ) { i ++ ; count ++ ; } ans += ( ( count * ( count + 1 ) ) / 2 ) ; } return ans ; }
int countSubarrays ( int arr [ ] , int n , int k ) { int count1 = totalSubarrays ( arr , n , k - 1 ) ; int count2 = totalSubarrays ( arr , n , k ) ; int ans = count2 - count1 ; return ans ; }
int MaximumSum ( int a [ ] , int b [ ] , int n ) { int [ ] [ ] dp = new int [ n ] [ 2 ] ; dp [ 0 ] [ 0 ] = a [ 0 ] ; dp [ 0 ] [ 1 ] = b [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i ] ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) ; if ( i - 2 >= 0 ) { dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , Math . max ( dp [ i - 2 ] [ 0 ] , dp [ i - 2 ] [ 1 ] ) + b [ i ] ) ; } else { dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , b [ i ] ) ; } } return Math . max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; }
int numberOfArrays ( int n , int l ) { int [ ] [ ] dp = new int [ l + 1 ] [ n + 1 ] ; dp [ 0 ] [ 1 ] = 1 ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { for ( int k = j ; k <= n ; k += j ) { dp [ i + 1 ] [ k ] += dp [ i ] [ j ] ; } } } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ans += dp [ l ] [ i ] ; } return ans ; }
int waysOfDecoding ( String s ) { long [ ] dp = new long [ s . length ( ) + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = s . charAt ( 0 ) == '*' ? 9 : s . charAt ( 0 ) == '0' ? 0 : 1 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '*' ) { dp [ i + 1 ] = 9 * dp [ i ] ; if ( s . charAt ( i - 1 ) == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ; else if ( s . charAt ( i - 1 ) == '2' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ; else if ( s . charAt ( i - 1 ) == '*' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else { dp [ i + 1 ] = s . charAt ( i ) != '0' ? dp [ i ] : 0 ; if ( s . charAt ( i - 1 ) == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s . charAt ( i - 1 ) == '2' && s . charAt ( i ) <= '6' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s . charAt ( i - 1 ) == '*' ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s . charAt ( i ) <= '6' ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return ( int ) dp [ s . length ( ) ] ; }
int KvisibleFromLeft ( int N , int K ) { if ( dp [ N ] [ K ] != - 1 ) return dp [ N ] [ K ] ; if ( N == K ) return dp [ N ] [ K ] = 1 ; if ( K == 1 ) { int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) ans *= i ; return dp [ N ] [ K ] = ans ; } return dp [ N ] [ K ] = KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) ; }
int minimumDeletions ( int A [ ] , int N ) { int ans = Integer . MAX_VALUE ; for ( int i = 1 ; i < ( 1 << N ) ; i ++ ) { ArrayList < Integer > temp = new ArrayList < Integer > ( ) ; for ( int j = 0 ; j < N ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) { temp . add ( A [ j ] ) ; } } int flag = 0 ; for ( int j = 1 ; j < temp . size ( ) ; j ++ ) if ( temp . get ( j ) < temp . get ( j - 1 ) ) flag = 1 ; for ( int j = 1 ; j < temp . size ( ) - 1 ; j ++ ) if ( temp . get ( j ) - temp . get ( j - 1 ) > temp . get ( j + 1 ) - temp . get ( j ) ) flag = 1 ; if ( flag == 0 ) { ans = Math . min ( ans , N - ( int ) temp . size ( ) ) ; } } return ans ; }
int kvowelwords ( int N , int K ) { int i , j ; int MOD = 1000000007 ; int [ ] [ ] dp = new int [ N + 1 ] [ K + 1 ] ; int sum = 1 ; for ( i = 1 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = sum * 21 ; dp [ i ] [ 0 ] %= MOD ; sum = dp [ i ] [ 0 ] ; for ( j = 1 ; j <= K ; j ++ ) { if ( j > i ) dp [ i ] [ j ] = 0 ; else if ( j == i ) { dp [ i ] [ j ] = power ( 5 , i , MOD ) ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] * 5 ; } dp [ i ] [ j ] %= MOD ; sum += dp [ i ] [ j ] ; sum %= MOD ; } } return sum ; }
int maximumSum ( int [ ] A , int N , int K , int D ) { int ans = 0 ; for ( int i = 0 ; i < ( 1 << N ) ; i ++ ) { int sum = 0 ; int c = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( ( i >> j & 1 ) != 0 ) { sum += A [ j ] ; c ++ ; } } if ( sum % D == 0 && c <= K ) ans = Math . max ( ans , sum ) ; } return ans ; }
int maxSumWO3Consec ( int A [ ] , int N ) { if ( N == 1 ) return A [ 0 ] ; if ( N == 2 ) return A [ 0 ] + A [ 1 ] ; int third = A [ 0 ] ; int second = third + A [ 1 ] ; int first = Math . max ( second , A [ 1 ] + A [ 2 ] ) ; int sum = Math . max ( Math . max ( third , second ) , first ) ; for ( int i = 3 ; i < N ; i ++ ) { sum = Math . max ( Math . max ( first , second + A [ i ] ) , third + A [ i ] + A [ i - 1 ] ) ; third = second ; second = first ; first = sum ; } return sum ; }
String longestSubsequence ( String X , String Y ) { int n = X . length ( ) ; int m = Y . length ( ) ; int [ ] [ ] mat = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < m + 1 ; j ++ ) { if ( i == 0 j == 0 ) mat [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < m + 1 ; j ++ ) { if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { mat [ i ] [ j ] = 1 + mat [ i - 1 ] [ j - 1 ] ; } else { mat [ i ] [ j ] = mat [ i - 1 ] [ j ] ; } } } int len = 0 , col = 0 ; for ( int i = 0 ; i < m + 1 ; i ++ ) { if ( mat [ n ] [ i ] > len ) { len = mat [ n ] [ i ] ; col = i ; } } String res = "" ; int i = n ; int j = col ; while ( len > 0 ) { if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { res = X . charAt ( i - 1 ) + res ; i -- ; j -- ; len -- ; } else { i -- ; } } return res ; }
void calculateStart ( int n , int m ) { for ( int i = 1 ; i < m ; ++ i ) { start [ 0 ] [ i ] += start [ 0 ] [ i - 1 ] ; } for ( int i = 1 ; i < n ; ++ i ) { start [ i ] [ 0 ] += start [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < n ; ++ i ) { for ( int j = 1 ; j < m ; ++ j ) { start [ i ] [ j ] += Math . max ( start [ i - 1 ] [ j ] , start [ i ] [ j - 1 ] ) ; } } }
void calculateEnd ( int n , int m ) { for ( int i = n - 2 ; i >= 0 ; -- i ) { ending [ i ] [ m - 1 ] += ending [ i + 1 ] [ m - 1 ] ; } for ( int i = m - 2 ; i >= 0 ; -- i ) { ending [ n - 1 ] [ i ] += ending [ n - 1 ] [ i + 1 ] ; } for ( int i = n - 2 ; i >= 0 ; -- i ) { for ( int j = m - 2 ; j >= 0 ; -- j ) { ending [ i ] [ j ] += Math . max ( ending [ i + 1 ] [ j ] , ending [ i ] [ j + 1 ] ) ; } } }
void maximumPathSum ( int mat [ ] [ ] , int n , int m , int q , int coordinates [ ] [ ] ) { for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { start [ i ] [ j ] = mat [ i ] [ j ] ; ending [ i ] [ j ] = mat [ i ] [ j ] ; } } calculateStart ( n , m ) ; calculateEnd ( n , m ) ; int ans = 0 ; for ( int i = 0 ; i < q ; ++ i ) { int X = coordinates [ i ] [ 0 ] - 1 ; int Y = coordinates [ i ] [ 1 ] - 1 ; ans = Math . max ( ans , start [ X ] [ Y ] + ending [ X ] [ Y ] - mat [ X ] [ Y ] ) ; } System . out . print ( ans ) ; }
int countAlternatingSubstrings ( String S , int N ) { int [ ] [ ] dp = new int [ 2 ] [ N ] ; for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 ) { if ( S . charAt ( i ) == '1' ) dp [ 1 ] [ i ] = 1 ; else dp [ 0 ] [ i ] = 1 ; } else { if ( S . charAt ( i ) == '0' ) dp [ 0 ] [ i ] = 1 + dp [ 1 ] [ i + 1 ] ; else dp [ 1 ] [ i ] = 1 + dp [ 0 ] [ i + 1 ] ; } } int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { ans += Math . max ( dp [ 0 ] [ i ] , dp [ 1 ] [ i ] ) ; } return ans ; }
int countSubset ( int [ ] arr , int n , int diff ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum += diff ; sum = sum / 2 ; int t [ ] [ ] = new int [ n + 1 ] [ sum + 1 ] ; for ( int j = 0 ; j <= sum ; j ++ ) t [ 0 ] [ j ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) t [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( arr [ i - 1 ] > j ) t [ i ] [ j ] = t [ i - 1 ] [ j ] ; else { t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } } return t [ n ] [ sum ] ; }
int maximizeAnd ( int i , int mask , int A [ ] , int B [ ] , int N , int [ ] [ ] dp ) { if ( i == N ) return 0 ; if ( dp [ i ] [ mask ] != - 1 ) return dp [ i ] [ mask ] ; for ( int j = 0 ; j < N ; ++ j ) { if ( ( mask & ( 1 << j ) ) == 0 ) { dp [ i ] [ mask ] = Math . max ( dp [ i ] [ mask ] , ( A [ i ] & B [ j ] ) + maximizeAnd ( i + 1 , mask | ( 1 << j ) , A , B , N , dp ) ) ; } } return dp [ i ] [ mask ] ; }
int maximizeAndUtil ( int A [ ] , int B [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ ( 1 << N ) + 1 ] ; for ( int dd [ ] : dp ) Arrays . fill ( dd , - 1 ) ; return maximizeAnd ( 0 , 0 , A , B , N , dp ) ; }
int countOfNumbers ( int digit , int prev1 , int prev2 , int N ) { if ( digit == N + 1 ) return 1 ; if ( dp [ digit ] [ prev1 ] [ prev2 ] != - 1 ) return dp [ digit ] [ prev1 ] [ prev2 ] ; dp [ digit ] [ prev1 ] [ prev2 ] = 0 ; if ( digit == 1 ) { for ( int j = ( N == 1 ? 0 : 1 ) ; j <= 9 ; ++ j ) { dp [ digit ] [ prev1 ] [ prev2 ] += countOfNumbers ( digit + 1 , j , prev1 , N ) ; } } else if ( digit == 2 ) { for ( int j = 0 ; j <= 9 ; ++ j ) { dp [ digit ] [ prev1 ] [ prev2 ] += countOfNumbers ( digit + 1 , j , prev1 , N ) ; } } else { for ( int j = 0 ; j <= Math . abs ( prev1 - prev2 ) ; ++ j ) { dp [ digit ] [ prev1 ] [ prev2 ] += countOfNumbers ( digit + 1 , j , prev1 , N ) ; } } return dp [ digit ] [ prev1 ] [ prev2 ] ; }
void findNthNum ( int N ) { int a = 0 , b , left ; int right , mid ; int t , last_num = 0 ; left = 1 ; right = N ; while ( left <= right ) { mid = left + ( right - left ) / 2 ; t = ( mid * ( mid + 1 ) ) / 2 ; if ( t < N ) { left = mid + 1 ; } else if ( t == N ) { a = mid ; break ; } else { a = mid ; right = mid - 1 ; } } t = a - 1 ; b = N - ( t * ( t + 1 ) ) / 2 - 1 ; System . out . print ( ( 1 << a ) + ( 1 << b ) ) ; }
void longestSubWithMaxSum ( int arr [ ] , int N ) { int Max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; if ( Max < 0 ) { System . out . print ( Max ) ; return ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= 0 ) { System . out . print ( arr [ i ] + " " ) ; } } }
void maxSumUtil ( int arr [ ] , int n ) { int [ ] [ ] dp = new int [ 100 ] [ 3 ] ; for ( int [ ] arr1 : dp ) Arrays . fill ( arr1 , - 1 ) ; System . out . print ( maxSum ( arr , 0 , n , 2 , false , dp ) ) ; }
void maximumSum ( int arr [ ] , int n ) { long [ ] preSum = new long [ n ] ; long sum = 0 ; long maxSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = Math . max ( arr [ i ] , sum + arr [ i ] ) ; maxSum = Math . max ( maxSum , sum ) ; preSum [ i ] = maxSum ; } sum = 0 ; maxSum = 0 ; long [ ] postSum = new long [ n + 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { sum = Math . max ( arr [ i ] , sum + arr [ i ] ) ; maxSum = Math . max ( maxSum , sum ) ; postSum [ i ] = maxSum ; } long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , preSum [ i ] + postSum [ i + 1 ] ) ; } System . out . println ( ans ) ; }
int NumberOfways ( int N , int K ) { int [ ] dp = new int [ N + 1 ] ; dp [ 0 ] = 1 ; for ( int row = 1 ; row < K + 1 ; row ++ ) { for ( int col = 1 ; col < N + 1 ; col ++ ) { if ( col >= row ) dp [ col ] = dp [ col ] + dp [ col - row ] ; } } return ( dp [ N ] ) ; }
void findAPSequence ( int arr [ ] , int N , int Q [ ] [ ] , int M ) { int dp [ ] = new int [ N + 5 ] ; for ( int i = 0 ; i + 1 < N ; ) { int j = i + 1 ; while ( j + 1 < N && arr [ j + 1 ] - arr [ j ] == arr [ i + 1 ] - arr [ i ] ) j ++ ; for ( int k = i ; k < j ; k ++ ) { dp [ k ] = j - k ; } i = j ; } for ( int i = 0 ; i < M ; i ++ ) { if ( dp [ Q [ i ] [ 0 ] ] >= Q [ i ] [ 1 ] - Q [ i ] [ 0 ] ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } } }
boolean isUnique ( String s ) { HashSet < Character > set = new HashSet < > ( ) ; for ( char c : s . toCharArray ( ) ) set . add ( c ) ; return set . size ( ) == 1 ; }
int maxScore ( String s , int [ ] a ) { int n = s . length ( ) ; if ( n == 0 ) return 0 ; if ( n == 1 ) return a [ 0 ] ; int mx = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { String sub = s . substring ( i , j + 1 ) ; if ( isUnique ( sub ) ) mx = Math . max ( mx , a [ sub . length ( ) - 1 ] + maxScore ( s . substring ( 0 , i ) + s . substring ( j + 1 ) , a ) ) ; } } return mx ; }
int numberOfUniqueOutcomes ( int N , int S ) { if ( S < N ) return 0 ; if ( N == 1 N == S ) return 1 ; return ( numberOfUniqueOutcomes ( N - 1 , S - 1 ) + numberOfUniqueOutcomes ( N - 1 , S - 2 ) ) ; }
int numberOfUniqueOutcomes ( int n , int s ) { if ( s < n ) ans [ n ] [ s ] = 0 ; else if ( n == 1 n == s ) ans [ n ] [ s ] = 1 ; else if ( ans [ n ] [ s ] == 0 ) { ans [ n ] [ s ] = numberOfUniqueOutcomes ( n - 1 , s - 1 ) + numberOfUniqueOutcomes ( n - 1 , s - 2 ) ; } return ans [ n ] [ s ] ; }
int MinimumLength ( int A [ ] , int N , int K ) { Arrays . sort ( A ) ; int suffix [ ] = new int [ N + 1 ] ; for ( int i = N - 1 ; i >= 0 ; i -- ) suffix [ i ] = suffix [ i + 1 ] + A [ i ] ; int dp [ ] [ ] = new int [ N + 1 ] [ K + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= K ; j ++ ) dp [ i ] [ j ] = MAX ; dp [ N ] [ 0 ] = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = K ; j >= 0 ; j -- ) { if ( j <= A [ i ] ) { dp [ i ] [ j ] = A [ i ] ; continue ; } if ( dp [ i + 1 ] [ j - A [ i ] ] == MAX ) dp [ i ] [ j ] = MAX ; else dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ j ] , dp [ i + 1 ] [ j - A [ i ] ] + A [ i ] ) ; } } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( suffix [ i ] - dp [ i ] [ K ] >= K ) { return N - i ; } } return - 1 ; }
void countXOR ( int arr [ ] , int comb [ ] , int start , int end , int index , int r ) { if ( index == r ) { int new_xor = 0 ; for ( int j = 0 ; j < r ; j ++ ) { new_xor ^= comb [ j ] ; } s . add ( new_xor ) ; return ; } for ( int i = start ; i <= end && end - i + 1 >= r - index ; i ++ ) { comb [ index ] = arr [ i ] ; countXOR ( arr , comb , i + 1 , end , index + 1 , r ) ; } }
void maxSizeSet ( int arr [ ] , int N ) { for ( int r = 1 ; r <= N ; r ++ ) { int comb [ ] = new int [ r + 1 ] ; countXOR ( arr , comb , 0 , N - 1 , 0 , r ) ; } System . out . println ( s . size ( ) ) ; }
void maxSizeSet ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { insertVector ( arr [ i ] ) ; } System . out . println ( 1 << ans ) ; }
void waysToPaint ( int n ) { long same = 6 ; long diff = 6 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long sameTmp = 3 * same + 2 * diff ; long diffTmp = 2 * same + 2 * diff ; same = sameTmp ; diff = diffTmp ; } System . out . println ( same + diff ) ; }
void printMinimumRemovals ( String str , String X ) { int N = str . length ( ) ; int M = X . length ( ) ; int dp [ ] [ ] = new int [ N ] [ M ] ; for ( int j = 0 ; j < M ; j ++ ) { if ( str . charAt ( 0 ) == X . charAt ( j ) ) { dp [ 0 ] [ j ] = 1 ; } } for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( str . charAt ( i ) == X . charAt ( j ) ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + 1 ; if ( j != 0 ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } } System . out . println ( dp [ N - 1 ] [ M - 1 ] ) ; }
int maxSubarraySum ( int [ ] sum , int k , int row ) { int curSum = 0 , curMax = Integer . MIN_VALUE ; Set < Integer > sumSet = new HashSet < Integer > ( ) ; sumSet . add ( 0 ) ; for ( int r = 0 ; r < row ; ++ r ) { curSum += sum [ r ] ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; list . addAll ( sumSet ) ; int it = Integer . MIN_VALUE ; for ( int e : list ) if ( e >= ( curSum - k ) ) { it = e ; break ; } if ( it != Integer . MIN_VALUE ) { curMax = Math . max ( curMax , curSum - it ) ; } sumSet . add ( curSum ) ; } return curMax ; }
void maxSumSubmatrix ( int [ ] [ ] matrix , int k ) { int row = matrix . length ; int col = matrix [ 0 ] . length ; int ret = Integer . MIN_VALUE ; for ( int i = 0 ; i < col ; ++ i ) { int [ ] sum = new int [ row ] ; for ( int j = i ; j < col ; ++ j ) { for ( int r = 0 ; r < row ; ++ r ) { sum [ r ] += matrix [ r ] [ j ] ; } int curMax = maxSubarraySum ( sum , k , row ) ; ret = Math . max ( ret , curMax ) ; } } System . out . print ( ret ) ; }
void minCost ( int arr [ ] , int n ) { if ( n < 3 ) { System . out . println ( arr [ 0 ] ) ; return ; } int dp [ ] = new int [ n ] ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ; for ( int i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = Math . min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ; dp [ n - 1 ] = Math . min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ; System . out . println ( dp [ n - 1 ] ) ; }
void maxSum ( int arr [ ] , int N , int K ) { int [ ] dp = new int [ N + 2 ] ; Arrays . fill ( dp , 0 ) ; int maxval = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( ( i + K * arr [ i ] ) >= N ) { dp [ i ] = arr [ i ] ; } else { dp [ i ] = dp [ i + K * arr [ i ] ] + arr [ i ] ; } maxval = Math . max ( maxval , dp [ i ] ) ; } System . out . print ( maxval ) ; }
void maxSubmatrixSum ( int [ ] [ ] matrix ) { int r = matrix . length ; int c = matrix [ 0 ] . length ; int maxSubmatrix = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { for ( int k = i ; k < r ; k ++ ) { for ( int l = j ; l < c ; l ++ ) { int sumSubmatrix = 0 ; for ( int m = i ; m <= k ; m ++ ) { for ( int n = j ; n <= l ; n ++ ) { sumSubmatrix += matrix [ m ] [ n ] ; } } maxSubmatrix = Math . max ( maxSubmatrix , sumSubmatrix ) ; } } } } System . out . println ( maxSubmatrix ) ; }
int kadane ( Vector < Integer > v ) { int currSum = 0 ; int maxSum = Integer . MIN_VALUE ; for ( int i = 0 ; i < ( int ) v . size ( ) ; i ++ ) { currSum += v . get ( i ) ; if ( currSum > maxSum ) { maxSum = currSum ; } if ( currSum < 0 ) { currSum = 0 ; } } return maxSum ; }
void minCost ( int costs [ ] [ ] , int N ) { if ( N == 0 ) return ; int dp [ ] [ ] = new int [ N ] [ 3 ] ; dp [ 0 ] [ 0 ] = costs [ 0 ] [ 0 ] ; dp [ 0 ] [ 1 ] = costs [ 0 ] [ 1 ] ; dp [ 0 ] [ 2 ] = costs [ 0 ] [ 2 ] ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = Math . min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 0 ] ; dp [ i ] [ 1 ] = Math . min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 1 ] ; dp [ i ] [ 2 ] = Math . min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + costs [ i ] [ 2 ] ; } System . out . println ( Math . min ( dp [ N - 1 ] [ 0 ] , Math . min ( dp [ N - 1 ] [ 1 ] , dp [ N - 1 ] [ 2 ] ) ) ) ; }
int findCnt ( int [ ] arr , int i , int required_sum , int n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ required_sum + Base ] ) return dp [ i ] [ required_sum + Base ] ; v [ i ] [ required_sum + Base ] = true ; dp [ i ] [ required_sum + Base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + Base ] ; }
void countSubsets ( int [ ] arr , int K , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int S1 = ( sum + K ) / 2 ; System . out . print ( findCnt ( arr , 0 , S1 , n ) ) ; }
int solve ( int [ ] A , int i , int sum , int N ) { int res = 2001 ; if ( sum < 0 || ( i == N && sum != 0 ) ) { return 2001 ; } if ( sum == 0 i >= N ) { return dp [ i ] [ sum ] = 0 ; } if ( dp [ i ] [ sum ] != - 1 ) { return dp [ i ] [ sum ] ; } res = Math . min ( solve ( A , i + 1 , sum - A [ i ] , N ) + 1 , solve ( A , i + 1 , sum , N ) ) ; return dp [ i ] [ sum ] = res ; }
void daysToCure ( int arr [ ] , int N , int P ) { int risk = 0 ; int normal_risk = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= 60 arr [ i ] <= 10 ) { risk ++ ; } else { normal_risk ++ ; } } int days = ( risk / P ) + ( normal_risk / P ) ; if ( risk % P > 0 ) { days ++ ; } if ( normal_risk % P > 0 ) { days ++ ; } System . out . print ( days ) ; }
int countAverage ( int n , int K , int [ ] arr ) { dp [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int s = 0 ; s <= 100 ; s ++ ) { dp [ i + 1 ] [ k + 1 ] [ s + arr [ i ] ] += dp [ i ] [ k ] [ s ] ; dp [ i + 1 ] [ k ] [ s ] += dp [ i ] [ k ] [ s ] ; } } } int cnt = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { cnt += dp [ n ] [ j ] [ K * j ] ; } return cnt ; }
void maximumSubsetSum ( int arr1 [ ] , int arr2 [ ] , int length ) { int dp [ ] = new int [ length + 1 ] ; if ( length == 1 ) { System . out . print ( Math . max ( arr1 [ 0 ] , arr2 [ 0 ] ) ) ; return ; } if ( length == 2 ) { System . out . print ( Math . max ( Math . max ( arr1 [ 1 ] , arr2 [ 1 ] ) , Math . max ( arr1 [ 0 ] , arr2 [ 0 ] ) ) ) ; return ; } else { dp [ 0 ] = Math . max ( arr1 [ 0 ] , arr2 [ 0 ] ) ; dp [ 1 ] = Math . max ( Math . max ( arr1 [ 1 ] , arr2 [ 1 ] ) , Math . max ( arr1 [ 0 ] , arr2 [ 0 ] ) ) ; int index = 2 ; while ( index < length ) { dp [ index ] = Math . max ( Math . max ( arr1 [ index ] , arr2 [ index ] ) , Math . max ( Math . max ( arr1 [ index ] + dp [ index - 2 ] , arr2 [ index ] + dp [ index - 2 ] ) , dp [ index - 1 ] ) ) ; ++ index ; } System . out . print ( dp [ length - 1 ] ) ; } }
int FindMaxS ( int X , int Y , int Z , int n , int [ ] A , int [ ] B , int [ ] C ) { if ( X < 0 Y < 0 Z < 0 ) return Integer . MIN_VALUE ; if ( n < 0 ) return 0 ; if ( dp [ n ] [ X ] [ Y ] [ Z ] != - 1 ) { return dp [ n ] [ X ] [ Y ] [ Z ] ; } int ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) ; int ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) ; int co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) ; int no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) ; int maximum = Math . max ( ch , Math . max ( ca , Math . max ( co , no ) ) ) ; return dp [ n ] [ X ] [ Y ] [ Z ] = maximum ; }
void findCount ( int N , int maxDigit [ ] ) { int position = 0 ; int previous = 0 ; int count = 1 ; int ans = findCountUtil ( N , maxDigit , position , previous , count ) ; System . out . println ( ans ) ; }
double find ( int N , int sum ) { if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } double s = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; }
float find ( int N , int sum ) { if ( N < 0 sum < 0 ) return 0 ; if ( dp [ N ] [ sum ] > 0 ) return dp [ N ] [ sum ] ; if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return ( float ) ( 1.0 / 6 ) ; else return 0 ; } for ( int i = 1 ; i <= 6 ; i ++ ) dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N ] [ sum ] ; }
float find ( int N , int a , int b ) { float probability = 0.0f ; for ( int i = 1 ; i <= 6 ; i ++ ) dp [ 1 ] [ i ] = ( float ) ( 1.0 / 6 ) ; for ( int i = 2 ; i <= N ; i ++ ) { for ( int j = i ; j <= 6 * i ; j ++ ) { for ( int k = 1 ; k <= 6 && k <= j ; k ++ ) { dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - k ] / 6 ; } } } for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + dp [ N ] [ sum ] ; return probability ; }
void minAtEachIndex ( int n , int arr [ ] ) { int dp1 [ ] = new int [ n ] ; int dp2 [ ] = new int [ n ] ; int i ; dp1 [ 0 ] = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) dp1 [ i ] = Math . min ( arr [ i ] , dp1 [ i - 1 ] + 1 ) ; dp2 [ n - 1 ] = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) dp2 [ i ] = Math . min ( arr [ i ] , dp2 [ i + 1 ] + 1 ) ; ArrayList < Integer > v = new ArrayList < Integer > ( ) ; for ( i = 0 ; i < n ; i ++ ) v . add ( Math . min ( dp1 [ i ] , dp2 [ i ] ) ) ; for ( int x : v ) System . out . print ( x + " " ) ; }
int totalArrays ( int N , int M ) { int [ ] end_with_one = new int [ N + 1 ] ; int [ ] end_not_with_one = new int [ N + 1 ] ; end_with_one [ 0 ] = 1 ; end_not_with_one [ 0 ] = 0 ; end_with_one [ 1 ] = 0 ; end_not_with_one [ 1 ] = M - 1 ; for ( int i = 2 ; i < N ; i ++ ) { end_with_one [ i ] = end_not_with_one [ i - 1 ] ; end_not_with_one [ i ] = end_with_one [ i - 1 ] * ( M - 1 ) + end_not_with_one [ i - 1 ] * ( M - 2 ) ; } return end_with_one [ N - 1 ] ; }
int prodOfDigit ( int N ) { int res = 1 ; while ( N > 0 ) { res = res * ( N % 10 ) ; N /= 10 ; } return res ; }
int cntNum ( String X , int i , int prod , int K , int st , int tight , int [ ] [ ] [ ] [ ] dp ) { if ( i >= X . length ( ) prod > K ) { return prod == K ? 1 : 0 ; } if ( dp [ prod ] [ i ] [ tight ] [ st ] != - 1 ) { return dp [ prod ] [ i ] [ tight ] [ st ] ; } int res = 0 ; int end = tight > 0 ? X . charAt ( i ) - '0' : 9 ; for ( int j = 0 ; j <= end ; j ++ ) { if ( j == 0 && st == 0 ) { res += cntNum ( X , i + 1 , prod , K , 0 , ( tight & ( ( j == end ) ? 1 : 0 ) ) , dp ) ; } else { res += cntNum ( X , i + 1 , prod * j , K , 1 , ( tight & ( ( j == end ) ? 1 : 0 ) ) , dp ) ; } } static int UtilCntNumRange  ( int L , int R , int K ) { String str = String . valueOf ( R ) ; int [ ] [ ] [ ] [ ] dp = new int [ M ] [ M ] [ 2 ] [ 2 ] ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { for ( int k = 0 ; k < 2 ; k ++ ) for ( int l = 0 ; l < 2 ; l ++ ) dp [ i ] [ j ] [ k ] [ l ] = - 1 ; } } int cntR = cntNum ( str , 0 , 1 , K , 0 , 1 , dp ) ; str = String . valueOf ( L - 1 ) ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { for ( int k = 0 ; k < 2 ; k ++ ) for ( int l = 0 ; l < 2 ; l ++ ) dp [ i ] [ j ] [ k ] [ l ] = - 1 ; } } int cntL = cntNum ( str , 0 , 1 , K , 0 , 1 , dp ) ; return ( cntR - cntL ) ; } public static void main  ( String [ ] args ) { int L = 20 , R = 10000 , K = 14 ; System . out . print ( UtilCntNumRange ( L , R , K ) ) ; } }
int power ( int X , int Y ) { int res = 1 ; X = X % M ; if ( X == 0 ) return 0 ; while ( Y > 0 ) { if ( ( Y & 1 ) != 0 ) { res = ( res * X ) % M ; } Y = Y >> 1 ; X = ( X * X ) % M ; } return res ; }
int findValue ( int n ) { int X = 0 ; int pow_10 = 1 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 ) { X += pow_10 ; } pow_10 *= 10 ; n /= 2 ; } X = ( X * 2 ) % M ; int res = power ( 2 , X ) ; return res ; }
int mod_pow2 ( int n ) { while ( n >= MEM . size ( ) ) MEM . add ( ( MEM . get ( MEM . size ( ) - 1 ) * 2 ) % MOD ) ; return MEM . get ( n ) ; }
int inversions ( char [ ] bstr ) { int total = 0 , zeros = 0 , questions = 0 ; int j = bstr . length - 1 ; for ( int i = 0 ; i < bstr . length / 2 ; i ++ ) { char temp = bstr [ i ] ; bstr [ i ] = bstr [ j ] ; bstr [ j ] = temp ; j -- ; } for ( char x : bstr ) { int q ; if ( x == '1' ) { int z = zeros * mod_pow2 ( questions ) ; if ( questions == 0 ) q = 0 ; else q = questions * mod_pow2 ( questions - 1 ) ; total = ( total + z + q ) % MOD ; } else if ( x == '0' ) { zeros += 1 ; } else { total *= 2 ; int z = zeros * mod_pow2 ( questions ) ; if ( questions == 0 ) q = 0 ; else q = questions * mod_pow2 ( questions - 1 ) ; total = ( total + z + q ) % MOD ; questions += 1 ; } } return total ; }
double findMedXOR ( int mat [ ] [ ] , int N , int M ) { int dp [ ] [ ] = new int [ N ] [ M ] ; int med [ ] = new int [ N * M ] ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; med [ 0 ] = dp [ 0 ] [ 0 ] ; int len = 1 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ^ mat [ i ] [ 0 ] ; med [ len ++ ] = dp [ i ] [ 0 ] ; } for ( int i = 1 ; i < M ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ^ mat [ 0 ] [ i ] ; med [ len ++ ] = dp [ 0 ] [ i ] ; } for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ^ dp [ i ] [ j - 1 ] ^ dp [ i - 1 ] [ j - 1 ] ^ mat [ i ] [ j ] ; med [ len ++ ] = dp [ i ] [ j ] ; } } Arrays . sort ( med ) ; if ( len % 2 == 0 ) { return ( med [ ( len / 2 ) ] + med [ ( len / 2 ) - 1 ] ) / 2.0 ; } return med [ len / 2 ] ; }
int countTriplets ( int [ ] A ) { int cnt = 0 ; HashMap < Integer , Integer > tuples = new HashMap < Integer , Integer > ( ) ; for ( int a : A ) for ( int b : A ) { if ( tuples . containsKey ( a & b ) ) tuples . put ( a & b , tuples . get ( a & b ) + 1 ) ; else tuples . put ( a & b , 1 ) ; } for ( int a : A ) for ( Map . Entry < Integer , Integer > t : tuples . entrySet ( ) ) if ( ( t . getKey ( ) & a ) == 0 ) cnt += t . getValue ( ) ; return cnt ; }
int countVowelPermutation ( int n ) { int MOD = ( int ) ( 1e9 + 7 ) ; long [ ] [ ] dp = new long [ n + 1 ] [ 5 ] ; for ( int i = 0 ; i < 5 ; i ++ ) { dp [ 1 ] [ i ] = 1 ; } int [ ] [ ] relation = new int [ ] [ ] { { 1 } , { 0 , 2 } , { 0 , 1 , 3 , 4 } , { 2 , 4 } , { 0 } } ; for ( int i = 1 ; i < n ; i ++ ) { for ( int u = 0 ; u < 5 ; u ++ ) { dp [ i + 1 ] [ u ] = 0 ; for ( int v : relation [ u ] ) { dp [ i + 1 ] [ u ] += dp [ i ] [ v ] % MOD ; } } } long ans = 0 ; for ( int i = 0 ; i < 5 ; i ++ ) { ans = ( ans + dp [ n ] [ i ] ) % MOD ; } return ( int ) ans ; }
int MaximumSubarraySum ( int n , int [ ] arr , int k ) { int [ ] [ ] dp = new int [ M ] [ M ] ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) dp [ i ] [ j ] = - 1 ; mxSubSum ( n - 1 , arr , k , dp ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= k ; j ++ ) { res = Math . max ( res , dp [ i ] [ j ] ) ; } } if ( Arrays . stream ( arr ) . max ( ) . getAsInt ( ) < 0 ) { res = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; } return res ; }
void countWaysToTileBoard ( int N ) { int dp [ ] = new int [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) ; } System . out . print ( dp [ N ] ) ; }
void DFS ( int node , int parent , int Val [ ] ) { answer [ node ] = Val [ node ] ; for ( Integer child : adj . get ( node ) ) { if ( child == parent ) continue ; DFS ( child , node , Val ) ; answer [ node ] = ( answer [ node ] answer [ child ] ) ; } }
void preprocess ( int Val [ ] ) { DFS ( 1 , - 1 , Val ) ; }
void findSubtreeOR ( int Queries [ ] , int Q , int Val [ ] ) { preprocess ( Val ) ; for ( int i = 0 ; i < Q ; i ++ ) { System . out . println ( answer [ Queries [ i ] ] + " " ) ; } }
void minCost ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int m = 2 * n ; int cost [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { cost [ i ] [ j ] = INF ; } } cost [ 0 ] [ 0 ] = 0 ; int prev = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { prev = cost [ i - 1 ] [ 0 ] ; for ( int j = 1 ; j <= m ; j ++ ) { cost [ i ] [ j ] = Math . min ( cost [ i ] [ j ] , prev + Math . abs ( j - arr [ i - 1 ] ) ) ; prev = Math . min ( prev , cost [ i - 1 ] [ j ] ) ; } } int minCost = INF ; for ( int j = 1 ; j <= m ; j ++ ) { minCost = Math . min ( minCost , cost [ n ] [ j ] ) ; } System . out . print ( minCost ) ; }
void FindSub ( String str , String res , int i ) { if ( i == str . length ( ) ) { if ( res . length ( ) > 0 ) { System . out . print ( res + " " ) ; } return ; } char ch = str . charAt ( i ) ; FindSub ( str , res , i + 1 ) ; FindSub ( str , res + ch , i + 1 ) ; FindSub ( str , res + ( int ) ch , i + 1 ) ; ; }
int MinOp ( int N ) { if ( N <= 1 ) return N ; int bit = ( int ) ( Math . log ( N ) / Math . log ( 2 ) ) + 1 ; return ( ( 1 << bit ) - 1 ) - MinOp ( N - ( 1 << ( bit - 1 ) ) ) ; }
int max ( int a , int b ) { return a > b ? a : b ; }
int maximumsum ( int arr [ ] [ ] , int K , int N , int M ) { int sum = 0 , maxSum ; int i , j , k ; int [ ] [ ] dp = new int [ K + 1 ] [ N + 1 ] ; for ( i = 0 ; i <= N ; i ++ ) dp [ 0 ] [ i ] = 0 ; for ( i = 0 ; i <= K ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( i = 1 ; i <= K ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { sum = 0 ; maxSum = dp [ i ] [ j ] ; for ( k = 1 ; k <= M && k <= i ; k ++ ) { sum += arr [ j ] [ k - 1 ] ; maxSum = Math . max ( maxSum , sum + dp [ i - k ] [ j ] ) ; } dp [ i ] [ j + 1 ] = maxSum ; } } return dp [ K ] [ N ] ; }
int check ( int [ ] [ ] memo , int i , int j , int [ ] A ) { if ( i == N - 1 ) return 1 ; if ( memo [ i ] [ j ] != - 1 ) return memo [ i ] [ j ] ; int flag = 0 , k ; for ( k = i + 1 ; k < N ; k ++ ) { if ( A [ k ] - A [ i ] > j + 1 ) break ; if ( A [ k ] - A [ i ] >= j - 1 && A [ k ] - A [ i ] <= j + 1 ) flag = check ( memo , k , A [ k ] - A [ i ] , A ) ; if ( flag != 0 ) break ; } memo [ i ] [ j ] = flag ; return memo [ i ] [ j ] ; }
void checkEndReach ( int A [ ] , int K ) { int [ ] [ ] memo = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { memo [ i ] [ j ] = - 1 ; } } int startIndex = 1 ; if ( check ( memo , startIndex , K , A ) != 0 ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
int maxProductPath ( int [ ] [ ] grid ) { int n = grid . length ; int m = grid [ 0 ] . length ; int [ ] [ ] maxPath = new int [ n ] [ m ] ; int [ ] [ ] minPath = new int [ n ] [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int mn = Integer . MAX_VALUE ; int mx = Integer . MIN_VALUE ; if ( i == 0 && j == 0 ) { mx = grid [ i ] [ j ] ; mn = grid [ i ] [ j ] ; } if ( i > 0 ) { int tempmx = Math . max ( ( maxPath [ i - 1 ] [ j ] * grid [ i ] [ j ] ) , ( minPath [ i - 1 ] [ j ] * grid [ i ] [ j ] ) ) ; mx = Math . max ( mx , tempmx ) ; int tempmn = Math . min ( ( maxPath [ i - 1 ] [ j ] * grid [ i ] [ j ] ) , ( minPath [ i - 1 ] [ j ] * grid [ i ] [ j ] ) ) ; mn = Math . min ( mn , tempmn ) ; } if ( j > 0 ) { int tempmx = Math . max ( ( maxPath [ i ] [ j - 1 ] * grid [ i ] [ j ] ) , ( minPath [ i ] [ j - 1 ] * grid [ i ] [ j ] ) ) ; mx = Math . max ( mx , tempmx ) ; int tempmn = Math . min ( ( maxPath [ i ] [ j - 1 ] * grid [ i ] [ j ] ) , ( minPath [ i ] [ j - 1 ] * grid [ i ] [ j ] ) ) ; mn = Math . min ( mn , tempmn ) ; } maxPath [ i ] [ j ] = mx ; minPath [ i ] [ j ] = mn ; } } if ( maxPath [ n - 1 ] [ m - 1 ] < 0 ) { return - 1 ; } else { return ( maxPath [ n - 1 ] [ m - 1 ] ) ; } }
void waysToArrangeKLengthStrings ( int N , int K ) { int [ ] column_sum = new int [ N + 1 ] ; int i , j ; for ( i = 1 ; i < N + 1 ; i ++ ) { column_sum [ i ] = 0 ; } int dp [ ] [ ] = new int [ K + 1 ] [ N + 1 ] ; for ( i = 1 ; i < K + 1 ; i ++ ) { for ( j = 1 ; j < N + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( i = 0 ; i <= N ; i ++ ) { dp [ 0 ] [ i ] = 1 ; column_sum [ i ] = 1 ; } for ( i = 1 ; i <= K ; i ++ ) { for ( j = 1 ; j <= N ; j ++ ) { dp [ i ] [ j ] += column_sum [ j - 1 ] ; column_sum [ j ] += dp [ i ] [ j ] ; } } System . out . print ( dp [ K ] [ N ] ) ; }
int findNumberOfLIS ( int [ ] nums ) { if ( nums . length == 0 ) return 0 ; int n = nums . length ; int [ ] dp_l = new int [ n ] ; Arrays . fill ( dp_l , 1 ) ; int [ ] dp_c = new int [ n ] ; Arrays . fill ( dp_c , 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( nums [ i ] <= nums [ j ] ) continue ; if ( dp_l [ j ] + 1 > dp_l [ i ] ) { dp_l [ i ] = dp_l [ j ] + 1 ; dp_c [ i ] = dp_c [ j ] ; } else if ( dp_l [ j ] + 1 == dp_l [ i ] ) dp_c [ i ] += dp_c [ j ] ; } } int max_length = 0 ; for ( int i : dp_l ) max_length = Math . max ( i , max_length ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp_l [ i ] == max_length ) count += dp_c [ i ] ; } return count ; }
int countPenality ( int [ ] arr , int N ) { int pos = 0 ; int turn = 0 ; return findMinimum ( arr , N , pos , turn ) + 1 ; }
void printAnswer ( int [ ] arr , int N ) { int a = countPenality ( arr , N ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } System . out . println ( a ) ; }
int removeSmallestSubarray ( int arr [ ] , int S , int n , int k ) { int target_remainder = S % k ; HashMap < Integer , Integer > map1 = new HashMap < > ( ) ; map1 . put ( 0 , - 1 ) ; int curr_remainder = 0 ; int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { curr_remainder = ( curr_remainder + arr [ i ] + k ) % k ; map1 . put ( curr_remainder , i ) ; int mod = ( curr_remainder - target_remainder + k ) % k ; if ( map1 . containsKey ( mod ) ) { res = Math . min ( res , i - map1 . get ( mod ) ) ; } } if ( res == Integer . MAX_VALUE res == n ) { res = - 1 ; } return res ; }
int smstSubmatDeleted ( int [ ] [ ] mat , int N , int M , int K ) { int S = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) S += mat [ i ] [ j ] ; } int min_area = N * M ; int left = 0 ; int right = 0 ; int width ; int area ; int [ ] prefixRowSum = new int [ N ] ; for ( left = 0 ; left < M ; left ++ ) { Arrays . fill ( prefixRowSum , 0 ) ; for ( right = left ; right < M ; right ++ ) { for ( int i = 0 ; i < N ; i ++ ) { prefixRowSum [ i ] += mat [ i ] [ right ] ; } width = removeSmallestSubarray ( prefixRowSum , S , N , K ) ; if ( width != - 1 ) { area = ( right - left + 1 ) * ( width ) ; if ( area < min_area ) { min_area = area ; } } } } return min_area ; }
int countstrings ( int n , int start ) { if ( n == 0 ) { return 1 ; } int cnt = 0 ; for ( int i = start ; i < 5 ; i ++ ) { cnt += countstrings ( n - 1 , i ) ; } return cnt ; }
int findNumberOfStrings ( int n ) { int DP [ ] [ ] = new int [ n + 1 ] [ 6 ] ; DP [ 1 ] [ 1 ] = 1 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < 6 ; j ++ ) { if ( i == 1 ) { DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + 1 ; } else { DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + DP [ i - 1 ] [ j ] ; } } } return DP [ n ] [ 5 ] ; }
int findNumberOfStrings ( int n ) { return ( n + 1 ) * ( n + 2 ) * ( n + 3 ) * ( n + 4 ) / 24 ; }
int check ( int sum , int x , int y ) { while ( sum > 0 ) { int ln = sum % 10 ; if ( ln != x && ln != y ) { return 0 ; } sum /= 10 ; } return 1 ; }
int countNumbers ( int n , int x , int y , int sum ) { for ( int i [ ] : dp ) Arrays . fill ( i , - 1 ) ; if ( n == 0 ) { return check ( sum , x , y ) ; } if ( dp [ n ] [ sum ] != - 1 ) { return dp [ n ] [ sum ] % mod ; } int option1 = countNumbers ( n - 1 , x , y , sum + x ) % mod ; int option2 = countNumbers ( n - 1 , x , y , sum + y ) % mod ; return dp [ n ] [ sum ] = ( option1 + option2 ) % mod ; }
int findTotalPath ( int X , int n , ArrayList < Integer > dp ) { if ( X == 0 ) { return 1 ; } int ans = 0 ; if ( dp . get ( X ) != - 1 ) { return dp . get ( X ) ; } for ( int i = 1 ; i <= Math . min ( X , n ) ; ++ i ) { ans += findTotalPath ( X - i , n , dp ) % mod ; ans %= mod ; } dp . set ( X , ans ) ; return ans ; }
void printAnswer ( int n , int edges [ ] [ ] , int values [ ] ) { ArrayList < Integer > adj [ ] = new ArrayList [ n ] ; for ( int i = 0 ; i < n ; i ++ ) adj [ i ] = new ArrayList < > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int u = edges [ i ] [ 0 ] - 1 ; int v = edges [ i ] [ 1 ] - 1 ; adj [ u ] . add ( v ) ; adj [ v ] . add ( u ) ; } int ans [ ] = new int [ n ] ; dfs ( 0 , - 1 , adj , ans , values ) ; for ( int x : ans ) { System . out . print ( x + " " ) ; } }
boolean checkEvenOddLevel ( Node root ) { if ( root == null ) return true ; Queue < Node > q = new LinkedList < > ( ) ; q . add ( root ) ; int level = 0 ; while ( ! q . isEmpty ( ) ) { ArrayList < Integer > list = new ArrayList < > ( ) ; int size = q . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Node node = q . poll ( ) ; list . add ( node . val ) ; if ( node . left != null ) q . add ( node . left ) ; if ( node . right != null ) q . add ( node . right ) ; } if ( level % 2 == 0 ) { for ( int i = 0 ; i < list . size ( ) - 1 ; i ++ ) { if ( list . get ( i + 1 ) > list . get ( i ) ) continue ; return false ; } } else if ( level % 2 == 1 ) { for ( int i = 0 ; i < list . size ( ) - 1 ; i ++ ) { if ( list . get ( i + 1 ) < list . get ( i ) ) continue ; return false ; } } level ++ ; } return true ; }
void build ( int dp [ ] , int arr [ ] , int N ) { dp [ 0 ] = 0 ; dp [ 1 ] = 0 ; Vector < Integer > prime = SieveOfEratosthenes ( ) ; int [ ] pref = new int [ N + 1 ] ; pref [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { pref [ i ] = pref [ i - 1 ] + arr [ i - 1 ] ; } for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; for ( int j = 0 ; j <= prime . size ( ) ; j ++ ) { int r = i - 1 ; int l = r - prime . get ( j ) + 1 ; if ( l < 0 ) break ; int temp = 0 ; temp = pref [ r + 1 ] - pref [ l ] ; if ( l - 2 >= 0 ) temp += dp [ l - 2 + 1 ] ; dp [ i ] = Math . max ( dp [ i ] , temp ) ; } } }
void maxSumSubseq ( int arr [ ] , int N ) { int [ ] dp = new int [ N + 1 ] ; build ( dp , arr , N ) ; System . out . print ( dp [ N ] ) ; }
int MinRunLengthEncoding ( String s , int n , int k ) { for ( int i [ ] [ ] [ ] : dp ) for ( int j [ ] [ ] : i ) for ( int p [ ] : j ) Arrays . fill ( p , - 1 ) ; return solve ( s , n , 0 , k , ( char ) 123 , 0 ) ; }
int minimumCost ( int [ ] A , int [ ] B , int M , int N , int C ) { int [ ] nums = new int [ 100000 ] ; int [ ] index = new int [ 100000 ] ; for ( int i = 0 ; i < 100000 ; i ++ ) index [ i ] = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { index [ B [ i ] ] = i ; } int k = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( index [ A [ i ] ] != - 1 ) { nums [ k ++ ] = index [ A [ i ] ] ; } } int lcs_length = findLCS ( nums , k ) ; int elements_to_be_added = N - lcs_length ; int min_cost = elements_to_be_added * C ; System . out . println ( min_cost ) ; return 0 ; }
void numberOfPermWithKInversion ( int N , int K ) { int [ ] [ ] dp = new int [ 2 ] [ K + 1 ] ; int mod = 1000000007 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= K ; j ++ ) { if ( i == 1 ) { dp [ i % 2 ] [ j ] = ( j == 0 ) ? 1 : 0 ; } else if ( j == 0 ) dp [ i % 2 ] [ j ] = 1 ; else { int maxm = Math . max ( j - ( i - 1 ) ) ; dp [ i % 2 ] [ j ] = ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( ( Math . max ( j - ( i - 1 ) , 0 ) == 0 ) ? 0 : dp [ 1 - i % 2 ] [ maxm , 0 ) - 1 ] ) + mod ) % mod ) % mod ; } } } System . out . println ( dp [ N % 2 ] [ K ] ) ; }
int maxScore ( int [ ] arr ) { int N = arr . length ; N ++ ; int [ ] [ ] dp = new int [ N + 1 ] [ 2 * ( N - 1 ) + 1 ] ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int s = 1 ; s <= 2 * ( N - 1 ) ; s ++ ) { for ( int j = 1 ; j <= N - 1 && j <= s ; j ++ ) { dp [ i ] [ s ] = Math . max ( dp [ i ] [ s ] , arr [ j - 1 ] + dp [ i - 1 ] [ s - j ] ) ; } } } return dp [ N ] [ 2 * ( N - 1 ) ] - 1 ; }
void minimumCost ( int [ ] cost , int n , int x ) { int [ ] dp = new int [ n + 2 ] ; dp [ 0 ] = cost [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( i == 1 ) dp [ i ] = cost [ i ] + dp [ i - 1 ] ; if ( i == 2 ) dp [ i ] = cost [ i ] + Math . min ( dp [ i - 1 ] , x + dp [ i - 2 ] ) ; if ( i >= 3 ) dp [ i ] = cost [ i ] + Math . min ( dp [ i - 1 ] , Math . min ( x + dp [ i - 2 ] , 2 * x + dp [ i - 3 ] ) ) ; } System . out . println ( dp [ n - 1 ] ) ; }
int maxSum ( int a [ ] , int n , int k ) { if ( n <= 0 ) return 0 ; int option = maxSum ( a , n - 1 , k ) ; if ( k >= a [ n - 1 ] ) option = Math . max ( option , a [ n - 1 ] + maxSum ( a , n - 2 , k - a [ n - 1 ] ) ) ; return option ; }
boolean checkStr ( String str , int P , int Q ) { int N = str . length ( ) ; char prev = str . charAt ( 0 ) ; int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( str . charAt ( i ) == prev ) { cnt ++ ; } else { if ( prev == '1' && cnt >= Q ) { return false ; } if ( prev == '0' && cnt >= P ) { return false ; } cnt = 1 ; } prev = str . charAt ( i ) ; } if ( prev == '1' && cnt >= Q ) { return false ; } if ( prev == '0' && cnt >= P ) { return false ; } return true ; }
int cntBinStr ( String str , int N , int P , int Q ) { int len = str . length ( ) ; if ( len == N ) { if ( checkStr ( str , P , Q ) ) return 1 ; return 0 ; } int X = cntBinStr ( str + '0' , N , P , Q ) ; int Y = cntBinStr ( str + '1' , N , P , Q ) ; return X + Y ; }
int maxCount ( int arr [ ] , int m , int V ) { int table [ ] = new int [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = - 1 ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ j ] <= i ) { int sub_res = table [ i - arr [ j ] ] ; if ( sub_res != - 1 && sub_res + 1 > table [ i ] ) table [ i ] = sub_res + 1 ; } } } return table [ V ] ; }
int binCoff ( int N , int R ) { int res = 1 ; if ( R > ( N - R ) ) { R = ( N - R ) ; } for ( int i = 0 ; i < R ; i ++ ) { res *= ( N - i ) ; res /= ( i + 1 ) ; } return res ; }
int cntPermutation ( int N ) { int cntPerm ; int C_2N_N = binCoff ( 2 * N , N ) ; cntPerm = C_2N_N / ( N + 1 ) ; return cntPerm ; }
int solve ( int a [ ] [ ] , String s , int n , int prev , int mask , int [ ] [ ] dp ) { if ( mask == 0 ) return 0 ; if ( dp [ mask ] [ prev + 1 ] != - 1 ) return dp [ mask ] [ prev + 1 ] ; int ans = 10000 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int id = s . charAt ( i ) - 'a' ; if ( check ( mask , id ) ) { if ( prev == - 1 ) { ans = Math . min ( ans , solve ( a , s , n , id , mask ^ ( 1 << id ) , dp ) ) ; } else { ans = Math . min ( ans , a [ prev ] [ id ] + solve ( a , s , n , id , mask ^ ( 1 << id ) , dp ) ) ; } } } dp [ mask ] [ prev + 1 ] = ans ; return ans ; }
int longestPalSubstr ( String str ) { int n = str . length ( ) ; int maxLength = 1 , start = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { for ( int j = i ; j < str . length ( ) ; j ++ ) { int flag = 1 ; for ( int k = 0 ; k < ( j - i + 1 ) / 2 ; k ++ ) if ( str . charAt ( i + k ) != str . charAt ( j - k ) ) flag = 0 ; if ( flag != 0 && ( j - i + 1 ) > maxLength ) { start = i ; maxLength = j - i + 1 ; } } } return maxLength ; }
long mElementsWithMaxSum ( long [ ] [ ] matrix , int M , int block , long [ ] [ ] dp ) { if ( block == matrix . length ) return 0 ; if ( dp [ block ] [ M ] != - 1 ) return dp [ block ] [ M ] ; long ans = mElementsWithMaxSum ( matrix , M , block + 1 , dp ) ; for ( int i = 0 ; i < matrix [ block ] . length ; i ++ ) { for ( int j = i ; j < matrix [ block ] . length ; j ++ ) { if ( j - i + 1 <= M ) { ans = Math . max ( ans , matrix [ block ] [ j ] - ( ( i - 1 ) >= 0 ? matrix [ block ] [ i - 1 ] : 0 ) + mElementsWithMaxSum ( matrix , M - j + i - 1 , block + 1 , dp ) ) ; } } } return dp [ block ] [ M ] = ans ; }
void preComputing ( long [ ] [ ] matrix , int N ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < matrix [ i ] . length ; j ++ ) { matrix [ i ] [ j ] = ( j > 0 ? matrix [ i ] [ j - 1 ] : 0 ) + matrix [ i ] [ j ] ; } } }
void mElementsWithMaxSumUtil ( long [ ] [ ] matrix , int M , int N ) { preComputing ( matrix , N ) ; long dp [ ] [ ] = new long [ N + 5 ] [ M + 5 ] ; for ( long i [ ] : dp ) Arrays . fill ( i , - 1 ) ; long sum = mElementsWithMaxSum ( matrix , M , 0 , dp ) ; System . out . print ( sum ) ; }
int lastRemaining ( int n , HashMap < Integer , Integer > dp ) { if ( dp . containsKey ( n ) ) return dp . get ( n ) ; if ( n == 1 ) return 1 ; else dp . put ( n , 2 * ( 1 + n / 2 - lastRemaining ( n / 2 , dp ) ) ) ; return dp . get ( n ) ; }
int Max_Sum ( int [ ] arr , int K , int N ) { int [ ] dp = new int [ N + 1 ] ; Arrays . fill ( dp , 0 ) ; int [ ] prefix = new int [ N + 1 ] ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } dp [ 0 ] = 0 ; for ( int i = 1 ; i <= K - 1 ; i ++ ) { dp [ i ] = prefix [ i ] ; } for ( int i = K ; i <= N ; ++ i ) { for ( int j = i ; j >= ( i - K + 1 ) ; j -- ) { dp [ i ] = Math . max ( dp [ i ] , dp [ j - 1 ] + prefix [ i ] - prefix [ j ] ) ; } } return dp [ N ] ; }
int binomialCoeff ( int n , int k ) { int [ ] [ ] C = new int [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
int waysToSplitN ( int k , int n , int P ) { int new_N = n - k * P ; return binomialCoeff ( new_N + k - 1 , new_N ) ; }
int maximumSumUtil ( int a [ ] , int index , int count , int n ) { if ( index > n count > n + 1 ) { return 0 ; } if ( dp [ index ] [ count ] != - 1 ) return dp [ index ] [ count ] ; int ans1 = maximumSumUtil ( a , index + 1 , count + 1 , n ) + a [ index ] * count ; int ans2 = maximumSumUtil ( a , index + 1 , count , n ) ; return ( dp [ index ] [ count ] = Math . max ( ans1 , ans2 ) ) ; }
void maximumSum ( int arr [ ] , int N ) { for ( int i = 0 ; i < 1005 ; i ++ ) { for ( int j = 0 ; j < 1005 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } System . out . print ( maximumSumUtil ( arr , 0 , 1 , N - 1 ) ) ; }
void Calculate_factorial ( ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i <= mx ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; fact [ i ] %= mod ; } }
int UniModal_per ( int a , int b ) { int res = 1 ; while ( b > 0 ) { if ( b % 2 != 0 ) res = res * a ; res %= mod ; a = a * a ; a %= mod ; b /= 2 ; } return res ; }
void countPermutations ( int n ) { Calculate_factorial ( ) ; int uni_modal = UniModal_per ( 2 , n - 1 ) ; int nonuni_modal = fact [ n ] - uni_modal ; System . out . print ( uni_modal + " " + nonuni_modal ) ; return ; }
void countMinCoinsUtil ( int X , int C [ ] , int N ) { for ( int i = 0 ; i < dp . length ; i ++ ) dp [ i ] = - 1 ; int isPossible = countMinCoins ( X , C , N ) ; if ( isPossible == Integer . MAX_VALUE ) { System . out . print ( "-1" ) ; } else { findSolution ( X , C , N ) ; } }
int helper ( int arr [ ] , int left , int right , int count , int m ) { if ( left > right ) return 0 ; if ( dp [ left ] [ right ] [ count ] != - 1 ) { return dp [ left ] [ right ] [ count ] ; } int ans = ( count + 1 ) * m + helper ( arr , left + 1 , right , 0 , m ) ; for ( int i = left + 1 ; i <= right ; ++ i ) { if ( arr [ i ] == arr [ left ] ) { ans = Math . max ( ans , helper ( arr , left + 1 , i - 1 , 0 , m ) + helper ( arr , i , right , count + 1 , m ) ) ; } } dp [ left ] [ right ] [ count ] = ans ; return ans ; }
int maxPoints ( int arr [ ] , int n , int m ) { int len = n ; for ( int i = 0 ; i < 101 ; i ++ ) { for ( int j = 0 ; j < 101 ; j ++ ) { for ( int k = 0 ; k < 101 ; k ++ ) dp [ i ] [ j ] [ k ] = - 1 ; } } return helper ( arr , 0 , len - 1 , 0 , m ) ; }
int findWays ( int N ) { if ( N == 0 ) { return 1 ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i ) ; } } return cnt ; }
int findWays ( int N , int dp [ ] ) { if ( N == 0 ) { return 1 ; } if ( dp [ N ] != - 1 ) { return dp [ N ] ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i , dp ) ; } } return dp [ N ] = cnt ; }
void findWays ( int N ) { int [ ] dp = new int [ N + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } System . out . print ( dp [ N ] ) ; }
int findWays ( int n ) { n -- ; int a , b , ans ; a = binCoff ( 2 * n , n ) ; b = a / ( n + 1 ) ; ans = b ; return ans ; }
Vector < Integer > find_sequence ( int n ) { Vector < Integer > temp = new Vector < Integer > ( ) ; temp . add ( 1 ) ; temp . add ( - 1 ) ; if ( n == 1 ) return temp ; Vector < Integer > arr = find_sequence ( n - 1 ) ; Vector < Integer > ans = new Vector < Integer > ( n ) ; ans . add ( arr . get ( 0 ) + 1 ) ; ans . add ( n - 1 ) ; if ( n % 2 == 0 ) { Vector < Integer > div_by_2 = find_sequence ( n / 2 ) ; if ( div_by_2 . get ( 0 ) < ans . get ( 0 ) ) { ans . clear ( ) ; ans . add ( div_by_2 . get ( 0 ) + 1 ) ; ans . add ( n / 2 ) ; } } if ( n % 3 == 0 ) { Vector < Integer > div_by_3 = find_sequence ( n / 3 ) ; if ( div_by_3 . get ( 0 ) < ans . get ( 0 ) ) { ans . clear ( ) ; ans . add ( div_by_3 . get ( 0 ) + 1 ) ; ans . add ( n / 3 ) ; } } return ans ; }
int FindNoOfFullVessels ( int n , int t ) { double Matrix [ ] [ ] = new double [ n ] [ n ] ; Matrix [ 0 ] [ 0 ] = t * 1.0 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { double exceededwater = Matrix [ i ] [ j ] - 1.0 ; if ( exceededwater < 0 ) continue ; ans ++ ; if ( i + 1 < n ) Matrix [ i + 1 ] [ j ] += exceededwater / 2 ; if ( i + 1 < n && j + 1 < n ) Matrix [ i + 1 ] [ j + 1 ] += exceededwater / 2 ; } } return ans ; }
int minCountOfNumbers ( int N ) { int k = N % 10 ; int z = N - ( 9 * ( 9 - k ) ) ; if ( z >= 9 && z % 10 == 9 ) { return 10 - k ; } else return - 1 ; }
int checkEqualSumUtil ( int arr [ ] , int N , int sm1 , int sm2 , int sm3 , int j ) { if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } else { int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; return Math . max ( Math . max ( l , m ) , r ) ; } }
int checkEqualSumUtil ( int arr [ ] , int N , int sm1 , int sm2 , int sm3 , int j ) { String s = String . valueOf ( sm1 ) + "_" + String . valueOf ( sm2 ) + String . valueOf ( j ) ; if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } if ( dp . containsKey ( s ) ) return dp . get ( s ) ; else { int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; dp . put ( s , Math . max ( Math . max ( l , m ) , r ) ) ; return dp . get ( s ) ; } }
void checkEqualSum ( int arr [ ] , int N ) { int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { System . out . print ( "Yes" ) ; } else { System . out . print ( "No" ) ; } }
void manipulation ( int [ ] [ ] matrix , int [ ] q ) { int x1 = q [ 0 ] , y1 = q [ 1 ] , x2 = q [ 2 ] , y2 = q [ 3 ] ; for ( int i = x1 - 1 ; i < x2 ; i ++ ) { for ( int j = y1 - 1 ; j < y2 ; j ++ ) { if ( matrix [ i ] [ j ] == 1 ) matrix [ i ] [ j ] = 0 ; else matrix [ i ] [ j ] = 1 ; } } }
int solve ( String s , String t ) { int n = s . length ( ) ; int r = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; if ( i > 0 ) { dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j ] ) ; } if ( s . charAt ( i ) == t . charAt ( j ) ) { int ans = 1 ; if ( i > 0 && j > 0 ) { ans = 1 + dp [ i - 1 ] [ j - 1 ] ; } dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , ans ) ; r = Math . max ( r , dp [ i ] [ j ] ) ; } } } return ( n - r ) ; }
int min_op ( int cur , int M ) { if ( cur > M ) return INF ; if ( cur == M ) return 0 ; int op = INF ; for ( int i = 2 ; i * i <= cur ; i ++ ) { if ( cur % i == 0 ) { if ( i % 2 == 0 ) { op = Math . min ( op , 1 + min_op ( cur + i , M ) ) ; } if ( ( cur / i ) != i && ( cur / i ) % 2 == 0 ) { op = Math . min ( op , 1 + min_op ( cur + ( cur / i ) , M ) ) ; } } } return op ; }
int min_op ( int cur , int M ) { if ( cur > M ) return INF ; if ( cur == M ) return 0 ; if ( dp [ cur ] != - 1 ) return dp [ cur ] ; int op = INF ; for ( int i = 2 ; i * i <= cur ; i ++ ) { if ( cur % i == 0 ) { if ( i % 2 == 0 ) { op = Math . min ( op , 1 + min_op ( cur + i , M ) ) ; } if ( ( cur / i ) != i && ( cur / i ) % 2 == 0 ) { op = Math . min ( op , 1 + min_op ( cur + ( cur / i ) , M ) ) ; } } } return dp [ cur ] = op ; }
int min_operations ( int N , int M ) { for ( int i = N ; i <= M ; i ++ ) { dp [ i ] = - 1 ; } return min_op ( N , M ) ; }
int solve ( int [ ] a ) { int n = a . length ; int [ ] dp = new int [ n + 1 ] ; int [ ] val = new int [ n + 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int sum = a [ i ] ; int j = i ; while ( j + 1 < n && sum < val [ j + 1 ] ) { j ++ ; sum += a [ j ] ; } dp [ i ] = ( j - i ) + dp [ j + 1 ] ; val [ i ] = sum ; } return dp [ 0 ] ; }
int [ ] findPrimeFactors ( int n ) { int [ ] primeFactors = new int [ 9 ] ; int j = 0 ; if ( n % 2 == 0 ) { primeFactors [ j ++ ] = 2 ; while ( n % 2 == 0 ) n >>= 1 ; } for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) { primeFactors [ j ++ ] = i ; while ( n % i == 0 ) n /= i ; } } if ( n > 2 ) primeFactors [ j ++ ] = n ; return Arrays . copyOfRange ( primeFactors , 0 , j ) ; }
void findShortestSubsequence ( int [ ] dp , int [ ] a , int index , int [ ] primeFactors ) { int n = a . length ; for ( int j = index ; j < n ; j ++ ) { int bitmask = 0 ; for ( int p = 0 ; p < primeFactors . length ; p ++ ) { if ( a [ j ] % primeFactors [ p ] == 0 ) { bitmask ^= ( 1 << p ) ; } } for ( int i = 0 ; i < dp . length ; i ++ ) { if ( dp [ i ] == n + 1 ) continue ; dp [ bitmask & i ] = Math . min ( dp [ bitmask & i ] , dp [ i ] + 1 ) ; } } }
int minDays ( int n ) { if ( n < 1 ) return n ; int cnt = 1 + Math . min ( n % 2 + minDays ( n / 2 ) , n % 3 + minDays ( n / 3 ) ) ; return cnt ; }
int count ( int n ) { HashMap < Integer , Integer > dp = new HashMap < Integer , Integer > ( ) ; dp . put ( 0 , 0 ) ; dp . put ( 1 , 1 ) ; if ( ! dp . containsKey ( n ) ) dp . put ( n , 1 + Math . min ( n % 2 + count ( n / 2 ) , n % 3 + count ( n / 3 ) ) ) ; return dp . get ( n ) ; }
int findMaxTimes ( String S ) { int [ ] arr = new int [ 26 ] ; int [ ] [ ] dp = new int [ 26 ] [ 26 ] ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { int now = S . charAt ( i ) - 'a' ; for ( int j = 0 ; j < 26 ; j ++ ) { dp [ j ] [ now ] += arr [ j ] ; } arr [ now ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) ans = Math . max ( ans , arr [ i ] ) ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { ans = Math . max ( ans , dp [ i ] [ j ] ) ; } } return ans ; }
int xorSum ( int a [ ] , int n , int mask , int [ ] dp ) { if ( dp [ mask ] != - 1 ) { return dp [ mask ] ; } int max_value = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( i != j && ( mask & ( 1 << i ) ) == 0 && ( mask & ( 1 << j ) ) == 0 ) { max_value = Math . max ( max_value , ( a [ i ] ^ a [ j ] ) + xorSum ( a , n , ( mask | ( 1 << i ) | ( 1 << j ) ) , dp ) ) ; } } } return dp [ mask ] = max_value ; }
int maxValue ( int a [ ] , int n , int pos , int moves , int left , int dp [ ] [ ] ) { if ( moves == 0 || ( pos > n - 1 pos < 0 ) ) return 0 ; if ( dp [ pos ] [ left ] != - 1 ) return dp [ pos ] [ left ] ; int value = 0 ; if ( left > 0 && pos >= 1 ) value = Math . max ( value , a [ pos ] + maxValue ( a , n , pos - 1 , moves - 1 , left - 1 , dp ) ) ; if ( pos <= n - 1 ) value = Math . max ( value , a [ pos ] + maxValue ( a , n , pos + 1 , moves - 1 , left , dp ) ) ; return dp [ pos ] [ left ] = value ; }
int maximumSum ( int [ ] a , int count , int index , int n , int [ ] [ ] dp ) { if ( index == n ) return 0 ; if ( dp [ index ] [ count ] != - 1 ) return dp [ index ] [ count ] ; int take_element = a [ index ] * count + maximumSum ( a , count + 1 , index + 1 , n , dp ) ; int dont_take = maximumSum ( a , count , index + 1 , n , dp ) ; return dp [ index ] [ count ] = Math . max ( take_element , dont_take ) ; }
void fibonacci ( ) { fib [ 1 ] = 1 ; fib [ 2 ] = 2 ; for ( int i = 3 ; i <= 87 ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } }
long find ( int num ) { int cnt = 0 ; for ( int i = 87 ; i > 0 ; i -- ) { if ( num >= fib [ i ] ) { v [ cnt ++ ] = i ; num -= fib [ i ] ; } } for ( int i = 0 ; i < cnt / 2 ; i ++ ) { long t = v [ i ] ; v [ i ] = v [ cnt - i - 1 ] ; v [ cnt - i - 1 ] = t ; } dp1 [ 0 ] = 1 ; dp2 [ 0 ] = ( v [ 0 ] - 1 ) / 2 ; for ( int i = 1 ; i < cnt ; i ++ ) { dp1 [ i ] = dp1 [ i - 1 ] + dp2 [ i - 1 ] ; dp2 [ i ] = ( ( v [ i ] - v [ i - 1 ] ) / 2 ) * dp2 [ i - 1 ] + ( ( v [ i ] - v [ i - 1 ] - 1 ) / 2 ) * dp1 [ i - 1 ] ; } return ( dp1 [ cnt - 1 ] + dp2 [ cnt - 1 ] ) ; }
int [ ] preprocess ( int [ ] a , int n ) { int p [ ] = new int [ n ] ; p [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) p [ i ] = p [ i - 1 ] + a [ i ] ; return p ; }
int Combine ( int [ ] p , int i , int j ) { if ( i == 0 ) return p [ j ] ; else return p [ j ] - p [ i - 1 ] ; }
int minCost ( int a [ ] , int i , int j , int k , int [ ] prefix , int [ ] [ ] dp ) { if ( i >= j ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; int best_cost = inf ; for ( int pos = i ; pos < j ; pos ++ ) { int left = minCost ( a , i , pos , k , prefix , dp ) ; int right = minCost ( a , pos + 1 , j , k , prefix , dp ) ; best_cost = Math . min ( best_cost , left + right + ( k * Combine ( prefix , i , j ) ) ) ; } return dp [ i ] [ j ] = best_cost ; }
void countNums ( int N ) { int l = ( int ) Math . pow ( 10 , N - 1 ) , r = ( int ) Math . pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int xor = 0 , temp = i ; while ( temp > 0 ) { xor = xor ^ ( temp % 10 ) ; temp /= 10 ; } if ( xor <= 9 ) count ++ ; } System . out . println ( count ) ; }
int distinctSimilarSubstrings ( String str ) { int n = str . length ( ) ; if ( n <= 1 ) return 0 ; long dp [ ] [ ] = new long [ n + 1 ] [ n + 1 ] ; ArrayList < String > list = new ArrayList < String > ( ) ; for ( int j = n - 1 ; j >= 0 ; j -- ) { for ( int i = j - 1 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == str . charAt ( j ) ) { dp [ i ] [ j ] = dp [ i + 1 ] [ j + 1 ] + 1 ; } else { dp [ i ] [ j ] = 0 ; } if ( dp [ i ] [ j ] >= j - i ) { list . add ( str . substring ( j - i , i ) ) ; } } } return list . size ( ) ; }
void SubarrayWithMaxSum ( Vector < Integer > nums ) { int endIndex = 0 , currMax = nums . get ( 0 ) ; int globalMax = nums . get ( 0 ) ; for ( int i = 1 ; i < nums . size ( ) ; ++ i ) { currMax = Math . max ( nums . get ( i ) , nums . get ( i ) + currMax ) ; if ( currMax > globalMax ) { globalMax = currMax ; endIndex = i ; } } int startIndex = endIndex ; while ( startIndex >= 0 ) { globalMax -= nums . get ( startIndex ) ; if ( globalMax == 0 ) break ; startIndex -- ; } for ( int i = startIndex ; i <= endIndex ; ++ i ) { System . out . print ( nums . get ( i ) + " " ) ; } }
int count ( int a [ ] , int M , int N ) { int cnt = 0 ; for ( int i = 1 ; i <= M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i % a [ j ] == 0 ) { cnt ++ ; break ; } } } return cnt ; }
void sieve ( ) { primes = new ArrayList < > ( ) ; boolean mark [ ] = new boolean [ M ] ; for ( int i = 2 ; i < M ; i ++ ) mark [ i ] = true ; for ( int i = 2 ; i * i < M ; i ++ ) { if ( mark [ i ] ) { for ( int j = i * i ; j < M ; j += i ) mark [ j ] = false ; } } for ( int i = 2 ; i < M ; i ++ ) if ( mark [ i ] ) primes . add ( i ) ; }
void countPrimonacci ( int l , int r ) { ArrayList < Integer > dp = new ArrayList < > ( ) ; dp . add ( 1 ) ; dp . add ( 1 ) ; int i = 2 ; HashSet < Integer > s = new HashSet < > ( ) ; while ( true ) { int x = 0 ; for ( int j = 0 ; j < primes . size ( ) ; j ++ ) { int p = primes . get ( j ) ; if ( p >= i ) break ; x += dp . get ( i - p ) ; } if ( x >= l && x <= r ) s . add ( x ) ; if ( x > r ) break ; dp . add ( x ) ; i ++ ; } System . out . println ( s . size ( ) ) ; }
long minSum ( int n , int num [ ] , int price [ ] ) { long dp [ ] = new long [ n ] ; Arrays . fill ( dp , Integer . MAX_VALUE ) ; long ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( num [ j ] > num [ i ] ) { dp [ j ] = ( long ) Math . min ( ( long ) dp [ j ] , ( long ) price [ i ] + ( long ) price [ j ] ) ; ans = Math . min ( ans , ( long ) dp [ i ] + ( long ) price [ j ] ) ; } } } return ans != Integer . MAX_VALUE ? ans : - 1 ; }
void SieveOfEratosthenes ( ) { Arrays . fill ( prime , 1 ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == 1 ) { for ( int i = p * p ; i <= MAX - 1 ; i += p ) prime [ i ] = 0 ; } } }
int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; }
int getSumUtil ( int [ ] st , int ss , int se , int qs , int qe , int si ) { if ( qs <= ss && qe >= se ) return st [ si ] ; if ( se < qs ss > qe ) return 0 ; int mid = getMid ( ss , se ) ; return getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ; }
void updateValueUtil ( int [ ] st , int ss , int se , int i , int diff , int si ) { if ( i < ss i > se ) return ; st [ si ] = st [ si ] + diff ; if ( se != ss ) { int mid = getMid ( ss , se ) ; updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) ; updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) ; } }
void updateValue ( int arr [ ] , int [ ] st , int n , int i , int new_val ) { if ( i < 0 i > n - 1 ) { System . out . print ( "-1" ) ; return ; } int diff = new_val - arr [ i ] ; int prev_val = arr [ i ] ; arr [ i ] = new_val ; if ( ( prime [ new_val ] prime [ prev_val ] ) != 0 ) { if ( prime [ prev_val ] == 0 ) updateValueUtil ( st , 0 , n - 1 , i , new_val , 0 ) ; else if ( prime [ new_val ] == 0 ) updateValueUtil ( st , 0 , n - 1 , i , - prev_val , 0 ) ; else updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) ; } }
int getSum ( int [ ] st , int n , int qs , int qe ) { if ( qs < 0 qe > n - 1 qs > qe ) { System . out . println ( "-1" ) ; return - 1 ; } return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) ; }
long countStrings ( int N ) { if ( N % 2 == 1 ) return 0 ; else { N /= 2 ; long c = binomialCoeff ( 2 * N , N ) ; return c / ( N + 1 ) ; } }
int solve ( int n , int k , int mod , int dp [ ] ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; int cnt = 0 ; for ( int i = 2 ; i <= k ; i += 2 ) { cnt = ( cnt % mod + solve ( n - i , k , mod , dp ) % mod ) % mod ; } dp [ n ] = cnt ; return cnt ; }
void fact ( ) { f [ 0 ] = f [ 1 ] = 1 ; for ( int i = 2 ; i <= 10 ; i ++ ) f [ i ] = i * 1 * f [ i - 1 ] ; }
void dfs2 ( int a , int par ) { for ( pair i : v . get ( a ) ) { if ( i . first == par ) continue ; int leafOutside = leaves [ a ] - leaves [ i . first ] ; dp [ i . first ] += ( dp [ a ] - dp [ i . first ] ) ; dp [ i . first ] += i . second * ( leafOutside - leaves [ i . first ] ) ; leaves [ i . first ] += leafOutside ; dfs2 ( i . first , a ) ; } }
int countPairs ( Node first , Node second , int value ) { int count = 0 ; while ( first != null && second != null && first != second && second . next != first ) { if ( ( first . data + second . data ) == value ) { count ++ ; first = first . next ; second = second . prev ; } else if ( ( first . data + second . data ) > value ) second = second . prev ; else first = first . next ; } return count ; }
int countTriplets ( Node head , int x ) { if ( head == null ) return 0 ; Node current , first , last ; int count = 0 ; last = head ; while ( last . next != null ) last = last . next ; for ( current = head ; current != null ; current = current . next ) { first = current . next ; count += countPairs ( first , last , x - current . data ) ; } return count ; }
int countChanges ( int matrix [ ] [ ] , int n , int m ) { int i , j , dist = n + m - 1 ; int Max_element = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { Max_element = Math . max ( Max_element , matrix [ i ] [ j ] ) ; } } int freq [ ] [ ] = new int [ dist ] [ Max_element + 1 ] ; for ( i = 0 ; i < dist ; i ++ ) { for ( j = 0 ; j < Max_element + 1 ; j ++ ) freq [ i ] [ j ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { freq [ i + j ] [ matrix [ i ] [ j ] ] ++ ; } } int min_changes_sum = 0 ; for ( i = 0 ; i < dist / 2 ; i ++ ) { int maximum = 0 ; int total_values = 0 ; for ( j = 0 ; j < Max_element + 1 ; j ++ ) { maximum = Math . max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; total_values += freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ; } min_changes_sum += total_values - maximum ; } return min_changes_sum ; }
void maxLength ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = 1 ; } for ( int i = n - 1 ; i > 1 ; i -- ) { for ( int j = 1 ; j <= Math . sqrt ( i ) ; j ++ ) { if ( i % j == 0 ) { int s = i / j ; if ( s == j ) { if ( arr [ i ] > arr [ s ] ) { dp [ s ] = Math . max ( dp [ i ] + 1 , dp [ s ] ) ; } } else { if ( s != i && arr [ i ] > arr [ s ] ) dp [ s ] = Math . max ( dp [ i ] + 1 , dp [ s ] ) ; if ( arr [ i ] > arr [ j ] ) { dp [ j ] = Math . max ( dp [ i ] + 1 , dp [ j ] ) ; } } } } } int max = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( dp [ i ] > max ) max = dp [ i ] ; } System . out . println ( max ) ; }
int maxProfit ( int price [ ] , int n ) { int buy1 , profit1 , buy2 , profit2 ; buy1 = buy2 = Integer . MAX_VALUE ; profit1 = profit2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { buy1 = Math . min ( buy1 , price [ i ] ) ; profit1 = Math . max ( profit1 , price [ i ] - buy1 ) ; buy2 = Math . min ( buy2 , price [ i ] - profit1 ) ; profit2 = Math . max ( profit2 , price [ i ] - buy2 ) ; } return profit2 ; }
int validsubsequences ( int arr [ ] , int n ) { long dp [ ] [ ] = new long [ n + 1 ] [ 2 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] [ 0 ] = 0 ; dp [ i ] [ 1 ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 != 0 ) { dp [ i ] [ 1 ] += 1 ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 0 ] ; } else { dp [ i ] [ 0 ] += 1 ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 1 ] ; } } return ( int ) ( dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ) ; }
long getCount ( int n , int k ) { if ( n == 1 ) return 10 ; long dp [ ] [ ] = new long [ n + 1 ] [ 11 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { int l = Math . max ( 0 , j - k ) ; int r = Math . min ( 9 , j + k ) ; dp [ i ] [ l ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ r + 1 ] -= dp [ i - 1 ] [ j ] ; } for ( int j = 1 ; j <= 9 ; j ++ ) dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } long count = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) count += dp [ n ] [ i ] ; return count ; }
boolean existPath ( int V , int edges [ ] [ ] , int u , int v ) { boolean [ ] [ ] mat = new boolean [ V ] [ V ] ; for ( int i = 0 ; i < X ; i ++ ) mat [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = true ; for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { mat [ i ] [ j ] = mat [ i ] [ j ] || mat [ i ] [ k ] && mat [ k ] [ j ] ; } } } if ( u >= V v >= V ) { return false ; } if ( mat [ u ] [ v ] ) return true ; return false ; }
int calculate_maximum_splits ( int arr [ ] , int N ) { int pre [ ] = { 0 , - 1 , - 1 } ; int [ ] dp = new int [ N ] ; Arrays . fill ( dp , 0 ) ; int C = 0 ; for ( int i = 0 ; i < N ; i ++ ) { C = C + arr [ i ] ; C = C % 3 ; if ( pre [ C ] == - 1 ) { if ( 1 <= i ) dp [ i ] = dp [ i - 1 ] ; } else { dp [ i ] = Math . max ( dp [ i - 1 ] , dp [ pre [ C ] ] + 1 ) ; } pre [ C ] = i ; } return dp [ N - 1 ] ; }
int solve ( int n , int last , int k ) { if ( n == 1 ) { if ( last == k ) { return ( k - 1 ) ; } else { return 1 ; } } if ( dp [ n ] [ last ] == 1 ) return dp [ n ] [ last ] ; if ( last == k ) { return dp [ n ] [ last ] = ( k - 1 ) * solve ( n - 1 , k , k ) + ( k - 1 ) * solve ( n - 1 , 1 , k ) ; } else { return dp [ n ] [ last ] = solve ( n - 1 , k , k ) ; } }
int mergeTwoNumbers ( int [ ] numbers ) { int len , i , j , k ; int n = numbers . length ; if ( numbers . length == 0 ) { return 0 ; } int [ ] prefixSum = new int [ n + 1 ] ; for ( i = 1 ; i <= n ; i ++ ) { prefixSum [ i ] = prefixSum [ i - 1 ] + numbers [ i - 1 ] ; } int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( len = 2 ; len <= n ; len ++ ) { for ( i = 1 ; i <= n - len + 1 ; i ++ ) { j = i + len - 1 ; int sum = prefixSum [ j ] - prefixSum [ i - 1 ] ; dp [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + sum ) ; } } } return dp [ 1 ] [ n ] ; }
void seiveOfEratosthenes ( ) { for ( int i = 2 ; i < 1000001 ; i ++ ) { prime [ i ] = 1 ; } for ( int i = 2 ; i * i < 1000001 ; i ++ ) { if ( prime [ i ] == 1 ) { for ( int j = i * i ; j < 1000001 ; j += i ) { prime [ j ] = 0 ; } } } }
Vector < Integer > constructPath ( int u , int v ) { if ( Next [ u ] [ v ] == - 1 ) return null ; Vector < Integer > path = new Vector < Integer > ( ) ; path . add ( u ) ; while ( u != v ) { u = Next [ u ] [ v ] ; path . add ( u ) ; } return path ; }
void floydWarshall ( int V ) { for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( dis [ i ] [ k ] == INF dis [ k ] [ j ] == INF ) continue ; if ( dis [ i ] [ j ] > dis [ i ] [ k ] + dis [ k ] [ j ] ) { dis [ i ] [ j ] = dis [ i ] [ k ] + dis [ k ] [ j ] ; Next [ i ] [ j ] = Next [ i ] [ k ] ; } } } } }
int maximumSum ( int A [ ] , int B [ ] , int length , int X , int Y ) { int l = length ; int l1 = Math . min ( length , X ) ; int l2 = Math . min ( length , Y ) ; int dp [ ] [ ] = new int [ l1 + 1 ] [ l2 + 1 ] ; int max_sum = Integer . MIN_VALUE ; for ( int i = 1 ; i <= l1 ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + A [ i - 1 ] ; max_sum = Math . max ( max_sum , dp [ i ] [ 0 ] ) ; } for ( int i = 1 ; i <= l2 ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + B [ i - 1 ] ; max_sum = Math . max ( max_sum , dp [ 0 ] [ i ] ) ; } for ( int i = 1 ; i <= l1 ; i ++ ) { for ( int j = 1 ; j <= l2 ; j ++ ) { if ( i + j <= l ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] + A [ i + j - 1 ] , dp [ i ] [ j - 1 ] + B [ i + j - 1 ] ) ; max_sum = Math . max ( dp [ i ] [ j ] , max_sum ) ; } } return max_sum ; }
void finding_factors ( int n ) { int i , a ; for ( i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i == n ) { vp [ n ] . add ( i ) ; } else { vp [ n ] . add ( i ) ; vp [ n ] . add ( n / i ) ; } } } }
int countSeq ( int N , int K ) { int i , j , k ; int dp [ ] [ ] = new int [ 109 ] [ 109 ] ; for ( i = 1 ; i <= N ; i ++ ) { finding_factors ( i ) ; dp [ 0 ] [ i ] = 0 ; dp [ 1 ] [ i ] = 1 ; } for ( i = 2 ; i <= K ; i ++ ) { for ( j = 1 ; j <= N ; j ++ ) { int sum = 0 ; for ( k = 0 ; k < vp [ j ] . size ( ) ; k ++ ) { sum = ( sum + dp [ i - 1 ] [ vp [ j ] . get ( k ) ] ) ; } dp [ i ] [ j ] = sum ; } } int ans = 0 ; for ( j = 1 ; j <= N ; j ++ ) { ans = ( ans + dp [ K ] [ j ] ) ; } return ans ; }
void find_minimum_operations ( int n , int b [ ] , int k ) { int d [ ] = new int [ n + 1 ] ; int i , operations = 0 , need ; for ( i = 0 ; i < n ; i ++ ) { if ( i > 0 ) { d [ i ] += d [ i - 1 ] ; } if ( b [ i ] > d [ i ] ) { operations += b [ i ] - d [ i ] ; need = b [ i ] - d [ i ] ; d [ i ] += need ; if ( i + k <= n ) { d [ i + k ] -= need ; } } } System . out . println ( operations ) ; }
void sieve ( ) { Arrays . fill ( primes , true ) ; primes [ 0 ] = false ; primes [ 1 ] = false ; for ( int i = 2 ; i * i <= maxn ; i ++ ) { if ( primes [ i ] ) { for ( int j = i * i ; j <= maxn ; j += i ) primes [ j ] = false ; } } }
int printpentaRec ( int n ) { if ( n == 0 n == 1 n == 2 n == 3 n == 4 ) return 0 ; else if ( n == 5 ) return 1 ; else return ( printpentaRec ( n - 1 ) + printpentaRec ( n - 2 ) + printpentaRec ( n - 3 ) + printpentaRec ( n - 4 ) + printpentaRec ( n - 5 ) ) ; }
int possibleBinaries ( int pos , int ones , int sum , int k ) { if ( ones == k ) return 0 ; if ( pos == 0 ) return ( sum == 0 ) ? 1 : 0 ; if ( dp [ pos ] [ ones ] [ sum ] != - 1 ) return dp [ pos ] [ ones ] [ sum ] ; int ret = possibleBinaries ( pos - 1 , ones + 1 , ( sum + 1 ) % 2 , k ) + possibleBinaries ( pos - 1 , 0 , sum , k ) ; dp [ pos ] [ ones ] [ sum ] = ret ; return dp [ pos ] [ ones ] [ sum ] ; }
int MAX_value ( int [ ] [ ] arr ) { int row = arr . length ; int col = arr [ 0 ] . length ; int [ ] [ ] dp = new int [ row ] [ col ] ; int i = 0 , j = 0 ; int c = arr [ 0 ] [ 0 ] , p = 0 ; int d = row ; for ( i = 0 ; i < d ; i ++ ) { for ( j = 0 ; j < d ; j ++ ) { if ( c < arr [ i ] [ j ] ) { c = arr [ i ] [ j ] ; } if ( i == 0 j == 0 ) { dp [ i ] [ j ] = 1 ; } else { if ( arr [ i - 1 ] [ j - 1 ] == arr [ i ] [ j ] && arr [ i - 1 ] [ j ] == arr [ i ] [ j ] && arr [ i ] [ j - 1 ] == arr [ i ] [ j ] ) { dp [ i ] [ j ] = Math . min ( dp [ i - 1 ] [ j - 1 ] , Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ) + 1 ; } else { dp [ i ] [ j ] = 1 ; } } } } for ( i = 0 ; i < d ; i ++ ) { for ( j = 0 ; j < d ; j ++ ) { if ( arr [ i ] [ j ] == c ) { if ( p < dp [ i ] [ j ] ) { p = dp [ i ] [ j ] ; } } } } return p * p ; }
void printList ( Node head ) { if ( head == null ) System . out . print ( "Doubly Linked list empty" ) ; while ( head != null ) { System . out . print ( head . data + " " ) ; head = head . next ; } }
int countStableNum ( String str , int N ) { int count1 [ ] [ ] = new int [ N ] [ 10 ] ; int count2 [ ] [ ] = new int [ N ] [ 10 ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < 10 ; j ++ ) count1 [ i ] [ j ] = count2 [ i ] [ j ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i != 0 ) { for ( int j = 0 ; j < 10 ; j ++ ) { count1 [ i ] [ j ] += count1 [ i - 1 ] [ j ] ; } } count1 [ i ] [ str . charAt ( i ) - '0' ] ++ ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i != N - 1 ) { for ( int j = 0 ; j < 10 ; j ++ ) { count2 [ i ] [ j ] += count2 [ i + 1 ] [ j ] ; } } count2 [ i ] [ str . charAt ( i ) - '0' ] ++ ; } int ans = 0 ; for ( int i = 1 ; i < N - 1 ; i ++ ) { if ( str . charAt ( i ) == '9' ) continue ; int c1 = count1 [ i - 1 ] [ str . charAt ( i ) - '0' ] ; int c2 = count2 [ i + 1 ] [ str . charAt ( i ) - '0' + 1 ] ; if ( c2 == 0 ) continue ; ans = ( ans + ( c1 * ( ( c2 * ( c2 - 1 ) / 2 ) ) ) ) ; } return ans ; }
long countWays ( String s , String t , int k ) { int n = s . length ( ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String p = s . substring ( i , n - i ) + s . substring ( 0 , i ) ; if ( p == t ) a ++ ; else b ++ ; } long dp1 [ ] = new long [ k + 1 ] ; long dp2 [ ] = new long [ k + 1 ] ; if ( s == t ) { dp1 [ 0 ] = 1 ; dp2 [ 0 ] = 0 ; } else { dp1 [ 0 ] = 0 ; dp2 [ 0 ] = 1 ; } for ( int i = 1 ; i <= k ; i ++ ) { dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod ; dp2 [ i ] = ( ( dp1 [ i - 1 ] * ( b ) ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod ; } return dp1 [ k ] ; }
void dfs1 ( int u , int par , Vector < Vector < Integer > > g , int [ ] weight ) { dp1 [ u ] = weight [ u ] ; for ( int c = 0 ; c < g . get ( u ) . size ( ) ; c ++ ) { if ( g . get ( u ) . get ( c ) != par ) { dfs1 ( g . get ( u ) . get ( c ) , u , g , weight ) ; dp1 [ u ] += Math . max ( 0 , dp1 [ g . get ( u ) . get ( c ) ] ) ; } } }
void dfs2 ( int u , int par , Vector < Vector < Integer > > g , int [ ] weight ) { if ( par != 0 ) { int maxSumAncestors = dp2 [ par ] - Math . max ( 0 , dp1 [ u ] ) ; dp2 [ u ] = dp1 [ u ] + Math . max ( 0 , maxSumAncestors ) ; } for ( int c = 0 ; c < g . get ( u ) . size ( ) ; c ++ ) { if ( g . get ( u ) . get ( c ) != par ) { dfs2 ( g . get ( u ) . get ( c ) , u , g , weight ) ; } } }
void addEdge ( int u , int v , Vector < Vector < Integer > > g ) { g . get ( u ) . add ( v ) ; g . get ( v ) . add ( u ) ; }
void maxSumSegments ( Vector < Vector < Integer > > g , int [ ] weight , int n ) { dfs1 ( 1 , 0 , g , weight ) ; for ( int i = 1 ; i < n + 1 ; i ++ ) dp2 [ i ] = dp1 [ i ] ; dfs2 ( 1 , 0 , g , weight ) ; }
void printAns ( int n ) { for ( int i = 1 ; i < n ; i ++ ) System . out . print ( dp2 [ i ] + " " ) ; }
void countMaximum ( Integer [ ] a , int n ) { Arrays . sort ( a , Collections . reverseOrder ( ) ) ; int count = 0 ; int mark = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ( a [ i ] + n >= mark ) ) { count += 1 ; } mark = Math . max ( mark , a [ i ] + i + 1 ) ; } System . out . print ( count ) ; }
int CountWays ( int i , int j , int k ) { if ( i >= N i < 0 j >= M j < 0 k < 0 ) return 0 ; if ( i == 0 && j == 0 && k == 0 ) return 1 ; if ( dp [ i ] [ j ] [ k ] != - 1 ) return dp [ i ] [ j ] [ k ] ; else dp [ i ] [ j ] [ k ] = ( CountWays ( i + 1 , j , k - 1 ) % MOD + CountWays ( i - 1 , j , k - 1 ) % MOD + CountWays ( i , j - 1 , k - 1 ) % MOD + CountWays ( i , j + 1 , k - 1 ) % MOD + CountWays ( i , j , k - 1 ) % MOD ) % MOD ; return dp [ i ] [ j ] [ k ] ; }
int smallestNum ( int n ) { int res = 1 ; for ( int i = 2 ; ; i *= 2 ) { int length = ( int ) ( Math . log10 ( i ) ) + 1 ; if ( length == n ) return ( int ) ( Math . log ( i ) / Math . log ( 2 ) ) ; } }
int findResultUtil ( int arr [ ] , int L , int R ) { int result = 0 ; boolean flag = false ; for ( int i = L ; i <= R ; i ++ ) { if ( flag == false ) { result = result + arr [ i ] ; flag = true ; } else { result = result - arr [ i ] ; flag = false ; } } return result ; }
boolean isKPartitionPossible ( int arr [ ] , int N , int K ) { if ( K == 1 ) return true ; if ( N < K ) return false ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % K != 0 ) return false ; int target = sum / K ; int [ ] dp = new int [ ( 1 << 15 ) ] ; for ( int i = 0 ; i < ( 1 << N ) ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( int mask = 0 ; mask < ( 1 << N ) ; mask ++ ) { if ( dp [ mask ] == - 1 ) continue ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( ( mask & ( 1 << i ) ) == 0 ) && dp [ mask ] + arr [ i ] <= target ) { dp [ mask ( 1 << i ) ] = ( dp [ mask ] + arr [ i ] ) % target ; } } } if ( dp [ ( 1 << N ) - 1 ] == 0 ) return true ; else return false ; }
long min_operation ( long i , long j , long val , long x ) { if ( i == n - 1 && j == m - 1 ) { if ( val > v . get ( ( int ) i ) . get ( ( int ) j ) ) { return dp [ ( int ) i ] [ ( int ) j ] = MAX ; } else { return dp [ ( int ) i ] [ ( int ) j ] = v . get ( ( int ) i ) . get ( ( int ) j ) - val ; } } if ( i == n j == m ) { return dp [ ( int ) i ] [ ( int ) j ] = MAX ; } if ( dp [ ( int ) i ] [ ( int ) j ] != - 1 ) { return dp [ ( int ) i ] [ ( int ) j ] ; } if ( val > v . get ( ( int ) i ) . get ( ( int ) j ) ) { return dp [ ( int ) i ] [ ( int ) j ] = MAX ; } long tmp = v . get ( ( int ) i ) . get ( ( int ) j ) - val ; tmp += Math . min ( min_operation ( i + 1 , j , val + x , x ) , min_operation ( i , j + 1 , val + x , x ) ) ; return dp [ ( int ) i ] [ ( int ) j ] = tmp ; }
long solve ( long x ) { long ans = Long . MAX_VALUE ; for ( long i = 0 ; i < n ; i ++ ) { for ( long j = 0 ; j < m ; j ++ ) { long val = v . get ( ( int ) i ) . get ( ( int ) j ) - x * ( i + j ) ; for ( int k = 0 ; k < dp . length ; k ++ ) for ( int l = 0 ; l < dp [ k ] . length ; l ++ ) dp [ k ] [ l ] = - 1 ; val = min_operation ( 0l , 0l , val , x ) ; ans = Math . min ( ans , val ) ; } } return ans ; }
void printList ( Node head ) { if ( head == null ) System . out . println ( "Doubly Linked list empty" ) ; while ( head != null ) { System . out . print ( head . data + " " ) ; head = head . next ; } }
int Count ( int S [ ] , int m , int n ) { int [ ] [ ] table = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { table [ 0 ] [ i ] = Integer . MAX_VALUE - 1 ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( S [ i - 1 ] > j ) { table [ i ] [ j ] = table [ i - 1 ] [ j ] ; } else { table [ i ] [ j ] = Math . min ( table [ i - 1 ] [ j ] , table [ i ] [ j - S [ i - 1 ] ] + 1 ) ; } } } return table [ m ] [ n ] ; }
int maxProductUtil ( int X , int Y , int [ ] A , int [ ] B , int [ ] [ ] dp ) { if ( X < 0 Y < 0 ) return - INF ; if ( dp [ X ] [ Y ] != - 1 ) return dp [ X ] [ Y ] ; dp [ X ] [ Y ] = maximum ( A [ X ] * B [ Y ] + maxProductUtil ( X - 1 , Y - 1 , A , B , dp ) , A [ X ] * B [ Y ] , maxProductUtil ( X - 1 , Y , A , B , dp ) , maxProductUtil ( X , Y - 1 , A , B , dp ) ) ; return dp [ X ] [ Y ] ; }
int maxProduct ( int A [ ] , int N , int B [ ] , int M ) { int [ ] [ ] dp = new int [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return maxProductUtil ( N - 1 , M - 1 , A , B , dp ) ; }
int minOperation ( int k ) { int dp [ ] = new int [ k + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ; if ( i % 2 == 0 ) { dp [ i ] = Math . min ( dp [ i ] , dp [ i / 2 ] + 1 ) ; } } return dp [ k ] ; }
int maximumSum ( int S , int M , int N , int [ ] [ ] stacks ) { int [ ] [ ] dp = new int [ S + 1 ] [ N + 1 ] ; for ( int i = 0 ; i < S ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { for ( int k = 0 ; k <= Math . min ( j , M ) ; k ++ ) { dp [ i + 1 ] [ j ] = Math . max ( dp [ i + 1 ] [ j ] , stacks [ i ] [ k ] + dp [ i ] [ j - k ] ) ; } } } int result = Integer . MIN_VALUE ; for ( int i = 0 ; i <= N ; i ++ ) { result = Math . max ( result , dp [ S ] [ i ] ) ; } return result ; }
int findSum ( int [ ] arr , int n ) { int totalSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { totalSum += arr [ i ] ; } int [ ] [ ] dp = new int [ 2 ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ 0 ] [ i ] = 1 ; dp [ 1 ] [ i ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { if ( dp [ 0 ] [ i ] < dp [ 0 ] [ j ] + 1 ) { dp [ 0 ] [ i ] = dp [ 0 ] [ j ] + 1 ; dp [ 1 ] [ i ] = dp [ 1 ] [ j ] + arr [ i ] ; } else if ( dp [ 0 ] [ i ] == dp [ 0 ] [ j ] + 1 ) { dp [ 1 ] [ i ] = Math . min ( dp [ 1 ] [ i ] , dp [ 1 ] [ j ] + arr [ i ] ) ; } } } } int maxm = 0 ; int subtractSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ 0 ] [ i ] > maxm ) { maxm = dp [ 0 ] [ i ] ; subtractSum = dp [ 1 ] [ i ] ; } else if ( dp [ 0 ] [ i ] == maxm ) { subtractSum = Math . min ( subtractSum , dp [ 1 ] [ i ] ) ; } } return totalSum - subtractSum ; }
int count ( int n ) { if ( n == 2 ) return 1 ; else if ( n == 4 ) return 2 ; else if ( n == 6 ) return 4 ; int table [ ] = new int [ n + 1 ] ; int i ; for ( i = 0 ; i < n + 1 ; i ++ ) table [ i ] = 0 ; table [ 0 ] = 0 ; table [ 2 ] = 1 ; table [ 4 ] = 2 ; table [ 6 ] = 4 ; for ( i = 8 ; i <= n ; i = i + 2 ) { table [ i ] = table [ i - 2 ] + table [ i - 4 ] + table [ i - 6 ] ; } return table [ n ] ; }
boolean isPrime ( String number ) { int num = Integer . valueOf ( number ) ; for ( int i = 2 ; i * i <= num ; i ++ ) { if ( ( num % i ) == 0 ) return false ; } return num > 1 ? true : false ; }
int countPrimeStrings ( String number , int i ) { if ( i == 0 ) return 1 ; int cnt = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 && number . charAt ( i - j ) != '0' && isPrime ( number . substring ( i - j , i ) ) ) { cnt += countPrimeStrings ( number , i - j ) ; cnt %= MOD ; } } return cnt ; }
void buildSieve ( ) { Arrays . fill ( sieve , true ) ; sieve [ 0 ] = false ; sieve [ 1 ] = false ; for ( int p = 2 ; p * p <= 1000000 ; p ++ ) { if ( sieve [ p ] == true ) { for ( int i = p * p ; i < 1000000 ; i += p ) sieve [ i ] = false ; } } }
boolean isPrime ( String number ) { int num = Integer . valueOf ( number ) ; return sieve [ num ] ; }
int rec ( String number , int i , int [ ] dp ) { if ( dp [ i ] != - 1 ) return dp [ i ] ; int cnt = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 && number . charAt ( i - j ) != '0' && isPrime ( number . substring ( i - j , i ) ) ) { cnt += rec ( number , i - j , dp ) ; cnt %= MOD ; } } return dp [ i ] = cnt ; }
int countPrimeStrings ( String number ) { int n = number . length ( ) ; int [ ] dp = new int [ n + 1 ] ; Arrays . fill ( dp , - 1 ) ; dp [ 0 ] = 1 ; return rec ( number , n , dp ) ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p < 100000 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= 100000 ; i += p ) prime [ i ] = false ; } } }
int distinctPrimeSubSeq ( int a [ ] , int n , int k ) { SieveOfEratosthenes ( ) ; Vector < Integer > primes = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ a [ i ] ] ) primes . add ( a [ i ] ) ; } int l = primes . size ( ) ; Collections . sort ( primes ) ; Vector < Integer > b = new Vector < > ( ) ; Vector < Integer > dp = new Vector < > ( ) ; int sum = 0 ; for ( int i = 0 ; i < l ; ) { int count = 1 , x = a [ i ] ; i ++ ; while ( i < l && a [ i ] == x ) { count ++ ; i ++ ; } b . add ( count ) ; dp . add ( count ) ; sum += count ; } int of_length = 2 ; int len = dp . size ( ) ; int ans = 0 ; while ( of_length < k ) { int freq = 0 ; int prev = 0 ; for ( int i = 0 ; i < ( len - 1 ) ; i ++ ) { freq += dp . elementAt ( i ) ; int j = sum - freq ; int subseq = b . elementAt ( i ) * j ; ans += subseq ; dp . add ( i , subseq ) ; prev += dp . elementAt ( i ) ; } len -- ; sum = prev ; of_length ++ ; } ans += ( l + 3 ) ; return ans ; }
int ways ( int [ ] [ ] arr , int K ) { int R = arr . length ; int C = arr [ 0 ] . length ; int [ ] [ ] preSum = new int [ R ] [ C ] ; for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { preSum [ r ] = arr [ r ] ; if ( r + 1 < R ) preSum [ r ] += preSum [ r + 1 ] ; if ( c + 1 < C ) preSum [ r ] += preSum [ r ] ; if ( r + 1 < R && c + 1 < C ) preSum [ r ] -= preSum [ r + 1 ] ; } } int [ ] [ ] [ ] dp = new int [ K + 1 ] [ R ] [ C ] ; for ( int k = 1 ; k <= K ; k ++ ) { for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { if ( k == 1 ) { dp [ k ] [ r ] = ( preSum [ r ] > 0 ) ? 1 : 0 ; } else { dp [ k ] [ r ] = 0 ; for ( int r1 = r + 1 ; r1 < R ; r1 ++ ) { if ( preSum [ r ] - preSum [ r1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r1 ] ; } for ( int c1 = c + 1 ; c1 < C ; c1 ++ ) { if ( preSum [ r ] - preSum [ r ] [ c1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r ] [ c1 ] ; } } } } } return dp [ K ] [ 0 ] [ 0 ] ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int sumPathCost ( int grid [ ] [ ] , int m , int n ) { int sum = 0 , count ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { count = nCr ( i + j , i ) * nCr ( m + n - i - j , m - i ) ; sum += count * grid [ i ] [ j ] ; } } return sum ; }
void init ( int x ) { for ( int i = 0 ; i < 20 ; i ++ ) for ( int j = 0 ; j < 1000 ; j ++ ) for ( int k = 0 ; k < 10 ; k ++ ) for ( int l = 0 ; l < 2 ; l ++ ) for ( int m = 0 ; m < 2 ; m ++ ) dp [ i ] [ j ] [ k ] [ l ] [ m ] = - 1 ; v . clear ( ) ; while ( x > 0 ) { v . add ( x % 10 ) ; x /= 10 ; } Collections . reverse ( v ) ; N = v . size ( ) ; }
void findCount ( int L , int R , int K ) { init ( R ) ; int r_ans = fun ( 0 , 0 , 0 , 0 , 0 ) ; init ( L - 1 ) ; int l_ans = fun ( 0 , 0 , 0 , 0 , 0 ) ; System . out . print ( r_ans - l_ans ) ; }
void dfs_lca ( int a , int par , int lev ) { dp [ 0 ] [ a ] = par ; level [ a ] = lev ; for ( int i = 0 ; i < v . get ( a ) . size ( ) ; i ++ ) { if ( v . get ( a ) . get ( i ) . x == par ) continue ; mx [ 0 ] [ v . get ( a ) . get ( i ) . x ] = v . get ( a ) . get ( i ) . y ; dfs_lca ( v . get ( a ) . get ( i ) . x , a , lev + 1 ) ; } }
void find_ancestor ( ) { for ( int i = 1 ; i < 16 ; i ++ ) { for ( int j = 1 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ dp [ i - 1 ] [ j ] ] ; mx [ i ] [ j ] = Math . max ( mx [ i - 1 ] [ j ] , mx [ i - 1 ] [ dp [ i - 1 ] [ j ] ] ) ; } } }
int getMax ( int a , int b ) { if ( level [ b ] < level [ a ] ) { int temp = a ; a = b ; b = temp ; } int ans = 0 ; int diff = level [ b ] - level [ a ] ; while ( diff > 0 ) { int log = ( int ) ( Math . log ( diff ) / Math . log ( 2 ) ) ; ans = Math . max ( ans , mx [ log ] [ b ] ) ; b = dp [ log ] [ b ] ; diff -= ( 1 << log ) ; } while ( a != b ) { int i = ( int ) ( Math . log ( level [ a ] ) / Math . log ( 2 ) ) ; while ( i > 0 && dp [ i ] [ a ] == dp [ i ] [ b ] ) { i -= 1 ; } ans = Math . max ( ans , mx [ i ] [ a ] ) ; ans = Math . max ( ans , mx [ i ] [ b ] ) ; a = dp [ i ] [ a ] ; b = dp [ i ] [ b ] ; } return ans ; }
void compute_lca ( ) { dfs_lca ( 1 , 0 , 0 ) ; find_ancestor ( ) ; }
int dfs ( ArrayList < ArrayList < Integer > > adj , int [ ] order , int [ ] bridge_detect , boolean [ ] mark , int v , int l ) { mark [ v ] = true ; order [ v ] = order [ l ] + 1 ; bridge_detect [ v ] = order [ v ] ; for ( int i = 0 ; i < adj . get ( v ) . size ( ) ; i ++ ) { int u = adj . get ( v ) . get ( i ) ; if ( u == l ) { continue ; } if ( order [ v ] < order [ u ] ) { continue ; } if ( mark [ u ] ) { bridge_detect [ v ] = Math . min ( order [ u ] , bridge_detect [ v ] ) ; } else { dfs ( adj , order , bridge_detect , mark , u , v ) ; } bridge_detect [ v ] = Math . min ( bridge_detect [ u ] , bridge_detect [ v ] ) ; ans . add ( new int [ ] { v , u } ) ; } if ( bridge_detect [ v ] == order [ v ] && l != 0 ) { flag = 0 ; } return flag ; }
void createGraph ( int Edges [ ] [ ] , ArrayList < ArrayList < Integer > > adj , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int u = Edges [ i ] [ 0 ] ; int v = Edges [ i ] [ 1 ] ; adj . get ( u ) . add ( v ) ; adj . get ( v ) . add ( u ) ; } }
void depthFirst ( int v , List < List < Integer > > graph , boolean [ ] visited , List < Integer > storeChain ) { visited [ v ] = true ; storeChain . add ( v ) ; for ( int i : graph . get ( v ) ) { if ( visited [ i ] == false ) { depthFirst ( i , graph , visited , storeChain ) ; } } }
int subarraySum ( int arr [ ] , int n ) { int maxSubarraySum = arr [ 0 ] ; int currentMax = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { currentMax = Math . max ( arr [ i ] , arr [ i ] + currentMax ) ; maxSubarraySum = Math . max ( maxSubarraySum , currentMax ) ; } return maxSubarraySum ; }
int get_max_sum ( int arr [ ] , int n ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . containsKey ( arr [ i ] ) ) { int x = freq . get ( arr [ i ] ) ; freq . replace ( arr [ i ] , x + 1 ) ; } else freq . put ( arr [ i ] , 1 ) ; } int [ ] dp = new int [ 100001 ] ; for ( int i = 0 ; i < 100001 ; i ++ ) dp [ i ] = 0 ; dp [ 0 ] = 0 ; if ( freq . containsKey ( 0 ) ) dp [ 1 ] = freq . get ( 0 ) ; else dp [ 1 ] = 0 ; for ( int i = 2 ; i <= 100000 ; i ++ ) { int temp = ( freq . containsKey ( i ) ) ? freq . get ( i ) : 0 ; dp [ i ] = Math . max ( dp [ i - 1 ] , dp [ i - 2 ] + i * temp ) ; } return dp [ 100000 ] ; }
int minFlip ( String a ) { int n = a . length ( ) ; int dp [ ] [ ] = new int [ n + 1 ] [ 2 ] ; if ( a . charAt ( 0 ) == '1' ) { dp [ 0 ] [ 0 ] = 1 ; } else dp [ 0 ] [ 0 ] = 0 ; if ( a . charAt ( 0 ) == '0' ) dp [ 0 ] [ 1 ] = 1 ; else dp [ 0 ] [ 1 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a . charAt ( i ) == '1' ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 1 ; } else dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; if ( a . charAt ( i ) == '0' ) { dp [ i ] [ 1 ] = Math . min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + 1 ; } else dp [ i ] [ 1 ] = Math . min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) ; } int answer = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { answer = Math . min ( answer , dp [ i ] [ 1 ] + dp [ n - 1 ] [ 0 ] - dp [ i ] [ 0 ] ) ; } return Math . min ( answer , dp [ n - 1 ] [ 0 ] ) ; }
int LIIDS ( int arr [ ] , int N ) { int [ ] dp = new int [ N + 1 ] ; int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 1 ; } for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + i ; j <= N ; j += i ) { if ( j < arr . length && arr [ j ] > arr [ i ] ) { dp [ j ] = Math . max ( dp [ j ] , dp [ i ] + 1 ) ; } } ans = Math . max ( ans , dp [ i ] ) ; } return ans ; }
boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
int findSubarraySum ( int arr [ ] , int n , int K ) { Map < Integer , Integer > prevSum = new HashMap < > ( ) ; int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == K ) { res ++ ; } if ( prevSum . containsKey ( currsum - K ) ) res += ( prevSum . get ( currsum - K ) ) ; prevSum . put ( currsum , prevSum . getOrDefault ( currsum , 0 ) + 1 ) ; } return res ; }
void countSubarray ( int arr [ ] , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) { if ( isPerfectSquare ( arr [ i ] ) ) { arr [ i ] = 1 ; } else { arr [ i ] = 0 ; } } System . out . println ( findSubarraySum ( arr , n , K ) ) ; }
int calculate ( int pos , int left , int k , int L , int R ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; int answer = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( i > left ) break ; answer = ( ( answer + calculate ( pos + 1 , left - i , k , L , R ) ) % mod ) ; } return answer ; }
int countWaystoDivide ( int n , int k , int L , int R ) { return calculate ( 0 , n , k , L , R ) ; }
int calculate ( int pos , int left , int k , int L , int R ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; if ( dp [ pos ] [ left ] != - 1 ) return dp [ pos ] [ left ] ; int answer = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( i > left ) break ; answer = ( answer + calculate ( pos + 1 , left - i , k , L , R ) ) % mod ; } return dp [ pos ] [ left ] = answer ; }
int countWaystoDivide ( int n , int k , int L , int R ) { for ( int i = 0 ; i < 1000 ; i ++ ) { for ( int j = 0 ; j < 1000 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return calculate ( 0 , n , k , L , R ) ; }
void PossibleSum ( int n , int m , int [ ] [ ] v , int k ) { int [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= k ; j ++ ) { if ( dp [ i ] [ j ] == 1 ) { for ( int d = 0 ; d < m ; d ++ ) { if ( ( j + v [ i ] [ d ] ) <= k ) { dp [ i + 1 ] [ j + v [ i ] [ d ] ] = 1 ; } } } } } if ( dp [ n ] [ k ] == 1 ) System . out . println ( "YES" ) ; else System . out . println ( "NO" ) ; }
void printList ( Node temp ) { while ( temp != null ) { System . out . print ( temp . info + " " ) ; temp = temp . next ; } }
boolean solve ( int arr [ ] , int curr , int mask , int n ) { if ( isprime ( curr ) ) { if ( mask == ( 1 << n ) - 1 ) { return true ; } curr = 0 ; } if ( mask == ( 1 << n ) - 1 ) { if ( ! isprime ( curr ) ) { return false ; } } if ( dp [ mask ] ) return dp [ mask ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( mask & ( 1 << i ) ) == 0 ) { if ( solve ( arr , curr + arr [ i ] , mask 1 << i , n ) ) { return true ; } } } return dp [ mask ] = false ; }
Vector < Integer > minSqrNum ( int n ) { int [ ] arr = new int [ n + 1 ] ; int k = 0 ; int [ ] sqrNum = new int [ n + 1 ] ; Vector < Integer > v = new Vector < > ( ) ; arr [ 0 ] = 0 ; sqrNum [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { arr [ i ] = arr [ i - 1 ] + 1 ; sqrNum [ i ] = 1 ; k = 1 ; while ( k * k <= i ) { if ( arr [ i ] > arr [ i - k * k ] + 1 ) { arr [ i ] = arr [ i - k * k ] + 1 ; sqrNum [ i ] = k * k ; } k ++ ; } } while ( n > 0 ) { v . add ( sqrNum [ n ] ) ; n -= sqrNum [ n ] ; } return v ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
void nCr ( int n , int p , int f [ ] [ ] , int m ) { for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( j > i ) { f [ i ] [ j ] = 0 ; } else if ( j == 0 j == i ) { f [ i ] [ j ] = 1 ; } else { f [ i ] [ j ] = ( f [ i - 1 ] [ j ] + f [ i - 1 ] [ j - 1 ] ) % p ; } } } }
void sieve ( ) { for ( int i = 0 ; i < 1000 ; i ++ ) isprime [ i ] = true ; for ( int i = 2 ; i * i < 1000 ; i ++ ) { if ( isprime [ i ] ) { for ( int j = i * i ; j < 1000 ; j += i ) { isprime [ j ] = false ; } } } for ( int i = 2 ; i < 1000 ; i ++ ) { if ( isprime [ i ] ) { prime . add ( i ) ; } } }
int CountWays ( int i , int j , int sum , int n , int k ) { if ( i >= prime . size ( ) - 1 sum > n ) { return 0 ; } if ( sum == n ) { if ( j == k ) { return 1 ; } return 0 ; } if ( j == k ) return 0 ; if ( dp [ i ] [ j ] [ sum ] != 0 ) return dp [ i ] [ j ] [ sum ] ; int inc = 0 , exc = 0 ; inc = CountWays ( i + 1 , j + 1 , sum + prime . get ( i ) , n , k ) ; exc = CountWays ( i + 1 , j , sum , n , k ) ; return dp [ i ] [ j ] [ sum ] = inc + exc ; }
void createTable ( int mtrx [ ] [ ] , int k , int p , int dp [ ] [ ] ) { dp [ 0 ] [ 0 ] = mtrx [ 0 ] [ 0 ] ; for ( int j = 1 ; j < dim ; j ++ ) { dp [ 0 ] [ j ] = mtrx [ 0 ] [ j ] + dp [ 0 ] [ j - 1 ] ; } for ( int i = 1 ; i < dim ; i ++ ) { dp [ i ] [ 0 ] = mtrx [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < dim ; i ++ ) { for ( int j = 1 ; j < dim ; j ++ ) { dp [ i ] [ j ] = mtrx [ i ] [ j ] + dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; } } }
int countSubMatrixUtil ( int dp [ ] [ ] , int k , int p ) { int count = 0 ; int subMatSum = 0 ; for ( int i = k - 1 ; i < dim ; i ++ ) { for ( int j = k - 1 ; j < dim ; j ++ ) { if ( i == ( k - 1 ) || j == ( k - 1 ) ) { if ( i == ( k - 1 ) && j == ( k - 1 ) ) { subMatSum = dp [ i ] [ j ] ; } else if ( i == ( k - 1 ) ) { subMatSum = dp [ i ] [ j ] - dp [ i ] [ j - k ] ; } else { subMatSum = dp [ i ] [ j ] - dp [ i - k ] [ j ] ; } } else { subMatSum = dp [ i ] [ j ] - dp [ i - k ] [ j ] - dp [ i ] [ j - k ] + dp [ i - k ] [ j - k ] ; } if ( subMatSum >= p ) { count ++ ; } } } return count ; }
int solve ( int arr [ ] , int i , int len , int prev , int n , int k ) { if ( len == k ) return 0 ; if ( i == n ) return Integer . MIN_VALUE ; if ( dp [ i ] [ len ] [ prev ] != 0 ) return dp [ i ] [ len ] [ prev ] ; int inc = 0 , exc = 0 ; if ( ( len & 1 ) != 0 ) { inc = ( productDigitSum ( arr [ prev ] , arr [ i ] ) + solve ( arr , i + 1 , len + 1 , 0 , n , k ) ) ; } else { inc = solve ( arr , i + 1 , len + 1 , i , n , k ) ; } exc = solve ( arr , i + 1 , len , prev , n , k ) ; return dp [ i ] [ len ] [ prev ] = Math . max ( inc , exc ) ; }
void precompute ( ) { for ( int i = 0 ; i < factors . length ; i ++ ) factors [ i ] = new Vector < Integer > ( ) ; for ( int i = 1 ; i <= 100000 ; i ++ ) { for ( int j = i ; j <= 100000 ; j += i ) { factors [ j ] . add ( i ) ; } } }
int solve ( int arr [ ] , int k , int n ) { if ( k == n - 1 ) { return 0 ; } if ( k >= n ) { return Integer . MAX_VALUE ; } if ( dp [ k ] != 0 ) { return dp [ k ] ; } int ans = Integer . MAX_VALUE ; for ( int j : factors [ arr [ k ] ] ) { int res = solve ( arr , k + j , n ) ; if ( res != Integer . MAX_VALUE ) { ans = Math . min ( ans , res + 1 ) ; } } return dp [ k ] = ans ; }
void precompute ( ) { for ( int i = 1 ; i <= 100000 ; i ++ ) { for ( int j = i ; j <= 100000 ; j += i ) factors [ j ] . add ( i ) ; } }
int solve ( int arr [ ] , int n ) { for ( int i = 0 ; i < 100005 ; i ++ ) { dp [ i ] = Integer . MAX_VALUE ; } dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j : factors [ arr [ i ] ] ) { if ( i + j < n ) dp [ i + j ] = Math . min ( dp [ i + j ] , 1 + dp [ i ] ) ; } } return dp [ n - 1 ] ; }
long operation ( int n ) { dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } long ans = 0 , fac = 1 ; for ( int k = 1 ; k <= n ; k ++ ) { fac *= k ; ans = ( ans + ( fac * f ( n , k ) ) % mod ) % mod ; } return ans ; }
int countWays ( int n , int m ) { int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; } int sum ; for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { sum = 0 ; for ( int k = 0 ; k <= j ; k ++ ) { sum += dp [ i - 1 ] [ k ] ; } dp [ i ] [ j ] = sum ; } } return dp [ m ] [ n ] ; }
int countWays ( int n , int m ) { int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; if ( i != 0 ) { dp [ 1 ] [ i ] += dp [ 1 ] [ i - 1 ] ; } } for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; if ( i == m && j == n ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } } } return Integer . MIN_VALUE ; }
void ConvertIntoDigit ( int n ) { while ( n > 0 ) { int dig = n % 10 ; digits . add ( dig ) ; n /= 10 ; } Collections . reverse ( digits ) ; }
int solve ( int idx , int k , int tight , int sum ) { if ( idx == digits . size ( ) && k == 0 && sum % 2 == 1 ) { if ( ! vis [ sum ] ) { vis [ sum ] = true ; return 1 ; } return 0 ; } if ( idx > digits . size ( ) ) { return 0 ; } if ( dp [ idx ] [ k ] [ tight ] [ sum ] > 0 ) { return dp [ idx ] [ k ] [ tight ] [ sum ] ; } int j ; if ( idx < digits . size ( ) && tight == 0 ) { j = digits . get ( idx ) ; } else { j = 9 ; } int cnt = 0 ; for ( int i = ( k > 0 ? 0 : 1 ) ; i <= j ; i ++ ) { int newtight = tight ; if ( i < j ) { newtight = 1 ; } if ( i == 0 ) cnt += solve ( idx + 1 , k - 1 , newtight , sum ) ; else cnt += solve ( idx + 1 , k , newtight , sum + i ) ; } return dp [ idx ] [ k ] [ tight ] [ sum ] = cnt ; }
int minDominatingSet ( Node root , int covered , int compulsory ) { if ( root == null ) return 0 ; if ( root . left != null && root . right != null && covered > 0 ) compulsory = 1 ; if ( dp [ root . data ] [ covered ] [ compulsory ] != - 1 ) return dp [ root . data ] [ covered ] [ compulsory ] ; if ( compulsory > 0 ) { return dp [ root . data ] [ covered ] [ compulsory ] = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) ; } if ( covered > 0 ) { return dp [ root . data ] [ covered ] [ compulsory ] = Math . min ( 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 0 ) ) ; } int ans = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) ; if ( root . left != null ) { ans = Math . min ( ans , minDominatingSet ( root . left , 0 , 1 ) + minDominatingSet ( root . right , 0 , 0 ) ) ; } if ( root . right != null ) { ans = Math . min ( ans , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 1 ) ) ; } return dp [ root . data ] [ covered ] [ compulsory ] = ans ; }
int getmask ( int val ) { int mask = 0 ; int prime [ ] = { 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 } ; for ( int i = 0 ; i < 15 ; i ++ ) { if ( val % prime [ i ] == 0 ) { mask = mask | ( 1 << i ) ; } } return mask ; }
int calculate ( int pos , int mask , int a [ ] , int n ) { if ( pos == n || mask == ( int ) ( 1 << n - 1 ) ) return 0 ; if ( dp [ pos ] [ mask ] != - 1 ) return dp [ pos ] [ mask ] ; int size = 0 ; size = Math . max ( size , calculate ( pos + 1 , mask , a , n ) ) ; if ( ( getmask ( a [ pos ] ) & mask ) == 0 ) { int new_mask = ( mask | ( getmask ( a [ pos ] ) ) ) ; size = Math . max ( size , 1 + calculate ( pos + 1 , new_mask , a , n ) ) ; } return dp [ pos ] [ mask ] = size ; }
int largestSubset ( int a [ ] , int n ) { for ( int i = 0 ; i < 5000 ; i ++ ) Arrays . fill ( dp [ i ] , - 1 ) ; return calculate ( 0 , 0 , a , n ) ; }
int countSubsets ( int N ) { if ( N <= 2 ) return N ; if ( N == 3 ) return 2 ; int [ ] DP = new int [ N + 1 ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; DP [ 2 ] = 2 ; DP [ 3 ] = 2 ; for ( int i = 4 ; i <= N ; i ++ ) { DP [ i ] = DP [ i - 2 ] + DP [ i - 3 ] ; } return DP [ N ] ; }
int CountSets ( int x , int pos ) { if ( x <= 0 ) { if ( pos == 0 ) return 1 ; else return 0 ; } if ( pos == 0 ) return 1 ; int answer = CountSets ( x - 1 , pos ) + CountSets ( x - 2 , pos - 1 ) ; return answer ; }
int CountOrderedSets ( int n ) { int [ ] factorial = new int [ 10000 ] ; factorial [ 0 ] = 1 ; for ( int i = 1 ; i < 10000 ; i ++ ) factorial [ i ] = factorial [ i - 1 ] * i ; int answer = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int sets = CountSets ( n , i ) * factorial [ i ] ; answer = answer + sets ; } return answer ; }
int CountOrderedSets ( int n ) { int [ ] factorial = new int [ 10000 ] ; factorial [ 0 ] = 1 ; for ( int i = 1 ; i < 10000 ; i ++ ) factorial [ i ] = factorial [ i - 1 ] * i ; int answer = 0 ; for ( int i = 0 ; i < 500 ; i ++ ) { for ( int j = 0 ; j < 500 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } for ( int i = 1 ; i <= n ; i ++ ) { int sets = CountSets ( n , i ) * factorial [ i ] ; answer = answer + sets ; } return answer ; }
int numberOfArithmeticSequences ( int L [ ] , int N ) { if ( N <= 2 ) return 0 ; int count = 0 ; int res = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( L [ i ] - L [ i - 1 ] == L [ i - 1 ] - L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }
int count_special ( int n ) { int [ ] fib = new int [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod ; } return fib [ n ] ; }
int CountOfTriplets ( int a [ ] , int n ) { int answer = 0 ; int x = 0 ; int count [ ] = new int [ 100005 ] ; int ways [ ] = new int [ 100005 ] ; for ( int i = 0 ; i < n ; i ++ ) { x ^= a [ i ] ; answer += count [ x ] * i - ways [ x ] ; count [ x ] ++ ; ways [ x ] += ( i + 1 ) ; } return answer ; }
int MaximumSum ( int a [ ] , int n ) { int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) dp [ i ] [ j ] = Integer . MIN_VALUE ; } for ( int i = 0 ; i < n + 1 ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { int val = Integer . MIN_VALUE ; if ( ( i - 2 >= 0 && dp [ i - 2 ] [ j - 1 ] != Integer . MIN_VALUE ) i - 2 < 0 ) { val = a [ i - 1 ] + ( i - 2 >= 0 ? dp [ i - 2 ] [ j - 1 ] : 0 ) ; } if ( i - 1 >= j ) { val = Math . max ( val , dp [ i - 1 ] [ j ] ) ; } dp [ i ] [ j ] = val ; } } return dp [ n ] [ n / 2 ] ; }
int MaximumSum ( int a [ ] , int n ) { int [ ] [ ] dp = new int [ n + 1 ] [ 2 ] ; dp [ 2 ] [ 1 ] = a [ 1 ] ; dp [ 2 ] [ 0 ] = a [ 0 ] ; for ( int i = 3 ; i < n + 1 ; i ++ ) { if ( i % 2 == 1 ) { int temp = Math . max ( ( Math . max ( dp [ i - 3 ] [ 1 ] , dp [ i - 3 ] [ 0 ] ) ) , Math . max ( dp [ i - 2 ] [ 1 ] , dp [ i - 2 ] [ 0 ] ) ) ; dp [ i ] [ 1 ] = a [ i - 1 ] + temp ; dp [ i ] [ 0 ] = Math . max ( ( Math . max ( a [ i - 2 ] + dp [ i - 2 ] [ 0 ] , a [ i - 2 ] + dp [ i - 3 ] [ 1 ] ) ) , Math . max ( a [ i - 2 ] + dp [ i - 3 ] [ 0 ] , a [ i - 3 ] + dp [ i - 3 ] [ 0 ] ) ) ; } else { dp [ i ] [ 1 ] = a [ i - 1 ] + ( Math . max ( ( Math . max ( dp [ i - 2 ] [ 1 ] , dp [ i - 2 ] [ 0 ] ) ) , dp [ i - 1 ] [ 0 ] ) ) ; dp [ i ] [ 0 ] = a [ i - 2 ] + dp [ i - 2 ] [ 0 ] ; } } return Math . max ( dp [ n ] [ 1 ] , dp [ n ] [ 0 ] ) ; }
int func ( int n ) { if ( n <= 0 ) return 0 ; if ( kPowKform . contains ( n ) ) return 1 ; int answer = 0 ; int x = n ; while ( x > 0 ) { int d = x % 10 ; if ( d != 0 ) { if ( func ( n - d * d ) == 1 ) { answer = 1 ; break ; } } x /= 10 ; } return answer ; }
void canBeConverted ( int n ) { if ( func ( n ) == 1 ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
int divisorGame ( int N , int A , int dp [ ] [ ] ) { if ( N == 1 N == 3 ) return 0 ; if ( N == 2 ) return 1 ; if ( dp [ N ] [ A ] != - 1 ) return dp [ N ] [ A ] ; int ans = ( A == 1 ) ? 0 : 1 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { if ( A == 1 ) ans |= divisorGame ( N - i , 0 , dp ) ; else ans &= divisorGame ( N - i , 1 , dp ) ; } } return dp [ N ] [ A ] = ans ; }
boolean check ( Vector < Integer > v ) { HashSet < Integer > digits = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { HashSet < Integer > d = new HashSet < Integer > ( ) ; while ( v . get ( i ) > 0 ) { d . add ( v . get ( i ) % 10 ) ; v . set ( i , v . get ( i ) / 10 ) ; } for ( int it : d ) { if ( digits . contains ( it ) ) return false ; } for ( int it : d ) digits . add ( it ) ; } return true ; }
int numberOfSubarrays ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { Vector < Integer > temp = new Vector < Integer > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) > 0 ) temp . add ( a [ j ] ) ; } if ( check ( temp ) ) answer ++ ; } return answer ; }
int countWays ( int pos , int mask , int a [ ] , int n ) { if ( pos == n ) return ( mask > 0 ? 1 : 0 ) ; if ( dp [ pos ] [ mask ] != - 1 ) return dp [ pos ] [ mask ] ; int count = 0 ; count = count + countWays ( pos + 1 , mask , a , n ) ; if ( ( getmask ( a [ pos ] ) & mask ) == 0 ) { int new_mask = ( mask | ( getmask ( a [ pos ] ) ) ) ; count = count + countWays ( pos + 1 , new_mask , a , n ) ; } return dp [ pos ] [ mask ] = count ; }
int numberOfSubarrays ( int a [ ] , int n ) { for ( int i = 0 ; i < 5000 ; i ++ ) { for ( int j = 0 ; j < ( 1 << 10 ) + 5 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return countWays ( 0 , 0 , a , n ) ; }
void change ( Pair p , int x ) { if ( p . second > x ) p . second = x ; if ( p . first > p . second ) { int tmp = p . first ; p . first = p . second ; p . second = tmp ; } }
int minNodetoRemove ( int n , ArrayList < Pair > edges ) { for ( int i = 0 ; i < edges . size ( ) ; i ++ ) { adj [ edges . get ( i ) . first ] . add ( edges . get ( i ) . second ) ; adj [ edges . get ( i ) . second ] . add ( edges . get ( i ) . first ) ; } Arrays . fill ( vis , 0 ) ; totBackEdges = 0 ; for ( int v = 1 ; v <= n ; v ++ ) { if ( vis [ v ] == 0 ) dfs ( v , - 1 , 0 ) ; } if ( totBackEdges == 0 ) return - 1 ; int node = - 1 ; for ( int v = 1 ; v <= n ; v ++ ) { if ( ( countAdj [ v ] + small [ v ] == totBackEdges ) && isPossible [ v ] != 0 ) { node = v ; } if ( node != - 1 ) break ; } return node ; }
int height ( node root ) { if ( root == null ) return 0 ; return ( Math . max ( height ( root . left ) , height ( root . right ) ) + 1 ) ; }
void FibonacciSeries ( int n ) { fib . add ( 0 ) ; fib . add ( 1 ) ; for ( int i = 2 ; i < n ; i ++ ) fib . add ( fib . get ( i - 1 ) + fib . get ( i - 2 ) ) ; }
int CountPathUtil ( node root , int i , int count ) { if ( root == null || ! ( fib . get ( i ) == root . data ) ) { return count ; } if ( root . left != null && root . right != null ) { count ++ ; } count = CountPathUtil ( root . left , i + 1 , count ) ; return CountPathUtil ( root . right , i + 1 , count ) ; }
void CountPath ( node root ) { int ht = height ( root ) ; FibonacciSeries ( ht ) ; System . out . print ( CountPathUtil ( root , 0 , 0 ) ) ; }
void SieveOfEratosthenes ( ) { boolean [ ] isPrime = new boolean [ Large + 1 ] ; Arrays . fill ( isPrime , true ) ; for ( int p = 2 ; p * p <= Large ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= Large ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= Large ; p ++ ) if ( isPrime [ p ] ) prime . add ( p ) ; }
void Display ( int arr [ ] [ ] , int row ) { for ( int i = 0 ; i < M ; i ++ ) System . out . print ( arr [ row ] [ i ] + " " ) ; }
void countDivisorsMult ( int arr [ ] [ ] ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int row_no = 0 ; long max_factor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int no = arr [ i ] [ j ] ; for ( int k = 0 ; k < prime . size ( ) ; k ++ ) { while ( no > 1 && no % prime . get ( k ) == 0 ) { no /= prime . get ( k ) ; if ( mp . containsKey ( prime . get ( k ) ) ) mp . put ( prime . get ( k ) , prime . get ( k ) + 1 ) ; else mp . put ( prime . get ( k ) , 1 ) ; } if ( no == 1 ) break ; } } int res = 1 ; for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) { res *= ( it . getValue ( ) + 1L ) ; } if ( max_factor < res ) { row_no = i ; max_factor = res ; } mp . clear ( ) ; } Display ( arr , row_no ) ; }
int isSquare ( int n ) { int k = ( int ) Math . sqrt ( n ) ; return k * k == n ? 1 : 0 ; }
int calculate ( int pos , int prev , int sum , int [ ] v ) { if ( pos == v . length ) return isSquare ( sum ) ; for ( int i = prev ; i <= 9 ; i ++ ) { v [ pos ] = i ; sum += i * i ; if ( calculate ( pos + 1 , i , sum , v ) != 0 ) return 1 ; sum -= i * i ; } return 0 ; }
int countMountains ( int a [ ] [ ] , int n ) { int [ ] [ ] A = new int [ n + 2 ] [ n + 2 ] ; int count = 0 ; for ( int i = 0 ; i < n + 2 ; i ++ ) { for ( int j = 0 ; j < n + 2 ; j ++ ) { if ( ( i == 0 ) || ( j == 0 ) || ( i == n + 1 ) || ( j == n + 1 ) ) { A [ i ] [ j ] = Integer . MIN_VALUE ; } else { A [ i ] [ j ] = a [ i - 1 ] [ j - 1 ] ; } } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( ( A [ i ] [ j ] > A [ i - 1 ] [ j ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j ] ) && ( A [ i ] [ j ] > A [ i ] [ j - 1 ] ) && ( A [ i ] [ j ] > A [ i ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i - 1 ] [ j - 1 ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i - 1 ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j - 1 ] ) ) { count ++ ; } } } return count ; }
int calculate ( int pos , int g , int n , int k ) { if ( pos == n ) { return g ; } int answer = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { answer = ( answer % MOD + calculate ( pos + 1 , __gcd ( g , i ) , n , k ) % MOD ) ; answer %= MOD ; } return answer ; }
int sumofGCD ( int n , int k ) { return calculate ( 0 , 0 , n , k ) ; }
int fastexpo ( int a , int b ) { int res = 1 ; a %= MOD ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res * a ) % MOD ; a *= a ; a %= MOD ; b >>= 1 ; } return res ; }
int sumofGCD ( int n , int k ) { int [ ] count = new int [ k + 1 ] ; for ( int g = k ; g >= 1 ; g -- ) { int count_multiples = k / g ; int temp ; temp = fastexpo ( count_multiples , n ) ; temp %= MOD ; int extra = 0 ; for ( int j = g * 2 ; j <= k ; j += g ) { extra = ( extra + count [ j ] ) ; extra %= MOD ; } count [ g ] = ( temp - extra + MOD ) ; count [ g ] %= MOD ; } int sum = 0 ; int add ; for ( int i = 1 ; i <= k ; ++ i ) { add = ( count [ i ] % MOD * i % MOD ) ; add %= MOD ; sum += add ; sum %= MOD ; } return sum ; }
int findCost ( int cost_mat [ ] [ ] , int N , int M ) { int dp [ ] [ ] = new int [ N ] [ M ] ; for ( int i = 0 ; i < M ; i ++ ) dp [ 0 ] [ i ] = cost_mat [ 0 ] [ i ] ; for ( int row = 1 ; row < N ; row ++ ) { for ( int curr_col = 0 ; curr_col < M ; curr_col ++ ) { int val = 999999999 ; for ( int prev_col = 0 ; prev_col < M ; prev_col ++ ) { if ( curr_col != prev_col ) val = Math . min ( val , dp [ row - 1 ] [ prev_col ] ) ; } dp [ row ] [ curr_col ] = val + cost_mat [ row ] [ curr_col ] ; } } int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < M ; i ++ ) ans = Math . min ( ans , dp [ N - 1 ] [ i ] ) ; return ans ; }
int checkOdd ( String number ) { int n = number . length ( ) ; int num = number . charAt ( n - 1 ) - '0' ; return ( num & 1 ) ; }
void getPrimesFromSeive ( HashSet < String > primes ) { boolean [ ] prime = new boolean [ 1000001 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int i = 2 ; i * i <= 1000000 ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = i * i ; j <= 1000000 ; j += i ) prime [ j ] = false ; } } for ( int i = 2 ; i <= 1000000 ; i ++ ) { if ( prime [ i ] == true ) primes . add ( String . valueOf ( i ) ) ; } }
int splitIntoPrimes ( String number ) { int numLen = number . length ( ) ; int [ ] splitDP = new int [ numLen + 1 ] ; Arrays . fill ( splitDP , - 1 ) ; HashSet < String > primes = new HashSet < String > ( ) ; getPrimesFromSeive ( primes ) ; for ( int i = 1 ; i <= numLen ; i ++ ) { if ( i <= 6 && ( primes . contains ( number . substring ( 0 , i ) ) ) ) splitDP [ i ] = 1 ; if ( splitDP [ i ] != - 1 ) { for ( int j = 1 ; j <= 6 && i + j <= numLen ; j ++ ) { if ( primes . contains ( number . substring ( i , i + j ) ) ) { if ( splitDP [ i + j ] == - 1 ) splitDP [ i + j ] = 1 + splitDP [ i ] ; else splitDP [ i + j ] = Math . min ( splitDP [ i + j ] , 1 + splitDP [ i ] ) ; } } } } return splitDP [ numLen ] ; }
int k_nonzero_numbers ( String s , int n , int k ) { int dp [ ] [ ] [ ] = new int [ n + 1 ] [ 2 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j < 2 ; j ++ ) for ( int x = 0 ; x <= k ; x ++ ) dp [ i ] [ j ] [ x ] = 0 ; dp [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < n ; ++ i ) { int sm = 0 ; while ( sm < 2 ) { for ( int j = 0 ; j < k + 1 ; ++ j ) { int x = 0 ; while ( x <= ( sm != 0 ? 9 : s . charAt ( i ) - '0' ) ) { if ( j + ( x > 0 ? 1 : 0 ) < k + 1 ) { dp [ i + 1 ] [ ( sm != 0 x < ( s . charAt ( i ) - '0' ) ) ? 1 : 0 ] [ j + ( x > 0 ? 1 : 0 ) ] += dp [ i ] [ sm ] [ j ] ; } ++ x ; } } ++ sm ; } } return dp [ n ] [ 0 ] [ k ] + dp [ n ] [ 1 ] [ k ] ; }
int maximumOccurrence ( String s ) { int n = s . length ( ) ; HashMap < String , Integer > freq = new HashMap < String , Integer > ( ) ; int i , j ; for ( i = 0 ; i < n ; i ++ ) { String temp = "" ; temp += s . charAt ( i ) ; if ( freq . containsKey ( temp ) ) { freq . put ( temp , freq . get ( temp ) + 1 ) ; } else { freq . put ( temp , 1 ) ; } } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { String temp = "" ; temp += s . charAt ( i ) ; temp += s . charAt ( j ) ; if ( freq . containsKey ( temp ) ) freq . put ( temp , freq . get ( temp ) + 1 ) ; else freq . put ( temp , 1 ) ; } } int answer = Integer . MIN_VALUE ; for ( int it : freq . values ( ) ) answer = Math . max ( answer , it ) ; return answer ; }
int maximumOccurrence ( String s ) { int n = s . length ( ) ; int freq [ ] = new int [ 26 ] ; int dp [ ] [ ] = new int [ 26 ] [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int c = ( s . charAt ( i ) - 'a' ) ; for ( int j = 0 ; j < 26 ; j ++ ) dp [ j ] += freq [ j ] ; freq ++ ; } int answer = Integer . MIN_VALUE ; for ( int i = 0 ; i < 26 ; i ++ ) answer = Math . max ( answer , freq [ i ] ) ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { answer = Math . max ( answer , dp [ i ] [ j ] ) ; } } return answer ; }
int calculate ( int pos , int rem , int z , int k , int n ) { if ( rem == 0 && z != 0 ) { if ( pos != n ) return ( powers [ n - pos - 1 ] * 9 ) % mod ; else return 1 ; } if ( pos == n ) return 0 ; if ( dp [ pos ] [ rem ] [ z ] != - 1 ) return dp [ pos ] [ rem ] [ z ] ; int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( i == 0 ) count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , z , k , n ) ) ) % mod ; else count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , 1 , k , n ) ) ) % mod ; } return dp [ pos ] [ rem ] [ z ] = count ; }
int waysToSplit ( String s ) { int n = s . length ( ) ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { String left = s . substring ( 0 , i ) ; String right = s . substring ( i , n ) ; if ( distinctChars ( left ) == distinctChars ( right ) ) answer ++ ; } return answer ; }
int waysToSplit ( String s ) { int n = s . length ( ) ; int answer = 0 ; int prefix [ ] = new int [ n ] ; int suffix [ ] = new int [ n ] ; int seen [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int prev = ( i - 1 >= 0 ? prefix [ i - 1 ] : 0 ) ; if ( seen [ s . charAt ( i ) - 'a' ] == 0 ) { prefix [ i ] += ( prev + 1 ) ; } else prefix [ i ] = prev ; seen [ s . charAt ( i ) - 'a' ] = 1 ; } for ( int i = 0 ; i < 26 ; i ++ ) seen [ i ] = 0 ; suffix [ n - 1 ] = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int prev = suffix [ i ] ; if ( seen [ s . charAt ( i ) - 'a' ] == 0 ) { suffix [ i - 1 ] += ( prev + 1 ) ; } else suffix [ i - 1 ] = prev ; seen [ s . charAt ( i ) - 'a' ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( prefix [ i ] == suffix [ i ] ) answer ++ ; } return answer ; }
int calculate ( int pos , int tight , int D [ ] , int sz , String num ) { if ( pos == num . length ( ) ) return 1 ; if ( dp [ pos ] [ tight ] != - 1 ) return dp [ pos ] [ tight ] ; int val = 0 ; if ( tight == 0 ) { for ( int i = 0 ; i < sz ; i ++ ) { if ( D [ i ] < ( num . charAt ( pos ) - '0' ) ) { val += calculate ( pos + 1 , 1 , D , sz , num ) ; } else if ( D [ i ] == num . charAt ( pos ) - '0' ) val += calculate ( pos + 1 , tight , D , sz , num ) ; } } else { for ( int i = 0 ; i < sz ; i ++ ) { val += calculate ( pos + 1 , tight , D , sz , num ) ; } } return dp [ pos ] [ tight ] = val ; }
int countNumbers ( int D [ ] , int N , int sz ) { String num = convertToString ( N ) ; int len = num . length ( ) ; for ( int i = 0 ; i < 15 ; i ++ ) for ( int j = 0 ; j < 2 ; j ++ ) dp [ i ] [ j ] = - 1 ; int ans = calculate ( 0 , 0 , D , sz , num ) ; for ( int i = 1 ; i < len ; i ++ ) ans += calculate ( i , 1 , D , sz , num ) ; return ans ; }
void fibonacci ( ) { int i ; fib [ 0 ] = 0 ; fib [ 1 ] = 1 ; for ( i = 2 ; i <= MAX_SIZE ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } }
void printLevel ( int level ) { int left_index = ( int ) Math . pow ( 2 , level - 1 ) ; int right_index = ( int ) ( Math . pow ( 2 , level ) - 1 ) ; for ( int i = left_index ; i <= right_index ; i ++ ) { System . out . print ( fib [ i - 1 ] + " " ) ; } System . out . println ( ) ; }
int calculate ( int pos , int prev , int left , int k ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; int answer = 0 ; for ( int i = prev ; i <= left ; i ++ ) { answer += calculate ( pos + 1 , i , left - i , k ) ; } return answer ; }
int countWaystoDivide ( int n , int k ) { return calculate ( 0 , 1 , n , k ) ; }
int calculate ( int pos , int prev , int left , int k ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; if ( dp [ pos ] [ prev ] [ left ] != - 1 ) return dp [ pos ] [ prev ] [ left ] ; int answer = 0 ; for ( int i = prev ; i <= left ; i ++ ) { answer += calculate ( pos + 1 , i , left - i , k ) ; } return dp [ pos ] [ prev ] [ left ] = answer ; }
int countWaystoDivide ( int n , int k ) { for ( int i = 0 ; i < 500 ; i ++ ) { for ( int j = 0 ; j < 500 ; j ++ ) { for ( int l = 0 ; l < 500 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; } } return calculate ( 0 , 1 , n , k ) ; }
int countWays ( Vector < String > a , String s ) { int n = a . size ( ) ; Vector < Integer > [ ] index = new Vector [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) index [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < a . get ( i ) . length ( ) ; j ++ ) { index [ a . get ( i ) . charAt ( j ) - 'a' ] . add ( j + 1 ) ; } } for ( int i = 0 ; i < 1000 ; i ++ ) { for ( int j = 0 ; j < 1000 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return calculate ( 0 , 0 , s , index [ 0 ] ) ; }
int minimalLength ( int a [ ] , int n ) { int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; int [ ] dp1 = new int [ n ] ; int i , j , k ; for ( i = 0 ; i < n + 1 ; i ++ ) { for ( j = 0 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } for ( int size = 1 ; size <= n ; size ++ ) { for ( i = 0 ; i < n - size + 1 ; i ++ ) { j = i + size - 1 ; if ( i == j ) dp [ i ] [ j ] = a [ i ] ; else { for ( k = i ; k < j ; k ++ ) { if ( dp [ i ] [ k ] != - 1 && dp [ i ] [ k ] == dp [ k + 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i ] [ k ] + 1 ; } } } } for ( i = 0 ; i < n ; i ++ ) dp1 [ i ] = ( int ) 1e7 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( dp [ j ] [ i ] != - 1 ) { if ( j == 0 ) dp1 [ i ] = 1 ; else dp1 [ i ] = Math . min ( dp1 [ i ] , dp1 [ j - 1 ] + 1 ) ; } } } return dp1 [ n - 1 ] ; }
int maxScore ( int l , int r , int prefix_sum [ ] , int num ) { if ( l > r ) return 0 ; int current_sum = prefix_sum [ r ] - ( l - 1 >= 0 ? prefix_sum [ l - 1 ] : 0 ) ; if ( num % 2 == 0 ) current_sum *= - 1 ; return current_sum + Math . max ( maxScore ( l + 1 , r , prefix_sum , num + 1 ) , maxScore ( l , r - 1 , prefix_sum , num + 1 ) ) ; }
int findMaxScore ( int a [ ] , int n ) { int prefix_sum [ ] = new int [ n ] ; prefix_sum [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix_sum [ i ] = prefix_sum [ i - 1 ] + a [ i ] ; } return maxScore ( 0 , n - 1 , prefix_sum , 1 ) ; }
int MaximumScoreDP ( int l , int r , int prefix_sum [ ] , int num ) { if ( l > r ) return 0 ; if ( dp [ l ] [ r ] [ num ] != - 1 ) return dp [ l ] [ r ] [ num ] ; int current_sum = prefix_sum [ r ] - ( l - 1 >= 0 ? prefix_sum [ l - 1 ] : 0 ) ; if ( num % 2 == 0 ) current_sum *= - 1 ; dp [ l ] [ r ] [ num ] = current_sum + Math . max ( MaximumScoreDP ( l + 1 , r , prefix_sum , num + 1 ) , MaximumScoreDP ( l , r - 1 , prefix_sum , num + 1 ) ) ; return dp [ l ] [ r ] [ num ] ; }
int findMaxScore ( int a [ ] , int n ) { int [ ] prefix_sum = new int [ n ] ; prefix_sum [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix_sum [ i ] = prefix_sum [ i - 1 ] + a [ i ] ; } for ( int i = 0 ; i < 100 ; i ++ ) { for ( int j = 0 ; j < 100 ; j ++ ) { for ( int l = 0 ; l < 100 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; } } return MaximumScoreDP ( 0 , n - 1 , prefix_sum , 1 ) ; }
void computeFibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 1 ; for ( int i = 2 ; i < 100005 ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } }
int countString ( String str ) { int ans = 1 ; int cnt = 1 ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( i - 1 ) ) { cnt ++ ; } else { ans = ans * fib [ cnt ] ; cnt = 1 ; } } ans = ans * fib [ cnt ] ; return ans ; }
int find_max ( int i , int sum , int [ ] v , int k ) { if ( i == v . length ) return 0 ; if ( dp [ i ] [ sum ] != - 1 ) return dp [ i ] [ sum ] ; int ans = 0 ; if ( ( sum + find_max ( i + 1 , sum , v , k ) ) % k == 0 ) ans = find_max ( i + 1 , sum , v , k ) ; if ( ( sum + v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) % k == 0 ) ans = Math . max ( ans , v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) ; return dp [ i ] [ sum ] = ans ; }
int maxLength ( int [ ] a , int n ) { int maximum = 1 ; int left [ ] = new int [ n ] ; int right [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = 1 ; right [ i ] = 1 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] > a [ i + 1 ] ) { right [ i ] = right [ i + 1 ] + 1 ; } maximum = Math . max ( maximum , right [ i ] ) ; } for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] ) { left [ i ] = left [ i - 1 ] + 1 ; } } if ( n > 2 ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i - 1 ] > a [ i + 1 ] ) { maximum = Math . max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) ; } } } return maximum ; }
void printGolombSequence ( int N ) { int [ ] arr = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) arr [ i ] = 0 ; int cnt = 0 ; arr [ 0 ] = 0 ; arr [ 1 ] = 1 ; Map < Integer , Integer > M = new HashMap < Integer , Integer > ( ) ; M . put ( 2 , 2 ) ; for ( int i = 2 ; i <= N ; i ++ ) { if ( cnt == 0 ) { arr [ i ] = 1 + arr [ i - 1 ] ; cnt = M . get ( arr [ i ] ) ; cnt -- ; } else { arr [ i ] = arr [ i - 1 ] ; cnt -- ; } M . put ( i , arr [ i ] ) ; } for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
int number_of_ways ( int n ) { int [ ] includes_3 = new int [ n + 1 ] ; int [ ] not_includes_3 = new int [ n + 1 ] ; includes_3 [ 3 ] = 1 ; not_includes_3 [ 1 ] = 1 ; not_includes_3 [ 2 ] = 2 ; not_includes_3 [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { includes_3 [ i ] = includes_3 [ i - 1 ] + includes_3 [ i - 2 ] + not_includes_3 [ i - 3 ] ; not_includes_3 [ i ] = not_includes_3 [ i - 1 ] + not_includes_3 [ i - 2 ] ; } return includes_3 [ n ] ; }
int cntSubSeq ( int arr [ ] , int n ) { int pos_count = 0 ; int neg_count = 0 ; int result ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = ( int ) Math . pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= Math . pow ( 2 , neg_count - 1 ) ; else result = 0 ; return result ; }
void generateDivisors ( int n ) { for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { divisors [ i ] ++ ; } else { divisors [ i ] ++ ; divisors [ n / i ] ++ ; } } } }
int findMaxMultiples ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . max ( divisors [ arr [ i ] ] , ans ) ; generateDivisors ( arr [ i ] ) ; } return ans ; }
int max_sum ( int arr [ ] , int n , int k ) { int dp [ ] = new int [ n ] ; dp [ 0 ] = Math . max ( 0 , arr [ 0 ] ) ; int i = 1 ; while ( i < k ) { dp [ i ] = Math . max ( dp [ i - 1 ] , arr [ i ] ) ; i ++ ; } i = k ; while ( i < n ) { dp [ i ] = Math . max ( dp [ i - 1 ] , arr [ i ] + dp [ i - k ] ) ; i ++ ; } return dp [ n - 1 ] ; }
int maxIncSubarr ( int a [ ] , int n ) { int pre [ ] = new int [ n ] ; int pos [ ] = new int [ n ] ; pre [ 0 ] = 1 ; pos [ n - 1 ] = 1 ; int l = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] > a [ i - 1 ] ) pre [ i ] = pre [ i - 1 ] + 1 ; else pre [ i ] = 1 ; } l = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] < a [ i + 1 ] ) pos [ i ] = pos [ i + 1 ] + 1 ; else pos [ i ] = 1 ; } int ans = 0 ; l = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] > a [ i - 1 ] ) l ++ ; else l = 1 ; ans = Math . max ( ans , l ) ; } for ( int i = 1 ; i <= n - 2 ; i ++ ) { if ( a [ i - 1 ] < a [ i + 1 ] ) ans = Math . max ( pre [ i - 1 ] + pos [ i + 1 ] , ans ) ; } return ans ; }
int countWays ( int n ) { if ( n == 0 ) return 1 ; if ( n <= 2 ) return n ; int f0 = 1 , f1 = 1 , f2 = 2 ; int ans = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { ans = f0 + f1 + f2 ; f0 = f1 ; f1 = f2 ; f2 = ans ; } return ans ; }
long countStr ( int N ) { long dp [ ] [ ] = new long [ N + 1 ] [ 3 ] ; dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; dp [ 1 ] [ 2 ] = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; } long ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; }
int update ( int in , int l , int r , int up_in , int val ) { if ( r < up_in l > up_in ) return seg [ in ] ; if ( l == up_in && r == up_in ) return seg [ in ] = val ; int m = ( l + r ) / 2 ; return seg [ in ] = update ( 2 * in + 1 , l , m , up_in , val ) + update ( 2 * in + 2 , m + 1 , r , up_in , val ) ; }
int maxLengthSquare ( int row , int column , int [ ] [ ] arr , int k ) { int sum [ ] [ ] = new int [ row + 1 ] [ column + 1 ] ; int cur_max = 1 ; int max = 0 ; for ( int i = 1 ; i <= row ; i ++ ) { for ( int j = 1 ; j <= column ; j ++ ) { sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] + arr [ i - 1 ] [ j - 1 ] - sum [ i - 1 ] [ j - 1 ] ; if ( i >= cur_max && j >= cur_max && sum [ i ] [ j ] - sum [ i - cur_max ] [ j ] - sum [ i ] [ j - cur_max ] + sum [ i - cur_max ] [ j - cur_max ] <= k ) { max = cur_max ++ ; } } } return max ; }
int getSum ( int x , int y , int z ) { int ans = 0 ; exactnum [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i <= x ; ++ i ) { for ( int j = 0 ; j <= y ; ++ j ) { for ( int k = 0 ; k <= z ; ++ k ) { if ( i > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] % mod ; } if ( j > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod ; } if ( k > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j ] [ k - 1 ] % mod ; } ans += exactsum [ i ] [ j ] [ k ] % mod ; ans %= mod ; } } } return ans ; }
int maximum_set ( int a [ ] , int n ) { int dp [ ] = new int [ N ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ a [ i ] ] = 1 ; int ans = 1 ; for ( int i = N - 1 ; i >= 1 ; i -- ) { if ( dp [ i ] != 0 ) { for ( int j = 2 * i ; j < N ; j += i ) { dp [ i ] = Math . max ( dp [ i ] , 1 + dp [ j ] ) ; ans = Math . max ( ans , dp [ i ] ) ; } } } return ans ; }
int findMaxCount ( Node root ) { res = Integer . MIN_VALUE ; countUntil ( root ) ; return res ; }
int findLargestString ( String s , int i , int r ) { if ( i == s . length ( ) ) { if ( r == 0 ) return 0 ; else return INT_MIN ; } if ( v [ i ] [ r ] == 1 ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = Math . max ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( s . charAt ( i ) - '0' ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) ; return dp [ i ] [ r ] ; }
int findCnt ( String s , int i , int r ) { if ( i == s . length ( ) ) { if ( r == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ r ] == 1 ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = findCnt ( s , i + 1 , ( r * 2 + ( s . charAt ( i ) - '0' ) ) % 3 ) + findCnt ( s , i + 1 , r ) ; return dp [ i ] [ r ] ; }
long modInv ( long a ) { long p = MOD - 2 ; long s = 1 ; while ( p != 1 ) { if ( p % 2 == 1 ) s = ( s * a ) % MOD ; a = ( a * a ) % MOD ; p /= 2 ; } return ( a * s ) % MOD ; }
long findCnt ( char x , String y ) { long ans = 0 ; long fact [ ] = new long [ y . length ( ) + 1 ] ; for ( int i = 0 ; i < y . length ( ) + 1 ; i ++ ) fact [ i ] = 1 ; for ( int i = 1 ; i <= y . length ( ) ; i ++ ) fact [ i ] = ( fact [ i - 1 ] * i ) % MOD ; for ( int i = 0 ; i < y . length ( ) ; i ++ ) { if ( y . charAt ( i ) == x ) { ans += ( modInv ( fact [ i ] ) * modInv ( fact [ y . length ( ) - i - 1 ] ) ) % MOD ; ans %= MOD ; } } ans *= fact [ ( y . length ( ) - 1 ) ] ; ans %= MOD ; return ans ; }
int minCount ( int arr [ ] , int n , int k ) { int ans = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum -= k ; int l = 0 ; int r = 0 ; int tot = 0 ; while ( l < n ) { if ( tot <= sum ) { ans = Math . max ( ans , r - l ) ; if ( r == n ) break ; tot += arr [ r ++ ] ; } else { tot -= arr [ l ++ ] ; } } return ( n - ans ) ; }
void findSubSeq ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int count [ ] = new int [ n ] ; int prev [ ] = new int [ n ] ; int i , j ; for ( i = 0 ; i < n ; i ++ ) count [ i ] = 1 ; for ( j = 0 ; j < n ; j ++ ) prev [ j ] = - 1 ; int max = 0 ; int maxprev = - 1 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] % arr [ j ] == 0 && count [ j ] + 1 > count [ i ] ) { count [ i ] = count [ j ] + 1 ; prev [ i ] = j ; } } if ( max < count [ i ] ) { max = count [ i ] ; maxprev = i ; } } i = maxprev ; while ( i >= 0 ) { if ( arr [ i ] != - 1 ) System . out . print ( arr [ i ] + " " ) ; i = prev [ i ] ; } }
int solve ( int arr [ ] , int l , int r , int k ) { if ( r - l + 1 <= k ) return sum ( arr , l , r ) ; if ( dp [ l ] [ r ] [ k ] != 0 ) return dp [ l ] [ r ] [ k ] ; int sum_ = sum ( arr , l , r ) ; int len_r = ( r - l + 1 ) - k ; int len = ( r - l + 1 ) ; int ans = 0 ; for ( int i = 0 ; i < len - len_r + 1 ; i ++ ) { int sum_sub = sum ( arr , i + l , i + l + len_r - 1 ) ; ans = Math . max ( ans , ( sum_ - sum_sub ) + ( sum_sub - solve ( arr , i + l , i + l + len_r - 1 , k ) ) ) ; } dp [ l ] [ r ] [ k ] = ans ; return ans ; }
int minDifference ( int x , int y , int k , int b [ ] [ ] , int c [ ] [ ] ) { if ( x >= n y >= m ) return INT_MAX ; if ( x == n - 1 && y == m - 1 ) { int diff = b [ x ] [ y ] - c [ x ] [ y ] ; return Math . min ( Math . abs ( k - diff ) , Math . abs ( k + diff ) ) ; } int ans = dp [ x ] [ y ] [ k ] ; if ( ans != - 1 ) return ans ; ans = INT_MAX ; int diff = b [ x ] [ y ] - c [ x ] [ y ] ; ans = Math . min ( ans , minDifference ( x + 1 , y , Math . abs ( k + diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x , y + 1 , Math . abs ( k + diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x + 1 , y , Math . abs ( k - diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x , y + 1 , Math . abs ( k - diff ) , b , c ) ) ; return ans ; }
int countSubSeq ( String str , int len ) { int ans = 0 ; int mul = 1 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '0' ) ans += mul ; mul *= 2 ; } return ans ; }
int solveDp ( int r , int i , int w [ ] , int val [ ] , int n ) { if ( r <= 0 ) return 0 ; if ( i == n ) return W_MAX ; if ( v [ r ] [ i ] ) return dp [ r ] [ i ] ; v [ r ] [ i ] = true ; dp [ r ] [ i ] = Math . min ( solveDp ( r , i + 1 , w , val , n ) , w [ i ] + solveDp ( r - val [ i ] , i + 1 , w , val , n ) ) ; return dp [ r ] [ i ] ; }
int maxWeight ( int w [ ] , int val [ ] , int n , int c ) { for ( int i = V_SUM_MAX ; i >= 0 ; i -- ) { if ( solveDp ( i , 0 , w , val , n ) <= c ) { return i ; } } return 0 ; }
int dfs ( int node ) { vis [ node ] = 1 ; subtree_size [ node ] = 1 ; for ( int child : ( ArrayList < Integer > ) tree [ node ] ) { if ( vis [ child ] == 0 ) { subtree_size [ node ] += dfs ( child ) ; } } return subtree_size [ node ] ; }
int contribution ( int node , int ans ) { vis [ node ] = 1 ; for ( int child : ( ArrayList < Integer > ) tree [ node ] ) { if ( vis [ child ] == 0 ) { ans += ( subtree_size [ child ] * ( n - subtree_size [ child ] ) ) ; ans = contribution ( child , ans ) ; } } return ans ; }
int getSum ( ) { Arrays . fill ( vis , 0 ) ; dfs ( 0 ) ; int ans = 0 ; Arrays . fill ( vis , 0 ) ; ans = contribution ( 0 , ans ) ; return ans ; }
int longest_subseq ( int n , int k , String s ) { int [ ] dp = new int [ n ] ; int [ ] max_length = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int curr = s . charAt ( i ) - 'a' ; int lower = Math . max ( 0 , curr - k ) ; int upper = Math . min ( 25 , curr + k ) ; for ( int j = lower ; j < upper + 1 ; j ++ ) { dp [ i ] = Math . max ( dp [ i ] , max_length [ j ] + 1 ) ; } max_length [ curr ] = Math . max ( dp [ i ] , max_length [ curr ] ) ; } int ans = 0 ; for ( int i : dp ) ans = Math . max ( i , ans ) ; return ans ; }
int countNum ( int idx , int sum , int tight , Vector < Integer > num , int len , int k ) { if ( len == idx ) { if ( sum == 0 ) return 1 ; else return 0 ; } if ( dp [ idx ] [ sum ] [ tight ] != - 1 ) return dp [ idx ] [ sum ] [ tight ] ; int res = 0 , limit ; if ( tight == 0 ) { limit = num . get ( idx ) ; } else { limit = 9 ; } for ( int i = 0 ; i <= limit ; i ++ ) { int new_tight = tight ; if ( tight == 0 && i < limit ) new_tight = 1 ; res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len , k ) ; res %= MOD ; } if ( res < 0 ) res += MOD ; return dp [ idx ] [ sum ] [ tight ] = res ; }
Vector < Integer > process ( String s ) { Vector < Integer > num = new Vector < Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { num . add ( s . charAt ( i ) - '0' ) ; } return num ; }
void maxLengthOf1s ( int arr [ ] , int n ) { int prefix [ ] = new int [ n ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i - 2 ] == 1 ) prefix [ i ] = prefix [ i - 1 ] + 1 ; else prefix [ i ] = 0 ; } int suffix [ ] = new int [ n ] ; for ( int i = n - 3 ; i >= 0 ; i -- ) { if ( arr [ i + 2 ] == 1 ) suffix [ i ] = suffix [ i + 1 ] + 1 ; else suffix [ i ] = 0 ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans = Math . max ( ans , prefix [ i + 1 ] + suffix [ i ] ) ; } System . out . println ( ans ) ; }
int MaxGCD ( int a [ ] , int n ) { int [ ] Prefix = new int [ n + 2 ] ; int [ ] Suffix = new int [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = __gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = __gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = Math . max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = Math . max ( ans , __gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; }
int max_sum ( int a [ ] , int n ) { int [ ] [ ] dp = new int [ n + 1 ] [ 2 ] ; dp [ 0 ] [ 0 ] = 0 ; dp [ 0 ] [ 1 ] = - 999999 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] + a [ i ] , dp [ i ] [ 1 ] - a [ i ] ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] - a [ i ] , dp [ i ] [ 1 ] + a [ i ] ) ; } return dp [ n ] [ 0 ] ; }
int sumOfProduct ( int arr [ ] , int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; int cur_sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = arr [ i - 1 ] ; cur_sum += arr [ i - 1 ] ; } for ( int i = 2 ; i <= k ; i ++ ) { int temp_sum = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { cur_sum -= dp [ i - 1 ] [ j ] ; dp [ i ] [ j ] = arr [ j - 1 ] * cur_sum ; temp_sum += dp [ i ] [ j ] ; } cur_sum = temp_sum ; } return cur_sum ; }
int number_of_ways ( int arr [ ] , int n , int k ) { if ( k == 1 ) return 1 ; int dp [ ] = new int [ k + 1 ] ; int i ; for ( i = 0 ; i < k + 1 ; i ++ ) dp [ i ] = - 1 ; for ( i = 0 ; i < n ; i ++ ) dp [ arr [ i ] ] = 0 ; dp [ 0 ] = 1 ; dp [ 1 ] = ( dp [ 1 ] == - 1 ) ? 1 : dp [ 1 ] ; for ( i = 2 ; i <= k ; ++ i ) { if ( dp [ i ] == 0 ) continue ; dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; dp [ i ] %= MOD ; } return dp [ k ] ; }
int MinCost ( int arr [ ] , int n ) { int [ ] [ ] dp = new int [ n + 5 ] [ n + 5 ] ; int [ ] [ ] sum = new int [ n + 5 ] [ n + 5 ] ; for ( int i = 0 ; i < n ; i ++ ) { int k = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { if ( i == j ) sum [ i ] [ j ] = k ; else { k += arr [ j ] ; sum [ i ] [ j ] = k ; } } } for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = i ; j < n ; j ++ ) { dp [ i ] [ j ] = Integer . MAX_VALUE ; if ( i == j ) dp [ i ] [ j ] = 0 ; else { for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + sum [ i ] [ j ] ) ; } } } } return dp [ 0 ] [ n - 1 ] ; }
int findCount ( int N ) { Vector list = new Vector ( ) ; int sum = 0 ; int i ; for ( i = 0 ; i < 20 ; i ++ ) { sum += Math . pow ( 2 , i ) ; list . add ( sum ) ; } for ( i = 0 ; i < 20 ; i ++ ) { if ( ( int ) list . get ( i ) >= N ) return ( list . indexOf ( list . get ( i ) ) + 1 ) ; } return 0 ; }
int findMax ( int arr [ ] , int n ) { int res = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( j = 0 ; j < i ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) count += 1 ; } res = Math . max ( count , res ) ; } return res ; }
int findMax ( int arr [ ] , int n ) { boolean [ ] divisible = new boolean [ n ] ; int res = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( divisible [ i ] ) continue ; int cnt = 0 ; for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] % arr [ i ] ) == 0 ) { divisible [ j ] = true ; cnt ++ ; } } res = Math . max ( res , cnt ) ; } return res ; }
void findSetBits ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) System . out . print ( Integer . bitCount ( i ) + " " ) ; }
void findSetBits ( int n ) { int [ ] dp = new int [ n + 1 ] ; System . out . print ( dp [ 0 ] + " " ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { dp [ i ] = dp [ i / 2 ] ; } else { dp [ i ] = dp [ i / 2 ] + 1 ; } System . out . print ( dp [ i ] + " " ) ; } }
int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == 0 ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
int findCnt ( int [ ] arr , int i , int required_sum , int n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ required_sum + base ] ) return dp [ i ] [ required_sum + base ] ; v [ i ] [ required_sum + base ] = true ; dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + base ] ; }
int findCnt ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { return ( curr == m ? 1 : 0 ) ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr arr [ i ] ) , n , m ) ; return dp [ i ] [ curr ] ; }
int findCnt ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { return ( curr == m ? 1 : 0 ) ; } if ( v1 [ i ] [ curr ] ) return dp1 [ i ] [ curr ] ; v1 [ i ] [ curr ] = true ; dp1 [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr & arr [ i ] ) , n , m ) ; return dp1 [ i ] [ curr ] ; }
int modulo_13 ( String s , int n ) { long [ ] [ ] dp = new long [ n + 1 ] [ 13 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { int nxt = s . charAt ( i ) - '0' ; if ( s . charAt ( i ) == '?' ) nxt = j ; for ( int k = 0 ; k < 13 ; k ++ ) { int rem = ( 10 * k + nxt ) % 13 ; dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] ; dp [ i + 1 ] [ rem ] %= MOD ; } if ( s . charAt ( i ) != '?' ) break ; } } return ( int ) dp [ n ] [ 5 ] ; }
int f ( int i , int state , int A [ ] , int dp [ ] [ ] , int N ) { if ( i >= N ) return 0 ; else if ( dp [ i ] [ state ] != - 1 ) { return dp [ i ] [ state ] ; } else { if ( i == N - 1 ) dp [ i ] [ state ] = 1 ; else if ( state == 1 && A [ i ] > A [ i + 1 ] ) dp [ i ] [ state ] = 1 ; else if ( state == 2 && A [ i ] < A [ i + 1 ] ) dp [ i ] [ state ] = 1 ; else if ( state == 1 && A [ i ] <= A [ i + 1 ] ) dp [ i ] [ state ] = 1 + f ( i + 1 , 2 , A , dp , N ) ; else if ( state == 2 && A [ i ] >= A [ i + 1 ] ) dp [ i ] [ state ] = 1 + f ( i + 1 , 1 , A , dp , N ) ; return dp [ i ] [ state ] ; } }
int maxLenSeq ( int A [ ] , int N ) { int i , j , tmp , y , ans ; int dp [ ] [ ] = new int [ 1000 ] [ 3 ] ; for ( i = 0 ; i < 1000 ; i ++ ) for ( j = 0 ; j < 3 ; j ++ ) dp [ i ] [ j ] = - 1 ; for ( i = 0 ; i < N ; i ++ ) { tmp = f ( i , 1 , A , dp , N ) ; tmp = f ( i , 2 , A , dp , N ) ; } ans = - 1 ; for ( i = 0 ; i < N ; i ++ ) { y = dp [ i ] [ 1 ] ; if ( i + y >= N ) ans = Math . max ( ans , dp [ i ] [ 1 ] + 1 ) ; else if ( y % 2 == 0 ) { ans = Math . max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 2 ] ) ; } else if ( y % 2 == 1 ) { ans = Math . max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 1 ] ) ; } } return ans ; }
int countWays ( int n ) { Vector < Integer > a = new Vector < > ( ) ; int i = 1 ; while ( i <= n ) a . add ( i ++ ) ; int ways = 0 ; do { boolean flag = ( a . get ( 0 ) == 1 ) ; for ( int j = 1 ; j < n ; j ++ ) { if ( Math . abs ( a . get ( j ) - a . get ( j - 1 ) ) > 2 ) flag = false ; } if ( flag ) ways ++ ; } while ( next_permutation ( a ) ) ; return ways ; }
int LISusingLCS ( Vector < Integer > seq ) { int n = seq . size ( ) ; int L [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; Vector < Integer > sortedseq = new Vector < Integer > ( seq ) ; Collections . sort ( sortedseq ) ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( seq . get ( i - 1 ) == sortedseq . get ( j - 1 ) ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ n ] [ n ] ; }
int count_numbers ( int k , int n , boolean flag ) { if ( n == 1 ) { if ( flag ) { return ( k - 1 ) ; } else { return 1 ; } } if ( flag ) return ( k - 1 ) * ( count_numbers ( k , n - 1 , false ) + count_numbers ( k , n - 1 , true ) ) ; else return count_numbers ( k , n - 1 , true ) ; }
int count_numbers ( int k , int n ) { int [ ] [ ] dp = new int [ n + 1 ] [ 2 ] ; dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = k - 1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) ; } return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ; }
int divideArray ( int arr [ ] , int n , int k ) { int dp [ ] [ ] = new int [ 500 ] [ 500 ] ; int i , j ; for ( i = 0 ; i < 500 ; i ++ ) for ( j = 0 ; j < 500 ; j ++ ) dp [ i ] [ j ] = 0 ; k -= 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { for ( j = 0 ; j <= k ; j ++ ) { dp [ i ] [ j ] = Integer . MAX_VALUE ; int max_ = - 1 , sum = 0 ; for ( int l = i ; l < n ; l ++ ) { max_ = Math . max ( max_ , arr [ l ] ) ; sum += arr [ l ] ; int diff = ( l - i + 1 ) * max_ - sum ; if ( j > 0 ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , diff + dp [ l + 1 ] [ j - 1 ] ) ; else dp [ i ] [ j ] = diff ; } } } return dp [ 0 ] [ k ] ; }
int cntSubsets ( int [ ] arr , int n ) { int max = ( int ) Math . pow ( 2 , n ) ; int result = 0 ; for ( int i = 0 ; i < max ; i ++ ) { int counter = i ; if ( ( counter & ( counter >> 1 ) ) > 0 ) continue ; result ++ ; } return result ; }
int cntSubsets ( int [ ] arr , int n ) { int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } int result = a [ n - 1 ] + b [ n - 1 ] ; return result ; }
void perfix_calculate ( int [ ] [ ] A , int [ ] [ ] row , int [ ] [ ] col ) { int n = ( int ) A . length ; int m = ( int ) A [ 0 ] . length ; for ( int i = 0 ; i < n ; ++ i ) { row [ i ] [ 0 ] = A [ i ] [ 0 ] ; } for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 1 ; j < m ; ++ j ) { row [ i ] [ j ] = row [ i ] [ j - 1 ] + A [ i ] [ j ] ; } } for ( int i = 0 ; i < m ; ++ i ) { col [ 0 ] [ i ] = A [ 0 ] [ i ] ; } for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 1 ; j < n ; ++ j ) { col [ j ] [ i ] = A [ j ] [ i ] + col [ j - 1 ] [ i ] ; } } }
int perimeter ( int i , int j , int k , int [ ] [ ] row , int [ ] [ ] col , int [ ] [ ] A ) { int row_s , col_s ; if ( j == 0 ) row_s = 0 ; else row_s = row [ i ] [ j - 1 ] ; if ( i == 0 ) col_s = 0 ; else col_s = col [ i - 1 ] [ j ] ; int upper_row = row [ i ] [ j + k ] - row_s ; int left_col = col [ i + k ] [ j ] - col_s ; if ( j == 0 ) row_s = 0 ; else row_s = row [ i + k ] [ j - 1 ] ; if ( i == 0 ) col_s = 0 ; else col_s = col [ i - 1 ] [ j + k ] ; int lower_row = row [ i + k ] [ j + k ] - row_s ; int right_col = col [ i + k ] [ j + k ] - col_s ; int sum = upper_row + lower_row + left_col + right_col ; sum -= ( A [ i ] [ j ] + A [ i + k ] [ j ] + A [ i ] [ j + k ] + A [ i + k ] [ j + k ] ) ; return sum ; }
int maxPerimeter ( int [ ] [ ] A ) { int n = ( int ) A . length ; int m = ( int ) A [ 0 ] . length ; int [ ] [ ] row = new int [ n ] [ m ] ; int [ ] [ ] col = new int [ n ] [ m ] ; perfix_calculate ( A , row , col ) ; int maxPer = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { for ( int k = 0 ; k < Math . min ( n - i , m - j ) ; ++ k ) { int perimtr = perimeter ( i , j , k , row , col , A ) ; maxPer = Math . max ( maxPer , perimtr ) ; } } } return maxPer ; }
boolean mazeProb ( ArrayList < ArrayList < Integer > > maze , int xpos , int ypos ) { boolean key = true ; if ( findPath ( maze , xpos , ypos , key ) ) return true ; return false ; }
int ways ( int i , int arr [ ] , int n ) { if ( i == n - 1 ) return 1 ; int sum = 0 ; for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; }
int minJumps ( int arr [ ] , int N ) { int MAX = 1000000 ; int [ ] fib = new int [ 30 ] ; fib [ 0 ] = 0 ; fib [ 1 ] = 1 ; for ( int i = 2 ; i < 30 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; int [ ] DP = new int [ N + 2 ] ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= N + 1 ; i ++ ) DP [ i ] = MAX ; for ( int i = 1 ; i <= N + 1 ; i ++ ) { for ( int j = 1 ; j < 30 ; j ++ ) { if ( ( i == N + 1 arr [ i - 1 ] == 1 ) && i - fib [ j ] >= 0 ) DP [ i ] = Math . min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) ; } } if ( DP [ N + 1 ] != MAX ) return DP [ N + 1 ] ; else return - 1 ; }
int CountOfOddSum ( int a [ ] [ ] , int n ) { int [ ] [ ] dp = new int [ n ] [ 2 ] ; int [ ] [ ] cnt = new int [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { if ( a [ i ] [ j ] % 2 == 0 ) { cnt [ i ] [ 0 ] ++ ; } else { cnt [ i ] [ 1 ] ++ ; } } } dp [ 0 ] [ 0 ] = cnt [ 0 ] [ 0 ] ; dp [ 0 ] [ 1 ] = cnt [ 0 ] [ 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] * cnt [ i ] [ 0 ] + dp [ i - 1 ] [ 1 ] * cnt [ i ] [ 1 ] ) ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] * cnt [ i ] [ 1 ] + dp [ i - 1 ] [ 1 ] * cnt [ i ] [ 0 ] ) ; } return dp [ n - 1 ] [ 1 ] ; }
int recur ( int ind , int cnt , int last , int a [ ] , int n , int k , int dp [ ] [ ] ) { if ( cnt == k ) return 0 ; if ( ind == n ) return ( int ) - 1e9 ; if ( dp [ ind ] [ cnt ] != - 1 ) return dp [ ind ] [ cnt ] ; int ans = 0 ; for ( int i = ind ; i < n ; i ++ ) { if ( cnt % 2 == 0 ) ans = Math . max ( ans , recur ( i + 1 , cnt + 1 , i , a , n , k , dp ) ) ; else ans = Math . max ( ans , __gcd ( a [ last ] , a [ i ] ) + recur ( i + 1 , cnt + 1 , 0 , a , n , k , dp ) ) ; } return dp [ ind ] [ cnt ] = ans ; }
int Max_Sum ( int arr1 [ ] , int arr2 [ ] , int n ) { int [ ] [ ] dp = new int [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { dp [ i ] [ 0 ] = arr1 [ i ] ; dp [ i ] [ 1 ] = arr2 [ i ] ; continue ; } dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] + arr1 [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] + arr2 [ i ] ) ; } return Math . max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; }
int maximizeSum ( int [ ] a , int n , int ind , int k , int [ ] [ ] dp ) { if ( k == 0 ) { if ( ind == n ) return 0 ; else return - 1000000000 ; } else if ( ind == n ) return - 1000000000 ; else if ( dp [ ind ] [ k ] != - 1 ) return dp [ ind ] [ k ] ; else { int ans = 0 ; int mini = a [ ind ] ; for ( int i = ind ; i < n ; i ++ ) { mini = Math . min ( mini , a [ i ] ) ; ans = Math . max ( ans , maximizeSum ( a , n , i + 1 , k - 1 , dp ) + mini ) ; } return dp [ ind ] [ k ] = ans ; } }
int Partition ( int arr [ ] , int n , int k ) { int prefix [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i ] ; } int LOGS = 20 ; int ans = 0 ; for ( int i = LOGS ; i >= 0 ; -- i ) { if ( checkpossible ( ans | ( 1 << i ) , arr , prefix , n , k ) ) { ans = ans | ( 1 << i ) ; } } return ans ; }
void SieveOfEratosthenes ( int MAX , Vector < Integer > primes ) { boolean [ ] prime = new boolean [ MAX + 1 ] ; for ( int i = 0 ; i < MAX + 1 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } for ( int i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] ) primes . add ( i ) ; } }
int findLongest ( int [ ] A , int n ) { HashMap < Integer , Integer > mpp = new HashMap < > ( ) ; Vector < Integer > primes = new Vector < > ( ) ; SieveOfEratosthenes ( A [ n - 1 ] , primes ) ; int [ ] dp = new int [ n ] ; dp [ n - 1 ] = 1 ; mpp . put ( A [ n - 1 ] , n - 1 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int num = A [ i ] ; dp [ i ] = 1 ; int maxi = 0 ; for ( int it : primes ) { int xx = num * it ; if ( xx > A [ n - 1 ] ) break ; else if ( mpp . get ( xx ) != null && mpp . get ( xx ) != 0 ) { dp [ i ] = Math . max ( dp [ i ] , 1 + dp [ mpp . get ( xx ) ] ) ; } } mpp . put ( A [ i ] , i ) ; } int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) ans = Math . max ( ans , dp [ i ] ) ; return ans ; }
void initialize ( ) { for ( int i = 0 ; i <= N ; i += 1 ) { for ( int j = 1 ; j <= RODS ; j ++ ) { for ( int k = 1 ; k <= RODS ; k += 1 ) { dp [ i ] [ j ] [ k ] = Integer . MAX_VALUE ; } } } }
int mincost ( int idx , int src , int dest , int costs [ ] [ ] ) { if ( idx > N ) return 0 ; if ( dp [ idx ] [ src ] [ dest ] != Integer . MAX_VALUE ) return dp [ idx ] [ src ] [ dest ] ; int rem = 6 - ( src + dest ) ; int ans = Integer . MAX_VALUE ; int case1 = costs [ src - 1 ] [ dest - 1 ] + mincost ( idx + 1 , src , rem , costs ) + mincost ( idx + 1 , rem , dest , costs ) ; int case2 = costs [ src - 1 ] [ rem - 1 ] + mincost ( idx + 1 , src , dest , costs ) + mincost ( idx + 1 , dest , src , costs ) + costs [ rem - 1 ] [ dest - 1 ] + mincost ( idx + 1 , src , dest , costs ) ; ans = Math . min ( case1 , case2 ) ; dp [ idx ] [ src ] [ dest ] = ans ; return ans ; }
int MaxGCD ( int a [ ] , int n ) { int Prefix [ ] = new int [ n + 2 ] ; int Suffix [ ] = new int [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = Math . max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = Math . max ( ans , gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; }
Vector < Integer > numToVec ( int N ) { Vector < Integer > digit = new Vector < Integer > ( ) ; while ( N != 0 ) { digit . add ( N % 10 ) ; N = N / 10 ; } if ( digit . size ( ) == 0 ) digit . add ( 0 ) ; Collections . reverse ( digit ) ; return digit ; }
int solve ( Vector < Integer > A , int B , int C ) { Vector < Integer > digit = new Vector < Integer > ( ) ; int d , d2 ; digit = numToVec ( C ) ; d = A . size ( ) ; if ( B > digit . size ( ) d == 0 ) return 0 ; else if ( B < digit . size ( ) ) { if ( A . get ( 0 ) == 0 && B != 1 ) return ( int ) ( ( d - 1 ) * Math . pow ( d , B - 1 ) ) ; else return ( int ) Math . pow ( d , B ) ; } else { int [ ] dp = new int [ B + 1 ] ; int [ ] lower = new int [ MAX + 1 ] ; for ( int i = 0 ; i < d ; i ++ ) lower [ A . get ( i ) + 1 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) lower [ i ] = lower [ i - 1 ] + lower [ i ] ; boolean flag = true ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= B ; i ++ ) { d2 = lower [ digit . get ( i - 1 ) ] ; dp [ i ] = dp [ i - 1 ] * d ; if ( i == 1 && A . get ( 0 ) == 0 && B != 1 ) d2 = d2 - 1 ; if ( flag ) dp [ i ] += d2 ; flag = ( flag & ( lower [ digit . get ( i - 1 ) + 1 ] == lower [ digit . get ( i - 1 ) ] + 1 ) ) ; } return dp [ B ] ; } }
int LongestConsSeq ( int [ ] arr , int N ) { int maxval = 1 ; for ( int i = 0 ; i < N ; i += 1 ) { maxval = Math . max ( maxval , arr [ i ] ) ; } int [ ] [ ] dp = new int [ maxval + 1 ] [ 2 ] ; int ans = 1 ; for ( int i = 0 ; i < N ; i += 1 ) { dp [ arr [ i ] ] [ 0 ] = ( 1 + dp [ arr [ i ] - 1 ] [ 0 ] ) ; if ( arr [ i ] >= 2 ) dp [ arr [ i ] ] [ 1 ] = Math . max ( 1 + dp [ arr [ i ] - 1 ] [ 1 ] , 2 + dp [ arr [ i ] - 2 ] [ 0 ] ) ; else dp [ arr [ i ] ] [ 1 ] = 1 ; ans = Math . max ( ans , dp [ arr [ i ] ] [ 1 ] ) ; } return ans ; }
int min ( int p , int q , int r , int s ) { int temp1 = p < q ? p : q ; int temp2 = r < s ? r : s ; if ( temp1 < temp2 ) return temp1 ; return temp2 ; }
int Distance ( int arr [ ] [ ] , int i , int j ) { if ( i >= R j >= C i < 0 j < 0 ) return INT_MAX ; else if ( arr [ i ] [ j ] == 0 ) { table [ i ] [ j ] = INT_MAX ; return INT_MAX ; } else if ( arr [ i ] [ j ] == 2 ) { table [ i ] [ j ] = 0 ; return 0 ; } else if ( visited [ i ] [ j ] == 1 ) { return INT_MAX ; } else { visited [ i ] [ j ] = 1 ; int temp1 = Distance ( arr , i + 1 , j ) ; int temp2 = Distance ( arr , i - 1 , j ) ; int temp3 = Distance ( arr , i , j + 1 ) ; int temp4 = Distance ( arr , i , j - 1 ) ; int min_value = 1 + min ( temp1 , temp2 , temp3 , temp4 ) ; if ( table [ i ] [ j ] > 0 && table [ i ] [ j ] < INT_MAX ) { if ( min_value < table [ i ] [ j ] ) table [ i ] [ j ] = min_value ; } else table [ i ] [ j ] = min_value ; visited [ i ] [ j ] = 0 ; } return table [ i ] [ j ] ; }
int minTime ( int arr [ ] [ ] ) { int max = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( arr [ i ] [ j ] == 1 ) Distance ( arr , i , j ) ; } } for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( arr [ i ] [ j ] == 1 && table [ i ] [ j ] > max ) max = table [ i ] [ j ] ; } } if ( max < INT_MAX ) return max ; return - 1 ; }
int findDepthRec ( String tree , int n , int index ) { if ( index >= n || tree . charAt ( index ) == 'l' ) return 0 ; index ++ ; int left = findDepthRec ( tree , n , index ) ; index ++ ; int right = findDepthRec ( tree , n , index ) ; return Math . max ( left , right ) + 1 ; }
int findDepth ( String tree , int n ) { int index = 0 ; return ( findDepthRec ( tree , n , index ) ) ; }
int solve ( String str , int K ) { int N = str . length ( ) ; dp = new int [ N ] [ K ] ; for ( int [ ] row : dp ) { Arrays . fill ( row , - 1 ) ; } int ans = solveUtil ( 0 , 0 , str , K ) ; return ans == Integer . MAX_VALUE ? - 1 : ans ; }
long solve ( String str , int K ) { int n = str . length ( ) ; long dp [ ] [ ] = new long [ K ] [ n ] ; if ( n < K ) return - 1 ; else if ( n == K ) return 0 ; long zeroes = 0 , ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '0' ) zeroes ++ ; else ones ++ ; dp [ 0 ] [ i ] = ones * zeroes ; } for ( int s = 1 ; s < K ; s ++ ) { for ( int i = 0 ; i < n ; i ++ ) { dp [ s ] [ i ] = Integer . MAX_VALUE ; ones = 0 ; zeroes = 0 ; for ( int k = i ; k >= 0 ; k -- ) { if ( str . charAt ( k ) == '0' ) zeroes ++ ; else ones ++ ; dp [ s ] [ i ] = Math . min ( dp [ s ] [ i ] , + ( ( k - 1 >= 0 ) ? ones * zeroes + dp [ s - 1 ] [ k - 1 ] : Integer . MAX_VALUE ) ) ; } } } return ( dp [ K - 1 ] [ n - 1 ] == Integer . MAX_VALUE ) ? - 1 : dp [ K - 1 ] [ n - 1 ] ; }
int max_sum ( int a [ ] , int n ) { int [ ] dp = new int [ n ] ; if ( n == 1 ) { dp [ 0 ] = Math . max ( 0 , a [ 0 ] ) ; } else if ( n == 2 ) { dp [ 0 ] = Math . max ( 0 , a [ 0 ] ) ; dp [ 1 ] = Math . max ( a [ 1 ] , dp [ 0 ] ) ; } else if ( n >= 3 ) { dp [ 0 ] = Math . max ( 0 , a [ 0 ] ) ; dp [ 1 ] = Math . max ( a [ 1 ] , Math . max ( 0 , a [ 0 ] ) ) ; dp [ 2 ] = Math . max ( a [ 2 ] , Math . max ( a [ 1 ] , Math . max ( 0 , a [ 0 ] ) ) ) ; int i = 3 ; while ( i < n ) { dp [ i ] = Math . max ( dp [ i - 1 ] , a [ i ] + dp [ i - 3 ] ) ; i ++ ; } } return dp [ n - 1 ] ; }
int minCount ( int K ) { int memo [ ] = new int [ 100 ] ; for ( int i = 0 ; i < 100 ; i ++ ) { memo [ i ] = Integer . MAX_VALUE ; } memo [ 0 ] = 0 ; for ( int i = 1 ; i < 100 ; i ++ ) { memo [ i ] = Math . min ( memo [ i - 1 ] + 1 , memo [ i ] ) ; } for ( int i = 10 ; i < 100 ; i ++ ) { memo [ i ] = Math . min ( memo [ i - 10 ] + 1 , memo [ i ] ) ; } for ( int i = 25 ; i < 100 ; i ++ ) { memo [ i ] = Math . min ( memo [ i - 25 ] + 1 , memo [ i ] ) ; } int min_count = 0 ; while ( K > 0 ) { min_count += memo [ K % 100 ] ; K /= 100 ; } return min_count ; }
int NoofWays ( int face , int throwsVal , int sum ) { if ( sum == 0 && throwsVal == 0 ) { return 1 ; } if ( sum < 0 throwsVal == 0 ) { return 0 ; } if ( dp [ throwsVal ] [ sum ] != - 1 ) { return dp [ throwsVal ] [ sum ] ; } int ans = 0 ; for ( int i = 1 ; i <= face ; i ++ ) { ans += NoofWays ( face , throwsVal - 1 , sum - i ) ; } return dp [ throwsVal ] [ sum ] = ans ; }
void solve ( char [ ] s ) { int n = s . length ; int [ ] [ ] dp = new int [ n ] [ n ] ; for ( int len = n - 1 ; len >= 0 ; -- len ) { for ( int i = 0 ; i + len < n ; ++ i ) { int j = i + len ; if ( i == 0 && j == n - 1 ) { if ( s [ i ] == s [ j ] ) dp [ i ] [ j ] = 2 ; else if ( s [ i ] != s [ j ] ) dp [ i ] [ j ] = 1 ; } else { if ( s [ i ] == s [ j ] ) { if ( i - 1 >= 0 ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } if ( j + 1 <= n - 1 ) { dp [ i ] [ j ] += dp [ i ] [ j + 1 ] ; } if ( i - 1 < 0 j + 1 >= n ) { dp [ i ] [ j ] += 1 ; } } else if ( s [ i ] != s [ j ] ) { if ( i - 1 >= 0 ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } if ( j + 1 <= n - 1 ) { dp [ i ] [ j ] += dp [ i ] [ j + 1 ] ; } if ( i - 1 >= 0 && j + 1 <= n - 1 ) { dp [ i ] [ j ] -= dp [ i - 1 ] [ j + 1 ] ; } } } } } Vector < Integer > ways = new Vector < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( i == 0 i == n - 1 ) { ways . add ( 1 ) ; } else { int total = dp [ i - 1 ] [ i + 1 ] ; ways . add ( total ) ; } } for ( int i = 0 ; i < ways . size ( ) ; ++ i ) { System . out . print ( ways . get ( i ) + " " ) ; } }
int maxSum ( int arr [ ] , int i , int n , int k ) { if ( i >= n ) return 0 ; if ( visit [ i ] ) return dp [ i ] ; visit [ i ] = true ; int tot = 0 ; dp [ i ] = maxSum ( arr , i + 1 , n , k ) ; for ( int j = i ; j < ( i + k ) && ( j < n ) ; j ++ ) { tot += arr [ j ] ; dp [ i ] = Math . max ( dp [ i ] , tot + maxSum ( arr , j + 2 , n , k ) ) ; } return dp [ i ] ; }
int get_binary ( int u ) { int ans = 0 ; while ( u > 0 ) { int rem = u % 10 ; ans |= ( 1 << rem ) ; u /= 10 ; } return ans ; }
int waysutil ( int index , int sum , int count , Vector < Integer > arr , int K ) { if ( index < 0 ) { return 0 ; } if ( index == 0 ) { if ( count == 0 ) { return 0 ; } int remainder = sum % count ; if ( remainder != 0 ) { return 0 ; } int average = sum / count ; if ( average == K ) { return 1 ; } } if ( dp [ index ] [ sum ] [ count ] != - 1 ) { return dp [ index ] [ sum ] [ count ] ; } int dontpick = waysutil ( index - 1 , sum , count , arr , K ) ; int pick = waysutil ( index - 1 , sum + arr . get ( index ) , count + 1 , arr , K ) ; int total = pick + dontpick ; dp [ index ] [ sum ] [ count ] = total ; return total ; }
int ways ( int N , int K , int [ ] arr ) { Vector < Integer > Arr = new Vector < > ( ) ; Arr . add ( - 1 ) ; for ( int i = 0 ; i < N ; ++ i ) { Arr . add ( arr [ i ] ) ; } for ( int i = 0 ; i < MAX_INDEX ; i ++ ) { for ( int j = 0 ; j < MAX_SUM ; j ++ ) { for ( int l = 0 ; l < MAX_INDEX ; l ++ ) { dp [ i ] [ j ] [ l ] = - 1 ; } } } int answer = waysutil ( N , 0 , 0 , Arr , K ) ; return answer ; }
int RetClose ( int a , int b , int s ) { if ( Math . abs ( a - s ) < Math . abs ( b - s ) ) return a ; else return b ; }
void FindClose ( int arr [ ] , int n ) { int ans = inf ; for ( int i = 1 ; i <= n ; i ++ ) ans = RetClose ( arr [ i - 1 ] + MinDiff ( i , arr [ i - 1 ] , arr , n ) , ans , 0 ) ; System . out . println ( ans ) ; }
int FindMax ( int i , int r , int w [ ] , int n , int c , int k ) { if ( i >= n ) { return 0 ; } if ( v . get ( i ) . get ( r ) ) { return dp . get ( i ) . get ( r ) ; } v . get ( i ) . set ( r , true ) ; dp . get ( i ) . set ( r , FindMax ( i + 1 , r , w , n , c , k ) ) ; for ( int j = 0 ; j < k ; j ++ ) { int x = ( r / exp_c . get ( j ) ) % ( c + 1 ) ; if ( x - w [ i ] >= 0 ) { dp . get ( i ) . set ( r , Math . max ( dp . get ( i ) . get ( r ) , w [ i ] + FindMax ( i + 1 , r - w [ i ] * exp_c . get ( j ) , w , n , c , k ) ) ) ; } } return dp . get ( i ) . get ( r ) ; }
int PreCompute ( int n , int c , int k ) { for ( int i = 0 ; i < k ; i ++ ) { exp_c . add ( 0 ) ; } exp_c . set ( 0 , 1 ) ; for ( int i = 1 ; i < k ; i ++ ) { exp_c . set ( i , ( exp_c . get ( i - 1 ) * ( c + 1 ) ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { dp . add ( new ArrayList < Integer > ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < ( exp_c . get ( k - 1 ) * ( c + 1 ) ) ; j ++ ) { dp . get ( i ) . add ( 0 ) ; } } for ( int i = 0 ; i < n ; i ++ ) { v . add ( new ArrayList < Boolean > ( Arrays . asList ( new Boolean [ ( exp_c . get ( k - 1 ) * ( c + 1 ) ) ] ) ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { Collections . fill ( v . get ( i ) , Boolean . FALSE ) ; } int R = 0 ; for ( int i = 0 ; i < k ; i ++ ) { R += exp_c . get ( i ) * c ; } return R ; }
int findMax ( int i , int r , int w [ ] , int n ) { if ( r < 0 ) return Integer . MIN_VALUE ; if ( i == n ) return 0 ; if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = true ; dp [ i ] [ r ] = Math . max ( w [ i ] + findMax ( i + 1 , r - w [ i ] , w , n ) , findMax ( i + 1 , r , w , n ) ) ; return dp [ i ] [ r ] ; }
void preCompute ( int w [ ] , int n ) { for ( int i = C_MAX ; i >= 0 ; i -- ) findMax ( 0 , i , w , n ) ; }
int ansQuery ( int w ) { return dp [ 0 ] [ w ] ; }
int minSum ( int A [ ] , int B [ ] , int C [ ] , int i , int n , int curr , int [ ] [ ] dp ) { if ( n <= 0 ) return 0 ; if ( dp [ n ] [ curr ] != - 1 ) return dp [ n ] [ curr ] ; if ( curr == 0 ) { return dp [ n ] [ curr ] = Math . min ( B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; } if ( curr == 1 ) return dp [ n ] [ curr ] = Math . min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; return dp [ n ] [ curr ] = Math . min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) ) ; }
void findPrefixSum ( int arr [ ] , int n ) { prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix_sum [ i ] = arr [ i ] + prefix_sum [ i - 1 ] ; } }
int maxSum ( int arr [ ] , int i , int n , int k ) { if ( i + k > n ) { return 0 ; } if ( v [ i ] ) { return dp [ i ] ; } v [ i ] = true ; int x ; if ( i == 0 ) { x = prefix_sum [ k - 1 ] ; } else { x = prefix_sum [ i + k - 1 ] - prefix_sum [ i - 1 ] ; } dp [ i ] = Math . max ( maxSum ( arr , i + 1 , n , k ) , x + maxSum ( arr , i + k + 1 , n , k ) ) ; return dp [ i ] ; }
long getChicks ( int n ) { int size = Math . max ( n , 7 ) ; long [ ] dp = new long [ size ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < 6 ; i ++ ) { dp [ i ] = dp [ i - 1 ] * 3 ; } dp [ 6 ] = 726 ; for ( int i = 8 ; i <= n ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] - ( 2 * dp [ i - 6 ] / 3 ) ) * 3 ; } return dp [ n ] ; }
int getChicks ( int n ) { int chicks = ( int ) Math . pow ( 3 , n - 1 ) ; return chicks ; }
int MaximumMarks ( int marksarr [ ] , int timearr [ ] , int h , int n , int p ) { int no_of_topics = n + 1 ; int total_time = h + 1 ; int T [ ] [ ] = new int [ no_of_topics ] [ total_time ] ; for ( int i = 0 ; i < no_of_topics ; i ++ ) { T [ i ] [ 0 ] = 0 ; } for ( int j = 0 ; j < total_time ; j ++ ) { T [ 0 ] [ j ] = 0 ; } for ( int i = 1 ; i < no_of_topics ; i ++ ) { for ( int j = 1 ; j < total_time ; j ++ ) { if ( j < timearr [ i ] ) { T [ i ] [ j ] = T [ i - 1 ] [ j ] ; } else { T [ i ] [ j ] = Math . max ( marksarr [ i ] + T [ i - 1 ] [ j - timearr [ i ] ] , T [ i - 1 ] [ j ] ) ; } } } int i = no_of_topics - 1 , j = total_time - 1 ; int sum = 0 ; while ( i > 0 && j > 0 ) { if ( T [ i ] [ j ] == T [ i - 1 ] [ j ] ) { i -- ; } else { sum += timearr [ i ] ; j -= timearr [ i ] ; i -- ; } } int marks = T [ no_of_topics - 1 ] [ total_time - 1 ] ; if ( marks < p ) return - 1 ; return sum ; }
void findSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; }
int cntWays ( int arr [ ] , int i , int ck , int k , int n , int curr_sum ) { if ( sum % k != 0 ) return 0 ; if ( i != n && ck == k + 1 ) return 0 ; if ( i == n ) { if ( ck == k + 1 ) return 1 ; else return 0 ; } if ( v [ i ] [ ck ] ) return dp [ i ] [ ck ] ; curr_sum += arr [ i ] ; v [ i ] [ ck ] = true ; dp [ i ] [ ck ] = cntWays ( arr , i + 1 , ck , k , n , curr_sum ) ; if ( curr_sum == ( sum / k ) * ck ) dp [ i ] [ ck ] += cntWays ( arr , i + 1 , ck + 1 , k , n , curr_sum ) ; return dp [ i ] [ ck ] ; }
int SubsetCnt ( int i , int s , int arr [ ] , int n ) { if ( i == n ) { if ( s == 0 ) { return 1 ; } else { return 0 ; } } if ( visit [ i ] [ s + arrSize ] ) { return dp [ i ] [ s + arrSize ] ; } visit [ i ] [ s + arrSize ] = true ; dp [ i ] [ s + arrSize ] = SubsetCnt ( i + 1 , s + arr [ i ] , arr , n ) + SubsetCnt ( i + 1 , s , arr , n ) ; return dp [ i ] [ s + arrSize ] ; }
int sumMax ( int i , int arr [ ] , int n ) { if ( i >= n - 1 ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = true ; dp [ i ] = Math . max ( arr [ i ] + arr [ i + 1 ] + sumMax ( i + 3 , arr , n ) , sumMax ( i + 1 , arr , n ) ) ; return dp [ i ] ; }
int MaxIncreasingSub ( int arr [ ] , int n , int k ) { int dp [ ] [ ] = new int [ n ] [ k + 1 ] , ans = - 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < k + 1 ; j ++ ) dp [ i ] [ j ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ 1 ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { for ( int l = 1 ; l <= k - 1 ; l ++ ) { if ( dp [ j ] [ l ] != - 1 ) { dp [ i ] [ l + 1 ] = Math . max ( dp [ i ] [ l + 1 ] , dp [ j ] [ l ] + arr [ i ] ) ; } } } } } for ( int i = 0 ; i < n ; i ++ ) { if ( ans < dp [ i ] [ k ] ) ans = dp [ i ] [ k ] ; } return ( ans == - 1 ) ? 0 : ans ; }
void solve ( int remSum , int maxVal , int idx , int count ) { if ( remSum == 0 ) { print ( idx ) ; count ++ ; return ; } for ( int i = maxVal ; i >= 1 ; i -- ) { if ( i > remSum ) { continue ; } else if ( i <= remSum ) { dp [ idx ] = i ; solve ( remSum - i , i , idx + 1 , count ) ; } } }
void findPrefixCount ( int arr [ ] [ ] ) { for ( int i = 0 ; i < bitscount ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { prefix_count [ i ] [ j ] [ 0 ] = ( ( arr [ j ] [ 0 ] >> i ) & 1 ) ; for ( int k = 1 ; k < n ; k ++ ) { prefix_count [ i ] [ j ] [ k ] = ( ( arr [ j ] [ k ] >> i ) & 1 ) ; prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j ] [ k - 1 ] ; } } } for ( int i = 0 ; i < bitscount ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) for ( int k = 0 ; k < n ; k ++ ) prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j - 1 ] [ k ] ; }
int rangeOr ( int x1 , int y1 , int x2 , int y2 ) { int ans = 0 ; for ( int i = 0 ; i < bitscount ; i ++ ) { int p ; if ( x1 == 0 && y1 == 0 ) p = prefix_count [ i ] [ x2 ] [ y2 ] ; else if ( x1 == 0 ) p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x2 ] [ y1 - 1 ] ; else if ( y1 == 0 ) p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x1 - 1 ] [ y2 ] ; else p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x1 - 1 ] [ y2 ] - prefix_count [ i ] [ x2 ] [ y1 - 1 ] + prefix_count [ i ] [ x1 - 1 ] [ y1 - 1 ] ; if ( p != 0 ) ans = ( ans | ( 1 << i ) ) ; } return ans ; }
void findPrefixCount ( int arr [ ] [ ] ) { for ( int i = 0 ; i < bitscount ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { prefix_count [ i ] [ j ] [ 0 ] = ( ( arr [ j ] [ 0 ] >> i ) & 1 ) ; for ( int k = 1 ; k < n ; k ++ ) { prefix_count [ i ] [ j ] [ k ] = ( ( arr [ j ] [ k ] >> i ) & 1 ) ; prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j ] [ k - 1 ] ; } } } for ( int i = 0 ; i < bitscount ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) for ( int k = 0 ; k < n ; k ++ ) prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j - 1 ] [ k ] ; }
void findPrefixCount ( int arr [ ] , int n ) { for ( int i = 0 ; i < bitscount ; i ++ ) { prefix_count [ i ] [ 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) ; for ( int j = 1 ; j < n ; j ++ ) { prefix_count [ i ] [ j ] = ( ( arr [ j ] >> i ) & 1 ) ; prefix_count [ i ] [ j ] += prefix_count [ i ] [ j - 1 ] ; } } }
int rangeOr ( int l , int r ) { int ans = 0 ; for ( int i = 0 ; i < bitscount ; i ++ ) { int x ; if ( l == 0 ) x = prefix_count [ i ] [ r ] ; else x = prefix_count [ i ] [ r ] - prefix_count [ i ] [ l - 1 ] ; if ( x != 0 ) ans = ( ans | ( 1 << i ) ) ; } return ans ; }
int palindromeSubStrs ( String s ) { int [ ] [ ] dp = new int [ s . length ( ) ] [ s . length ( ) ] ; int st , end , i , len ; HashMap < String , Boolean > m = new HashMap < > ( ) ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { dp [ i ] [ i ] = 1 ; m . put ( s . substring ( i , i + 1 ) , true ) ; } for ( i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) { dp [ i ] [ i + 1 ] = 1 ; m . put ( s . substring ( i , i + 2 ) , true ) ; } else dp [ i ] [ i + 1 ] = 0 ; } for ( len = 3 ; len <= s . length ( ) ; len ++ ) { for ( st = 0 ; st <= s . length ( ) - len ; st ++ ) { end = st + len - 1 ; if ( s . charAt ( st ) == s . charAt ( end ) && dp [ st + 1 ] [ end - 1 ] == 1 ) { dp [ st ] [ end ] = 1 ; m . put ( s . substring ( st , end + 1 ) , true ) ; } else dp [ st ] [ end ] = 0 ; } } return m . size ( ) ; }
int maxSum ( int arr [ ] , int i , int n ) { if ( i >= n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = true ; dp [ i ] = Math . max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) ; return dp [ i ] ; }
int countWays ( int i , int j , int x , int arr [ ] [ ] ) { if ( i == n j == n ) { return 0 ; } x = ( x & arr [ i ] [ j ] ) ; if ( x == 0 ) { return 0 ; } if ( i == n - 1 && j == n - 1 ) { return 1 ; } if ( v [ i ] [ j ] [ x ] == 1 ) { return dp [ i ] [ j ] [ x ] ; } v [ i ] [ j ] [ x ] = 1 ; dp [ i ] [ j ] [ x ] = countWays ( i + 1 , j , x , arr ) + countWays ( i , j + 1 , x , arr ) ; return dp [ i ] [ j ] [ x ] ; }
int minSteps ( int i , int j , int arr [ ] [ ] ) { if ( i == n - 1 && j == n - 1 ) { return 0 ; } if ( i > n - 1 j > n - 1 ) { return 9999999 ; } if ( v [ i ] [ j ] == 1 ) { return dp [ i ] [ j ] ; } v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 9999999 ; for ( int k = Math . max ( 0 , arr [ i ] [ j ] + j - n + 1 ) ; k <= Math . min ( n - i - 1 , arr [ i ] [ j ] ) ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , minSteps ( i + k , j + arr [ i ] [ j ] - k , arr ) ) ; } dp [ i ] [ j ] ++ ; return dp [ i ] [ j ] ; }
int minSteps ( int i , int j , int arr [ ] [ ] ) { if ( i == n - 1 && j == n - 1 ) { return 0 ; } if ( i > n - 1 j > n - 1 ) { return 9999999 ; } if ( v [ i ] [ j ] == 1 ) { return dp [ i ] [ j ] ; } v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 1 + Math . min ( minSteps ( i + arr [ i ] [ j ] , j , arr ) , minSteps ( i , j + arr [ i ] [ j ] , arr ) ) ; return dp [ i ] [ j ] ; }
int oSRec ( int [ ] arr , int i , int j , int sum ) { if ( j == i + 1 ) return Math . max ( arr [ i ] , arr [ j ] ) ; return Math . max ( ( sum - oSRec ( arr , i + 1 , j , sum - arr [ i ] ) ) , ( sum - oSRec ( arr , i , j - 1 , sum - arr [ j ] ) ) ) ; }
int optimalStrategyOfGame ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } return oSRec ( arr , 0 , n - 1 , sum ) ; }
int oSRec ( int arr [ ] , int i , int j , int sum ) { if ( j == i + 1 ) return Math . max ( arr [ i ] , arr [ j ] ) ; if ( memo [ i ] [ j ] != - 1 ) return memo [ i ] [ j ] ; memo [ i ] [ j ] = Math . max ( ( sum - oSRec ( arr , i + 1 , j , sum - arr [ i ] ) ) , ( sum - oSRec ( arr , i , j - 1 , sum - arr [ j ] ) ) ) ; return memo [ i ] [ j ] ; }
int optimalStrategyOfGame ( int [ ] arr , int n ) { int sum = 0 ; sum = accumulate ( arr , 0 , n ) ; for ( int j = 0 ; j < MAX ; j ++ ) { for ( int k = 0 ; k < MAX ; k ++ ) memo [ j ] [ k ] = - 1 ; } return oSRec ( arr , 0 , n - 1 , sum ) ; }
long number ( String s , int i , int j ) { long ans = 0 ; for ( int x = i ; x < j ; x ++ ) { ans = ans * 2 + ( s . charAt ( x ) - '0' ) ; } return ans ; }
int minCuts ( String s , int n ) { int [ ] dp = new int [ n + 1 ] ; Arrays . fill ( dp , n + 1 ) ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( s . charAt ( i - 1 ) == '0' ) { continue ; } for ( int j = 0 ; j < i ; j ++ ) { if ( s . charAt ( j ) == '0' ) { continue ; } long num = number ( s , j , i ) ; if ( ! ispower ( num ) ) { continue ; } dp [ i ] = Math . min ( dp [ i ] , dp [ j ] + 1 ) ; } } return ( ( dp [ n ] < n + 1 ) ? dp [ n ] : - 1 ) ; }
int sum ( int i1 , int j1 , int i2 , int j2 ) { if ( i1 == i2 && j1 == j2 ) { return arr [ i1 ] [ j1 ] ; } return arr [ i1 ] [ j1 ] + arr [ i2 ] [ j2 ] ; }
int MinOfCubed ( int k ) { if ( k < 8 ) return k ; int res = k ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = Math . min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }
int MinOfCubedDP ( int k ) { int [ ] DP = new int [ k + 1 ] ; int j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { DP [ i ] = Integer . MAX_VALUE ; while ( j <= i ) { if ( j == i ) DP [ i ] = 1 ; else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ; t ++ ; j = t * t * t ; } t = j = 1 ; } return DP [ k ] ; }
int getMaximumSum ( int a [ ] , int n , int x ) { int dp [ ] [ ] = new int [ n ] [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxi = Math . max ( maxi , func ( i , 0 , a , dp , n , x ) ) ; } return maxi ; }
void pre_process ( boolean dp [ ] [ ] , char [ ] s ) { int n = s . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = false ; } } for ( int j = 1 ; j <= n ; j ++ ) { for ( int i = 0 ; i <= n - j ; i ++ ) { if ( j <= 2 ) { if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i ] [ i + j - 1 ] = true ; } } else if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] ; } } } }
int countPairs ( String s ) { boolean dp [ ] [ ] = new boolean [ N ] [ N ] ; pre_process ( dp , s . toCharArray ( ) ) ; int n = s . length ( ) ; int left [ ] = new int [ n ] ; int right [ ] = new int [ n ] ; left [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( dp [ j ] [ i ] == true ) { left [ i ] ++ ; } } } right [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { right [ i ] = right [ i + 1 ] ; for ( int j = n - 1 ; j >= i ; j -- ) { if ( dp [ i ] [ j ] == true ) { right [ i ] ++ ; } } } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans += left [ i ] * right [ i + 1 ] ; } return ans ; }
void answerQuery ( int l , int r , boolean dp [ ] [ ] ) { if ( dp [ l ] [ r ] ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } }
int LIS ( int a [ ] , int n ) { int dp [ ] = new int [ N ] , d [ ] = new int [ N ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( int j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = Math . max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; }
boolean check ( String s ) { int n = s . length ( ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' && s . charAt ( i - 1 ) == '1' && s . charAt ( i - 2 ) == '1' ) return true ; } return false ; }
int solve ( int i , int x , int dp [ ] [ ] ) { if ( i < 0 ) { return x == 3 ? 1 : 0 ; } if ( dp [ i ] [ x ] != - 1 ) { return dp [ i ] [ x ] ; } dp [ i ] [ x ] = solve ( i - 1 , 0 , dp ) ; dp [ i ] [ x ] += solve ( i - 1 , x + 1 , dp ) ; return dp [ i ] [ x ] ; }
void dfs ( int u , int p ) { for ( int v : g [ u ] ) { if ( v != p ) { dfs ( v , u ) ; for ( int i = 0 ; i < 22 ; i ++ ) a [ u ] [ i ] += a [ v ] [ i ] ; } } int pp = 0 ; for ( int i = 0 ; i < 22 ; i ++ ) { if ( ! ( ( a [ u ] [ i ] > 0 && x [ i ] - a [ u ] [ i ] > 0 ) || ( a [ u ] [ i ] == 0 && x [ i ] == 0 ) ) ) { pp = 1 ; break ; } } if ( pp == 0 ) ans ++ ; }
int findCount ( int mat [ ] [ ] , int i , int j , int m ) { if ( i == 0 && j == 0 ) { if ( m == mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; } if ( m < 0 ) return 0 ; if ( i < 0 j < 0 ) return 0 ; if ( v [ i ] [ j ] [ m ] ) return dp [ i ] [ j ] [ m ] ; v [ i ] [ j ] [ m ] = true ; dp [ i ] [ j ] [ m ] = findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ; return dp [ i ] [ j ] [ m ] ; }
int maxSum ( int [ ] arr , int k , int n ) { if ( n == 0 ) return 0 ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return Math . max ( arr [ 0 ] , arr [ 1 ] ) ; int [ ] dp = new int [ n ] ; dp [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i <= k ; i ++ ) dp [ i ] = Math . max ( arr [ i ] , dp [ i - 1 ] ) ; for ( int i = k + 1 ; i < n ; i ++ ) dp [ i ] = Math . max ( arr [ i ] , dp [ i - ( k + 1 ) ] + arr [ i ] ) ; return maximum ( dp ) ; }
int [ ] precompute ( ) { int dp [ ] = new int [ maxn ] , arr [ ] = { 4 , 6 , 9 } ; for ( int i = 0 ; i < maxn ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < maxn ; ++ i ) { for ( int k = 0 ; k < 3 ; k ++ ) { int j = arr [ k ] ; if ( i >= j && dp [ i - j ] != - 1 ) { dp [ i ] = Math . max ( dp [ i ] , dp [ i - j ] + 1 ) ; } } } return dp ; }
int CountWays ( int r , int b , int l , int R , int B , int W , int [ ] [ ] [ ] dp ) { if ( l > W ) return 0 ; if ( r > R ) return 0 ; if ( b == B && r == R ) return 1 ; if ( b == B ) return 0 ; if ( dp [ r ] [ b ] [ l ] != - 1 ) return dp [ r ] [ b ] [ l ] ; int ans = 0 ; ans += CountWays ( r , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 1 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 2 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 3 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 4 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 6 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r , b + 1 , l + 1 , R , B , W , dp ) ; ans = ans % mod ; return dp [ r ] [ b ] [ l ] = ans ; }
int FindMinimumCost ( int ind , int a [ ] , int n , int k , int dp [ ] ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != - 1 ) return dp [ ind ] ; else { int ans = Integer . MAX_VALUE ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = Math . min ( ans , Math . abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } }
int minCostJumpsDP ( int [ ] A , int k ) { int size = A . length ; int [ ] x = new int [ size ] ; Arrays . fill ( x , Integer . MAX_VALUE ) ; x [ 0 ] = 0 ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = i + 1 ; j < i + k + 1 && j < size ; j ++ ) { x [ j ] = min ( x [ j ] , x [ i ] + Math . abs ( A [ i ] - A [ j ] ) ) ; } } return x [ size - 1 ] ; }
int FindMaximumSum ( int ind , int kon , int a [ ] , int b [ ] , int c [ ] , int n , int dp [ ] [ ] ) { if ( ind == n ) return 0 ; if ( dp [ ind ] [ kon ] != - 1 ) return dp [ ind ] [ kon ] ; int ans = ( int ) ( - 1e9 + 5 ) ; if ( kon == 0 ) { ans = Math . max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = Math . max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; } else if ( kon == 1 ) { ans = Math . max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; ans = Math . max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; } else if ( kon == 2 ) { ans = Math . max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = Math . max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; } return dp [ ind ] [ kon ] = ans ; }
boolean isVowel ( char x ) { return ( x == 'a' x == 'e' x == 'i' x == 'o' x == 'u' ) ; }
int findMinimumDeletion ( int l , int r , int dp [ ] [ ] , String s ) { if ( l > r ) { return 0 ; } if ( l == r ) { return 1 ; } if ( dp [ l ] [ r ] != - 1 ) { return dp [ l ] [ r ] ; } int res = 1 + findMinimumDeletion ( l + 1 , r , dp , s ) ; for ( int i = l + 1 ; i <= r ; ++ i ) { if ( s . charAt ( l ) == s . charAt ( i ) ) { res = Math . min ( res , findMinimumDeletion ( l + 1 , i - 1 , dp , s ) + findMinimumDeletion ( i , r , dp , s ) ) ; } } return dp [ l ] [ r ] = res ; }
int noOfBinaryStrings ( int N , int k ) { int dp [ ] = new int [ 100002 ] ; for ( int i = 1 ; i <= k - 1 ; i ++ ) { dp [ i ] = 1 ; } dp [ k ] = 2 ; for ( int i = k + 1 ; i <= N ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; } return dp [ N ] ; }
long answer ( int n ) { int [ ] dp = new int [ 10 ] ; int [ ] prev = new int [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { prev [ j ] = dp [ j ] ; } for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ j ] = prev [ j + 1 ] ; else if ( j == 9 ) dp [ j ] = prev [ j - 1 ] ; else dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ] ; } } long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ j ] ; return sum ; }
int MinimumCost ( int a [ ] , int n , int x ) { for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = Math . min ( a [ i ] , 2 * a [ i - 1 ] ) ; } int ind = 0 ; int sum = 0 ; while ( x > 0 ) { if ( x != 0 ) sum += a [ ind ] ; ind ++ ; x = x >> 1 ; } return sum ; }
void dfs ( int node , ArrayList < Integer > adj [ ] , int dp [ ] , boolean visited [ ] ) { visited [ node ] = true ; for ( int i = 0 ; i < adj [ node ] . size ( ) ; i ++ ) { if ( ! visited [ adj [ node ] . get ( i ) ] ) dfs ( adj [ node ] . get ( i ) , adj , dp , visited ) ; dp [ node ] = Math . max ( dp [ node ] , 1 + dp [ adj [ node ] . get ( i ) ] ) ; } }
void sieve_modified ( ) { for ( int i = 2 ; i < MAX ; i += 2 ) { for ( int j = i ; j < MAX ; j += i ) prefix [ j ] += i ; } for ( int i = 1 ; i < MAX ; i ++ ) prefix [ i ] += prefix [ i - 1 ] ; }
void binomialCoeff ( int n ) { int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } }
int findSubarraySum ( int ind , int flips , int n , int [ ] a , int k ) { if ( flips > k ) return ( int ) ( - 1e9 ) ; if ( ind == n ) return 0 ; if ( dp [ ind ] [ flips ] != - 1 ) return dp [ ind ] [ flips ] ; int ans = 0 ; ans = Math . max ( 0 , a [ ind ] + findSubarraySum ( ind + 1 , flips , n , a , k ) ) ; ans = Math . max ( ans , - a [ ind ] + findSubarraySum ( ind + 1 , flips + 1 , n , a , k ) ) ; return dp [ ind ] [ flips ] = ans ; }
void catalanDP ( long n ) { catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) { catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } } }
int CatalanSequence ( int arr [ ] , int n ) { catalanDP ( n ) ; HashSet < Integer > s = new HashSet < Integer > ( ) ; int a = 1 , b = 1 ; int c ; s . add ( a ) ; if ( n >= 2 ) { s . add ( b ) ; } for ( int i = 2 ; i < n ; i ++ ) { s . add ( ( int ) catalan [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( s . contains ( arr [ i ] ) ) { s . remove ( arr [ i ] ) ; } } return s . size ( ) ; }
int findSubsequence ( int arr [ ] , int n ) { int len = 1 ; int tmp ; int i , j , d ; int [ ] [ ] dp = new int [ n ] [ 10 ] ; int [ ] cnt = new int [ 10 ] ; int locMax ; tmp = arr [ 0 ] ; while ( tmp > 0 ) { dp [ 0 ] [ tmp % 10 ] = 1 ; tmp /= 10 ; } for ( i = 1 ; i < n ; i ++ ) { tmp = arr [ i ] ; locMax = 1 ; for ( int x = 0 ; x < 10 ; x ++ ) cnt [ x ] = 0 ; while ( tmp > 0 ) { cnt [ tmp % 10 ] = 1 ; tmp /= 10 ; } for ( d = 0 ; d <= 9 ; d ++ ) { if ( cnt [ d ] > 0 ) { dp [ i ] [ d ] = 1 ; for ( j = 0 ; j < i ; j ++ ) { dp [ i ] [ d ] = Math . max ( dp [ i ] [ d ] , dp [ j ] [ d ] + 1 ) ; locMax = Math . max ( dp [ i ] [ d ] , locMax ) ; } } } for ( d = 0 ; d <= 9 ; d ++ ) { if ( cnt [ d ] > 0 ) { dp [ i ] [ d ] = locMax ; } } len = Math . max ( len , locMax ) ; } return len ; }
int solve ( int x ) { Vector < Integer > num = new Vector < Integer > ( ) ; while ( x != 0 ) { num . add ( x % 10 ) ; x /= 10 ; } Collections . reverse ( num ) ; for ( int i = 0 ; i < dp . length ; i ++ ) for ( int j = 0 ; j < dp [ i ] . length ; j ++ ) for ( int k = 0 ; k < dp [ i ] [ j ] . length ; k ++ ) for ( int k1 = 0 ; k1 < dp [ i ] [ j ] [ k ] . length ; k1 ++ ) dp [ i ] [ j ] [ k ] [ k1 ] = - 1 ; return count ( 0 , 0 , 0 , 0 , num ) ; }
void Add_edge ( int x , int y ) { gr [ x ] . add ( y ) ; gr [ y ] . add ( x ) ; }
void dfs ( int v , int par ) { d [ v ] [ 0 ] = 1 ; for ( Integer i : gr [ v ] ) { if ( i != par ) { dfs ( i , v ) ; for ( int j = 1 ; j <= k ; j ++ ) ans += d [ i ] [ j - 1 ] * d [ v ] [ k - j ] ; for ( int j = 1 ; j <= k ; j ++ ) d [ v ] [ j ] += d [ i ] [ j - 1 ] ; } } }
int count ( int pos , int sum , int rem , int tight , int nonz , Vector < Integer > num ) { if ( pos == num . size ( ) ) { if ( rem == 0 && sum == n ) return 1 ; return 0 ; } if ( dp [ pos ] [ sum ] [ rem ] [ tight ] != - 1 ) return dp [ pos ] [ sum ] [ rem ] [ tight ] ; int ans = 0 ; int limit = ( tight != 0 ? 9 : num . get ( pos ) ) ; for ( int d = 0 ; d <= limit ; d ++ ) { if ( d == 0 && nonz != 0 ) continue ; int currSum = sum + d ; int currRem = ( rem * 10 + d ) % m ; int currF = ( tight != 0 || ( d < num . get ( pos ) ) ) ? 1 : 0 ; ans += count ( pos + 1 , currSum , currRem , currF , ( nonz != 0 d != 0 ) ? 1 : 0 , num ) ; } return dp [ pos ] [ sum ] [ rem ] [ tight ] = ans ; }
int findXorSum ( int arr [ ] , int n ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { int c_odd = 0 ; boolean odd = false ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) odd = ( ! odd ) ; if ( odd ) c_odd ++ ; } for ( int j = 0 ; j < n ; j ++ ) { sum += ( mul * c_odd ) ; if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) c_odd = ( n - j - c_odd ) ; } mul *= 2 ; } return sum ; }
void preCompute ( ) { lpd = new int [ MAX + 1 ] ; lpd [ 0 ] = lpd [ 1 ] = 1 ; for ( int i = 2 ; i * i <= MAX ; i ++ ) { for ( int j = i * 2 ; j <= MAX ; j += i ) { if ( lpd [ j ] == 0 ) { lpd [ j ] = i ; } } } for ( int i = 2 ; i <= MAX ; i ++ ) { if ( lpd [ i ] == 0 ) { lpd [ i ] = i ; } } }
int maxLengthSubsequence ( Integer arr [ ] , int n ) { Integer dp [ ] = new Integer [ N ] ; Map < Integer , Integer > pos = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { while ( arr [ i ] > 1 ) { int p = lpd [ arr [ i ] ] ; if ( pos . containsKey ( p ) ) { dp [ i ] = Math . max ( dp [ i ] , 1 + dp [ pos . get ( p ) ] ) ; } pos . put ( p , i ) ; while ( arr [ i ] % p == 0 ) arr [ i ] /= p ; } } int ans = Collections . max ( Arrays . asList ( dp ) ) ; return ans ; }
int charVal ( String s , int i ) { if ( s . charAt ( i ) == '0' ) { return 0 ; } else if ( s . charAt ( i ) == '1' ) { return 1 ; } else { return 2 ; } }
int getSum ( int r1 , int r2 , int c1 , int c2 , int dp [ ] [ ] ) { return dp [ r2 ] [ c2 ] - dp [ r2 ] [ c1 ] - dp [ r1 ] [ c2 ] + dp [ r1 ] [ c1 ] ; }
boolean sumFound ( int K , int S , int grid [ ] [ ] ) { int dp [ ] [ ] = new int [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i + 1 ] [ j + 1 ] = dp [ i + 1 ] [ j ] + dp [ i ] [ j + 1 ] - dp [ i ] [ j ] + grid [ i ] [ j ] ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int sum = getSum ( i , i + K , j , j + K , dp ) ; if ( sum == S ) { return true ; } } } return false ; }
int totalSubSets ( int n , int l , int r ) { int zero = ( int ) Math . floor ( ( double ) r / 3 ) - ( int ) Math . ceil ( ( double ) l / 3 ) + 1 ; int one = ( int ) Math . floor ( ( double ) ( r - 1 ) / 3 ) - ( int ) Math . ceil ( ( double ) ( l - 1 ) / 3 ) + 1 ; int two = ( int ) Math . floor ( ( double ) ( r - 2 ) / 3 ) - ( int ) Math . ceil ( ( double ) ( l - 2 ) / 3 ) + 1 ; int [ ] [ ] dp = new int [ n ] [ 3 ] ; dp [ 0 ] [ 0 ] = zero ; dp [ 0 ] [ 1 ] = one ; dp [ 0 ] [ 2 ] = two ; for ( int i = 1 ; i < n ; ++ i ) { dp [ i ] [ 0 ] = ( ( dp [ i - 1 ] [ 0 ] * zero ) + ( dp [ i - 1 ] [ 1 ] * two ) + ( dp [ i - 1 ] [ 2 ] * one ) ) % MOD ; dp [ i ] [ 1 ] = ( ( dp [ i - 1 ] [ 0 ] * one ) + ( dp [ i - 1 ] [ 1 ] * zero ) + ( dp [ i - 1 ] [ 2 ] * two ) ) % MOD ; dp [ i ] [ 2 ] = ( ( dp [ i - 1 ] [ 0 ] * two ) + ( dp [ i - 1 ] [ 1 ] * one ) + ( dp [ i - 1 ] [ 2 ] * zero ) ) % MOD ; } return dp [ n - 1 ] [ 0 ] ; }
int solve ( int idx , int diff , int N , int M , int K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx ] [ diff ] != - 1 ) return dp [ idx ] [ diff ] ; int ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; return dp [ idx ] [ diff ] = ans % MOD ; }
int maxPathSum ( int tri [ ] [ ] ) { int ans = 0 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < N - i ; j ++ ) { if ( j - 1 >= 0 ) tri [ i ] [ j ] += Math . max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; ans = Math . max ( ans , tri [ i ] [ j ] ) ; } } return ans ; }
int subsetXOR ( int arr [ ] , int n , int K ) { int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; int m = ( 1 << ( int ) ( Math . log ( max_ele ) / Math . log ( 2 ) + 1 ) ) - 1 ; int [ ] [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) for ( int k = 0 ; k <= n ; k ++ ) dp [ i ] [ j ] [ k ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { for ( int k = 0 ; k <= n ; k ++ ) { dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] ; if ( k != 0 ) { dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] ; } } } } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ans += dp [ n ] [ K ] [ i ] ; } return ans ; }
float calcProbability ( int M [ ] [ ] , int k ) { float dp [ ] [ ] = new float [ m ] [ n ] ; float sum [ ] = new float [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { dp [ 0 ] [ j ] = M [ 0 ] [ j ] ; sum [ 0 ] = sum [ 0 ] + dp [ 0 ] [ j ] ; } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] / sum [ i - 1 ] + M [ i ] [ j ] ; sum [ i ] += dp [ i ] [ j ] ; } } return dp [ n - 1 ] [ k - 1 ] / sum [ n - 1 ] ; }
int MaximumNumbers ( String s ) { int n = s . length ( ) ; int [ ] remIndex = { - 1 , - 1 , - 1 } ; remIndex [ 0 ] = 0 ; int [ ] res = new int [ n + 1 ] ; int r = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { r = ( r + s . charAt ( i - 1 ) - '0' ) % 3 ; res [ i ] = res [ i - 1 ] ; if ( remIndex [ r ] != - 1 ) res [ i ] = Math . max ( res [ i ] , res [ remIndex [ r ] ] + 1 ) ; remIndex [ r ] = i + 1 ; } return res [ n ] ; }
int get_max_splits ( String num_String ) { int count = 0 , current_num ; int running_sum = 0 ; for ( int i = 0 ; i < num_String . length ( ) ; i ++ ) { current_num = num_String . charAt ( i ) - '0' ; running_sum += current_num ; if ( current_num % 3 == 0 || ( running_sum != 0 && running_sum % 3 == 0 ) ) { count += 1 ; running_sum = 0 ; } } return count ; }
int findMinimumSteps ( int mat [ ] [ ] , int x , int y , int n ) { int i , j , k ; int [ ] [ ] dist = new int [ n ] [ n ] ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 0 ) dist [ i ] [ j ] = INF ; else dist [ i ] [ j ] = 1 ; if ( i == j ) dist [ i ] [ j ] = 1 ; } } for ( k = 0 ; k < n ; k ++ ) { for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; } } } if ( dist [ x ] [ y ] < INF ) return dist [ x ] [ y ] ; else return - 1 ; }
boolean findmatch ( char mat [ ] [ ] , String pat , int x , int y , int nrow , int ncol , int level ) { int l = pat . length ( ) ; if ( level == l ) return true ; if ( x < 0 y < 0 x >= nrow y >= ncol ) return false ; if ( mat [ x ] [ y ] == pat . charAt ( level ) ) { char temp = mat [ x ] [ y ] ; mat [ x ] [ y ] = '#' ; boolean res = findmatch ( mat , pat , x - 1 , y , nrow , ncol , level + 1 ) | findmatch ( mat , pat , x + 1 , y , nrow , ncol , level + 1 ) | findmatch ( mat , pat , x , y - 1 , nrow , ncol , level + 1 ) | findmatch ( mat , pat , x , y + 1 , nrow , ncol , level + 1 ) ; mat [ x ] [ y ] = temp ; return res ; } return false ; }
boolean checkMatch ( char mat [ ] [ ] , String pat , int nrow , int ncol ) { int l = pat . length ( ) ; if ( l > nrow * ncol ) return false ; for ( int i = 0 ; i < nrow ; i ++ ) { for ( int j = 0 ; j < ncol ; j ++ ) { if ( mat [ i ] [ j ] == pat . charAt ( 0 ) ) if ( findmatch ( mat , pat , i , j , nrow , ncol , 0 ) ) return true ; } } return false ; }
int countPaths ( int sum , int get , int m , int n , int dp [ ] [ ] ) { if ( sum < 0 ) return 0 ; if ( sum == 0 ) return get ; if ( dp [ sum ] [ get ] != - 1 ) return dp [ sum ] [ get ] ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == m ) res += countPaths ( sum - i , 1 , m , n , dp ) ; res += countPaths ( sum - i , get , m , n , dp ) ; } dp [ sum ] [ get ] = res ; return dp [ sum ] [ get ] ; }
int countInRange ( int x ) { num = new Vector < Integer > ( ) ; while ( x != 0 ) { num . add ( x % 10 ) ; x /= 10 ; } Collections . reverse ( num ) ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) for ( int k = 0 ; k < 2 ; k ++ ) dp [ i ] [ j ] [ k ] = - 1 ; return countInRangeUtil ( 0 , 0 , 0 ) ; }
int solve ( int x ) { Vector < Integer > num = new Vector < Integer > ( ) ; while ( x != 0 ) { num . add ( x % 10 ) ; x /= 10 ; } Collections . reverse ( num ) ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) for ( int k = 0 ; k < 2 ; k ++ ) for ( int l = 0 ; l < 2 ; l ++ ) dp [ i ] [ j ] [ k ] [ l ] = - 1 ; return count ( 0 , 0 , 0 , 0 , num ) ; }
int bin ( int a , int b ) { int ans = ( ( fac [ a ] ) / ( fac [ a - b ] * fac [ b ] ) ) ; return ans ; }
int sumofn ( int n , int k ) { int p = 0 ; int num1 , temp ; int arr [ ] = new int [ 1000 ] ; for ( int j = 1 ; j <= k ; j ++ ) { if ( j == 1 ) { num1 = ( n * ( n + 1 ) ) / 2 ; arr [ p ++ ] = num1 ; temp = num1 ; } else { temp = ( ( int ) Math . pow ( n + 1 , j + 1 ) - 1 - n ) ; for ( int s = 1 ; s < j ; s ++ ) { temp = temp - ( arr [ j - s - 1 ] * bin ( j + 1 , s + 1 ) ) ; } temp = temp / ( j + 1 ) ; arr [ p ++ ] = temp ; } } temp = arr [ p - 1 ] ; return temp ; }
int findMinOperations ( String S ) { S = reverse ( S ) ; int n = S . length ( ) ; int dp [ ] [ ] = new int [ n + 1 ] [ 2 ] ; if ( S . charAt ( 0 ) == '0' ) { dp [ 0 ] [ 0 ] = 0 ; } else { dp [ 0 ] [ 0 ] = 1 ; } dp [ 0 ] [ 1 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( S . charAt ( i ) == '0' ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] = 1 + Math . min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] ) ; } else { dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 0 ] = 1 + Math . min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) ; } } return dp [ n - 1 ] [ 0 ] ; }
int solve ( int x ) { int ans = 0 , first = 0 , last , temp = x ; if ( x < 10 ) return x ; last = x % 10 ; while ( x != 0 ) { first = x % 10 ; x /= 10 ; } if ( first <= last ) ans = 9 + temp / 10 ; else ans = 8 + temp / 10 ; return ans ; }
int findMinimumCost ( int n , int x , int y ) { int dp [ ] = new int [ n + 1 ] ; dp [ 1 ] = x ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ( i & 1 ) != 0 ) { dp [ i ] = Math . min ( dp [ i - 1 ] + x , dp [ ( i + 1 ) / 2 ] + y + x ) ; } else { dp [ i ] = Math . min ( dp [ i - 1 ] + x , dp [ i / 2 ] + y ) ; } } return dp [ n ] ; }
int countWays ( int index , int cnt , int dp [ ] [ ] , int n , int m , int k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index ] [ cnt ] != - 1 ) return dp [ index ] [ cnt ] ; int ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index ] [ cnt ] = ans ; }
int findMinSteps ( int mat [ ] [ ] , int n , int m , int dp [ ] [ ] , boolean vis [ ] [ ] ) { if ( n == 0 || m == 0 || n == ( r - 1 ) || m == ( c - 1 ) ) { return 0 ; } if ( dp [ n ] [ m ] != - 1 ) return dp [ n ] [ m ] ; vis [ n ] [ m ] = true ; int ans1 , ans2 , ans3 , ans4 ; ans1 = ans2 = ans3 = ans4 = ( int ) 1e9 ; if ( mat [ n - 1 ] [ m ] == 0 ) { if ( ! vis [ n - 1 ] [ m ] ) ans1 = 1 + findMinSteps ( mat , n - 1 , m , dp , vis ) ; } if ( mat [ n ] [ m + 1 ] == 0 ) { if ( ! vis [ n ] [ m + 1 ] ) ans2 = 1 + findMinSteps ( mat , n , m + 1 , dp , vis ) ; } if ( mat [ n ] [ m - 1 ] == 0 ) { if ( ! vis [ n ] [ m - 1 ] ) ans3 = 1 + findMinSteps ( mat , n , m - 1 , dp , vis ) ; } if ( mat [ n + 1 ] [ m ] == 0 ) { if ( ! vis [ n + 1 ] [ m ] ) ans4 = 1 + findMinSteps ( mat , n + 1 , m , dp , vis ) ; } dp [ n ] [ m ] = Math . min ( ans1 , Math . min ( ans2 , Math . min ( ans3 , ans4 ) ) ) ; return dp [ n ] [ m ] ; }
int minimumSteps ( int mat [ ] [ ] , int n , int m ) { int twox = - 1 ; int twoy = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 2 ) { twox = i ; twoy = j ; break ; } } if ( twox != - 1 ) break ; } int dp [ ] [ ] = new int [ r ] [ r ] ; for ( int j = 0 ; j < r ; j ++ ) for ( int i = 0 ; i < r ; i ++ ) dp [ j ] [ i ] = - 1 ; boolean vis [ ] [ ] = new boolean [ r ] [ r ] ; for ( int j = 0 ; j < r ; j ++ ) for ( int i = 0 ; i < r ; i ++ ) vis [ j ] [ i ] = false ; int res = findMinSteps ( mat , twox , twoy , dp , vis ) ; if ( res >= 1e9 ) return - 1 ; else return res ; }
int nCr ( int n , int r ) { int ans = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; i ++ ) { ans *= ( n - i ) ; ans /= ( i + 1 ) ; } return ans ; }
int countDerangements ( int n ) { int der [ ] = new int [ n + 3 ] ; der [ 0 ] = 1 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
int countPermutations ( int n , int k ) { int ans = 0 ; for ( int i = n - k ; i <= n ; i ++ ) { int ways = nCr ( n , i ) ; ans += ( ways * countDerangements ( n - i ) ) ; } return ans ; }
int solve ( int [ ] [ ] dp , int wt , int K , int M , int used ) { if ( wt < 0 ) { return 0 ; } if ( wt == 0 ) { if ( used == 1 ) { return 1 ; } return 0 ; } if ( dp [ wt ] [ used ] != - 1 ) { return dp [ wt ] [ used ] ; } int ans = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( i >= M ) { ans += solve ( dp , wt - i , K , M , used 1 ) ; } else { ans += solve ( dp , wt - i , K , M , used ) ; } } return dp [ wt ] [ used ] = ans ; }
int squares ( int i ) { if ( ( i & 1 ) == 1 ) return i / 4 * 2 + 1 ; else return ( i - 1 ) / 4 * 2 + 2 ; }
long bishop_placements ( int n , int k ) { if ( k > 2 * n - 1 ) return 0 ; long [ ] [ ] dp = new long [ n * 2 ] [ k + 1 ] ; for ( int i = 0 ; i < n * 2 ; i ++ ) dp [ i ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; for ( int i = 2 ; i < n * 2 ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) dp [ i ] [ j ] = dp [ i - 2 ] [ j ] + dp [ i - 2 ] [ j - 1 ] * ( squares ( i ) - j + 1 ) ; } long ans = 0 ; for ( int i = 0 ; i <= k ; i ++ ) { ans += dp [ n * 2 - 1 ] [ i ] * dp [ n * 2 - 2 ] [ k - i ] ; } return ans ; }
int sumOddFibonacci ( int n ) { int Sum [ ] = new int [ n + 1 ] ; Sum [ 0 ] = 0 ; Sum [ 1 ] = 1 ; Sum [ 2 ] = 2 ; Sum [ 3 ] = 5 ; Sum [ 4 ] = 10 ; Sum [ 5 ] = 23 ; for ( int i = 6 ; i <= n ; i ++ ) { Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; } return Sum [ n ] ; }
int noOfAssignments ( String s , int n , int i , int c_x , int c_y ) { if ( F [ i ] [ c_x ] [ c_y ] != - 1 ) return F [ i ] [ c_x ] [ c_y ] ; if ( i == n ) { F [ i ] [ c_x ] [ c_y ] = ( c_x == 0 && c_y == 0 ) ? 1 : 0 ; return F [ i ] [ c_x ] [ c_y ] ; } if ( s . charAt ( i ) == '(' ) { F [ i ] [ c_x ] [ c_y ] = noOfAssignments ( s , n , i + 1 , c_x + 1 , c_y ) + noOfAssignments ( s , n , i + 1 , c_x , c_y + 1 ) ; return F [ i ] [ c_x ] [ c_y ] ; } F [ i ] [ c_x ] [ c_y ] = 0 ; if ( c_x != 0 ) F [ i ] [ c_x ] [ c_y ] += noOfAssignments ( s , n , i + 1 , c_x - 1 , c_y ) ; if ( c_y != 0 ) F [ i ] [ c_x ] [ c_y ] += noOfAssignments ( s , n , i + 1 , c_x , c_y - 1 ) ; return F [ i ] [ c_x ] [ c_y ] ; }
int noOfAssignments ( String S , int n , int i , int c_x ) { if ( F [ i ] [ c_x ] != - 1 ) { return F [ i ] [ c_x ] ; } if ( i == n ) { if ( c_x == 1 ) { F [ i ] [ c_x ] = 0 ; } else { F [ i ] [ c_x ] = 1 ; } return F [ i ] [ c_x ] ; } int c_y = C [ i ] - c_x ; if ( S . charAt ( i ) == '(' ) { F [ i ] [ c_x ] = noOfAssignments ( S , n , i + 1 , c_x + 1 ) + noOfAssignments ( S , n , i + 1 , c_x ) ; return F [ i ] [ c_x ] ; } F [ i ] [ c_x ] = 0 ; if ( c_x == 1 ) { F [ i ] [ c_x ] += noOfAssignments ( S , n , i + 1 , c_x - 1 ) ; } if ( c_y == 1 ) { F [ i ] [ c_x ] += noOfAssignments ( S , n , i + 1 , c_x ) ; } return F [ i ] [ c_x ] ; }
int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) { int sum = 0 ; if ( k == n ) return 0 ; if ( col == color [ k ] ) sum += Math . max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += Math . max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return sum ; }
int calculateEvenSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ 2 * n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = 0 ; for ( int i = 2 ; i <= 2 * n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum += fibo [ i ] ; } return sum ; }
int fib ( int n ) { if ( n == 0 ) { return 0 ; } if ( n == 1 n == 2 ) { return ( f [ n ] = 1 ) ; } if ( f [ n ] == 1 ) { return f [ n ] ; } int k = ( n % 2 == 1 ) ? ( n + 1 ) / 2 : n / 2 ; f [ n ] = ( n % 2 == 1 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; }
int calculateEvenSum ( int n ) { return ( fib ( 2 * n + 1 ) - 1 ) ; }
int find ( int index , int openbrk , int n , int adj [ ] [ ] ) { if ( openbrk < 0 ) return MAX_VAL ; if ( index == n ) { if ( openbrk == 0 ) { return 0 ; } return MAX_VAL ; } if ( dp [ index ] [ openbrk ] != - 1 ) return dp [ index ] [ openbrk ] ; dp [ index ] [ openbrk ] = Math . min ( adj [ index ] [ 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index ] [ 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) ; return dp [ index ] [ openbrk ] ; }
void gouldSequence ( int n ) { for ( int row_num = 1 ; row_num <= n ; row_num ++ ) { int count = 1 ; int c = 1 ; for ( int i = 1 ; i <= row_num ; i ++ ) { c = c * ( row_num - i ) / i ; if ( c % 2 == 1 ) count ++ ; } System . out . print ( count + " " ) ; } }
void gouldSequence ( ) { arr [ 0 ] = 1 ; int i = 1 ; int p = 1 ; while ( i <= MAX ) { int j = 0 ; while ( j < i ) { arr [ i + j ] = 2 * arr [ j ] ; j ++ ; } i = ( 1 << p ) ; p ++ ; } }
void printSequence ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
int minFallingPathSum ( int A [ ] [ ] ) { for ( int R = n - 2 ; R >= 0 ; -- R ) { for ( int C = 0 ; C < n ; ++ C ) { int best = A [ R + 1 ] [ C ] ; if ( C > 0 ) best = Math . min ( best , A [ R + 1 ] [ C - 1 ] ) ; if ( C + 1 < n ) best = Math . min ( best , A [ R + 1 ] [ C + 1 ] ) ; A [ R ] [ C ] = A [ R ] [ C ] + best ; } } int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; ++ i ) ans = Math . min ( ans , A [ 0 ] [ i ] ) ; return ans ; }
int maxPlus ( int [ ] [ ] arr ) { int ans = Integer . MIN_VALUE ; int [ ] [ ] left = new int [ N ] [ N ] ; int [ ] [ ] right = new int [ N ] [ N ] ; int [ ] [ ] up = new int [ N ] [ N ] ; int [ ] [ ] down = new int [ N ] [ N ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { left [ i ] [ j ] = Math . max ( 0 , ( ( j != 0 ) ? left [ i ] [ j - 1 ] : 0 ) ) + arr [ i ] [ j ] ; up [ i ] [ j ] = Math . max ( 0 , ( ( i != 0 ) ? up [ i - 1 ] [ j ] : 0 ) ) + arr [ i ] [ j ] ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { right [ i ] [ j ] = Math . max ( 0 , ( j + 1 == m ? 0 : right [ i ] [ j + 1 ] ) ) + arr [ i ] [ j ] ; down [ i ] [ j ] = Math . max ( 0 , ( i + 1 == n ? 0 : down [ i + 1 ] [ j ] ) ) + arr [ i ] [ j ] ; } } for ( int i = 1 ; i < n - 1 ; ++ i ) for ( int j = 1 ; j < m - 1 ; ++ j ) ans = Math . max ( ans , up [ i - 1 ] [ j ] + down [ i + 1 ] [ j ] + left [ i ] [ j - 1 ] + right [ i ] [ j + 1 ] + arr [ i ] [ j ] ) ; return ans ; }
long fun ( int marks [ ] , int n ) { long dp [ ] = new long [ n ] ; int temp ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } } else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; }
long getNumberOfWays ( long N , long [ ] Coins ) { long [ ] ways = new long [ ( int ) N + 1 ] ; ways [ 0 ] = 1 ; for ( int i = 0 ; i < Coins . length ; i ++ ) { for ( int j = 0 ; j < ways . length ; j ++ ) { if ( Coins [ i ] <= j ) { ways [ j ] += ways [ ( int ) ( j - Coins [ i ] ) ] ; } } } return ways [ ( int ) N ] ; }
int countStaircases ( int N ) { int [ ] [ ] memo = new int [ N + 5 ] [ N + 5 ] ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { memo [ i ] [ j ] = 0 ; } } memo [ 3 ] [ 2 ] = memo [ 4 ] [ 2 ] = 1 ; for ( int i = 5 ; i <= N ; i ++ ) { for ( int j = 2 ; j <= i ; j ++ ) { if ( j == 2 ) { memo [ i ] [ j ] = memo [ i - j ] [ j ] + 1 ; } else { memo [ i ] [ j ] = memo [ i - j ] [ j ] + memo [ i - j ] [ j - 1 ] ; } } } int answer = 0 ; for ( int i = 1 ; i <= N ; i ++ ) answer = answer + memo [ N ] [ i ] ; return answer ; }
long partitions ( int n ) { long p [ ] = new long [ n + 1 ] ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) { k *= - 1 ; } else { k = 1 - k ; } } } return p [ n ] ; }
int find ( int m , int n , int adj [ ] ) { int sweet [ ] = new int [ n + 1 ] ; int dp [ ] [ ] [ ] = new int [ n + 1 ] [ n + 1 ] [ n + 1 ] ; sweet [ 0 ] = 0 ; for ( int i = 1 ; i <= m ; ++ i ) sweet [ i ] = adj [ i - 1 ] ; for ( int i = 0 ; i <= m ; ++ i ) { for ( int k = 0 ; k <= n ; ++ k ) dp [ i ] [ 0 ] [ k ] = 0 ; for ( int k = 1 ; k <= n ; ++ k ) dp [ i ] [ k ] [ 0 ] = - 1 ; } for ( int i = 0 ; i <= m ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { for ( int k = 1 ; k <= n ; ++ k ) { dp [ i ] [ j ] [ k ] = - 1 ; if ( i > 0 && j >= k && sweet [ k ] > 0 && dp [ i - 1 ] [ j - k ] [ k ] != - 1 ) dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j - k ] [ k ] + sweet [ k ] ; if ( dp [ i ] [ j ] [ k ] == - 1 || ( dp [ i ] [ j ] [ k - 1 ] != - 1 && dp [ i ] [ j ] [ k ] > dp [ i ] [ j ] [ k - 1 ] ) ) dp [ i ] [ j ] [ k ] = dp [ i ] [ j ] [ k - 1 ] ; } } } if ( dp [ m ] [ n ] [ n ] == - 1 ) return 0 ; else return dp [ m ] [ n ] [ n ] ; }
int find_min_odd_cost ( int given [ ] [ ] , int m , int n ) { int floor [ ] [ ] = new int [ M ] [ N ] ; int min_odd_cost = 0 ; int i , j , temp ; for ( j = 0 ; j < n ; j ++ ) floor [ 0 ] [ j ] = given [ 0 ] [ j ] ; for ( i = 1 ; i < m ; i ++ ) for ( j = 0 ; j < n ; j ++ ) { if ( j == 0 ) { floor [ i ] [ j ] = given [ i ] [ j ] ; floor [ i ] [ j ] += Math . min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j + 1 ] ) ; } else if ( j == n - 1 ) { floor [ i ] [ j ] = given [ i ] [ j ] ; floor [ i ] [ j ] += Math . min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j - 1 ] ) ; } else { temp = Math . min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j - 1 ] ) ; temp = Math . min ( temp , floor [ i - 1 ] [ j + 1 ] ) ; floor [ i ] [ j ] = given [ i ] [ j ] + temp ; } } min_odd_cost = Integer . MAX_VALUE ; for ( j = 0 ; j < n ; j ++ ) { if ( floor [ n - 1 ] [ j ] % 2 == 1 ) { if ( min_odd_cost > floor [ n - 1 ] [ j ] ) min_odd_cost = floor [ n - 1 ] [ j ] ; } } if ( min_odd_cost == Integer . MIN_VALUE ) return - 1 ; return min_odd_cost ; }
int countPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; }
int countPaths ( int m , int n ) { int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i == 1 j == 1 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; }
int factorial ( int n ) { int res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
int countWays ( int m , int n ) { m = m - 1 ; n = n - 1 ; return factorial ( m + n ) / ( factorial ( m ) * factorial ( n ) ) ; }
int MatrixChainOrder ( int p [ ] , int n ) { int [ ] [ ] dp = new int [ n ] [ n ] ; for ( int i = 1 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ; for ( int L = 1 ; L < n - 1 ; L ++ ) for ( int i = 1 ; i < n - L ; i ++ ) dp [ i ] [ i + L ] = Math . min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 ] [ n - 1 ] ; }
int createPalindrome ( int input , int isOdd ) { int n = input ; int palin = input ; if ( isOdd % 2 == 1 ) { n /= 10 ; } while ( n > 0 ) { palin = palin * 10 + ( n % 10 ) ; n /= 10 ; } return palin ; }
Vector < Integer > generatePalindromes ( int N ) { Vector < Integer > palindromes = new Vector < > ( ) ; int number ; for ( int j = 0 ; j < 2 ; j ++ ) { int i = 1 ; while ( ( number = createPalindrome ( i ++ , j ) ) <= N ) { palindromes . add ( number ) ; } } return palindromes ; }
int minimumNoOfPalindromes ( int N ) { String a = String . valueOf ( N ) ; String b = String . valueOf ( N ) ; b = reverse ( b ) ; if ( a . equals ( b ) ) { return 1 ; } Vector < Integer > palindromes = generatePalindromes ( N ) ; Collections . sort ( palindromes ) ; int l = 0 , r = palindromes . size ( ) - 1 ; while ( l < r ) { if ( palindromes . get ( l ) + palindromes . get ( r ) == N ) { return 2 ; } else if ( palindromes . get ( l ) + palindromes . get ( r ) < N ) { ++ l ; } else { -- r ; } } return 3 ; }
int costOfString ( String str ) { int cost = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) cost += ( str . charAt ( i ) - 48 ) ; return cost ; }
int lds ( Integer arr [ ] , int n ) { Integer lds [ ] = new Integer [ n ] ; lds [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { lds [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) if ( lds [ j ] != 0 && arr [ i ] % arr [ j ] == 0 ) lds [ i ] = Math . max ( lds [ i ] , lds [ j ] + 1 ) ; } int max = ( int ) Collections . max ( Arrays . asList ( lds ) ) ; return max ; }
int find ( int start , String adj , int n , int dp [ ] ) { if ( start == n ) return 0 ; if ( dp [ start ] != - 1 ) return dp [ start ] ; dp [ start ] = 0 ; int one = 0 , zero = 0 , k ; for ( k = start ; k < n ; k ++ ) { if ( adj . charAt ( k ) == '1' ) one ++ ; else zero ++ ; if ( one > zero ) dp [ start ] = Math . max ( dp [ start ] , find ( k + 1 , adj , n , dp ) + k - start + 1 ) ; else dp [ start ] = Math . max ( dp [ start ] , find ( k + 1 , adj , n , dp ) ) ; } return dp [ start ] ; }
boolean isVowel ( char ch ) { if ( ch == 'a' ch == 'e' ch == 'i' ch == 'o' ch == 'u' ) return true ; return false ; }
int lcs ( String X , String Y , int m , int n ) { int L [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) && isVowel ( X . charAt ( i - 1 ) ) ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; }
long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
void makePairs ( Vector < Integer > pairs , int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { int sumOfDigits = 0 , k = i ; while ( k > 0 ) { sumOfDigits += k % 10 ; k /= 10 ; } if ( sumOfDigits <= 162 ) pairs . add ( sumOfDigits ) ; } }
int countCoPrime ( int a , int b ) { Vector < Integer > pairs = new Vector < Integer > ( ) ; makePairs ( pairs , a , b ) ; int count = 0 ; for ( int i = 0 ; i < pairs . size ( ) ; i ++ ) for ( int j = i + 1 ; j < pairs . size ( ) ; j ++ ) if ( GCD ( pairs . get ( i ) , pairs . get ( j ) ) == 1 ) count ++ ; return count ; }
long recursive ( long idx , long sum , long tight , String st , long [ ] [ ] [ ] dp , long num ) { if ( idx == num ) { return sum == 0 ? 1 : 0 ; } if ( dp [ ( int ) idx ] [ ( int ) tight ] [ ( int ) sum ] != - 1 ) return dp [ ( int ) idx ] [ ( int ) tight ] [ ( int ) sum ] ; long newTight ; long ans = 0 ; long d ; for ( d = 0 ; d < 10 ; ++ d ) { newTight = 0 ; if ( tight == 1 && st . charAt ( ( int ) idx ) - '0' < d ) continue ; if ( tight == 1 && st . charAt ( ( int ) idx ) - '0' == d ) newTight = 1 ; if ( sum >= d ) ans += recursive ( idx + 1 , sum - d , ( int ) newTight , st , dp , num ) ; } return dp [ ( int ) idx ] [ ( int ) tight ] [ ( int ) sum ] = ans ; }
ArrayList < Long > formArray ( long N ) { long [ ] [ ] [ ] dp = new long [ 20 ] [ 2 ] [ 166 ] ; for ( long [ ] [ ] innerRow : dp ) { for ( long [ ] innerInnerRow : innerRow ) { Arrays . fill ( innerInnerRow , - 1 ) ; } } String st = String . valueOf ( N ) ; long num = st . length ( ) ; ArrayList < Long > arr = new ArrayList < Long > ( ) ; for ( int i = 1 ; i <= 162 ; ++ i ) { arr . add ( recursive ( 0 , i , 1 , st , dp , num ) ) ; } return arr ; }
long findPair ( long a , long b ) { ArrayList < Long > arr_smaller = formArray ( a - 1 ) ; ArrayList < Long > arr_greater = formArray ( b ) ; for ( int i = 0 ; i < arr_greater . size ( ) ; ++ i ) { arr_greater . set ( i , arr_greater . get ( i ) - arr_smaller . get ( i ) ) ; } long ans = 0 ; for ( int i = 1 ; i <= 162 ; ++ i ) { for ( int j = i + 1 ; j <= 162 ; ++ j ) { if ( gcd ( i , j ) == 1 ) { ans = ( ans + arr_greater . get ( i - 1 ) * arr_greater . get ( j - 1 ) ) ; } } } return ans ; }
int printTetraRec ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return 1 ; if ( n == 3 ) return 2 ; else return printTetraRec ( n - 1 ) + printTetraRec ( n - 2 ) + printTetraRec ( n - 3 ) + printTetraRec ( n - 4 ) ; }
void printTetra ( int n ) { int [ ] dp = new int [ n + 5 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; System . out . print ( dp [ n ] ) ; }
void printTetra ( int n ) { if ( n < 0 ) return ; int first = 0 , second = 1 ; int third = 1 , fourth = 2 ; int curr = 0 ; if ( n == 0 ) System . out . print ( first ) ; else if ( n == 1 n == 2 ) System . out . print ( second ) ; else if ( n == 3 ) System . out . print ( fourth ) ; else { for ( int i = 4 ; i <= n ; i ++ ) { curr = first + second + third + fourth ; first = second ; second = third ; third = fourth ; fourth = curr ; } System . out . print ( curr ) ; } }
boolean check ( int n ) { Vector < Integer > v = new Vector < > ( ) ; v = factors ( n ) ; Collections . sort ( v ) ; int r = v . size ( ) ; boolean [ ] [ ] subset = new boolean [ r + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= r ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= r ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j < v . elementAt ( i - 1 ) ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; else { subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - v . elementAt ( i - 1 ) ] ; } } } if ( ( subset [ r ] [ n ] ) == false ) return false ; else return true ; }
int maxSum1 ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; int maxi = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { dp [ i ] = arr [ i ] ; if ( maxi < arr [ i ] ) maxi = arr [ i ] ; } for ( int i = 2 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < i - 1 ; j ++ ) { if ( dp [ i ] < dp [ j ] + arr [ i ] ) { dp [ i ] = dp [ j ] + arr [ i ] ; if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } } return maxi ; }
int maxSum2 ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; int maxi = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; if ( maxi < arr [ i ] ) maxi = arr [ i ] ; } for ( int i = 3 ; i < n ; i ++ ) { for ( int j = 1 ; j < i - 1 ; j ++ ) { if ( dp [ i ] < arr [ i ] + dp [ j ] ) { dp [ i ] = arr [ i ] + dp [ j ] ; if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } } return maxi ; }
int findMaxSum ( int arr [ ] , int n ) { int t = Math . max ( maxSum1 ( arr , n ) , maxSum2 ( arr , n ) ) ; return t ; }
int solve ( int N , int K ) { int [ ] combo ; combo = new int [ 50 ] ; combo [ 0 ] = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { if ( j >= i ) { combo [ j ] += combo [ j - i ] ; } } } return combo [ N ] ; }
void fibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i < 43 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; }
int rec ( int x , int y , int last ) { if ( y == 0 ) { if ( x == 0 ) return 1 ; return 0 ; } int sum = 0 ; for ( int i = last ; i >= 0 && fib [ i ] * y >= x ; i -- ) { if ( fib [ i ] > x ) continue ; sum += rec ( x - fib [ i ] , y - 1 , i ) ; } return sum ; }
double MinimumPrimes ( int n ) { double [ ] dp ; dp = new double [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] = 1e9 ; dp [ 0 ] = dp [ 2 ] = dp [ 3 ] = dp [ 5 ] = dp [ 7 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( check ( i , 2 ) ) dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - 2 ] ) ; if ( check ( i , 3 ) ) dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - 3 ] ) ; if ( check ( i , 5 ) ) dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - 5 ] ) ; if ( check ( i , 7 ) ) dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - 7 ] ) ; } if ( dp [ n ] == ( 1e9 ) ) return - 1 ; else return dp [ n ] ; }
int minimumCost ( int cost [ ] , int n ) { int dp [ ] = new int [ n ] ; if ( n == 1 ) return cost [ 0 ] ; dp [ 0 ] = cost [ 0 ] ; dp [ 1 ] = cost [ 1 ] ; for ( int i = 2 ; i < n ; i ++ ) { dp [ i ] = Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] ; } return Math . min ( dp [ n - 2 ] , dp [ n - 1 ] ) ; }
int minimumCost ( int cost [ ] , int n ) { int dp1 = 0 , dp2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dp0 = cost [ i ] + Math . min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . min ( dp1 , dp2 ) ; }
void subsetSum ( int arr [ ] , int n , int maxSum ) { boolean dp [ ] = new boolean [ maxSum + 1 ] ; Arrays . fill ( dp , false ) ; dp [ arr [ 0 ] ] = true ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = maxSum ; j >= 1 ; j -- ) { if ( arr [ i ] <= j ) { if ( arr [ i ] == j || dp [ j ] || dp [ ( j - arr [ i ] ) ] ) dp [ j ] = true ; else dp [ j ] = false ; } } } System . out . print ( 0 + " " ) ; for ( int j = 0 ; j <= maxSum ; j ++ ) { if ( dp [ j ] == true ) System . out . print ( j + " " ) ; } System . out . print ( "21" ) ; }
void printDistinct ( int a [ ] , int n ) { int maxSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxSum += a [ i ] ; } subsetSum ( a , n , maxSum ) ; }
int maxCost ( int a [ ] [ ] , int m , int n , int dp [ ] [ ] ) { if ( n < 0 m < 0 ) return ( int ) - 1e9 ; else if ( m == 0 && n == 0 ) return 0 ; else if ( dp [ m ] [ n ] != - 1 ) return dp [ m ] [ n ] ; else { int num = m + n ; if ( ( num & ( num - 1 ) ) == 0 ) return dp [ m ] [ n ] = a [ m ] [ n ] + maxCost ( a , m - 1 , n - 1 , dp ) ; else return dp [ m ] [ n ] = ( a [ m ] [ n ] + Math . max ( maxCost ( a , m - 1 , n , dp ) , maxCost ( a , m , n - 1 , dp ) ) ) ; } }
int answer ( int a [ ] [ ] , int n ) { int dp [ ] [ ] = new int [ size ] [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = 0 ; j < size ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return maxCost ( a , n - 1 , n - 1 , dp ) ; }
int editDistanceWith2Ops ( String X , String Y ) { int m = X . length ( ) , n = Y . length ( ) ; int L [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) { L [ i ] [ j ] = 0 ; } else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; } else { L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } } int lcs = L [ m ] [ n ] ; return ( m - lcs ) + ( n - lcs ) ; }
int lcs ( String X , String Y , int m , int n ) { if ( m == 0 n == 0 ) { return 0 ; } if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) { return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; } else { return Math . max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; } }
int lcs ( String X , String Y , int m , int n , int dp [ ] [ ] ) { if ( m == 0 n == 0 ) { return 0 ; } if ( dp [ m - 1 ] [ n - 1 ] != - 1 ) { return dp [ m - 1 ] [ n - 1 ] ; } if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) { dp [ m - 1 ] [ n - 1 ] = 1 + lcs ( X , Y , m - 1 , n - 1 , dp ) ; return dp [ m - 1 ] [ n - 1 ] ; } else { dp [ m - 1 ] [ n - 1 ] = Math . max ( lcs ( X , Y , m , n - 1 , dp ) , lcs ( X , Y , m - 1 , n , dp ) ) ; return dp [ m - 1 ] [ n - 1 ] ; } }
int countPaths ( int n ) { int zB = 1 ; int zADC = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int nzB = zADC * 3 ; int nzADC = ( zADC * 2 + zB ) ; zB = nzB ; zADC = nzADC ; } return zB ; }
int sumSubSequence ( int [ ] arr , int len , int m ) { int sum = 0 ; for ( int x : arr ) { sum += x ; } int [ ] [ ] dp = new int [ len + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= len ; i ++ ) dp [ i ] [ 0 ] ++ ; for ( int i = 1 ; i <= len ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] ++ ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] > 0 ) { dp [ i ] [ j ] ++ ; dp [ i ] [ j + arr [ i - 1 ] ] ++ ; } } } int count = 0 ; for ( int j = 1 ; j <= sum ; j ++ ) if ( dp [ len ] [ j ] > 0 ) if ( j % m == 0 ) count += dp [ len ] [ j ] ; return count ; }
int totalWays ( int N , int M , int X ) { int dp [ ] [ ] = new int [ N + 1 ] [ 2 ] ; if ( X == 1 ) { dp [ 0 ] [ 0 ] = 1 ; } else { dp [ 0 ] [ 1 ] = 0 ; } if ( X == 1 ) { dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = M - 1 ; } else { dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = ( M - 2 ) ; } for ( int i = 2 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) ; } return dp [ N - 1 ] [ 0 ] ; }
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
int fib ( int n ) { if ( n <= 1 ) return n ; if ( term [ n ] != 0 ) return term [ n ] ; else { term [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ; return term [ n ] ; } }
int lcs ( String X , String Y , int m , int n ) { if ( m == 0 n == 0 ) return 0 ; if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; }
int lcs ( String X , String Y , int m , int n ) { if ( m == 0 n == 0 ) return 0 ; if ( arr [ m - 1 ] [ n - 1 ] != - 1 ) return arr [ m - 1 ] [ n - 1 ] ; if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) { arr [ m - 1 ] [ n - 1 ] = 1 + lcs ( X , Y , m - 1 , n - 1 ) ; return arr [ m - 1 ] [ n - 1 ] ; } else { arr [ m - 1 ] [ n - 1 ] = max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; return arr [ m - 1 ] [ n - 1 ] ; } }
int lcs ( String X , String Y , String Z , int m , int n , int o ) { if ( m == 0 n == 0 o == 0 ) return 0 ; if ( arr [ m - 1 ] [ n - 1 ] [ o - 1 ] != - 1 ) return arr [ m - 1 ] [ n - 1 ] [ o - 1 ] ; if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) && Y . charAt ( n - 1 ) == Z . charAt ( o - 1 ) ) { arr [ m - 1 ] [ n - 1 ] [ o - 1 ] = 1 + lcs ( X , Y , Z , m - 1 , n - 1 , o - 1 ) ; return arr [ m - 1 ] [ n - 1 ] [ o - 1 ] ; } else { arr [ m - 1 ] [ n - 1 ] [ o - 1 ] = max ( lcs ( X , Y , Z , m , n - 1 , o ) , max ( lcs ( X , Y , Z , m - 1 , n , o ) , lcs ( X , Y , Z , m , n , o - 1 ) ) ) ; return arr [ m - 1 ] [ n - 1 ] [ o - 1 ] ; } }
int minStepsNeeded ( int k , int d1 , int d2 , int x ) { int gcd = __gcd ( d1 , d2 ) ; if ( ( k - x ) % gcd != 0 ) return - 1 ; Queue < pair > q = new LinkedList < > ( ) ; HashSet < Integer > visited = new HashSet < > ( ) ; q . add ( new pair ( k , 0 ) ) ; visited . add ( k ) ; while ( ! q . isEmpty ( ) ) { int s = q . peek ( ) . first ; int stp = q . peek ( ) . second ; if ( s == x ) return stp ; q . remove ( ) ; if ( ! visited . contains ( s + d1 ) ) { q . add ( new pair ( s + d1 , stp + 1 ) ) ; visited . add ( s + d1 ) ; } if ( visited . contains ( s + d2 ) ) { q . add ( new pair ( s + d2 , stp + 1 ) ) ; visited . add ( s + d2 ) ; } if ( ! visited . contains ( s - d1 ) ) { q . add ( new pair ( s - d1 , stp + 1 ) ) ; visited . add ( s - d1 ) ; } if ( ! visited . contains ( s - d2 ) ) { q . add ( new pair ( s - d2 , stp + 1 ) ) ; visited . add ( s - d2 ) ; } } return Integer . MIN_VALUE ; }
int lds ( int arr [ ] , int n ) { int lds [ ] = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] < arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lds [ i ] ) max = lds [ i ] ; return max ; }
int minimumNumberOfDigits ( int a , int b ) { if ( a > b a < 0 b < 0 a > 900 b > 8100 ) { return - 1 ; } if ( a == 0 && b == 0 ) { return 0 ; } if ( dp [ a ] [ b ] != - 1 ) { return dp [ a ] [ b ] ; } int ans = 101 ; for ( int i = 9 ; i >= 1 ; i -- ) { int k = minimumNumberOfDigits ( a - i , b - ( i * i ) ) ; if ( k != - 1 ) { ans = Math . min ( ans , k + 1 ) ; } } return dp [ a ] [ b ] = ans ; }
void printSmallestNumber ( int a , int b ) { for ( int [ ] row : dp ) { Arrays . fill ( row , - 1 ) ; } dp [ 0 ] [ 0 ] = 0 ; int k = minimumNumberOfDigits ( a , b ) ; if ( k == - 1 k > 100 ) { System . out . println ( "-1" ) ; } else { while ( a > 0 && b > 0 ) { for ( int i = 1 ; i <= 9 ; i ++ ) { if ( a >= i && b >= i * i && 1 + dp [ a - i ] [ b - i * i ] == dp [ a ] [ b ] ) { System . out . print ( i ) ; a -= i ; b -= i * i ; break ; } } } } }
void binomialCoeff ( int C [ ] , int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , n ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } }
int sumOfproduct ( int n ) { int sum = 0 ; int C [ ] = new int [ MAX ] ; binomialCoeff ( C , n ) ; for ( int i = 0 ; i <= n ; i ++ ) sum += C [ i ] * C [ i + 1 ] ; return sum ; }
int binomialCoeff ( int n , int k ) { int C [ ] = new int [ k + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
int sumOfproduct ( int n ) { return binomialCoeff ( 2 * n , n - 1 ) ; }
int check ( int i , int sum , int n , int k , int a [ ] , int dp [ ] [ ] ) { if ( sum <= 0 ) { return 0 ; } if ( i >= n ) { if ( sum == k ) { return 1 ; } return 0 ; } if ( dp [ i ] [ sum ] != - 1 ) { return dp [ i ] [ sum ] ; } dp [ i ] [ sum ] = check ( i + 1 , sum - 2 * a [ i ] , n , k , a , dp ) | check ( i + 1 , sum , n , k , a , dp ) ; dp [ i ] [ sum ] = check ( i + 1 , sum - ( i + 1 ) , n , k , a , dp ) | dp [ i ] [ sum ] ; dp [ i ] [ sum ] = check ( i + 1 , sum + i + 1 , n , k , a , dp ) | dp [ i ] [ sum ] ; return dp [ i ] [ sum ] ; }
int wrapper ( int n , int k , int a [ ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return check ( 0 , sum , n , k , a , dp ) ; }
boolean isPowerOf ( long val , int base ) { while ( val > 1 ) { if ( val % base != 0 ) val /= base ; } return true ; }
int numberOfPartitions ( String binaryNo ) { int i , j , n = binaryNo . length ( ) ; long val ; int dp [ ] = new int [ n ] ; dp [ n - 1 ] = ( ( ( binaryNo . charAt ( n - 1 ) - '0' ) == 0 ) ? - 1 : 1 ) ; for ( i = n - 2 ; i >= 0 ; i -- ) { val = 0 ; if ( ( binaryNo . charAt ( i ) - '0' ) == 0 ) { dp [ i ] = - 1 ; continue ; } dp [ i ] = Integer . MAX_VALUE ; for ( j = i ; j < n ; j ++ ) { val = ( val * 2 ) + ( long ) ( binaryNo . charAt ( j ) - '0' ) ; if ( isPowerOf ( val , 4 ) || isPowerOf ( val , 6 ) ) { if ( j == n - 1 ) { dp [ i ] = 1 ; } else { if ( dp [ j + 1 ] != - 1 ) dp [ i ] = Math . min ( dp [ i ] , dp [ j + 1 ] + 1 ) ; } } } if ( dp [ i ] == Integer . MAX_VALUE ) dp [ i ] = - 1 ; } return dp [ 0 ] ; }
void binomialCoeff ( int n , int C [ ] ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , n ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } }
int summation ( int n ) { int C [ ] = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) C [ i ] = 0 ; binomialCoeff ( n , C ) ; int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += ( i * C [ i ] ) ; return sum ; }
int summation ( int n ) { return n << ( n - 1 ) ; }
int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
int countArray ( int N , int K ) { return binomialCoeff ( K - 1 , N - 1 ) ; }
int count ( int n , int c , int a [ ] , int b [ ] ) { int need [ ] = new int [ N ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i + n ] = a [ i ] ; b [ i + n ] = b [ i ] ; } int s = 0 ; int tank = 0 ; for ( int i = 0 ; i < 2 * n ; i ++ ) { tank += a [ i ] ; tank = Math . min ( tank , c ) ; tank -= b [ i ] ; if ( tank < 0 ) { tank = 0 ; s = i + 1 ; } } if ( s >= n ) return 0 ; int ans = 1 ; need [ s + n ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int id = s + n - i ; need [ id ] = Math . max ( 0 , need [ id + 1 ] + b [ id ] - Math . min ( a [ id ] , c ) ) ; if ( need [ id ] == 0 ) ans ++ ; } return ans ; }
void fib ( int n ) { int a = 0 , b = 1 , c ; if ( n >= 0 ) System . out . print ( a + " " ) ; if ( n >= 1 ) System . out . print ( b + " " ) ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; System . out . print ( c + " " ) ; a = b ; b = c ; } }
int countDigits ( int n ) { int count = 0 ; while ( n > 0 ) { count += 1 ; n /= 10 ; } return count ; }
int findCount ( int L , int R ) { int count = 0 ; int countDigitsL = countDigits ( L ) ; int countDigitsR = countDigits ( R ) ; int firstDigitL = ( L / ( int ) Math . pow ( 10 , countDigitsL - 1 ) ) ; int firstDigitR = ( R / ( int ) Math . pow ( 10 , countDigitsR - 1 ) ) ; if ( countDigitsL < countDigitsR ) { count += ( 9 * ( countDigitsR - countDigitsL - 1 ) ) ; if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) count += ( 9 - firstDigitL + 1 ) ; else count += ( 9 - firstDigitL ) ; if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) count += firstDigitR ; else count += ( firstDigitR - 1 ) ; } else { if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) count += ( 9 - firstDigitL + 1 ) ; else count += ( 9 - firstDigitL ) ; if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) count -= ( 9 - firstDigitR ) ; else count -= ( 9 - firstDigitR + 1 ) ; } return count ; }
double score ( int n , Vector < Integer > A , int k ) { if ( memo [ n ] [ k ] > 0 ) return memo [ n ] [ k ] ; double sum = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { sum += A . elementAt ( i ) ; memo [ n ] [ k ] = Math . max ( memo [ n ] [ k ] , score ( i , A , k - 1 ) + sum / ( n - i ) ) ; } return memo [ n ] [ k ] ; }
int pre_compute ( int a [ ] , int n , int index , int k ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ; else dp [ 0 ] [ i ] = a [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) { if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } return dp [ index ] [ k ] ; }
int gen ( int n ) { int [ ] S = new int [ n + 1 ] ; S [ 0 ] = 0 ; if ( n != 0 ) S [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) S [ i ] = 4 * S [ i / 2 ] ; else S [ i ] = 4 * S [ i / 2 ] + 1 ; } return S [ n ] ; }
void moserDeBruijn ( int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( gen ( i ) + " " ) ; }
int LCSubStr ( String X , String Y ) { int m = X . length ( ) ; int n = Y . length ( ) ; int result = 0 ; int [ ] [ ] len = new int [ 2 ] [ n ] ; int currRow = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 j == 0 ) { len [ currRow ] [ j ] = 0 ; } else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { len [ currRow ] [ j ] = len [ ( 1 - currRow ) ] [ ( j - 1 ) ] + 1 ; result = Math . max ( result , len [ currRow ] [ j ] ) ; } else { len [ currRow ] [ j ] = 0 ; } } currRow = 1 - currRow ; } return result ; }
boolean isPartitionPoss ( Integer [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; return findSets ( arr , n , 0 , 0 , 0 ) ; }
void func ( int n , int m , int [ ] A ) { Vector < Integer > ModArray = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) ModArray . add ( 0 ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ModArray . set ( i , A [ i ] % m ) ; sum += ( ( int ) ModArray . get ( i ) ) ; } sum = sum % m ; if ( sum % m == 0 ) { System . out . println ( "True" ) ; return ; } if ( sum % 2 != 0 ) { System . out . println ( "False" ) ; } else { ModArray . remove ( 0 ) ; int i = 0 ; int j = ModArray . size ( ) - 1 ; Collections . sort ( ModArray ) ; sum = sum / 2 ; int i1 , i2 ; while ( i <= j ) { int s = ( int ) ModArray . get ( i ) + ( int ) ModArray . get ( j ) ; if ( s == sum ) { i1 = i ; i2 = j ; System . out . println ( "True" ) ; break ; } else if ( s > sum ) j -- ; else i ++ ; } } }
void dfs1 ( ArrayList < ArrayList < Integer > > v , int u , int parent ) { in [ u ] = 0 ; for ( int j = 0 ; j < v . get ( u ) . size ( ) ; j ++ ) { int child = v . get ( u ) . get ( j ) ; if ( child == parent ) continue ; dfs1 ( v , child , u ) ; in [ u ] = Math . max ( in [ u ] , 1 + in [ child ] ) ; } }
void dfs2 ( ArrayList < ArrayList < Integer > > v , int u , int parent ) { int mx1 = - 1 , mx2 = - 1 ; for ( int j = 0 ; j < v . get ( u ) . size ( ) ; j ++ ) { int child = v . get ( u ) . get ( j ) ; if ( child == parent ) continue ; if ( in [ child ] >= mx1 ) { mx2 = mx1 ; mx1 = in [ child ] ; } else if ( in [ child ] > mx2 ) mx2 = in [ child ] ; } for ( int j = 0 ; j < v . get ( u ) . size ( ) ; j ++ ) { int child = v . get ( u ) . get ( j ) ; if ( child == parent ) continue ; int longest = mx1 ; if ( mx1 == in [ child ] ) longest = mx2 ; out [ child ] = 1 + Math . max ( out [ u ] , 1 + longest ) ; dfs2 ( v , child , u ) ; } }
void printGolomb ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( findGolomb ( i ) + " " ) ; }
void dfs ( int [ ] a , Vector < Integer > [ ] v , int u , int parent ) { dp [ u ] = a [ u - 1 ] ; int maximum = 0 ; for ( int child : v [ u ] ) { if ( child == parent ) continue ; dfs ( a , v , child , u ) ; maximum = Math . max ( maximum , dp [ child ] ) ; } dp [ u ] += maximum ; }
int maximumValue ( int [ ] a , Vector < Integer > [ ] v ) { dfs ( a , v , 1 , 0 ) ; return dp [ 1 ] ; }
int countRemovals ( int a [ ] , int i , int j , int k ) { if ( i >= j ) return 0 ; else if ( ( a [ j ] - a [ i ] ) <= k ) return 0 ; else if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; else if ( ( a [ j ] - a [ i ] ) > k ) { dp [ i ] [ j ] = 1 + Math . min ( countRemovals ( a , i + 1 , j , k ) , countRemovals ( a , i , j - 1 , k ) ) ; } return dp [ i ] [ j ] ; }
int removals ( int a [ ] , int n , int k ) { Arrays . sort ( a ) ; for ( int [ ] rows : dp ) Arrays . fill ( rows , - 1 ) ; if ( n == 1 ) return 0 ; else return countRemovals ( a , 0 , n - 1 , k ) ; }
int removals ( int arr [ ] , int n , int k ) { int i , j , ans = n - 1 ; Arrays . sort ( arr ) ; for ( i = 0 ; i < n ; i ++ ) { j = findInd ( arr [ i ] , i , n , k , arr ) ; if ( j != - 1 ) { ans = Math . min ( ans , n - ( j - i + 1 ) ) ; } } return ans ; }
int removals ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int dp [ ] = new int [ n ] ; Arrays . fill ( dp , - 1 ) ; int ans = n - 1 ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = i ; int j = dp [ i - 1 ] ; while ( j != i && arr [ i ] - arr [ j ] > k ) { j ++ ; } dp [ i ] = Integer . min ( dp [ i ] , j ) ; ans = Integer . min ( ans , ( n - ( i - j + 1 ) ) ) ; } return ans ; }
int maximumSegments ( int n , int a , int b , int c ) { int dp [ ] = new int [ n + 10 ] ; Arrays . fill ( dp , - 1 ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ; dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ; dp [ i + c ] = Math . max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }
void postfix ( int a [ ] , int n ) { for ( int i = n - 1 ; i > 0 ; i -- ) { a [ i - 1 ] = a [ i - 1 ] + a [ i ] ; } }
void modify ( int a [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { a [ i - 1 ] = i * a [ i ] ; } }
void sequence ( int n ) { int f [ ] = new int [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; System . out . print ( f [ 1 ] + " " + f [ 2 ] + " " ) ; for ( int i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; System . out . print ( f [ i ] + " " ) ; } }
long sum ( int a [ ] , int i , int j ) { long ans = 0 ; for ( int m = i ; m <= j ; m ++ ) ans = ( ans + a [ m ] ) % 100 ; return ans ; }
long solve ( int a [ ] , int i , int j ) { if ( i == j ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; dp [ i ] [ j ] = 100000000 ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , ( solve ( a , i , k ) + solve ( a , k + 1 , j ) + ( sum ( a , i , k ) * sum ( a , k + 1 , j ) ) ) ) ; } return dp [ i ] [ j ] ; }
void initialize ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = - 1 ; }
void reverseFibonacci ( int n ) { int a [ ] = new int [ n ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { System . out . print ( a [ i ] + " " ) ; } }
int longestSubsequenceCommonSegment ( int k , String s1 , String s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; int lcs [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; int cnt [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { lcs [ i ] [ j ] = Math . max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) ; if ( s1 . charAt ( i - 1 ) == s2 . charAt ( j - 1 ) ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; if ( cnt [ i ] [ j ] >= k ) { for ( int a = k ; a <= cnt [ i ] [ j ] ; a ++ ) lcs [ i ] [ j ] = Math . max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) ; } } } return lcs [ n ] [ m ] ; }
long arrangeBraces ( int n , int pos [ ] , int k ) { boolean h [ ] = new boolean [ N ] ; int dp [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < k ; i ++ ) { h [ pos [ i ] ] = true ; } dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { for ( int j = 0 ; j <= 2 * n ; j ++ ) { if ( h [ i ] ) { if ( j != 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 0 ; } } else if ( j != 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } } } return dp [ 2 * n ] [ 0 ] ; }
boolean check ( String s1 , String s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; boolean dp [ ] [ ] = new boolean [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = false ; } } dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { for ( int j = 0 ; j <= s2 . length ( ) ; j ++ ) { if ( dp [ i ] [ j ] ) { if ( j < s2 . length ( ) && ( Character . toUpperCase ( s1 . charAt ( i ) ) == s2 . charAt ( j ) ) ) dp [ i + 1 ] [ j + 1 ] = true ; if ( ! Character . isUpperCase ( s1 . charAt ( i ) ) ) dp [ i + 1 ] [ j ] = true ; } } } return ( dp [ n ] [ m ] ) ; }
int findLength ( String str , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_sum += ( str . charAt ( i ) == '0' ? 1 : - 1 ) ; if ( current_sum < 0 ) current_sum = 0 ; max_sum = Math . max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; }
float find_prob ( int N , float P ) { double dp [ ] = new double [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return ( ( float ) ( dp [ N ] ) ) ; }
int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = 0 ; int INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int chordCnt ( int A ) { int n = 2 * A ; int [ ] dpArray = new int [ n + 1 ] ; dpArray [ 0 ] = 1 ; dpArray [ 2 ] = 1 ; for ( int i = 4 ; i <= n ; i += 2 ) { for ( int j = 0 ; j < i - 1 ; j += 2 ) { dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) ; } } return dpArray [ n ] ; }
int maximumSumSubarray ( int arr [ ] , int n ) { int min_prefix_sum = 0 ; int res = Integer . MIN_VALUE ; int prefix_sum [ ] = new int [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { res = Math . max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = Math . min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; }
boolean isPath ( int [ ] [ ] arr ) { int [ ] [ ] dir = { { 0 , 1 } , { 0 , - 1 } , { 1 , 0 } , { - 1 , 0 } } ; Queue < pair > q = new LinkedList < > ( ) ; q . add ( new pair ( 0 , 0 ) ) ; while ( q . size ( ) > 0 ) { pair p = ( q . peek ( ) ) ; q . remove ( ) ; arr [ p . Item1 ] [ p . Item2 ] = - 1 ; if ( p == new pair ( row - 1 , col - 1 ) ) return true ; for ( int i = 0 ; i < 4 ; i ++ ) { int a = p . Item1 + dir [ i ] [ 0 ] ; int b = p . Item2 + dir [ i ] [ 1 ] ; if ( a >= 0 && b >= 0 && a < row && b < col && arr [ a ] [ b ] != - 1 ) { q . add ( new pair ( a , b ) ) ; } } } return false ; }
boolean isPath ( int arr [ ] [ ] ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) if ( arr [ 0 ] [ i ] != - 1 ) arr [ 0 ] [ i ] = arr [ 0 ] [ i - 1 ] ; for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ j ] [ 0 ] != - 1 ) arr [ j ] [ 0 ] = arr [ j - 1 ] [ 0 ] ; for ( int i = 1 ; i < 5 ; i ++ ) for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = Math . max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) ; }
int Jacobsthal ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + 2 * dp [ i - 2 ] ; return dp [ n ] ; }
int Jacobsthal_Lucas ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 2 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + 2 * dp [ i - 2 ] ; return dp [ n ] ; }
int findStep ( int n ) { if ( n == 1 n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; }
int countWays ( int n ) { int [ ] res = new int [ n + 1 ] ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; }
int countWays ( int n ) { int a = 1 , b = 2 , c = 4 ; int d = 0 ; if ( n == 0 n == 1 n == 2 ) return n ; if ( n == 3 ) return c ; for ( int i = 4 ; i <= n ; i ++ ) { d = c + b + a ; a = b ; b = c ; c = d ; } return d ; }
int sequence ( int n ) { if ( n == 1 n == 2 ) return 1 ; else return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ; }
int sequence ( int n ) { int f [ ] = new int [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; int i ; for ( i = 3 ; i <= n ; i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; return f [ n ] ; }
int choose ( int n , int k ) { if ( k > n ) { return 0 ; } if ( n <= 1 ) { return 1 ; } if ( k == 0 ) { return 1 ; } if ( nck [ n ] [ k ] != - 1 ) { return nck [ n ] [ k ] ; } int answer = choose ( n - 1 , k - 1 ) + choose ( n - 1 , k ) ; nck [ n ] [ k ] = answer ; return answer ; }
int getLeft ( int n ) { if ( n == 1 ) { return 0 ; } int h = log2 [ n ] ; int last = n - ( ( 1 << h ) - 1 ) ; if ( last >= ( numh / 2 ) ) { } else { return ( 1 << h ) - 1 - ( ( numh / 2 ) - last ) ; } }
int numberOfHeaps ( int n ) { if ( n <= 1 ) { return 1 ; } if ( dp [ n ] != - 1 ) { return dp [ n ] ; } int left = getLeft ( n ) ; int ans = ( choose ( n - 1 , left ) * numberOfHeaps ( left ) ) * ( numberOfHeaps ( n - 1 - left ) ) ; dp [ n ] = ans ; return ans ; }
int Hosoya ( int n , int m ) { if ( ( n == 0 && m == 0 ) || ( n == 1 && m == 0 ) || ( n == 1 && m == 1 ) || ( n == 2 && m == 1 ) ) return 1 ; if ( n > m ) return Hosoya ( n - 1 , m ) + Hosoya ( n - 2 , m ) ; else if ( m == n ) return Hosoya ( n - 1 , m - 1 ) + Hosoya ( n - 2 , m - 2 ) ; else return 0 ; }
int numberofways ( int n , int m ) { int dp [ ] [ ] = new int [ n + 2 ] [ n + 2 ] ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
int zigzag ( int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= Math . min ( i , k ) ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; } return dp [ n ] [ k ] ; }
int eulerian ( int n , int m ) { if ( m >= n n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }
int eulerian ( int n , int m ) { int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }
int nswp ( int n ) { if ( n == 0 n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }
int binomialCoeff ( int n , int k ) { int C [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
int longOddEvenIncSeq ( int arr [ ] , int n ) { int [ ] lioes = new int [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; }
int dealnnoy ( int n , int m ) { if ( m == 0 n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; }
int dealnnoy ( int n , int m ) { int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }
void longestAlternating ( int arr [ ] , int n ) { int [ ] count = new int [ n ] ; count [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( count [ i ] + " " ) ; }
int maxDP ( int n ) { int res [ ] = new int [ n + 1 ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res [ i ] = Math . max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) ; return res [ n ] ; }
int findlength ( int arr [ ] , String s , int n , int ind , int st , int dp [ ] [ ] ) { if ( ind >= n ) return 0 ; if ( dp [ ind ] [ st ] != - 1 ) return dp [ ind ] [ st ] ; if ( st == 0 ) return dp [ ind ] [ st ] = Math . max ( arr [ ind ] + findlength ( arr , s , n , ind + 1 , 1 , dp ) , findlength ( arr , s , n , ind + 1 , 0 , dp ) ) ; else return dp [ ind ] [ st ] = Math . max ( arr [ ind ] + findlength ( arr , s , n , ind + 1 , 1 , dp ) , 0 ) ; }
int maxLen ( String s , int n ) { if ( allones ( s , n ) ) return - 1 ; int arr [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = ( s . charAt ( i ) == '0' ? 1 : - 1 ) ; int dp [ ] [ ] = new int [ MAX ] [ 3 ] ; for ( int [ ] row : dp ) Arrays . fill ( row , - 1 ) ; return findlength ( arr , s , n , 0 , 0 , dp ) ; }
int countarray ( int n , int k , int x ) { int [ ] dp = new int [ 109 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; }
int countPalindromes ( int k , int n , int l [ ] [ ] , int r [ ] [ ] ) { int ans = 0 ; if ( k == 1 ) { for ( int i = 0 ; i < MAX_CHAR ; i ++ ) ans += l [ i ] [ n - 1 ] ; return ans ; } if ( k == 2 ) { for ( int i = 0 ; i < MAX_CHAR ; i ++ ) ans += ( ( l [ i ] [ n - 1 ] * ( l [ i ] [ n - 1 ] - 1 ) ) / 2 ) ; return ans ; } for ( int i = 1 ; i < n - 1 ; i ++ ) for ( int j = 0 ; j < MAX_CHAR ; j ++ ) ans += l [ j ] [ i - 1 ] * r [ j ] [ i + 1 ] ; return ans ; }
int lcs ( char [ ] X , char [ ] Y , int m , int n ) { int [ ] [ ] L = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; ++ i ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 2 * ( X [ i - 1 ] - '0' ) ; else L [ i ] [ j ] = L [ i - 1 ] [ j ] > L [ i ] [ j - 1 ] ? L [ i - 1 ] [ j ] : L [ i ] [ j - 1 ] ; } } return L [ m ] [ n ] ; }
int findMinCost ( char X [ ] , char Y [ ] ) { int m = X . length , n = Y . length ; int cost = 0 ; for ( int i = 0 ; i < m ; ++ i ) cost += X [ i ] - '0' ; for ( int i = 0 ; i < n ; ++ i ) cost += Y [ i ] - '0' ; return cost - lcs ( X , Y , m , n ) ; }
int isSubsetSum ( int set [ ] , int n , int sum ) { boolean subset [ ] [ ] = new boolean [ sum + 1 ] [ n + 1 ] ; int count [ ] [ ] = new int [ sum + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { subset [ 0 ] [ i ] = true ; count [ 0 ] [ i ] = 0 ; } for ( int i = 1 ; i <= sum ; i ++ ) { subset [ i ] [ 0 ] = false ; count [ i ] [ 0 ] = - 1 ; } for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; count [ i ] [ j ] = count [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) { subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; if ( subset [ i ] [ j ] ) count [ i ] [ j ] = Math . max ( count [ i ] [ j - 1 ] , count [ i - set [ j - 1 ] ] [ j - 1 ] + 1 ) ; } } } return count [ sum ] [ n ] ; }
long answer ( int n ) { int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; }
boolean isSubSeqDivisible ( String str ) { int i , j , k , l = str . length ( ) ; int arr [ ] = new int [ l ] ; for ( i = 0 ; i < l ; i ++ ) arr [ i ] = str . charAt ( i ) - '0' ; for ( i = 0 ; i < l ; i ++ ) { for ( j = i ; j < l ; j ++ ) { for ( k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }
int maxLength ( String s , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( s . charAt ( i ) == '(' && s . charAt ( i + 1 ) == ')' ) dp [ i ] [ i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s . charAt ( i ) == '(' && s . charAt ( j ) == ')' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( int k = i ; k < j ; k ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; }
int maxLength ( String s , int n ) { int invalidOpenBraces = 0 ; int invalidCloseBraces = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '(' ) { invalidOpenBraces ++ ; } else { if ( invalidOpenBraces == 0 ) { invalidCloseBraces ++ ; } else { invalidOpenBraces -- ; } } } return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; }
int numberOfWays ( int x ) { int dp [ ] = new int [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
void dfs ( int node , int parent , Vector < Integer > tree [ ] , int colour [ ] , int answer [ ] ) { answer [ node ] = colour [ node ] ; for ( Integer u : tree [ node ] ) { if ( u == parent ) continue ; dfs ( u , node , tree , colour , answer ) ; answer [ node ] += Math . max ( answer [ u ] , 0 ) ; } }
int maxDiff ( Vector < Integer > tree [ ] , int colour [ ] , int N ) { int [ ] answer = new int [ N + 1 ] ; dfs ( 1 , 0 , tree , colour , answer ) ; int high = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { high = Math . max ( high , answer [ i ] ) ; answer [ i ] = 0 ; } for ( int i = 1 ; i <= N ; i ++ ) { if ( colour [ i ] == - 1 ) colour [ i ] = 1 ; else colour [ i ] = - 1 ; } dfs ( 1 , 0 , tree , colour , answer ) ; for ( int i = 1 ; i < N ; i ++ ) high = Math . max ( high , answer [ i ] ) ; return high ; }
void alternateSubarray ( boolean arr [ ] , int n ) { int len [ ] = new int [ n ] ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; ++ i ) System . out . print ( len [ i ] + " " ) ; }
void alternateSubarray ( boolean arr [ ] , int n ) { int count = 1 ; boolean prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { if ( ( arr [ i ] ^ prev ) == false ) { while ( count > 0 ) { System . out . print ( count -- + " " ) ; } } ++ count ; prev = arr [ i ] ; } while ( count != 0 ) { System . out . print ( count -- + " " ) ; } }
int lcs ( int [ ] [ ] [ ] dp , int [ ] arr1 , int n , int [ ] arr2 , int m , int k ) { if ( k < 0 ) return - 10000000 ; if ( n < 0 m < 0 ) return 0 ; int ans = dp [ n ] [ m ] [ k ] ; if ( ans != - 1 ) return ans ; try { ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; } catch ( Exception e ) { } return ans ; }
int productSubSeqCount ( ArrayList < Integer > arr , int k ) { int n = arr . size ( ) ; int dp [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; if ( arr . get ( j - 1 ) <= i && arr . get ( j - 1 ) > 0 ) dp [ i ] [ j ] += dp [ i / arr . get ( j - 1 ) ] [ j - 1 ] + 1 ; } } return dp [ k ] [ n ] ; }
int waysToArrange ( int N , int K , int [ ] k ) { int [ ] [ ] C = new int [ N + 1 ] [ N + 1 ] ; int i , j ; for ( i = 0 ; i <= N ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) { C [ i ] [ j ] = 1 ; } else { C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } } int [ ] dp = new int [ K + 1 ] ; int count = 0 ; dp [ 0 ] = 1 ; for ( i = 0 ; i < K ; i ++ ) { dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) ; count += k [ i ] ; } return dp [ K ] ; }
int LIP ( int dp [ ] [ ] , int mat [ ] [ ] , int n , int m , int x , int y ) { if ( dp [ x ] [ y ] < 0 ) { int result = 0 ; if ( x == n - 1 && y == m - 1 ) return dp [ x ] [ y ] = 1 ; if ( x == n - 1 y == m - 1 ) result = 1 ; if ( x + 1 < n && mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) ; if ( y + 1 < m && mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) result = Math . max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) ; dp [ x ] [ y ] = result ; } return dp [ x ] [ y ] ; }
int wrapper ( int mat [ ] [ ] , int n , int m ) { int dp [ ] [ ] = new int [ 10 ] [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) Arrays . fill ( dp [ i ] , - 1 ) ; return LIP ( dp , mat , n , m , 0 , 0 ) ; }
int minCells ( int mat [ ] [ ] , int m , int n ) { int dp [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = Integer . MAX_VALUE ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m - 1 ] [ n - 1 ] != Integer . MAX_VALUE ) return dp [ m - 1 ] [ n - 1 ] ; return - 1 ; }
Integer GetCeilIndex ( Integer [ ] arr , Integer [ ] T , Integer l , Integer r , Integer key ) { while ( r - l > 1 ) { Integer m = l + ( r - l ) / 2 ; if ( arr [ T [ m ] ] >= key ) r = m ; else l = m ; } return r ; }
void LIS ( Integer [ ] arr , Integer n ) { Integer [ ] tailIndices = new Integer [ n ] ; Integer [ ] prevIndices = new Integer [ n ] ; for ( Integer i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ tailIndices [ 0 ] ] ) tailIndices [ 0 ] = i ; else if ( arr [ i ] > arr [ tailIndices [ len - 1 ] ] ) { prevIndices [ i ] = tailIndices [ len - 1 ] ; tailIndices [ len ++ ] = i ; } else { Integer pos = GetCeilIndex ( arr , tailIndices , - 1 , len - 1 , arr [ i ] ) ; prevIndices [ i ] = tailIndices [ pos - 1 ] ; tailIndices [ pos ] = i ; } } for ( Integer i = tailIndices [ len - 1 ] ; i >= 0 ; i = prevIndices [ i ] ) res . add ( arr [ i ] ) ; }
void longestBitonic ( Integer [ ] arr1 , Integer n1 , Integer [ ] arr2 , Integer n2 ) { LIS ( arr1 , n1 ) ; Collections . reverse ( res ) ; Collections . reverse ( Arrays . asList ( arr2 ) ) ; LIS ( arr2 , n2 ) ; for ( Integer i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . elementAt ( i ) + " " ) ; }
boolean ElementsCalculationFunc ( int pre [ ] , int maxx [ ] , int x , int k , int n ) { for ( int i = 0 , j = x ; j <= n ; j ++ , i ++ ) { if ( x * maxx [ j ] - ( pre [ j ] - pre [ i ] ) <= k ) return true ; } return false ; }
int solve ( int dp [ ] [ ] , int a [ ] , int low , int high , int turn ) { if ( low == high ) { return a [ low ] * turn ; } if ( dp [ low ] [ high ] != 0 ) { return dp [ low ] [ high ] ; } dp [ low ] [ high ] = Math . max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; return dp [ low ] [ high ] ; }
int cal ( int ones [ ] [ ] , int x , int y , int k ) { return ones [ x + k - 1 ] [ y + k - 1 ] - ones [ x - 1 ] [ y + k - 1 ] - ones [ x + k - 1 ] [ y - 1 ] + ones [ x - 1 ] [ y - 1 ] ; }
int sol ( int mat [ ] [ ] ) { int ans = 0 ; int val = 0 ; int ones [ ] [ ] = new int [ R + 1 ] [ C + 1 ] ; for ( int i = 1 ; i <= R ; i ++ ) for ( int j = 1 ; j <= C ; j ++ ) { if ( mat [ i - 1 ] [ j - 1 ] == 1 ) val = 1 ; ones [ i ] [ j ] = ones [ i - 1 ] [ j ] + ones [ i ] [ j - 1 ] - ones [ i - 1 ] [ j - 1 ] + ( val ) ; } for ( int k = 1 ; k <= Math . min ( R , C ) ; k ++ ) for ( int i = 1 ; i + k - 1 <= R ; i ++ ) for ( int j = 1 ; j + k - 1 <= C ; j ++ ) ans = Math . max ( ans , ( ones [ R ] [ C ] + k * k - 2 * cal ( ones , i , j , k ) ) ) ; return ans ; }
int maxSumBitonicSubArr ( int arr [ ] , int n ) { int [ ] msis = new int [ n ] ; int [ ] msds = new int [ n ] ; int max_sum = Integer . MIN_VALUE ; msis [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ; msds [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ; return max_sum ; }
int maxSumBitonicSubArr ( int arr [ ] , int n ) { int max_sum = - 1000000 ; int i = 0 ; while ( i < n ) { int j = i ; while ( j + 1 < n && arr [ j ] < arr [ j + 1 ] ) j ++ ; while ( i < j && arr [ i ] <= 0 ) i ++ ; int k = j ; while ( k + 1 < n && arr [ k ] > arr [ k + 1 ] ) k ++ ; int last = k ; while ( k > j && arr [ k ] <= 0 ) k -- ; int sum_inc = find_partial_sum ( arr , i , j + 1 ) ; int sum_dec = find_partial_sum ( arr , j , k + 1 ) ; int sum_all = sum_inc + sum_dec - arr [ j ] ; max_sum = Math . max ( Math . max ( max_sum , sum_inc ) , Math . max ( sum_dec , sum_all ) ) ; i = Math . max ( last , i + 1 ) ; } return max_sum ; }
long countWays ( int n ) { long dp [ ] [ ] = new long [ 2 ] [ n + 1 ] ; dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }
int countways ( int n ) { int [ ] A = new int [ n + 1 ] ; A [ 0 ] = 1 ; A [ 1 ] = 3 ; A [ 2 ] = 7 ; for ( int i = 2 ; i <= n ; i ++ ) { A [ i ] = 2 * A [ i - 1 ] + A [ i - 2 ] ; } return A [ n ] ; }
boolean findWinner ( int x , int y , int n ) { boolean [ ] dp = new boolean [ n + 1 ] ; Arrays . fill ( dp , false ) ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 && dp [ i - 1 ] == false ) dp [ i ] = true ; else if ( i - x >= 0 && dp [ i - x ] == false ) dp [ i ] = true ; else if ( i - y >= 0 && dp [ i - y ] == false ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; }
void printSuperSeq ( String a , String b ) { int m = a . length ( ) , n = b . length ( ) ; int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } String res = "" ; int i = m , j = n ; while ( i > 0 && j > 0 ) { if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) { res = a . charAt ( i - 1 ) + res ; i -- ; j -- ; } else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) { res = a . charAt ( i - 1 ) + res ; i -- ; } else { res = b . charAt ( j - 1 ) + res ; j -- ; } } while ( i > 0 ) { res = a . charAt ( i - 1 ) + res ; i -- ; } while ( j > 0 ) { res = b . charAt ( j - 1 ) + res ; j -- ; } System . out . println ( res ) ; }
int maxGameByWinner ( int N ) { int [ ] dp = new int [ N ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; int i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; }
boolean isSubsetSum ( int arr [ ] , int n , int sum ) { boolean subset [ ] [ ] = new boolean [ 2 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }
int countTransformation ( String a , String b ) { int n = a . length ( ) , m = b . length ( ) ; if ( m == 0 ) { return 1 ; } int dp [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( i == 0 ) { if ( j == 0 ) { dp [ i ] [ j ] = ( a . charAt ( j ) == b . charAt ( i ) ) ? 1 : 0 ; } else if ( a . charAt ( j ) == b . charAt ( i ) ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 ; } else { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } else if ( a . charAt ( j ) == b . charAt ( i ) ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } } return dp [ m - 1 ] [ n - 1 ] ; }
int getSpecialNumber ( int N ) { return ans ( -- N ) ; }
int minimumSquare ( int m , int n ) { int vertical_min = Integer . MAX_VALUE ; int horizontal_min = Integer . MAX_VALUE ; if ( n == 13 && m == 11 ) return 6 ; if ( m == 13 && n == 11 ) return 6 ; if ( m == n ) return 1 ; if ( dp [ m ] [ n ] != 0 ) return dp [ m ] [ n ] ; for ( int i = 1 ; i <= m / 2 ; i ++ ) { horizontal_min = Math . min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontal_min ) ; } for ( int j = 1 ; j <= n / 2 ; j ++ ) { vertical_min = Math . min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , vertical_min ) ; } dp [ m ] [ n ] = Math . min ( vertical_min , horizontal_min ) ; return dp [ m ] [ n ] ; }
long fact ( int n ) { long res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
long nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
long countWays ( int n , int k ) { long total = k ; int mod = 1000000007 ; int same = 0 , diff = k ; for ( int i = 2 ; i <= n ; i ++ ) { same = diff ; diff = ( int ) total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }
int computeLIS ( int circBuff [ ] , int start , int end , int n ) { int LIS [ ] = new int [ n + end - start ] ; for ( int i = start ; i < end ; i ++ ) LIS [ i ] = 1 ; for ( int i = start + 1 ; i < end ; i ++ ) for ( int j = start ; j < i ; j ++ ) if ( circBuff [ i ] > circBuff [ j ] && LIS [ i ] < LIS [ j ] + 1 ) LIS [ i ] = LIS [ j ] + 1 ; int res = Integer . MIN_VALUE ; for ( int i = start ; i < end ; i ++ ) res = Math . max ( res , LIS [ i ] ) ; return res ; }
int LICS ( int arr [ ] , int n ) { int circBuff [ ] = new int [ 2 * n ] ; for ( int i = 0 ; i < n ; i ++ ) circBuff [ i ] = arr [ i ] ; for ( int i = n ; i < 2 * n ; i ++ ) circBuff [ i ] = arr [ i - n ] ; int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) res = Math . max ( computeLIS ( circBuff , i , i + n , n ) , res ) ; return res ; }
long countBT ( int h ) { long [ ] dp = new long [ h + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ; return dp [ h ] ; }
int minTimeForWritingChars ( int N , int insert , int remove , int copy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insert ; int dp [ ] = new int [ N + 1 ] ; dp [ 1 ] = insert ; for ( int i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + copy ) ; else dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) / 2 ] + copy + remove ) ; } return dp [ N ] ; }
int countPaths ( int n , int m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }
int countPaths ( int n , int m ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }
int binomialCoeff ( int n , int k ) { int C [ ] = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
long sumOfSubstrings ( String num ) { long sum = 0 ; long mf = 1 ; for ( int i = num . length ( ) - 1 ; i >= 0 ; i -- ) { sum += ( num . charAt ( i ) - '0' ) * ( i + 1 ) * mf ; mf = mf * 10 + 1 ; } return sum ; }
int countWays ( int n , int m ) { int count [ ] = new int [ n + 1 ] ; count [ 0 ] = 0 ; int i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m i == 1 ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }
int maxSum ( int grid [ ] [ ] , int n ) { int incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; int excl = 0 , excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = Math . max ( excl , incl ) ; incl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; excl = excl_new ; } return Math . max ( excl , incl ) ; }
int maxSumWithK ( int a [ ] , int n , int k ) { int maxSum [ ] = new int [ n ] ; maxSum [ 0 ] = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; maxSum [ i ] = curr_max ; } int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += a [ i ] ; int result = sum ; for ( int i = k ; i < n ; i ++ ) { sum = sum + a [ i ] - a [ i - k ] ; result = Math . max ( result , sum ) ; result = Math . max ( result , sum + maxSum [ i - k ] ) ; } return result ; }
int getTotalNumberOfSequences ( int m , int n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }
int getTotalNumberOfSequences ( int m , int n ) { int T [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] ; } } return T [ m ] [ n ] ; }
int minInsertionStepToSortArray ( int arr [ ] , int N ) { int [ ] lis = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int max = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return ( N - max ) ; }
void printDistinct ( String str ) { int [ ] count = new int [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) != ' ' ) count [ ( int ) str . charAt ( i ) ] ++ ; int n = i ; for ( i = 0 ; i < n ; i ++ ) if ( count [ ( int ) str . charAt ( i ) ] == 1 ) System . out . print ( str . charAt ( i ) ) ; }
int lcs ( String str1 , String str2 , int m , int n ) { int L [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j - 1 ) ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; }
void countWaysToJump ( int arr [ ] , int n ) { int count_jump [ ] = new int [ n ] ; Arrays . fill ( count_jump , 0 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( count_jump [ i ] + " " ) ; }
int lis ( int arr [ ] , int n ) { int result = 0 ; int [ ] lis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < lis [ i ] ) result = lis [ i ] ; return result ; }
int minStepToDeleteString ( String str ) { int N = str . length ( ) ; int [ ] [ ] dp = new int [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= N ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int len = 1 ; len <= N ; len ++ ) { for ( int i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) { if ( len == 1 ) dp [ i ] [ j ] = 1 ; else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( str . charAt ( i ) == str . charAt ( i + 1 ) ) dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; for ( int K = i + 2 ; K <= j ; K ++ ) if ( str . charAt ( i ) == str . charAt ( K ) ) dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } return dp [ 0 ] [ N - 1 ] ; }
void solve ( int i , int par , int a [ ] , int n , int k , int current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = Math . min ( ans , current_ans ) ; return ; } for ( int j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }
int minCost ( int a [ ] , int n , int k ) { int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= k ; j ++ ) dp [ i ] [ j ] = inf ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) for ( int m = i - 1 ; m >= 0 ; m -- ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; return dp [ n ] [ k ] ; }
int getMinSteps ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int min = dp [ i - 1 ] ; if ( i % 2 == 0 ) { min = Math . min ( min , dp [ i / 2 ] ) ; } if ( i % 3 == 0 ) { min = Math . min ( min , dp [ i / 3 ] ) ; } dp [ i ] = min + 1 ; } return dp [ n ] ; }
int minimumNumberOfDeletions ( String str ) { int n = str . length ( ) ; int len = lps ( str ) ; return ( n - len ) ; }
int utility_fun_for_del ( String str , int i , int j ) { if ( i >= j ) return 0 ; if ( str . charAt ( i ) == str . charAt ( j ) ) { return utility_fun_for_del ( str , i + 1 , j - 1 ) ; } return 1 + Math . min ( utility_fun_for_del ( str , i + 1 , j ) , utility_fun_for_del ( str , i , j - 1 ) ) ; }
int min_ele_del ( String str ) { return utility_fun_for_del ( str , 0 , str . length ( ) - 1 ) ; }
int numofArray ( int n , int m ) { int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; Vector < Integer > [ ] di = new Vector [ MAX ] ; Vector < Integer > [ ] mu = new Vector [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < MAX ; i ++ ) { di [ i ] = new Vector < > ( ) ; mu [ i ] = new Vector < > ( ) ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 2 * i ; j <= m ; j += i ) { di [ j ] . add ( i ) ; mu [ i ] . add ( j ) ; } di [ i ] . add ( i ) ; } for ( int i = 1 ; i <= m ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; for ( Integer x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; for ( Integer x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { ans += dp [ n ] [ i ] ; di [ i ] . clear ( ) ; mu [ i ] . clear ( ) ; } return ans ; }
int offeringNumber ( int n , int templeHeight [ ] ) { for ( int i = 0 ; i < n ; ++ i ) { int left = 0 , right = 0 ; for ( int j = i - 1 ; j >= 0 ; -- j ) { if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ left ; else break ; } for ( int j = i + 1 ; j < n ; ++ j ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ right ; else break ; } sum += Math . max ( right , left ) + 1 ; } return sum ; }
int stringReduction ( String str ) { int n = str . length ( ) ; int count [ ] = new int [ 3 ] ; for ( int i = 0 ; i < n ; ++ i ) { count [ str . charAt ( i ) - 'a' ] ++ ; } if ( count [ 0 ] == n count [ 1 ] == n count [ 2 ] == n ) { return n ; } if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) { return 2 ; } return 1 ; }
boolean modularSum ( int arr [ ] , int n , int m ) { if ( n > m ) return true ; boolean DP [ ] = new boolean [ m ] ; Arrays . fill ( DP , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; boolean temp [ ] = new boolean [ m ] ; Arrays . fill ( temp , false ) ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }
int maxSum ( int tri [ ] [ ] , int n ) { if ( n > 1 ) tri [ 1 ] [ 1 ] = tri [ 1 ] [ 1 ] + tri [ 0 ] [ 0 ] ; tri [ 1 ] [ 0 ] = tri [ 1 ] [ 0 ] + tri [ 0 ] [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { tri [ i ] [ 0 ] = tri [ i ] [ 0 ] + tri [ i - 1 ] [ 0 ] ; tri [ i ] [ i ] = tri [ i ] [ i ] + tri [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j < i ; j ++ ) { if ( tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] >= tri [ i ] [ j ] + tri [ i - 1 ] [ j ] ) tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] ; else tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j ] ; } } int max = tri [ n - 1 ] [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( max < tri [ n - 1 ] [ i ] ) max = tri [ n - 1 ] [ i ] ; } return max ; }
int largestZigZagSumRec ( int mat [ ] [ ] , int i , int j , int n ) { if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( i == n - 1 ) return ( dp [ i ] [ j ] = mat [ i ] [ j ] ) ; int zzs = 0 ; for ( int k = 0 ; k < n ; k ++ ) if ( k != j ) zzs = Math . max ( zzs , largestZigZagSumRec ( mat , i + 1 , k , n ) ) ; return ( dp [ i ] [ j ] = ( zzs + mat [ i ] [ j ] ) ) ; }
int largestZigZag ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < MAX ; i ++ ) for ( int k = 0 ; k < MAX ; k ++ ) dp [ i ] [ k ] = - 1 ; int res = 0 ; for ( int j = 0 ; j < n ; j ++ ) res = Math . max ( res , largestZigZagSumRec ( mat , 0 , j , n ) ) ; return res ; }
int countEndless ( boolean input [ ] [ ] , int n ) { boolean row [ ] [ ] = new boolean [ n ] [ n ] ; boolean col [ ] [ ] = new boolean [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { boolean isEndless = true ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( input [ i ] [ j ] == false ) isEndless = false ; col [ i ] [ j ] = isEndless ; } } for ( int i = 0 ; i < n ; i ++ ) { boolean isEndless = true ; for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( input [ i ] [ j ] == false ) isEndless = false ; row [ i ] [ j ] = isEndless ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ; return ans ; }
int countSubsequences ( String s ) { int aCount = 0 ; int bCount = 0 ; int cCount = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == 'a' ) aCount = ( 1 + 2 * aCount ) ; else if ( s . charAt ( i ) == 'b' ) bCount = ( aCount + 2 * bCount ) ; else if ( s . charAt ( i ) == 'c' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }
int maximumDifferenceSum ( int arr [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }
int countStr ( int n , int bCount , int cCount ) { if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; int res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }
int maxRevenue ( int m , int [ ] x , int [ ] revenue , int n , int t ) { int [ ] maxRev = new int [ m + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) maxRev [ i ] = 0 ; int nxtbb = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = Math . max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; }
int getMaxGold ( int gold [ ] [ ] , int m , int n ) { int goldTable [ ] [ ] = new int [ m ] [ n ] ; for ( int [ ] rows : goldTable ) Arrays . fill ( rows , 0 ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + Math . max ( right , Math . max ( right_up , right_down ) ) ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = Math . max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }
int largestKSubmatrix ( int [ ] [ ] a ) { int [ ] [ ] dp = new int [ Row ] [ Col ] ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] && dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i - 1 ] [ j ] : ( dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j ] && dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i ] [ j - 1 ] : dp [ i - 1 ] [ j - 1 ] + 1 ; } else dp [ i ] [ j ] = 1 ; } result = result > dp [ i ] [ j ] ? result : dp [ i ] [ j ] ; } } return result ; }
int countDivisibleSubseq ( String str , int n ) { int len = str . length ( ) ; int dp [ ] [ ] = new int [ len ] [ n ] ; dp [ 0 ] [ ( str . charAt ( 0 ) - '0' ) % n ] ++ ; for ( int i = 1 ; i < len ; i ++ ) { dp [ i ] [ ( str . charAt ( i ) - '0' ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( str . charAt ( i ) - '0' ) ) % n ] += dp [ i - 1 ] [ j ] ; } } return dp [ len - 1 ] [ 0 ] ; }
int MaximumPath ( int Mat [ ] [ ] ) { int result = 0 ; int dp [ ] [ ] = new int [ N ] [ N + 2 ] ; for ( int [ ] rows : dp ) Arrays . fill ( rows , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) result = Math . max ( result , dp [ N - 1 ] [ i ] ) ; return result ; }
double probability ( int k , int n ) { double ans = 0 ; for ( int i = k ; i <= n ; ++ i ) ans += fact [ n ] / ( fact [ i ] * fact [ n - i ] ) ; ans = ans / ( 1 << n ) ; return ans ; }
void precompute ( ) { fact [ 0 ] = fact [ 1 ] = 1 ; for ( int i = 2 ; i < 20 ; ++ i ) fact [ i ] = fact [ i - 1 ] * i ; }
double probability ( int k , int n ) { double ans = 0.0 ; for ( int i = k ; i <= n ; ++ i ) { double res = dp [ n ] - dp [ i ] - dp [ n - i ] - n ; ans += Math . pow ( 2.0 , res ) ; } return ans ; }
void precompute ( ) { for ( int i = 2 ; i < MAX ; ++ i ) dp [ i ] = ( Math . log ( i ) / Math . log ( 2 ) ) + dp [ i - 1 ] ; }
int countStrings ( int n , int k ) { int dp [ ] [ ] [ ] = new int [ n + 1 ] [ k + 1 ] [ 2 ] ; dp [ 1 ] [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j < i && j < k + 1 ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) { dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }
boolean canVote ( int [ ] a , int n , int x ) { int [ ] [ ] dp = new int [ n + 1 ] [ x + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < x + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 1 ; j <= x ; j ++ ) if ( a [ i ] <= j ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , a [ i ] + dp [ i - 1 ] [ j - a [ i ] ] ) ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; return ( sum - dp [ n ] [ x ] >= x ) ; }
int countFriendsPairings ( int n ) { int dp [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }
int countFriendsPairings ( int n ) { if ( dp [ n ] != - 1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else return dp [ n ] = n ; }
int countFriendsPairings ( int n ) { int a = 1 , b = 2 , c = 0 ; if ( n <= 2 ) { return n ; } for ( int i = 3 ; i <= n ; i ++ ) { c = b + ( i - 1 ) * a ; a = b ; b = c ; } return c ; }
int maxPathSum ( int tri [ ] [ ] , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; }
int findMaxPoints ( int A [ ] [ ] ) { int [ ] [ ] P1S = new int [ M + 2 ] [ N + 2 ] ; int [ ] [ ] P1E = new int [ M + 2 ] [ N + 2 ] ; int [ ] [ ] P2S = new int [ M + 2 ] [ N + 2 ] ; int [ ] [ ] P2E = new int [ M + 2 ] [ N + 2 ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 1 ; j <= M ; j ++ ) P1S [ i ] [ j ] = Math . max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = M ; j >= 1 ; j -- ) P1E [ i ] [ j ] = Math . max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = 1 ; j <= M ; j ++ ) P2S [ i ] [ j ] = Math . max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = M ; j >= 1 ; j -- ) P2E [ i ] [ j ] = Math . max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { for ( int j = 2 ; j < M ; j ++ ) { int op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] ; int op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] ; ans = Math . max ( ans , Math . max ( op1 , op2 ) ) ; } } return ans ; }
boolean inside ( int x , int y ) { return ( x >= 0 && x < N && y >= 0 && y < N ) ; }
double findProb ( int start_x , int start_y , int steps ) { double dp1 [ ] [ ] [ ] = new double [ N ] [ N ] [ steps + 1 ] ; for ( int i = 0 ; i < N ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) dp1 [ i ] [ j ] [ 0 ] = 1 ; for ( int s = 1 ; s <= steps ; ++ s ) { for ( int x = 0 ; x < N ; ++ x ) { for ( int y = 0 ; y < N ; ++ y ) { double prob = 0.0 ; for ( int i = 0 ; i < 8 ; ++ i ) { int nx = x + dx [ i ] ; int ny = y + dy [ i ] ; if ( inside ( nx , ny ) ) prob += dp1 [ nx ] [ ny ] [ s - 1 ] / 8.0 ; } dp1 [ x ] [ y ] [ s ] = prob ; } } } return dp1 [ start_x ] [ start_y ] [ steps ] ; }
int lcsOf3 ( String X , String Y , String Z , int m , int n , int o ) { int [ ] [ ] [ ] L = new int [ m + 1 ] [ n + 1 ] [ o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 j == 0 k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) && X . charAt ( i - 1 ) == Z . charAt ( k - 1 ) ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; }
int lcsOf3 ( int i , int j , int k ) { if ( i == - 1 j == - 1 k == - 1 ) { return 0 ; } if ( dp [ i ] [ j ] [ k ] != - 1 ) { return dp [ i ] [ j ] [ k ] ; } if ( X . charAt ( i ) == Y . charAt ( j ) && Y . charAt ( j ) == Z . charAt ( k ) ) { return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ; } else { return dp [ i ] [ j ] [ k ] = Math . max ( Math . max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) ; } }
void distSumRec ( int arr [ ] , int n , int sum , int currindex , HashSet < Integer > s ) { if ( currindex > n ) return ; if ( currindex == n ) { s . add ( sum ) ; return ; } distSumRec ( arr , n , sum + arr [ currindex ] , currindex + 1 , s ) ; distSumRec ( arr , n , sum , currindex + 1 , s ) ; }
void printDistSum ( int arr [ ] , int n ) { HashSet < Integer > s = new HashSet < > ( ) ; distSumRec ( arr , n , 0 , 0 , s ) ; for ( int i : s ) System . out . print ( i + " " ) ; }
void printDistSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; boolean [ ] [ ] dp = new boolean [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( int j = 0 ; j <= sum ; j ++ ) if ( dp [ n ] [ j ] == true ) System . out . print ( j + " " ) ; }
void printMaxSum ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; Arrays . fill ( dp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; int maxi = 0 ; for ( int j = 1 ; j <= Math . sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += maxi ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( dp [ i ] + " " ) ; }
int countPaths ( int maze [ ] [ ] ) { if ( maze [ 0 ] [ 0 ] == - 1 ) return 0 ; for ( int i = 0 ; i < R ; i ++ ) { if ( maze [ i ] [ 0 ] == 0 ) maze [ i ] [ 0 ] = 1 ; else break ; } for ( int i = 1 ; i < C ; i ++ ) { if ( maze [ 0 ] [ i ] == 0 ) maze [ 0 ] [ i ] = 1 ; else break ; } for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) { if ( maze [ i ] [ j ] == - 1 ) continue ; if ( maze [ i - 1 ] [ j ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) ; if ( maze [ i ] [ j - 1 ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; } } return ( maze [ R - 1 ] [ C - 1 ] > 0 ) ? maze [ R - 1 ] [ C - 1 ] : 0 ; }
int minSum ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return Math . min ( arr [ 0 ] , arr [ 1 ] ) ; if ( n == 3 ) return Math . min ( arr [ 0 ] , Math . min ( arr [ 1 ] , arr [ 2 ] ) ) ; if ( n == 4 ) return Math . min ( Math . min ( arr [ 0 ] , arr [ 1 ] ) , Math . min ( arr [ 2 ] , arr [ 3 ] ) ) ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = arr [ 1 ] ; dp [ 2 ] = arr [ 2 ] ; dp [ 3 ] = arr [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) dp [ i ] = arr [ i ] + Math . min ( Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) , Math . min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ; return Math . min ( Math . min ( dp [ n - 1 ] , dp [ n - 2 ] ) , Math . min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ; }
int minSum ( int ar [ ] , int n ) { if ( n <= 4 ) return Arrays . stream ( ar ) . min ( ) . getAsInt ( ) ; int [ ] sum = new int [ n ] ; sum [ 0 ] = ar [ 0 ] ; sum [ 1 ] = ar [ 1 ] ; sum [ 2 ] = ar [ 2 ] ; sum [ 3 ] = ar [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) sum [ i ] = ar [ i ] + Arrays . stream ( Arrays . copyOfRange ( sum , i - 4 , i ) ) . min ( ) . getAsInt ( ) ; return Arrays . stream ( Arrays . copyOfRange ( sum , n - 4 , n ) ) . min ( ) . getAsInt ( ) ; }
void printMinAndMaxValueOfExp ( String exp ) { Vector < Integer > num = new Vector < Integer > ( ) ; Vector < Character > opr = new Vector < Character > ( ) ; String tmp = "" ; for ( int i = 0 ; i < exp . length ( ) ; i ++ ) { if ( isOperator ( exp . charAt ( i ) ) ) { opr . add ( exp . charAt ( i ) ) ; num . add ( Integer . parseInt ( tmp ) ) ; tmp = "" ; } else { tmp += exp . charAt ( i ) ; } } num . add ( Integer . parseInt ( tmp ) ) ; int len = num . size ( ) ; int [ ] [ ] minVal = new int [ len ] [ len ] ; int [ ] [ ] maxVal = new int [ len ] [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = 0 ; j < len ; j ++ ) { minVal [ i ] [ j ] = Integer . MAX_VALUE ; maxVal [ i ] [ j ] = 0 ; if ( i == j ) minVal [ i ] [ j ] = maxVal [ i ] [ j ] = num . get ( i ) ; } } for ( int L = 2 ; L <= len ; L ++ ) { for ( int i = 0 ; i < len - L + 1 ; i ++ ) { int j = i + L - 1 ; for ( int k = i ; k < j ; k ++ ) { int minTmp = 0 , maxTmp = 0 ; if ( opr . get ( k ) == '+' ) { minTmp = minVal [ i ] [ k ] + minVal [ k + 1 ] [ j ] ; maxTmp = maxVal [ i ] [ k ] + maxVal [ k + 1 ] [ j ] ; } else if ( opr . get ( k ) == '*' ) { minTmp = minVal [ i ] [ k ] * minVal [ k + 1 ] [ j ] ; maxTmp = maxVal [ i ] [ k ] * maxVal [ k + 1 ] [ j ] ; } if ( minTmp < minVal [ i ] [ j ] ) minVal [ i ] [ j ] = minTmp ; if ( maxTmp > maxVal [ i ] [ j ] ) maxVal [ i ] [ j ] = maxTmp ; } } } System . out . print ( "Minimum value : " + minVal [ 0 ] [ len - 1 ] + ", Maximum value : " + maxVal [ 0 ] [ len - 1 ] ) ; }
int maxDecimalValue ( int mat [ ] [ ] , int i , int j , int p ) { if ( i >= N j >= N ) { return 0 ; } int result = Math . max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) ; if ( mat [ i ] [ j ] == 1 ) { return ( int ) ( Math . pow ( 2 , p ) + result ) ; } else { return result ; } }
int MaximumDecimalValue ( int mat [ ] [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; if ( mat [ 0 ] [ 0 ] == 1 ) { } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ 0 ] [ i ] == 1 ) { dp [ 0 ] [ i ] = ( int ) ( dp [ 0 ] [ i - 1 ] + Math . pow ( 2 , i ) ) ; else  { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ i ] [ 0 ] == 1 ) { dp [ i ] [ 0 ] = ( int ) ( dp [ i - 1 ] [ 0 ] + Math . pow ( 2 , i ) ) ; else  { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { dp [ i ] [ j ] = ( int ) ( Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + Math . pow ( 2 , i + j ) ) ; } else { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } } return dp [ n - 1 ] [ n - 1 ] ; } public static void main  ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 0 , 1 } , { 0 , 1 , 1 , 0 } , { 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 } , } ; System . out . println ( MaximumDecimalValue ( mat , 4 ) ) ; } } }
int longestSubseqWithDiffOne ( int arr [ ] , int n ) { int dp [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }
int nCr ( int n , int k ) { int C [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
double resultOfAllSubsets ( int arr [ ] , int N ) { double result = 0.0 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; for ( int n = 1 ; n <= N ; n ++ ) result += ( double ) ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n ; return result ; }
int maxSumWO3Consec ( int arr [ ] , int n ) { int sum [ ] = new int [ n ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = Math . max ( Math . max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }
int maxSumWO3Consec ( int n ) { if ( sum [ n ] != - 1 ) return sum [ n ] ; if ( n == 0 ) return sum [ n ] = 0 ; if ( n == 1 ) return sum [ n ] = arr [ 0 ] ; if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; return sum [ n ] = Math . max ( Math . max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; }
int maxAlternateSum ( int arr [ ] , int n ) { if ( n == 1 ) return arr [ 0 ] ; int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( min > arr [ i ] ) min = arr [ i ] ; } if ( min == arr [ 0 ] ) { return arr [ 0 ] ; } int dec [ ] = new int [ n ] ; int inc [ ] = new int [ n ] ; dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ; int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i ] = Math . max ( inc [ i ] , dec [ j ] + arr [ i ] ) ; } } int result = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( result < inc [ i ] ) result = inc [ i ] ; if ( result < dec [ i ] ) result = dec [ i ] ; } return result ; }
int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int dp [ ] = new int [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; }
void printInorder ( TreeNode node ) { if ( node == null ) return ; printInorder ( node . left ) ; System . out . print ( node . val + " " ) ; printInorder ( node . right ) ; }
int lucas ( int n ) { int a = 2 , b = 1 , c , i ; if ( n == 0 ) return a ; for ( i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return b ; }
double maxAverageOfPath ( int cost [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N + 1 ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
int breakSum ( int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = Math . max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ; return dp [ n ] ; }
int countPS ( String str ) { int N = str . length ( ) ; int [ ] [ ] cps = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) cps [ i ] [ i ] = 1 ; for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i <= N - L ; i ++ ) { int k = L + i - 1 ; if ( str . charAt ( i ) == str . charAt ( k ) ) { cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ; } else { cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ; } } } return cps [ 0 ] [ N - 1 ] ; }
int countPS ( int i , int j ) { if ( i > j ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( i == j ) return dp [ i ] [ j ] = 1 ; else if ( str . charAt ( i ) == str . charAt ( j ) ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; }
int lcs ( String str1 , String str2 , int len1 , int len2 , int i , int j ) { int ret = dp [ i ] [ j ] ; if ( i == len1 j == len2 ) return ret = 0 ; if ( ret != - 1 ) return ret ; ret = 0 ; if ( str1 . charAt ( i ) == str2 . charAt ( j ) ) ret = 1 + lcs ( str1 , str2 , len1 , len2 , i + 1 , j + 1 ) ; else ret = Math . max ( lcs ( str1 , str2 , len1 , len2 , i + 1 , j ) , lcs ( str1 , str2 , len1 , len2 , i , j + 1 ) ) ; return ret ; }
void prinlAllLCSSorted ( String str1 , String str2 ) { int len1 = str1 . length ( ) , len2 = str2 . length ( ) ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } lcslen = lcs ( str1 , str2 , len1 , len2 , 0 , 0 ) ; char [ ] data = new char [ MAX ] ; printAll ( str1 , str2 , len1 , len2 , data , 0 , 0 , 0 ) ; }
int maxCost ( int mat [ ] [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ N ] ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + Math . max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }
int numberOfPermWithKInversion ( int N , int K ) { if ( N == 0 ) return 0 ; if ( K == 0 ) return 1 ; if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ; int sum = 0 ; for ( int i = 0 ; i <= K ; i ++ ) { if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 1 , K - i ) ; } memo [ N ] [ K ] = sum ; return sum ; }
int countSub ( int arr [ ] , int n ) { int count [ ] = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - 1 ; j >= 0 ; j -- ) count [ arr [ i ] ] += count [ j ] ; count [ arr [ i ] ] ++ ; } int result = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) result += count [ i ] ; return result ; }
int minimum ( int a , int b , int c ) { return Math . min ( Math . min ( a , b ) , c ) ; }
int countSub ( String s ) { HashMap < Character , Integer > map = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { map . put ( s . charAt ( i ) , - 1 ) ; } int allCount = 0 ; int levelCount = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( i == 0 ) { allCount = 1 ; map . put ( c , 1 ) ; levelCount = 1 ; continue ; } levelCount = allCount + 1 ; if ( map . get ( c ) < 0 ) { allCount = allCount + levelCount ; } else { allCount = allCount + levelCount - map . get ( c ) ; } map . put ( c , levelCount ) ; } return allCount ; }
int catalanDP ( int n ) { int [ ] catalan = new int [ n + 1 ] ; catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } return catalan [ n ] ; }
int countWays ( int n ) { if ( n < 1 ) { System . out . println ( "Invalid" ) ; return 0 ; } return catalanDP ( n / 2 ) ; }
int countGroups ( int position , int previous_sum , int length , char [ ] num ) { if ( position == length ) return 1 ; if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [ position ] [ previous_sum ] ; dp [ position ] [ previous_sum ] = 0 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position ] [ previous_sum ] = res ; return res ; }
int MinimumCost ( int cost [ ] , int n , int W ) { Vector < Integer > val = new Vector < Integer > ( ) ; Vector < Integer > wt = new Vector < Integer > ( ) ; int size = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( cost [ i ] != - 1 ) { val . add ( cost [ i ] ) ; wt . add ( i + 1 ) ; size ++ ; } } n = size ; int min_cost [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( int i = 0 ; i <= W ; i ++ ) min_cost [ 0 ] [ i ] = Integer . MAX_VALUE ; for ( int i = 1 ; i <= n ; i ++ ) min_cost [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= W ; j ++ ) { if ( wt . get ( i - 1 ) > j ) min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] ; else min_cost [ i ] [ j ] = Math . min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt . get ( i - 1 ) ] + val . get ( i - 1 ) ) ; } } return ( min_cost [ n ] [ W ] == Integer . MAX_VALUE ) ? - 1 : min_cost [ n ] [ W ] ; }
int minCost ( int cost [ ] , int n ) { int dp [ ] = new int [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int min_cost = Integer . MAX_VALUE ; for ( int j = 0 ; j < i ; j ++ ) if ( j < cost . length && cost [ j ] != - 1 ) { min_cost = Math . min ( min_cost , cost [ j ] + dp [ i - j - 1 ] ) ; } dp [ i ] = min_cost ; } return dp [ n ] ; }
int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int [ ] dp = new int [ W + 1 ] ; Arrays . fill ( dp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; }
int count ( String a , String b , int m , int n ) { if ( ( m == 0 && n == 0 ) n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a . charAt ( m - 1 ) == b . charAt ( n - 1 ) ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
int count ( String a , String b ) { int m = a . length ( ) ; int n = b . length ( ) ; int lookup [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) lookup [ 0 ] [ i ] = 0 ; for ( int i = 0 ; i <= m ; ++ i ) lookup [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ; else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ; } } return lookup [ m ] [ n ] ; }
int lcs ( String X , String Y , int m , int n ) { int L [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; }
int findMinCost ( String X , String Y , int costX , int costY ) { int m = X . length ( ) ; int n = Y . length ( ) ; int len_LCS ; len_LCS = lcs ( X , Y , m , n ) ; return costX * ( m - len_LCS ) + costY * ( n - len_LCS ) ; }
int findSum ( Vector < Integer > arr ) { int sum = 0 ; for ( int i : arr ) sum += i ; return sum ; }
int maxTasks ( int high [ ] , int low [ ] , int n ) { if ( n <= 0 ) return 0 ; return Math . max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; }
int maxTasks ( int [ ] high , int [ ] low , int n ) { int [ ] task_dp = new int [ n + 1 ] ; task_dp [ 0 ] = 0 ; task_dp [ 1 ] = high [ 0 ] ; for ( int i = 2 ; i <= n ; i ++ ) task_dp [ i ] = Math . max ( high [ i - 1 ] + task_dp [ i - 2 ] , low [ i - 1 ] + task_dp [ i - 1 ] ) ; return task_dp [ n ] ; }
Set < String > findLCS ( String X , String Y , int m , int n ) { Set < String > s = new HashSet < > ( ) ; if ( m == 0 n == 0 ) { s . add ( "" ) ; return s ; } if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) { Set < String > tmp = findLCS ( X , Y , m - 1 , n - 1 ) ; for ( String str : tmp ) s . add ( str + X . charAt ( m - 1 ) ) ; } else { if ( L [ m - 1 ] [ n ] >= L [ m ] [ n - 1 ] ) s = findLCS ( X , Y , m - 1 , n ) ; if ( L [ m ] [ n - 1 ] >= L [ m - 1 ] [ n ] ) { Set < String > tmp = findLCS ( X , Y , m , n - 1 ) ; s . addAll ( tmp ) ; } } return s ; }
int LCS ( String X , String Y , int m , int n ) { for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; }
int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n - i ; j ++ ) for ( int k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }
int countIntegralSolutions ( int n ) { return ( ( n + 1 ) * ( n + 2 ) ) / 2 ; }
int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int table [ ] = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }
int minTime ( int arr [ ] , int n ) { if ( n <= 0 ) return 0 ; int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int incl_new = arr [ i ] + Math . min ( excl , incl ) ; int excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . min ( incl , excl ) ; }
int lcs ( String X , String Y ) { int m = X . length ( ) , n = Y . length ( ) ; int L [ ] [ ] = new int [ 2 ] [ n + 1 ] ; int bi = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = Math . max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; }
int countUtil ( int p , int q , int r ) { }
int countWays ( int p , int q , int r , int last ) { if ( p < 0 q < 0 r < 0 ) return 0 ; if ( p == 1 && q == 0 && r == 0 && last == 0 ) return 1 ; if ( p == 0 && q == 1 && r == 0 && last == 1 ) return 1 ; if ( p == 0 && q == 0 && r == 1 && last == 2 ) return 1 ; if ( dp [ p ] [ q ] [ r ] [ last ] != - 1 ) return dp [ p ] [ q ] [ r ] [ last ] ; if ( last == 0 ) dp [ p ] [ q ] [ r ] [ last ] = countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ; else if ( last == 1 ) dp [ p ] [ q ] [ r ] [ last ] = countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ; else dp [ p ] [ q ] [ r ] [ last ] = countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ; return dp [ p ] [ q ] [ r ] [ last ] ; }
int countUtil ( int p , int q , int r ) { for ( int [ ] [ ] [ ] row : dp ) { for ( int [ ] [ ] innerRow : row ) { for ( int [ ] innerInnerRow : innerRow ) { Arrays . fill ( innerInnerRow , - 1 ) ; } } } ; }
void multiply ( int a [ ] [ ] , int b [ ] [ ] ) { int mul [ ] [ ] = new int [ 3 ] [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { mul [ i ] [ j ] = 0 ; for ( int k = 0 ; k < 3 ; k ++ ) mul [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; } } for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) a [ i ] [ j ] = mul [ i ] [ j ] ; }
int power ( int F [ ] [ ] , int n ) { int M [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; if ( n == 1 ) return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ; power ( F , n / 2 ) ; multiply ( F , F ) ; if ( n % 2 != 0 ) multiply ( F , M ) ; return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ; }
int findNthTerm ( int n ) { int F [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; return power ( F , n - 2 ) ; }
int count ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } } return dp [ n ] ; }
int KSmallestUsingMorris ( Node root , int k ) { int count = 0 ; int ksmall = Integer . MIN_VALUE ; Node curr = root ; while ( curr != null ) { if ( curr . left == null ) { count ++ ; if ( count == k ) ksmall = curr . key ; curr = curr . right ; } else { Node pre = curr . left ; while ( pre . right != null && pre . right != curr ) pre = pre . right ; if ( pre . right == null ) { pre . right = curr ; curr = curr . left ; } else { pre . right = null ; count ++ ; if ( count == k ) ksmall = curr . key ; curr = curr . right ; } } } return ksmall ; }
int subsetXOR ( int [ ] arr , int n , int k ) { int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; int m = ( 1 << ( int ) ( Math . log ( max_ele ) / Math . log ( 2 ) + 1 ) ) - 1 ; if ( k > m ) { return 0 ; } int [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = 0 ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ; return dp [ n ] [ k ] ; }
int permutationCoeff ( int n , int k ) { int [ ] fact = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return fact [ n ] / fact [ n - k ] ; }
int findMin ( int arr [ ] , int n ) { int sumTotal = 0 ; for ( int i = 0 ; i < n ; i ++ ) sumTotal += arr [ i ] ; return findMinRec ( arr , n , 0 , sumTotal ) ; }
int countDer ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }
int countDer ( int n ) { int der [ ] = new int [ n + 1 ] ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
int countDer ( int n ) { if ( n == 1 n == 2 ) { return n - 1 ; } int a = 0 ; int b = 1 ; for ( int i = 3 ; i <= n ; ++ i ) { int cur = ( i - 1 ) * ( a + b ) ; a = b ; b = cur ; } return b ; }
int bellNumber ( int n ) { int [ ] [ ] bell = new int [ n + 1 ] [ n + 1 ] ; bell [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j <= i ; j ++ ) bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ; } return bell [ n ] [ 0 ] ; }
int minSizeRec ( int arr [ ] , int low , int high , int k ) { if ( dp [ low ] [ high ] != - 1 ) { return dp [ low ] [ high ] ; } if ( ( high - low + 1 ) < 3 ) { return high - low + 1 ; } int res = 1 + minSizeRec ( arr , low + 1 , high , k ) ; for ( int i = low + 1 ; i <= high - 1 ; i ++ ) { for ( int j = i + 1 ; j <= high ; j ++ ) { if ( arr [ i ] == ( arr [ low ] + k ) && arr [ j ] == ( arr [ low ] + 2 * k ) && minSizeRec ( arr , low + 1 , i - 1 , k ) == 0 && minSizeRec ( arr , i + 1 , j - 1 , k ) == 0 ) { res = Math . min ( res , minSizeRec ( arr , j + 1 , high , k ) ) ; } } } return ( dp [ low ] [ high ] = res ) ; }
int countSol ( int coeff [ ] , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }
int countSol ( int coeff [ ] , int n , int rhs ) { int dp [ ] = new int [ rhs + 1 ] ; Arrays . fill ( dp , 0 ) ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }
int printCountRec ( int dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }
int printCountDP ( int dist ) { int [ ] count = new int [ dist + 1 ] ; count [ 0 ] = 1 ; if ( dist >= 1 ) count [ 1 ] = 1 ; if ( dist >= 2 ) count [ 2 ] = 2 ; for ( int i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }
int countSeq ( int n ) { int nCr = 1 , res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }
int findLongestRepeatingSubSeq ( String str ) { int n = str . length ( ) ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; }
boolean isInorder ( int [ ] arr , int n ) { if ( n == 0 n == 1 ) { return true ; } for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] > arr [ i ] ) { return false ; } } return true ; }
int getMaxRec ( String str , int i , int n , int [ ] lookup ) { if ( i >= n ) { return 0 ; } if ( lookup [ i ] != - 1 ) { return lookup [ i ] ; } int ans = 1 + getMaxRec ( str , i + 1 , n , lookup ) ; if ( i + 1 < n ) { if ( str . charAt ( i ) != str . charAt ( i + 1 ) ) { ans = Math . max ( 4 + getMaxRec ( str , i + 2 , n , lookup ) , ans ) ; } else { ans = Math . max ( 3 + getMaxRec ( str , i + 2 , n , lookup ) , ans ) ; } } return lookup [ i ] = ans ; }
int getMaxWeight ( String str ) { int n = str . length ( ) ; int [ ] lookup = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { lookup [ i ] = - 1 ; } return getMaxRec ( str , 0 , str . length ( ) , lookup ) ; }
int countRec ( int digits , int esum , int osum , int isOdd , int n ) { if ( digits == n ) return ( esum - osum == 1 ) ? 1 : 0 ; if ( lookup [ digits ] [ esum ] [ osum ] [ isOdd ] != - 1 ) return lookup [ digits ] [ esum ] [ osum ] [ isOdd ] ; int ans = 0 ; if ( isOdd == 1 ) for ( int i = 0 ; i <= 9 ; i ++ ) ans += countRec ( digits + 1 , esum , osum + i , 0 , n ) ; for ( int i = 0 ; i <= 9 ; i ++ ) ans += countRec ( digits + 1 , esum + i , osum , 1 , n ) ; return lookup [ digits ] [ esum ] [ osum ] [ isOdd ] = ans ; }
int finalCount ( int n ) { int digits = 0 ; for ( int i = 0 ; i < 50 ; i ++ ) for ( int j = 0 ; j < 1000 ; j ++ ) for ( int k = 0 ; k < 1000 ; k ++ ) for ( int l = 0 ; l < 2 ; l ++ ) lookup [ i ] [ j ] [ k ] [ l ] = - 1 ; int ans = 0 ; int esum = 0 , osum = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) ans += countRec ( digits + 1 , esum + i , osum , 1 , n ) ; return ans ; }
int steps ( int source , int step , int dest ) { if ( Math . abs ( source ) > ( dest ) ) return Integer . MAX_VALUE ; if ( source == dest ) return step ; int pos = steps ( source + step + 1 , step + 1 , dest ) ; int neg = steps ( source - step - 1 , step + 1 , dest ) ; return Math . min ( pos , neg ) ; }
int countNumbersWith4 ( int n ) { int result = 0 ; for ( int x = 1 ; x <= n ; x ++ ) result += has4 ( x ) ? 1 : 0 ; return result ; }
int countNumbersWith4 ( int n ) { if ( n < 4 ) return 0 ; int d = ( int ) Math . log10 ( n ) ; int [ ] a = new int [ d + 2 ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + ( int ) Math . ceil ( Math . pow ( 10 , i - 1 ) ) ; int p = ( int ) Math . ceil ( Math . pow ( 10 , d ) ) ; int msd = n / p ; if ( msd == 4 ) return ( msd ) * a [ d ] + ( n % p ) + 1 ; if ( msd > 4 ) return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ; return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; }
int max ( int arr [ ] , int l , int h ) { int mx = arr [ l ] ; for ( int i = l + 1 ; i <= h ; i ++ ) if ( mx < arr [ i ] ) mx = arr [ i ] ; return mx ; }
int minRemovalsDP ( int arr [ ] , int n ) { int table [ ] [ ] = new int [ n ] [ n ] , gap , i , j , mn , mx ; for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { mn = min ( arr , i , j ) ; mx = max ( arr , i , j ) ; table [ i ] [ j ] = ( 2 * mn > mx ) ? 0 : min ( table [ i ] [ j - 1 ] + 1 , table [ i + 1 ] [ j ] + 1 ) ; } } return table [ 0 ] [ n - 1 ] ; }
int minRemovalsDP ( int arr [ ] , int n ) { int longest_start = - 1 , longest_end = 0 ; for ( int start = 0 ; start < n ; start ++ ) { int min = Integer . MAX_VALUE , max = Integer . MIN_VALUE ; for ( int end = start ; end < n ; end ++ ) { int val = arr [ end ] ; if ( val < min ) { min = val ; } if ( val > max ) { max = val ; } if ( 2 * min <= max ) { break ; } if ( end - start > longest_end - longest_start longest_start == - 1 ) { longest_start = start ; longest_end = end ; } } } if ( longest_start == - 1 ) { return n ; } return ( n - ( longest_end - longest_start + 1 ) ) ; }
int numberOfPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }
int numberOfPaths ( int m , int n ) { int count [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] ; + count [ i - 1 ] [ j - 1 ] ; } return count [ m - 1 ] [ n - 1 ] ; }
int numberOfPaths ( int m , int n ) { int [ ] dp = new int [ n ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] += dp [ j - 1 ] ; } } return dp [ n - 1 ] ; }
int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; }
boolean checkBSTs ( Node root1 , Node root2 ) { if ( root1 != null && root2 != null ) return true ; if ( ( root1 == null && root2 != null ) || ( root1 != null && root2 == null ) ) return false ; Vector < Integer > v1 = new Vector < Integer > ( ) ; Vector < Integer > v2 = new Vector < Integer > ( ) ; storeInorder ( root1 , v1 ) ; storeInorder ( root2 , v2 ) ; return ( v1 == v2 ) ; }
int lenghtOfLongestAP ( int set [ ] , int n ) { if ( n <= 2 ) return n ; int L [ ] [ ] = new int [ n ] [ n ] ; int llap = 2 ; for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ n - 1 ] = 2 ; for ( int j = n - 2 ; j >= 1 ; j -- ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ; else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) { L [ i ] [ j ] = 2 ; i -- ; } else { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; llap = Math . max ( llap , L [ i ] [ j ] ) ; i -- ; k ++ ; } } while ( i >= 0 ) { L [ i ] [ j ] = 2 ; i -- ; } } return llap ; }
int carAssembly ( int a [ ] [ ] , int t [ ] [ ] , int e [ ] , int x [ ] ) { int T1 [ ] = new int [ NUM_STATION ] ; int T2 [ ] = new int [ NUM_STATION ] ; int i ; T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ; T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ; for ( i = 1 ; i < NUM_STATION ; ++ i ) { T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) ; T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ; } return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ; }
long findWays ( int m , int n , int x ) { long [ ] [ ] table = new long [ n + 1 ] [ x + 1 ] ; for ( int j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= x ; j ++ ) { for ( int k = 1 ; k < j && k <= m ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; } } return table [ n ] [ x ] ; }
long findWays ( int f , int d , int s ) { long mem [ ] [ ] = new long [ d + 1 ] [ s + 1 ] ; mem [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= d ; i ++ ) { for ( int j = i ; j <= s ; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ; if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ; } } return mem [ d ] [ s ] ; }
int LCSubStr ( char X [ ] , char Y [ ] , int m , int n ) { int LCStuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCStuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 ; result = Integer . max ( result , LCStuff [ i ] [ j ] ) ; } else LCStuff [ i ] [ j ] = 0 ; } } return result ; }
int LCSubStr ( String s , String t , int n , int m ) { int dp [ ] [ ] = new int [ 2 ] [ m + 1 ] ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( s . charAt ( i - 1 ) == t . charAt ( j - 1 ) ) { dp [ i % 2 ] [ j ] = dp [ ( i - 1 ) % 2 ] [ j - 1 ] + 1 ; if ( dp [ i % 2 ] [ j ] > res ) res = dp [ i % 2 ] [ j ] ; } else dp [ i % 2 ] [ j ] = 0 ; } } return res ; }
int lcs ( int i , int j , int count ) { if ( i == 0 j == 0 ) { return count ; } if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { count = lcs ( i - 1 , j - 1 , count + 1 ) ; } count = Math . max ( count , Math . max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) ; return count ; }
int findMinInsertions ( char str [ ] , int l , int h ) { if ( l > h ) return Integer . MAX_VALUE ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Integer . min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }
int maxCrossingSum ( int arr [ ] , int l , int m , int h ) { int sum = 0 ; int left_sum = Integer . MIN_VALUE ; for ( int i = m ; i >= l ; i -- ) { sum = sum + arr [ i ] ; if ( sum > left_sum ) left_sum = sum ; } sum = 0 ; int right_sum = Integer . MIN_VALUE ; for ( int i = m + 1 ; i <= h ; i ++ ) { sum = sum + arr [ i ] ; if ( sum > right_sum ) right_sum = sum ; } return Math . max ( left_sum + right_sum , Math . max ( left_sum , right_sum ) ) ; }
int maxSubArraySum ( int arr [ ] , int l , int h ) { if ( l == h ) return arr [ l ] ; int m = ( l + h ) / 2 ; return Math . max ( Math . max ( maxSubArraySum ( arr , l , m ) , maxSubArraySum ( arr , m + 1 , h ) ) , maxCrossingSum ( arr , l , m , h ) ) ; }
boolean isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
int subsetSum ( int a [ ] , int n , int sum ) { int tab [ ] [ ] = new int [ n + 1 ] [ sum + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { tab [ i ] [ j ] = - 1 ; } } if ( sum == 0 ) return 1 ; if ( n <= 0 ) return 0 ; if ( tab [ n - 1 ] [ sum ] != - 1 ) return tab [ n - 1 ] [ sum ] ; if ( a [ n - 1 ] > sum ) return tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) ; else { if ( subsetSum ( a , n - 1 , sum ) != 0 || subsetSum ( a , n - 1 , sum - a [ n - 1 ] ) != 0 ) { return tab [ n - 1 ] [ sum ] = 1 ; } else return tab [ n - 1 ] [ sum ] = 0 ; } }
float findWater ( int i , int j , float X ) { if ( j > i ) { System . out . println ( "Incorrect Input" ) ; System . exit ( 0 ) ; } int ll = Math . round ( ( i * ( i + 1 ) ) ) ; float [ ] glass = new float [ ll + 2 ] ; int index = 0 ; glass [ index ] = X ; for ( int row = 1 ; row <= i ; ++ row ) { for ( int col = 1 ; col <= row ; ++ col , ++ index ) { X = glass [ index ] ; glass [ index ] = ( X >= 1.0f ) ? 1.0f : X ; X = ( X >= 1.0f ) ? ( X - 1 ) : 0.0f ; glass [ index + row ] += X / 2 ; glass [ index + row + 1 ] += X / 2 ; } } return glass [ ( int ) ( i * ( i - 1 ) / 2 + j - 1 ) ] ; }
int maxChainLength ( Pair arr [ ] , int n ) { int i , j , max = 0 ; int mcl [ ] = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) mcl [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] . a > arr [ j ] . b && mcl [ i ] < mcl [ j ] + 1 ) mcl [ i ] = mcl [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < mcl [ i ] ) max = mcl [ i ] ; return max ; }
void solveWordWrap ( int l [ ] , int n , int M ) { int extras [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; int lc [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; int c [ ] = new int [ n + 1 ] ; int p [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { extras [ i ] [ i ] = M - l [ i - 1 ] ; for ( int j = i + 1 ; j <= n ; j ++ ) extras [ i ] [ j ] = extras [ i ] [ j - 1 ] - l [ j - 1 ] - 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { if ( extras [ i ] [ j ] < 0 ) lc [ i ] [ j ] = MAX ; else if ( j == n && extras [ i ] [ j ] >= 0 ) lc [ i ] [ j ] = 0 ; else lc [ i ] [ j ] = extras [ i ] [ j ] * extras [ i ] [ j ] ; } } c [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { c [ j ] = MAX ; for ( int i = 1 ; i <= j ; i ++ ) { if ( c [ i - 1 ] != MAX && lc [ i ] [ j ] != MAX && ( c [ i - 1 ] + lc [ i ] [ j ] < c [ j ] ) ) { c [ j ] = c [ i - 1 ] + lc [ i ] [ j ] ; p [ j ] = i ; } } } printSolution ( p , n ) ; }
int distanceFromRoot ( Node root , int x ) { if ( root . key == x ) return 0 ; else if ( root . key > x ) return 1 + distanceFromRoot ( root . left , x ) ; return 1 + distanceFromRoot ( root . right , x ) ; }
int findDistWrapper ( Node root , int a , int b ) { int temp = 0 ; if ( a > b ) { temp = a ; a = b ; b = temp ; } return distanceBetween2 ( root , a , b ) ; }
boolean isSubsetSum ( int arr [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( arr [ n - 1 ] > sum ) return isSubsetSum ( arr , n - 1 , sum ) ; return isSubsetSum ( arr , n - 1 , sum ) || isSubsetSum ( arr , n - 1 , sum - arr [ n - 1 ] ) ; }
boolean findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; boolean [ ] part = new boolean [ sum / 2 + 1 ] ; for ( i = 0 ; i <= sum / 2 ; i ++ ) { part [ i ] = false ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = sum / 2 ; j >= arr [ i ] ; j -- ) { if ( part [ j - arr [ i ] ] == true j == arr [ i ] ) part [ j ] = true ; } } return part [ sum / 2 ] ; }
int minPalPartion ( String string , int i , int j ) { if ( i >= j || isPalindrome ( string , i , j ) ) return 0 ; int ans = Integer . MAX_VALUE , count ; for ( int k = i ; k < j ; k ++ ) { count = minPalPartion ( string , i , k ) + minPalPartion ( string , k + 1 , j ) + 1 ; ans = Math . min ( ans , count ) ; } return ans ; }
int minCut ( String a ) { int [ ] cut = new int [ a . length ( ) ] ; boolean [ ] [ ] palindrome = new boolean [ a . length ( ) ] [ a . length ( ) ] ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) { int minCut = i ; for ( int j = 0 ; j <= i ; j ++ ) { if ( a . charAt ( i ) == a . charAt ( j ) && ( i - j < 2 palindrome [ j + 1 ] [ i - 1 ] ) ) { palindrome [ j ] [ i ] = true ; minCut = Math . min ( minCut , j == 0 ? 0 : ( cut [ j - 1 ] + 1 ) ) ; } } cut [ i ] = minCut ; } return cut [ a . length ( ) - 1 ] ; }
int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ ] = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }
int cutRod ( int price [ ] , int n ) { int val [ ] = new int [ n + 1 ] ; val [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int max_val = Integer . MIN_VALUE ; for ( int j = 0 ; j < i ; j ++ ) max_val = Math . max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; }
int max ( int x , int y ) { return ( x > y ) ? x : y ; }
int binomialCoeff ( int n , int r ) { if ( r > n ) return 0 ; long m = 1000000007 ; long inv [ ] = new long [ r + 1 ] ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - ( m / i ) * inv [ ( int ) ( m % i ) ] % m ; } int ans = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { ans = ( int ) ( ( ( ans % m ) * ( inv [ i ] % m ) ) % m ) ; } for ( int i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( int ) ( ( ( ans % m ) * ( i % m ) ) % m ) ; } return ans ; }
int matrixChainMemoised ( int [ ] p , int i , int j ) { if ( i == j ) { return 0 ; } if ( dp [ i ] [ j ] != - 1 ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] = Integer . MAX_VALUE ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i ] [ j ] ; }
int MatrixChainOrder ( int [ ] p , int n ) { int i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; }
int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }
int factorial ( int n ) { int res = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { res *= i ; } return res ; }
int catalan ( int n ) { int c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
int countBST ( int n ) { int count = catalan ( n ) ; return count ; }
int countBT ( int n ) { int count = catalan ( n ) ; return count * factorial ( n ) ; }
int checkArray ( int arr [ ] , int N , int k ) { if ( N < 3 ) return - 1 ; int i , Sum = 0 , temp = 0 ; for ( i = 0 ; i < N ; i ++ ) Sum += arr [ i ] ; int R = ( k * k + k + 1 ) ; if ( Sum % R != 0 ) return 0 ; int Mid = k * ( Sum / R ) ; for ( i = 1 ; i < N - 1 ; i ++ ) { temp += arr [ i - 1 ] ; if ( arr [ i ] == Mid ) { if ( temp == Mid / k ) return i + 1 ; else return 0 ; } } return 0 ; }
void encodeString ( String str ) { String res = "" ; int small [ ] = new int [ 26 ] ; int capital [ ] = new int [ 26 ] ; int num [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { small [ i ] = 0 ; capital [ i ] = 0 ; } for ( int i = 0 ; i < 10 ; i ++ ) { num [ i ] = 0 ; } int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) { num [ str . charAt ( i ) - 48 ] = i ; } else if ( str . charAt ( i ) >= 'a' && str . charAt ( i ) <= 'z' ) { small [ str . charAt ( i ) - 97 ] = i ; } else if ( str . charAt ( i ) >= 'A' && str . charAt ( i ) <= 'Z' ) { capital [ str . charAt ( i ) - 65 ] = i ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ( str . charAt ( i ) >= 'a' && str . charAt ( i ) <= 'z' ) && small [ str . charAt ( i ) - 97 ] == i ) { int occ = str . charAt ( i ) - 96 ; while ( occ -- > 0 ) { res += str . charAt ( i ) ; } } else if ( ( str . charAt ( i ) >= 'A' && str . charAt ( i ) <= 'Z' ) && capital [ str . charAt ( i ) - 65 ] == i ) { int occ = str . charAt ( i ) - 64 ; while ( occ -- > 0 ) { res = res + str . charAt ( i ) ; } } else if ( ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) && num [ str . charAt ( i ) - 48 ] == i ) { int occ = str . charAt ( i ) - 48 ; while ( occ -- > 0 ) { res = res + str . charAt ( i ) ; } } else { res = res + str . charAt ( i ) ; } } System . out . print ( res ) ; }
void possibleEqualArray ( int A [ ] , int N ) { int [ ] pref = new int [ N ] ; pref [ 0 ] = A [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { pref [ i ] = pref [ i - 1 ] ^ A [ i ] ; } if ( pref [ N - 1 ] == 0 ) { System . out . println ( "YES" ) ; return ; } int cur_xor = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { cur_xor ^= A [ i ] ; for ( int j = 0 ; j < i ; j ++ ) { if ( j != 0 ) { int middle_xor = pref [ j - 1 ] ^ pref [ i - 1 ] ; int left_xor = pref [ j - 1 ] ; int right_xor = cur_xor ; if ( left_xor == middle_xor && middle_xor == right_xor ) { System . out . println ( "YES" ) ; return ; } } } } System . out . println ( "NO" ) ; }
void RangeTraversal ( node root , int n1 , int n2 ) { if ( root == null ) return ; node curr = root ; while ( curr != null ) { if ( curr . left == null ) { if ( curr . data <= n2 && curr . data >= n1 ) { System . out . print ( curr . data + " " ) ; } curr = curr . right ; } else { node pre = curr . left ; while ( pre . right != null && pre . right != curr ) pre = pre . right ; if ( pre . right == null ) { pre . right = curr ; curr = curr . left ; } else { pre . right = null ; if ( curr . data <= n2 && curr . data >= n1 ) { System . out . print ( curr . data + " " ) ; } curr = curr . right ; } } } }
void possibleEqualArray ( int A [ ] , int N ) { int tot_XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { tot_XOR ^= A [ i ] ; } if ( tot_XOR == 0 ) { System . out . print ( "YES" ) ; return ; } int cur_XOR = 0 ; int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { cur_XOR ^= A [ i ] ; if ( cur_XOR == tot_XOR ) { cnt ++ ; cur_XOR = 0 ; } } if ( cnt > 2 ) { System . out . print ( "YES" ) ; } else { System . out . print ( "NO" ) ; } }
void GenerateArray ( int N , int X ) { int prev_xor = X ; for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( i ^ prev_xor ) ; if ( i != N ) { System . out . print ( " " ) ; } prev_xor = i ; } }
void createGrid ( char [ ] [ ] grid , boolean is1 , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( is1 ) { grid [ i ] [ j ] = '0' ; is1 = false ; } else { grid [ i ] [ j ] = '1' ; is1 = true ; } } if ( M % 2 == 0 ) is1 = ! is1 ; } }
boolean testGrid ( char [ ] [ ] testGrid , char [ ] [ ] Grid , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( Grid [ i ] [ j ] != '*' ) { if ( Grid [ i ] [ j ] != testGrid [ i ] [ j ] ) { return false ; } } } } return true ; }
void findPossibleGrid ( int N , int M , char [ ] [ ] grid ) { char [ ] [ ] gridTest1 = new char [ N ] [ 1001 ] ; char [ ] [ ] gridTest2 = new char [ N ] [ 1001 ] ; createGrid ( gridTest1 , true , N , M ) ; createGrid ( gridTest2 , false , N , M ) ; if ( testGrid ( gridTest1 , grid , N , M ) ) { System . out . println ( "Yes" ) ; printGrid ( gridTest1 , N , M ) ; } else if ( testGrid ( gridTest2 , grid , N , M ) ) { System . out . println ( "Yes" ) ; printGrid ( gridTest2 , N , M ) ; } else { System . out . println ( "No" ) ; } }
void brute ( int ind , int l , int r ) { if ( ind == n / 2 ) { for ( int i = 0 ; i < ( int ) n ; i ++ ) System . out . print ( brr [ i ] + " " ) ; System . exit ( 0 ) ; } for ( int i = l ; i <= arr [ ind ] / 2 ; ++ i ) if ( arr [ ind ] - i <= r ) { brr [ ind ] = i ; brr [ n - ind - 1 ] = arr [ ind ] - i ; brute ( ind + 1 , i , arr [ ind ] - i ) ; } }
int minCount ( int N , int K ) { int SmallestNumber [ ] = new int [ 10 ] ; int MinimumSteps [ ] = new int [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) { SmallestNumber [ i ] = Integer . MAX_VALUE ; MinimumSteps [ i ] = Integer . MAX_VALUE ; } for ( int i = 1 ; i <= 10 ; i ++ ) { int num = K * i ; SmallestNumber [ num % 10 ] = Math . min ( SmallestNumber [ num % 10 ] , num ) ; MinimumSteps [ num % 10 ] = Math . min ( MinimumSteps [ num % 10 ] , i ) ; } if ( N < SmallestNumber [ N % 10 ] ) { return - 1 ; } else { return MinimumSteps [ N % 10 ] ; } }
boolean inRange ( node root , int low , int high ) { return root . data >= low && root . data <= high ; }
int countMinSteps ( int arr [ ] , int N ) { int val = 0 ; int mx = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { int curr = arr [ i ] ; mx = Math . max ( mx , curr ) ; val = Math . max ( val , mx - curr ) ; } long res = 0 ; while ( ( 1 << res ) - 1 < val ) { ++ res ; } return ( int ) res ; }
int func2 ( int L , int R , int K ) { if ( R - L >= 2 ) return 1 ; return Math . min ( L , L ^ R ) ; }
int func3 ( int L , int R , int K ) { if ( ( R ^ L ) > L && ( R ^ L ) < R ) return 0 ; return func2 ( L , R , K ) ; }
int func4 ( int L , int R , int K ) { if ( R - L >= 4 ) return 0 ; int minval = L ^ ( L + 1 ) ^ ( L + 2 ) ^ ( L + 3 ) ; return Math . min ( minval , func3 ( L , R , K ) ) ; }
int minimumXor ( int L , int R , int K ) { if ( K > 4 ) return 0 ; else if ( K == 4 ) return func4 ( L , R , K ) ; else if ( K == 3 ) return func3 ( L , R , K ) ; else if ( K == 2 ) return func2 ( L , R , K ) ; else return L ; }
int setBits ( long n ) { int count = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; count ++ ; } return count ; }
void findNthTerm ( int N ) { int x = setBits ( N ^ ( N - 1 ) ) ; System . out . println ( x ) ; }
void findEquation ( int A , int B , int C ) { System . out . print ( "(" + C + ")" + "x^2 +(" + B + ")x + (" + A + ") = 0" ) ; }
int findMinMoves ( int [ ] arr , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % N != 0 ) return - 1 ; int avg = sum / N ; int total = 0 ; int needCount = 0 ; for ( int i = 0 ; i < N ; i ++ ) { needCount += ( arr [ i ] - avg ) ; total = Math . max ( Math . max ( Math . abs ( needCount ) , arr [ i ] - avg ) , total ) ; } return total ; }
String checkPro ( int n , int k ) { double exp = 1.0 / k ; int KthRoot = ( int ) Math . pow ( n , exp ) ; int product = 1 ; for ( int i = 1 ; i < k + 1 ; i ++ ) { product = product * i ; } if ( product == n ) return "Yes" ; else { for ( int j = 2 ; j < KthRoot + 1 ; j ++ ) { product = product * ( j + k - 1 ) ; product = product / ( j - 1 ) ; if ( product == n ) return "Yes" ; } } return "No" ; }
int totalCombination ( int L , int R ) { int count = 0 ; int K = R - L ; if ( K < L ) return 0 ; int ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ; return count ; }
void inorder ( Node root ) { if ( root != null ) { inorder ( root . left ) ; System . out . print ( root . data + " " ) ; inorder ( root . right ) ; } }
void getZarr ( String str , int Z [ ] ) { int n = str . length ( ) ; int k ; int L = 0 ; int R = 0 ; for ( int i = 1 ; i < n ; ++ i ) { if ( i > R ) { L = R = i ; while ( R < n && str . charAt ( R - L ) == str . charAt ( R ) ) { R ++ ; } Z [ i ] = R - L ; R -- ; } else { k = i - L ; if ( Z [ k ] < R - i + 1 ) { Z [ i ] = Z [ k ] ; } else { L = i ; while ( R < n && str . charAt ( R - L ) == str . charAt ( R ) ) { R ++ ; } Z [ i ] = R - L ; R -- ; } } } }
String goodStr ( String str , String word ) { String concat = word + "$" + str ; int l = concat . length ( ) ; int [ ] Z = new int [ l ] ; getZarr ( concat , Z ) ; String res = "" ; int pSize = word . length ( ) ; for ( int i = 0 ; i < l ; ++ i ) { if ( i + pSize < l - 1 && Z [ i + pSize + 1 ] == pSize ) { i += pSize - 1 ; } else if ( i < str . length ( ) ) { res += str . charAt ( i ) ; } } return res ; }
int findCount0th ( int [ ] arr , int N , int K ) { int oddsum = 0 , evensum = 0 ; for ( int i = 1 ; i < N ; i += 2 ) { oddsum += arr [ i ] ; } for ( int i = 2 ; i < N ; i += 2 ) { evensum += arr [ i ] ; } if ( Math . abs ( oddsum - evensum ) == K ) return 1 ; else return 0 ; }
int findCount1st ( int [ ] arr , int N , int K ) { int evensum = arr [ 0 ] , oddsum = 0 ; for ( int i = 3 ; i < N ; i += 2 ) { evensum += arr [ i ] ; } for ( int i = 2 ; i < N ; i += 2 ) { oddsum += arr [ i ] ; } if ( Math . abs ( oddsum - evensum ) == K ) return 1 ; else return 0 ; }
void printDiagonalTraversal ( int [ ] [ ] nums ) { int max_size = nums [ 0 ] . length ; ArrayList < ArrayList < Integer > > v = new ArrayList < ArrayList < Integer > > ( ) ; for ( int i = 0 ; i < 2 * max_size - 1 ; i ++ ) { v . add ( new ArrayList < Integer > ( ) ) ; } for ( int i = 0 ; i < nums [ 0 ] . length ; i ++ ) { for ( int j = 0 ; j < nums [ 0 ] . length ; j ++ ) { v . get ( i + j ) . add ( nums [ i ] [ j ] ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { for ( int j = v . get ( i ) . size ( ) - 1 ; j >= 0 ; j -- ) { System . out . print ( v . get ( i ) . get ( j ) + " " ) ; } } }
void printDiagonalTraversal ( int [ ] [ ] nums ) { int m = nums . length ; Queue < pair > q = new LinkedList < > ( ) ; q . add ( new pair ( 0 , 0 ) ) ; while ( ! q . isEmpty ( ) ) { pair p = q . peek ( ) ; q . remove ( ) ; System . out . print ( nums [ p . first ] [ p . second ] + " " ) ; if ( p . second == 0 && p . first + 1 < m ) { q . add ( new pair ( p . first + 1 , p . second ) ) ; } if ( p . second + 1 < nums [ p . first ] . length ) q . add ( new pair ( p . first , p . second + 1 ) ) ; } }
void flipBitsOfAandB ( int A , int B ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A & ( 1 << i ) ) & ( B & ( 1 << i ) ) ) != 0 ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } System . out . print ( A + " " + B ) ; }
void flipBitsOfAandB ( int A , int B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; System . out . print ( A + " " + B ) ; }
void isValid ( String s ) { int n = ( int ) Math . sqrt ( s . length ( ) ) ; char check = s . charAt ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = i , y = i ; while ( x >= 0 && y < n ) { if ( s . charAt ( ( n * x ) + y ) != check || s . charAt ( ( n * y ) + x ) != check ) { System . out . print ( "No" ) ; return ; } x -- ; y ++ ; } } System . out . print ( "Yes" ) ; }
void minimumOperations ( String orig_str , int m , int n ) { String orig = orig_str ; int turn = 1 ; int j = 1 ; for ( int i = 0 ; i < orig_str . length ( ) ; i ++ ) { String m_cut = orig_str . substring ( orig_str . length ( ) - m ) ; orig_str = orig_str . substring ( 0 , orig_str . length ( ) - m ) ; orig_str = m_cut + orig_str ; j = j + 1 ; if ( ! orig . equals ( orig_str ) ) { turn = turn + 1 ; String n_cut = orig_str . substring ( orig_str . length ( ) - n ) ; orig_str = orig_str . substring ( 0 , orig_str . length ( ) - n ) ; orig_str = n_cut + orig_str ; j = j + 1 ; } if ( orig . equals ( orig_str ) ) { break ; } turn = turn + 1 ; } System . out . println ( turn ) ; }
int gcd ( int a , int b ) { if ( a < b ) { int t = a ; a = b ; b = t ; } if ( a % b == 0 ) return b ; return gcd ( b , a % b ) ; }
void printAnswer ( int x , int y ) { int val = gcd ( x , y ) ; if ( ( val & ( val - 1 ) ) == 0 ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
int toDigit ( char ch ) { return ( ch - '0' ) ; }
void powerOf10 ( ) { power [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) power [ i ] = power [ i - 1 ] * 10 ; }
void precomputePrefix ( char [ ] str , int n ) { pref [ 0 ] = str [ 0 ] - '0' ; for ( int i = 1 ; i < n ; i ++ ) pref [ i ] = pref [ i - 1 ] + toDigit ( str [ i ] ) ; }
int triangularNumber ( int i ) { int res = i * ( i + 1 ) / 2 ; return res ; }
void sumOfSubarrayProd ( int arr [ ] , int n ) { int ans = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int incr = arr [ i ] * ( 1 + res ) ; ans += incr ; res = incr ; } System . out . println ( ans ) ; }
int OddLengthSum ( int [ ] arr ) { int sum = 0 ; int l = arr . length ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = i ; j < l ; j += 2 ) { for ( int k = i ; k <= j ; k ++ ) { sum += arr [ k ] ; } } } return sum ; }
int phi ( int n ) { int result = 1 ; for ( int p = 2 ; p < n ; p ++ ) { if ( __gcd ( p , n ) == 1 ) { result ++ ; } } return result ; }
boolean sameEulerTotient ( int n ) { return phi ( n ) == phi ( 2 * n ) ; }
int sameEulerTotient ( int N ) { return ( N & 1 ) ; }
Vector < Integer > restore ( int arr [ ] , int N ) { Vector < Integer > result = new Vector < > ( ) ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) && mp . get ( arr [ i ] ) == 0 ) { result . add ( arr [ i ] ) ; if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } else mp . put ( arr [ i ] , 0 ) ; } return result ; }
void print_result ( Vector < Integer > result ) { for ( int i = 0 ; i < result . size ( ) ; i ++ ) System . out . print ( result . get ( i ) + " " ) ; }
Vector < Integer > restore ( int arr [ ] , int N ) { Vector < Integer > result = new Vector < Integer > ( ) ; int count1 = 1 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { s . add ( arr [ i ] ) ; if ( s . size ( ) == count1 ) { result . add ( arr [ i ] ) ; count1 ++ ; } } return result ; }
void print_result ( Vector < Integer > result ) { for ( int i = 0 ; i < result . size ( ) ; i ++ ) System . out . print ( result . get ( i ) + " " ) ; }
boolean checkReverseBitonic ( int arr [ ] , int n ) { int i , j , f = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) continue ; if ( arr [ i ] == arr [ i - 1 ] ) return false ; else { f = 1 ; break ; } } if ( i == n ) return true ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j - 1 ] ) continue ; if ( arr [ i ] == arr [ i - 1 ] ) return false ; else { if ( f == 1 ) return false ; } } return true ; }
int sum ( int n ) { return n * ( n - 1 ) / 2 ; }
int getFirstSetBitPos ( int n ) { return ( int ) ( Math . log ( n & - n ) / Math . log ( 2 ) ) ; }
int oddFirst ( int a , int b ) { int steps_a = getFirstSetBitPos ( a ) ; int steps_b = getFirstSetBitPos ( b ) ; if ( steps_a == steps_b ) { return - 1 ; } else if ( steps_a > steps_b ) { return b ; } else { return a ; } }
int nCycle ( int N ) { return ( N ) * ( N - 1 ) + 1 ; }
int checkReverseBitonic ( String s ) { int i , j ; for ( i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) < s . charAt ( i - 1 ) ) continue ; if ( s . charAt ( i ) >= s . charAt ( i - 1 ) ) break ; } if ( i == s . length ( ) - 1 ) return 1 ; for ( j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) > s . charAt ( j - 1 ) ) continue ; if ( s . charAt ( j ) <= s . charAt ( j - 1 ) ) break ; } i = j ; if ( i != s . length ( ) ) return 0 ; return 1 ; }
void solve ( long n ) { long s = 0 ; for ( int l = 1 ; l <= n ; ) { int r = ( int ) ( n / Math . floor ( n / l ) ) ; int x = ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ; int y = ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ; int p = ( int ) ( ( n / l ) % m ) ; s = ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ; s %= m ; l = r + 1 ; } System . out . print ( ( s + m ) % m ) ; }
int solve ( int n ) { int i , sum = 0 ; while ( n > 0 ) { i = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; n = n - ( int ) Math . pow ( 2 , i ) ; sum = sum + ( i + 1 ) + Count ( i - 1 ) ; } return sum ; }
int smallestNum ( int N ) { float x = ( float ) ( Math . pow ( 10 , ( N - 1 ) / 2.0 ) ) ; return ( int ) ( Math . ceil ( x ) ) ; }
int checkBitonic ( char [ ] s ) { int i , j ; for ( i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] > s [ i - 1 ] ) continue ; if ( s [ i ] <= s [ i - 1 ] ) break ; } if ( i == s . length - 1 ) return 1 ; for ( j = i + 1 ; j < s . length ; j ++ ) { if ( s [ j ] < s [ j - 1 ] ) continue ; if ( s [ j ] >= s [ j - 1 ] ) break ; } i = j ; if ( i != s . length ) return 0 ; return 1 ; }
void findArray ( int [ ] a , int n , int P ) { int mi = Arrays . stream ( a ) . min ( ) . getAsInt ( ) ; int ctr = 0 ; mi = Math . max ( 0 , mi - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] -= mi ; ctr += mi ; } int i = P - 1 ; int start = - 1 ; while ( true ) { if ( a [ i ] == 0 ) { start = i ; break ; } a [ i ] -= 1 ; ctr += 1 ; i = ( i - 1 + n ) % n ; } a [ start ] = ctr ; for ( i = 0 ; i < n ; i ++ ) { System . out . print ( a [ i ] + ", " ) ; } }
void checkstateA ( String n ) { if ( n . charAt ( 0 ) == '0' ) stateB ( n . substring ( 1 ) ) ; else stateD ( n . substring ( 1 ) ) ; }
void stateB ( String n ) { if ( n . length ( ) == 0 ) System . out . println ( "string not accepted" ) ; else { if ( n . charAt ( 0 ) == '1' ) stateC ( n . substring ( 1 ) ) ; else stateD ( n . substring ( 1 ) ) ; } }
void stateD ( String n ) { if ( n . length ( ) == 0 ) System . out . println ( "string not accepted" ) ; else { if ( n . charAt ( 0 ) == '1' ) stateD ( n . substring ( 1 ) ) ; else stateE ( n . substring ( 1 ) ) ; } }
void stateE ( String n ) { if ( n . length ( ) == 0 ) System . out . println ( "string not accepted" ) ; else { if ( n . charAt ( 0 ) == '0' ) stateE ( n . substring ( 1 ) ) ; else stateF ( n . substring ( 1 ) ) ; } }
void stateF ( String n ) { if ( n . length ( ) == 0 ) System . out . println ( "string accepred" ) ; else { if ( n . charAt ( 0 ) == '1' ) stateD ( n . substring ( 1 ) ) ; else stateE ( n . substring ( 1 ) ) ; } }
int HogbenNumber ( int a ) { int p = ( int ) ( Math . pow ( a , 2 ) - a + 1 ) ; return p ; }
int countKCountdown ( int arr [ ] , int N , int K ) { int flag = - 1 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) flag = K ; if ( arr [ i ] == flag ) flag -- ; else flag = - 1 ; if ( flag == 0 ) count ++ ; } return count ; }
int findDistinctSums ( int N ) { return ( 2 * N - 1 ) ; }
Pair < Integer , Integer > count_ht ( char s , int N ) { Pair < Integer , Integer > p = new Pair < Integer , Integer > ( 0 , 0 ) ; if ( s == 'H' ) { p = new Pair < Integer , Integer > ( ( int ) Math . floor ( N / 2.0 ) , ( int ) Math . ceil ( N / 2.0 ) ) ; } else if ( s == 'T' ) { p = new Pair < Integer , Integer > ( ( int ) Math . ceil ( N / 2.0 ) , ( int ) Math . floor ( N / 2.0 ) ) ; } return p ; }
int getProduct ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; }
int productinRange ( int l , int r ) { if ( r - l > 9 ) return 0 ; else { int p = 1 ; for ( int i = l ; i <= r ; i ++ ) p *= getProduct ( i ) ; return p ; } }
int checkQwertyRow ( char x ) { Character [ ] first_row1 = { '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '0' , '-' , '=' } ; Set < Character > first_row = new HashSet < > ( Arrays . asList ( first_row1 ) ) ; Character [ ] second_row1 = { 'Q' , 'W' , 'E' , 'R' , 'T' , 'Y' , 'U' , 'I' , 'O' , 'P' , '[' , ']' , 'q' , 'w' , 'e' , 'r' , 't' , 'y' , 'u' , 'i' , 'o' , 'p' } ; Set < Character > second_row = new HashSet < > ( Arrays . asList ( second_row1 ) ) ; Character [ ] third_row1 = { 'A' , 'S' , 'D' , 'F' , 'G' , 'H' , 'J' , 'K' , 'L' , ';' , ':' , 'a' , 's' , 'd' , 'f' , 'g' , 'h' , 'j' , 'k' , 'l' } ; Set < Character > third_row = new HashSet < > ( Arrays . asList ( third_row1 ) ) ; Character [ ] fourth_row1 = { 'Z' , 'X' , 'C' , 'V' , 'B' , 'N' , 'M' , ',' , '.' , '/' , 'z' , 'x' , 'c' , 'v' , 'b' , 'n' , 'm' } ; Set < Character > fourth_row = new HashSet < > ( Arrays . asList ( fourth_row1 ) ) ; if ( first_row . contains ( x ) ) { return 1 ; } else if ( second_row . contains ( x ) ) { return 2 ; } else if ( third_row . contains ( x ) ) { return 3 ; } else if ( fourth_row . contains ( x ) ) { return 4 ; } return 0 ; }
boolean checkValidity ( String str ) { char x = str . charAt ( 0 ) ; int row = checkQwertyRow ( x ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { x = str . charAt ( i ) ; if ( row != checkQwertyRow ( x ) ) { return false ; } } return true ; }
int fib ( long n ) { int f0 = 0 ; int f1 = 1 ; if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; else { int rem = ( int ) ( n % 60 ) ; if ( rem == 0 ) return 0 ; for ( int i = 2 ; i < rem + 3 ; i ++ ) { int f = ( f0 + f1 ) % 60 ; f0 = f1 ; f1 = f ; } int s = f1 - 1 ; return s ; } }
void sumBetweenZero ( int arr [ ] , int N ) { int i = 0 ; Vector < Integer > A = new Vector < Integer > ( ) ; int sum = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { i ++ ; break ; } } for ( ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { A . add ( sum ) ; sum = 0 ; } else { sum += arr [ i ] ; } } for ( int j = 0 ; j < A . size ( ) ; j ++ ) { System . out . print ( A . get ( j ) + " " ) ; } if ( A . size ( ) == 0 ) System . out . print ( "-1" ) ; }
int nthTerm ( int N ) { if ( N == 1 ) { return 2 ; } return ( ( N - 1 ) * 13 ) + nthTerm ( N - 1 ) ; }
void maximumSubsequence ( int arr [ ] , int N ) { HashMap < Integer , Integer > M = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( M . containsKey ( arr [ i ] ) ) { M . put ( arr [ i ] , M . get ( arr [ i ] ) + 1 ) ; } else { M . put ( arr [ i ] , 1 ) ; } } int distinct_size = M . size ( ) ; int maxFreq = 1 ; for ( Map . Entry < Integer , Integer > it : M . entrySet ( ) ) { maxFreq = Math . max ( maxFreq , it . getValue ( ) ) ; } System . out . print ( Math . max ( Math . min ( distinct_size , maxFreq - 1 ) , Math . min ( distinct_size - 1 , maxFreq ) ) ) ; }
String decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 2 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; i ++ ; } n = n / 16 ; } String hexCode = "" ; if ( i == 2 ) { hexCode += hexaDeciNum [ 0 ] ; hexCode += hexaDeciNum [ 1 ] ; } else if ( i == 1 ) { hexCode = "0" ; hexCode += hexaDeciNum [ 0 ] ; } else if ( i == 0 ) hexCode = "00" ; return hexCode ; }
String convertRGBtoHex ( int R , int G , int B ) { if ( ( R >= 0 && R <= 255 ) && ( G >= 0 && G <= 255 ) && ( B >= 0 && B <= 255 ) ) { String hexCode = "#" ; hexCode += decToHexa ( R ) ; hexCode += decToHexa ( G ) ; hexCode += decToHexa ( B ) ; return hexCode ; } else return "-1" ; }
boolean isKAlternating ( String s , int k ) { if ( s . length ( ) < k ) return false ; int checker = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int bitAtIndex = s . charAt ( i ) - 'a' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } for ( int i = k ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i - k ) != s . charAt ( i ) ) return false ; return true ; }
void findFactors ( int N ) { int temp = ( int ) Math . sqrt ( N ) ; int [ ] factor = new int [ MAX ] ; Arrays . fill ( factor , 1 ) ; int i , j , k ; int len1 = 1 ; while ( temp % 2 == 0 ) { factor [ len1 ++ ] = 2 ; factor [ len1 ++ ] = 2 ; temp /= 2 ; } for ( j = 3 ; j < Math . sqrt ( temp ) ; j += 2 ) { while ( temp % j == 0 ) { factor [ len1 ++ ] = j ; factor [ len1 ++ ] = j ; temp /= j ; } } if ( temp > 2 ) { factor [ len1 ++ ] = temp ; factor [ len1 ++ ] = temp ; } int [ ] [ ] M = new int [ len1 ] [ MAX ] ; int tpc = 0 , tpr = 0 ; M [ 0 ] [ 0 ] = 1 ; j = 1 ; while ( j < len1 ) { if ( factor [ j ] != factor [ j - 1 ] ) { tpr ++ ; M [ tpr ] [ 0 ] = factor [ j ] ; j ++ ; tpc = 1 ; } else { M [ tpr ] [ tpc ] = M [ tpr ] [ tpc - 1 ] * factor [ j ] ; j ++ ; tpc ++ ; } } int [ ] arr1 = new int [ MAX ] ; int [ ] arr2 = new int [ MAX ] ; int l1 , l2 ; l1 = l2 = 1 ; arr1 [ 0 ] = arr2 [ 0 ] = 1 ; for ( i = 1 ; i < tpr + 1 ; i ++ ) { for ( j = 0 ; M [ i ] [ j ] != 0 ; j ++ ) { for ( k = 0 ; k < l1 ; k ++ ) { arr2 [ l2 ++ ] = arr1 [ k ] * M [ i ] [ j ] ; } } for ( j = l1 ; j < l2 ; j ++ ) { arr1 [ j ] = arr2 [ j ] ; } l1 = l2 ; } for ( i = 0 ; i < l2 ; i ++ ) { System . out . print ( arr2 [ i ] + " " ) ; } }
int countSubstring ( String S , int n ) { int ans = 0 ; int i = 0 ; while ( i < n ) { int cnt0 = 0 , cnt1 = 0 ; if ( S . charAt ( i ) == '0' ) { while ( i < n && S . charAt ( i ) == '0' ) { cnt0 ++ ; i ++ ; } int j = i ; while ( j < n && S . charAt ( j ) == '1' ) { cnt1 ++ ; j ++ ; } } else { while ( i < n && S . charAt ( i ) == '1' ) { cnt1 ++ ; i ++ ; } int j = i ; while ( j < n && S . charAt ( j ) == '0' ) { cnt0 ++ ; j ++ ; } } ans += Math . min ( cnt0 , cnt1 ) ; } return ans ; }
void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) { System . out . print ( ( 3 * i * ( i - 1 ) + 1 ) + " " ) ; i ++ ; } }
int [ ] zArray ( int arr [ ] ) { int z [ ] ; int n = arr . length ; z = new int [ n ] ; int r = 0 , l = 0 ; for ( int k = 1 ; k < n ; k ++ ) { if ( k > r ) { r = l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } else { int k1 = k - l ; if ( z [ k1 ] < r - k + 1 ) z [ k ] = z [ k1 ] ; else { l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } } } return z ; }
int [ ] mergeArray ( int A [ ] , int B [ ] ) { int n = A . length ; int m = B . length ; int z [ ] ; int c [ ] = new int [ n + m + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) c [ i ] = B [ i ] ; c [ m ] = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) c [ m + i + 1 ] = A [ i ] ; z = zArray ( c ) ; return z ; }
void findZArray ( int A [ ] , int B [ ] , int n ) { int flag = 0 ; int z [ ] ; z = mergeArray ( A , B ) ; for ( int i = 0 ; i < z . length ; i ++ ) { if ( z [ i ] == n ) { System . out . print ( ( i - n - 1 ) + " " ) ; flag = 1 ; } } if ( flag == 0 ) { System . out . println ( "Not Found" ) ; } }
void insertNode ( Node root , int x ) { Node p = root , q = null ; while ( p != null ) { q = p ; if ( p . data < x ) p = p . right ; else p = p . left ; } if ( q == null ) p = createNode ( x ) ; else { if ( q . data < x ) q . right = createNode ( x ) ; else q . left = createNode ( x ) ; } }
int maxelpath ( Node q , int x ) { Node p = q ; int mx = - 1 ; while ( p . data != x ) { if ( p . data > x ) { mx = Math . max ( mx , p . data ) ; p = p . left ; } else { mx = Math . max ( mx , p . data ) ; p = p . right ; } } return Math . max ( mx , x ) ; }
int maximumElement ( Node root , int x , int y ) { Node p = root ; while ( ( x < p . data && y < p . data ) || ( x > p . data && y > p . data ) ) { if ( x < p . data && y < p . data ) p = p . left ; else if ( x > p . data && y > p . data ) p = p . right ; } return Math . max ( maxelpath ( p , x ) , maxelpath ( p , y ) ) ; }
void q1 ( String s , int i ) { if ( i == s . length ( ) ) { System . out . println ( "Yes" ) ; return ; } if ( s . charAt ( i ) == 'a' ) q1 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; }
void q2 ( String s , int i ) { if ( i == s . length ( ) ) { System . out . println ( "No" ) ; return ; } if ( s . charAt ( i ) == 'a' ) q1 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; }
void q4 ( String s , int i ) { if ( i == s . length ( ) ) { System . out . println ( "No" ) ; return ; } if ( s . charAt ( i ) == 'a' ) q4 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; }
void q0 ( String s , int i ) { if ( i == s . length ( ) ) { System . out . println ( "No" ) ; return ; } if ( s . charAt ( i ) == 'a' ) q1 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; }
int nthTerm ( int N ) { int nth = 0 , first_term = 4 ; int pi = 1 , po = 1 ; int n = N ; while ( n > 1 ) { pi *= n - 1 ; n -- ; po *= 2 ; } nth = ( first_term * pi ) / po ; return nth ; }
void q1 ( String s , int i ) { System . out . print ( "q1->" ) ; if ( i == s . length ( ) ) { System . out . println ( "NO" ) ; return ; } if ( s . charAt ( i ) == '0' ) q1 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; }
void q2 ( String s , int i ) { System . out . print ( "q2->" ) ; if ( i == s . length ( ) ) { System . out . println ( "NO " ) ; return ; } if ( s . charAt ( i ) == '0' ) q4 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; }
void q3 ( String s , int i ) { System . out . print ( "q3->" ) ; if ( i == s . length ( ) ) { System . out . println ( "YES" ) ; return ; } if ( s . charAt ( i ) == '0' ) q4 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; }
void q4 ( String s , int i ) { System . out . print ( "q4->" ) ; if ( i == s . length ( ) ) { System . out . println ( "YES" ) ; return ; } if ( s . charAt ( i ) == '0' ) q1 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; }
void q0 ( String s , int i ) { System . out . print ( "q0->" ) ; if ( i == s . length ( ) ) { System . out . println ( "NO" ) ; return ; } if ( s . charAt ( i ) == '0' ) q1 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; }
int findSum ( int [ ] arr , int n , int k ) { if ( k <= n - 2 ) return ( arr [ n - 1 ] - arr [ 0 ] ) ; return 0 ; }
int finalNum ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { result = __gcd ( result , arr [ i ] ) ; } return result ; }
int maxSubStr ( String str , int n ) { int count0 = 0 , count1 = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '0' ) { count0 ++ ; } else { count1 ++ ; } if ( count0 == count1 ) { cnt ++ ; } } if ( cnt == 0 ) { return - 1 ; } return cnt ; }
boolean isSatisfied ( char [ ] str , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( ! isVowel ( str [ i ] ) && ! isVowel ( str [ i - 1 ] ) ) { return false ; } } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( isVowel ( str [ i ] ) && ! isVowel ( str [ i - 1 ] ) && ! isVowel ( str [ i + 1 ] ) ) { return false ; } } return true ; }
long squareDigitSum ( String s ) { long lengthN = s . length ( ) ; long result = ( lengthN / 9 ) * 81 + ( long ) Math . pow ( ( lengthN % 9 ) , 2 ) ; return result ; }
int getElement ( int N , int r , int c ) { if ( r > c ) return 0 ; if ( r == 1 ) { return c ; } int a = ( r + 1 ) * ( int ) ( Math . pow ( 2 , ( r - 2 ) ) ) ; int d = ( int ) ( Math . pow ( 2 , ( r - 1 ) ) ) ; c = c - r ; int element = a + d * c ; return element ; }
void computeLPSArray ( char [ ] pat , int M , int [ ] lps ) { int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < M ) { if ( pat [ i ] == pat [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } }
void CntSubstr ( char [ ] s , int l ) { int hash = 0 ; for ( int i = 0 ; i < l ; i ++ ) { hash = ( hash * x + ( s [ i ] - 97 ) ) % mod ; } int pow_l = 1 ; for ( int i = 0 ; i < l - 1 ; i ++ ) { pow_l = ( pow_l * x ) % mod ; } HashSet < Integer > result = new HashSet < Integer > ( ) ; result . add ( hash ) ; for ( int i = l ; i < s . length ; i ++ ) { hash = ( ( hash - pow_l * ( s [ i - l ] - 97 ) + 2 * mod ) * x + ( s [ i ] - 97 ) ) % mod ; result . add ( hash ) ; } System . out . println ( result . size ( ) ) ; }
int LengthlongestPrefixSuffix ( String s ) { int n = s . length ( ) ; int lps [ ] = new int [ n ] ; lps [ 0 ] = 0 ; int len = 0 ; int i = 1 ; while ( i < n ) { if ( s . charAt ( i ) == s . charAt ( len ) ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } int res = lps [ n - 1 ] ; return ( res > n / 2 ) ? n / 2 : res ; }
int no_of_characters ( int M ) { int k = 1 ; while ( true ) { if ( ( int ) Math . pow ( 2 , k + 1 ) - 2 < M ) k ++ ; else break ; } return k ; }
String updateString ( String S , String A , String B ) { int l = A . length ( ) ; for ( int i = 0 ; i + l <= S . length ( ) ; i ++ ) { String curr = S . substring ( i , i + l ) ; if ( curr . equals ( A ) ) { String new_string = S . substring ( 0 , i ) + B + S . substring ( i + l , S . length ( ) ) ; S = new_string ; i += l - 1 ; } else { String new_string = S . substring ( 0 , i ) + A + S . substring ( i + l , S . length ( ) ) ; S = new_string ; i += l - 1 ; } } return S ; }
int findCount ( String str1 , String str2 ) { int len = str1 . length ( ) ; int len2 = str2 . length ( ) ; int ans = Integer . MAX_VALUE ; int [ ] hash1 = new int [ 26 ] ; int [ ] hash2 = new int [ 26 ] ; for ( int i = 0 ; i < len ; i ++ ) hash1 [ ( int ) ( str1 . charAt ( i ) - 'a' ) ] ++ ; for ( int i = 0 ; i < len2 ; i ++ ) hash2 [ ( int ) ( str2 . charAt ( i ) - 'a' ) ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( hash2 [ i ] != 0 ) ans = Math . min ( ans , hash1 [ i ] / hash2 [ i ] ) ; return ans ; }
int getEndingIndex ( String str , int n , int i ) { i ++ ; while ( i < n ) { char curr = str . charAt ( i ) ; char prev = str . charAt ( i - 1 ) ; if ( ( curr == 'a' && prev == 'z' ) || ( curr - prev == 1 ) ) i ++ ; else break ; } return i - 1 ; }
void printPattern ( int n , int m ) { if ( m > 2 * ( n + 1 ) m < n - 1 ) { System . out . print ( "-1" ) ; } else if ( Math . abs ( n - m ) <= 1 ) { while ( n > 0 && m > 0 ) { System . out . print ( "01" ) ; n -- ; m -- ; } if ( n != 0 ) { System . out . print ( "0" ) ; } if ( m != 0 ) { System . out . print ( "1" ) ; } } else { while ( m - n > 1 && n > 0 ) { System . out . print ( "110" ) ; m = m - 2 ; n = n - 1 ; } while ( n > 0 ) { System . out . print ( "10" ) ; n -- ; m -- ; } while ( m > 0 ) { System . out . print ( "1" ) ; m -- ; } } }
void printPermutation ( int N , int K ) { Vector < Integer > res = new Vector < > ( ) ; int l = 1 , r = N , flag = 0 ; for ( int i = 0 ; i < K ; i ++ ) { if ( flag == 0 ) { res . add ( l ) ; l ++ ; } else { res . add ( r ) ; r -- ; } flag ^= 1 ; } if ( flag != 1 ) { for ( int i = r ; i >= l ; i -- ) { res . add ( i ) ; } } else { for ( int i = l ; i <= r ; i ++ ) { res . add ( i ) ; } } for ( Integer i : res ) { System . out . print ( i + " " ) ; } }
boolean hasDigit ( HashMap < Integer , Integer > hashMap , int digit ) { if ( hashMap . containsKey ( digit ) && hashMap . get ( digit ) > 0 ) { hashMap . put ( digit , hashMap . get ( digit ) - 1 ) ; return true ; } return false ; }
void compute_z ( String s , int z [ ] ) { int l = 0 , r = 0 ; int n = s . length ( ) ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { if ( i > r ) { l = i ; r = i ; while ( r < n && s . charAt ( r - l ) == s . charAt ( r ) ) r ++ ; z [ i ] = r - l ; r -- ; } else { int k = i - l ; if ( z [ k ] < r - i + 1 ) { z [ i ] = z [ k ] ; } else { l = i ; while ( r < n && s . charAt ( r - l ) == s . charAt ( r ) ) r ++ ; z [ i ] = r - l ; r -- ; } } } }
int countPermutation ( String a , String b ) { b = b + b ; b = b . substring ( 0 , b . length ( ) - 1 ) ; int ans = 0 ; String s = a + "$" + b ; int n = s . length ( ) ; int z [ ] = new int [ n ] ; compute_z ( s , z ) ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { if ( z [ i ] == a . length ( ) ) ans ++ ; } return ans ; }
int countDecreasing ( int A [ ] , int n ) { int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( A [ i + 1 ] < A [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
int doMatch ( String A , String B ) { for ( int i = 0 ; i < A . length ( ) ; i ++ ) { if ( A . charAt ( i ) != '*' && B . charAt ( i ) != '*' ) { if ( A . charAt ( i ) != B . charAt ( i ) ) return 0 ; } } return 1 ; }
boolean printRLE ( String str , String typed ) { int n = str . length ( ) , m = typed . length ( ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) != typed . charAt ( j ) ) return false ; if ( isVowel ( str . charAt ( i ) ) == false ) { j ++ ; continue ; } int count1 = 1 ; while ( i < n - 1 && str . charAt ( i ) == str . charAt ( i + 1 ) ) { count1 ++ ; i ++ ; } int count2 = 1 ; while ( j < m - 1 && typed . charAt ( j ) == str . charAt ( i ) ) { count2 ++ ; j ++ ; } if ( count1 > count2 ) return false ; } return true ; }
int minimumChar ( String S1 , String S2 ) { int n = S1 . length ( ) ; int m = S2 . length ( ) ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < m - n + 1 ; i ++ ) { int minRemovedChar = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( S1 . charAt ( j ) != S2 . charAt ( i + j ) ) { minRemovedChar ++ ; } } ans = Math . min ( minRemovedChar , ans ) ; } return ans ; }
int fact ( int N ) { int i , product = 1 ; for ( i = 1 ; i <= N ; i ++ ) product = product * i ; return product ; }
int nthTerm ( int N ) { return ( N * N ) * fact ( N ) ; }
int factorial ( int N ) { int fact = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fact = fact * i ; return fact ; }
int nthTerm ( int N ) { return ( factorial ( N ) * ( N + 2 ) / 2 ) ; }
int factorial ( int N ) { if ( N == 0 N == 1 ) return 1 ; return N * factorial ( N - 1 ) ; }
int nthTerm ( int N ) { return ( factorial ( N ) * ( N + 2 ) / 2 ) ; }
boolean check ( String S1 , String S2 ) { int n1 = S1 . length ( ) ; int n2 = S2 . length ( ) ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( mp . containsKey ( ( int ) S1 . charAt ( i ) ) ) { mp . put ( ( int ) S1 . charAt ( i ) , mp . get ( ( int ) S1 . charAt ( i ) ) + 1 ) ; } else { mp . put ( ( int ) S1 . charAt ( i ) , 1 ) ; } } for ( int i = 0 ; i < n2 ; i ++ ) { if ( mp . containsKey ( ( int ) S2 . charAt ( i ) ) ) { mp . put ( ( int ) S2 . charAt ( i ) , mp . get ( ( int ) S2 . charAt ( i ) ) - 1 ) ; } else if ( mp . containsKey ( S2 . charAt ( i ) - 1 ) && mp . containsKey ( S2 . charAt ( i ) - 2 ) ) { mp . put ( ( S2 . charAt ( i ) - 1 ) , mp . get ( S2 . charAt ( i ) - 1 ) - 1 ) ; mp . put ( ( S2 . charAt ( i ) - 2 ) , mp . get ( S2 . charAt ( i ) - 2 ) - 1 ) ; } else { return false ; } } return true ; }
void state1 ( char c ) { if ( c == 't' c == 'T' ) dfa = 1 ; else if ( c == 'h' c == 'H' ) dfa = 2 ; else dfa = 0 ; }
void state2 ( char c ) { if ( c == 'e' c == 'E' ) dfa = 3 ; else dfa = 0 ; }
void state3 ( char c ) { if ( c == 't' c == 'T' ) dfa = 1 ; else dfa = 0 ; }
boolean isAccepted ( char str [ ] ) { int len = str . length ; for ( int i = 0 ; i < len ; i ++ ) { if ( dfa == 0 ) start ( str [ i ] ) ; else if ( dfa == 1 ) state1 ( str [ i ] ) ; else if ( dfa == 2 ) state2 ( str [ i ] ) ; else state3 ( str [ i ] ) ; } return ( dfa != 3 ) ; }
int isSubstring ( String s1 , String s2 ) { int M = s1 . length ( ) ; int N = s2 . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 . charAt ( i + j ) != s1 . charAt ( j ) ) break ; if ( j == M ) return i ; } return - 1 ; }
int countFreq ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int res = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) { if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) { break ; } } if ( j == M ) { res ++ ; j = 0 ; } } return res ; }
int countPattern ( String str ) { int len = str . length ( ) ; boolean oneSeen = false ; for ( int i = 0 ; i < len ; i ++ ) { char getChar = str . charAt ( i ) ; if ( getChar == '1' && oneSeen == true ) { if ( str . charAt ( i - 1 ) == '0' ) count ++ ; } if ( getChar == '1' && oneSeen == false ) oneSeen = true ; if ( getChar != '0' && str . charAt ( i ) != '1' ) oneSeen = false ; } return count ; }
int patternCount ( String str ) { char last = str . charAt ( 0 ) ; int i = 1 , counter = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) == '0' && last == '1' ) { while ( str . charAt ( i ) == '0' ) i ++ ; if ( str . charAt ( i ) == '1' ) counter ++ ; } last = str . charAt ( i ) ; i ++ ; } return counter ; }
int maxPrefix ( String s , String t ) { int count = 0 ; for ( int i = 0 ; i < t . length ( ) ; i ++ ) { if ( count == s . length ( ) ) break ; if ( t . charAt ( i ) == s . charAt ( count ) ) count ++ ; } return count ; }
void translate ( char str [ ] ) { for ( int i = 1 ; i < str . length ; i ++ ) { if ( str [ i - 1 ] == 'A' && str [ i ] == 'B' ) { str [ i - 1 ] = 'C' ; int j ; for ( j = i ; j < str . length - 1 ; j ++ ) str [ j ] = str [ j + 1 ] ; str [ j ] = ' ' ; } } return ; }
boolean isvalid ( int row , int col , int prevRow , int prevCol ) { return ( row >= 0 ) && ( row < ROW ) && ( col >= 0 ) && ( col < COL ) && ! ( row == prevRow && col == prevCol ) ; }
int getNextState ( char [ ] pat , int M , int state , int x ) { if ( state < M && x == pat [ state ] ) return state + 1 ; int ns , i ; for ( ns = state ; ns > 0 ; ns -- ) { if ( pat [ ns - 1 ] == x ) { for ( i = 0 ; i < ns - 1 ; i ++ ) if ( pat [ i ] != pat [ state - ns + 1 + i ] ) break ; if ( i == ns - 1 ) return ns ; } } return 0 ; }
void calculate ( String ans ) { int dp [ ] = new int [ 26 ] ; for ( int i = 0 ; i < ans . length ( ) ; ++ i ) { dp [ ans . charAt ( i ) - 'A' ] ++ ; } for ( int i = 0 ; i < dp . length ; ++ i ) { if ( dp [ i ] % 2 == 1 ) { return ; } } if ( max < ans . length ( ) ) { max = ans . length ( ) ; ans1 = ans ; } }
void longestString ( List < String > arr , int index , String str ) { if ( index == arr . size ( ) ) { return ; } longestString ( arr , index + 1 , str ) ; str += arr . get ( index ) ; calculate ( str ) ; longestString ( arr , index + 1 , str ) ; }
int countSubstrings ( String str ) { int [ ] freq = new int [ 3 ] ; int count = 0 ; int i = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { freq [ str . charAt ( j ) - '0' ] ++ ; while ( freq [ 0 ] > 0 && freq [ 1 ] > 0 && freq [ 2 ] > 0 ) { freq [ str . charAt ( i ++ ) - '0' ] -- ; } count += i ; } return count ; }
int minSwaps ( String s ) { int ones = 0 , zeros = 0 ; int N = s . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == '1' ) ones ++ ; else zeros ++ ; } if ( ( N % 2 == 0 && ones != zeros ) || ( N % 2 == 1 && Math . abs ( ones - zeros ) != 1 ) ) { return - 1 ; } int ans_1 = 0 ; int j = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == '1' ) { ans_1 += Math . abs ( j - i ) ; j += 2 ; } } int ans_0 = 0 ; int k = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == '0' ) { ans_0 += Math . abs ( k - i ) ; k += 2 ; } } if ( N % 2 == 0 ) return Math . min ( ans_1 , ans_0 ) ; else { if ( ones > zeros ) return ans_1 ; else return ans_0 ; } }
void isOnesGreater ( String S , int N ) { char [ ] st = new char [ S . length ( ) ] ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { st [ i ] = S . charAt ( i ) ; } int cnt0 = 0 ; int cnt1 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( st [ i ] == '1' ) cnt1 ++ ; else cnt0 ++ ; } for ( int i = 0 ; i < N ; i ++ ) { if ( st [ i ] == '1' ) { if ( i > 0 && st [ i - 1 ] == '0' ) { st [ i - 1 ] = '_' ; cnt0 -- ; } else if ( i < N && st [ i + 1 ] == '0' ) { st [ i + 1 ] = '_' ; cnt0 -- ; } } } if ( cnt1 > cnt0 ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } }
String findString ( String arr [ ] , int N ) { String ans = "" ; for ( int i = 0 ; i < N ; i ++ ) { ans += arr [ i ] . charAt ( i ) == '0' ? '1' : '0' ; } return ans ; }
int waysToClearString ( String S ) { for ( int i = 0 ; i < 505 ; i ++ ) { for ( int j = 0 ; j < 505 ; j ++ ) dp [ i ] [ j ] = - 1 ; } int n = S . length ( ) ; choose [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= ( n / 2 ) ; ++ i ) { choose [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j <= i ; ++ j ) { choose [ i ] [ j ] = ( choose [ i - 1 ] [ j ] + choose [ i - 1 ] [ j - 1 ] ) ; } } return calc ( 0 , n - 1 , S ) ; }
int minFlips ( String str ) { int count = 0 ; if ( str . length ( ) <= 2 ) { return 0 ; } for ( int i = 0 ; i < str . length ( ) - 2 { if ( str . charAt ( i ) == str . charAt ( i + 1 ) && str . charAt ( i + 2 ) == str . charAt ( i + 1 ) ) { i = i + 3 ; count ++ ; } else { i ++ ; } } return count ; } public static void main ( String [ ] args ) { String S = "0011101" ; System . out . println ( minFlips ( S ) ) ; }
int findMissingDigit ( String a , String b , String c ) { int w = 1 ; int a_mod_11 = 0 ; for ( int i = a . length ( ) - 1 ; i >= 0 ; i -- ) { a_mod_11 = ( a_mod_11 + w * ( a . charAt ( i ) - '0' ) ) % 11 ; w = w * - 1 ; } int b_mod_11 = 0 ; w = 1 ; for ( int i = b . length ( ) - 1 ; i >= 0 ; i -- ) { b_mod_11 = ( b_mod_11 + w * ( b . charAt ( i ) - '0' ) ) % 11 ; w = w * - 1 ; } int c_mod_11 = 0 ; boolean xSignIsPositive = true ; w = 1 ; for ( int i = c . length ( ) - 1 ; i >= 0 ; i -- ) { if ( c . charAt ( i ) == 'x' ) { xSignIsPositive = ( w == 1 ) ; } else { c_mod_11 = ( c_mod_11 + w * ( c . charAt ( i ) - '0' ) ) % 11 ; } w = w * - 1 ; } int x = ( ( a_mod_11 * b_mod_11 ) - c_mod_11 ) % 11 ; if ( ! xSignIsPositive ) { x = - x ; } return ( x % 11 + 11 ) % 11 ; }
boolean validInsertionstring ( String S1 , String S2 ) { int N = S1 . length ( ) ; int M = S2 . length ( ) ; Stack < Character > st = new Stack < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { st . push ( S1 . charAt ( i ) ) ; if ( S1 . charAt ( i ) == S2 . charAt ( M - 1 ) ) { int idx = M - 1 ; while ( idx >= 0 ) { if ( st . size ( ) == 0 ) { return false ; } char c = st . peek ( ) ; st . pop ( ) ; if ( c != S2 . charAt ( idx ) ) { return false ; } idx -- ; } } } if ( st . size ( ) > 0 ) { return false ; } else { return true ; } }
int lengthNPalindrome ( int N , int K ) { int half = N / 2 ; if ( N % 2 == 1 ) { half += 1 ; } int ans = 1 ; for ( int i = 1 ; i <= half ; i ++ ) { ans *= K ; K -- ; } return ans ; }
int palindromicStrings ( int N , int K ) { if ( N == 1 ) { return K ; } if ( N == 2 ) { return 2 * K ; } int ans = 0 ; ans += ( 2 * K ) ; for ( int i = 3 ; i <= N ; i ++ ) { ans += lengthNPalindrome ( i , K ) ; } return ans ; }
int LCS ( String S , int N , String T , int M , int dp [ ] [ ] ) { if ( N == 0 M == 0 ) return 0 ; if ( dp [ N ] [ M ] != 0 ) return dp [ N ] [ M ] ; if ( S . charAt ( N - 1 ) == T . charAt ( M - 1 ) ) { return dp [ N ] [ M ] = 1 + LCS ( S , N - 1 , T , M - 1 , dp ) ; } return dp [ N ] [ M ] = Math . max ( LCS ( S , N - 1 , T , M , dp ) , LCS ( S , N , T , M - 1 , dp ) ) ; }
int maxlength ( String s ) { int n = s . length ( ) , i , j ; int ans = 0 ; for ( i = 0 ; i <= n - 1 ; i ++ ) { if ( s . charAt ( i ) == '1' ) { int count = 1 ; for ( j = i + 1 ; j <= n - 1 && s . charAt ( j ) == '1' ; j ++ ) count ++ ; ans = Math . max ( ans , count ) ; } } return ans ; }
int maximumK ( String S ) { int N = S . length ( ) ; int ans = N ; int flag = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( S . charAt ( i ) != S . charAt ( i + 1 ) ) { flag = 1 ; ans = Math . min ( ans , Math . max ( i + 1 , N - i - 1 ) ) ; } } if ( flag == 0 ) return 0 ; return ans ; }
void findIfPossible ( int N , String str ) { int countG = 0 , countF = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( str . charAt ( i ) == 'G' ) countG ++ ; else countF ++ ; } if ( 2 * countF != countG ) { System . out . println ( "No" ) ; } else { int id = 0 ; boolean flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( str . charAt ( i ) == 'G' ) { countG -- ; id ++ ; } else { countF -- ; id -- ; } if ( id < 0 ) { flag = false ; break ; } if ( countG < countF ) { flag = false ; break ; } } if ( flag ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } } }
int findComb ( int N , int M ) { int x = fact ( N + 1 ) ; int y = fact ( M ) ; return ( x * y ) ; }
void isPossible ( String str1 , String str2 ) { int arr [ ] = new int [ 256 ] ; Arrays . fill ( arr , 0 ) ; int l1 = str1 . length ( ) ; int l2 = str2 . length ( ) ; int i , j ; boolean possible = true ; for ( i = 0 ; i < l1 ; i ++ ) { arr [ str1 . charAt ( i ) ] = 1 ; } for ( i = 0 ; i < l2 ; i ++ ) { if ( str2 . charAt ( i ) != ' ' ) { if ( arr [ str2 . charAt ( i ) ] == 1 ) continue ; else { possible = false ; break ; } } } if ( possible ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } }
boolean check ( char [ ] S ) { for ( int i = 1 ; i < S . length ; i ++ ) { if ( S [ i - 1 ] == S [ i ] ) { return false ; } } return true ; }
void findMinimumSwaps ( char [ ] S ) { ansSwaps = Integer . MAX_VALUE ; minimumSwaps ( S , 0 , 0 ) ; if ( ansSwaps == Integer . MAX_VALUE ) System . out . print ( "-1" ) ; else System . out . print ( ansSwaps ) ; }
char FindKthChar ( String str , int K , int X ) { char ans = ' ' ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int digit = ( int ) str . charAt ( i ) - 48 ; int range = ( int ) Math . pow ( digit , X ) ; sum += range ; if ( K <= sum ) { ans = str . charAt ( i ) ; break ; } } return ans ; }
String convertToHex ( int num ) { StringBuilder temp = new StringBuilder ( ) ; while ( num != 0 ) { int rem = num % 16 ; char c ; if ( rem < 10 ) { c = ( char ) ( rem + 48 ) ; } else { c = ( char ) ( rem + 87 ) ; } temp . append ( c ) ; num = num / 16 ; } return temp . toString ( ) ; }
int minimumHammingDistance ( String S , int K ) { int n = S . length ( ) ; int [ ] pref = new int [ n ] ; pref [ 0 ] = S . charAt ( 0 ) - '0' ; for ( int i = 1 ; i < n ; i ++ ) pref [ i ] = pref [ i - 1 ] + ( S . charAt ( i ) - '0' ) ; int cnt = pref [ n - 1 ] ; int ans = cnt ; for ( int i = 0 ; i < n - K ; i ++ ) { int value = pref [ i + K - 1 ] - ( i - 1 >= 0 ? pref [ i - 1 ] : 0 ) ; ans = Math . min ( ans , cnt - value + ( K - value ) ) ; } return ans ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; else if ( n == 2 ) return true ; else if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { if ( n % i == 0 ) return false ; } return true ; }
void checkPermutation ( String s1 , String s2 ) { int freq [ ] = new int [ 26 ] ; for ( char ch : s1 . toCharArray ( ) ) { freq [ ch - 'a' ] -- ; } for ( char ch : s2 . toCharArray ( ) ) { freq [ ch - 'a' ] ++ ; } boolean isAllChangesPrime = true ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == 0 ) { continue ; } else if ( ! isPrime ( Math . abs ( freq [ i ] ) ) ) { isAllChangesPrime = false ; break ; } } if ( isAllChangesPrime ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } }
void minimumOperations ( String S , int N ) { int ans = 0 ; int cntOne = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( S . charAt ( i ) == '0' ) { ans += cntOne ; cntOne *= 2 ; } else cntOne ++ ; } System . out . println ( ans ) ; }
void differentBitwiseOR ( String s1 , String s2 ) { int n = s1 . length ( ) ; int t00 = 0 , t10 = 0 , t01 = 0 , t11 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 . charAt ( i ) == '0' && s2 . charAt ( i ) == '0' ) { t00 ++ ; } if ( s1 . charAt ( i ) == '1' && s2 . charAt ( i ) == '0' ) { t10 ++ ; } if ( s1 . charAt ( i ) == '1' && s2 . charAt ( i ) == '1' ) { t11 ++ ; } if ( s1 . charAt ( i ) == '0' && s2 . charAt ( i ) == '1' ) { t01 ++ ; } } int ans = t00 * t10 + t01 * t10 + t00 * t11 ; System . out . print ( ans ) ; }
void RemoveCharacters ( String s ) { String ans = "" ; int [ ] c = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) c [ i ] = 0 ; int pos = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( c [ ( int ) s . charAt ( i ) - 97 ] == 0 ) { c [ ( int ) s . charAt ( i ) - 97 ] = 1 ; pos = i ; ans += s . charAt ( i ) ; } } for ( int i = pos + 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( 0 ) ) { ans += s . charAt ( i ) ; break ; } } System . out . println ( ans ) ; }
void changeCharacters ( String S , int N , int K ) { int flag = 1 ; int count = 0 ; Stack < Character > st = new Stack < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( st . empty ( ) ) { if ( S . charAt ( i ) == '0' ) { flag = 0 ; break ; } count = 0 ; st . push ( S . charAt ( i ) ) ; } else { if ( S . charAt ( i ) == '0' ) { count ++ ; if ( count == K ) { st . pop ( ) ; count = 0 ; } } else { count = 0 ; } } } if ( flag == 1 ) System . out . print ( "YES" ) ; else System . out . print ( "NO" ) ; }
int findSubsequence ( String S , char ch ) { int N = S . length ( ) ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . charAt ( i ) == ch ) { ans ++ ; ch ++ ; } } return ans ; }
int findMaxSubsequence ( String S ) { int ans = 0 ; for ( char ch = 'a' ; ch <= 'z' ; ch ++ ) { ans = Math . max ( ans , findSubsequence ( S , ch ) ) ; } return ans ; }
void minOpsToEmptyString ( String s ) { int ans = Integer . MIN_VALUE ; int cn0 = 0 ; int cn1 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '0' ) { if ( cn1 > 0 ) cn1 -- ; cn0 ++ ; } else { if ( cn0 > 0 ) cn0 -- ; cn1 ++ ; } ans = Math . max ( ans , Math . max ( cn0 , cn1 ) ) ; } System . out . print ( ans ) ; }
boolean prefixDivisble ( int n ) { int i = 1 ; while ( n > 0 ) { if ( n % i != 0 ) return false ; n = n / 10 ; i ++ ; } return true ; }
boolean isPrime ( int num ) { boolean flag = false ; if ( num > 1 ) { for ( int i = 2 ; i < num ; i ++ ) { if ( ( num % i ) == 0 ) { flag = true ; break ; } } } if ( flag ) return false ; else return true ; }
int order ( int x ) { int n = 0 ; while ( x != 0 ) { n = n + 1 ; x = x / 10 ; } return n ; }
boolean isArmstrong ( int x ) { int n = order ( x ) ; int temp = x ; int sum1 = 0 ; while ( temp != 0 ) { int r = temp % 10 ; sum1 = sum1 + ( int ) ( Math . pow ( r , n ) ) ; temp = temp / 10 ; } return ( sum1 == x ) ; }
int count_armstrong ( String [ ] li ) { int c = 0 ; for ( String ele : li ) { int val = 0 ; for ( char che : ele . toCharArray ( ) ) val += che ; if ( isArmstrong ( val ) ) c += 1 ; } return c ; }
int count_prime ( String [ ] li ) { int c = 0 ; for ( String ele : li ) { int val = 0 ; for ( char che : ele . toCharArray ( ) ) val += che ; if ( isPrime ( val ) ) c += 1 ; } return c ; }
void findMinimumCost ( String s , int N ) { int count_1 = 0 , count_0 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == '1' ) count_1 ++ ; else count_0 ++ ; } int k = Math . abs ( count_0 - count_1 ) ; if ( count_1 == N count_0 == N ) System . out . println ( - 1 ) ; else System . out . println ( k / 2 ) ; }
void countOccurrences ( String S , String X , String Y ) { int count = 0 ; int N = S . length ( ) , A = X . length ( ) ; int B = Y . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . substring ( i , Math . min ( N , i + B ) ) . equals ( Y ) ) count ++ ; if ( S . substring ( i , Math . min ( N , i + A ) ) . equals ( X ) ) System . out . print ( count + " " ) ; } }
int findLength ( String str , int n ) { int pre [ ] = new int [ n ] ; int post [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { pre [ i ] = 0 ; post [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i != 0 ) { pre [ i ] += pre [ i - 1 ] ; } if ( str . charAt ( i ) == '1' ) { pre [ i ] += 1 ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i != n - 1 ) post [ i ] += post [ i + 1 ] ; if ( str . charAt ( i ) == '0' ) post [ i ] += 1 ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , pre [ i ] + post [ i ] ) ; } return ans ; }
int countSubstring ( String S , int N ) { HashMap < Integer , Integer > prevSum = new HashMap < > ( ) ; int res = 0 ; int currentSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . charAt ( i ) >= 'A' && S . charAt ( i ) <= 'Z' ) { currentSum ++ ; } else currentSum -- ; if ( currentSum == 0 ) res ++ ; if ( prevSum . containsKey ( currentSum ) ) { res += prevSum . get ( currentSum ) ; } prevSum . put ( currentSum , prevSum . getOrDefault ( currentSum , 0 ) + 1 ) ; } return res ; }
void checkforSubsequence ( String S , String target ) { Stack < Character > s = new Stack < > ( ) ; for ( int i = 0 ; i < target . length ( ) ; i ++ ) { s . push ( target . charAt ( i ) ) ; } for ( int i = ( int ) S . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s . empty ( ) ) { System . out . println ( "Yes" ) ; return ; } if ( S . charAt ( i ) == s . peek ( ) ) { s . pop ( ) ; } } if ( s . empty ( ) ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
void makeDFA ( ) { dfa [ 0 ] [ 0 ] = 1 ; dfa [ 1 ] [ 0 ] = 1 ; dfa [ 1 ] [ 2 ] = 3 ; dfa [ 1 ] [ 3 ] = 2 ; dfa [ 1 ] [ 4 ] = 6 ; dfa [ 3 ] [ 0 ] = 4 ; dfa [ 4 ] [ 0 ] = 4 ; dfa [ 4 ] [ 3 ] = 5 ; dfa [ 4 ] [ 4 ] = 6 ; dfa [ 6 ] [ 0 ] = 8 ; dfa [ 6 ] [ 1 ] = 7 ; dfa [ 7 ] [ 0 ] = 8 ; dfa [ 8 ] [ 0 ] = 8 ; dfa [ 8 ] [ 3 ] = 9 ; }
void buildDFA ( ) { for ( int i = 0 ; i < 11 ; i ++ ) for ( int j = 0 ; j < 5 ; j ++ ) dfa [ i ] [ j ] = 10 ; makeDFA ( ) ; }
void checkDFA ( String s ) { buildDFA ( ) ; int currentstate = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( digits . indexOf ( s . charAt ( i ) ) != - 1 ) currentstate = dfa [ currentstate ] [ 0 ] ; else if ( sign . indexOf ( s . charAt ( i ) ) != - 1 ) currentstate = dfa [ currentstate ] [ 1 ] ; else if ( dot . indexOf ( s . charAt ( i ) ) != - 1 ) currentstate = dfa [ currentstate ] [ 2 ] ; else if ( ex . indexOf ( s . charAt ( i ) ) != - 1 ) currentstate = dfa [ currentstate ] [ 4 ] ; else currentstate = dfa [ currentstate ] [ 3 ] ; } if ( currentstate == 1 currentstate == 4 currentstate == 8 ) { System . out . println ( "Unsigned integer" ) ; } else { System . out . println ( "Not an unsigned integer" ) ; } }
String getString ( int N ) { String ans = "" ; while ( N >= 26 ) { ans += 'z' ; N -= 26 ; } ans += ( char ) ( N + 'a' - 1 ) ; return ans ; }
int subString ( String s , int n ) { Map < Integer , Integer > hash = new HashMap < > ( ) ; hash . put ( 0 , 1 ) ; int pre = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { pre ^= ( 1 << ( int ) ( s . charAt ( i ) - 97 ) ) ; count += hash . getOrDefault ( pre , 0 ) ; hash . put ( pre , hash . getOrDefault ( pre , 0 ) + 1 ) ; } return count ; }
void countSamePrefixSuffix ( String s , int n ) { String prefix = "" ; for ( int i = 0 ; i < n - 1 ; i ++ ) { prefix += s . charAt ( i ) ; String suffix = s . substring ( n - 1 - i , n ) ; if ( prefix . equals ( suffix ) ) { System . out . print ( prefix . length ( ) + " " ) ; } } }
void atleastkDistinctChars ( String s , int k ) { int n = s . length ( ) ; Map < Character , Integer > mp = new HashMap < > ( ) ; int begin = 0 , end = 0 ; int ans = 0 ; while ( end < n ) { char c = s . charAt ( end ) ; mp . put ( c , mp . getOrDefault ( c , 0 ) + 1 ) ; end ++ ; while ( mp . size ( ) >= k ) { char pre = s . charAt ( begin ) ; mp . put ( pre , mp . getOrDefault ( pre , 0 ) - 1 ) ; if ( mp . get ( pre ) == 0 ) { mp . remove ( pre ) ; } ans += s . length ( ) - end + 1 ; begin ++ ; } } System . out . println ( ans ) ; }
void minimumMoves ( String s , int n , int k ) { if ( n % 2 == 1 ) { System . out . println ( "No" ) ; return ; } int countOpen = 0 , countClose = 0 ; for ( char ch : s . toCharArray ( ) ) if ( ch == '(' ) countOpen ++ ; else if ( ch == ')' ) countClose ++ ; if ( countOpen != countClose ) { System . out . println ( "No" ) ; return ; } int ans = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( s . charAt ( i ) == '(' ) ++ cnt ; else { -- cnt ; if ( cnt < 0 ) { cnt = 0 ; ++ ans ; } } } if ( ans <= k ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
void inOrder ( Node root ) { if ( root == null ) return ; Node cur = leftMost ( root ) ; while ( cur != null ) { System . out . print ( cur . key + " " ) ; if ( cur . isThreaded ) cur = cur . right ; else cur = leftMost ( cur . right ) ; } }
void countFrequency ( String S , int N ) { int [ ] freq = new int [ 26 ] ; Array . Clear ( freq , 0 , freq . Length ) ; for ( int i = 0 ; i < N ; i ++ ) { freq [ ( int ) S . charAt ( i ) - 'a' ] += 1 ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == 0 ) continue ; int lg = ( int ) ( Math . log ( freq [ i ] ) / Math . log ( 2 ) ) ; int a = ( int ) Math . pow ( 2 , lg ) ; if ( a == freq [ i ] ) { while ( freq [ i ] > 0 ) { freq [ i ] -= 1 ; System . out . print ( ( char ) ( i + 'a' ) ) ; } } } }
void buildTree ( char s [ ] , treeNode tree [ ] , int start , int end , int treenode ) { if ( start == end ) { tree [ treenode ] . square_sum = ( int ) Math . pow ( s [ start ] - 'a' + 1 , 2 ) ; return ; } int mid = start + ( ( end - start ) / 2 ) ; buildTree ( s , tree , start , mid , 2 * treenode ) ; buildTree ( s , tree , mid + 1 , end , 1 + 2 * treenode ) ; tree [ treenode ] . square_sum = tree [ ( 2 * treenode ) ] . square_sum + tree [ ( 2 * treenode ) + 1 ] . square_sum ; }
int querySquareSum ( treeNode tree [ ] , int start , int end , int treenode , int l , int r ) { if ( ( l > end ) || ( r < start ) ) { return 0 ; } if ( ( l <= start ) && ( r >= end ) ) { return tree [ treenode ] . square_sum ; } int mid = start + ( ( end - start ) / 2 ) ; int X = querySquareSum ( tree , start , mid , 2 * treenode , l , r ) ; int Y = + querySquareSum ( tree , mid + 1 , end , 1 + 2 * treenode , l , r ) ; return X + Y ; }
void canSplit ( String S ) { int frequency [ ] = new int [ 26 ] ; int cnt_singles = 0 ; int k = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) frequency [ S . charAt ( i ) - 'a' ] ++ ; int odd = 0 , eve = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( frequency [ i ] != 0 ) { odd += ( frequency [ i ] & 1 ) ; eve += frequency [ i ] / 2 ; } } if ( eve >= odd ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
String isPossible ( String S , int R , int N ) { int cntl = 0 , cntr = 0 ; int cntu = 0 , cntd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . charAt ( i ) == 'L' ) cntl ++ ; else if ( S . charAt ( i ) == 'R' ) cntr ++ ; else if ( S . charAt ( i ) == 'U' ) cntu ++ ; else cntd ++ ; } if ( Math . max ( Math . max ( cntl , cntr ) , Math . max ( cntu , cntd ) ) >= R ) return "Yes" ; HashMap < Integer , Integer > mp = new HashMap < > ( ) ; int r_square = R * R ; for ( int i = 1 ; i * i <= r_square ; i ++ ) { mp . put ( i * i , i ) ; if ( mp . containsKey ( r_square - i * i ) ) { if ( Math . max ( cntl , cntr ) >= mp . get ( r_square - i * i ) && Math . max ( cntu , cntd ) >= i ) return "Yes" ; if ( Math . max ( cntl , cntr ) >= i && Math . max ( cntu , cntd ) >= mp . get ( r_square - i * i ) ) return "Yes" ; } } return "No" ; }
void inorder ( Node root ) { boolean leftdone = false ; while ( root != null ) { if ( ! leftdone ) { while ( root . left != null ) { root = root . left ; } } System . out . print ( root . key + " " ) ; leftdone = true ; if ( root . right != null ) { leftdone = false ; root = root . right ; } else if ( root . parent != null ) { while ( root . parent != null && root == root . parent . right ) root = root . parent ; if ( root . parent == null ) break ; root = root . parent ; } else break ; } }
int findDuplicate ( int arr [ ] , int n , int k ) { int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 1 && arr [ i ] > MAX ) { System . out . println ( "Out of range" ) ; return - 1 ; } freq [ arr [ i ] ] += 1 ; } for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == k ) return i ; } return - 1 ; }
void nearestPowerOfTwo ( String S ) { int N = S . length ( ) ; HashMap < Character , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { freq . put ( S . charAt ( i ) , freq . getOrDefault ( S . charAt ( i ) , 0 ) + 1 ) ; } nearestPowerOfTwoUtil ( freq ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int lcm ( int a , int b ) { return ( a / gcd ( a , b ) ) * b ; }
int canMakeSame ( String s1 , String s2 ) { int ans = 0 ; if ( s1 . length ( ) != s2 . length ( ) ) { return - 1 ; } int N = s1 . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( s1 . charAt ( i ) != s2 . charAt ( i ) ) { while ( i < s1 . length ( ) && s1 . charAt ( i ) != s2 . charAt ( i ) ) { i ++ ; } ans ++ ; } } return ans ; }
void printSorted ( int [ ] arr , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; System . out . print ( arr [ start ] + " " ) ; printSorted ( arr , start * 2 + 2 , end ) ; }
int minDeletions ( String str ) { int fre [ ] = new int [ 26 ] ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { fre [ str . charAt ( i ) - 'a' ] += 1 ; } int count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( fre [ i ] % 2 == 1 ) { count += 1 ; } } if ( count == 0 count == 1 ) { return 0 ; } else { return count - 1 ; } }
void countTotalFrequencies ( String S1 , String S2 ) { HashSet < Character > bset = new HashSet < Character > ( ) ; char [ ] S1arr = S1 . toCharArray ( ) ; char [ ] S2arr = S2 . toCharArray ( ) ; for ( char x : S1arr ) bset . add ( x ) ; int count = 0 ; for ( char x : S2arr ) { if ( bset . contains ( x ) ) count += 1 ; } System . out . print ( count ) ; }
void min_length ( String str ) { int n = str . length ( ) ; int total_zeros = 0 ; int total_ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '0' ) { total_zeros ++ ; } else { total_ones ++ ; } } int ans = Math . min ( total_zeros , total_ones ) ; int cur_zeros = 0 , cur_ones = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char x = str . charAt ( i ) ; if ( x == '0' ) { cur_zeros ++ ; } else { cur_ones ++ ; } ans = Math . min ( ans , cur_ones + ( total_zeros - cur_zeros ) ) ; } System . out . println ( ans ) ; }
void findWinner ( String a , int n ) { Vector < Integer > v = new Vector < Integer > ( ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a . charAt ( i ) == '0' ) { c ++ ; } else { if ( c != 0 ) v . add ( c ) ; c = 0 ; } } if ( c != 0 ) v . add ( c ) ; if ( v . size ( ) == 0 ) { System . out . print ( "Player B" ) ; return ; } if ( v . size ( ) == 1 ) { if ( ( v . get ( 0 ) & 1 ) != 0 ) System . out . print ( "Player A" ) ; else System . out . print ( "Player B" ) ; return ; } int first = Integer . MIN_VALUE ; int second = Integer . MIN_VALUE ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( a . charAt ( i ) > first ) { second = first ; first = a . charAt ( i ) ; } else if ( a . charAt ( i ) > second && a . charAt ( i ) != first ) second = a . charAt ( i ) ; } if ( ( first & 1 ) != 0 && ( first + 1 ) / 2 > second ) System . out . print ( "Player A" ) ; else System . out . print ( "Player B" ) ; }
int minimumSwaps ( String s , int l , int r , int k ) { int n = s . length ( ) ; int tot_ones = 0 , tot_zeros = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '1' ) tot_ones ++ ; else tot_zeros ++ ; } int ones = 0 , zeros = 0 , sum = 0 ; for ( int i = l - 1 ; i < r ; i ++ ) { if ( s . charAt ( i ) == '1' ) { ones ++ ; sum ++ ; } else zeros ++ ; } int rem_ones = tot_ones - ones ; int rem_zeros = tot_zeros - zeros ; if ( k >= sum ) { int rem = k - sum ; if ( zeros >= rem && rem_ones >= rem ) return rem ; } else if ( k < sum ) { int rem = sum - k ; if ( ones >= rem && rem_zeros >= rem ) return rem ; } return - 1 ; }
boolean longHelper ( int [ ] freq1 , int [ ] freq2 ) { for ( int i = 0 ; i < SIZE ; ++ i ) { if ( freq1 [ i ] != freq2 [ i ] ) { return false ; } } return true ; }
void longCommomPrefixAnagram ( String s1 , String s2 , int n1 , int n2 ) { int [ ] freq1 = new int [ 26 ] ; int [ ] freq2 = new int [ 26 ] ; int ans = 0 ; int mini_len = Math . min ( n1 , n2 ) ; for ( int i = 0 ; i < mini_len ; ++ i ) { freq1 [ s1 . charAt ( i ) - 'a' ] ++ ; freq2 [ s2 . charAt ( i ) - 'a' ] ++ ; if ( longHelper ( freq1 , freq2 ) ) { ans = i + 1 ; } } System . out . print ( ans ) ; }
void getMin ( int [ ] arr ) { int minSum = Integer . MAX_VALUE ; for ( int i = 0 ; i < 10 ; i ++ ) { int curSum = 0 ; for ( int num : arr ) curSum += remove ( num , i ) ; minSum = Math . min ( minSum , curSum ) ; } System . out . print ( minSum ) ; }
boolean isReducible ( String str ) { int N = str . length ( ) ; ArrayList < Character > s = new ArrayList < Character > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( str . charAt ( i ) == '1' ) s . add ( str . charAt ( i ) ) ; else if ( s . size ( ) > 0 ) s . remove ( s . size ( ) - 1 ) ; else return false ; } if ( s . size ( ) == 0 ) { return true ; } else { return false ; } }
boolean checkPalindrome ( String s ) { int low = 0 , high = ( int ) s . length ( ) - 1 ; while ( low < high ) { if ( s . charAt ( low ) != s . charAt ( high ) ) return false ; low ++ ; high -- ; } return true ; }
void populateNumber ( ) { Ans [ index ++ ] = ( 2 ) ; Ans [ index ++ ] = ( 5 ) ; long x = 5 ; long inf = 1000000000001L ; while ( x < inf ) { x *= 2 ; Ans [ index ++ ] = ( x ) ; x = x * 2 + 1 ; Ans [ index ++ ] = ( x ) ; } }
void checkString ( int N ) { populateNumber ( ) ; for ( int i = 0 ; i < index ; i ++ ) { if ( Ans [ i ] == N ) { System . out . println ( "YES" ) ; return ; } } System . out . println ( "NO" ) ; }
void DFA ( String str , int N ) { if ( N <= 1 ) { System . out . print ( "No" ) ; return ; } int count = 0 ; if ( str . charAt ( 0 ) == 'C' ) { count ++ ; for ( int i = 1 ; i < N ; i ++ ) { if ( str . charAt ( i ) == 'A' || str . charAt ( i ) == 'B' ) count ++ ; else break ; } } else { System . out . print ( "No" ) ; return ; } if ( count == N ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
boolean balanced ( int small [ ] , int caps [ ] ) { for ( int i = 0 ; i < 26 ; i ++ ) { if ( small [ i ] != 0 && ( caps [ i ] == 0 ) ) return false ; else if ( ( small [ i ] == 0 ) && ( caps [ i ] != 0 ) ) return false ; } return true ; }
int GCD ( int lena , int lenb ) { if ( lena == 0 ) return lenb ; if ( lenb == 0 ) return lena ; if ( lena == lenb ) return lena ; if ( lena > lenb ) return GCD ( lena - lenb , lenb ) ; return GCD ( lena , lenb - lena ) ; }
void cntBalancedParenthesis ( String s , int N ) { int cntPairs = 0 ; int cntCurly = 0 ; int cntSml = 0 ; int cntSqr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == '{' ) { cntCurly ++ ; } else if ( s . charAt ( i ) == '(' ) { cntSml ++ ; } else if ( s . charAt ( i ) == '[' ) { cntSqr ++ ; } else if ( s . charAt ( i ) == '}' && cntCurly > 0 ) { cntCurly -- ; cntPairs ++ ; } else if ( s . charAt ( i ) == ')' && cntSml > 0 ) { cntSml -- ; cntPairs ++ ; } else if ( s . charAt ( i ) == ']' && cntSqr > 0 ) { cntSqr -- ; cntPairs ++ ; } } System . out . println ( cntPairs ) ; }
boolean canBeBalanced ( String sequence ) { if ( sequence . length ( ) % 2 == 1 ) return false ; Stack < Character > stack_ = new Stack < Character > ( ) ; Stack < Character > stack2_ = new Stack < Character > ( ) ; int countOpen = 0 , countClosed = 0 ; int countSymbol = 0 ; for ( int i = 0 ; i < sequence . length ( ) ; i ++ ) { if ( sequence . charAt ( i ) == ')' ) { countClosed ++ ; if ( stack_ . isEmpty ( ) ) { return false ; } else { stack_ . pop ( ) ; } } else { if ( sequence . charAt ( i ) == '$' ) { countSymbol ++ ; } else { countOpen ++ ; } stack_ . add ( sequence . charAt ( i ) ) ; } } for ( int i = sequence . length ( ) - 1 ; i >= 0 ; i -- ) { if ( sequence . charAt ( i ) == '(' ) { if ( stack2_ . isEmpty ( ) ) { return false ; } else { stack2_ . pop ( ) ; } } else { stack2_ . add ( sequence . charAt ( i ) ) ; } } int extra = Math . abs ( countClosed - countOpen ) ; if ( countSymbol < extra ) { return false ; } else { countSymbol -= extra ; if ( countSymbol % 2 == 0 ) { return true ; } } return false ; }
void maximum_pallindromic ( int arr [ ] ) { int res = 0 ; int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { res += arr [ i ] / 3 ; arr [ i ] = arr [ i ] % 3 ; if ( arr [ i ] == 1 ) c1 ++ ; else if ( arr [ i ] == 2 ) c2 ++ ; } res += Math . min ( c1 , c2 ) ; int t = Math . min ( c1 , c2 ) ; c1 -= t ; c2 -= t ; res += 2 * ( c2 / 3 ) ; c2 %= 3 ; res += c2 / 2 ; System . out . print ( res ) ; }
void inorder ( node root ) { if ( root != null ) { inorder ( root . left ) ; System . out . print ( root . key + "(" + root . count + ") " ) ; inorder ( root . right ) ; } }
int query ( int BIT [ ] [ ] , int idx , int i ) { int ans = 0 ; while ( i > 0 ) { ans += BIT [ idx ] [ i ] ; i = i - ( i & ( - i ) ) ; } return ans ; }
int minOperation ( String arr [ ] , int N ) { int cntMinOP = 0 ; int M = arr [ 0 ] . length ( ) ; int [ ] [ ] hash = new int [ 256 ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { hash [ arr [ i ] . charAt ( j ) ] [ j ] ++ ; } } for ( int i = 0 ; i < M ; i ++ ) { int Sum = 0 ; int Max = 0 ; for ( int j = 0 ; j < 256 ; j ++ ) { Sum += hash [ j ] [ i ] ; Max = Math . max ( Max , hash [ j ] [ i ] ) ; } cntMinOP += ( Sum - Max ) ; } return cntMinOP ; }
void find_Winner ( String [ ] arr , int N ) { @ SuppressWarnings ( "unchecked" ) Vector < Character > [ ] Q = new Vector [ N ] ; for ( int i = 0 ; i < Q . length ; i ++ ) Q [ i ] = new Vector < Character > ( ) ; int M = arr . length ; for ( int i = 0 ; i < M ; i ++ ) { int len = arr [ i ] . length ( ) ; for ( int j = 0 ; j < len ; j ++ ) { Q [ i ] . add ( arr [ i ] . charAt ( j ) ) ; } } int player = 0 ; while ( Q [ player ] . size ( ) > 0 ) { int nextPlayer = Q [ player ] . get ( 0 ) - '0' - 1 ; Q [ player ] . remove ( 0 ) ; player = nextPlayer ; } System . out . print ( "Player " + ( player + 1 ) ) ; }
int longestSubstring ( String s ) { int dp [ ] = new int [ 1024 ] ; Arrays . fill ( dp , s . length ( ) ) ; int res = 0 , mask = 0 ; dp [ 0 ] = - 1 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { mask ^= 1 << ( s . charAt ( i ) - '0' ) ; res = Math . max ( res , i - dp [ mask ] ) ; for ( int j = 0 ; j <= 9 ; ++ j ) res = Math . max ( res , i - dp [ mask ^ ( 1 << j ) ] ) ; dp [ mask ] = Math . min ( dp [ mask ] , i ) ; } return res ; }
int countStrings ( String S , String [ ] list ) { HashSet < Character > valid = new HashSet < Character > ( ) ; for ( char x : S . toCharArray ( ) ) { valid . add ( x ) ; } int cnt = 0 ; for ( int i = 0 ; i < list . length ; i ++ ) { int j = 0 ; for ( j = 0 ; j < list [ i ] . length ( ) ; j ++ ) { if ( valid . contains ( list [ i ] . charAt ( j ) ) ) continue ; else break ; } if ( j == list [ i ] . length ( ) ) cnt ++ ; } return cnt ; }
void inorder ( node root ) { if ( root != null ) { inorder ( root . left ) ; System . out . print ( root . key + " " ) ; inorder ( root . right ) ; } }
void countStrings ( String s , int k ) { int ans = 1 ; int len = s . length ( ) ; int flag = 0 ; int start_ind = 0 ; for ( int i = 0 ; i < len - 1 ; i ++ ) { if ( s . charAt ( i ) - '0' + s . charAt ( i + 1 ) - '0' == k && flag == 0 ) { flag = 1 ; start_ind = i ; } if ( flag == 1 && s . charAt ( i ) - '0' + s . charAt ( i + 1 ) - '0' != k ) { flag = 0 ; if ( ( i - start_ind + 1 ) % 2 != 0 ) ans *= ( i - start_ind + 1 - 1 ) / 2 + 1 ; } } if ( flag == 1 && ( len - start_ind ) % 2 != 0 ) ans *= ( len - start_ind ) / 2 + 1 ; System . out . println ( ans ) ; }
int minLength ( String str , int N , String K , int M ) { Stack < Character > stackOfChar = new Stack < Character > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { stackOfChar . add ( str . charAt ( i ) ) ; if ( stackOfChar . size ( ) >= M ) { String l = "" ; for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( K . charAt ( j ) != stackOfChar . peek ( ) ) { int f = 0 ; while ( f != l . length ( ) ) { stackOfChar . add ( l . charAt ( f ) ) ; f ++ ; } break ; } else { l = stackOfChar . peek ( ) + l ; stackOfChar . pop ( ) ; } } } } return stackOfChar . size ( ) ; }
void printSequences ( HashSet < String > combinations ) { for ( String s : combinations ) { System . out . print ( s + " " ) ; } }
void generateCombinations ( String s , int n ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { combination += ( s . charAt ( i ) ) ; long x = Integer . valueOf ( combination ) ; if ( x <= n ) { combinations . add ( combination ) ; generateCombinations ( s , n ) ; } combination = combination . substring ( 0 , combination . length ( ) - 1 ) ; } }
int compute_hash ( String str ) { int p = 31 ; int MOD = ( int ) 1e9 + 7 ; int hash_val = 0 ; int mul = 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; hash_val = ( hash_val + ( ch - 'a' + 1 ) * mul ) % MOD ; mul = ( mul * p ) % MOD ; } return hash_val ; }
int distinct_str ( String arr [ ] , int n ) { int hash [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { hash [ i ] = compute_hash ( arr [ i ] ) ; } Arrays . sort ( hash ) ; int cntElem = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( hash [ i ] != hash [ i - 1 ] ) { cntElem ++ ; } } return cntElem ; }
boolean isEqualStrings ( String [ ] arr , int N ) { int M = arr [ 0 ] . length ( ) ; int [ ] cntFreq = new int [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { cntFreq [ i ] = 0 ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { cntFreq [ arr [ i ] . charAt ( j ) - 'a' ] += 1 ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( cntFreq [ i ] % N != 0 ) { return false ; } } return true ; }
void minimumOperations ( String s , int n ) { HashMap < Character , List < Integer > > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( s . charAt ( i ) ) ) { mp . get ( s . charAt ( i ) ) . add ( i ) ; } else { mp . put ( s . charAt ( i ) , new ArrayList < Integer > ( Arrays . asList ( i ) ) ) ; } } int ans = Integer . MAX_VALUE ; for ( Map . Entry < Character , List < Integer > > x : mp . entrySet ( ) ) { int curr = 0 ; int prev = 0 ; boolean first = true ; for ( Integer index : ( x . getValue ( ) ) ) { if ( first ) { if ( index > 0 ) { curr ++ ; } prev = index ; first = false ; } else { if ( index != prev + 1 ) { curr ++ ; } prev = index ; } } if ( prev != n - 1 ) { curr ++ ; } ans = Math . min ( ans , curr ) ; } System . out . print ( ans ) ; }
void PrintStack ( Stack < Character > s ) { if ( s . isEmpty ( ) ) return ; char x = s . peek ( ) ; s . pop ( ) ; PrintStack ( s ) ; System . out . print ( x ) ; s . add ( x ) ; }
void minString ( String s ) { Stack < Character > Stack = new Stack < Character > ( ) ; Stack . add ( s . charAt ( 0 ) ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( Stack . isEmpty ( ) ) { Stack . add ( s . charAt ( i ) ) ; } else { if ( Stack . peek ( ) == s . charAt ( i ) ) { Stack . pop ( ) ; } else { Stack . push ( s . charAt ( i ) ) ; } } } PrintStack ( Stack ) ; }
void SieveOfEratosthenes ( boolean [ ] prime , int n ) { for ( int i = 0 ; i <= n ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = prime [ 1 ] = false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = 2 ; i * j <= n ; j ++ ) { prime [ i * j ] = false ; } } } }
void removePrimeFrequencies ( char [ ] s ) { int n = s . length ; boolean [ ] prime = new boolean [ n + 1 ] ; SieveOfEratosthenes ( prime , n ) ; HashMap < Character , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( m . containsKey ( s [ i ] ) ) { m . put ( s [ i ] , m . get ( s [ i ] ) + 1 ) ; } else { m . put ( s [ i ] , 1 ) ; } } String new_String = "" ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( prime [ m . get ( s [ i ] ) ] ) continue ; new_String += s [ i ] ; } System . out . print ( new_String ) ; }
void minMaxDigits ( String str , int N ) { int arr [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = ( str . charAt ( i ) - '0' ) % 3 ; int zero = 0 , one = 0 , two = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero ++ ; if ( arr [ i ] == 1 ) one ++ ; if ( arr [ i ] == 2 ) two ++ ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum = ( sum + arr [ i ] ) % 3 ; } if ( sum == 0 ) { System . out . print ( 0 + " " ) ; } if ( sum == 1 ) { if ( ( one != 0 ) && ( N > 1 ) ) System . out . print ( 1 + " " ) ; else if ( two > 1 && N > 2 ) System . out . print ( 2 + " " ) ; else System . out . print ( - 1 + " " ) ; } if ( sum == 2 ) { if ( two != 0 && N > 1 ) System . out . print ( 1 + " " ) ; else if ( one > 1 && N > 2 ) System . out . print ( 2 + " " ) ; else System . out . print ( - 1 + " " ) ; } if ( zero > 0 ) System . out . print ( N - 1 + " " ) ; else if ( one > 0 && two > 0 ) System . out . print ( N - 2 + " " ) ; else if ( one > 2 two > 2 ) System . out . print ( N - 3 + " " ) ; else System . out . print ( - 1 + " " ) ; }
void findDisStr ( List < String > arr , int N ) { Set < String > DistString = new HashSet < String > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! DistString . contains ( arr . get ( i ) ) ) { DistString . add ( arr . get ( i ) ) ; } } for ( String string : DistString ) { System . out . print ( string + " " ) ; } }
int count_of_accident ( String a , String b ) { int n = a . length ( ) , m = b . length ( ) ; if ( n > m ) return ( m * ( m + 1 ) ) / 2 ; else return ( n * ( n + 1 ) ) / 2 + ( m - n ) * n ; }
double count_of_collision ( String a , String b ) { int n = a . length ( ) , m = b . length ( ) ; double answer = 0 ; int count_of_truck_in_lane_b = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( b . charAt ( i ) == 'T' ) count_of_truck_in_lane_b ++ ; for ( int i = 0 ; i < n && i < m ; i ++ ) { if ( a . charAt ( i ) == 'T' ) answer += count_of_truck_in_lane_b ; if ( b . charAt ( i ) == 'T' ) count_of_truck_in_lane_b -- ; } return answer ; }
int arcIntersection ( String S , int len ) { Stack < Character > stk = new Stack < > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { stk . push ( S . charAt ( i ) ) ; if ( stk . size ( ) >= 2 ) { char temp = stk . peek ( ) ; stk . pop ( ) ; if ( stk . peek ( ) == temp ) { stk . pop ( ) ; } else { stk . add ( temp ) ; } } } if ( stk . isEmpty ( ) ) return 1 ; return 0 ; }
int findMinimumChanges ( int N , int K , char [ ] S ) { int ans = 0 ; for ( int i = 0 ; i < ( K + 1 ) / 2 ; i ++ ) { HashMap < Character , Integer > mp = new HashMap < > ( ) ; for ( int j = i ; j < N ; j += K ) { if ( mp . containsKey ( S [ j ] ) ) { mp . put ( S [ j ] , mp . get ( S [ j ] ) + 1 ) ; } else { mp . put ( S [ j ] , 1 ) ; } } for ( int j = N - i - 1 ; j >= 0 ; j -= K ) { if ( K % 2 == 1 && i == K / 2 ) break ; if ( mp . containsKey ( S [ j ] ) ) { mp . put ( S [ j ] , mp . get ( S [ j ] ) + 1 ) ; } else { mp . put ( S [ j ] , 1 ) ; } } int curr_max = Integer . MIN_VALUE ; for ( Map . Entry < Character , Integer > p : mp . entrySet ( ) ) { curr_max = Math . max ( curr_max , p . getValue ( ) ) ; } if ( ( K % 2 == 1 ) && i == K / 2 ) ans += ( N / K - curr_max ) ; else ans += ( N / K * 2 - curr_max ) ; } return ans ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
void checkValidDFA ( String s ) { int initial_state = 0 ; int final_state = 0 ; int previous_state = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( s . charAt ( i ) == '0' && previous_state == 0 ) || ( s . charAt ( i ) == '1' && previous_state == 3 ) ) { final_state = 1 ; } else if ( ( s . charAt ( i ) == '0' && previous_state == 3 ) || ( s . charAt ( i ) == '1' && previous_state == 0 ) ) { final_state = 2 ; } else if ( ( s . charAt ( i ) == '0' && previous_state == 1 ) || ( s . charAt ( i ) == '1' && previous_state == 2 ) ) { final_state = 0 ; } else if ( ( s . charAt ( i ) == '0' && previous_state == 2 ) || ( s . charAt ( i ) == '1' && previous_state == 1 ) ) { final_state = 3 ; } previous_state = final_state ; } if ( final_state == 3 ) { System . out . println ( "Accepted" ) ; } else { System . out . println ( "Not Accepted" ) ; } }
void findFraction ( String s ) { String be_deci = "" , af_deci = "" , reccu = "" ; boolean x = true , y = false , z = false ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( s . charAt ( i ) == '.' ) { x = false ; y = true ; continue ; } if ( s . charAt ( i ) == '(' ) { z = true ; y = false ; continue ; } if ( x ) be_deci += s . charAt ( i ) ; if ( y ) af_deci += s . charAt ( i ) ; if ( z ) { for ( ; i < s . length ( ) && s . charAt ( i ) != ')' ; ++ i ) reccu += s . charAt ( i ) ; break ; } } int num_be_deci = Integer . valueOf ( be_deci ) ; int num_af_deci = 0 ; if ( af_deci . length ( ) != 0 ) num_af_deci = Integer . valueOf ( af_deci ) ; int numr = num_be_deci * ( int ) Math . pow ( 10 , af_deci . length ( ) ) + num_af_deci ; int deno = ( int ) Math . pow ( 10 , af_deci . length ( ) ) ; if ( reccu . length ( ) == 0 ) { int gd = __gcd ( numr , deno ) ; System . out . print ( numr / gd + " / " + deno / gd ) ; } else { int reccu_num = Integer . valueOf ( reccu ) ; int numr1 = numr * ( int ) Math . pow ( 10 , reccu . length ( ) ) + reccu_num ; int deno1 = deno * ( int ) Math . pow ( 10 , reccu . length ( ) ) ; int res_numr = numr1 - numr , res_deno = deno1 - deno ; int gd = __gcd ( res_numr , res_deno ) ; System . out . print ( res_numr / gd + " / " + res_deno / gd ) ; } }
int minCost ( String s , int n ) { int minValue = 100000000 ; for ( int i = 0 ; i <= 25 ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < n ; j ++ ) { cnt += Math . min ( Math . abs ( i - ( s . charAt ( j ) - 'a' ) ) , 26 - Math . abs ( i - ( s . charAt ( j ) - 'a' ) ) ) ; } minValue = Math . min ( minValue , cnt ) ; } return minValue ; }
int longComPre ( String arr [ ] , int N ) { int [ ] [ ] freq = new int [ N ] [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { int M = arr [ i ] . length ( ) ; for ( int j = 0 ; j < M ; j ++ ) { freq [ i ] [ arr [ i ] . charAt ( j ) ] ++ ; } } int maxLen = 0 ; for ( int j = 0 ; j < 256 ; j ++ ) { int minRowVal = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { minRowVal = Math . min ( minRowVal , freq [ i ] [ j ] ) ; } maxLen += minRowVal ; } return maxLen ; }
int fact ( int n ) { int res = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { res = res * i ; } return res ; }
int distinctWays ( String str1 , String str2 ) { int n = str1 . length ( ) ; int m = str2 . length ( ) ; if ( n == m ) { return 2 * fact ( n ) * fact ( m ) ; } return fact ( n ) * fact ( m ) ; }
void printResult ( ArrayList < Integer > result ) { Collections . reverse ( result ) ; int i = 0 ; while ( i < result . size ( ) ) { System . out . print ( result . get ( i ) ) ; i ++ ; } }
void sumOfLargeNumbers ( String v [ ] , int k , int N ) { ArrayList < ArrayList < Integer > > x = new ArrayList < > ( 1000 ) ; for ( int i = 0 ; i < k ; i ++ ) x . add ( new ArrayList < Integer > ( ) ) ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { x . get ( i ) . add ( v [ i ] . charAt ( j ) - '0' ) ; } } int carry = 0 ; ArrayList < Integer > result = new ArrayList < > ( ) ; for ( int i = N - 1 ; i >= 0 ; i -- ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += x . get ( j ) . get ( i ) ; sum += carry ; int temp = sum ; int count = 0 ; while ( temp > 9 ) { temp = temp % 10 ; count ++ ; } long l = ( long ) Math . pow ( 10 , count ) ; if ( l != 1 ) carry = ( int ) ( sum / l ) ; sum = sum % 10 ; result . add ( sum ) ; } while ( carry != 0 ) { int a = carry % 10 ; result . add ( a ) ; carry = carry / 10 ; } printResult ( result ) ; }
void printRev ( String str ) { Stack < String > st = new Stack < String > ( ) ; String [ ] ss = str . split ( " " ) ; for ( String temp : ss ) { st . add ( temp ) ; } while ( ! st . isEmpty ( ) ) { System . out . print ( st . peek ( ) + " " ) ; st . pop ( ) ; } }
void printLeaves ( int preorder [ ] , int n ) { isLeaf ( preorder , n , Integer . MIN_VALUE , Integer . MAX_VALUE ) ; }
int min_cost ( String S ) { int cost = 0 ; int F = 0 ; int B = 0 ; int count = 0 ; for ( char c : S . toCharArray ( ) ) if ( c == ' ' ) count ++ ; int n = S . length ( ) - count ; if ( n == 1 ) return cost ; for ( char in : S . toCharArray ( ) ) { if ( in != ' ' ) { if ( B != 0 ) { cost += Math . min ( n - F , F ) * B ; B = 0 ; } F += 1 ; } else { B += 1 ; } } return cost ; }
int findPermutations ( int n ) { int sum = 0 , P ; for ( int r = 1 ; r <= n ; r ++ ) { P = permute ( n , r ) ; sum = sum + P ; } return sum ; }
int countOfString ( int N ) { int Stotal = ( int ) Math . pow ( 2 , N ) ; int Sequal = 0 ; if ( N % 2 == 0 ) Sequal = binomialCoeff ( N , N / 2 ) ; int S1 = ( Stotal - Sequal ) / 2 ; return S1 ; }
boolean check ( String s ) { HashSet < Character > a = new HashSet < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( a . contains ( s . charAt ( i ) ) ) { return false ; } a . add ( s . charAt ( i ) ) ; } return true ; }
long binExp ( long base , long power ) { long x = 1 ; while ( power != 0 ) { if ( power % 2 == 1 ) x = ( ( x % mod ) * ( base % mod ) ) % mod ; base = ( ( base % mod ) * ( base % mod ) ) % mod ; power = power / 2 ; } return x ; }
long fact ( long num ) { long result = 1 ; for ( long i = 1 ; i <= num ; ++ i ) { result = ( ( result % mod ) * ( i % mod ) ) % mod ; } return result ; }
long calculate_nCi ( long N , long i ) { long nfact = fact ( N ) ; long ifact = fact ( i ) ; long dfact = fact ( N - i ) ; long inv_ifact = binExp ( ifact , mod - 2 ) ; long inv_dfact = binExp ( dfact , mod - 2 ) ; long denm = ( ( inv_ifact % mod ) * ( inv_dfact % mod ) ) % mod ; long answer = ( ( nfact % mod ) * ( denm % mod ) ) % mod ; return answer ; }
void countSubstring ( long N , long s , long k ) { long allWays = binExp ( 26 , N ) ; long noWays = 0 ; for ( long i = 0 ; i < s ; ++ i ) { long nCi = calculate_nCi ( N , i ) ; long remaining = binExp ( 25 , N - i ) ; long multiply = ( ( nCi % mod ) * ( remaining % mod ) ) % mod ; noWays = ( ( noWays % mod ) + ( multiply % mod ) ) % mod ; } long answer = ( ( allWays % mod ) - ( noWays % mod ) ) % mod ; if ( answer < 0 ) answer += mod ; System . out . println ( answer ) ; }
boolean is_rtol ( String s ) { int tmp = ( int ) ( Math . sqrt ( s . length ( ) ) ) - 1 ; char first = s . charAt ( tmp ) ; for ( int pos = tmp ; pos < s . length ( ) - 1 ; pos += tmp ) { if ( s . charAt ( pos ) != first ) { return false ; } } return true ; }
int isSpecial ( char c , char [ ] special ) { for ( char i : special ) if ( i == c ) return 1 ; return 0 ; }
double countRatio ( char [ ] s , char [ ] special ) { int n = s . length ; for ( int i = 0 ; i < n ; i ++ ) { prefix [ i ] = ( isSpecial ( s [ i ] , special ) ) ; if ( i > 0 ) prefix [ i ] += prefix [ i - 1 ] ; } for ( int i = 0 ; i < n ; i ++ ) { sum [ i ] = prefix [ i ] ; if ( i > 0 ) sum [ i ] += sum [ i - 1 ] ; } double ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int count = sum [ n - 1 ] - ( i > 1 ? sum [ i - 2 ] : 0 ) ; count -= ( i < n ? sum [ n - i - 1 ] : 0 ) ; ans += ( double ) count / ( double ) i ; } return ans ; }
boolean isVowel ( char ch ) { if ( ch == 'a' ch == 'e' ch == 'i' ch == 'o' ch == 'u' ) return true ; else return false ; }
int minCost ( String S ) { int cA = 0 ; int cE = 0 ; int cI = 0 ; int cO = 0 ; int cU = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( isVowel ( S . charAt ( i ) ) ) { cA += Math . abs ( S . charAt ( i ) - 'a' ) ; cE += Math . abs ( S . charAt ( i ) - 'e' ) ; cI += Math . abs ( S . charAt ( i ) - 'i' ) ; cO += Math . abs ( S . charAt ( i ) - 'o' ) ; cU += Math . abs ( S . charAt ( i ) - 'u' ) ; } } return Math . min ( Math . min ( Math . min ( Math . min ( cA , cE ) , cI ) , cO ) , cU ) ; }
boolean isPalindrome ( String str ) { int l = 0 ; int h = str . length ( ) - 1 ; while ( h > l ) { if ( str . charAt ( l ++ ) != str . charAt ( h -- ) ) return false ; } return true ; }
String makeOddString ( String str ) { String odd = "" ; for ( int i = 1 ; i < str . length ( ) ; i += 2 ) { odd += str . charAt ( i ) ; } return odd ; }
String makeevenString ( String str ) { String even = "" ; for ( int i = 0 ; i < str . length ( ) ; i += 2 ) { even += str . charAt ( i ) ; } return even ; }
void checkevenOddPalindrome ( String str ) { String odd = makeOddString ( str ) ; String even = makeevenString ( str ) ; if ( isPalindrome ( odd ) && isPalindrome ( even ) ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
boolean inRange ( int hh , int mm , int L , int R ) { int a = Math . abs ( hh - mm ) ; if ( a < L a > R ) return false ; return true ; }
void firstNonRepElement ( String str ) { LinkedList < Character > list = new LinkedList < Character > ( ) ; list . add ( str . charAt ( 0 ) ) ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( list . contains ( str . charAt ( i ) ) ) list . remove ( list . indexOf ( str . charAt ( i ) ) ) ; else list . add ( str . charAt ( i ) ) ; } System . out . println ( list . get ( 0 ) ) ; }
String makeOddString ( String str ) { String odd = "" ; for ( int i = 1 ; i < str . length ( ) ; i += 2 ) { odd += str . charAt ( i ) ; } return odd ; }
void checkOddlyPalindrome ( String str ) { String odd = makeOddString ( str ) ; if ( isPalindrome ( odd ) ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
void decrypt ( String Str , int Start , int End ) { if ( Start > End ) { return ; } int mid = ( Start + End ) >> 1 ; System . out . print ( Str . charAt ( mid ) ) ; decrypt ( Str , mid + 1 , End ) ; decrypt ( Str , Start , mid - 1 ) ; }
boolean isSuffix ( String s1 , String s2 ) { int n1 = s1 . length ( ) , n2 = s2 . length ( ) ; if ( n1 > n2 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( s1 . charAt ( n1 - i - 1 ) != s2 . charAt ( n2 - i - 1 ) ) return false ; return true ; }
boolean CheckBinaryEquivalent ( int N , String str ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; int c = ( int ) Math . pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } String bin = Integer . toString ( B_Number ) ; return isSuffix ( str , bin ) ; }
void decode_String ( String str , int K ) { String ans = "" ; for ( int i = 0 ; i < str . length ( ) ; i += K ) ans += str . charAt ( i ) ; for ( int i = str . length ( ) - ( K - 1 ) ; i < str . length ( ) ; i ++ ) ans += str . charAt ( i ) ; System . out . println ( ans ) ; }
boolean check ( String str , int K ) { if ( str . length ( ) % K == 0 ) { int sum = 0 , i ; for ( i = 0 ; i < K ; i ++ ) { sum += str . charAt ( i ) ; } for ( int j = i ; j < str . length ( ) ; j += K ) { int s_comp = 0 ; for ( int p = j ; p < j + K ; p ++ ) s_comp += str . charAt ( p ) ; if ( s_comp != sum ) return false ; } return true ; } return false ; }
boolean check ( String s , int n ) { Stack < Character > st = new Stack < Character > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! st . isEmpty ( ) && st . peek ( ) == s . charAt ( i ) ) st . pop ( ) ; else st . add ( s . charAt ( i ) ) ; } if ( st . isEmpty ( ) ) { return true ; } else { return false ; } }
boolean isPalindrome ( String str ) { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) != str . charAt ( len - i - 1 ) ) return false ; } return true ; }
boolean isCompressablePalindrome ( String str ) { int len = str . length ( ) ; String compressed = "" ; compressed = String . valueOf ( str . charAt ( 0 ) ) ; for ( int i = 1 ; i < len ; i ++ ) { if ( str . charAt ( i ) != str . charAt ( i - 1 ) ) compressed += str . charAt ( i ) ; } return isPalindrome ( compressed ) ; }
int CountTotal ( String s ) { int ans = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String temp = "" ; for ( int j = i ; j < n ; j ++ ) { temp += s . charAt ( j ) ; if ( isvalid ( temp ) ) ans += 1 ; } } return ans ; }
boolean isvowel ( char x ) { return ( x == 'a' x == 'e' x == 'i' x == 'o' x == 'u' ) ; }
void getTotCount ( int num ) { totCount = 1 ; firstCount = 1 ; int temp = 1 ; while ( ( num & temp ) == 0 ) { temp = temp << 1 ; totCount += 1 ; } firstCount = totCount ; temp = num >> totCount ; while ( temp != 0 ) { totCount += 1 ; temp = temp >> 1 ; } }
int flipBitsFromRightMostSetBit ( int num ) { getTotCount ( num ) ; int num1 = num ^ ( ( 1 << totCount ) - 1 ) ; num1 = num1 ^ ( ( 1 << firstCount ) - 1 ) ; return num1 ; }
boolean isVowel ( char c ) { return ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) ; }
boolean isValid ( String s ) { int n = s . length ( ) ; if ( n == 1 ) return ( isVowel ( s . charAt ( 0 ) ) ) ; if ( isVowel ( s . charAt ( 0 ) ) == false ) return false ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 ) || ! isVowel ( s . charAt ( i ) ) ) return false ; } return true ; }
int findMaxLen ( String s ) { int maxLen = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String temp = "" ; for ( int j = i ; j < n ; j ++ ) { temp = temp + s . charAt ( j ) ; if ( isValid ( temp ) ) maxLen = Math . max ( maxLen , ( j - i + 1 ) ) ; } } return maxLen ; }
int findMaxLen ( String s ) { int maxLen = 0 ; int cur ; if ( isVowel ( s . charAt ( 0 ) ) ) maxLen = 1 ; cur = maxLen ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( isVowel ( s . charAt ( i ) ) ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) ) cur += 1 ; else cur = 1 ; } else { cur = 0 ; } maxLen = Math . max ( cur , maxLen ) ; } return maxLen ; }
long power ( long base , long pow ) { long res = 1 ; while ( pow > 0 ) { if ( ( pow & 1 ) == 1 ) res = ( res * base ) ; base = ( base * base ) ; pow >>= 1 ; } return res ; }
long countNonPalindromicString ( long n , long m ) { long total = power ( n , m ) ; long palindrome = power ( n , m / 2 + m % 2 ) ; long count = total - palindrome ; return count ; }
void BalancedNumber ( String s ) { int Leftsum = 0 ; int Rightsum = 0 ; for ( int i = 0 ; i < s . length ( ) / 2 ; i ++ ) { Leftsum += ( int ) ( s . charAt ( i ) - '0' ) ; Rightsum += ( int ) ( s . charAt ( s . length ( ) - 1 - i ) - '0' ) ; } if ( Leftsum == Rightsum ) System . out . println ( "Balanced" ) ; else System . out . println ( "Not Balanced" ) ; }
int expo ( int base , int exponent ) { int ans = 1 ; while ( exponent != 0 ) { if ( ( exponent & 1 ) == 1 ) { ans = ans * base ; ans = ans % mod ; } base = base * base ; base %= mod ; exponent >>= 1 ; } return ans % mod ; }
int findCount ( int N ) { int ans = ( expo ( 26 , N ) - expo ( 5 , N ) - expo ( 21 , N ) ) % mod ; ans += mod ; ans %= mod ; return ans ; }
int countPalindromePermutation ( char [ ] s , int k ) { for ( int i = 0 ; i < k ; i ++ ) { freq [ s [ i ] - 97 ] ++ ; } int ans = 0 ; if ( checkPalindrome ( ) ) { ans ++ ; } int i = 0 , j = k ; while ( j < s . length ) { freq [ s [ i ++ ] - 97 ] -- ; freq [ s [ j ++ ] - 97 ] ++ ; if ( checkPalindrome ( ) ) { ans ++ ; } } return ans ; }
int minFlips ( String target ) { char curr = '1' ; int count = 0 ; for ( int i = 0 ; i < target . length ( ) ; i ++ ) { if ( target . charAt ( i ) == curr ) { count ++ ; curr = ( char ) ( 48 + ( curr + 1 ) % 2 ) ; } } return count ; }
int decompose ( Vector < Integer > S ) { Stack < Integer > s = new Stack < Integer > ( ) ; int N = S . size ( ) ; int ans = 0 ; int nix = Integer . MAX_VALUE ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( s . isEmpty ( ) ) { s . add ( S . get ( i ) ) ; nix = S . get ( i ) ; } else { if ( S . get ( i ) < s . peek ( ) ) { s . add ( S . get ( i ) ) ; nix = Math . min ( nix , S . get ( i ) ) ; } else { int val = S . get ( i ) ; while ( ! s . isEmpty ( ) && val >= s . peek ( ) ) { s . pop ( ) ; } nix = Math . min ( nix , S . get ( i ) ) ; s . add ( nix ) ; } } ans += s . size ( ) ; } return ans ; }
int maxSetBitCount ( String s , int k ) { int maxCount = 0 , n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( s . charAt ( i ) == '1' ) count ++ ; } maxCount = count ; for ( int i = k ; i < n ; i ++ ) { if ( s . charAt ( i - k ) == '1' ) count -- ; if ( s . charAt ( i ) == '1' ) count ++ ; maxCount = Math . max ( maxCount , count ) ; } return maxCount ; }
String maxVowelSubString ( String str , int K ) { int N = str . length ( ) ; int [ ] pref = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( str . charAt ( i ) == 'a' || str . charAt ( i ) == 'e' || str . charAt ( i ) == 'i' || str . charAt ( i ) == 'o' || str . charAt ( i ) == 'u' ) pref [ i ] = 1 ; else pref [ i ] = 0 ; if ( i != 0 ) pref [ i ] += pref [ i - 1 ] ; } int maxCount = pref [ K - 1 ] ; String res = str . substring ( 0 , K ) ; for ( int i = K ; i < N ; i ++ ) { int currCount = pref [ i ] - pref [ i - K ] ; if ( currCount > maxCount ) { maxCount = currCount ; res = str . substring ( i - K + 1 , i + 1 ) ; } else if ( currCount == maxCount ) { String temp = str . substring ( i - K + 1 , i + 1 ) ; if ( temp . compareTo ( res ) < 0 ) res = temp ; } } return res ; }
void miniOperToMakeAllEleEqual ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } if ( sum % n != 0 ) { System . out . println ( - 1 ) ; return ; } int valueAfterDivision = sum / n ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . abs ( valueAfterDivision - arr [ i ] ) % k != 0 ) { System . out . println ( - 1 ) ; return ; } count += Math . abs ( valueAfterDivision - arr [ i ] ) / k ; } System . out . println ( ( int ) count / 2 ) ; }
void minOperations ( ArrayList < Integer > a ) { int res = Integer . MAX_VALUE ; int N = a . size ( ) ; for ( int r = 0 ; r < 2 ; r ++ ) { int sum = 0 , ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a . get ( i ) ; if ( ( i + r ) % 2 == 1 ) { if ( sum <= 0 ) { ans += - sum + 1 ; sum = 1 ; } } else { if ( sum >= 0 ) { ans += sum + 1 ; sum = - 1 ; } } } res = Math . min ( res , ans ) ; } System . out . print ( res ) ; }
boolean checkWord ( char [ ] [ ] board , String word , int index , int row , int col ) { if ( row < 0 col < 0 row >= board . length col >= board [ 0 ] . length ) return false ; if ( board [ row ] [ col ] != word . charAt ( index ) ) return false ; else if ( index == word . length ( ) - 1 ) return true ; char temp = board [ row ] [ col ] ; board [ row ] [ col ] = '*' ; if ( checkWord ( board , word , index + 1 , row + 1 , col ) || checkWord ( board , word , index + 1 , row - 1 , col ) || checkWord ( board , word , index + 1 , row , col + 1 ) || checkWord ( board , word , index + 1 , row , col - 1 ) ) { board [ row ] [ col ] = temp ; return true ; } board [ row ] [ col ] = temp ; return false ; }
int count ( String N , int X , String subStr , int index , int n ) { if ( index == n ) return 0 ; String a = subStr + N . charAt ( index ) ; int b = 0 ; if ( Long . valueOf ( a ) % X == 0 ) b = 1 ; int m1 = count ( N , X , a , index + 1 , n ) ; int m2 = b + count ( N , X , "" , index + 1 , n ) ; return Math . max ( m1 , m2 ) ; }
boolean checkSuffix ( int A , int B ) { String s1 = String . valueOf ( A ) ; String s2 = String . valueOf ( B ) ; int n1 = s1 . length ( ) ; int n2 = s2 . length ( ) ; if ( n1 < n2 ) { return false ; } for ( int i = 0 ; i < n2 ; i ++ ) { if ( s1 . charAt ( n1 - i - 1 ) != s2 . charAt ( n2 - i - 1 ) ) { return false ; } } return true ; }
void checkSuffix ( int A , int B ) { String s1 = String . valueOf ( A ) ; String s2 = String . valueOf ( B ) ; boolean result ; result = s1 . endsWith ( s2 ) ; if ( result ) { System . out . print ( "Yes" ) ; } else { System . out . print ( "No" ) ; } }
boolean checkSuffix ( int A , int B ) { int digit_B = ( int ) ( Math . log10 ( B ) + 1 ) ; A -= B ; return ( A % ( int ) ( Math . pow ( 10 , digit_B ) ) > 0 ) ; }
boolean check ( String s ) { boolean ok = true ; for ( int i = 0 ; i + 1 < s . length ( ) ; ++ i ) ok &= ( Math . abs ( s . charAt ( i ) - s . charAt ( i + 1 ) ) != 1 ) ; return ok ; }
int findMinLength ( String s ) { int n = s . length ( ) ; HashMap < Character , Integer > counts = new HashMap < > ( ) ; Vector < Integer > indices = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == 'a' || s . charAt ( i ) == 'e' || s . charAt ( i ) == 'o' || s . charAt ( i ) == 'i' || s . charAt ( i ) == 'u' ) { if ( counts . containsKey ( s . charAt ( i ) ) ) { counts . replace ( s . charAt ( i ) , counts . get ( s . charAt ( i ) ) + 1 ) ; } else { counts . put ( s . charAt ( i ) , 1 ) ; } indices . add ( i ) ; } } if ( counts . size ( ) < 5 ) return - 1 ; int flag1 = 0 , flag2 = 0 ; int i = 0 ; int j = indices . size ( ) - 1 ; while ( ( j - i ) >= 4 ) { if ( flag1 == 0 && counts . get ( s . charAt ( indices . get ( i ) ) ) > 1 ) { counts . replace ( s . charAt ( indices . get ( i ) ) , counts . get ( s . charAt ( indices . get ( i ) ) ) - 1 ) ; i ++ ; } else flag1 = 1 ; if ( flag2 == 0 && counts . get ( s . charAt ( indices . get ( j ) ) ) > 1 ) { counts . replace ( s . charAt ( indices . get ( j ) ) , counts . get ( s . charAt ( indices . get ( j ) ) ) - 1 ) ; j -- ; } else flag2 = 1 ; if ( flag1 == 1 && flag2 == 1 ) break ; } return ( indices . get ( j ) - indices . get ( i ) + 1 ) ; }
int get_index ( char ch ) { if ( ch == 'a' ) return 0 ; else if ( ch == 'e' ) return 1 ; else if ( ch == 'i' ) return 2 ; else if ( ch == 'o' ) return 3 ; else if ( ch == 'u' ) return 4 ; else return - 1 ; }
int findMinLength ( String s ) { int n = s . length ( ) ; int ans = n + 1 ; int start = 0 ; int count [ ] = new int [ 5 ] ; for ( int x = 0 ; x < n ; x ++ ) { int idx = get_index ( s . charAt ( x ) ) ; if ( idx != - 1 ) { count [ idx ] ++ ; } int idx_start = get_index ( s . charAt ( start ) ) ; while ( idx_start == - 1 count [ idx_start ] > 1 ) { if ( idx_start != - 1 ) { count [ idx_start ] -- ; } start ++ ; if ( start < n ) idx_start = get_index ( s . charAt ( start ) ) ; } if ( count [ 0 ] > 0 && count [ 1 ] > 0 && count [ 2 ] > 0 && count [ 3 ] > 0 && count [ 4 ] > 0 ) { ans = Math . min ( ans , x - start + 1 ) ; } } if ( ans == n + 1 ) return - 1 ; return ans ; }
int count_min_length ( String s ) { int [ ] hash = new int [ 26 ] ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < 26 ; i ++ ) hash [ i ] = - 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( hash [ s . charAt ( i ) - 'a' ] == - 1 ) hash [ s . charAt ( i ) - 'a' ] = i ; else { if ( hash [ s . charAt ( i ) - 'a' ] == i - 1 || hash [ s . charAt ( i ) - 'a' ] == i - 2 ) return 0 ; ans = Math . min ( ans , i - hash [ s . charAt ( i ) - 'a' ] - 1 ) ; hash [ s . charAt ( i ) - 'a' ] = i ; } } if ( ans == Integer . MAX_VALUE ) return - 1 ; return ans ; }
int countStrings ( String s ) { int cnt = 0 ; for ( int i = 1 ; i < s . length ( ) - 1 ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) { cnt ++ ; } } return cnt ; }
void RemoveHTMLTags ( String str ) { str = str . replaceAll ( "\\<.*?\\>" , "" ) ; System . out . println ( str ) ; }
boolean checkValidString ( String str ) { int freq [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { freq [ str . charAt ( i ) - 'a' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] != 0 ) { if ( freq [ i ] != i + 1 ) { return false ; } } } return true ; }
boolean checkSemiprime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i ; ++ cnt ; } } if ( num > 1 ) { ++ cnt ; } return cnt == 2 ; }
void makeCypherString ( int N ) { String semiPrime = "" ; String sumOfPrime = "" ; String str = String . valueOf ( N ) ; if ( checkSemiprime ( N ) ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( i % 2 == 1 ) { semiPrime += str . charAt ( i ) ; } else { semiPrime += ( char ) ( str . charAt ( i ) - '0' + 65 ) ; } } } if ( isPossibleSum ( N ) ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( i % 2 == 1 ) { sumOfPrime += ( char ) ( str . charAt ( i ) - '0' + 65 ) ; } else { sumOfPrime += str . charAt ( i ) ; } } } if ( semiPrime + sumOfPrime == "" ) { System . out . print ( "-1" ) ; } else { System . out . print ( semiPrime + sumOfPrime ) ; } }
int modulo_by_26 ( String num ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { res = ( ( res * 10 + ( int ) num . charAt ( i ) - '0' ) % MOD ) ; } return res ; }
String longestConsonantsSubsequence ( String str ) { String answer = "" ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( isConsonants ( str . charAt ( i ) ) ) { answer += str . charAt ( i ) ; } } return answer ; }
String generateTheString ( int n ) { String ans = "" ; if ( n % 2 != 0 ) { for ( int i = 0 ; i < Math . min ( n , 24 ) ; i ++ ) { ans += ( char ) ( 'b' + i ) ; } if ( n > 24 ) { for ( int i = 0 ; i < ( n - 24 ) ; i ++ ) ans += 'a' ; } } else { for ( int i = 0 ; i < Math . min ( n , 25 ) ; i ++ ) { ans += ( char ) ( 'b' + i ) ; } if ( n > 25 ) { for ( int i = 0 ; i < ( n - 25 ) ; i ++ ) ans += 'a' ; } } return ans ; }
void finalCoordinates ( int SX , int SY , char [ ] D ) { for ( int i = 0 ; i < D . length ; i ++ ) { if ( D [ i ] == 'N' ) SY += 1 ; else if ( D [ i ] == 'S' ) SY -= 1 ; else if ( D [ i ] == 'E' ) SX += 1 ; else SX -= 1 ; } String ans = '(' + String . valueOf ( SX ) + ',' + String . valueOf ( SY ) + ')' ; System . out . print ( ans ) ; }
void shortestPalindrome ( String s ) { int [ ] abcd = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) abcd [ s . charAt ( i ) - 97 ] = 1 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( abcd [ i ] == 1 ) { System . out . print ( ( char ) ( i + 97 ) + " " ) ; } } }
void contain ( int L , int U , int M ) { int count = 0 ; for ( int j = L ; j < U ; j ++ ) { HashSet < String > num = new HashSet < > ( ) ; String str = Integer . toString ( j ) ; num . add ( str ) ; if ( j % M == 0 && ! num . contains ( Integer . toString ( M ) ) ) { count += 1 ; } } System . out . println ( count - 2 ) ; }
int MaxLength ( Vector < String > v , int i , int m ) { if ( i >= m ) { return m - 1 ; } for ( int k = 0 ; k < 26 ; k ++ ) { char c = ( char ) ( 'a' + k ) ; Vector < String > v1 = new Vector < String > ( ) ; for ( int j = 0 ; j < v . size ( ) ; j ++ ) { if ( v . get ( j ) . charAt ( i ) == c ) { v1 . add ( v . get ( j ) ) ; } } if ( v1 . size ( ) >= 2 ) { max1 = Math . max ( max1 , MaxLength ( v1 , i + 1 , m ) ) ; } else { max1 = Math . max ( max1 , i - 1 ) ; } } return max1 ; }
void group_formed ( String S ) { int count = 1 ; for ( int i = 0 ; i < S . length ( ) - 1 ; i ++ ) { if ( S . charAt ( i ) != S . charAt ( i + 1 ) ) count += 1 ; } System . out . println ( count ) ; }
int value ( char x ) { return ( int ) ( x - 'a' ) ; }
void finalString ( String str ) { int x = 0 , y = 0 ; int left ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '1' ) x ++ ; else y ++ ; } if ( x > y ) left = 1 ; else left = 0 ; int length = n - 2 * Math . min ( x , y ) ; for ( int i = 0 ; i < length ; i ++ ) { System . out . print ( left ) ; } }
int noOfDeletions ( String str , char k ) { int ans = 0 , cnt = 0 , pos = 0 ; while ( pos < str . length ( ) && str . charAt ( pos ) != k ) { pos ++ ; } int i = pos ; while ( i < str . length ( ) ) { while ( i < str . length ( ) && str . charAt ( i ) == k ) { i = i + 1 ; } ans = ans + cnt ; cnt = 0 ; while ( i < str . length ( ) && str . charAt ( i ) != k ) { i = i + 1 ; cnt = cnt + 1 ; } } return ans ; }
int GetDigitalRoot ( String str ) { if ( str . length ( ) == 1 ) { return str . charAt ( 0 ) - '0' ; } str = GetIndividulaDigitSum ( str , str . length ( ) ) ; return GetDigitalRoot ( str ) ; }
int val ( char c ) { if ( c >= '0' && c <= '9' ) return ( int ) c - '0' ; else return ( int ) c - 'A' + 10 ; }
int toDeci ( String str , int base ) { int len = str . length ( ) ; int power = 1 ; int num = 0 ; int i ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str . charAt ( i ) ) >= base ) { return - 1 ; } num += val ( str . charAt ( i ) ) * power ; power = power * base ; } return num ; }
boolean repeatingString ( String s , int n , int k ) { if ( n % k != 0 ) { return false ; } int [ ] frequency = new int [ 123 ] ; for ( int i = 0 ; i < 123 ; i ++ ) { frequency [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { frequency [ s . charAt ( i ) ] ++ ; } int repeat = n / k ; for ( int i = 0 ; i < 123 ; i ++ ) { if ( frequency [ i ] % repeat != 0 ) { return false ; } } return true ; }
int longestPalindromic ( String str , int i , int j , int count ) { if ( i > j ) return count ; if ( i == j ) return ( count + 1 ) ; if ( str . charAt ( i ) == str . charAt ( j ) ) { count = longestPalindromic ( str , i + 1 , j - 1 , count + 2 ) ; return max ( count , max ( longestPalindromic ( str , i + 1 , j , 0 ) , longestPalindromic ( str , i , j - 1 , 0 ) ) ) ; } return Math . max ( longestPalindromic ( str , i + 1 , j , 0 ) , longestPalindromic ( str , i , j - 1 , 0 ) ) ; }
int longest_palindromic_substr ( String str ) { return longestPalindromic ( str , 0 , str . length ( ) - 1 , 0 ) ; }
String removeOddFrequencyCharacters ( String s ) { HashMap < Character , Integer > m = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char p = s . charAt ( i ) ; Integer count = m . get ( p ) ; if ( count == null ) { count = 0 ; m . put ( p , 1 ) ; } else m . put ( p , count + 1 ) ; } String new_string = "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( m . get ( s . charAt ( i ) ) & 1 ) == 1 ) continue ; new_string += s . charAt ( i ) ; } return new_string ; }
int LexicoLesserStrings ( String s ) { int count = 0 ; int len ; len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { count += ( s . charAt ( i ) - 'a' ) * Math . pow ( 26 , len - i - 1 ) ; } return count ; }
int countString ( String S1 , String S2 ) { int countS1 , countS2 , totalString ; countS1 = LexicoLesserStrings ( S1 ) ; countS2 = LexicoLesserStrings ( S2 ) ; totalString = countS2 - countS1 - 1 ; return ( totalString < 0 ? 0 : totalString ) ; }
boolean isVowel ( char x ) { x = Character . toLowerCase ( x ) ; return ( x == 'a' x == 'e' x == 'i' x == 'o' x == 'u' ) ; }
void MaxPrefix ( String s ) { Map < Character , Integer > Dict = new HashMap < > ( ) ; for ( char i : s . toCharArray ( ) ) { Dict . put ( i , Dict . getOrDefault ( i , 0 ) + 1 ) ; } int minfrequency = Integer . MAX_VALUE ; for ( Integer x : Dict . values ( ) ) { minfrequency = Math . min ( minfrequency , x ) ; } int countminFrequency = 0 ; for ( Map . Entry < Character , Integer > x : Dict . entrySet ( ) ) { if ( x . getValue ( ) == minfrequency ) countminFrequency += 1 ; } Map < Character , Integer > mapper = new HashMap < > ( ) ; int indi = 0 ; for ( char i : s . toCharArray ( ) ) { mapper . put ( i , mapper . getOrDefault ( i , 0 ) + 1 ) ; if ( mapper . get ( i ) > countminFrequency ) break ; indi += 1 ; } System . out . println ( s . substring ( 0 , indi ) ) ; }
long countSubstr ( String s , int k ) { int n = s . length ( ) ; int l = n - 1 ; int r = n - 1 ; int [ ] arr = new int [ n ] ; int last_indexof1 = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) { arr [ i ] = i ; last_indexof1 = i ; } else { arr [ i ] = last_indexof1 ; } } long no_of_substr = 0 ; for ( r = n - 1 ; r >= 0 ; r -- ) { l = r ; while ( l >= 0 && ( r - l + 1 ) <= 64 && Integer . valueOf ( s . substring ( l , r + 1 ) , 2 ) < k ) { l -- ; } if ( r - l + 1 <= 64 ) no_of_substr += l + 1 ; else { no_of_substr += arr [ l + 1 ] + 1 ; } } return no_of_substr ; }
boolean isPerfectCubeString ( String str ) { int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) sum += ( int ) str . charAt ( i ) ; double cr = Math . round ( Math . cbrt ( sum ) ) ; return ( cr * cr * cr == sum ) ; }
int XorAscii ( String str , int len ) { int ans = ( str . charAt ( 0 ) ) ; for ( int i = 1 ; i < len ; i ++ ) { ans = ( ans ^ ( ( str . charAt ( i ) ) ) ) ; } return ans ; }
int countSticks ( String str ) { int cnt = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch >= 'A' && ch <= 'Z' ) { cnt += sticks [ ch - 'A' ] ; } else { cnt += number [ ch - '0' ] ; } } return cnt ; }
void count ( String str1 , String str2 ) { int c = 0 , j = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { if ( str2 . indexOf ( str1 . charAt ( i ) ) >= 0 ) { c += 1 ; } } System . out . println ( "No. of matching characters are: " + c ) ; }
int checkIfStartsWithCapital ( String str ) { if ( str . charAt ( 0 ) >= 'A' && str . charAt ( 0 ) <= 'Z' ) return 1 ; else return 0 ; }
int checkIfAllVowels ( String str ) { int [ ] hash = new int [ 5 ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == 'A' || str . charAt ( i ) == 'a' ) hash [ 0 ] = 1 ; else if ( str . charAt ( i ) == 'E' || str . charAt ( i ) == 'e' ) hash [ 1 ] = 1 ; else if ( str . charAt ( i ) == 'I' || str . charAt ( i ) == 'i' ) hash [ 2 ] = 1 ; else if ( str . charAt ( i ) == 'O' || str . charAt ( i ) == 'o' ) hash [ 3 ] = 1 ; else if ( str . charAt ( i ) == 'U' || str . charAt ( i ) == 'u' ) hash [ 4 ] = 1 ; } for ( int i = 0 ; i < 5 ; i ++ ) { if ( hash [ i ] == 0 ) { return 1 ; } } return 0 ; }
int countOfLetters ( String str ) { int letter = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ( str . charAt ( i ) >= 'A' && str . charAt ( i ) <= 'Z' ) || ( str . charAt ( i ) >= 'a' && str . charAt ( i ) <= 'z' ) ) letter ++ ; } return letter ; }
int countOfNumbers ( String str ) { int number = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) number ++ ; } return number ; }
int findNthOccur ( String str , char ch , int N ) { int occur = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ch ) { occur += 1 ; } if ( occur == N ) return i ; } return - 1 ; }
void countSmaller ( String str ) { int n = str . length ( ) ; int arr [ ] = new int [ 26 ] ; int ans [ ] = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { arr [ str . charAt ( i ) - 'a' ] ++ ; int ct = 0 ; for ( int j = 0 ; j < str . charAt ( i ) - 'a' ; j ++ ) { ct += arr [ j ] ; } ans [ i ] = ct ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + " " ) ; } }
void printValue ( char digit ) { switch ( digit ) { case '0' : System . out . print ( "Zero " ) ; break ; case '1' : System . out . print ( "One " ) ; break ; case '2' : System . out . print ( "Two " ) ; break ; case '3' : System . out . print ( "Three " ) ; break ; case '4' : System . out . print ( "Four " ) ; break ; case '5' : System . out . print ( "Five " ) ; break ; case '6' : System . out . print ( "Six " ) ; break ; case '7' : System . out . print ( "Seven " ) ; break ; case '8' : System . out . print ( "Eight " ) ; break ; case '9' : System . out . print ( "Nine " ) ; break ; } }
void printWord ( String N ) { int i , length = N . length ( ) ; for ( i = 0 ; i < length ; i ++ ) { printValue ( N . charAt ( i ) ) ; } }
int solve ( String X , String Y , int N , int K ) { int [ ] count = new int [ N + 1 ] ; int sol = 0 ; count [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { count [ i ] = count [ i - 1 ] + Math . abs ( X . charAt ( i - 1 ) - Y . charAt ( i - 1 ) ) ; } int j = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { while ( ( count [ i ] - count [ j ] ) > K ) { j ++ ; } sol = Math . max ( sol , i - j ) ; } return sol ; }
int find ( int x ) { if ( x != parent [ x ] ) return parent [ x ] = find ( parent [ x ] ) ; return x ; }
void join ( int x , int y ) { int px = find ( x ) ; int pz = find ( y ) ; if ( px != pz ) { parent [ pz ] = px ; } }
boolean convertible ( String s1 , String s2 ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( ! mp . containsKey ( s1 . charAt ( i ) - 'a' ) ) { mp . put ( s1 . charAt ( i ) - 'a' , s2 . charAt ( i ) - 'a' ) ; } else { if ( mp . get ( s1 . charAt ( i ) - 'a' ) != s2 . charAt ( i ) - 'a' ) return false ; } } for ( Map . Entry < Integer , Integer > it : mp . entrySet ( ) ) { if ( it . getKey ( ) == it . getValue ( ) ) continue ; else { if ( find ( it . getKey ( ) ) == find ( it . getValue ( ) ) ) return false ; else join ( it . getKey ( ) , it . getValue ( ) ) ; } } return true ; }
void initialize ( ) { for ( int i = 0 ; i < 26 ; i ++ ) { parent [ i ] = i ; } }
double jaro_distance ( String s1 , String s2 ) { if ( s1 == s2 ) return 1.0 ; int len1 = s1 . length ( ) , len2 = s2 . length ( ) ; int max_dist = ( int ) ( Math . floor ( Math . max ( len1 , len2 ) / 2 ) - 1 ) ; int match = 0 ; int hash_s1 [ ] = new int [ s1 . length ( ) ] ; int hash_s2 [ ] = new int [ s2 . length ( ) ] ; for ( int i = 0 ; i < len1 ; i ++ ) { for ( int j = Math . max ( 0 , i - max_dist ) ; j < Math . min ( len2 , i + max_dist + 1 ) ; j ++ ) if ( s1 . charAt ( i ) == s2 . charAt ( j ) && hash_s2 [ j ] == 0 ) { hash_s1 [ i ] = 1 ; hash_s2 [ j ] = 1 ; match ++ ; break ; } } if ( match == 0 ) return 0.0 ; double t = 0 ; int point = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) if ( hash_s1 [ i ] == 1 ) { while ( hash_s2 [ point ] == 0 ) point ++ ; if ( s1 . charAt ( i ) != s2 . charAt ( point ++ ) ) t ++ ; } t /= 2 ; return ( ( ( double ) match ) / ( ( double ) len1 ) + ( ( double ) match ) / ( ( double ) len2 ) + ( ( double ) match - t ) / ( ( double ) match ) ) / 3.0 ; }
double jaro_distance ( String s1 , String s2 ) { if ( s1 == s2 ) return 1.0 ; int len1 = s1 . length ( ) , len2 = s2 . length ( ) ; if ( len1 == 0 len2 == 0 ) return 0.0 ; int max_dist = ( int ) Math . floor ( Math . max ( len1 , len2 ) / 2 ) - 1 ; int match = 0 ; int hash_s1 [ ] = new int [ s1 . length ( ) ] ; int hash_s2 [ ] = new int [ s2 . length ( ) ] ; for ( int i = 0 ; i < len1 ; i ++ ) { for ( int j = Math . max ( 0 , i - max_dist ) ; j < Math . min ( len2 , i + max_dist + 1 ) ; j ++ ) if ( s1 . charAt ( i ) == s2 . charAt ( j ) && hash_s2 [ j ] == 0 ) { hash_s1 [ i ] = 1 ; hash_s2 [ j ] = 1 ; match ++ ; break ; } } if ( match == 0 ) return 0.0 ; double t = 0 ; int point = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) if ( hash_s1 [ i ] == 1 ) { while ( hash_s2 [ point ] == 0 ) point ++ ; if ( s1 . charAt ( i ) != s2 . charAt ( point ++ ) ) t ++ ; } t /= 2 ; return ( ( ( double ) match ) / ( ( double ) len1 ) + ( ( double ) match ) / ( ( double ) len2 ) + ( ( double ) match - t ) / ( ( double ) match ) ) / 3.0 ; }
double jaro_Winkler ( String s1 , String s2 ) { double jaro_dist = jaro_distance ( s1 , s2 ) ; if ( jaro_dist > 0.7 ) { int prefix = 0 ; for ( int i = 0 ; i < Math . min ( s1 . length ( ) , s2 . length ( ) ) ; i ++ ) { if ( s1 . charAt ( i ) == s2 . charAt ( i ) ) prefix ++ ; else break ; } prefix = Math . min ( 4 , prefix ) ; jaro_dist += 0.1 * prefix * ( 1 - jaro_dist ) ; } return jaro_dist ; }
boolean isWordPresent ( String sentence , String word ) { String [ ] s = sentence . split ( " " ) ; for ( String temp : s ) { if ( temp . compareTo ( word ) == 0 ) { return true ; } } return false ; }
String canMake ( String s ) { int o = 0 , z = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) - '0' == 1 ) o ++ ; else z ++ ; } if ( o % 2 == 1 && z % 2 == 1 ) return "NO" ; else return "YES" ; }
int countChars ( String str , int n ) { int i = 0 , cnt = 0 ; while ( i < n ) { if ( str . charAt ( i ) == '0' ) i += 1 ; else i += 2 ; cnt += 1 ; } return cnt ; }
int findMinSwaps ( String s , int k ) { int ans = 0 ; int c_one = 0 , c_zero = 0 ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '1' ) c_one ++ ; if ( s . charAt ( i ) == '0' ) { c_zero ++ ; ans += c_one ; } if ( c_zero == k ) break ; } if ( c_zero < k ) return - 1 ; return ans ; }
boolean checkvowel ( char ch ) { ch = Character . toLowerCase ( ch ) ; if ( ch == 'a' ch == 'e' ch == 'i' ch == 'o' ch == 'u' ) { return true ; } else { return false ; } }
void decBinary ( int arr [ ] , int n ) { int k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } }
int concat ( int m , int n ) { int k = ( int ) ( Math . log ( m ) / Math . log ( 2 ) ) + 1 ; int l = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; int a [ ] = new int [ k ] ; int b [ ] = new int [ l ] ; int c [ ] = new int [ k + l ] ; decBinary ( a , m ) ; decBinary ( b , n ) ; int in = 0 ; for ( int i = 0 ; i < k ; i ++ ) c [ in ++ ] = a [ i ] ; for ( int i = 0 ; i < l ; i ++ ) c [ in ++ ] = b [ i ] ; return ( binaryDec ( c , k + l ) ) ; }
int getBinaryLength ( int n ) { int length = 0 ; while ( n > 0 ) { length += 1 ; n /= 2 ; } return length ; }
int concat ( int m , int n ) { int length = getBinaryLength ( n ) ; return ( m << length ) + n ; }
int countSubStr ( String str , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '0' ) ans += ( i + 1 ) ; } return ans ; }
String largestSubStr ( String s ) { while ( s . length ( ) != 0 && s . charAt ( s . length ( ) - 1 ) == '1' ) s = s . substring ( 0 , s . length ( ) - 1 ) ; if ( s . length ( ) == 0 ) return "-1" ; else return s ; }
boolean areEqual ( int [ ] a , int [ ] b ) { for ( int i = 0 ; i < MAX ; i ++ ) if ( a [ i ] != b [ i ] ) return false ; return true ; }
String reverseParentheses ( String str , int len ) { Stack < Integer > st = new Stack < Integer > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '(' ) { st . push ( i ) ; } else if ( str . charAt ( i ) == ')' ) { char [ ] A = str . toCharArray ( ) ; reverse ( A , st . peek ( ) + 1 , i ) ; str = String . copyValueOf ( A ) ; st . pop ( ) ; } } String res = "" ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) != ')' && str . charAt ( i ) != '(' ) { res += ( str . charAt ( i ) ) ; } } return res ; }
int maxCount ( String str , String patt ) { int [ ] strFreq = new int [ MAX ] ; updateFreq ( str , strFreq ) ; int [ ] pattFreq = new int [ MAX ] ; updateFreq ( patt , pattFreq ) ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( pattFreq [ i ] == 0 ) continue ; ans = Math . min ( ans , strFreq [ i ] / pattFreq [ i ] ) ; } return ans ; }
int minNum ( char [ ] str , int len ) { int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '4' str [ i ] == '8' ) { res = Math . min ( res , str [ i ] - '0' ) ; } } for ( int i = 0 ; i < len - 1 ; i ++ ) { for ( int j = i + 1 ; j < len ; j ++ ) { int num = ( str [ i ] - '0' ) * TEN + ( str [ j ] - '0' ) ; if ( num % 4 == 0 ) { res = Math . min ( res , num ) ; } } } return ( ( res == Integer . MAX_VALUE ) ? - 1 : res ) ; }
int minOperation ( String str , int len ) { int first [ ] = new int [ MAX ] ; int last [ ] = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { first [ i ] = - 1 ; last [ i ] = - 1 ; } for ( int i = 0 ; i < len ; i ++ ) { int index = ( str . charAt ( i ) - 'a' ) ; if ( first [ index ] == - 1 ) first [ index ] = i ; last [ index ] = i ; } int minOp = - 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] == - 1 first [ i ] == last [ i ] ) continue ; int cnt = len - ( last [ i ] - first [ i ] + 1 ) ; if ( minOp == - 1 cnt < minOp ) minOp = cnt ; } return minOp ; }
void findMidAlphabet ( String s1 , String s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int mid = ( s1 . charAt ( i ) + s2 . charAt ( i ) ) / 2 ; System . out . print ( ( char ) mid ) ; } }
int countVowels ( String str , int l , int r ) { int cnt = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( isVowel ( str . charAt ( i ) ) ) cnt ++ ; } return cnt ; }
int sumDigits ( int n ) { int sum = 0 ; while ( n > 0 ) { int digit = n % 10 ; sum += digit ; n /= 10 ; } return sum ; }
boolean isDivBySix ( String str , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ( int ) ( str . charAt ( i ) - 'a' + 1 ) ; } if ( sum % 3 != 0 ) return false ; int lastDigit = ( ( int ) ( str . charAt ( n - 1 ) - 'a' + 1 ) ) % 10 ; if ( lastDigit % 2 != 0 ) return false ; return true ; }
int minLength ( String str , int len ) { Stack < Character > s = new Stack < Character > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( s . empty ( ) ) { s . push ( str . charAt ( i ) ) ; } else { char c = s . peek ( ) ; if ( c != str . charAt ( i ) && Character . toUpperCase ( c ) == Character . toUpperCase ( ( str . charAt ( i ) ) ) ) { s . pop ( ) ; } else { s . push ( str . charAt ( i ) ) ; } } } return s . size ( ) ; }
int cntSplits ( String s ) { if ( s . charAt ( s . length ( ) - 1 ) == '1' ) return 0 ; int c_zero = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) c_zero += ( s . charAt ( i ) == '0' ) ? 1 : 0 ; return ( int ) Math . pow ( 2 , c_zero - 1 ) ; }
boolean isDivisible ( String s , int m ) { Map < Character , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < DIGITS ; i ++ ) { mp . put ( CHARS [ i ] , i ) ; } int r = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { r = ( r * 16 + mp . get ( s . charAt ( i ) ) ) % m ; } if ( r == 0 ) return true ; return false ; }
boolean isPalindrome ( float num ) { String s = String . valueOf ( num ) ; int low = 0 ; int high = s . length ( ) - 1 ; while ( low < high ) { if ( s . charAt ( low ) != s . charAt ( high ) ) return false ; low ++ ; high -- ; } return true ; }
int maxSubStr ( char [ ] str1 , int len1 , char [ ] str2 , int len2 ) { if ( len1 > len2 ) return 0 ; int freq1 [ ] = new int [ MAX ] ; for ( int i = 0 ; i < len1 ; i ++ ) freq1 [ i ] = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) freq1 [ str1 [ i ] - 'a' ] ++ ; int freq2 [ ] = new int [ MAX ] ; for ( int i = 0 ; i < len2 ; i ++ ) freq2 [ i ] = 0 ; for ( int i = 0 ; i < len2 ; i ++ ) freq2 [ str2 [ i ] - 'a' ] ++ ; int minPoss = Integer . MAX_VALUE ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq1 [ i ] == 0 ) continue ; if ( freq1 [ i ] > freq2 [ i ] ) return 0 ; minPoss = Math . min ( minPoss , freq2 [ i ] / freq1 [ i ] ) ; } return minPoss ; }
int Count ( String s , int pos ) { int c = s . charAt ( pos - 1 ) ; int counter = 0 ; for ( int i = 0 ; i < pos - 1 ; i ++ ) { if ( s . charAt ( i ) == c ) counter = counter + 1 ; } return counter ; }
void findSubStr ( String str , int cnt , int start ) { if ( start == str . length ( ) ) { minCnt = Math . min ( cnt , minCnt ) ; } for ( int len = 1 ; len <= ( str . length ( ) - start ) ; len ++ ) { String subStr = str . substring ( start , start + len ) ; if ( uSet . contains ( subStr ) ) { findSubStr ( str , cnt + 1 , start + len ) ; } } }
int getMod ( String str , int n , int k ) { int pwrTwo [ ] = new int [ n ] ; pwrTwo [ 0 ] = 1 % k ; for ( int i = 1 ; i < n ; i ++ ) { pwrTwo [ i ] = pwrTwo [ i - 1 ] * ( 2 % k ) ; pwrTwo [ i ] %= k ; } int res = 0 ; int i = 0 , j = n - 1 ; while ( i < n ) { if ( str . charAt ( j ) == '1' ) { res += ( pwrTwo [ i ] ) ; res %= k ; } i ++ ; j -- ; } return res ; }
long countStrings ( int N ) { int i , j ; int dp [ ] [ ] = new int [ N + 1 ] [ 3 ] ; for ( i = 0 ; i < N + 1 ; i ++ ) { for ( j = 9 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; dp [ 1 ] [ 2 ] = 0 ; for ( i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; } int ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; }
int getCount ( char [ ] str , int n ) { int cnt = 0 ; int i = 0 ; while ( i < n - 2 ) { if ( str [ i ] == str [ i + 1 ] && str [ i ] == str [ i + 2 ] ) { cnt ++ ; i = i + 2 ; } else { i ++ ; } } return cnt ; }
String maxNumber ( String str , int n ) { int [ ] freq = new int [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == 'z' ) freq [ 0 ] ++ ; else if ( str . charAt ( i ) == 'n' ) freq [ 1 ] ++ ; } String num = "" ; for ( int i = 0 ; i < freq [ 1 ] ; i ++ ) num += '1' ; for ( int i = 0 ; i < freq [ 0 ] ; i ++ ) num += '0' ; return num ; }
int fact ( int n ) { int fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact *= i ; return fact ; }
int countStrings ( String str , int n ) { Set < Character > distinct_char = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { distinct_char . add ( str . charAt ( i ) ) ; } return fact ( distinct_char . size ( ) ) ; }
char getChar ( String str ) { int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { sum += ( str . charAt ( i ) - 'a' + 1 ) ; } if ( sum % 26 == 0 ) return 'z' ; else { sum = sum % 26 ; return ( char ) ( 'a' + sum - 1 ) ; } }
int countFreq ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int res = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) { if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) { break ; } } if ( j == M ) { res ++ ; j = 0 ; } } return res ; }
void findOccurrence ( int arr [ ] , int n , String pattern ) { for ( int i = 0 ; i < n ; i ++ ) { String binary = decToBinary ( arr [ i ] ) ; System . out . print ( countFreq ( pattern , binary ) + " " ) ; } }
void findNumbers ( String s ) { int n = s . length ( ) ; int count = 1 ; int result = 0 ; int left = 0 ; int right = 1 ; while ( right < n ) { if ( s . charAt ( left ) == s . charAt ( right ) ) { count ++ ; } else { result += count * ( count + 1 ) / 2 ; left = right ; count = 1 ; } right ++ ; } result += count * ( count + 1 ) / 2 ; System . out . println ( result ) ; }
void SieveOfEratosthenes ( boolean [ ] prime , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i < p_size ; i += p ) prime [ i ] = false ; } } }
boolean canBeBalanced ( String s , int n ) { if ( n % 2 == 1 ) return false ; String k = "(" ; k += s + ")" ; Vector < String > d = new Vector < > ( ) ; for ( int i = 0 ; i < k . length ( ) ; i ++ ) { if ( k . charAt ( i ) == '(' ) d . add ( "(" ) ; else { if ( d . size ( ) != 0 ) d . remove ( d . size ( ) - 1 ) ; else return false ; } } if ( d . isEmpty ( ) ) return true ; return false ; }
int maxLenSubStr ( String s ) { if ( s . length ( ) < 3 ) return s . length ( ) ; int temp = 2 ; int ans = 2 ; for ( int i = 2 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) || s . charAt ( i ) != s . charAt ( i - 2 ) ) temp ++ ; else { ans = Math . max ( temp , ans ) ; temp = 2 ; } } ans = Math . max ( temp , ans ) ; return ans ; }
boolean CompareAlphanumeric ( char [ ] str1 , char [ ] str2 ) { int i , j ; i = 0 ; j = 0 ; int len1 = str1 . length ; int len2 = str2 . length ; while ( i <= len1 && j <= len2 ) { while ( i < len1 && ( ! ( ( str1 [ i ] >= 'a' && str1 [ i ] <= 'z' ) || ( str1 [ i ] >= 'A' && str1 [ i ] <= 'Z' ) || ( str1 [ i ] >= '0' && str1 [ i ] <= '9' ) ) ) ) { i ++ ; } while ( j < len2 && ( ! ( ( str2 [ j ] >= 'a' && str2 [ j ] <= 'z' ) || ( str2 [ j ] >= 'A' && str2 [ j ] <= 'Z' ) || ( str2 [ j ] >= '0' && str2 [ j ] <= '9' ) ) ) ) { j ++ ; } if ( i == len1 && j == len2 ) { return true ; } else if ( str1 [ i ] != str2 [ j ] ) { return false ; } else { i ++ ; j ++ ; } } return false ; }
void expandString ( String strin ) { String temp = "" ; int j ; for ( int i = 0 ; i < strin . length ( ) ; i ++ ) { if ( strin . charAt ( i ) >= 0 ) { int num = strin . charAt ( i ) - '0' ; if ( strin . charAt ( i + 1 ) == '(' ) { for ( j = i + 1 ; strin . charAt ( j ) != ')' ; j ++ ) { if ( ( strin . charAt ( j ) >= 'a' && strin . charAt ( j ) <= 'z' ) || ( strin . charAt ( j ) >= 'A' && strin . charAt ( j ) <= 'Z' ) ) { temp += strin . charAt ( j ) ; } } for ( int k = 1 ; k <= num ; k ++ ) { System . out . print ( temp ) ; } num = 0 ; temp = "" ; if ( j < strin . length ( ) ) { i = j ; } } } } }
int countSubStr ( String s , int n ) { int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 5 && "geeks" . equals ( s . substring ( i , i + 5 ) ) ) { c1 ++ ; } if ( i < n - 3 && "for" . equals ( s . substring ( i , i + 3 ) ) ) { c2 = c2 + c1 ; } } return c2 ; }
boolean isVowel ( char ch ) { ch = Character . toUpperCase ( ch ) ; return ( ch == 'A' ch == 'E' ch == 'I' ch == 'O' ch == 'U' ) ; }
String balancedBrackets ( String str ) { int dep = 0 ; int minDep = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == '(' ) dep ++ ; else dep -- ; if ( minDep > dep ) minDep = dep ; } if ( minDep < 0 ) { for ( int i = 0 ; i < Math . abs ( minDep ) ; i ++ ) str = '(' + str ; } dep = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == '(' ) dep ++ ; else dep -- ; } if ( dep != 0 ) { for ( int i = 0 ; i < dep ; i ++ ) str = str + ')' ; } return str ; }
int minOperations ( String str , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str . charAt ( i ) != str . charAt ( i + 1 ) ) count ++ ; } return ( count + 1 ) / 2 ; }
int stringToInt ( String str ) { if ( str . length ( ) == 1 ) return ( str . charAt ( 0 ) - '0' ) ; double y = stringToInt ( str . substring ( 1 ) ) ; double x = str . charAt ( 0 ) - '0' ; x = x * Math . pow ( 10 , str . length ( ) - 1 ) + y ; return ( int ) ( x ) ; }
int largestSubSeq ( String arr [ ] , int n ) { int [ ] count = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { String str = arr [ i ] ; boolean [ ] hash = new boolean [ MAX ] ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { hash [ str . charAt ( j ) - 'a' ] = true ; } for ( int j = 0 ; j < MAX ; j ++ ) { if ( hash [ j ] ) count [ j ] ++ ; } } int max = - 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( max < count [ i ] ) max = count [ i ] ; } return max ; }
int longest_substring ( String s , int k ) { int n = s . length ( ) ; if ( k > 1 ) { s += s ; n *= 2 ; } int ans = 0 ; int i = 0 ; while ( i < n ) { int x = 0 ; while ( i < n && s . charAt ( i ) == '0' ) { x ++ ; i ++ ; } ans = Math . max ( ans , x ) ; i ++ ; } if ( k == 1 ans != n ) return ans ; else return ( ans / 2 ) * k ; }
int Occurrence ( String s , int position ) { int count = 0 ; for ( int i = 0 ; i < position - 1 ; i ++ ) if ( s . charAt ( i ) == s . charAt ( position - 1 ) ) count ++ ; return count ; }
int countOccurrence ( String s , int position ) { int [ ] alpha = new int [ 26 ] ; int [ ] b = new int [ s . length ( ) ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { b [ i ] = alpha [ ( int ) s . charAt ( i ) - 97 ] ; alpha [ ( int ) s . charAt ( i ) - 97 ] ++ ; } return b [ position - 1 ] ; }
void find_permutation ( String str1 , String str2 , int len1 , int len2 , int i , int j , String res ) { if ( res . length ( ) == len1 + len2 ) { stringSet . add ( res ) ; return ; } if ( i < len1 ) find_permutation ( str1 , str2 , len1 , len2 , i + 1 , j , res + str1 . charAt ( i ) ) ; if ( j < len2 ) find_permutation ( str1 , str2 , len1 , len2 , i , j + 1 , res + str2 . charAt ( j ) ) ; }
boolean canConvert ( String str1 , String str2 ) { int i = 0 , j = 0 ; while ( i < str1 . length ( ) && j < str2 . length ( ) ) { if ( str1 . charAt ( i ) != str2 . charAt ( j ) ) { if ( str1 . charAt ( i ) == '0' && str2 . charAt ( j ) == '1' && i + 1 < str1 . length ( ) && str1 . charAt ( i + 1 ) == '0' ) { i += 2 ; j ++ ; } else { return false ; } } else { i ++ ; j ++ ; } } if ( i == str1 . length ( ) && j == str2 . length ( ) ) return true ; return false ; }
void reverse ( String s ) { Stack < String > stc = new Stack < > ( ) ; String temp = "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' ' ) { stc . add ( temp ) ; temp = "" ; } else { temp = temp + s . charAt ( i ) ; } } stc . add ( temp ) ; while ( ! stc . isEmpty ( ) ) { temp = stc . peek ( ) ; System . out . print ( temp + " " ) ; stc . pop ( ) ; } System . out . println ( ) ; }
int countPairs ( char [ ] str , int k ) { int n = str . length ; int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str [ i ] - 'a' ] ++ ; } int cnt = 0 ; if ( k == 0 ) { for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] > 1 ) { cnt += ( ( freq [ i ] * ( freq [ i ] - 1 ) ) / 2 ) ; } } } else { for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] > 0 && i + k < MAX && freq [ i + k ] > 0 ) { cnt += ( freq [ i ] * freq [ i + k ] ) ; } } ; } return cnt ; }
void printUncommon ( String str1 , String str2 ) { int a1 = 0 , a2 = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { int ch = ( str1 . charAt ( i ) ) - 'a' ; a1 = a1 | ( 1 << ch ) ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { int ch = ( str2 . charAt ( i ) ) - 'a' ; a2 = a2 | ( 1 << ch ) ; } int ans = a1 ^ a2 ; int i = 0 ; while ( i < 26 ) { if ( ans % 2 == 1 ) { System . out . print ( ( char ) ( 'a' + i ) ) ; } ans = ans / 2 ; i ++ ; } }
boolean isPalin ( int i , int j , int k , int l , int p , int q , String s ) { int start = i , end = q ; while ( start < end ) { if ( s . charAt ( start ) != s . charAt ( end ) ) { return false ; } start ++ ; if ( start == j + 1 ) { start = k ; } end -- ; if ( end == p - 1 ) { end = l ; } } return true ; }
int countSubStr ( String s ) { int count = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k ; l < n - 1 ; l ++ ) { for ( int p = l + 1 ; p < n ; p ++ ) { for ( int q = p ; q < n ; q ++ ) { if ( isPalin ( i , j , k , l , p , q , s ) ) { count ++ ; } } } } } } } return count ; }
boolean isPrime ( int n ) { if ( n == 0 n == 1 ) { return false ; } for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; }
int sumAscii ( String str , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime ( i + 1 ) ) { sum += ( int ) ( str . charAt ( i ) ) ; } } return sum ; }
boolean Pangram ( String x ) { HashMap < Character , Integer > mp = new HashMap < > ( ) ; int n = x . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( x . charAt ( i ) ) ) { mp . put ( x . charAt ( i ) , mp . get ( x . charAt ( i ) ) + 1 ) ; } else { mp . put ( x . charAt ( i ) , 1 ) ; } } if ( mp . size ( ) == 26 ) return true ; else return false ; }
int countTotalPangram ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( Pangram ( weight [ i ] ) ) cnt ++ ; return cnt ; }
void dfs ( int node , int parent ) { for ( int to : graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; weight [ node ] += weight [ to ] ; } }
boolean uniqueChars ( char [ ] arr ) { HashMap < Character , Integer > mp = new HashMap < Character , Integer > ( ) ; int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } if ( mp . size ( ) == arr . length ) return true ; else return false ; }
void dfs ( int node , int parent ) { if ( uniqueChars ( weight [ node ] . toCharArray ( ) ) ) cnt += 1 ; for ( int to : graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; } }
void preCalculate ( String str , int n ) { freq [ ( int ) str . charAt ( 0 ) ] [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { char ch = str . charAt ( i ) ; for ( int j = 0 ; j < MAX ; j ++ ) { char charToUpdate = ( char ) j ; if ( charToUpdate == ch ) freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 ; else freq [ j ] [ i ] = freq [ j ] [ i - 1 ] ; } } }
int getFrequency ( char ch , int l , int r ) { if ( l == 0 ) return freq [ ( int ) ch ] [ r ] ; else return ( freq [ ( int ) ch ] [ r ] - freq [ ( int ) ch ] [ l - 1 ] ) ; }
boolean isValid ( String s ) { if ( ( s . indexOf ( "geek" ) != - 1 ) && ( s . indexOf ( "keeg" , s . indexOf ( "geek" ) + 4 ) != - 1 ) ) return true ; return false ; }
boolean isTwoAlter ( String s ) { for ( int i = 0 ; i < s . length ( ) - 2 ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i + 2 ) ) { return false ; } } if ( s . charAt ( 0 ) == s . charAt ( 1 ) ) return false ; return true ; }
int findCount ( String s , int n , int a , int b ) { int res = 0 ; char [ ] s1 = s . toCharArray ( ) ; for ( int i = 0 ; i < b ; i ++ ) { if ( i == a ) { if ( s1 [ n - i - 1 ] != '1' ) res += 1 ; } else { if ( s1 [ n - i - 1 ] != '0' ) res += 1 ; } } return res ; }
int lenoflongestnonpalindrome ( String s ) { int max1 = 1 , len = 0 ; char [ ] new_str = s . toCharArray ( ) ; for ( int i = 0 ; i < new_str . length - 1 ; i ++ ) { if ( new_str [ i ] == new_str [ i + 1 ] ) len = 0 ; else if ( i > 0 && ( new_str [ i + 1 ] == new_str [ i - 1 ] ) ) len = 1 ; len ++ ; } if ( max1 == 1 ) return 0 ; else return max1 ; }
int calcScore ( String str ) { int score = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; ) { int chunkSize = 1 ; char currentChar = str . charAt ( i ++ ) ; while ( i < len && str . charAt ( i ) == currentChar ) { chunkSize ++ ; i ++ ; } if ( currentChar == '1' ) score += Math . pow ( chunkSize , 2 ) ; else score -= Math . pow ( chunkSize , 2 ) ; } return score ; }
void pre_process ( String substrings [ ] , String s ) { int n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String dup = "" ; for ( int j = i ; j < n ; j ++ ) { dup += s . charAt ( j ) ; substrings [ count ++ ] = dup ; } } int size = substrings . length ; for ( int i = 0 ; i < size - 1 ; i ++ ) { for ( int j = i + 1 ; j < substrings . length ; j ++ ) { if ( substrings [ i ] . compareTo ( substrings [ j ] ) > 0 ) { String temp = substrings [ i ] ; substrings [ i ] = substrings [ j ] ; substrings [ j ] = temp ; } } } }
boolean check ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s . charAt ( i ) > s . charAt ( i + 1 ) ) return true ; } return false ; }
int countSubString ( char [ ] s , char c , int k ) { int leftCount = 0 , rightCount = 0 ; int left = 0 , right = 0 ; int freq = 0 ; int result = 0 , len = s . length ; while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } right = left + 1 ; while ( freq != ( k - 1 ) && ( right - 1 ) < len ) { if ( s [ right ] == c ) freq ++ ; right ++ ; } while ( left < len && ( right - 1 ) < len ) { while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } while ( right < len && s [ right ] != c ) { if ( s [ right ] == c ) freq ++ ; right ++ ; rightCount ++ ; } result = result + ( leftCount + 1 ) * ( rightCount + 1 ) ; freq = k - 1 ; leftCount = 0 ; rightCount = 0 ; left ++ ; right ++ ; } return result ; }
int performQueries ( int l , int r , int prefix [ ] [ ] ) { l -- ; r -- ; boolean flag = false ; int count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { int cnt = prefix [ r ] [ i ] ; if ( l > 0 ) cnt -= prefix [ l - 1 ] [ i ] ; if ( cnt % 2 == 1 ) { flag = true ; count += cnt - 1 ; } else count += cnt ; } if ( flag ) count += 1 ; return count ; }
void printSmallSub ( int [ ] arr , int N ) { int gcdArr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { gcdArr = gcd ( gcdArr , arr [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == gcdArr ) { System . out . print ( arr [ i ] + " " ) ; return ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( gcd ( arr [ i ] , arr [ j ] ) == gcdArr ) { System . out . print ( arr [ i ] + " " + arr [ j ] ) ; return ; } } } }
int countSubStr ( String str , int n , char x ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == x ) { res += ( ( count + 1 ) * ( n - i ) ) ; count = 0 ; } else count ++ ; } return res ; }
boolean isValid ( String str , int n ) { if ( ! ( ( str . charAt ( 0 ) >= 'a' && str . charAt ( 0 ) <= 'z' ) || ( str . charAt ( 0 ) >= 'A' && str . charAt ( 0 ) <= 'Z' ) || str . charAt ( 0 ) == '_' ) ) return false ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( ! ( ( str . charAt ( i ) >= 'a' && str . charAt ( i ) <= 'z' ) || ( str . charAt ( i ) >= 'A' && str . charAt ( i ) <= 'Z' ) || ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) || str . charAt ( i ) == '_' ) ) return false ; } return true ; }
int countSubStr ( String str , int n ) { int len = str . length ( ) ; return ( len - n + 1 ) ; }
int countSubstrings ( String s , char c ) { int n = s . length ( ) ; int cnt = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) != c ) cnt ++ ; else { sum += ( cnt * ( cnt + 1 ) ) / 2 ; cnt = 0 ; } } sum += ( cnt * ( cnt + 1 ) ) / 2 ; return sum ; }
boolean equalIgnoreCase ( String str1 , String str2 ) { int i = 0 ; str1 = str1 . toUpperCase ( ) ; str2 = str2 . toUpperCase ( ) ; int x = str1 . compareTo ( str2 ) ; if ( x != 0 ) { return false ; } else { return true ; } }
void equalIgnoreCaseUtil ( String str1 , String str2 ) { boolean res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) { System . out . println ( "Same" ) ; } else { System . out . println ( "Not Same" ) ; } }
boolean equalIgnoreCase ( String str1 , String str2 ) { int i = 0 ; str1 = str1 . toLowerCase ( ) ; str2 = str2 . toLowerCase ( ) ; int x = str1 . compareTo ( str2 ) ; return x == 0 ; }
void equalIgnoreCaseUtil ( String str1 , String str2 ) { boolean res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) System . out . println ( "Same" ) ; else System . out . println ( "Not Same" ) ; }
int findM ( String s , int x ) { int cnt = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) - '0' != x ) cnt ++ ; } return cnt ; }
void FirstAndLast ( String str ) { int i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( i == 0 ) System . out . print ( str . charAt ( i ) ) ; if ( i == str . length ( ) - 1 ) System . out . print ( str . charAt ( i ) ) ; if ( str . charAt ( i ) == ' ' ) { System . out . print ( str . charAt ( i - 1 ) + " " + str . charAt ( i + 1 ) ) ; } } }
void Longestsubstring ( String s ) { int [ ] lps = compute_lps ( s ) ; int n = s . length ( ) ; if ( lps [ n - 1 ] == 0 ) { System . out . println ( - 1 ) ; return ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( lps [ i ] == lps [ n - 1 ] ) { System . out . println ( s . substring ( 0 , lps [ i ] ) ) ; return ; } } if ( lps [ lps [ n - 1 ] - 1 ] == 0 ) System . out . println ( - 1 ) ; else System . out . println ( s . substring ( 0 , lps [ lps [ n - 1 ] - 1 ] ) ) ; }
int getBitmask ( char [ ] s ) { int temp = 0 ; for ( int j = 0 ; j < s . length ; j ++ ) { switch ( s [ j ] ) { case 's' : temp = temp | ( 1 ) ; break ; case 't' : temp = temp | ( 2 ) ; break ; case 'r' : temp = temp | ( 4 ) ; break ; case 'i' : temp = temp | ( 8 ) ; break ; case 'n' : temp = temp | ( 16 ) ; break ; case 'g' : temp = temp | ( 32 ) ; break ; default : break ; } } return temp ; }
int calculateWays ( String s , int n , int l , int r ) { int freq [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < l i > r ) freq [ s . charAt ( i ) - 'a' ] ++ ; } int ways = 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( freq [ s . charAt ( i ) - 'a' ] != 0 ) { ways = ways * freq [ s . charAt ( i ) - 'a' ] ; freq [ s . charAt ( i ) - 'a' ] -- ; } else { ways = 0 ; break ; } } return ways ; }
void asciiToSentence ( String str , int len ) { int num = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = num * 10 + ( str . charAt ( i ) - '0' ) ; if ( num >= 32 && num <= 122 ) { char ch = ( char ) num ; System . out . print ( ch ) ; num = 0 ; } } }
int countDistinctCode ( String str ) { Set < String > codes = new HashSet < > ( ) ; for ( int i = 0 ; i < str . length ( ) - 1 ; i ++ ) codes . add ( str . substring ( i , i + 2 ) ) ; return codes . size ( ) ; }
boolean isReverseEqual ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) return false ; int len = s1 . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) if ( s1 . charAt ( i ) != s2 . charAt ( len - i - 1 ) ) return false ; return true ; }
boolean isPrefix ( String str , int len , int i , int k ) { if ( i + k > len ) return false ; for ( int j = 0 ; j < k ; j ++ ) { if ( str . charAt ( i ) != str . charAt ( j ) ) return false ; i ++ ; } return true ; }
boolean isKPeriodic ( String str , int len , int k ) { for ( int i = k ; i < len ; i += k ) if ( ! isPrefix ( str , len , i , k ) ) return false ; return true ; }
boolean isFrequencyEqual ( String str , int len ) { if ( len % 2 == 1 ) { return false ; } int i , freq [ ] = new int [ 26 ] ; for ( i = 0 ; i < len ; i ++ ) { freq [ str . charAt ( i ) - 'a' ] ++ ; } for ( i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == len / 2 ) { return true ; } } return false ; }
int minLettersNeeded ( int n ) { if ( n % 26 == 0 ) return ( n / 26 ) ; else return ( ( n / 26 ) + 1 ) ; }
int countMinReversals ( String expr ) { int len = expr . length ( ) ; if ( len % 2 != 0 ) return - 1 ; int ans = 0 ; int i ; int open = 0 ; int close = 0 ; for ( i = 0 ; i < len ; i ++ ) { if ( expr . charAt ( i ) == '{' ) open ++ ; else { if ( open == 0 ) close ++ ; else open -- ; } } ans = ( close / 2 ) + ( open / 2 ) ; close %= 2 ; open %= 2 ; if ( close != 0 ) ans += 2 ; return ans ; }
int minReplacement ( String s , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( i % 2 == 0 && s . charAt ( i ) == '1' ) ans ++ ; if ( i % 2 == 1 && s . charAt ( i ) == '0' ) ans ++ ; } return Math . min ( ans , len - ans ) ; }
int maxBalancedStr ( String s ) { int open1 = 0 , close1 = 0 ; int open2 = 0 , close2 = 0 ; int open3 = 0 , close3 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { switch ( s . charAt ( i ) ) { case '(' : open1 ++ ; break ; case ')' : close1 ++ ; break ; case '{' : open2 ++ ; break ; case '}' : close2 ++ ; break ; case '[' : open3 ++ ; break ; case ']' : close3 ++ ; break ; } } int maxLen = 2 * Math . min ( open1 , close1 ) + 2 * Math . min ( open2 , close2 ) + 2 * Math . min ( open3 , close3 ) ; return maxLen ; }
int totalPairs ( String s1 , String s2 ) { int count = 0 ; int [ ] arr1 = new int [ 7 ] ; int [ ] arr2 = new int [ 7 ] ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { int set_bits = Integer . bitCount ( s1 . charAt ( i ) ) ; arr1 [ set_bits ] ++ ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { int set_bits = Integer . bitCount ( s2 . charAt ( i ) ) ; arr2 [ set_bits ] ++ ; } for ( int i = 1 ; i <= 6 ; i ++ ) { count += ( arr1 [ i ] * arr2 [ i ] ) ; } return count ; }
int findCost ( String s1 , String s2 , int a , int b , int c , int d , int n ) { int cost = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 . charAt ( i ) == s2 . charAt ( i ) ) continue ; else { if ( ( s1 . charAt ( i ) == '1' && s2 . charAt ( i ) == '2' ) || ( s2 . charAt ( i ) == '1' && s1 . charAt ( i ) == '2' ) ) cost += Math . min ( d , Math . min ( a , b + c ) ) ; else if ( ( s1 . charAt ( i ) == '2' && s2 . charAt ( i ) == '3' ) || ( s2 . charAt ( i ) == '2' && s1 . charAt ( i ) == '3' ) ) cost += Math . min ( d , Math . min ( b , a + c ) ) ; else if ( ( s1 . charAt ( i ) == '1' && s2 . charAt ( i ) == '3' ) || ( s2 . charAt ( i ) == '1' && s1 . charAt ( i ) == '3' ) ) cost += Math . min ( d , Math . min ( c , a + b ) ) ; } } return cost ; }
int totalPairs ( String s1 , String s2 ) { int a1 = 0 , b1 = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( ( int ) s1 . charAt ( i ) % 2 != 0 ) a1 ++ ; else b1 ++ ; } int a2 = 0 , b2 = 0 ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( ( int ) s2 . charAt ( i ) % 2 != 0 ) a2 ++ ; else b2 ++ ; } return ( ( a1 * a2 ) + ( b1 * b2 ) ) ; }
String replaceConsonants ( String str ) { String res = "" ; int i = 0 , count = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) != 'a' && str . charAt ( i ) != 'e' && str . charAt ( i ) != 'i' && str . charAt ( i ) != 'o' && str . charAt ( i ) != 'u' ) { i ++ ; count ++ ; } else { if ( count > 0 ) res += count ; res += str . charAt ( i ) ; i ++ ; count = 0 ; } } if ( count > 0 ) res += count ; return res ; }
int prefixOccurrences ( String str ) { char c = str . charAt ( 0 ) ; int countc = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == c ) countc ++ ; } return countc ; }
int Preprocess ( String A , String B ) { int n = A . length ( ) ; int ans = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { HashMap < Character , Integer > mp = new HashMap < > ( ) ; if ( mp . containsKey ( A . charAt ( i ) ) ) mp . put ( A . charAt ( i ) , mp . get ( A . charAt ( i ) ) + 1 ) ; else mp . put ( A . charAt ( i ) , 1 ) ; if ( mp . containsKey ( A . charAt ( n - i - 1 ) ) ) mp . put ( A . charAt ( n - i - 1 ) , mp . get ( A . charAt ( n - i - 1 ) ) + 1 ) ; else mp . put ( A . charAt ( n - i - 1 ) , 1 ) ; if ( mp . containsKey ( B . charAt ( i ) ) ) mp . put ( B . charAt ( i ) , mp . get ( B . charAt ( i ) ) + 1 ) ; else mp . put ( B . charAt ( i ) , 1 ) ; if ( mp . containsKey ( B . charAt ( n - i - 1 ) ) ) mp . put ( B . charAt ( n - i - 1 ) , mp . get ( B . charAt ( n - i - 1 ) ) + 1 ) ; else mp . put ( B . charAt ( n - i - 1 ) , 1 ) ; int sz = mp . size ( ) ; if ( sz == 4 ) ans += 2 ; else if ( sz == 3 ) ans += 1 + ( A . charAt ( i ) == A . charAt ( n - i - 1 ) ? 1 : 0 ) ; else if ( sz == 2 ) ans += mp . get ( A . charAt ( i ) ) != 2 ? 1 : 0 ; } if ( n % 2 == 1 && A . charAt ( n / 2 ) != B . charAt ( n / 2 ) ) ans ++ ; return ans ; }
boolean isPalindrome ( String s ) { int i = 0 ; int j = s . length ( ) - 1 ; while ( i < j ) { if ( s . charAt ( i ) != s . charAt ( j ) ) return false ; i ++ ; j -- ; } return true ; }
int getIndex ( String S1 , String S2 , int n ) { String S = "" ; for ( int i = 0 ; i < n ; i ++ ) { S = S + S1 . charAt ( i ) ; String Temp = "" ; for ( int j = i + 1 ; j < n ; j ++ ) Temp += S2 . charAt ( j ) ; if ( isPalindrome ( S + Temp ) ) { return i ; } } return - 1 ; }
boolean isPalindrome ( String s , int i , int j ) { while ( i < j ) { if ( s . charAt ( i ) != s . charAt ( j ) ) return false ; i ++ ; j -- ; } return true ; }
boolean isVowel ( char c ) { if ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) return true ; return false ; }
boolean checkPossibility ( String s1 , String s2 ) { int l1 = s1 . length ( ) ; int l2 = s2 . length ( ) ; if ( l1 != l2 ) return false ; for ( int i = 0 ; i < l1 ; i ++ ) { if ( isVowel ( s1 . charAt ( i ) ) && isVowel ( s2 . charAt ( i ) ) ) continue ; else if ( ! ( isVowel ( s1 . charAt ( i ) ) ) && ! ( isVowel ( s2 . charAt ( i ) ) ) ) continue ; else return false ; } return true ; }
void generateString ( int A , int B ) { String rt = "" ; while ( 0 < A 0 < B ) { if ( A < B ) { if ( 0 < B -- ) { rt += ( 'b' ) ; } if ( 0 < B -- ) { rt += ( 'b' ) ; } if ( 0 < A -- ) { rt += ( 'a' ) ; } } else if ( B < A ) { if ( 0 < A -- ) { rt += ( 'a' ) ; } if ( 0 < A -- ) { rt += ( 'a' ) ; } if ( 0 < B -- ) { rt += ( 'b' ) ; } } else { if ( 0 < A -- ) { rt += ( 'a' ) ; } if ( 0 < B -- ) { rt += ( 'b' ) ; } } } System . out . println ( rt ) ; }
int countStrings ( int n , int m , String s [ ] ) { HashSet < Integer > ind = new HashSet < Integer > ( ) ; for ( int j = 0 ; j < m ; j ++ ) { int mx = 0 ; for ( int i = 0 ; i < n ; i ++ ) mx = Math . max ( mx , ( int ) ( s [ i ] . charAt ( j ) - '0' ) ) ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] . charAt ( j ) - '0' == mx ) ind . add ( i ) ; } return ind . size ( ) ; }
int minOperations ( String s , String t , int n ) { int ct0 = 0 , ct1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == t . charAt ( i ) ) continue ; if ( s . charAt ( i ) == '0' ) ct0 ++ ; else ct1 ++ ; } return Math . max ( ct0 , ct1 ) ; }
int count_acronym ( int n , String [ ] arr ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] . charAt ( 0 ) - 'a' ] ++ ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { String st = arr [ i ] ; int [ ] num = new int [ 26 ] ; for ( int j = 0 ; j < st . length ( ) ; j ++ ) num [ st . charAt ( j ) - 'a' ] ++ ; boolean flag = true ; for ( int j = 1 ; j < 26 ; j ++ ) { if ( num [ j ] > freq [ j ] ) { flag = false ; break ; } } int x = st . charAt ( 0 ) - 'a' ; if ( freq [ x ] - 1 < num [ x ] ) flag = false ; if ( flag ) cnt ++ ; } return cnt ; }
int minOperations ( String str , int n ) { int i , lastUpper = - 1 , firstLower = - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( Character . isUpperCase ( str . charAt ( i ) ) ) { lastUpper = i ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( Character . isLowerCase ( str . charAt ( i ) ) ) { firstLower = i ; break ; } } if ( lastUpper == - 1 firstLower == - 1 ) return 0 ; int countUpper = 0 ; for ( i = firstLower ; i < n ; i ++ ) { if ( Character . isUpperCase ( str . charAt ( i ) ) ) { countUpper ++ ; } } int countLower = 0 ; for ( i = 0 ; i < lastUpper ; i ++ ) { if ( Character . isLowerCase ( str . charAt ( i ) ) ) { countLower ++ ; } } return Math . min ( countLower , countUpper ) ; }
boolean check ( String s , int k ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i % k ) ) { return false ; } } return true ; }
int countCommonDivisors ( String a , String b ) { int ct = 0 ; int n = a . length ( ) , m = b . length ( ) ; for ( int i = 1 ; i <= Math . min ( n , m ) ; i ++ ) { if ( n % i == 0 && m % i == 0 ) { if ( a . substring ( 0 , i ) . equals ( b . substring ( 0 , i ) ) ) { if ( check ( a , i ) && check ( b , i ) ) { ct ++ ; } } } } return ct ; }
boolean valid ( int [ ] cnt ) { for ( int i = 0 ; i < 26 ; i ++ ) { if ( cnt [ i ] >= 2 ) return false ; } return true ; }
boolean isVowel ( char c ) { c = Character . toLowerCase ( c ) ; if ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) { return true ; } return false ; }
String largestPalinSub ( String s ) { String res = "" ; char mx = s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) mx = ( char ) Math . max ( ( int ) mx , ( int ) s . charAt ( i ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) == mx ) res += s . charAt ( i ) ; return res ; }
boolean isValid ( String str , int len ) { for ( int i = 1 ; i < len ; i ++ ) { if ( str . charAt ( i ) == str . charAt ( i - 1 ) ) return false ; } return true ; }
String decryptString ( String str , int n ) { int i = 0 , jump = 1 ; String decryptedStr = "" ; while ( i < n ) { decryptedStr += str . charAt ( i ) ; i += jump ; jump ++ ; } return decryptedStr ; }
int countSubStr ( String str , int len , int k ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int n = 0 ; for ( int j = i ; j < len ; j ++ ) { n = n * 10 + ( str . charAt ( j ) - '0' ) ; if ( n % k == 0 ) count ++ ; } } return count ; }
int nextZero ( int i , int occurrences [ ] ) { while ( i < occurrences . length ) { if ( occurrences [ i ] == 0 ) return i ; i ++ ; } return - 1 ; }
int findPermutation ( String str , int k ) { boolean [ ] has = new boolean [ 26 ] ; Arrays . fill ( has , false ) ; int cnt = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ! has [ str . charAt ( i ) - 'a' ] ) { cnt ++ ; has [ str . charAt ( i ) - 'a' ] = true ; } } int ans = 1 ; for ( int i = 2 ; i <= cnt ; i ++ ) ans *= i ; for ( int i = cnt - k ; i > 1 ; i -- ) ans /= i ; return ans ; }
int countPairs ( String [ ] bracks , int num ) { HashMap < Integer , Integer > open = new HashMap < > ( ) ; HashMap < Integer , Integer > close = new HashMap < > ( ) ; int cnt = 0 ; for ( int i = 0 ; i < num ; i ++ ) { String s = bracks [ i ] ; int l = s . length ( ) ; int op = 0 , cl = 0 ; for ( int j = 0 ; j < l ; j ++ ) { if ( s . charAt ( j ) == '(' ) op ++ ; else { if ( op != 0 ) op -- ; else cl ++ ; } } if ( op != 0 && cl == 0 ) open . put ( op , open . get ( op ) == null ? 1 : open . get ( op ) + 1 ) ; if ( cl != 0 && op == 0 ) close . put ( cl , close . get ( cl ) == null ? 1 : close . get ( cl ) + 1 ) ; if ( op == 0 && cl == 0 ) cnt ++ ; } cnt /= 2 ; for ( HashMap . Entry < Integer , Integer > it : open . entrySet ( ) ) cnt += Math . min ( it . getValue ( ) , close . get ( it . getKey ( ) ) ) ; return cnt ; }
int no_of_ways ( String s ) { int n = s . length ( ) ; int count_left = 0 , count_right = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( s . charAt ( i ) == s . charAt ( 0 ) ) { ++ count_left ; } else break ; } for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s . charAt ( i ) == s . charAt ( n - 1 ) ) { ++ count_right ; } else break ; } if ( s . charAt ( 0 ) == s . charAt ( n - 1 ) ) return ( ( count_left + 1 ) * ( count_right + 1 ) ) ; else return ( count_left + count_right + 1 ) ; }
boolean isPalindrome ( String str ) { int len = str . length ( ) ; for ( int i = 0 ; i < len / 2 ; i ++ ) { if ( str . charAt ( i ) != str . charAt ( len - 1 - i ) ) return false ; } return true ; }
boolean createStringAndCheckPalindrome ( int N ) { String sub = "" + N , res_str = "" ; int sum = 0 ; while ( N > 0 ) { int digit = N % 10 ; sum += digit ; N = N / 10 ; } while ( res_str . length ( ) < sum ) res_str += sub ; if ( res_str . length ( ) > sum ) res_str = res_str . substring ( 0 , sum ) ; if ( isPalindrome ( res_str ) ) return true ; return false ; }
int product ( int x ) { int prod = 1 ; while ( x > 0 ) { prod *= ( x % 10 ) ; x /= 10 ; } return prod ; }
String removeChars ( String s ) { String modifiedStr = "" ; modifiedStr += s . charAt ( 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( Character . isUpperCase ( s . charAt ( i ) ) && Character . isLowerCase ( s . charAt ( i - 1 ) ) || Character . isLowerCase ( s . charAt ( i ) ) && Character . isUpperCase ( s . charAt ( i - 1 ) ) ) modifiedStr += s . charAt ( i ) ; } return modifiedStr ; }
int pangramCost ( int arr [ ] , String str ) { int cost = 0 ; boolean [ ] occurred = new boolean [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) occurred [ i ] = false ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) occurred [ str . charAt ( i ) - 'a' ] = true ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( occurred [ i ] == false ) cost += arr [ i ] ; } return cost ; }
void pairStar ( String input , int i ) { output = output + input . charAt ( i ) ; if ( i == input . length ( ) - 1 ) return ; if ( input . charAt ( i ) == input . charAt ( i + 1 ) ) output = output + '*' ; pairStar ( input , i + 1 ) ; }
int countMinParts ( String str ) { int n = str . length ( ) ; int freq [ ] = getFrequencies ( str ) ; List < Integer > oddFreq = new ArrayList < > ( ) ; List < Integer > evenFreq = new ArrayList < > ( ) ; int i , sumEven = 0 ; for ( i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == 0 ) continue ; if ( freq [ i ] % 2 == 0 ) evenFreq . add ( freq [ i ] ) ; else oddFreq . add ( freq [ i ] ) ; } for ( i = 0 ; i < evenFreq . size ( ) ; i ++ ) { sumEven += evenFreq . get ( i ) ; } if ( oddFreq . size ( ) == 0 ) return 1 ; if ( sumEven == 0 ) { if ( oddFreq . size ( ) == 1 ) return 1 ; return 0 ; } i = 0 ; while ( i < oddFreq . size ( ) ) { if ( ( sumEven / 2 ) % oddFreq . size ( ) == 0 ) return oddFreq . size ( ) ; if ( oddFreq . get ( i ) == 1 ) { i ++ ; continue ; } sumEven += 2 ; oddFreq . set ( i , oddFreq . get ( i ) - 2 ) ; } return n ; }
int check ( String s , int K ) { for ( int ch = 0 ; ch < 26 ; ch ++ ) { char c = ( char ) ( 'a' + ch ) ; int last = - 1 ; boolean found = true ; for ( int i = 0 ; i < K ; i ++ ) if ( s . charAt ( i ) == c ) last = i ; if ( last == - 1 ) continue ; for ( int i = K ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == c ) last = i ; if ( last <= ( i - K ) ) { found = false ; break ; } } if ( found ) return 1 ; } return 0 ; }
int binarySearch ( String s ) { int low = 1 , high = s . length ( ) ; int ans = 0 ; while ( low <= high ) { int mid = ( high + low ) >> 1 ; if ( check ( s , mid ) == 1 ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; }
int subStringsStartingHere ( String str , int n , int startIndex ) { int count = 0 , i = startIndex + 1 ; while ( i <= n ) { if ( str . startsWith ( str . substring ( startIndex , i ) ) ) { count ++ ; } else break ; i ++ ; } return count ; }
void printExpansion ( String str ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { String subStr = str . substring ( i ) ; System . out . print ( subStr ) ; } }
void printExpansion ( String str ) { String suff = "" ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { suff = suff + str . charAt ( i ) ; System . out . print ( suff ) ; } }
boolean search ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int i ; char countP [ ] = new char [ ALL_CHARS ] ; char countTW [ ] = new char [ ALL_CHARS ] ; for ( i = 0 ; i < M ; i ++ ) { ( countP [ pat . charAt ( i ) ] ) ++ ; ( countTW [ txt . charAt ( i ) ] ) ++ ; } for ( i = M ; i < N ; i ++ ) { if ( compare ( countP , countTW ) ) { return true ; } ( countTW [ txt . charAt ( i ) ] ) ++ ; countTW [ txt . charAt ( i - M ) ] -- ; } if ( compare ( countP , countTW ) ) return true ; return false ; }
char logicalExpressionEvaluation ( String str ) { Stack < Character > arr = new Stack < Character > ( ) ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == '[' ) { Vector < Character > s = new Stack < Character > ( ) ; while ( arr . peek ( ) != ']' ) { s . add ( arr . peek ( ) ) ; arr . pop ( ) ; } arr . pop ( ) ; if ( s . size ( ) == 3 ) { arr . push ( s . get ( 2 ) == '1' ? '0' : '1' ) ; } else if ( s . size ( ) == 5 ) { int a = s . get ( 0 ) - 48 , b = s . get ( 4 ) - 48 , c ; if ( s . get ( 2 ) == '&' ) { c = a & b ; } else { c = a | b ; } arr . push ( ( char ) ( c + 48 ) ) ; } } else { arr . push ( str . charAt ( i ) ) ; } } return arr . peek ( ) ; }
int count ( String s , int k ) { int n = s . length ( ) ; int d = 0 , i ; int count = 0 ; for ( i = 0 ; i < n ; i ++ ) d += s . charAt ( i ) ; if ( d % k == 0 ) count += 1 ; for ( i = k ; i < n ; i ++ ) { int prev = s . charAt ( i - k ) ; d -= prev ; d += s . charAt ( i ) ; if ( d % k == 0 ) count += 1 ; } return count ; }
String MaxFreq ( String str ) { int n = str . length ( ) ; Map < String , Integer > mp = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String s = "" ; for ( int j = i ; j < n ; j ++ ) { s += str . charAt ( j ) ; if ( mp . containsKey ( s ) ) { mp . put ( s , mp . get ( s ) + 1 ) ; } else { mp . put ( s , 1 ) ; } } } int maxi = 0 ; String s = "" ; for ( Map . Entry < String , Integer > i : mp . entrySet ( ) ) { if ( i . getValue ( ) > maxi ) { maxi = i . getValue ( ) ; s = i . getKey ( ) ; } else if ( i . getValue ( ) == maxi ) { String ss = i . getKey ( ) ; if ( ss . length ( ) > s . length ( ) ) s = ss ; } } return s ; }
void preCompute ( int n , String s , int pref [ ] ) { pref [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { pref [ i ] = pref [ i - 1 ] ; if ( s . charAt ( i - 1 ) == s . charAt ( i ) ) pref [ i ] ++ ; } }
int query ( int pref [ ] , int l , int r ) { return pref [ r ] - pref [ l ] ; }
int countWays ( String s1 , String s2 , int n ) { int a , b , c , d ; a = b = c = d = 0 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s2 . charAt ( i ) == '0' ) { if ( s1 . charAt ( i ) == '0' ) { c ++ ; } else { d ++ ; } } else { if ( s1 . charAt ( i ) == '0' ) { a ++ ; } else { b ++ ; } } } result = a * d + b * c + c * d ; return result ; }
boolean isPrime ( int n ) { int i ; if ( n == 1 ) { return false ; } for ( i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; }
boolean check_frequency ( char [ ] s ) { HashMap < Character , Integer > m = new HashMap < Character , Integer > ( ) ; { if ( m . containsKey ( s [ i ] ) ) { m . put ( s [ i ] , m . get ( s [ i ] ) + 1 ) ; } else { m . put ( s [ i ] , 1 ) ; } } for ( char ch = 'a' ; ch <= 'z' ; ch ++ ) { if ( m . get ( ch ) != null && m . get ( ch ) > 0 && ! isPrime ( m . get ( ch ) ) ) { return false ; } } return true ; }
int returnWinner ( String s , int l ) { int freq [ ] = new int [ 26 ] ; for ( int i = 0 ; i < l ; i ++ ) { freq [ s . charAt ( i ) - 'a' ] ++ ; } int cnt = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] % 2 != 0 ) cnt ++ ; } if ( ( cnt == 0 ) || ( cnt & 1 ) == 1 ) return 1 ; else return 2 ; }
int check ( String s ) { int i , j ; int fr [ ] = new int [ 26 ] ; int n = s . length ( ) ; for ( i = 0 ; i < n ; i ++ ) { char x = s . charAt ( i ) ; fr [ x - 'a' ] += 1 ; } int minimum = Integer . MAX_VALUE ; for ( i = 0 ; i < 26 ; i ++ ) { for ( j = i + 1 ; j < 26 ; j ++ ) { int z = fr [ i ] + fr [ j ] ; minimum = Math . min ( minimum , n - z ) ; } } return minimum ; }
int findSubstringCount ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str . charAt ( i ) + 1 == str . charAt ( i + 1 ) ) { result ++ ; while ( str . charAt ( i ) + 1 == str . charAt ( i + 1 ) ) { i ++ ; } } } return result ; }
int CountCharacters ( String str , int l , int r ) { int cnt = 0 ; Map < Character , Integer > m = new HashMap < Character , Integer > ( ) ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ! ( l <= str . charAt ( i ) && str . charAt ( i ) <= r ) ) { cnt ++ ; if ( m . get ( str . charAt ( i ) ) != null ) if ( m . get ( str . charAt ( i ) ) != 1 ) { System . out . print ( str . charAt ( i ) + " " ) ; m . put ( str . charAt ( i ) , m . get ( str . charAt ( i ) ) == null ? 0 : m . get ( str . charAt ( i ) ) + 1 ) ; } } } return cnt ; }
int strScore ( String str [ ] , String s , int n ) { int score = 0 , index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) score += s . charAt ( j ) - 'a' + 1 ; index = i + 1 ; break ; } } score = score * index ; return score ; }
int countChar ( String str , char x ) { int count = 0 ; int n = 10 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str . charAt ( i ) == x ) count ++ ; int repetitions = n / str . length ( ) ; count = count * repetitions ; for ( int i = 0 ; i < n % str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == x ) count ++ ; } return count ; }
int countConsecutive ( String s ) { int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) { i ++ ; } else { count ++ ; } } return count ; }
int check_digits ( int n ) { while ( n > 0 ) { return 0 ; n /= 10 ; } return 1 ; }
int smallest_number ( int n ) { for ( int i = n ; ; i ++ ) if ( check_digits ( i ) > 0 ) return i ; }
int minSteps ( String str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) - 2 ; i ++ ) { if ( ( ( int ) str . charAt ( i ) ) == '0' ) { if ( str . charAt ( i + 1 ) == '1' ) { if ( str . charAt ( i + 2 ) == '0' ) { count ++ ; i += 2 ; } } } } return count ; }
void SieveOfEratosthenes ( boolean prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
int xorOfPrime ( char [ ] s ) { boolean [ ] prime = new boolean [ 100005 ] ; for ( int i = 0 ; i < 100005 ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , 10005 ) ; int i , j ; Map < Character , Integer > m = new HashMap < > ( ) ; for ( i = 0 ; i < s . length ; i ++ ) { if ( m . containsKey ( s [ i ] ) ) { m . put ( s [ i ] , m . get ( s [ i ] ) + 1 ) ; } else { m . put ( s [ i ] , 1 ) ; } } int result = 0 ; int flag = 0 ; for ( Map . Entry < Character , Integer > entry : m . entrySet ( ) ) { if ( prime [ entry . getValue ( ) ] ) { result ^= entry . getValue ( ) ; flag = 1 ; } } if ( flag != 1 ) return - 1 ; return result ; }
int CountCharacters ( String str , int k ) { int cnt = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ( ( int ) str . charAt ( i ) ) < k ) cnt ++ ; } return cnt ; }
void dfs ( String node , int k , String A ) { for ( int i = 0 ; i < k ; ++ i ) { String str = node + A . charAt ( i ) ; if ( ! seen . contains ( str ) ) { seen . add ( str ) ; dfs ( str . substring ( 1 ) , k , A ) ; edges . add ( i ) ; } } }
int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { f = f * i ; } return f ; }
int npr ( int n , int r ) { return fact ( n ) / fact ( n - r ) ; }
boolean checkIfUnequal ( int n , int q ) { String s1 = Integer . toString ( n ) ; int a [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) a [ s1 . charAt ( i ) - '0' ] ++ ; int prod = n * q ; String s2 = Integer . toString ( prod ) ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( a [ s2 . charAt ( i ) - '0' ] > 0 ) return false ; } return true ; }
int countInRange ( int l , int r , int q ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( checkIfUnequal ( i , q ) ) count ++ ; } return count ; }
int search ( int arr [ ] , int strt , int end , int value ) { int i ; for ( i = strt ; i <= end ; i ++ ) { if ( arr [ i ] == value ) break ; } return i ; }
void preOrder ( Node node ) { if ( node == null ) return ; System . out . print ( node . data + " " ) ; preOrder ( node . left ) ; preOrder ( node . right ) ; }
int countOnOff ( String n ) { int Led [ ] = { 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 5 } ; int len = n . length ( ) ; int sum = Led [ n . charAt ( 0 ) - '0' ] ; for ( int i = 1 ; i < len ; i ++ ) { sum = sum + Math . abs ( Led [ n . charAt ( i ) - '0' ] - Led [ n . charAt ( i - 1 ) - '0' ] ) ; } return sum ; }
boolean checkMarkov ( double m [ ] [ ] ) { for ( int i = 0 ; i < m . length ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < m [ i ] . length ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }
boolean isBinary ( int n ) { while ( n != 0 ) { int temp = n % 10 ; if ( temp != 0 && temp != 1 ) { return false ; } n = n / 10 ; } return true ; }
boolean checkPalindrome ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( s . length ( ) - i - 1 ) ) return false ; } return true ; }
boolean CheckOdd ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String x = "" ; for ( int j = i ; j < n ; j ++ ) { x += s . charAt ( j ) ; if ( x . length ( ) % 2 == 0 && checkPalindrome ( x ) == true ) return false ; } } return true ; }
boolean areVowelsInOrder ( String s ) { int n = s . length ( ) ; char c = ( char ) 64 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == 'a' || s . charAt ( i ) == 'e' || s . charAt ( i ) == 'i' || s . charAt ( i ) == 'o' || s . charAt ( i ) == 'u' ) { if ( s . charAt ( i ) < c ) return false ; else { c = s . charAt ( i ) ; } } } return true ; }
void solve ( String s , int k ) { int count = 0 , length = 0 , pos = 0 ; HashMap < Character , Integer > m = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m . containsKey ( s . charAt ( i ) ) ) m . put ( s . charAt ( i ) , m . get ( s . charAt ( i ) ) + 1 ) ; else m . put ( s . charAt ( i ) , 1 ) ; length ++ ; if ( length > k ) { m . put ( s . charAt ( pos ) , m . get ( s . charAt ( pos ) ) - 1 ) ; pos ++ ; length -- ; } if ( length == k && m . get ( s . charAt ( i ) ) == length ) count ++ ; } System . out . println ( count ) ; }
void solve ( String s ) { HashMap < Character , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m . containsKey ( s . charAt ( i ) ) ) m . put ( s . charAt ( i ) , m . get ( s . charAt ( i ) ) + 1 ) ; else m . put ( s . charAt ( i ) , 1 ) ; } String new_string = "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m . get ( s . charAt ( i ) ) % 2 == 0 ) continue ; new_string = new_string + s . charAt ( i ) ; } System . out . println ( new_string ) ; }
boolean isDiagonalMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; return true ; }
int minParentheses ( String p ) { int bal = 0 ; int ans = 0 ; for ( int i = 0 ; i < p . length ( ) ; ++ i ) { bal += p . charAt ( i ) == '(' ? 1 : - 1 ; if ( bal == - 1 ) { ans += 1 ; bal += 1 ; } } return bal + ans ; }
int fact ( int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result *= i ; return result ; }
int getResult ( String str , char ch ) { int has [ ] = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) has [ i ] = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) has [ str . charAt ( i ) - 'A' ] ++ ; int particular = has [ ch - 'A' ] ; if ( particular == 0 ) return 0 ; has [ ch - 'A' ] = 0 ; int total = str . length ( ) ; total = total - particular + 1 ; int result = fact ( total ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( has [ i ] > 1 ) { result = result / fact ( has [ i ] ) ; } } return result ; }
boolean isAnyNotPalindrome ( String s ) { Set < Character > unique = new HashSet < Character > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) unique . add ( s . charAt ( i ) ) ; if ( unique . size ( ) > 1 ) return true ; else return false ; }
long factorial ( long n ) { long res = 1 ; for ( int i = 1 ; i <= n ; i ++ ) res = res * i ; return res ; }
boolean isScalarMatrix ( int mat [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( int i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; return true ; }
int Remainder ( String str , int R ) { int len = str . length ( ) ; int Num , Rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str . charAt ( i ) - '0' ) ; Rem = Num % R ; } return Rem ; }
void Solve ( int N , int M ) { int temp = ( N - 1 ) * ( M - 1 ) ; int ans = ( int ) ( Math . pow ( 2 , temp ) ) ; if ( ( N + M ) % 2 != 0 ) System . out . print ( ans ) ; else System . out . print ( 2 * ans ) ; }
void countWays ( int a [ ] , int n ) { int i , j ; long suff [ ] = new long [ n ] ; if ( a [ n - 1 ] == 2 ) suff [ n - 1 ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] == 2 ) suff [ i ] = suff [ i + 1 ] + 1 ; else suff [ i ] = suff [ i + 1 ] ; } long ss = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ss += suff [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] == 1 && a [ j ] == 1 && suff [ j ] >= 2 ) { ss += ( suff [ j ] ) * ( suff [ j ] - 1 ) / 2 ; } } } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] == 1 && a [ j ] == 1 && ( suff [ i ] - suff [ j ] ) >= 1 && suff [ j ] >= 1 ) { ss += ( suff [ i ] - suff [ j ] ) * suff [ j ] ; } } } System . out . println ( ss ) ; }
long productAscii ( String str ) { long prod = 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { prod *= str . charAt ( i ) ; } return prod ; }
void sortByRow ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) Arrays . sort ( mat [ i ] ) ; }
void transpose ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { int temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ j ] [ i ] ; mat [ j ] [ i ] = temp ; } }
void sortMatRowAndColWise ( int mat [ ] [ ] , int n ) { sortByRow ( mat , n ) ; transpose ( mat , n ) ; sortByRow ( mat , n ) ; transpose ( mat , n ) ; }
int minimumLength ( String s ) { int maxOcc = 0 , n = s . length ( ) ; int arr [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ s . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ; return ( n - maxOcc ) ; }
void balancedString ( String str ) { int count = 0 , i ; int n = str . length ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '(' ) { System . out . print ( str . charAt ( i ) ) ; count ++ ; } else if ( str . charAt ( i ) == ')' && count != 0 ) { System . out . print ( str . charAt ( i ) ) ; count -- ; } else if ( str . charAt ( i ) != ')' ) System . out . print ( str . charAt ( i ) ) ; } if ( count != 0 ) for ( i = 0 ; i < count ; i ++ ) System . out . print ( ")" ) ; }
int minOperation ( String s , int i , int j , int count ) { if ( ( i >= s . length ( ) && j < 0 ) || ( i == j ) ) return MAX ; if ( s . charAt ( i ) == s . charAt ( j ) ) return count ; if ( i >= s . length ( ) ) return minOperation ( s , i , j - 1 , count + 1 ) ; else if ( j < 0 ) return minOperation ( s , i + 1 , j , count + 1 ) ; else return Math . min ( minOperation ( s , i , j - 1 , count + 1 ) , minOperation ( s , i + 1 , j , count + 1 ) ) ; }
int minOperation ( String s , int i , int j , int count ) { if ( ( i >= s . length ( ) && j < 0 ) || ( i == j ) ) { return MAX ; } if ( s . charAt ( i ) == s . charAt ( j ) || ( count >= Min ) ) { return count ; } String str = String . valueOf ( i ) + "|" + String . valueOf ( j ) ; if ( ! m . containsKey ( str ) ) { if ( i >= s . length ( ) ) { m . put ( str , minOperation ( s , i , j - 1 , count + 1 ) ) ; } else if ( j < 0 ) { m . put ( str , minOperation ( s , i + 1 , j , count + 1 ) ) ; } else { m . put ( str , Math . min ( minOperation ( s , i , j - 1 , count + 1 ) , minOperation ( s , i + 1 , j , count + 1 ) ) ) ; } } if ( m . get ( str ) < Min ) { Min = m . get ( str ) ; } return m . get ( str ) ; }
int countStrings ( String s ) { int sum = 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( i % 2 == 0 && s . charAt ( i ) == '$' ) sum *= 21 ; else if ( s . charAt ( i ) == '$' ) sum *= 5 ; } return sum ; }
int firstPos ( String str , int start , int end ) { int firstChar = - 1 ; for ( int i = start ; i <= end ; i ++ ) { if ( str . charAt ( i ) >= 'a' && str . charAt ( i ) <= 'z' ) { firstChar = i ; break ; } } return firstChar ; }
int lastPos ( String str , int start , int end ) { int lastChar = - 1 ; for ( int i = start ; i >= end ; i -- ) { if ( str . charAt ( i ) >= 'a' && str . charAt ( i ) <= 'z' ) { lastChar = i ; break ; } } return lastChar ; }
boolean isInGivenBase ( String str , int base ) { if ( base > 16 ) return false ; else if ( base <= 10 ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ! ( str . charAt ( i ) >= '0' && str . charAt ( i ) < ( '0' + base ) ) ) return false ; } else { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ! ( ( str . charAt ( i ) >= '0' && str . charAt ( i ) < ( '0' + base ) ) || ( str . charAt ( i ) >= 'A' && str . charAt ( i ) < ( 'A' + base - 10 ) ) ) ) return false ; } return true ; }
void frequency ( int fre [ ] [ ] , String s [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { String str = s [ i ] ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) fre [ i ] [ str . charAt ( j ) - 'a' ] ++ ; } }
void printIndex ( String str , String s ) { boolean flag = false ; for ( int i = 0 ; i < str . length ( ) - s . length ( ) + 1 ; i ++ ) { if ( str . substring ( i , i + s . length ( ) ) . equals ( s ) ) { System . out . print ( i + " " ) ; flag = true ; } } if ( flag == false ) { System . out . println ( "NONE" ) ; } }
int powerOfJump ( String s ) { int count = 1 ; int max_so_far = Integer . MIN_VALUE ; char ch = s . charAt ( s . length ( ) - 1 ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ch ) { if ( count > max_so_far ) { max_so_far = count ; } count = 1 ; } else count ++ ; } return max_so_far ; }
int findLongestSub ( String bin ) { int n = bin . length ( ) , i ; int sum = 0 ; HashMap < Integer , Integer > prevSum = new HashMap < > ( ) ; int maxlen = 0 ; int currlen ; for ( i = 0 ; i < n ; i ++ ) { if ( bin . charAt ( i ) == '1' ) sum ++ ; else sum -- ; if ( sum > 0 ) { maxlen = i + 1 ; } else if ( sum <= 0 ) { if ( prevSum . containsKey ( sum - 1 ) ) { currlen = i - ( prevSum . get ( sum - 1 ) == null ? 1 : prevSum . get ( sum - 1 ) ) ; maxlen = Math . max ( maxlen , currlen ) ; } } if ( ! prevSum . containsKey ( sum ) ) prevSum . put ( sum , i ) ; } return maxlen ; }
void countEvenOdd ( int arr [ ] , int n , int K ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ; y = __builtin_popcount ( K ) ; if ( ( y & 1 ) != 0 ) { System . out . println ( "Even = " + odd + ", Odd = " + even ) ; } else { System . out . println ( "Even = " + even + ", Odd = " + odd ) ; } }
int averageValue ( String s ) { int sum_char = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum_char += ( int ) s . charAt ( i ) ; } return sum_char / s . length ( ) ; }
int findNumberOfTimes ( String str1 , String str2 ) { int freq [ ] = new int [ 26 ] ; int freq2 [ ] = new int [ 26 ] ; int l1 = str1 . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) { freq [ str1 . charAt ( i ) - 'a' ] += 1 ; } int l2 = str2 . length ( ) ; for ( int i = 0 ; i < l2 ; i ++ ) { freq2 [ str2 . charAt ( i ) - 'a' ] += 1 ; } int count = Integer . MAX_VALUE ; for ( int i = 0 ; i < l2 ; i ++ ) { if ( freq2 [ str2 . charAt ( i ) - 'a' ] != 0 ) count = Math . min ( count , freq [ str2 . charAt ( i ) - 'a' ] / freq2 [ str2 . charAt ( i ) - 'a' ] ) ; } return count ; }
boolean solve ( String s1 , String s2 ) { boolean flag1 = false , flag2 = false ; if ( s1 . length ( ) != s2 . length ( ) ) return false ; int l = s1 . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s1 . charAt ( i ) == '1' ) flag1 = true ; if ( s2 . charAt ( i ) == '1' ) flag2 = true ; if ( flag1 == true && flag2 == true ) return true ; } if ( ! flag1 && ! flag2 ) return true ; return false ; }
boolean check ( String s , int l ) { int freq [ ] = new int [ 26 ] ; Arrays . fill ( freq , 0 ) ; for ( int i = 0 ; i < l ; i ++ ) { freq [ s . charAt ( i ) - 'a' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] >= 2 ) return true ; } return false ; }
boolean isPalindrome ( String str , int l , int r ) { while ( l < r ) { if ( str . charAt ( l ) != str . charAt ( r ) ) return false ; l ++ ; r -- ; } return true ; }
int CyclicShifts ( String str ) { int n = str . length ( ) ; int left = 0 ; int right = n - 1 ; str = str + str ; int cnt = 0 ; while ( right < 2 * n - 1 ) { if ( isPalindrome ( str , left , right ) ) break ; cnt ++ ; left ++ ; right ++ ; } return cnt ; }
void printNum ( String s ) { int i = 0 , j = 0 , val = 0 ; LinkedHashMap < Integer , Integer > hm = new LinkedHashMap < > ( ) ; val = ( s . charAt ( 0 ) - '0' ) * 100 + ( s . charAt ( 1 ) - '0' ) * 10 + ( s . charAt ( 2 ) - '0' ) ; hm . put ( val , 1 ) ; for ( i = 3 ; i < s . length ( ) ; i ++ ) { val = ( val % 100 ) * 10 + s . charAt ( i ) - '0' ; if ( hm . containsKey ( val ) ) { hm . put ( val , hm . get ( val ) + 1 ) ; } else { hm . put ( val , 1 ) ; } } for ( Map . Entry < Integer , Integer > en : hm . entrySet ( ) ) { int key = en . getKey ( ) ; int value = en . getValue ( ) ; if ( value > 1 ) System . out . println ( key + " - " + value + " times" ) ; } }
int countSubstrig ( String str1 , String str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; if ( n1 == 0 n1 < n2 ) return 0 ; if ( str1 . substring ( 0 , n2 ) . equals ( str2 ) ) return countSubstrig ( str1 . substring ( n2 - 1 ) , str2 ) + 1 ; return countSubstrig ( str1 . substring ( n2 - 1 ) , str2 ) ; }
boolean check ( String s , int m ) { int l = s . length ( ) ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == '0' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; }
char nextGreatestAlphabet ( char alphabets [ ] , char K ) { int n = alphabets . length ; if ( K >= alphabets [ n - 1 ] ) return alphabets [ 0 ] ; int l = 0 , r = alphabets . length - 1 ; int ans = - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( alphabets [ mid ] > K ) { r = mid - 1 ; ans = mid ; } else l = mid + 1 ; } return alphabets [ ans ] ; }
void reverse ( char str [ ] , int start , int end ) { char temp ; while ( start <= end ) { temp = str [ start ] ; str [ start ] = str [ end ] ; str [ end ] = temp ; start ++ ; end -- ; } }
void reverseletter ( char str [ ] , int start , int end ) { int wstart , wend ; for ( wstart = wend = start ; wend < end ; wend ++ ) { if ( str [ wend ] == ' ' ) { continue ; } while ( wend <= end && str [ wend ] != ' ' ) { wend ++ ; } wend -- ; reverse ( str , wstart , wend ) ; } }
int subCount ( int arr [ ] , int n , int k ) { int mod [ ] = new int [ k ] ; Arrays . fill ( mod , 0 ) ; int cumSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumSum += arr [ i ] ; mod [ ( ( cumSum % k ) + k ) % k ] ++ ; } int result = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( mod [ i ] > 1 ) result += ( mod [ i ] * ( mod [ i ] - 1 ) ) / 2 ; result += mod [ 0 ] ; return result ; }
int countSubmatrix ( int mat [ ] [ ] , int n , int k ) { int tot_count = 0 ; int left , right , i ; int temp [ ] = new int [ n ] ; for ( left = 0 ; left < n ; left ++ ) { Arrays . fill ( temp , 0 ) ; for ( right = left ; right < n ; right ++ ) { for ( i = 0 ; i < n ; ++ i ) temp [ i ] += mat [ i ] [ right ] ; tot_count += subCount ( temp , n , k ) ; } } return tot_count ; }
int matchClosing ( char X [ ] , int start , int end , char open , char close ) { int c = 1 ; int i = start + 1 ; while ( i <= end ) { if ( X [ i ] == open ) { c ++ ; } else if ( X [ i ] == close ) { c -- ; } if ( c == 0 ) { return i ; } i ++ ; } return i ; }
int matchingOpening ( char X [ ] , int start , int end , char open , char close ) { int c = - 1 ; int i = end - 1 ; while ( i >= start ) { if ( X [ i ] == open ) { c ++ ; } else if ( X [ i ] == close ) { c -- ; } if ( c == 0 ) { return i ; } i -- ; } return - 1 ; }
boolean isBalanced ( char X [ ] , int n ) { int i , j = 0 , k , x , start , end ; for ( i = 0 ; i < n ; i ++ ) { if ( X [ i ] == '(' ) { j = matchClosing ( X , i , n - 1 , '(' , ')' ) ; } else if ( X [ i ] == '{' ) { j = matchClosing ( X , i , n - 1 , '{' , '}' ) ; } else if ( X [ i ] == '[' ) { j = matchClosing ( X , i , n - 1 , '[' , ']' ) ; } else { if ( X [ i ] == ')' ) { j = matchingOpening ( X , 0 , i , '(' , ')' ) ; } else if ( X [ i ] == '}' ) { j = matchingOpening ( X , 0 , i , '{' , '}' ) ; } else if ( X [ i ] == ']' ) { j = matchingOpening ( X , 0 , i , '[' , ']' ) ; } if ( j < 0 j >= i ) { return false ; } continue ; } if ( j >= n j < 0 ) { return false ; } start = i ; end = j ; for ( k = start + 1 ; k < end ; k ++ ) { if ( X [ k ] == '(' ) { x = matchClosing ( X , k , end , '(' , ')' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ')' ) { x = matchingOpening ( X , start , k , '(' , ')' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == '{' ) { x = matchClosing ( X , k , end , '{' , '}' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == '}' ) { x = matchingOpening ( X , start , k , '{' , '}' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == '[' ) { x = matchClosing ( X , k , end , '[' , ']' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ']' ) { x = matchingOpening ( X , start , k , '[' , ']' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } } } return true ; }
String possibleToSort ( int arr [ ] , int n , String str ) { int max_element = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { max_element = Math . max ( max_element , arr [ i ] ) ; if ( str . charAt ( i ) == '0' ) { if ( max_element > i + 1 ) return "No" ; } } return "Yes" ; }
int largestNum ( int n ) { int num = 0 ; int max_setBits = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { int setBits = countSetBits ( i ) ; if ( setBits >= max_setBits ) { num = i ; max_setBits = setBits ; } } return num ; }
int findMinOpeartion ( int matrix [ ] [ ] , int n ) { int [ ] sumRow = new int [ n ] ; int [ ] sumCol = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { sumRow [ i ] += matrix [ i ] [ j ] ; sumCol [ j ] += matrix [ i ] [ j ] ; } int maxSum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { maxSum = Math . max ( maxSum , sumRow [ i ] ) ; maxSum = Math . max ( maxSum , sumCol [ i ] ) ; } int count = 0 ; for ( int i = 0 , j = 0 ; i < n && j < n ; ) { int diff = Math . min ( maxSum - sumRow [ i ] , maxSum - sumCol [ j ] ) ; matrix [ i ] [ j ] += diff ; sumRow [ i ] += diff ; sumCol [ j ] += diff ; count += diff ; if ( sumRow [ i ] == maxSum ) ++ i ; if ( sumCol [ j ] == maxSum ) ++ j ; } return count ; }
int countPair ( char str [ ] [ ] , int n ) { int [ ] cnt = new int [ 1 << 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { int mask = 0 ; for ( int j = 0 ; j < str [ i ] . length ; ++ j ) mask |= ( 1 << ( str [ i ] [ j ] - '0' ) ) ; cnt [ mask ] ++ ; } int ans = 0 ; for ( int m1 = 0 ; m1 <= 1023 ; m1 ++ ) for ( int m2 = 0 ; m2 <= 1023 ; m2 ++ ) if ( ( m1 m2 ) == 1023 ) { ans += ( ( m1 == m2 ) ? ( cnt [ m1 ] * ( cnt [ m1 ] - 1 ) ) : ( cnt [ m1 ] * cnt [ m2 ] ) ) ; } return ans / 2 ; }
long computeStringCount ( int N ) { int n = N / 2 ; long ans = 0 ; for ( int i = 2 ; i <= n ; i += 2 ) ans = ( ans + ( ( nCr [ n ] [ i ] * nCr [ n ] [ i / 2 ] ) % mod ) ) % mod ; return ans ; }
void countSubsequence ( String s , int n ) { int cntG = 0 , cntF = 0 , result = 0 , C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { switch ( s . charAt ( i ) ) { case 'G' : cntG ++ ; result += C ; break ; case 'F' : cntF ++ ; C += cntG ; break ; default : continue ; } } System . out . println ( result ) ; }
int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
String LexicographicalMaxString ( String str ) { char maxchar = 'a' ; ArrayList < Integer > index = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) >= maxchar ) { maxchar = str . charAt ( i ) ; index . add ( i ) ; } } String maxstring = "" ; for ( int i = 0 ; i < index . size ( ) ; i ++ ) { if ( str . substring ( index . get ( i ) , str . length ( ) ) . compareTo ( maxstring ) > 0 ) { maxstring = str . substring ( index . get ( i ) , str . length ( ) ) ; } } return maxstring ; }
boolean isDivisible ( String str , int k ) { int n = str . length ( ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str . charAt ( n - i - 1 ) == '0' ) c ++ ; return ( c == k ) ; }
String longestPalin ( String str ) { str = str + " " ; String longestword = "" , word = "" ; int length , length1 = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch != ' ' ) word = word + ch ; else { length = word . length ( ) ; if ( checkPalin ( word ) && length > length1 ) { length1 = length ; longestword = word ; } word = "" ; } } return longestword ; }
boolean isCommonBase ( String base , String s1 , String s2 ) { for ( int j = 0 ; j < s1 . length ( ) ; ++ j ) { if ( base . charAt ( j % base . length ( ) ) != s1 . charAt ( j ) ) { return false ; } } for ( int j = 0 ; j < s2 . length ( ) ; ++ j ) { if ( base . charAt ( j % base . length ( ) ) != s2 . charAt ( j ) ) { return false ; } } return true ; }
int countCommonBases ( String s1 , String s2 ) { int n1 = s1 . length ( ) , n2 = s2 . length ( ) ; int count = 0 ; for ( int i = 1 ; i <= Math . min ( n1 , n2 ) ; i ++ ) { String base = s1 . substring ( 0 , i ) ; if ( isCommonBase ( base , s1 , s2 ) ) { count ++ ; } } return count ; }
boolean isPrimeString ( String str ) { int len = str . length ( ) , n = 0 ; for ( int i = 0 ; i < len ; i ++ ) n += ( int ) str . charAt ( i ) ; if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int countPalin ( String str ) { str = str + " " ; String word = "" ; int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch != ' ' ) word = word + ch ; else { if ( checkPalin ( word ) ) count ++ ; word = "" ; } } return count ; }
boolean targetstring ( String str1 , String str2 ) { int l1 = str1 . length ( ) ; int l2 = str2 . length ( ) ; if ( l1 != l2 ) return false ; int [ ] map = new int [ MAX ] ; for ( int i = 0 ; i < l1 ; i ++ ) map [ str1 . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) { map [ str2 . charAt ( i ) - 'a' ] -- ; if ( map [ str2 . charAt ( i ) - 'a' ] < 0 ) return false ; } return true ; }
boolean isDigitPresent ( int x , int d ) { while ( x > 0 ) { if ( x % 10 == d ) break ; x = x / 10 ; } return ( x > 0 ) ; }
void printNumbers ( int n , int d ) { for ( int i = 0 ; i <= n ; i ++ ) if ( i == d || isDigitPresent ( i , d ) ) System . out . print ( i + " " ) ; }
void printNumbers ( int n , int d ) { String st = "" + d ; char ch = st . charAt ( 0 ) ; for ( int i = 0 ; i <= n ; i ++ ) { st = "" ; st = st + i ; if ( i == d || st . indexOf ( ch ) >= 0 ) System . out . print ( i + " " ) ; } }
char findExtraCharcter ( String strA , String strB ) { int res = 0 , i ; for ( i = 0 ; i < strA . length ( ) ; i ++ ) { res ^= strA . charAt ( i ) ; } for ( i = 0 ; i < strB . length ( ) ; i ++ ) { res ^= strB . charAt ( i ) ; } return ( ( char ) ( res ) ) ; }
char findExtraCharacter ( String s1 , String s2 ) { String smallStr ; String largeStr ; if ( s1 . length ( ) > s2 . length ( ) ) { smallStr = s2 ; largeStr = s1 ; } else { smallStr = s1 ; largeStr = s2 ; } int smallStrCodeTotal = 0 ; int largeStrCodeTotal = 0 ; int i = 0 ; for ( ; i < smallStr . length ( ) ; i ++ ) { smallStrCodeTotal += smallStr . charAt ( i ) ; largeStrCodeTotal += largeStr . charAt ( i ) ; } largeStrCodeTotal += largeStr . charAt ( i ) ; int intChar = largeStrCodeTotal - smallStrCodeTotal ; return ( char ) intChar ; }
long fact ( int n ) { long res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int countPalinPermutations ( String str ) { int n = str . length ( ) ; int freq [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) ] ++ ; long res = fact ( n / 2 ) ; boolean oddFreq = false ; for ( int i = 0 ; i < MAX ; i ++ ) { int half = freq [ i ] / 2 ; if ( freq [ i ] % 2 != 0 ) { if ( oddFreq == true ) return 0 ; oddFreq = true ; } res = res / fact ( half ) ; } return ( int ) res ; }
int minChanges ( String str ) { int n = str . length ( ) ; if ( n > MAX_CHAR ) return - 1 ; int dist_count = 0 ; int count [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ str . charAt ( i ) - 'a' ] == 0 ) dist_count ++ ; count [ str . charAt ( i ) - 'a' ] ++ ; } return ( n - dist_count ) ; }
void printList ( Node head ) { while ( head != null ) { System . out . print ( head . c + " " ) ; head = head . next ; } }
void strToBinary ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int val = Integer . valueOf ( s . charAt ( i ) ) ; String bin = "" ; while ( val > 0 ) { if ( val % 2 == 1 ) { bin += '1' ; } else bin += '0' ; val /= 2 ; } bin = reverse ( bin ) ; System . out . print ( bin + " " ) ; } }
int numofstring ( int n , int m ) { if ( n == 1 ) return m ; if ( n == 2 ) return m * ( m - 1 ) ; return m * ( m - 1 ) * ( int ) Math . pow ( m - 2 , n - 2 ) ; }
int calculateSum ( String arr [ ] , int n ) { if ( n == 0 ) return 0 ; String s = arr [ 0 ] ; int value = Integer . parseInt ( s ) ; int sum = value ; for ( int i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; value = Integer . parseInt ( s ) ; char operation = arr [ i - 1 ] . charAt ( 0 ) ; if ( operation == '+' ) sum += value ; else sum -= value ; } return sum ; }
int FindMaxProduct ( int arr [ ] [ ] , int n ) { int max = 0 , result ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 1 ) <= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] ; if ( max < result ) max = result ; } } } return max ; }
int CountSpecialPalindrome ( String str ) { int n = str . length ( ) ; int result = 0 ; int [ ] sameChar = new int [ n ] ; for ( int v = 0 ; v < n ; v ++ ) sameChar [ v ] = 0 ; int i = 0 ; while ( i < n ) { int sameCharCount = 1 ; int j = i + 1 ; while ( j < n && str . charAt ( i ) == str . charAt ( j ) ) { sameCharCount ++ ; j ++ ; } result += ( sameCharCount * ( sameCharCount + 1 ) / 2 ) ; sameChar [ i ] = sameCharCount ; i = j ; } for ( int j = 1 ; j < n ; j ++ ) { if ( str . charAt ( j ) == str . charAt ( j - 1 ) ) sameChar [ j ] = sameChar [ j - 1 ] ; if ( j > 0 && j < ( n - 1 ) && ( str . charAt ( j - 1 ) == str . charAt ( j + 1 ) && str . charAt ( j ) != str . charAt ( j - 1 ) ) ) result += Math . min ( sameChar [ j - 1 ] , sameChar [ j + 1 ] ) ; } return result - n ; }
int productAtKthLevel ( String tree , int k ) { int level = - 1 ; int product = 1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree . charAt ( i ) == '(' ) level ++ ; else if ( tree . charAt ( i ) == ')' ) level -- ; else { if ( level == k ) product *= ( tree . charAt ( i ) - '0' ) ; } } return product ; }
boolean isCornerPresent ( String str , String corner ) { int n = str . length ( ) ; int cl = corner . length ( ) ; if ( n < cl ) return false ; return ( str . substring ( 0 , cl ) . equals ( corner ) && str . substring ( n - cl , n ) . equals ( corner ) ) ; }
int factorial ( int n ) { int f = 1 ; for ( int i = 1 ; i <= n ; i ++ ) f = f * i ; return f ; }
int calculateTotal ( char [ ] temp , int n ) { int f = factorial ( n ) ; HashMap < Character , Integer > hm = new HashMap < Character , Integer > ( ) ; for ( int i = 0 ; i < temp . length ; i ++ ) { if ( hm . containsKey ( temp [ i ] ) ) hm . put ( temp [ i ] , hm . get ( temp [ i ] ) + 1 ) ; else hm . put ( temp [ i ] , 1 ) ; } for ( Map . Entry e : hm . entrySet ( ) ) { Integer x = ( Integer ) e . getValue ( ) ; if ( x > 1 ) { int temp5 = factorial ( x ) ; f = f / temp5 ; } } return f ; }
void nextPermutation ( char [ ] temp ) { int i ; for ( i = temp . length - 1 ; i > 0 ; i -- ) if ( temp [ i ] > temp [ i - 1 ] ) break ; int min = i ; int j , x = temp [ i - 1 ] ; for ( j = i + 1 ; j < temp . length ; j ++ ) if ( ( temp [ j ] < temp [ min ] ) && ( temp [ j ] > x ) ) min = j ; char temp_to_swap ; temp_to_swap = temp [ i - 1 ] ; temp [ i - 1 ] = temp [ min ] ; temp [ min ] = temp_to_swap ; Arrays . sort ( temp , i , temp . length ) ; print ( temp ) ; }
int countSpecial ( char [ ] str ) { int len = str . length ; if ( len == 0 ) return 0 ; int co [ ] = new int [ len + 1 ] ; int vo [ ] = new int [ len + 1 ] ; if ( isCons ( str [ len - 1 ] ) == true ) co [ len - 1 ] = 1 ; else vo [ len - 1 ] = 1 ; for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( isCons ( str [ i ] ) == true ) { co [ i ] = co [ i + 1 ] + 1 ; vo [ i ] = vo [ i + 1 ] ; } else { co [ i ] = co [ i + 1 ] ; vo [ i ] = vo [ i + 1 ] + 1 ; } } long ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( isVowel ( str [ i ] ) ) ans = ans + co [ i + 1 ] ; else ans = ans + vo [ i + 1 ] ; } return ( int ) ans ; }
int findSubSequence ( String s , int num ) { int res = 0 ; int i = 0 ; while ( num > 0 ) { if ( ( num & 1 ) == 1 ) res += s . charAt ( i ) - '0' ; i ++ ; num = num >> 1 ; } return res ; }
void findSubsequence ( String str , int k ) { int a [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) a [ str . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( a [ str . charAt ( i ) - 'a' ] >= k ) System . out . print ( str . charAt ( i ) ) ; }
boolean isConvertible ( String str1 , String str2 , int k ) { if ( ( str1 . length ( ) + str2 . length ( ) ) < k ) return true ; int commonLength = 0 ; for ( int i = 0 ; i < Math . min ( str1 . length ( ) , str2 . length ( ) ) ; i ++ ) { if ( str1 == str2 ) commonLength ++ ; else break ; } if ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) return true ; return false ; }
int maxLower ( String str ) { int n = str . length ( ) ; int i = 0 ; for ( ; i < n ; i ++ ) { if ( str . charAt ( i ) >= 'A' && str . charAt ( i ) <= 'Z' ) { i ++ ; break ; } } int maxCount = 0 ; int count [ ] = new int [ MAX_CHAR ] ; for ( ; i < n ; i ++ ) { if ( str . charAt ( i ) >= 'A' && str . charAt ( i ) <= 'Z' ) { int currCount = 0 ; for ( int j = 0 ; j < MAX_CHAR ; j ++ ) { if ( count [ j ] > 0 ) { currCount ++ ; } } maxCount = Math . max ( maxCount , currCount ) ; Arrays . fill ( count , 0 ) ; } if ( str . charAt ( i ) >= 'a' && str . charAt ( i ) <= 'z' ) { count [ str . charAt ( i ) - 'a' ] ++ ; } } return maxCount ; }
int maxLower ( char [ ] str ) { int n = str . length ; int i = 0 ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { i ++ ; break ; } } int maxCount = 0 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { maxCount = Math . max ( maxCount , ( int ) s . size ( ) ) ; s . clear ( ) ; } if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) s . add ( ( int ) str [ i ] ) ; } return maxCount ; }
boolean checkPalindrome ( String str ) { int n = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) if ( str . charAt ( i ) != str . charAt ( n - i - 1 ) ) ++ count ; return ( count <= 1 ) ; }
int minimumflip ( int mat [ ] [ ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }
int findLUSlength ( String a , String b ) { HashMap < String , Integer > map = new HashMap < String , Integer > ( ) ; Vector < String > strArr = new Vector < String > ( ) ; strArr . add ( a ) ; strArr . add ( b ) ; for ( String s : strArr ) { for ( int i = 0 ; i < ( 1 << s . length ( ) ) ; i ++ ) { String t = "" ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( ( ( i >> j ) & 1 ) != 0 ) t += s . charAt ( j ) ; } if ( map . containsKey ( t ) ) map . put ( t , map . get ( t ) + 1 ) ; else map . put ( t , 1 ) ; } } int res = 0 ; for ( HashMap . Entry < String , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) == 1 ) res = Math . max ( res , entry . getKey ( ) . length ( ) ) ; } return res ; }
int findLUSlength ( String a , String b ) { if ( a . equals ( b ) == true ) return 0 ; return Math . max ( a . length ( ) , b . length ( ) ) ; }
String convert ( String str ) { String w = "" , z = "" ; str = str . toUpperCase ( ) + " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch != ' ' ) w = w + ch ; else { z = z + ( Character . toLowerCase ( w . charAt ( 0 ) ) ) + w . substring ( 1 ) + " " ; w = "" ; } } return z ; }
char first ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( Character . isUpperCase ( str . charAt ( i ) ) ) return str . charAt ( i ) ; return 0 ; }
int fact ( int n ) { int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ans * i ; return ( ans ) ; }
int evenDecimalValue ( String str , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int decimalValue = 0 ; int powerOf2 = 1 ; for ( int k = i ; k <= j ; k ++ ) { decimalValue += ( ( str . charAt ( k ) - '0' ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; }
void solve ( String s ) { int l = s . length ( ) ; int x = l / 2 ; int y = l ; String p = "" ; while ( x > 0 && y > l / 2 ) { char ch = s . charAt ( x - 1 ) ; p += ch ; x -- ; ch = s . charAt ( y - 1 ) ; p += ch ; y -- ; } if ( y > l / 2 ) { char ch = s . charAt ( x - 1 ) ; p += ch ; y -- ; } System . out . println ( p ) ; }
boolean isConsonant ( char ch ) { ch = Character . toUpperCase ( ch ) ; return ! ( ch == 'A' ch == 'E' ch == 'I' ch == 'O' ch == 'U' ) && ch >= 65 && ch <= 90 ; }
int totalConsonants ( String str , int n ) { if ( n == 1 ) { if ( isConsonant ( str . charAt ( 0 ) ) ) return 1 ; else return 0 ; } if ( isConsonant ( str . charAt ( n - 1 ) ) ) return totalConsonants ( str , n - 1 ) + 1 ; else return totalConsonants ( str , n - 1 ) ; }
int countSubstr ( String s ) { int n = s . length ( ) ; int [ ] auxArr = new int [ n ] ; if ( s . charAt ( 0 ) == '1' ) auxArr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) auxArr [ i ] = auxArr [ i - 1 ] + 1 ; else auxArr [ i ] = auxArr [ i - 1 ] ; } int count = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) if ( s . charAt ( i ) == '1' ) count += auxArr [ i ] ; return count ; }
int calSumUtil ( int a [ ] , int b [ ] , int n , int m ) { int [ ] sum = new int [ n ] ; int i = n - 1 , j = m - 1 , k = n - 1 ; int carry = 0 , s = 0 ; while ( j >= 0 ) { s = a [ i ] + b [ j ] + carry ; sum [ k ] = ( s % 10 ) ; carry = s / 10 ; k -- ; i -- ; j -- ; } while ( i >= 0 ) { s = a [ i ] + carry ; sum [ k ] = ( s % 10 ) ; carry = s / 10 ; i -- ; k -- ; } int ans = 0 ; if ( carry == 1 ) ans = 10 ; for ( i = 0 ; i <= n - 1 ; i ++ ) { ans += sum [ i ] ; ans *= 10 ; } return ans / 10 ; }
int calSum ( int a [ ] , int b [ ] , int n , int m ) { if ( n >= m ) return calSumUtil ( a , b , n , m ) ; else return calSumUtil ( b , a , m , n ) ; }
int longCommomAnagramSubseq ( String str1 , String str2 , int n1 , int n2 ) { int [ ] freq1 = new int [ SIZE ] ; int [ ] freq2 = new int [ SIZE ] ; for ( int i = 0 ; i < SIZE ; i ++ ) { freq1 [ i ] = 0 ; freq2 [ i ] = 0 ; } int len = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) freq1 [ ( int ) str1 . charAt ( i ) - ( int ) 'a' ] ++ ; for ( int i = 0 ; i < n2 ; i ++ ) freq2 [ ( int ) str2 . charAt ( i ) - ( int ) 'a' ] ++ ; for ( int i = 0 ; i < SIZE ; i ++ ) len += Math . min ( freq1 [ i ] , freq2 [ i ] ) ; return len ; }
boolean isPanalphabeticWindow ( String s , int n ) { char ch = 'a' ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ch ) ch ++ ; if ( ch == 'z' + 1 ) return true ; } return false ; }
int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; }
boolean HalfDiagonalSums ( int mat [ ] [ ] , int n ) { int diag1_left = 0 , diag1_right = 0 ; int diag2_left = 0 , diag2_right = 0 ; for ( int i = 0 , j = n - 1 ; i < n ; i ++ , j -- ) { if ( i < n / 2 ) { diag1_left += mat [ i ] [ i ] ; diag2_left += mat [ j ] [ i ] ; } else if ( i > n / 2 ) { diag1_right += mat [ i ] [ i ] ; diag2_right += mat [ j ] [ i ] ; } } return ( diag1_left == diag2_right && diag2_right == diag2_left && diag1_right == diag2_left && diag2_right == mat [ n / 2 ] [ n / 2 ] ) ; }
boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
void prime_index ( String input ) { int n = input . length ( ) ; for ( int i = 2 ; i <= n ; i ++ ) if ( isPrime ( i ) ) System . out . print ( input . charAt ( i - 1 ) ) ; }
boolean isHeterogram ( String s , int n ) { int hash [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) != ' ' ) { if ( hash [ s . charAt ( i ) - 'a' ] == 0 ) hash [ s . charAt ( i ) - 'a' ] = 1 ; else return false ; } } return true ; }
void ASCIISentence ( String str ) { int l = str . length ( ) ; int convert ; for ( int i = 0 ; i < l ; i ++ ) { convert = str . charAt ( i ) ; System . out . print ( convert ) ; } }
void preProcess ( String a , String b ) { int n = a . length ( ) ; int j = 0 ; for ( int i = 1 ; i <= a . length ( ) ; i ++ ) { if ( j < b . length ( ) && a . charAt ( i - 1 ) == b . charAt ( j ) ) { j ++ ; } fwd [ i ] = j ; } j = 0 ; for ( int i = a . length ( ) ; i >= 1 ; i -- ) { if ( j < b . length ( ) && a . charAt ( i - 1 ) == b . charAt ( b . length ( ) - j - 1 ) ) { j ++ ; } bwd [ i ] = j ; } }
int findOccurrences ( String str1 , String substr1 ) { int counter = 0 ; char [ ] str = str1 . toCharArray ( ) ; char [ ] substr = substr1 . toCharArray ( ) ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { if ( str [ i ] == substr [ 0 ] ) { for ( int j = i + 1 ; j < str1 . length ( ) ; j ++ ) { if ( str [ j ] == substr [ 1 ] ) { for ( int k = j + 1 ; k < str1 . length ( ) ; k ++ ) { if ( str [ k ] == substr [ 2 ] ) counter ++ ; } } } } } return counter ; }
int findOccurrences ( String str1 , String substr1 ) { int n = str1 . length ( ) ; char [ ] str = str1 . toCharArray ( ) ; char [ ] substr = substr1 . toCharArray ( ) ; int [ ] preLeft = new int [ n ] ; int [ ] preRight = new int [ n ] ; if ( str [ 0 ] == substr [ 0 ] ) preLeft [ 0 ] ++ ; for ( int i = 1 ; i < n ; i ++ ) { if ( str [ i ] == substr [ 0 ] ) preLeft [ i ] = preLeft [ i - 1 ] + 1 ; else preLeft [ i ] = preLeft [ i - 1 ] ; } if ( str [ n - 1 ] == substr [ 2 ] ) preRight [ n - 1 ] ++ ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( str [ i ] == substr [ 2 ] ) preRight [ i ] = preRight [ i + 1 ] + 1 ; else preRight [ i ] = preRight [ i + 1 ] ; } int counter = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( str [ i ] == str [ 1 ] ) { int total = preLeft [ i - 1 ] * preRight [ i + 1 ] ; counter += total ; } } return counter ; }
boolean canMakeStr2 ( String str1 , String str2 ) { int [ ] count = new int [ MAX ] ; char [ ] str3 = str1 . toCharArray ( ) ; for ( int i = 0 ; i < str3 . length ; i ++ ) count [ str3 [ i ] ] ++ ; char [ ] str4 = str2 . toCharArray ( ) ; for ( int i = 0 ; i < str4 . length ; i ++ ) { if ( count [ str4 [ i ] ] == 0 ) return false ; count [ str4 [ i ] ] -- ; } return true ; }
boolean isVowel ( char c ) { return ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) ; }
boolean isVowel ( char c ) { return ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) ; }
void finalPosition ( String move ) { int l = move . length ( ) ; int countUp = 0 , countDown = 0 ; int countLeft = 0 , countRight = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( move . charAt ( i ) == 'U' ) countUp ++ ; else if ( move . charAt ( i ) == 'D' ) countDown ++ ; else if ( move . charAt ( i ) == 'L' ) countLeft ++ ; else if ( move . charAt ( i ) == 'R' ) countRight ++ ; } System . out . println ( "Final Position: (" + ( countRight - countLeft ) + ", " + ( countUp - countDown ) + ")" ) ; }
boolean isIdentity ( int mat [ ] [ ] , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }
int maxbalancedprefix ( String str , int n ) { int sum = 0 ; int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '(' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; }
int countOccurrences ( String str , String word ) { String a [ ] = str . split ( " " ) ; int count = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( word . equals ( a [ i ] ) ) count ++ ; } return count ; }
int minCost ( char [ ] s ) { boolean alphabets [ ] = new boolean [ 26 ] ; for ( int i = 0 ; i < s . length ; i ++ ) { alphabets [ ( int ) s [ i ] - 97 ] = true ; } int count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( alphabets [ i ] ) { count ++ ; } } return count ; }
int numberOfDifferentSubstrings ( String s , char a , char b ) { int ans = 0 ; int ls = s . length ( ) ; int [ ] x = new int [ ls ] ; int [ ] y = new int [ ls ] ; for ( int i = 0 ; i < ls ; i ++ ) { if ( s . charAt ( i ) == a ) x [ i ] = 1 ; if ( s . charAt ( i ) == b ) y [ i ] = 1 ; } HashSet < String > hash = new HashSet < > ( ) ; String curr_substr = "" ; for ( int i = 0 ; i < ls ; i ++ ) { if ( x [ i ] != 0 ) { for ( int j = i ; j < ls ; j ++ ) { if ( y [ j ] == 0 ) curr_substr += s . charAt ( i ) ; if ( y [ j ] != 0 ) { curr_substr += s . charAt ( j ) ; if ( ! hash . contains ( curr_substr ) ) ans ++ ; hash . add ( curr_substr ) ; } } curr_substr = "" ; } } return ans ; }
long countWays ( int n , int m , int k ) { if ( n == 1 m == 1 ) return 1 ; else if ( ( n + m ) % 2 == 1 && k == - 1 ) return 0 ; return ( modPower ( modPower ( ( long ) 2 , n - 1 , mod ) , m - 1 , mod ) % mod ) ; }
int cost ( String str ) { int len = str . length ( ) ; int res = 0 ; for ( int i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) if ( str . charAt ( i ) != str . charAt ( j ) ) res += Math . min ( str . charAt ( i ) , str . charAt ( j ) ) - 'a' + 1 ; return res ; }
String pigLatin ( String s ) { int len = s . length ( ) ; int index = - 1 ; for ( int i = 0 ; i < len ; i ++ ) { if ( isVowel ( s . charAt ( i ) ) ) { index = i ; break ; } } if ( index == - 1 ) return "-1" ; return s . substring ( index ) + s . substring ( 0 , index ) + "ay" ; }
boolean isValidISBN ( String isbn ) { int n = isbn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn . charAt ( i ) - '0' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn . charAt ( 9 ) ; if ( last != 'X' && ( last < '0' last > '9' ) ) return false ; sum += ( ( last == 'X' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; }
int remainder ( String str ) { int len = str . length ( ) ; int num , rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str . charAt ( i ) - '0' ) ; rem = num % 11 ; } return rem ; }
int longestSubseq ( String s ) { int n = s . length ( ) ; int [ ] pre_count_0 = new int [ n + 2 ] ; int [ ] pre_count_1 = new int [ n + 1 ] ; int [ ] post_count_0 = new int [ n + 2 ] ; pre_count_0 [ 0 ] = 0 ; post_count_0 [ n + 1 ] = 0 ; pre_count_1 [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { pre_count_0 [ j ] = pre_count_0 [ j - 1 ] ; pre_count_1 [ j ] = pre_count_1 [ j - 1 ] ; post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] ; if ( s . charAt ( j - 1 ) == '0' ) pre_count_0 [ j ] ++ ; else pre_count_1 [ j ] ++ ; if ( s . charAt ( n - j ) == '0' ) post_count_0 [ n - j + 1 ] ++ ; } if ( pre_count_0 [ n ] == n pre_count_0 [ n ] == 0 ) return n ; int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) ans = Math . max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) ; return ans ; }
void removeSpecialCharacter ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) < 'A' || s . charAt ( i ) > 'Z' && s . charAt ( i ) < 'a' || s . charAt ( i ) > 'z' ) { s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; i -- ; } } System . out . print ( s ) ; }
void imageSwap ( int mat [ ] [ ] , int n ) { int row = 0 ; for ( int j = 0 ; j < n ; j ++ ) { Stack < Integer > s = new Stack < > ( ) ; int i = row , k = j ; while ( i < n && k >= 0 ) { s . push ( mat [ i ++ ] [ k -- ] ) ; } i = row ; k = j ; while ( i < n && k >= 0 ) { mat [ i ++ ] [ k -- ] = s . peek ( ) ; s . pop ( ) ; } } int column = n - 1 ; for ( int j = 1 ; j < n ; j ++ ) { Stack < Integer > s = new Stack < > ( ) ; int i = j , k = column ; while ( i < n && k >= 0 ) { s . push ( mat [ i ++ ] [ k -- ] ) ; } i = j ; k = column ; while ( i < n && k >= 0 ) { mat [ i ++ ] [ k -- ] = s . peek ( ) ; s . pop ( ) ; } } }
boolean shouldSwap ( char str [ ] , int start , int curr ) { for ( int i = start ; i < curr ; i ++ ) { if ( str [ i ] == str [ curr ] ) { return false ; } } return true ; }
String decodeMedianString ( String s ) { int l = s . length ( ) ; String s1 = "" ; boolean isEven = ( l % 2 == 0 ) ? true : false ; for ( int i = 0 ; i < l ; i += 2 ) { if ( isEven ) { s1 = s . charAt ( i ) + s1 ; s1 += s . charAt ( i + 1 ) ; } else { if ( l - i > 1 ) { s1 += s . charAt ( i ) ; s1 = s . charAt ( i + 1 ) + s1 ; } else { s1 += s . charAt ( i ) ; } } } return s1 ; }
int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( str . charAt ( i ) == str . charAt ( j ) ) res = Math . max ( res , Math . abs ( j - i - 1 ) ) ; return res ; }
int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; int [ ] firstInd = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) firstInd [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_ind = firstInd [ str . charAt ( i ) ] ; if ( first_ind == - 1 ) firstInd [ str . charAt ( i ) ] = i ; else res = Math . max ( res , Math . abs ( i - first_ind - 1 ) ) ; } return res ; }
boolean isUnique ( int [ ] a , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum += n - 1 ; return ( sum == k ) ; }
void imageSwap ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j <= i ; j ++ ) mat [ i ] [ j ] = mat [ i ] [ j ] + mat [ j ] [ i ] - ( mat [ j ] [ i ] = mat [ i ] [ j ] ) ; }
boolean isPresent ( String s , String q ) { int [ ] freq = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) freq [ s . charAt ( i ) ] ++ ; for ( int i = 0 ; i < q . length ( ) ; i ++ ) { freq [ q . charAt ( i ) ] -- ; if ( freq [ q . charAt ( i ) ] < 0 ) return false ; } return true ; }
String findString ( int n , int k ) { String res = "" ; for ( int i = 0 ; i < k ; i ++ ) res = res + ( char ) ( 'a' + i ) ; int count = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { res = res + ( char ) ( 'a' + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; }
boolean isValid ( String p ) { int n = p . length ( ) ; int c1 = 0 , c0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p . charAt ( i ) == '0' ) { c0 ++ ; } if ( p . charAt ( i ) == '1' ) { c1 ++ ; } } if ( c0 == c1 ) { return true ; } else { return false ; } }
int longestSub ( String s ) { int max_len = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( isValid ( s . substring ( i , j + 1 ) ) && max_len < j - i + 1 ) { max_len = j - i + 1 ; } } } return max_len ; }
boolean isPalindrome ( String s , int i , int j ) { int p = j ; for ( int k = i ; k <= p ; k ++ ) { if ( s . charAt ( k ) != s . charAt ( p ) ) return false ; p -- ; } return true ; }
int countWays ( String s ) { int n = s . length ( ) ; int count = 0 ; if ( isPalindrome ( s , 0 , n - 1 ) ) { for ( int i = n / 2 ; i < n ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) count ++ ; else break ; } { count ++ ; } else  } else { for ( int i = 0 ; i < n / 2 ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( n - 1 - i ) ) { int j = n - 1 - i ; if ( isPalindrome ( s , i , n - 2 - i ) ) { for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( s . charAt ( k ) != s . charAt ( j ) ) break ; count ++ ; } count ++ ; } if ( isPalindrome ( s , i + 1 , n - 1 - i ) ) { for ( int k = n - i ; k < n ; k ++ ) { if ( s . charAt ( k ) != s . charAt ( i ) ) break ; count ++ ; } count ++ ; } break ; } } } return count ; }
boolean makeAndCheckString ( Vector < String > words , String str ) { int n = words . size ( ) ; boolean first = false , second = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( words . get ( i ) == str ) return true ; if ( str . charAt ( 0 ) == words . get ( i ) . charAt ( 1 ) ) first = true ; if ( str . charAt ( 1 ) == words . get ( i ) . charAt ( 0 ) ) second = true ; if ( first && second ) return true ; } return false ; }
int countOfSubstringWithKOnes ( String s , int K ) { int N = s . length ( ) ; int res = 0 ; int countOfOne = 0 ; int [ ] freq = new int [ N + 1 ] ; freq [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { countOfOne += ( s . charAt ( i ) - '0' ) ; if ( countOfOne >= K ) { res += freq [ countOfOne - K ] ; } freq [ countOfOne ] ++ ; } return res ; }
void printRec ( String number , int extraOnes , int remainingPlaces ) { if ( 0 == remainingPlaces ) { System . out . print ( number + " " ) ; return ; } printRec ( number + "1" , extraOnes + 1 , remainingPlaces - 1 ) ; if ( 0 < extraOnes ) printRec ( number + "0" , extraOnes - 1 , remainingPlaces - 1 ) ; }
void printNums ( int n ) { String str = "" ; printRec ( str , 0 , n ) ; }
String getBinaryRep ( int N , int num_of_bits ) { String r = "" ; num_of_bits -- ; while ( num_of_bits >= 0 ) { if ( ( N & ( 1 << num_of_bits ) ) != 0 ) r += "1" ; else r += "0" ; num_of_bits -- ; } return r ; }
ArrayList < String > NBitBinary ( int N ) { ArrayList < String > r = new ArrayList < String > ( ) ; int first = 1 << ( N - 1 ) ; int last = first * 2 ; for ( int i = last - 1 ; i >= first ; -- i ) { int zero_cnt = 0 ; int one_cnt = 0 ; int t = i ; int num_of_bits = 0 ; while ( t > 0 ) { if ( ( t & 1 ) != 0 ) one_cnt ++ ; else zero_cnt ++ ; num_of_bits ++ ; t = t >> 1 ; } if ( one_cnt >= zero_cnt ) { boolean all_prefix_match = true ; int msk = ( 1 << num_of_bits ) - 2 ; int prefix_shift = 1 ; while ( msk > 0 ) { int prefix = ( msk & i ) >> prefix_shift ; int prefix_one_cnt = 0 ; int prefix_zero_cnt = 0 ; while ( prefix > 0 ) { if ( ( prefix & 1 ) != 0 ) prefix_one_cnt ++ ; else prefix_zero_cnt ++ ; prefix = prefix >> 1 ; } if ( prefix_zero_cnt > prefix_one_cnt ) { all_prefix_match = false ; break ; } prefix_shift ++ ; msk = msk & ( msk << 1 ) ; } if ( all_prefix_match ) { r . add ( getBinaryRep ( i , num_of_bits ) ) ; } } } return r ; }
boolean isPossible ( String s1 , String s2 ) { int count [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) count [ ( int ) s2 . charAt ( i ) ] ++ ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( count [ ( int ) s1 . charAt ( i ) ] == 0 ) return false ; count [ ( int ) s1 . charAt ( i ) ] -- ; } return true ; }
boolean checkLuhn ( String cardNo ) { int nDigits = cardNo . length ( ) ; int nSum = 0 ; boolean isSecond = false ; for ( int i = nDigits - 1 ; i >= 0 ; i -- ) { int d = cardNo . charAt ( i ) - '0' ; if ( isSecond == true ) d = d * 2 ; nSum += d / 10 ; nSum += d % 10 ; isSecond = ! isSecond ; } return ( nSum % 10 == 0 ) ; }
boolean isVowel ( char ch ) { if ( ch == 'a' ch == 'e' ch == 'i' ch == 'o' ch == 'u' ) { return true ; } return false ; }
int findRepeatFirstN2 ( String s ) { int p = - 1 , i , j ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { for ( j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; }
boolean isVowel ( char c ) { return ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) ; }
boolean isVowel ( char x ) { return ( x == 'a' x == 'e' x == 'i' x == 'o' x == 'u' ) ; }
boolean isVowel ( char x ) { return ( x == 'a' x == 'e' x == 'i' x == 'o' x == 'u' ) ; }
int substrings ( String s , int k ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int freq [ ] = new int [ MAX_CHAR ] ; for ( int j = i ; j < s . length ( ) ; j ++ ) { int index = s . charAt ( j ) - 'a' ; freq [ index ] ++ ; if ( freq [ index ] > k ) break ; else if ( freq [ index ] == k && check ( freq , k ) == true ) res ++ ; } } return res ; }
void longestSubseqWithK ( String str , int k ) { int n = str . length ( ) ; int freq [ ] = new int [ MAX_CHARS ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str . charAt ( i ) - 'a' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str . charAt ( i ) - 'a' ] >= k ) { System . out . print ( str . charAt ( i ) ) ; } } }
boolean canFormPalindrome ( String str ) { int [ ] count = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str . charAt ( i ) ] ++ ; int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( ( count [ i ] & 1 ) != 0 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; }
void generate ( Set < String > st , String s ) { if ( s . length ( ) == 0 ) { return ; } if ( ! st . contains ( s ) ) { st . add ( s ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String t = s ; t = t . substring ( 0 , i ) + t . substring ( i + 1 ) ; generate ( st , t ) ; } } return ; }
int countSubstrs ( String str , int i , int j , int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str . charAt ( i ) == str . charAt ( j ) ) res ++ ; return res ; }
int countManipulations ( String s1 , String s2 ) { int count = 0 ; int char_count [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) char_count [ s1 . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { char_count [ s2 . charAt ( i ) - 'a' ] -- ; } for ( int i = 0 ; i < 26 ; ++ i ) { if ( char_count [ i ] != 0 ) { count += Math . abs ( char_count [ i ] ) ; } } return count / 2 ; }
char stringPalindrome ( String A , String B ) { int [ ] countA = new int [ MAX_CHAR ] ; int [ ] countB = new int [ MAX_CHAR ] ; int l1 = A . length ( ) ; int l2 = B . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) countA [ A . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) countB [ B . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( ( countA [ i ] > 1 && countB [ i ] == 0 ) ) return 'A' ; return 'B' ; }
boolean check ( Vector < String > list , String s ) { int n = ( int ) list . size ( ) ; if ( n == 0 ) { return false ; } for ( int i = 0 ; i < n ; i ++ ) { if ( list . get ( i ) . length ( ) != s . length ( ) ) { continue ; } boolean diff = false ; for ( int j = 0 ; j < ( int ) list . get ( i ) . length ( ) ; j ++ ) { if ( list . get ( i ) . charAt ( j ) != s . charAt ( j ) ) { if ( ! diff ) { diff = true ; } else { diff = false ; break ; } } } if ( diff ) { return true ; } } return false ; }
int FirstRepeated ( String str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str . charAt ( i ) - 'a' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; }
void search ( int [ ] [ ] mat , int n , int x ) { int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { System . out . print ( "n Found at " + i + " " + j ) ; return ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } System . out . print ( "n Element not found" ) ; return ; }
void nPermute ( String str , int n ) { precomputeFactorirals ( ) ; int len = str . length ( ) ; int freq [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < len ; i ++ ) freq [ str . charAt ( i ) - 'a' ] ++ ; String out = "" ; int sum = 10 ; int k = 0 ; while ( sum >= n ) { for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( freq [ i ] == 0 ) continue ; freq [ i ] -- ; sum = 0 ; int xsum = ( int ) fact [ len - 1 - k ] ; for ( int j = 0 ; j < MAX_CHAR ; j ++ ) xsum /= fact [ freq [ j ] ] ; sum += xsum ; if ( sum >= n ) { out += ( char ) ( i + 'a' ) ; k ++ ; n -= ( sum - xsum ) ; break ; } if ( sum < n ) freq [ i ] ++ ; } } for ( int i = MAX_CHAR - 1 ; k < len && i >= 0 ; i -- ) if ( freq [ i ] != 0 ) { out += ( char ) ( i + 'a' ) ; freq [ i ++ ] -- ; } System . out . println ( out ) ; }
boolean sentencePalindrome ( String str ) { int l = 0 ; int h = str . length ( ) - 1 ; str = str . toLowerCase ( ) ; while ( l <= h ) { char getAtl = str . charAt ( l ) ; char getAth = str . charAt ( h ) ; if ( ! ( getAtl >= 'a' && getAtl <= 'z' ) ) l ++ ; else if ( ! ( getAth >= 'a' && getAth <= 'z' ) ) h -- ; else if ( getAtl == getAth ) { l ++ ; h -- ; } else return false ; } return true ; }
void substringConversions ( String str , int k , int b ) { for ( int i = 0 ; i + k <= str . length ( ) ; i ++ ) { String sub = str . substring ( i , i + k ) ; int sum = 0 , counter = 0 ; for ( int j = sub . length ( ) - 1 ; j >= 0 ; j -- ) { sum = ( int ) ( sum + ( ( sub . charAt ( j ) - '0' ) * Math . pow ( b , counter ) ) ) ; counter ++ ; } System . out . print ( sum + " " ) ; } }
int countBalance ( String s ) { char [ ] str = s . toCharArray ( ) ; int [ ] rightVisited = new int [ MAX_CHAR ] ; int [ ] leftVisited = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) rightVisited [ str [ i ] ] ++ ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { leftVisited [ str [ i ] ] ++ ; rightVisited [ str [ i ] ] -- ; int j ; for ( j = 0 ; j < MAX_CHAR ; j ++ ) { if ( ( leftVisited [ j ] == 0 && rightVisited [ j ] != 0 ) || ( leftVisited [ j ] != 0 && rightVisited [ j ] == 0 ) ) break ; } if ( j == MAX_CHAR ) res ++ ; } return res ; }
int countWords ( String str [ ] , int n ) { HashMap < String , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( str [ i ] ) ) { int get = m . get ( str [ i ] ) ; m . put ( str [ i ] , get + 1 ) ; } else { m . put ( str [ i ] , 1 ) ; } } int res = 0 ; for ( Map . Entry < String , Integer > it : m . entrySet ( ) ) { if ( it . getValue ( ) == 2 ) res ++ ; } return res ; }
int findFlips ( String str , int n ) { char last = ' ' ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( last != str . charAt ( i ) ) res ++ ; last = str . charAt ( i ) ; } return res / 2 ; }
int findLen ( String A , int n , int k , char ch ) { int maxlen = 1 ; int cnt = 0 ; int l = 0 , r = 0 ; while ( r < n ) { if ( A . charAt ( r ) != ch ) ++ cnt ; while ( cnt > k ) { if ( A . charAt ( l ) != ch ) -- cnt ; ++ l ; } maxlen = Math . max ( maxlen , r - l + 1 ) ; ++ r ; } return maxlen ; }
int answer ( String A , int n , int k ) { int maxlen = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) { maxlen = Math . max ( maxlen , findLen ( A , n , k , ( char ) ( i + 'A' ) ) ) ; maxlen = Math . max ( maxlen , findLen ( A , n , k , ( char ) ( i + 'a' ) ) ) ; } return maxlen ; }
void printString ( String str , char ch , int count ) { int occ = 0 , i ; if ( count == 0 ) { System . out . println ( str ) ; return ; } for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ch ) occ ++ ; if ( occ == count ) break ; } if ( i < str . length ( ) - 1 ) System . out . println ( str . substring ( i + 1 ) ) ; else System . out . println ( "Empty string" ) ; }
boolean checkCorrectOrNot ( String s ) { int [ ] count1 = new int [ MAX_CHAR ] ; int [ ] count2 = new int [ MAX_CHAR ] ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count1 [ s . charAt ( i ) - 'a' ] ++ ; count2 [ s . charAt ( j ) - 'a' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; }
boolean checkCorrectOrNot ( String s ) { int [ ] count = new int [ MAX_CHAR ] ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count [ s . charAt ( i ) - 'a' ] ++ ; count [ s . charAt ( j ) - 'a' ] -- ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count [ i ] != 0 ) return false ; return true ; }
int possibleStrings ( int n , int r , int b , int g ) { int fact [ ] = new int [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }
boolean checkString ( String s ) { int len = s . length ( ) ; int first = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( s . charAt ( i ) == '1' ) { first = i ; break ; } } int last = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '1' ) { last = i ; break ; } } for ( int i = first ; i <= last ; i ++ ) if ( s . charAt ( i ) == '0' ) return false ; return true ; }
boolean isVowel ( char c ) { return ( c == 'a' c == 'A' c == 'e' c == 'E' c == 'i' c == 'I' c == 'o' c == 'O' c == 'u' c == 'U' ) ; }
boolean isUnique ( int mat [ ] [ ] , int i , int j , int n , int m ) { int sumrow = 0 ; for ( int k = 0 ; k < m ; k ++ ) { sumrow += mat [ i ] [ k ] ; if ( sumrow > 1 ) return false ; } int sumcol = 0 ; for ( int k = 0 ; k < n ; k ++ ) { sumcol += mat [ k ] [ j ] ; if ( sumcol > 1 ) return false ; } return true ; }
void findAndPrintUncommonChars ( String str1 , String str2 ) { int present [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { present [ i ] = 0 ; } int l1 = str1 . length ( ) ; int l2 = str2 . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) { present [ str1 . charAt ( i ) - 'a' ] = 1 ; } for ( int i = 0 ; i < l2 ; i ++ ) { if ( present [ str2 . charAt ( i ) - 'a' ] == 1 || present [ str2 . charAt ( i ) - 'a' ] == - 1 ) { present [ str2 . charAt ( i ) - 'a' ] = - 1 ; } else { present [ str2 . charAt ( i ) - 'a' ] = 2 ; } } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( present [ i ] == 1 present [ i ] == 2 ) { System . out . print ( ( char ) ( i + 'a' ) + " " ) ; } } }
int countUnique ( int mat [ ] [ ] , int n , int m ) { int [ ] rowsum = new int [ n ] ; int [ ] colsum = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 ) { rowsum [ i ] ++ ; colsum [ j ] ++ ; } int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ; return uniquecount ; }
int lengthOfLastWord ( final String a ) { int len = 0 ; String x = a . trim ( ) ; for ( int i = 0 ; i < x . length ( ) ; i ++ ) { if ( x . charAt ( i ) == ' ' ) len = 0 ; else len ++ ; } return len ; }
boolean isVowel ( char ch ) { ch = Character . toUpperCase ( ch ) ; return ( ch == 'A' ch == 'E' ch == 'I' ch == 'O' ch == 'U' ) ; }
int countVowels ( String str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) ++ count ; return count ; }
int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; }
int countDistinctPermutations ( String str ) { int length = str . length ( ) ; int [ ] freq = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < length ; i ++ ) if ( str . charAt ( i ) >= 'a' ) freq [ str . charAt ( i ) - 'a' ] ++ ; int fact = 1 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) fact = fact * factorial ( freq [ i ] ) ; return factorial ( length ) / fact ; }
boolean uniqueCharacters ( String str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int bitAtIndex = str . charAt ( i ) - 'a' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) return false ; checker = checker | ( 1 << bitAtIndex ) ; } return true ; }
int solve ( int i , int X , int Y , int a [ ] , int b [ ] , int n ) { if ( i == n ) return 0 ; if ( X <= 0 ) return b [ i ] + solve ( i + 1 , X , Y - 1 , a , b , n ) ; if ( Y <= 0 ) return a [ i ] + solve ( i + 1 , X - 1 , Y , a , b , n ) ; else return Math . max ( a [ i ] + solve ( i + 1 , X - 1 , Y , a , b , n ) , b [ i ] + solve ( i + 1 , X , Y - 1 , a , b , n ) ) ; }
char smallest_alphabet ( String a , int n ) { char min = 'z' ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( a . charAt ( i ) < min ) min = a . charAt ( i ) ; return min ; }
Boolean isPalindrome ( String str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) if ( str . charAt ( i ) != str . charAt ( n - i - 1 ) ) return false ; return true ; }
void moveSpaceInFront ( char str [ ] ) { int i = str . length - 1 ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ' ) { char c = str [ i ] ; str [ i ] = str [ j ] ; str [ j ] = c ; i -- ; } }
int countCommon ( int mat [ ] [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }
void moveSpaceInFront ( char str [ ] ) { int i = str . length - 1 ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ' ) str [ i -- ] = str [ j ] ; while ( i >= 0 ) str [ i -- ] = ' ' ; }
int titleToNumber ( String s ) { int result = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { result *= 26 ; result += s . charAt ( i ) - 'A' + 1 ; } return result ; }
void isKthBitSet ( int n , int k ) { if ( ( n & ( 1 << ( k - 1 ) ) ) > 0 ) System . out . print ( "SET" ) ; else System . out . print ( "NOT SET" ) ; }
void isKthBitSet ( int n , int k ) { if ( ( ( n >> ( k - 1 ) ) & 1 ) > 0 ) System . out . println ( "SET" ) ; else System . out . println ( "NOT SET" ) ; }
boolean isPalindrome ( String str ) { int n = str . length ( ) ; if ( n == 0 ) return true ; return isPalRec ( str , 0 , n - 1 ) ; }
boolean areSumSame ( int a [ ] [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 = 0 ; sum2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return true ; } return false ; }
int getIdx ( char ch ) { return ( ch - 'a' ) ; }
boolean allSame ( int freq [ ] , int N ) { int same = 0 ; int i ; for ( i = 0 ; i < N ; i ++ ) { if ( freq [ i ] > 0 ) { same = freq [ i ] ; break ; } } for ( int j = i + 1 ; j < N ; j ++ ) if ( freq [ j ] > 0 && freq [ j ] != same ) return false ; return true ; }
boolean possibleSameCharFreqByOneRemoval ( String str ) { int l = str . length ( ) ; int [ ] freq = new int [ M ] ; for ( int i = 0 ; i < l ; i ++ ) freq [ getIdx ( str . charAt ( i ) ) ] ++ ; if ( allSame ( freq , M ) ) return true ; for ( char c = 'a' ; c <= 'z' ; c ++ ) { int i = getIdx ( c ) ; if ( freq [ i ] > 0 ) { freq [ i ] -- ; if ( allSame ( freq , M ) ) return true ; freq [ i ] ++ ; } } return false ; }
int findIndex ( String str ) { int len = str . length ( ) ; int open [ ] = new int [ len + 1 ] ; int close [ ] = new int [ len + 1 ] ; int index = - 1 ; open [ 0 ] = 0 ; close [ len ] = 0 ; if ( str . charAt ( 0 ) == '(' ) open [ 1 ] = 1 ; if ( str . charAt ( len - 1 ) == ')' ) close [ len - 1 ] = 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '(' ) open [ i + 1 ] = open [ i ] + 1 ; else open [ i + 1 ] = open [ i ] ; } for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == ')' ) close [ i ] = close [ i + 1 ] + 1 ; else close [ i ] = close [ i + 1 ] ; } if ( open [ len ] == 0 ) return len ; if ( close [ 0 ] == 0 ) return 0 ; for ( int i = 0 ; i <= len ; i ++ ) if ( open [ i ] == close [ i ] ) index = i ; return index ; }
boolean checkEquality ( String s ) { return ( s . charAt ( 0 ) == s . charAt ( s . length ( ) - 1 ) ) ; }
int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) count [ s . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }
int getValue ( String str , int i , int m ) { if ( i + m > str . length ( ) ) { return - 1 ; } int value = 0 ; for ( int j = 0 ; j < m ; j ++ ) { int c = str . charAt ( i + j ) - '0' ; if ( c < 0 c > 9 ) { return - 1 ; } value = value * 10 + c ; } return value ; }
int findMissingNumber ( String str ) { for ( int m = 1 ; m <= MAX_DIGITS ; ++ m ) { int n = getValue ( str , 0 , m ) ; if ( n == - 1 ) { break ; } int missingNo = - 1 ; boolean fail = false ; for ( int i = m ; i != str . length ( ) ; i += 1 + Math . log10 ( n ) ) { if ( ( missingNo == - 1 ) && ( getValue ( str , i , ( int ) ( 1 + Math . log10 ( n + 2 ) ) ) == n + 2 ) ) { missingNo = n + 1 ; n += 2 ; else if  ( getValue ( str , i , ( int ) ( 1 + Math . log10 ( n + 1 ) ) ) == n + 1 )  { n ++ ; } else { fail = true ; break ; } } if ( ! fail ) { return missingNo ; } } }
boolean isSmaller ( String str1 , String str2 ) { int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; if ( n1 < n2 ) return true ; if ( n2 < n1 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( str1 . charAt ( i ) < str2 . charAt ( i ) ) return true ; else if ( str1 . charAt ( i ) > str2 . charAt ( i ) ) return false ; } return false ; }
char maxRepeating ( String str ) { int len = str . length ( ) ; int count = 0 ; char res = str . charAt ( 0 ) ; for ( int i = 0 ; i < len ; i ++ ) { int cur_count = 1 ; for ( int j = i + 1 ; j < len ; j ++ ) { if ( str . charAt ( i ) != str . charAt ( j ) ) break ; cur_count ++ ; } if ( cur_count > count ) { count = cur_count ; res = str . charAt ( i ) ; } } return res ; }
boolean isSymmetric ( int mat [ ] [ ] , int N ) { int tr [ ] [ ] = new int [ N ] [ MAX ] ; transpose ( mat , tr , N ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != tr [ i ] [ j ] ) return false ; return true ; }
char maxRepeating ( String str ) { int n = str . length ( ) ; int count = 0 ; char res = str . charAt ( 0 ) ; int cur_count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str . charAt ( i ) == str . charAt ( i + 1 ) ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str . charAt ( i ) ; } cur_count = 1 ; } } return res ; }
boolean check ( String str ) { int n = str . length ( ) ; int oddDigSum = 0 , evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str . charAt ( i ) - '0' ) ; else evenDigSum += ( str . charAt ( i ) - '0' ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }
boolean isSubSequence ( String str1 , String str2 ) { int m = str1 . length ( ) , n = str2 . length ( ) ; for ( int i = 0 ; i < n && j < m ; i ++ ) { if ( str1 . charAt ( j ) == str2 . charAt ( i ) ) { j ++ ; } } return ( j == m ) ; }
boolean isSymmetric ( int mat [ ] [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }
int countWords ( String str , int len ) { int count = 1 ; if ( len == 1 ) return count ; if ( str . charAt ( 0 ) == str . charAt ( 1 ) ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < len - 1 ; j ++ ) { if ( str . charAt ( j ) == str . charAt ( j - 1 ) && str . charAt ( j ) == str . charAt ( j + 1 ) ) count *= 1 ; else if ( str . charAt ( j ) == str . charAt ( j - 1 ) || str . charAt ( j ) == str . charAt ( j + 1 ) || str . charAt ( j - 1 ) == str . charAt ( j + 1 ) ) count *= 2 ; else count *= 3 ; } if ( str . charAt ( len - 1 ) == str . charAt ( len - 2 ) ) count *= 1 ; else count *= 2 ; return count ; }
int hammingDist ( String str1 , String str2 ) { int i = 0 , count = 0 ; while ( i < str1 . length ( ) ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) count ++ ; i ++ ; } return count ; }
int replaceDig ( int x , int from , int to ) { int result = 0 ; int multiply = 1 ; while ( x > 0 ) { int reminder = x % 10 ; if ( reminder == from ) result = result + to * multiply ; else result = result + reminder * multiply ; multiply *= 10 ; x = x / 10 ; } return result ; }
void calculateMinMaxSum ( int x1 , int x2 ) { int minSum = replaceDig ( x1 , 6 , 5 ) + replaceDig ( x2 , 6 , 5 ) ; int maxSum = replaceDig ( x1 , 5 , 6 ) + replaceDig ( x2 , 5 , 6 ) ; System . out . print ( "Minimum sum = " + minSum ) ; System . out . print ( "Maximumsum=" + maxSum ) ; }
void qType2 ( int l , int r , char str [ ] ) { int freq [ ] = new int [ 27 ] ; for ( int i = l - 1 ; i <= r - 1 ; i ++ ) { freq [ str [ i ] - 'a' ] ++ ; } int count = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( freq [ j ] % 2 != 0 ) { count ++ ; } } if ( count <= 1 ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } }
void update ( int tree [ ] [ ] , int idx , int val , int i ) { while ( idx <= max ) { tree [ idx ] [ i ] += val ; idx += ( idx & - idx ) ; } }
void buildBIT ( int tree [ ] [ ] , char str [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) update ( tree , i + 1 , 1 , str [ i ] - 97 + 1 ) ; }
void precompute ( int mat [ ] [ ] , String str , int len ) { for ( int i = 0 ; i < CHAR_SIZE ; ++ i ) mat [ len ] [ i ] = len ; for ( int i = len - 1 ; i >= 0 ; -- i ) { for ( int j = 0 ; j < CHAR_SIZE ; ++ j ) mat [ i ] [ j ] = mat [ i + 1 ] [ j ] ; mat [ i ] [ str . charAt ( i ) - 'a' ] = i ; } }
boolean query ( int mat [ ] [ ] , String str , int len ) { int pos = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { if ( mat [ pos ] [ str . charAt ( i ) - 'a' ] >= len ) return false ; else pos = mat [ pos ] [ str . charAt ( i ) - 'a' ] + 1 ; } return true ; }
String findTwoscomplement ( StringBuffer str ) { int n = str . length ( ) ; int i ; for ( i = n - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == '1' ) break ; if ( i == - 1 ) return "1" + str ; for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( str . charAt ( k ) == '1' ) str . replace ( k , k + 1 , "0" ) ; else str . replace ( k , k + 1 , "1" ) ; } return str . toString ( ) ; }
boolean isequal ( String str ) { int n = str . length ( ) ; int num = 0 , x = 1 , i = n - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( '0' <= str . charAt ( i ) && str . charAt ( i ) <= '9' ) { num = ( str . charAt ( i ) - '0' ) * x + num ; x = x * 10 ; if ( num >= n ) return false ; } else break ; } return num == i + 1 ; }
boolean arekAnagrams ( String str1 , String str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int [ ] count1 = new int [ MAX_CHAR ] ; int [ ] count2 = new int [ MAX_CHAR ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) count1 [ str1 . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) count2 [ str2 . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + Math . abs ( count1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; }
boolean areKAnagrams ( String str1 , String str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int [ ] hash_str1 = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) hash_str1 [ str1 . charAt ( i ) - 'a' ] ++ ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash_str1 [ str2 . charAt ( i ) - 'a' ] > 0 ) hash_str1 [ str2 . charAt ( i ) - 'a' ] -- ; else count ++ ; if ( count > k ) return false ; } return true ; }
int countToMake0lternate ( String s ) { int result = 0 ; for ( int i = 0 ; i < ( s . length ( ) - 1 ) ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) return result ; }
char getDigit ( int N , int d ) { String str = Integer . toString ( N ) ; return str . charAt ( d - 1 ) ; }
char getNthChar ( int N ) { int sum = 0 , nine = 9 ; int dist = 0 , len ; for ( len = 1 ; ; len ++ ) { sum += nine * len ; dist += nine ; if ( sum >= N ) { sum -= nine * len ; dist -= nine ; N -= sum ; break ; } nine *= 10 ; } int diff = ( int ) ( Math . ceil ( ( double ) ( N ) / ( double ) ( len ) ) ) ; int d = N % len ; if ( d == 0 ) d = len ; return getDigit ( dist + diff , d ) ; }
boolean ispalindrome ( String s ) { int l = s . length ( ) ; for ( int i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s . charAt ( i ) != s . charAt ( j ) ) { return false ; } } return true ; }
int findCount ( String str ) { int result = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( i == ( str . charAt ( i ) - 'a' ) || i == ( str . charAt ( i ) - 'A' ) ) { result ++ ; } } return result ; }
void sortByPattern ( char [ ] str , char [ ] pat ) { int count [ ] = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < str . length ; i ++ ) { count [ str [ i ] - 'a' ] ++ ; } int index = 0 ; for ( int i = 0 ; i < pat . length ; i ++ ) { for ( int j = 0 ; j < count [ pat [ i ] - 'a' ] ; j ++ ) { str [ index ++ ] = pat [ i ] ; } } }
char flip ( char ch ) { return ( ch == '0' ) ? '1' : '0' ; }
int getFlipWithStartingCharcter ( String str , char expected ) { int flipCount = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) != expected ) flipCount ++ ; expected = flip ( expected ) ; } return flipCount ; }
int minFlipToMakeStringAlternate ( String str ) { return Math . min ( getFlipWithStartingCharcter ( str , '0' ) , getFlipWithStartingCharcter ( str , '1' ) ) ; }
int remAnagram ( String str1 , String str2 ) { int count1 [ ] = new int [ 26 ] ; int count2 [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) count1 [ str1 . charAt ( i ) - 'a' ] ++ ; for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) count2 [ str2 . charAt ( i ) - 'a' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }
boolean isPalin ( String str ) { int len = str . length ( ) / 2 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) != str . charAt ( str . length ( ) - i - 1 ) ) return false ; } return true ; }
int remainderWith7 ( String num ) { int series [ ] = { 1 , 3 , 2 , - 1 , - 3 , - 2 } ; int series_index = 0 ; int result = 0 ; for ( int i = num . length ( ) - 1 ; i >= 0 ; i -- ) { int digit = num . charAt ( i ) - '0' ; result += digit * series [ series_index ] ; series_index = ( series_index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; }
boolean checkForVariation ( String str ) { if ( str == null || str . isEmpty ( ) ) { return true ; } Map < Character , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { map . put ( str . charAt ( i ) , map . getOrDefault ( str . charAt ( i ) , 0 ) + 1 ) ; } Iterator < Integer > itr = map . values ( ) . iterator ( ) ; boolean first = true , second = true ; int val1 = 0 , val2 = 0 ; int countOfVal1 = 0 , countOfVal2 = 0 ; while ( itr . hasNext ( ) ) { int i = itr . next ( ) ; if ( first ) { val1 = i ; first = false ; countOfVal1 ++ ; continue ; } if ( i == val1 ) { countOfVal1 ++ ; continue ; } if ( second ) { val2 = i ; countOfVal2 ++ ; second = false ; continue ; } if ( i == val2 ) { countOfVal2 ++ ; continue ; } return false ; } if ( countOfVal1 > 1 && countOfVal2 > 1 ) { return false ; } else { return true ; } }
void waysToPaint ( int n ) { long same = 6 ; long diff = 6 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long sameTmp = 3 * same + 2 * diff ; long diffTmp = 2 * same + 2 * diff ; same = sameTmp ; diff = diffTmp ; } System . out . println ( same + diff ) ; }
boolean isReversible ( String str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str . charAt ( i ) != str . charAt ( j ) ) return false ; i ++ ; j -- ; } return true ; }
int findPossibleMoves ( int mat [ ] [ ] , int p , int q ) { int X [ ] = { 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 } ; int Y [ ] = { 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 } ; int count = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int x = p + X [ i ] ; int y = q + Y [ i ] ; if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) count ++ ; } return count ; }
int countCompletePairs ( String set1 [ ] , String set2 [ ] , int n , int m ) { int result = 0 ; int [ ] con_s1 = new int [ n ] ; int [ ] con_s2 = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { con_s1 [ i ] = 0 ; for ( int j = 0 ; j < set1 [ i ] . length ( ) ; j ++ ) { con_s1 [ i ] = con_s1 [ i ] | ( 1 << ( set1 [ i ] . charAt ( j ) - 'a' ) ) ; } } for ( int i = 0 ; i < m ; i ++ ) { con_s2 [ i ] = 0 ; for ( int j = 0 ; j < set2 [ i ] . length ( ) ; j ++ ) { con_s2 [ i ] = con_s2 [ i ] | ( 1 << ( set2 [ i ] . charAt ( j ) - 'a' ) ) ; } } long complete = ( 1 << 26 ) - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( con_s1 [ i ] con_s2 [ j ] ) == complete ) { result ++ ; } } } return result ; }
boolean checkPattern ( String str , String pat ) { int [ ] label = new int [ CHAR_SIZE ] ; for ( int i = 0 ; i < CHAR_SIZE ; i ++ ) label [ i ] = - 1 ; int order = 1 ; for ( int i = 0 ; i < pat . length ( ) ; i ++ ) { label [ pat . charAt ( i ) ] = order ; order ++ ; } int last_order = - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( label [ str . charAt ( i ) ] != - 1 ) { if ( label [ str . charAt ( i ) ] < last_order ) return false ; last_order = label [ str . charAt ( i ) ] ; } } return true ; }
char encodedChar ( String str , int k ) { String expand = "" ; for ( int i = 0 ; i < str . length ( ) ; ) { while ( i < str . length ( ) && str . charAt ( i ) >= 'a' && str . charAt ( i ) <= 'z' ) { temp += str . charAt ( i ) ; i ++ ; } while ( i < str . length ( ) && str . charAt ( i ) >= '1' && str . charAt ( i ) <= '9' ) { freq = freq * 10 + str . charAt ( i ) - '0' ; i ++ ; } for ( int j = 1 ; j <= freq ; j ++ ) expand += temp ; } if ( freq == 0 ) expand += temp ; return expand . charAt ( k - 1 ) ; }
void findMatchedWords ( String [ ] dict , String pattern ) { int len = pattern . length ( ) ; String hash = encodeString ( pattern ) ; for ( String word : dict ) { if ( word . length ( ) == len && encodeString ( word ) . equals ( hash ) ) System . out . print ( word + " " ) ; } }
boolean check ( String pattern , String word ) { if ( pattern . length ( ) != word . length ( ) ) return false ; int [ ] ch = new int [ 128 ] ; int Len = word . length ( ) ; for ( int i = 0 ; i < Len ; i ++ ) { if ( ch [ ( int ) pattern . charAt ( i ) ] == 0 ) { ch [ ( int ) pattern . charAt ( i ) ] = word . charAt ( i ) ; } else if ( ch [ ( int ) pattern . charAt ( i ) ] != word . charAt ( i ) ) { return false ; } } return true ; }
int findSum ( String str ) { String temp = "0" ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( Character . isDigit ( ch ) ) temp += ch ; else { sum += Integer . parseInt ( temp ) ; temp = "0" ; } } return sum + Integer . parseInt ( temp ) ; }
int countkDist ( String str , int k ) { int res = 0 ; int n = str . length ( ) ; int cnt [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int dist_count = 0 ; Arrays . fill ( cnt , 0 ) ; for ( int j = i ; j < n ; j ++ ) { if ( cnt [ str . charAt ( j ) - 'a' ] == 0 ) dist_count ++ ; cnt [ str . charAt ( j ) - 'a' ] ++ ; if ( dist_count == k ) res ++ ; } } return res ; }
String commonPrefixUtil ( String str1 , String str2 ) { String result = "" ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; for ( int i = 0 , j = 0 ; i <= n1 - 1 && j <= n2 - 1 ; i ++ , j ++ ) { if ( str1 . charAt ( i ) != str2 . charAt ( j ) ) { break ; } result += str1 . charAt ( i ) ; } return ( result ) ; }
String commonPrefix ( String arr [ ] , int low , int high ) { if ( low == high ) { return ( arr [ low ] ) ; } if ( high > low ) { int mid = low + ( high - low ) / 2 ; String str1 = commonPrefix ( arr , low , mid ) ; String str2 = commonPrefix ( arr , mid + 1 , high ) ; return ( commonPrefixUtil ( str1 , str2 ) ) ; } return null ; }
int countTriplets ( int [ ] A ) { int cnt = 0 ; HashMap < Integer , Integer > tuples = new HashMap < Integer , Integer > ( ) ; for ( int a : A ) for ( int b : A ) { if ( tuples . containsKey ( a & b ) ) tuples . put ( a & b , tuples . get ( a & b ) + 1 ) ; else tuples . put ( a & b , 1 ) ; } for ( int a : A ) for ( Map . Entry < Integer , Integer > t : tuples . entrySet ( ) ) if ( ( t . getKey ( ) & a ) == 0 ) cnt += t . getValue ( ) ; return cnt ; }
boolean isPalindrome ( String str ) { int l = 0 ; int h = str . length ( ) - 1 ; while ( h > l ) if ( str . charAt ( l ++ ) != str . charAt ( h -- ) ) return false ; return true ; }
char flip ( char c ) { return ( c == '0' ) ? '1' : '0' ; }
String zigZagConcat ( String s , int n ) { if ( n <= 1 ) { return s ; } StringBuilder result = new StringBuilder ( ) ; for ( int rowNum = 0 ; rowNum < n ; rowNum ++ ) { int i = rowNum ; boolean up = true ; while ( i < s . length ( ) ) { result = result . append ( s . charAt ( i ) ) ; if ( rowNum == 0 rowNum == n - 1 ) { i += ( 2 * n - 2 ) ; } else { if ( up ) { i += ( 2 * ( n - rowNum ) - 2 ) ; } else { i += rowNum * 2 ; } up ^= true ; } } } return result . toString ( ) ; }
boolean isEditDistanceOne ( String s1 , String s2 ) { int m = s1 . length ( ) , n = s2 . length ( ) ; if ( Math . abs ( m - n ) > 1 ) return false ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( s1 . charAt ( i ) != s2 . charAt ( j ) ) { if ( count == 1 ) return false ; if ( m > n ) i ++ ; else if ( m < n ) j ++ ; { i ++ ; j ++ ; } count ++ ; } { i ++ ; j ++ ; } } if ( i < m j < n ) count ++ ; return count == 1 ; }
int countOccurrences ( int x , int d ) { int count = 0 ; while ( x > 0 ) { if ( x % 10 == d ) count ++ ; x = x / 10 ; } return count ; }
int maxOccurring ( int x ) { if ( x < 0 ) x = - x ; int result = 0 ; int max_count = 1 ; for ( int d = 0 ; d <= 9 ; d ++ ) { int count = countOccurrences ( x , d ) ; if ( count >= max_count ) { max_count = count ; result = d ; } } return result ; }
int maxSubarrayXOR ( int arr [ ] , int n ) { int ans = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . max ( ans , curr_xor ) ; } } return ans ; }
int cntNum ( String X , int i , int sum , int tight , int dp [ ] [ ] [ ] ) { if ( i >= X . length ( ) sum < 0 ) { if ( sum == 0 ) { return 1 ; } return 0 ; } if ( dp [ sum ] [ i ] [ tight ] != - 1 ) { return dp [ sum ] [ i ] [ tight ] ; } int res = 0 ; int end = tight != 0 ? X . charAt ( i ) - '0' : 9 ; for ( int j = 0 ; j <= end ; j ++ ) { res += cntNum ( X , i + 1 , sum - j , ( tight > 0 & ( j == end ) ) == true ? 1 : 0 , dp ) ; } return dp [ sum ] [ i ] [ tight ] = res ; }
int UtilCntNumRange ( int L , int R , int Y ) { if ( R == 0 && Y == 0 ) { return 1 ; } String str = String . valueOf ( R ) ; int [ ] [ ] [ ] dp = new int [ M ] [ M ] [ 2 ] ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { for ( int k = 0 ; k < 2 ; k ++ ) dp [ i ] [ j ] [ k ] = - 1 ; } } int cntR = cntNum ( str , 0 , Y , 1 , dp ) ; str = String . valueOf ( L - 1 ) ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { for ( int k = 0 ; k < 2 ; k ++ ) dp [ i ] [ j ] [ k ] = - 1 ; } } int cntL = cntNum ( str , 0 , Y , 1 , dp ) ; return ( cntR - cntL ) ; }
boolean areIsomorphic ( String str1 , String str2 ) { int m = str1 . length ( ) ; int n = str2 . length ( ) ; if ( m != n ) return false ; Boolean [ ] marked = new Boolean [ size ] ; Arrays . fill ( marked , Boolean . FALSE ) ; int [ ] map = new int [ size ] ; Arrays . fill ( map , - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( map [ str1 . charAt ( i ) ] == - 1 ) { if ( marked [ str2 . charAt ( i ) ] == true ) return false ; marked [ str2 . charAt ( i ) ] = true ; map [ str1 . charAt ( i ) ] = str2 . charAt ( i ) ; } else if ( map [ str1 . charAt ( i ) ] != str2 . charAt ( i ) ) return false ; } return true ; }
boolean isPalin ( char [ ] str , int st , int end ) { while ( st < end ) { if ( str [ st ] != str [ end ] ) return false ; st ++ ; end -- ; } return true ; }
int findMinInsert ( char [ ] str , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( isPalin ( str , 0 , i ) ) return ( n - i - 1 ) ; } return 0 ; }
long removeRecur ( long n ) { long prev_digit = n % 10 ; long pow = 10 ; long res = prev_digit ; while ( n > 0 ) { long curr_digit = n % 10 ; if ( curr_digit != prev_digit ) { res += curr_digit * pow ; prev_digit = curr_digit ; pow *= 10 ; } n = n / 10 ; } return res ; }
int removeSpaces ( char [ ] str ) { int count = 0 ; for ( int i = 0 ; i < str . length ; i ++ ) if ( str [ i ] != ' ' ) return count ; }
boolean isValid ( int count [ ] , int k ) { int val = 0 ; for ( int i = 0 ; i < MAX_CHARS ; i ++ ) { if ( count [ i ] > 0 ) { val ++ ; } } return ( k >= val ) ; }
void kUniques ( String s , int k ) { int u = 0 ; int n = s . length ( ) ; int count [ ] = new int [ MAX_CHARS ] ; Arrays . fill ( count , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ s . charAt ( i ) - 'a' ] == 0 ) { u ++ ; } count [ s . charAt ( i ) - 'a' ] ++ ; } if ( u < k ) { System . out . print ( "Not enough unique characters" ) ; return ; } int curr_start = 0 , curr_end = 0 ; int max_window_size = 1 ; int max_window_start = 0 ; Arrays . fill ( count , 0 ) ; count [ s . charAt ( 0 ) - 'a' ] ++ ; for ( int i = 1 ; i < n ; i ++ ) { count [ s . charAt ( i ) - 'a' ] ++ ; curr_end ++ ; while ( ! isValid ( count , k ) ) { count [ s . charAt ( curr_start ) - 'a' ] -- ; curr_start ++ ; } if ( curr_end - curr_start + 1 > max_window_size ) { max_window_size = curr_end - curr_start + 1 ; max_window_start = curr_start ; } } System . out . println ( "Max substring is : " + s . substring ( max_window_start , max_window_start + max_window_size ) + " with length " + max_window_size ) ; }
boolean canFormPalindrome ( String str ) { int count [ ] = new int [ NO_OF_CHARS ] ; Arrays . fill ( count , 0 ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ ( int ) ( str . charAt ( i ) ) ] ++ ; int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( ( count [ i ] & 1 ) == 1 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; }
int count9s ( String number ) { int count = 0 ; int n = number . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int sum = number . charAt ( i ) - '0' ; if ( number . charAt ( i ) == '9' ) count ++ ; for ( int j = i + 1 ; j < n ; j ++ ) { sum = ( sum + number . charAt ( j ) - '0' ) % 9 ; if ( sum == 0 ) count ++ ; } } return count ; }
int difference ( int arr [ ] [ ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return Math . abs ( d1 - d2 ) ; }
ArrayList < String > generateGray ( int n ) { if ( n <= 0 ) { ArrayList < String > temp = new ArrayList < String > ( ) { { add ( "0" ) ; } } ; return temp ; } if ( n == 1 ) { ArrayList < String > temp = new ArrayList < String > ( ) { { add ( "0" ) ; add ( "1" ) ; } } ; return temp ; } ArrayList < String > recAns = generateGray ( n - 1 ) ; ArrayList < String > mainAns = new ArrayList < String > ( ) ; for ( int i = 0 ; i < recAns . size ( ) ; i ++ ) { String s = recAns . get ( i ) ; mainAns . add ( "0" + s ) ; } for ( int i = recAns . size ( ) - 1 ; i >= 0 ; i -- ) { String s = recAns . get ( i ) ; mainAns . add ( "1" + s ) ; } return mainAns ; }
boolean areAnagram ( char str1 [ ] , char str2 [ ] ) { int count1 [ ] = new int [ NO_OF_CHARS ] ; Arrays . fill ( count1 , 0 ) ; int count2 [ ] = new int [ NO_OF_CHARS ] ; Arrays . fill ( count2 , 0 ) ; int i ; for ( i = 0 ; i < str1 . length && i < str2 . length ; i ++ ) { count1 [ str1 [ i ] ] ++ ; count2 [ str2 [ i ] ] ++ ; } if ( str1 . length != str2 . length ) return false ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; }
boolean areAnagram ( char [ ] str1 , char [ ] str2 ) { int [ ] count = new int [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; i < str1 . length ; i ++ ) { count [ str1 [ i ] - 'a' ] ++ ; count [ str2 [ i ] - 'a' ] -- ; } if ( str1 . length != str2 . length ) return false ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count [ i ] != 0 ) { return false ; } return true ; }
int longestUniqueSubsttr ( String str ) { int n = str . length ( ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( areDistinct ( str , i , j ) ) res = Math . max ( res , j - i + 1 ) ; return res ; }
int longestUniqueSubsttr ( String str ) { int n = str . length ( ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { boolean [ ] visited = new boolean [ 256 ] ; for ( int j = i ; j < n ; j ++ ) { if ( visited [ str . charAt ( j ) ] == true ) break ; else { res = Math . max ( res , j - i + 1 ) ; visited [ str . charAt ( j ) ] = true ; } } visited [ str . charAt ( i ) ] = false ; } return res ; }
void spiralFill ( int m , int n , int a [ ] [ ] ) { int val = 1 ; int k = 0 , l = 0 ; while ( k < m && l < n ) { for ( int i = l ; i < n ; ++ i ) { a [ k ] [ i ] = val ++ ; } k ++ ; for ( int i = k ; i < m ; ++ i ) { a [ i ] [ n - 1 ] = val ++ ; } n -- ; if ( k < m ) { for ( int i = n - 1 ; i >= l ; -- i ) { a [ m - 1 ] [ i ] = val ++ ; } m -- ; } if ( l < n ) { for ( int i = m - 1 ; i >= k ; -- i ) { a [ i ] [ l ] = val ++ ; } l ++ ; } } }
boolean isValid ( int [ ] [ ] board , int i , int j , int K ) { if ( board [ i ] [ j ] <= K ) { return true ; } return false ; }
boolean findPath ( int [ ] [ ] board , int X , int Y , int M , int N , int K ) { if ( X < 0 X == M Y < 0 Y == N ) { return true ; } if ( isValid ( board , X , Y , K ) ) { int board_XY = board [ X ] [ Y ] ; board [ X ] [ Y ] = Integer . MAX_VALUE ; if ( findPath ( board , X + 1 , Y , M , N , K - board_XY ) || findPath ( board , X - 1 , Y , M , N , K - board_XY ) || findPath ( board , X , Y + 1 , M , N , K - board_XY ) || findPath ( board , X , Y - 1 , M , N , K - board_XY ) ) { return true ; } board [ X ] [ Y ] = board_XY ; } return false ; }
void pathMoves ( char mat [ ] [ ] , Point src , Point dest ) { int d [ ] [ ] = new int [ ROW ] [ COL ] ; for ( int dd [ ] : d ) Arrays . fill ( dd , - 1 ) ; d [ src . x ] [ src . y ] = 0 ; boolean visited [ ] [ ] = new boolean [ ROW ] [ COL ] ; visited [ src . x ] [ src . y ] = true ; ArrayDeque < Node > q = new ArrayDeque < > ( ) ; Node s = new Node ( src , 0 ) ; q . addLast ( s ) ; boolean ok = false ; while ( ! q . isEmpty ( ) ) { Node curr = q . removeFirst ( ) ; Point pt = curr . pt ; if ( pt . x == dest . x && pt . y == dest . y ) { int xx = pt . x , yy = pt . y ; int dist = curr . dist ; d [ pt . x ] [ pt . y ] = dist ; String pathmoves = "" ; while ( xx != src . x yy != src . y ) { if ( xx > 0 && d [ xx - 1 ] [ yy ] == dist - 1 ) { pathmoves += 'D' ; xx -- ; } if ( xx < ROW - 1 && d [ xx + 1 ] [ yy ] == dist - 1 ) { pathmoves += 'U' ; xx ++ ; } if ( yy > 0 && d [ xx ] [ yy - 1 ] == dist - 1 ) { pathmoves += 'R' ; yy -- ; } if ( yy < COL - 1 && d [ xx ] [ yy + 1 ] == dist - 1 ) { pathmoves += 'L' ; yy ++ ; } dist -- ; } for ( int i = pathmoves . length ( ) - 1 ; i >= 0 ; -- i ) System . out . print ( pathmoves . charAt ( i ) ) ; ok = true ; break ; } if ( ! q . isEmpty ( ) ) q . removeFirst ( ) ; for ( int i = 0 ; i < 4 ; i ++ ) { int row = pt . x + dRow [ i ] ; int col = pt . y + dCol [ i ] ; if ( isValid ( row , col ) && ( mat [ row ] [ col ] == '1' mat [ row ] [ col ] == 's' mat [ row ] [ col ] == 'd' ) && ! visited [ row ] [ col ] ) { visited [ row ] [ col ] = true ; Node adjCell = new Node ( new Point ( row , col ) , curr . dist + 1 ) ; q . addLast ( adjCell ) ; d [ row ] [ col ] = curr . dist + 1 ; } } } if ( ! ok ) System . out . println ( - 1 ) ; }
int isPerfect ( int x ) { int sum_div = 1 ; for ( int i = 2 ; i <= x / 2 ; ++ i ) { if ( x % i == 0 ) { sum_div += i ; } } if ( sum_div == x ) { return 1 ; } else return 0 ; }
int isPerfect ( int x ) { int sum_div = 1 ; for ( int i = 2 ; i <= x / 2 ; ++ i ) { if ( x % i == 0 ) { sum_div += i ; } } if ( sum_div == x ) { return 1 ; } else return 0 ; }
void subsetSum ( int arr [ ] , int n ) { long total = 1 << n ; for ( long i = 0 ; i < total ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( ( i & ( 1 << j ) ) != 0 ) sum += arr [ j ] ; if ( isPerfect ( sum ) != 0 ) { System . out . print ( sum + " " ) ; } } }
void factorial ( int N ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; }
void printLevelOrder ( node root ) { if ( root == null ) return ; Queue < node > q = new LinkedList < > ( ) ; q . add ( root ) ; while ( ! q . isEmpty ( ) ) { node temp = q . peek ( ) ; System . out . print ( temp . data + " " ) ; q . remove ( ) ; if ( temp . left != null ) { q . add ( temp . left ) ; } else if ( temp . right != null ) { System . out . print ( "null " ) ; } if ( temp . right != null ) { q . add ( temp . right ) ; } else if ( temp . left != null ) { System . out . print ( "null " ) ; } } }
void PenGame ( int N ) { int P1 = 0 ; int P2 = 0 ; int X = 0 ; int Move = 0 ; boolean QuitP1 = false ; boolean QuitP2 = false ; solve ( N , P1 , P2 , X , Move , QuitP1 , QuitP2 ) ; }
int findTrace ( int mat [ ] [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += mat [ i ] [ i ] ; return sum ; }
void checkUntil ( int num , int K , int N , Vector < Integer > ans ) { if ( N == 1 ) { ans . add ( num ) ; return ; } if ( ( num % 10 + K ) <= 9 ) checkUntil ( 10 * num + ( num % 10 + K ) , K , N - 1 , ans ) ; if ( K > 0 ) { if ( ( num % 10 - K ) >= 0 ) checkUntil ( 10 * num + num % 10 - K , K , N - 1 , ans ) ; } }
void check ( int K , int N , Vector < Integer > ans ) { for ( int i = 1 ; i <= 9 ; i ++ ) { checkUntil ( i , K , N , ans ) ; } }
void comb ( int [ ] arr , int len , int r , int ipos , int [ ] op , int opos , int sum ) { if ( opos == r ) { int sum2 = 0 ; for ( int i = 0 ; i < opos ; i ++ ) { sum2 = sum2 + op [ i ] ; } if ( sum == sum2 ) { for ( int i = 0 ; i < opos ; i ++ ) System . out . print ( op [ i ] + ", " ) ; System . out . println ( ) ; } return ; } if ( ipos < len ) { comb ( arr , len , r , ipos + 1 , op , opos , sum ) ; op [ opos ] = arr [ ipos ] ; comb ( arr , len , r , ipos + 1 , op , opos + 1 , sum ) ; } }
void SieveOfEratosthenes ( boolean prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
void primeCliques ( int i , int l , boolean prime [ ] ) { for ( int j = i + 1 ; j <= n ; j ++ ) { store [ l ] = j ; if ( is_clique ( l + 1 ) ) { if ( prime [ l ] ) ans ++ ; primeCliques ( j , l + 1 , prime ) ; } } }
int countWays ( int mtrx [ ] [ ] , int vrtx , int i , int dest , boolean visited [ ] ) { if ( i == dest ) { return 1 ; } int total = 0 ; for ( int j = 0 ; j < vrtx ; j ++ ) { if ( mtrx [ i ] [ j ] == 1 && ! visited [ j ] ) { visited [ j ] = true ; total += countWays ( mtrx , vrtx , j , dest , visited ) ; visited [ j ] = false ; } } return total ; }
int totalWays ( int mtrx [ ] [ ] , int vrtx , int src , int dest ) { boolean [ ] visited = new boolean [ vrtx ] ; for ( int i = 0 ; i < vrtx ; i ++ ) { visited [ i ] = false ; } visited [ src ] = true ; return countWays ( mtrx , vrtx , src , dest , visited ) ; }
int minOperation ( boolean arr [ ] [ ] ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == false ) { ans ++ ; for ( int k = 0 ; k <= i ; k ++ ) { for ( int h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == true ) { arr [ k ] [ h ] = false ; } else { arr [ k ] [ h ] = true ; } } } } } } return ans ; }
int find_x ( int n ) { if ( n == 1 ) return 1 ; double num , den , p ; num = Math . log10 ( n ) ; int x = 0 , no = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { den = Math . log10 ( i ) ; p = num / den ; no = ( int ) ( Math . pow ( i , ( int ) p ) ) ; if ( Math . abs ( no - n ) < 1e-6 ) { x = i ; break ; } } return x ; }
boolean is_key ( int n , int x ) { double p ; p = Math . log10 ( n ) / Math . log10 ( x ) ; int no = ( int ) ( Math . pow ( x , ( int ) p ) ) ; if ( n == no ) return true ; return false ; }
int evenPaths ( Node node , int count , int x ) { if ( node == null || ! is_key ( node . key , x ) ) { return count ; } if ( node . left == null && node . right == null ) { count ++ ; } count = evenPaths ( node . left , count , x ) ; return evenPaths ( node . right , count , x ) ; }
void dfs ( int a , int b , Vector < Integer > v [ ] , int vis [ ] ) { vis [ a ] = 1 ; c ++ ; for ( int i : v [ a ] ) { if ( vis [ i ] == 0 && i != b ) dfs ( i , b , v , vis ) ; } }
void printExistPath ( Stack < Integer > sx , Stack < Integer > sy , int last ) { if ( sx . isEmpty ( ) || sy . isEmpty ( ) ) { return ; } int x = sx . peek ( ) ; int y = sy . peek ( ) ; sx . pop ( ) ; sy . pop ( ) ; printExistPath ( sx , sy , last ) ; if ( sx . size ( ) == last - 1 ) { System . out . print ( "(" + x + ", " + y + ")" ) ; } else { System . out . print ( "(" + x + ", " + y + ")->" ) ; } }
boolean storePath ( int srcX , int srcY , int destX , int destY , Stack < Integer > sx , Stack < Integer > sy ) { if ( srcX > destX srcY > destY ) { return false ; } sx . add ( srcX ) ; sy . add ( srcY ) ; if ( srcX == destX && srcY == destY ) { printExistPath ( sx , sy , sx . size ( ) ) ; return true ; } if ( storePath ( ( 2 * srcX ) + srcY , srcY , destX , destY , sx , sy ) ) { return true ; } if ( storePath ( srcX , ( 2 * srcY ) + srcX , destX , destY , sx , sy ) ) { return true ; } sx . pop ( ) ; sy . pop ( ) ; return false ; }
boolean isPathExist ( int srcX , int srcY , int destX , int destY ) { Stack < Integer > sx = new Stack < Integer > ( ) ; Stack < Integer > sy = new Stack < Integer > ( ) ; return storePath ( srcX , srcY , destX , destY , sx , sy ) ; }
void printPath ( int srcX , int srcY , int destX , int destY ) { if ( ! isPathExist ( srcX , srcY , destX , destY ) ) { System . out . print ( "-1" ) ; } }
void dfs ( int v ) { col [ v ] = 1 ; for ( pair p : g [ v ] ) { int to = p . first , id = p . second ; if ( col [ to ] == 0 ) { dfs ( to ) ; res [ id ] = 1 ; } else if ( col [ to ] == 2 ) { res [ id ] = 1 ; } else { res [ id ] = 2 ; cyc = true ; } } col [ v ] = 2 ; }
void sumSubsets ( int set [ ] , int n , int target ) { int x [ ] = new int [ set . length ] ; int j = set . length - 1 ; while ( n > 0 ) { x [ j ] = n % 2 ; n = n / 2 ; j -- ; } int sum = 0 ; for ( int i = 0 ; i < set . length ; i ++ ) if ( x [ i ] == 1 ) sum = sum + set [ i ] ; if ( sum == target ) { System . out . print ( "{" ) ; for ( int i = 0 ; i < set . length ; i ++ ) if ( x [ i ] == 1 ) System . out . print ( set [ i ] + ", " ) ; System . out . print ( "}, " ) ; } }
void findSubsets ( int [ ] arr , int K ) { int x = ( int ) Math . pow ( 2 , arr . length ) ; for ( int i = 1 ; i < x ; i ++ ) sumSubsets ( arr , i , K ) ; }
int ncr ( int n , int r ) { return ( fact [ n ] / fact [ r ] ) / fact [ n - r ] ; }
int findSum ( int [ ] arr , int n ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; int mul = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) mul += ( int ) Math . pow ( 2 , i ) * ncr ( n - 1 , i ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += mul * arr [ i ] ; return ans ; }
int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; }
int solve ( int maze [ ] [ ] ) { int ans = numberOfPaths ( R , C ) - countPaths ( maze ) ; return ans ; }
void dfs1 ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent . get ( u ) . size ( ) ; i ++ ) { if ( ! visited [ adjacent . get ( u ) . get ( i ) ] ) { temp ++ ; parent [ adjacent . get ( u ) . get ( i ) ] = u ; dfs1 ( adjacent . get ( u ) . get ( i ) , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; endnode = u ; } } }
void dfs2 ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent . get ( u ) . size ( ) ; i ++ ) { if ( ! visited [ adjacent . get ( u ) . get ( i ) ] && ! vis [ adjacent . get ( u ) . get ( i ) ] ) { temp ++ ; dfs2 ( adjacent . get ( u ) . get ( i ) , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; thirdnode = u ; } } }
void findNodes ( ) { dfs ( 1 , 0 ) ; for ( int i = 0 ; i <= N ; i ++ ) visited [ i ] = false ; maxi = - 1 ; dfs1 ( startnode , 0 ) ; for ( int i = 0 ; i <= N ; i ++ ) visited [ i ] = false ; int x = endnode ; vis [ startnode ] = true ; while ( x != startnode ) { vis [ x ] = true ; x = parent [ x ] ; } maxi = - 1 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( vis [ i ] ) dfs2 ( i , 0 ) ; } }
void dfsUtil ( int u , int node , boolean visited [ ] , ArrayList < ArrayList < Integer > > road_used , int parent , int it ) { int c = 0 ; for ( int i = 0 ; i < node ; i ++ ) if ( visited [ i ] ) c ++ ; if ( c == node ) return ; visited [ u ] = true ; road_used . add ( new ArrayList < Integer > ( Arrays . asList ( parent , u ) ) ) ; System . out . print ( u + " " ) ; for ( int x : adj . get ( u ) ) { if ( ! visited [ x ] ) { dfsUtil ( x , node , visited , road_used , u , it + 1 ) ; } } for ( int y = 0 ; y < road_used . size ( ) ; y ++ ) { if ( road_used . get ( y ) . get ( 1 ) == u ) { dfsUtil ( road_used . get ( y ) . get ( 0 ) , node , visited , road_used , u , it + 1 ) ; } } }
void dfs ( int node ) { boolean [ ] visited = new boolean [ node ] ; ArrayList < ArrayList < Integer > > road_used = new ArrayList < ArrayList < Integer > > ( ) ; for ( int i = 0 ; i < node ; i ++ ) { visited [ i ] = false ; } dfsUtil ( 0 , node , visited , road_used , - 1 , 0 ) ; }
void primeSum ( int total , int N , int S , int index ) { if ( total == S && set . size ( ) == N ) { display ( ) ; return ; } if ( total > S || index == prime . size ( ) || set . size ( ) >= N ) return ; set . add ( prime . get ( index ) ) ; primeSum ( total + prime . get ( index ) , N , S , index + 1 ) ; set . remove ( set . size ( ) - 1 ) ; primeSum ( total , N , S , index + 1 ) ; }
void allPrime ( int N , int S , int P ) { for ( int i = P + 1 ; i <= S ; i ++ ) { if ( isPrime ( i ) ) prime . add ( i ) ; } if ( prime . size ( ) < N ) return ; primeSum ( 0 , N , S , 0 ) ; }
Vector < Integer > grayCodes ( int n ) { Vector < Integer > res = new Vector < Integer > ( ) ; num = 0 ; grayCodeUtil ( res , n ) ; return res ; }
boolean isParenthesis ( char c ) { return ( ( c == '(' ) || ( c == ')' ) ) ; }
boolean isValidString ( String str ) { int cnt = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == '(' ) cnt ++ ; else if ( str . charAt ( i ) == ')' ) cnt -- ; if ( cnt < 0 ) return false ; } return ( cnt == 0 ) ; }
int findSum ( int n ) { int ans = 0 , temp = 0 , num ; for ( int i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; }
boolean isSafe ( int [ ] [ ] grid , int row , int col , int num ) { for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ row ] [ x ] == num ) return false ; for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ x ] [ col ] == num ) return false ; int startRow = row - row % 3 , startCol = col - col % 3 ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) if ( grid [ i + startRow ] [ j + startCol ] == num ) return false ; return true ; }
boolean solveSuduko ( int grid [ ] [ ] , int row , int col ) { if ( row == N - 1 && col == N ) return true ; if ( col == N ) { row ++ ; col = 0 ; } if ( grid [ row ] [ col ] != 0 ) return solveSuduko ( grid , row , col + 1 ) ; for ( int num = 1 ; num < 10 ; num ++ ) { if ( isSafe ( grid , row , col , num ) ) { grid [ row ] [ col ] = num ; if ( solveSuduko ( grid , row , col + 1 ) ) return true ; } grid [ row ] [ col ] = 0 ; } return false ; }
int fact ( int n ) { int ans = 1 ; for ( int i = 2 ; i <= n ; i ++ ) ans *= i ; return ans ; }
int remainder ( int n , int a , int p ) { int len = fact ( n ) ; int ans = 1 ; for ( int i = 1 ; i <= len ; i ++ ) ans = ( ans * a ) % p ; return ans ; }
long power ( long x , long y , long p ) { long res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
long remainder ( long n , long a , long p ) { long ans = a % p ; for ( long i = 1 ; i <= n ; i ++ ) ans = power ( ans , i , p ) ; return ans ; }
boolean check ( int n , int w ) { int [ ] a = new int [ 105 ] ; int p = 0 ; while ( n > 0 ) { a [ p ++ ] = n % w ; n /= w ; } boolean flag = true ; for ( int i = 0 ; i <= 100 ; i ++ ) { if ( a [ i ] == 0 a [ i ] == 1 ) continue ; else if ( a [ i ] == w a [ i ] == w - 1 ) a [ i + 1 ] ++ ; else flag = false ; } return flag ; }
int numPairs ( int a [ ] , int n ) { int ans , i , index ; ans = 0 ; for ( i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ; Arrays . sort ( a ) ; for ( i = 0 ; i < n ; i ++ ) { index = 2 ; ans += index - i - 1 ; } return ans ; }
int exponentMod ( int A , int B ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; long y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 ) ; y = ( y * y ) % mod ; } else { y = A % mod ; y = ( y * exponentMod ( A , B - 1 ) % mod ) % mod ; } return ( int ) ( ( y + mod ) % mod ) ; }
void countWays ( int N ) { long select = exponentMod ( 2 , N - 1 ) ; long ways = ( ( N % mod ) * ( select % mod ) ) ; ways %= mod ; System . out . print ( ways ) ; }
int findSum ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = Math . abs ( i - j ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }
int MaxUtil ( int [ ] st , int ss , int se , int l , int r , int node ) { if ( l <= ss && r >= se ) return st [ node ] ; if ( se < l ss > r ) return - 1 ; int mid = getMid ( ss , se ) ; return Math . max ( MaxUtil ( st , ss , mid , l , r , 2 * node ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 1 ) ) ; }
int count ( int arr [ ] , int low , int high , int x ) { if ( ( low > high ) || ( low == high && arr [ low ] != x ) ) return 0 ; if ( low == high && arr [ low ] == x ) return 1 ; return count ( arr , low , ( low + high ) / 2 , x ) + count ( arr , 1 + ( low + high ) / 2 , high , x ) ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
double [ ] [ ] matrix_product ( double [ ] [ ] a , double [ ] [ ] b ) { double [ ] [ ] c = new double [ 7 ] [ 7 ] ; for ( int i = 0 ; i < 7 ; i ++ ) for ( int j = 0 ; j < 7 ; j ++ ) for ( int k = 0 ; k < 7 ; k ++ ) c [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; return c ; }
double [ ] [ ] mul_expo ( double [ ] [ ] mul , int p ) { double [ ] [ ] s = { { 1 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 1 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 1 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 1 } } ; while ( p != 1 ) { if ( p % 2 == 1 ) s = matrix_product ( s , mul ) ; mul = matrix_product ( mul , mul ) ; p /= 2 ; } return matrix_product ( mul , s ) ; }
double expectedSteps ( int x ) { if ( x == 0 ) return 0 ; if ( x <= 6 ) return 6 ; double [ ] [ ] mul = { { ( double ) 7 / 6 , 1 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 1 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 1 } , { ( double ) - 1 / 6 , 0 , 0 , 0 , 0 , 0 , 0 } } ; mul = mul_expo ( mul , x - 6 ) ; return ( mul [ 0 ] [ 0 ] + mul [ 1 ] [ 0 ] + mul [ 2 ] [ 0 ] + mul [ 3 ] [ 0 ] + mul [ 4 ] [ 0 ] + mul [ 5 ] [ 0 ] ) * 6 ; }
int maxDistance ( int cell [ ] , int n , int p ) { Arrays . sort ( cell ) ; int start = 0 ; int end = cell [ n - 1 ] - cell [ 0 ] ; int ans = 0 ; while ( start <= end ) { int mid = start + ( ( end - start ) / 2 ) ; if ( canPlace ( cell , n , p , mid ) ) { ans = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } return ans ; }
int [ ] solve ( int n ) { int low = 1 , high = ( int ) 1e4 , x = n , p = 0 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = ( mid * ( mid + 1 ) ) / 2 ; if ( x - sum >= 1 ) { p = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } int start = 1 , end = ( int ) 1e4 , y = 1 , q = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int sum = ( mid * ( mid + 1 ) ) / 2 ; if ( y + sum <= n ) { q = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } x = x - ( p * ( p + 1 ) ) / 2 ; y = y + ( q * ( q + 1 ) ) / 2 ; int r = x ; int c = q + 1 - n + y ; int ans [ ] = { r , c } ; return ans ; }
int build ( int l , int r , int in , int [ ] arr ) { if ( l == r ) return seg [ in ] = arr [ l ] ; int mid = ( l + r ) / 2 ; return seg [ in ] = __gcd ( build ( l , mid , 2 * in + 1 , arr ) , build ( mid + 1 , r , 2 * in + 2 , arr ) ) ; }
int query ( int l , int r , int l1 , int r1 , int in ) { if ( l1 <= l && r <= r1 ) return seg [ in ] ; if ( l > r1 r < l1 ) return 0 ; int mid = ( l + r ) / 2 ; return __gcd ( query ( l , mid , l1 , r1 , 2 * in + 1 ) , query ( mid + 1 , r , l1 , r1 , 2 * in + 2 ) ) ; }
int findLen ( int [ ] arr , int n ) { build ( 0 , n - 1 , 0 , arr ) ; int i = 0 , j = 0 ; int ans = Integer . MAX_VALUE ; while ( i < n ) { while ( j < n && query ( 0 , n - 1 , i , j , 0 ) != 1 ) j ++ ; if ( j == n ) break ; ans = Math . min ( ( j - i + 1 ) , ans ) ; i ++ ; j = Math . max ( j , i ) ; } if ( ans == Integer . MAX_VALUE ) return - 1 ; else return ans ; }
int mergeSort ( int arr [ ] , int array_size ) { int temp [ ] = new int [ array_size ] ; return _mergeSort ( arr , temp , 0 , array_size - 1 ) ; }
int merge ( int arr [ ] , int temp [ ] , int left , int mid , int right ) { int i , j , k ; int inv_count = 0 ; i = left ; j = mid ; k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] > 2 * arr [ j ] ) { inv_count += ( mid - i ) ; j ++ ; } else { i ++ ; } } i = left ; j = mid ; k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) { temp [ k ++ ] = arr [ i ++ ] ; } else { temp [ k ++ ] = arr [ j ++ ] ; } } while ( i <= mid - 1 ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= right ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = left ; i <= right ; i ++ ) arr [ i ] = temp [ i ] ; return inv_count ; }
void findGrid ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; int x = 0 ; for ( int i = 0 ; i < n / 4 ; i ++ ) { for ( int j = 0 ; j < n / 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { for ( int l = 0 ; l < 4 ; l ++ ) { arr [ i * 4 + k ] [ j * 4 + l ] = x ; x ++ ; } } } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( arr [ i ] [ j ] + " " ) ; } System . out . println ( " " ) ; } }
int buildTree ( int l , int r , int i , int [ ] arr ) { if ( l == r ) { segtree [ i ] = l ; return l ; } int l1 = buildTree ( l , ( l + r ) / 2 , 2 * i + 1 , arr ) ; int r1 = buildTree ( ( l + r ) / 2 + 1 , r , 2 * i + 2 , arr ) ; if ( arr [ l1 ] > arr [ r1 ] ) segtree [ i ] = l1 ; else segtree [ i ] = r1 ; return segtree [ i ] ; }
int rangeMax ( int l , int r , int rl , int rr , int i , int [ ] arr ) { if ( r < rl l > rr ) return - 1 ; if ( l >= rl && r <= rr ) return segtree [ i ] ; int l1 = rangeMax ( l , ( l + r ) / 2 , rl , rr , 2 * i + 1 , arr ) ; int r1 = rangeMax ( ( l + r ) / 2 + 1 , r , rl , rr , 2 * i + 2 , arr ) ; if ( l1 == - 1 ) return r1 ; if ( r1 == - 1 ) return l1 ; if ( arr [ l1 ] > arr [ r1 ] ) return l1 ; else return r1 ; }
void inorder ( node curr ) { if ( curr == null ) return ; inorder ( curr . left ) ; System . out . print ( curr . data + " " ) ; inorder ( curr . right ) ; }
int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
int kthSmallest ( int [ ] arr , int k , int n ) { int low = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; int high = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; int countless = 0 , countequal = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] < mid ) ++ countless ; else if ( arr [ i ] == mid ) ++ countequal ; } if ( countless < k && ( countless + countequal ) >= k ) { return mid ; } else if ( countless >= k ) { high = mid - 1 ; } else if ( countless < k && countless + countequal < k ) { low = mid + 1 ; } } return Integer . MIN_VALUE ; }
void update ( int x , int y , int value , int id , int l , int r ) { if ( x >= r l >= y ) return ; if ( x <= l && r <= y ) { lazy [ id ] = value ; return ; } int mid = ( l + r ) / 2 ; if ( lazy [ id ] != 0 ) lazy [ 2 * id ] = lazy [ 2 * id + 1 ] = lazy [ id ] ; lazy [ id ] = 0 ; update ( x , y , value , 2 * id , l , mid ) ; update ( x , y , value , 2 * id + 1 , mid , r ) ; }
void query ( int id , int l , int r ) { if ( lazy [ id ] != 0 ) { se . add ( lazy [ id ] ) ; return ; } if ( r - l < 2 ) return ; int mid = ( l + r ) / 2 ; query ( 2 * id , l , mid ) ; query ( 2 * id + 1 , mid , r ) ; }
void updateRangeUtil ( int si , int ss , int se , int us , int ue , int diff ) { if ( lazy [ si ] != 0 ) { tree [ si ] += lazy [ si ] ; if ( ss != se ) { lazy [ si * 2 + 1 ] += lazy [ si ] ; lazy [ si * 2 + 2 ] += lazy [ si ] ; } lazy [ si ] = 0 ; } if ( ss > se ss > ue se < us ) return ; if ( ss >= us && se <= ue ) { tree [ si ] += diff ; if ( ss != se ) { lazy [ si * 2 + 1 ] += diff ; lazy [ si * 2 + 2 ] += diff ; } return ; } int mid = ( ss + se ) / 2 ; updateRangeUtil ( si * 2 + 1 , ss , mid , us , ue , diff ) ; updateRangeUtil ( si * 2 + 2 , mid + 1 , se , us , ue , diff ) ; tree [ si ] = Math . max ( tree [ si * 2 + 1 ] , tree [ si * 2 + 2 ] ) ; }
void updateRange ( int n , int us , int ue , int diff ) { updateRangeUtil ( 0 , 0 , n - 1 , us , ue , diff ) ; }
void constructSTUtil ( int arr [ ] , int ss , int se , int si ) { if ( ss > se ) return ; if ( ss == se ) { tree [ si ] = arr [ ss ] ; return ; } int mid = ( ss + se ) / 2 ; constructSTUtil ( arr , ss , mid , si * 2 + 1 ) ; constructSTUtil ( arr , mid + 1 , se , si * 2 + 2 ) ; tree [ si ] = Math . max ( tree [ si * 2 + 1 ] , tree [ si * 2 + 2 ] ) ; }
void constructST ( int arr [ ] , int n ) { constructSTUtil ( arr , 0 , n - 1 , 0 ) ; }
int getCount ( int n ) { int count = 1 ; while ( n != 0 ) { int leadDigit = firstDigit ( n ) ; n -= leadDigit ; count ++ ; } return count ; }
int getLargestNumber ( int k ) { int left = k ; int right = k * 10 ; int mid = ( left + right ) / 2 ; int len = getCount ( mid ) ; while ( len != k ) { mid = ( left + right ) / 2 ; len = getCount ( mid ) ; if ( len > k ) { right = mid ; } else { left = mid ; } } while ( len == k ) { if ( len != getCount ( mid + 1 ) ) { break ; } mid ++ ; } return ( mid ) ; }
long F ( long A , long B ) { if ( A == 1 ) return ( 4 % B ) ; else { long temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
void checkHV ( int [ ] [ ] arr , int N , int M ) { boolean horizontal = true ; boolean vertical = true ; for ( int i = 0 , k = N - 1 ; i < N / 2 ; i ++ , k -- ) { for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { horizontal = false ; break ; } } } for ( int i = 0 , k = M - 1 ; i < M / 2 ; i ++ , k -- ) { for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { horizontal = false ; break ; } } } if ( ! horizontal && ! vertical ) System . out . println ( "NO" ) ; else if ( horizontal && ! vertical ) System . out . println ( "HORIZONTAL" ) ; else if ( vertical && ! horizontal ) System . out . println ( "VERTICAL" ) ; else System . out . println ( "BOTH" ) ; }
int rangeSum ( int l , int r ) { int a = 1 , b = 9 , res = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int L = Math . max ( l , a ) ; int R = Math . min ( r , b ) ; if ( L <= R ) { int sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( i * i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
int getSetBitsFromOneToN ( int N ) { int two = 2 , ans = 0 ; int n = N ; while ( n != 0 ) { ans += ( N / two ) * ( two >> 1 ) ; if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 ; two <<= 1 ; n >>= 1 ; } return ans ; }
int findMinimum ( int x ) { int low = 0 , high = 100000 ; int ans = high ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( getSetBitsFromOneToN ( mid ) >= x ) { ans = Math . min ( ans , mid ) ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; }
int exponentMod ( int A , int B , int C ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; long y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; } else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return ( int ) ( ( y + C ) % C ) ; }
int trailingZeroes ( int n ) { int cnt = 0 ; while ( n > 0 ) { n /= 5 ; cnt += n ; } return cnt ; }
void binarySearch ( int n ) { int low = 0 ; int high = 1000000 ; while ( low < high ) { int mid = ( low + high ) / 2 ; int count = trailingZeroes ( mid ) ; if ( count < n ) low = mid + 1 ; else high = mid ; } int result [ ] = new int [ 1000 ] ; int k = 0 ; while ( trailingZeroes ( low ) == n ) { result [ k ] = low ; k ++ ; low ++ ; } for ( int i = 0 ; i < k ; i ++ ) System . out . print ( result [ i ] + " " ) ; }
int maxDet ( int n ) { return ( 2 * n * n * n ) ; }
void resMatrix ( int n ) { for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { if ( i == 0 && j == 2 ) System . out . print ( "0 " ) ; else if ( i == 1 && j == 0 ) System . out . print ( "0 " ) ; else if ( i == 2 && j == 1 ) System . out . print ( "0 " ) ; else System . out . print ( n + " " ) ; } System . out . println ( "" ) ; } }
int getCumulateSum ( int n ) { return ( n * ( n + 1 ) ) / 2 ; }
int minDaysToEmpty ( int C , int l ) { if ( C <= l ) return C ; int lo = 0 ; int hi = ( int ) 1e4 ; int mid ; while ( lo < hi ) { mid = ( lo + hi ) / 2 ; if ( getCumulateSum ( mid ) >= ( C - l ) ) hi = mid ; else lo = mid + 1 ; } return ( l + lo ) ; }
int minDaysToEmpty ( int C , int l ) { if ( l >= C ) return C ; double eq_root = ( Math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return ( int ) ( Math . ceil ( eq_root ) + l ) ; }
void shuffleArray ( int a [ ] , int n ) { for ( int i = 0 , q = 1 , k = n ; i < n ; i ++ , k ++ , q ++ ) for ( int j = k ; j > i + q ; j -- ) { int temp = a [ j - 1 ] ; a [ j - 1 ] = a [ j ] ; a [ j ] = temp ; } }
int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) { int [ ] sorted1 = new int [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; }
int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }
void binarySearch ( int mat [ ] [ ] , int i , int j_low , int j_high , int x ) { while ( j_low <= j_high ) { int j_mid = ( j_low + j_high ) / 2 ; if ( mat [ i ] [ j_mid ] == x ) { System . out . println ( "Found at (" + i + ", " + j_mid + ")" ) ; return ; } else if ( mat [ i ] [ j_mid ] > x ) j_high = j_mid - 1 ; else j_low = j_mid + 1 ; } System . out . println ( "Element no found" ) ; }
void sortedMatrixSearch ( int mat [ ] [ ] , int n , int m , int x ) { if ( n == 1 ) { binarySearch ( mat , 0 , 0 , m - 1 , x ) ; return ; } int i_low = 0 ; int i_high = n - 1 ; int j_mid = m / 2 ; while ( ( i_low + 1 ) < i_high ) { int i_mid = ( i_low + i_high ) / 2 ; if ( mat [ i_mid ] [ j_mid ] == x ) { System . out . println ( "Found at (" + i_mid + ", " + j_mid + ")" ) ; return ; } else if ( mat [ i_mid ] [ j_mid ] > x ) i_high = i_mid ; else i_low = i_mid ; } if ( mat [ i_low ] [ j_mid ] == x ) System . out . println ( "Found at (" + i_low + "," + j_mid + ")" ) ; else if ( mat [ i_low + 1 ] [ j_mid ] == x ) System . out . println ( "Found at (" + ( i_low + 1 ) + ", " + j_mid + ")" ) ; else if ( x <= mat [ i_low ] [ j_mid - 1 ] ) binarySearch ( mat , i_low , 0 , j_mid - 1 , x ) ; else if ( x >= mat [ i_low ] [ j_mid + 1 ] && x <= mat [ i_low ] [ m - 1 ] ) binarySearch ( mat , i_low , j_mid + 1 , m - 1 , x ) ; else if ( x <= mat [ i_low + 1 ] [ j_mid - 1 ] ) binarySearch ( mat , i_low + 1 , 0 , j_mid - 1 , x ) ; else binarySearch ( mat , i_low + 1 , j_mid + 1 , m - 1 , x ) ; }
boolean isFeasible ( int mid , int arr [ ] , int n , int k ) { int pos = arr [ 0 ] ; int elements = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - pos >= mid ) { pos = arr [ i ] ; elements ++ ; if ( elements == k ) return true ; } } return false ; }
int largestMinDist ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int res = - 1 ; int left = 1 , right = arr [ n - 1 ] ; while ( left < right ) { int mid = ( left + right ) / 2 ; if ( isFeasible ( mid , arr , n , k ) ) { res = Math . max ( res , mid ) ; left = mid + 1 ; } else right = mid ; } return res ; }
int bsearch ( int low , int high , int n , int arr [ ] ) { int mid = ( low + high ) / 2 ; if ( low <= high ) { if ( arr [ mid ] < n ) return bsearch ( mid + 1 , high , n , arr ) ; return bsearch ( low , mid - 1 , n , arr ) ; } return low ; }
int mindiff ( int arr [ ] [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) Arrays . sort ( arr [ i ] ) ; int ans = + 2147483647 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int p = bsearch ( 0 , m - 1 , arr [ i ] [ j ] , arr [ i + 1 ] ) ; ans = Math . min ( ans , Math . abs ( arr [ i + 1 ] [ p ] - arr [ i ] [ j ] ) ) ; if ( p - 1 >= 0 ) ans = Math . min ( ans , Math . abs ( arr [ i + 1 ] [ p - 1 ] - arr [ i ] [ j ] ) ) ; } } return ans ; }
int binarySearch ( int arr [ ] , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return - 1 ; }
int findRepeatingElement ( int arr [ ] , int low , int high ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; }
double diff ( double n , double mid ) { if ( n > ( mid * mid * mid ) ) return ( n - ( mid * mid * mid ) ) ; else return ( ( mid * mid * mid ) - n ) ; }
double cubicRoot ( double n ) { double start = 0 , end = n ; double e = 0.0000001 ; while ( true ) { double mid = ( start + end ) / 2 ; double error = diff ( n , mid ) ; if ( error <= e ) return mid ; if ( ( mid * mid * mid ) > n ) end = mid ; else start = mid ; } }
void findFrequencyUtil ( int arr [ ] , int low , int high , int [ ] freq ) { if ( arr [ low ] == arr [ high ] ) { freq [ arr [ low ] ] += high - low + 1 ; } else { int mid = ( low + high ) / 2 ; findFrequencyUtil ( arr , low , mid , freq ) ; findFrequencyUtil ( arr , mid + 1 , high , freq ) ; } }
void findFrequency ( int arr [ ] , int n ) { int [ ] freq = new int [ arr [ n - 1 ] + 1 ] ; findFrequencyUtil ( arr , 0 , n - 1 , freq ) ; for ( int i = 0 ; i <= arr [ n - 1 ] ; i ++ ) if ( freq [ i ] != 0 ) System . out . println ( "Element " + i + " occurs " + freq [ i ] + " times" ) ; }
int floorSqrt ( int x ) { if ( x == 0 x == 1 ) return x ; int i = 1 , result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; }
int countDirectPath ( int N ) { return N + ( N * ( N - 3 ) ) / 2 ; }
int isPossibleToReach ( int [ ] A , int N , int X , int Y ) { double distance = Math . sqrt ( ( X * X + Y * Y ) ) ; double mx = 0 ; for ( int i = 0 ; i < N ; i ++ ) { mx += ( A [ i ] ) ; } if ( mx < distance ) { System . out . print ( "NO" ) ; return 0 ; } if ( ( mx - distance ) < 0.000001 ) { System . out . print ( "YES" ) ; return 0 ; } for ( int i = 0 ; i < N ; i ++ ) { if ( distance + mx < 2 * A [ i ] ) { System . out . print ( "No" ) ; return 0 ; } } System . out . print ( "Yes" ) ; return 0 ; }
boolean canReach ( int X , int Y ) { int steps = 0 ; while ( X != 0 Y != 0 ) { int pos1 = X % 3 ; int pos2 = Y % 3 ; if ( pos1 == 2 pos2 == 2 ) { return false ; } if ( pos1 == 1 && pos2 == 1 ) { return false ; } if ( pos1 == 0 && pos2 == 0 ) { return false ; } X /= 3 ; Y /= 3 ; steps ++ ; } return true ; }
int numofneighbour ( int mat [ ] [ ] , int i , int j ) { int count = 0 ; if ( i > 0 && mat [ i - 1 ] [ j ] == 1 ) count ++ ; if ( j > 0 && mat [ i ] [ j - 1 ] == 1 ) count ++ ; if ( i < R - 1 && mat [ i + 1 ] [ j ] == 1 ) count ++ ; if ( j < C - 1 && mat [ i ] [ j + 1 ] == 1 ) count ++ ; return count ; }
int findperimeter ( int mat [ ] [ ] ) { int perimeter = 0 ; for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) if ( mat [ i ] [ j ] == 1 ) perimeter += ( 4 - numofneighbour ( mat , i , j ) ) ; return perimeter ; }
double findRadius ( double r1 , double r2 , double r3 ) { double r4 = ( r1 * r2 * r3 ) / ( r1 * r2 + r2 * r3 + r1 * r3 + 2.0 * Math . sqrt ( r1 * r2 * r3 * ( r1 + r2 + r3 ) ) ) ; return r4 ; }
void findSides ( double A , double C , double c ) { double B = 180 - ( A + C ) ; A = A * ( 3.14159 / 180 ) ; C = C * ( 3.14159 / 180 ) ; B = B * ( 3.14159 / 180 ) ; double a = ( c / Math . sin ( C ) ) * Math . sin ( A ) ; double b = ( c / Math . sin ( C ) ) * Math . sin ( B ) ; System . out . println ( String . format ( "%.2f" , a ) ) ; System . out . println ( String . format ( "%.2f" , b ) ) ; }
void closestsAngle ( int N , int A ) { double mi = Integer . MAX_VALUE ; int ans = 0 ; for ( int i = 1 ; i < N - 1 ; i ++ ) { double angle = 180.0 * i / N ; if ( Math . abs ( angle - A ) < Math . abs ( mi - A ) ) { mi = angle ; ans = i ; } } System . out . print ( 2 + " " + 1 + " " + ( 2 + ans ) ) ; }
double lengthOfLatusRectum ( double A , double B ) { double major = 2.0 * A ; double minor = 2.0 * B ; double latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }
double radius ( int a , int b , int c ) { int g = a / 2 ; int f = b / 2 ; if ( g * g + f * f - c < 0 ) return ( - 1 ) ; return ( Math . sqrt ( g * g + f * f - c ) ) ; }
double centerDistanceFromLine ( int a , int b , int i , int j , int k ) { int g = a / 2 ; int f = b / 2 ; double distance = Math . abs ( i * g + j * f + k ) / ( Math . sqrt ( i * i + j * j ) ) ; if ( distance < 0 ) return ( - 1 ) ; return distance ; }
void check_position ( int a , int b , int c , int d , int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { int value_1 = a * x1 + b * y1 + c * z1 + d ; int value_2 = a * x2 + b * y2 + c * z2 + d ; if ( ( value_1 > 0 && value_2 > 0 ) || ( value_1 < 0 && value_2 < 0 ) ) System . out . print ( "On same side" ) ; if ( ( value_1 > 0 && value_2 < 0 ) || ( value_1 < 0 && value_2 > 0 ) ) System . out . print ( "On different sides" ) ; if ( value_1 == 0 && value_2 == 0 ) System . out . print ( "Both on the plane" ) ; if ( value_1 == 0 && value_2 != 0 ) System . out . print ( "Point 1 on the plane" ) ; if ( value_1 != 0 && value_2 == 0 ) System . out . print ( "Point 2 on the plane" ) ; }
void normal_equation ( double a , double b , double x1 , double y1 ) { double slope = normal_slope ( a , b , x1 , y1 ) ; if ( slope == - 1 ) { System . out . print ( "x = " + x1 ) ; } if ( slope == - 2 ) { System . out . print ( "y = " + y1 ) ; } if ( slope != - 1 && slope != - 2 ) { x1 *= - slope ; x1 += y1 ; if ( x1 > 0 ) System . out . print ( "y = " + slope + "x + " + x1 ) ; else System . out . print ( "y = " + slope + "x " + x1 ) ; } }
double point_distance ( int x1 , int y1 , int x2 , int y2 ) { int p = ( x2 - x1 ) ; int q = ( y2 - y1 ) ; double distance = Math . sqrt ( p * p + q * q ) ; return distance ; }
boolean check ( circle C [ ] ) { double C1C2 = Math . sqrt ( ( C [ 1 ] . x - C [ 0 ] . x ) * ( C [ 1 ] . x - C [ 0 ] . x ) + ( C [ 1 ] . y - C [ 0 ] . y ) * ( C [ 1 ] . y - C [ 0 ] . y ) ) ; boolean flag = false ; if ( C1C2 < ( C [ 0 ] . r + C [ 1 ] . r ) ) { if ( ( C [ 0 ] . x + C [ 1 ] . x ) == 2 * C [ 2 ] . x && ( C [ 0 ] . y + C [ 1 ] . y ) == 2 * C [ 2 ] . y ) { flag = true ; } } return flag ; }
boolean IsFairTriplet ( circle c [ ] ) { boolean f = false ; f |= check ( c ) ; for ( int i = 0 ; i < 2 ; i ++ ) { swap ( c [ 0 ] , c [ 2 ] ) ; f |= check ( c ) ; } return f ; }
double eccHyperbola ( double A , double B ) { double r = ( double ) B * B / A * A ; r += 1 ; return Math . sqrt ( r ) ; }
double findInteriorAngle ( int n ) { return ( ( n - 2 ) * PI ) / n ; }
void findAngle ( double M1 , double M2 ) { double angle = Math . abs ( ( M2 - M1 ) / ( 1 + M1 * M2 ) ) ; double ret = Math . atan ( angle ) ; double val = ( ret * 180 ) / PI ; System . out . println ( val ) ; }
float calculateArea ( float A , float B , float C , float D ) { float S = ( A + B + C + D ) / 2 ; float area = ( float ) Math . sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) ; return area ; }
float angle ( float R1 , float R2 , float D ) { float ans = ( R1 * R1 + R2 * R2 - D * D ) / ( 2 * R1 * R2 ) ; return ans ; }
void triangleArea ( int a , int b ) { double ratio = ( double ) b / a ; System . out . println ( ratio ) ; }
int countInscribed ( int R1 , int R2 ) { if ( R2 > R1 ) return 0 ; double angle ; double ratio ; int number_of_circles = 0 ; ratio = R2 / ( double ) ( R1 - R2 ) ; if ( R1 < 2 * R2 ) { number_of_circles = 1 ; } else { angle = Math . abs ( Math . asin ( ratio ) * 180 ) / 3.14159265 ; number_of_circles = ( int ) ( 360 / ( 2 * Math . floor ( angle ) ) ) ; } return number_of_circles ; }
float distance ( int m , int n , int p , int q ) { return ( float ) Math . sqrt ( Math . pow ( n - m , 2 ) + Math . pow ( q - p , 2 ) * 1.0 ) ; }
double magnitude ( double arr [ ] , int N ) { double magnitude = 0 ; for ( int i = 0 ; i < N ; i ++ ) magnitude += arr [ i ] * arr [ i ] ; return Math . sqrt ( magnitude ) ; }
double dotProduct ( double [ ] arr , double [ ] brr , int N ) { double product = 0 ; for ( int i = 0 ; i < N ; i ++ ) product = product + arr [ i ] * brr [ i ] ; return product ; }
void angleBetweenVectors ( double [ ] arr , double [ ] brr , int N ) { double dotProductOfVectors = dotProduct ( arr , brr , N ) ; double magnitudeOfA = magnitude ( arr , N ) ; double magnitudeOfB = magnitude ( brr , N ) ; double angle = dotProductOfVectors / ( magnitudeOfA * magnitudeOfB ) ; System . out . println ( angle ) ; }
double lengthOfLatusRectum ( double A , double B ) { double major = 2.0 * A ; double minor = 2.0 * B ; double latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }
int totalCircles ( int L , int B ) { if ( L > B ) { int temp = L ; L = B ; B = temp ; } return B / L ; }
void findSquareSum ( int Coordinates [ ] [ ] , int N ) { long xq = 0 , yq = 0 ; long xs = 0 , ys = 0 ; long res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int a , b ; a = Coordinates [ i ] [ 0 ] ; b = Coordinates [ i ] [ 1 ] ; res += xq ; res -= 2 * xs * a ; res += i * ( long ) ( a * a ) ; xq += a * a ; xs += a ; res += yq ; res -= 2 * ys * b ; res += i * ( long ) b * b ; yq += b * b ; ys += b ; } System . out . println ( res ) ; }
double findDiagonal ( double s ) { return ( double ) Math . sqrt ( 2 ) * s ; }
void triangleArea ( float a , float b ) { if ( a < 0 b < 0 ) { System . out . println ( - 1 ) ; return ; } float area = ( 3 * ( float ) Math . sqrt ( 3 ) * a * b ) / ( 4 ) ; System . out . println ( area ) ; }
int maxRowDiff ( int mat [ ] [ ] , int m , int n ) { int rowSum [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] ; rowSum [ i ] = sum ; } int max_diff = rowSum [ 1 ] - rowSum [ 0 ] ; int min_element = rowSum [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) { if ( rowSum [ i ] - min_element > max_diff ) max_diff = rowSum [ i ] - min_element ; if ( rowSum [ i ] < min_element ) min_element = rowSum [ i ] ; } return max_diff ; }
float distance ( float x1 , float y1 , float x2 , float y2 ) { return ( float ) Math . sqrt ( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ) ; }
void lengthOfLatusRectum ( float a , float b , float c ) { pair vertex = new pair ( ( - b / ( 2 * a ) ) , ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) ) ; pair focus = new pair ( ( - b / ( 2 * a ) ) , ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) ) ; System . out . print ( 4 * distance ( ( float ) focus . first , ( float ) focus . second , ( float ) vertex . first , ( float ) vertex . second ) ) ; }
boolean doIntersect ( int [ ] X , int [ ] Y ) { if ( X [ 0 ] > X [ 3 ] X [ 2 ] > X [ 1 ] ) return false ; if ( Y [ 0 ] > Y [ 3 ] Y [ 2 ] > Y [ 1 ] ) return false ; return true ; }
int getUnionPerimeter ( int [ ] X , int [ ] Y ) { int perimeter = 0 ; if ( ! doIntersect ( X , Y ) ) { perimeter += 2 * ( Math . abs ( X [ 1 ] - X [ 0 ] ) + Math . abs ( Y [ 1 ] - Y [ 0 ] ) ) ; perimeter += 2 * ( Math . abs ( X [ 3 ] - X [ 2 ] ) + Math . abs ( Y [ 3 ] - Y [ 2 ] ) ) ; } else { int w = Arrays . stream ( X ) . max ( ) . getAsInt ( ) - Arrays . stream ( X ) . min ( ) . getAsInt ( ) ; int l = Arrays . stream ( Y ) . max ( ) . getAsInt ( ) - Arrays . stream ( Y ) . min ( ) . getAsInt ( ) ; perimeter = 2 * ( l + w ) ; } return perimeter ; }
int getPointsIns ( int x1 , int y1 , int radius , int x2 , int y2 , pair points [ ] ) { int ans = 0 ; for ( int i = 0 ; i < points . length ; i ++ ) { boolean condOne = false , condTwo = false ; if ( ( points [ i ] . b - y2 ) * ( x2 - x1 ) - ( y2 - y1 ) * ( points [ i ] . a - x2 ) >= 0 ) { condOne = true ; } if ( radius >= ( int ) Math . sqrt ( Math . pow ( ( y1 - points [ i ] . b ) , 2 ) + Math . pow ( x1 - points [ i ] . a , 2 ) ) ) { condTwo = true ; } if ( condOne && condTwo ) { ans += 1 ; } } return ans ; }
double Convert ( double degree ) { double pi = 3.14159265359 ; return ( degree * ( pi / 180 ) ) ; }
double findRadius ( double r1 , double r2 ) { double a1 , a2 , a3 , r3 ; a1 = 3.14 * r1 * r1 ; a2 = 3.14 * r2 * r2 ; a3 = a1 + a2 ; r3 = Math . sqrt ( a3 / 3.14 ) ; return r3 ; }
int find_lcm ( int a , int b , int c ) { int g = __gcd ( a , b ) ; int LCM1 = ( a * b ) / g ; g = __gcd ( LCM1 , c ) ; int LCM = ( LCM1 * c ) / g ; return LCM ; }
void minimumCuboids ( int L , int B , int H ) { int lcm = find_lcm ( L , B , H ) ; int volume_cube = lcm * lcm * lcm ; int volume_cuboid = L * B * H ; System . out . print ( ( volume_cube / volume_cuboid ) ) ; }
double distance ( pair p1 , pair p2 ) { double x1 = p1 . first , x2 = p2 . first ; double y1 = p1 . second , y2 = p2 . second ; return Math . sqrt ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) * 1.0 ) ; }
int CrossProduct ( int A [ ] [ ] ) { int X1 = ( A [ 1 ] [ 0 ] - A [ 0 ] [ 0 ] ) ; int Y1 = ( A [ 1 ] [ 1 ] - A [ 0 ] [ 1 ] ) ; int X2 = ( A [ 2 ] [ 0 ] - A [ 0 ] [ 0 ] ) ; int Y2 = ( A [ 2 ] [ 1 ] - A [ 0 ] [ 1 ] ) ; return ( X1 * Y2 - Y1 * X2 ) ; }
boolean isConvex ( int points [ ] [ ] ) { int N = points . length ; int prev = 0 ; int curr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int temp [ ] [ ] = { points [ i ] , points [ ( i + 1 ) % N ] , points [ ( i + 2 ) % N ] } ; curr = CrossProduct ( temp ) ; if ( curr != 0 ) { if ( curr * prev < 0 ) { return false ; } else { prev = curr ; } } } return true ; }
int cntRect ( int points [ ] [ ] , int N , int rectangle [ ] [ ] ) { HashSet < Integer > cntHor = new HashSet < > ( ) ; HashSet < Integer > cntVer = new HashSet < > ( ) ; cntHor . add ( 0 ) ; cntVer . add ( 0 ) ; cntHor . add ( rectangle [ 3 ] [ 0 ] ) ; cntVer . add ( rectangle [ 3 ] [ 1 ] ) ; for ( int i = 0 ; i < N ; i ++ ) { cntHor . add ( points [ i ] [ 0 ] ) ; cntVer . add ( points [ i ] [ 1 ] ) ; } return ( cntHor . size ( ) - 1 ) * ( cntVer . size ( ) - 1 ) ; }
int numberOfSquares ( int [ ] X , int [ ] Y , int N , int M ) { HashMap < Integer , Integer > m1 = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > m2 = new HashMap < Integer , Integer > ( ) ; int i , j , ans = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { int dist = Math . abs ( X [ i ] - X [ j ] ) ; m1 . put ( dist , m1 . getOrDefault ( dist , 0 ) + 1 ) ; } } for ( i = 0 ; i < M ; i ++ ) { for ( j = i + 1 ; j < M ; j ++ ) { int dist = Math . abs ( Y [ i ] - Y [ j ] ) ; m2 . put ( dist , m2 . getOrDefault ( dist , 0 ) + 1 ) ; } } for ( Map . Entry < Integer , Integer > entry : m1 . entrySet ( ) ) { if ( m2 . containsKey ( entry . getKey ( ) ) ) { ans += ( entry . getValue ( ) * m2 . get ( entry . getKey ( ) ) ) ; } } return ans ; }
double Area_Parallelogram1 ( int a , int b , int theta ) { double area = ( Math . abs ( Math . tan ( Math . toRadians ( theta ) ) ) / 2 ) * Math . abs ( a * a - b * b ) ; return area ; }
double Area_Parallelogram3 ( int d1 , int d2 , int theta ) { double area = ( Math . abs ( Math . sin ( Math . toRadians ( theta ) ) ) / 2 ) * Math . abs ( d1 * d2 ) ; return area ; }
int noOfTriangles ( int n ) { return ( n * ( n + 2 ) * ( 2 * n + 1 ) / 8 ) ; }
int No_of_squares ( int N , int K ) { int no_of_squares = 0 ; no_of_squares = ( N - K + 1 ) * ( N - K + 1 ) ; return no_of_squares ; }
void checkTriangle ( int x , int y , int z ) { if ( x == y && y == z ) System . out . println ( "Equilateral Triangle" ) ; else if ( x == y y == z z == x ) System . out . println ( "Isosceles Triangle" ) ; else System . out . println ( "Scalene Triangle" ) ; }
int getTotalCoverageOfMatrix ( int [ ] [ ] mat ) { int res = 0 ; for ( int i = 0 ; i < R ; i ++ ) { boolean isOne = false ; for ( int j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } isOne = false ; for ( int j = C - 1 ; j >= 0 ; j -- ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } } for ( int j = 0 ; j < C ; j ++ ) { boolean isOne = false ; for ( int i = 0 ; i < R ; i ++ ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } isOne = false ; for ( int i = R - 1 ; i >= 0 ; i -- ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } } return res ; }
double Circumradius ( int a , int b , int c , int d ) { double s = ( a + b + c + d ) / 2.0 ; double radius = Math . sqrt ( ( ( a * b ) + ( c * d ) ) * ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( s - a ) * ( s - b ) * ( s - c ) * ( s - d ) ) ) ; return radius / 4 ; }
int calculateTriangles ( int sides [ ] ) { double count = Math . pow ( sides [ 0 ] + sides [ 1 ] + sides [ 2 ] , 2 ) ; count -= Math . pow ( sides [ 0 ] , 2 ) ; count -= Math . pow ( sides [ 2 ] , 2 ) ; count -= Math . pow ( sides [ 4 ] , 2 ) ; return ( int ) ( count ) ; }
double Length_Diagonal ( int a , int b , double theta ) { double diagonal = Math . sqrt ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) - 2 * a * b * Math . cos ( theta * ( Math . PI / 180 ) ) ) ; return diagonal ; }
void maximumTiles ( int n , int m ) { System . out . println ( ( m * n ) / 2 ) ; }
float Length_Diagonal ( int a , int b , int d ) { float diagonal = ( float ) Math . sqrt ( 2 * ( ( a * a ) + ( b * b ) ) - ( d * d ) ) ; return diagonal ; }
Vector < Float > Diagonals ( int a , int b , int c , int d ) { Vector < Float > ans = new Vector < Float > ( ) ; ans . add ( ( float ) Math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( a * b ) + ( c * d ) ) ) ) ; ans . add ( ( float ) Math . sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * b ) + ( c * d ) ) / ( ( a * d ) + ( b * c ) ) ) ) ; return ans ; }
double find ( double x , double y , int [ ] [ ] p ) { double mind = 0 ; for ( int i = 0 ; i < p . length ; i ++ ) { double a = p [ i ] [ 0 ] , b = p [ i ] [ 1 ] ; mind += Math . sqrt ( ( x - a ) * ( x - a ) + ( y - b ) * ( y - b ) ) ; } return mind ; }
double getMinDistSum ( int [ ] [ ] p ) { double x = 0 , y = 0 ; for ( int i = 0 ; i < p . length ; i ++ ) { x += p [ i ] [ 0 ] ; y += p [ i ] [ 1 ] ; } x = x / p . length ; y = y / p . length ; double mind = find ( x , y , p ) ; return mind ; }
int det ( int [ ] [ ] d ) { int Sum = d [ 0 ] [ 0 ] * ( ( d [ 1 ] [ 1 ] * d [ 2 ] [ 2 ] ) - ( d [ 2 ] [ 1 ] * d [ 1 ] [ 2 ] ) ) ; Sum -= d [ 0 ] [ 1 ] * ( ( d [ 1 ] [ 0 ] * d [ 2 ] [ 2 ] ) - ( d [ 1 ] [ 2 ] * d [ 2 ] [ 0 ] ) ) ; Sum += d [ 0 ] [ 2 ] * ( ( d [ 0 ] [ 1 ] * d [ 1 ] [ 2 ] ) - ( d [ 0 ] [ 2 ] * d [ 1 ] [ 1 ] ) ) ; return Sum ; }
double distance ( int r , int R ) { double d = Math . sqrt ( Math . pow ( R , 2 ) - ( 2 * r * R ) ) ; return d ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void replacematrix ( int [ ] [ ] mat , int n , int m ) { int [ ] rgcd = new int [ R ] ; int [ ] cgcd = new int [ C ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { rgcd [ i ] = gcd ( rgcd [ i ] , mat [ i ] [ j ] ) ; cgcd [ j ] = gcd ( cgcd [ j ] , mat [ i ] [ j ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) mat [ i ] [ j ] = Math . max ( rgcd [ i ] , cgcd [ j ] ) ; }
int areaOfSquare ( int S ) { int area = S * S ; return area ; }
boolean isAllKs ( int n , int b , int k ) { int len = findNumberOfDigits ( n , b ) ; int sum = k * ( 1 - ( int ) Math . pow ( b , len ) ) / ( 1 - b ) ; return sum == n ; }
void checkRightAngled ( int X1 , int Y1 , int X2 , int Y2 , int X3 , int Y3 ) { int A = ( int ) Math . pow ( ( X2 - X1 ) , 2 ) + ( int ) Math . pow ( ( Y2 - Y1 ) , 2 ) ; int B = ( int ) Math . pow ( ( X3 - X2 ) , 2 ) + ( int ) Math . pow ( ( Y3 - Y2 ) , 2 ) ; int C = ( int ) Math . pow ( ( X3 - X1 ) , 2 ) + ( int ) Math . pow ( ( Y3 - Y1 ) , 2 ) ; if ( ( A > 0 && B > 0 && C > 0 ) && ( A == ( B + C ) || B == ( A + C ) || C == ( A + B ) ) ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
void checkValidPolygon ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum == 180 * ( N - 2 ) ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
double minAnglRot ( int N ) { double res ; res = 360 / ( double ) N ; return res ; }
int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; }
int sortedCount ( int mat [ ] [ ] , int r , int c ) { int result = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = 0 ; j < c - 1 ; j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ; if ( j == c - 1 ) result ++ ; } for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = c - 1 ; j > 0 ; j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ; if ( c > 1 && j == 0 ) result ++ ; } return result ; }
double Area_of_Triangle ( int a , int b , int c ) { int s = ( a + b + c ) / 2 ; int x = s * ( s - a ) ; x = x * ( s - b ) ; x = x * ( s - c ) ; double area = ( 4 / ( double ) 3 ) * Math . sqrt ( x ) ; return area ; }
float Area_of_Triangle ( int a , int b , int k ) { float area = ( float ) ( ( 1 / 2.0 ) * a * b * Math . sin ( k ) ) ; return area ; }
int findAreaCovered ( ) { int area = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { if ( arr [ i ] [ j ] == true ) { area ++ ; } } } return area ; }
void findEquation ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int d , int e , int f ) { double a = x2 - x1 ; double b = y2 - y1 ; double c = z2 - z1 ; int A = ( int ) ( b * f - c * e ) ; int B = ( int ) ( a * f - c * d ) ; int C = ( int ) ( a * e - b * d ) ; int D = - ( int ) ( A * d - B * e + C * f ) ; System . out . println ( A + "x + " + B + "y + " + C + "z + " + D + "= 0 " ) ; }
void createPrefixArray ( int n , int arr [ ] , int prefSize , int pref [ ] ) { for ( int i = 0 ; i < prefSize ; i ++ ) { pref [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] + 1000000 ; pref [ x ] ++ ; } for ( int i = 1 ; i < prefSize ; i ++ ) { pref [ i ] += pref [ i - 1 ] ; } }
int count_rectangles ( int N , int M ) { int p_x = ( N * ( N - 1 ) ) / 2 ; int p_y = ( M * ( M - 1 ) ) / 2 ; return p_x * p_y ; }
float median ( int a , int b , int c ) { float n = ( float ) ( Math . sqrt ( 2 * b * b + 2 * c * c - a * a ) / 2 ) ; return n ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i < n + 1 ; i ++ ) res = res * i ; return res ; }
double circleArea ( double r ) { double pi = 3.14159265358979323846 ; return ( pi * r * r ) ; }
double findCircleAreaByMedian ( int m ) { double r = 2 * m / 3 ; return circleArea ( r ) ; }
int areaSquare ( int L , int B ) { int large = Math . max ( L , B ) ; int small = Math . min ( L , B ) ; if ( large >= 2 * small ) { return large * large ; } else { return ( 2 * small ) * ( 2 * small ) ; } }
double nGon ( int N ) { double proAngleVar ; if ( N % 4 == 0 ) { proAngleVar = pi * ( 180.0 / N ) / 180 ; } else { proAngleVar = pi * ( 180.0 / ( 2 * N ) ) / 180 ; } double negX = 1.0e+99 , posX = - 1.0e+99 , negY = 1.0e+99 , posY = - 1.0e+99 ; for ( int j = 0 ; j < N ; ++ j ) { double px = Math . cos ( 2 * pi * j / N + proAngleVar ) ; double py = Math . sin ( 2 * pi * j / N + proAngleVar ) ; negX = Math . min ( negX , px ) ; posX = Math . max ( posX , px ) ; negY = Math . min ( negY , py ) ; posY = Math . max ( posY , py ) ; } double opt2 = Math . max ( posX - negX , posY - negY ) ; return ( double ) opt2 / Math . sin ( pi / N ) / 2 ; }
float cal_cos ( float n ) { float accuracy = ( float ) 0.0001 , x1 , denominator , cosx , cosval ; n = ( float ) ( n * ( 3.142 / 180.0 ) ) ; x1 = 1 ; cosx = x1 ; cosval = ( float ) Math . cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= Math . abs ( cosval - cosx ) ) ; return cosx ; }
int triacontagonalNum ( int n ) { return ( 28 * n * n - 26 * n ) / 2 ; }
int hexacontagonNum ( int n ) { return ( 58 * n * n - 56 * n ) / 2 ; }
boolean isicositetragonal ( int N ) { float n = ( float ) ( ( 10 + Math . sqrt ( 44 * N + 100 ) ) / 22 ) ; return ( n - ( int ) n ) == 0 ; }
int enneacontagonNum ( int n ) { return ( 88 * n * n - 86 * n ) / 2 ; }
int triacontakaidigonNum ( int n ) { return ( 30 * n * n - 28 * n ) / 2 ; }
int maxXOR ( int mat [ ] [ ] , int N ) { int r_xor , c_xor ; int max_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { r_xor = 0 ; c_xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < Math . max ( r_xor , c_xor ) ) max_xor = Math . max ( r_xor , c_xor ) ; } return max_xor ; }
boolean isTridecagon ( int N ) { float n = ( float ) ( ( 9 + Math . sqrt ( 88 * N + 81 ) ) / 22 ) ; return ( n - ( int ) n ) == 0 ; }
boolean isicosihenagonal ( int N ) { float n = ( float ) ( ( 17 + Math . sqrt ( 152 * N + 289 ) ) / 38 ) ; return ( n - ( int ) n ) == 0 ; }
boolean isicositrigonal ( int N ) { float n = ( float ) ( 19 + Math . sqrt ( 168 * N + 361 ) ) / 42 ; return ( n - ( int ) n ) == 0 ; }
int IcosihexagonalNum ( int n ) { return ( 24 * n * n - 22 * n ) / 2 ; }
int icosikaioctagonalNum ( int n ) { return ( 26 * n * n - 24 * n ) / 2 ; }
int hectagonNum ( int n ) { return ( 98 * n * n - 96 * n ) / 2 ; }
int tetracontagonNum ( int n ) { return ( 38 * n * n - 36 * n ) / 2 ; }
int Tridecagonal_num ( int n ) { return ( 11 * n * n - 9 * n ) / 2 ; }
int Octadecagonal_num ( int n ) { return ( 16 * n * n - 14 * n ) / 2 ; }
int Icositetragonal_num ( int n ) { return ( 22 * n * n - 20 * n ) / 2 ; }
int Icosihenagonal_num ( int n ) { return ( 19 * n * n - 17 * n ) / 2 ; }
void checkTriangle ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int a = x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ; if ( a == 0 ) System . out . println ( "No" ) ; else System . out . println ( "Yes" ) ; }
int numTrip ( ArrayList points ) { int res = 0 ; for ( int i = 0 ; i < points . size ( ) ; ++ i ) { HashMap < Long , Integer > map = new HashMap < > ( ) ; for ( int j = 0 ; j < points . size ( ) ; ++ j ) { if ( j == i ) continue ; int dy = ( ( pair ) points . get ( i ) ) . second - ( ( pair ) points . get ( j ) ) . second ; int dx = ( ( pair ) points . get ( i ) ) . first - ( ( pair ) points . get ( j ) ) . first ; long key = dy * dy ; key += dx * dx ; if ( map . containsKey ( key ) ) { map . put ( key , map . get ( key ) + 1 ) ; } else { map . put ( key , 1 ) ; } } for ( int p : map . values ( ) ) res += p * ( p - 1 ) ; } return res ; }
boolean checkOverlap ( int R , int Xc , int Yc , int X1 , int Y1 , int X2 , int Y2 ) { int Xn = Math . max ( X1 , Math . min ( Xc , X2 ) ) ; int Yn = Math . max ( Y1 , Math . min ( Yc , Y2 ) ) ; int Dx = Xn - Xc ; int Dy = Yn - Yc ; return ( Dx * Dx + Dy * Dy ) <= R * R ; }
double area_of_circle ( int m , int n ) { int square_of_radius = ( m * n ) / 4 ; double area = ( 3.141 * square_of_radius ) ; return area ; }
void direction ( int R , int C ) { if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) { System . out . println ( "Left" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) { System . out . println ( "Up" ) ; return ; } if ( R == C && R % 2 != 0 && C % 2 != 0 ) { System . out . println ( "Right" ) ; return ; } if ( R == C && R % 2 == 0 && C % 2 == 0 ) { System . out . println ( "Left" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { System . out . println ( "Right" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) { System . out . println ( "Down" ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) { System . out . println ( "Left" ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) { System . out . println ( "Up" ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) { System . out . println ( "Down" ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) { System . out . println ( "Right" ) ; return ; } }
int checkIntersection ( pair p1 , pair p2 , pair p ) { int val ; if ( p1 . second == p2 . second && p1 . second == p . second ) { if ( p . first <= Math . max ( p1 . first , p2 . first ) && ( p . first >= Math . min ( p1 . first , p2 . first ) ) ) return 1 ; } if ( p1 . first == p2 . first && p1 . first == p . first ) { if ( p . second <= Math . max ( p1 . second , p2 . second ) && ( p . second >= Math . min ( p1 . second , p2 . second ) ) ) return 1 ; } else { val = ( p . second - p1 . second ) * ( p2 . first - p1 . first ) - ( p . first - p1 . first ) * ( p2 . second - p1 . second ) ; if ( val == 0 ) if ( ( p . first <= Math . max ( p1 . first , p2 . first ) && ( p . first >= Math . min ( p1 . first , p2 . first ) ) ) && ( p . second <= Math . max ( p1 . second , p2 . second ) && ( p . second >= Math . min ( p1 . second , p2 . second ) ) ) ) return 1 ; } return 0 ; }
void towerOfSight ( pair a , pair b , pair c , pair d ) { int flag = 0 ; if ( checkIntersection ( a , c , b ) == 1 ) flag = 1 ; else if ( checkIntersection ( a , c , d ) == 1 ) flag = 1 ; else if ( checkIntersection ( b , d , a ) == 1 ) flag = 1 ; else if ( checkIntersection ( b , d , c ) == 1 ) flag = 1 ; System . out . print ( flag == 1 ? "Yes" : "No" ) ; }
int NotParallel ( int p [ ] [ ] , int n ) { HashMap < Integer , Integer > x_axis = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > y_axis = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( x_axis . containsKey ( p [ i ] [ 0 ] ) ) x_axis . put ( p [ i ] [ 0 ] , x_axis . get ( p [ i ] [ 0 ] ) + 1 ) ; else x_axis . put ( p [ i ] [ 0 ] , 1 ) ; if ( y_axis . containsKey ( p [ i ] [ 1 ] ) ) y_axis . put ( p [ i ] [ 1 ] , y_axis . get ( p [ i ] [ 1 ] ) + 1 ) ; else y_axis . put ( p [ i ] [ 1 ] , 1 ) ; } int total = ( n * ( n - 1 ) ) / 2 ; for ( Map . Entry < Integer , Integer > i : x_axis . entrySet ( ) ) { int c = i . getValue ( ) ; total -= ( c * ( c - 1 ) ) / 2 ; } for ( Map . Entry < Integer , Integer > i : y_axis . entrySet ( ) ) { int c = i . getValue ( ) ; total -= ( c * ( c - 1 ) ) / 2 ; } return total ; }
void checkTypeOfTriangle ( int a , int b , int c ) { int sqa = ( int ) Math . pow ( a , 2 ) ; int sqb = ( int ) Math . pow ( b , 2 ) ; int sqc = ( int ) Math . pow ( c , 2 ) ; if ( sqa == sqa + sqb sqb == sqa + sqc sqc == sqa + sqb ) { System . out . print ( "Right-angled Triangle" ) ; } else if ( sqa > sqc + sqb sqb > sqa + sqc sqc > sqa + sqb ) { System . out . print ( "Obtuse-angled Triangle" ) ; } else { System . out . print ( "Acute-angled Triangle" ) ; } }
void lineFromPoints ( point P , point Q , double a , double b , double c ) { a = Q . y - P . y ; b = P . x - Q . x ; c = a * ( P . x ) + b * ( P . y ) ; }
double LineInterX ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { double determ = a1 * b2 - a2 * b1 ; double x = ( b2 * c1 - b1 * c2 ) ; x /= determ ; return x ; }
double LineInterY ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { double determ = a1 * b2 - a2 * b1 ; double y = ( a1 * c2 - a2 * c1 ) ; y /= determ ; return y ; }
void findPosition ( point P , point Q , point R , point D ) { point r = new point ( ) ; double a = 0 , b = 0 , c = 0 ; lineFromPoints ( P , Q , a , b , c ) ; double e = 0 , f = 0 , g = 0 ; lineFromPoints ( Q , R , e , f , g ) ; perpenBisectorFromLine ( P , Q , a , b , c ) ; perpenBisectorFromLine ( Q , R , e , f , g ) ; r . x = LineInterX ( a , b , c , e , f , g ) ; r . y = LineInterY ( a , b , c , e , f , g ) ; double q = ( r . x - P . x ) * ( r . x - P . x ) + ( r . y - P . y ) * ( r . y - P . y ) ; double dis = ( r . x - D . x ) * ( r . x - D . x ) + ( r . y - D . y ) * ( r . y - D . y ) ; if ( dis < q ) { System . out . print ( "Point (" + D . x + ", " + D . y + ") is inside " + "the circumcircle" ) ; } else if ( dis == q ) { System . out . print ( "Point (" + D . x + ", " + D . y + ") lies on the " + "circumcircle" ) ; } else { System . out . print ( "Point (" + D . x + ", " + D . y + ") lies outside" + " the circumcircle" ) ; } }
void disp ( int row_no , int block ) { System . out . print ( row_no * block ) ; }
int row ( int ht , int h ) { return ht / h ; }
void calculate ( int l , int w , int h , int a , int ht ) { int no_block = ( 4 * a ) / l ; int row_no ; if ( h < w ) row_no = row ( ht , w ) ; else row_no = row ( ht , h ) ; disp ( row_no , no_block ) ; }
double solve ( int s ) { double area = ( 1.732 * Math . pow ( s , 2 ) ) / 8 ; return area ; }
double area ( int R ) { double base = 1.732 * R ; double height = ( 1.5 ) * R ; double area = 0.5 * base * height ; return area ; }
void spiralPrint ( int m , int n , int [ ] [ ] a , int c ) { int i , k = 0 , l = 0 ; int count = 0 ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) { count ++ ; if ( count == c ) System . out . println ( a [ k ] [ i ] + " " ) ; } k ++ ; for ( i = k ; i < m ; ++ i ) { count ++ ; if ( count == c ) System . out . println ( a [ i ] [ n - 1 ] + " " ) ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { count ++ ; if ( count == c ) System . out . println ( a [ m - 1 ] [ i ] + " " ) ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { count ++ ; if ( count == c ) System . out . println ( a [ i ] [ l ] + " " ) ; } l ++ ; } } }
float find_Area ( float a ) { float R = a * ( float ) ( 2.0 - Math . sqrt ( 2 ) ) ; float area = ( float ) ( ( 3.14 * R * R ) / 2.0 ) ; return area ; }
int times ( int [ ] steps , int n ) { int current_level = 0 ; int previous_level = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { previous_level = current_level ; current_level = current_level + steps [ i ] ; if ( ( previous_level < 0 && current_level >= 0 ) || ( previous_level > 0 && current_level <= 0 ) ) { count ++ ; } } return count ; }
int solve ( int n , int m , int obstacles , double range [ ] ) { double val = Math . min ( n , m ) ; Arrays . sort ( range ) ; int c = 1 ; for ( int i = obstacles - 1 ; i >= 0 ; i -- ) { range [ i ] = 2 * range [ i ] ; val -= range [ i ] ; if ( val <= 0 ) { return c ; } else { c ++ ; } } if ( val > 0 ) { return - 1 ; } return 0 ; }
void equation_plane ( int [ ] p , int [ ] q , int [ ] r ) { int x1 = p [ 0 ] ; int y1 = p [ 1 ] ; int z1 = p [ 2 ] ; int x2 = q [ 0 ] ; int y2 = q [ 1 ] ; int z2 = q [ 2 ] ; int x3 = r [ 0 ] ; int y3 = r [ 1 ] ; int z3 = r [ 2 ] ; int a1 = x2 - x1 ; int b1 = y2 - y1 ; int c1 = z2 - z1 ; int a2 = x3 - x1 ; int b2 = y3 - y1 ; int c2 = z3 - z1 ; int A = b1 * c2 - b2 * c1 ; int B = a2 * c1 - a1 * c2 ; int C = a1 * b2 - b1 * a2 ; int D = ( - A * x1 - B * y1 - C * z1 ) ; double [ ] rslt = XandYandZintercept ( A , B , C , D ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . printf ( rslt [ i ] + " " ) ; } }
int countPairs ( int [ ] P , int [ ] Q , int N , int M ) { int [ ] A = new int [ 2 ] , B = new int [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( int i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; }
float find_angle ( int x , int y , int z ) { int volume = x * x * y ; float ans = 0 ; if ( z < volume / 2 ) { float d = ( float ) ( ( x * y * y ) / ( 2.0 * z ) ) ; ans = ( float ) Math . atan ( d ) ; } else { z = volume - z ; float d = ( 2 * z ) / ( float ) ( x * x * x ) ; ans = ( float ) Math . atan ( d ) ; } ans = ( float ) ( ( ans * 180 ) / 3.14159265 ) ; return ans ; }
Vector < pair > FindPoints ( int n ) { Vector < pair > v = new Vector < pair > ( ) ; v . add ( new pair ( 0 , 0 ) ) ; v . add ( new pair ( 0 , n ) ) ; v . add ( new pair ( n , 0 ) ) ; v . add ( new pair ( n , n ) ) ; if ( n % 2 == 0 ) v . add ( new pair ( n / 2 , n / 2 ) ) ; return v ; }
double findsolution ( double d , double h , double m , double n ) { double k = ( 4 * m ) / ( pie * d * d ) ; if ( n > k ) return - 1 ; double ans = ( h / ( k - n ) ) ; return ans ; }
double [ ] find_Centroid ( double v [ ] [ ] ) { double [ ] ans = new double [ 2 ] ; int n = v . length ; double signedArea = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x0 = v [ i ] [ 0 ] , y0 = v [ i ] [ 1 ] ; double x1 = v [ ( i + 1 ) % n ] [ 0 ] , y1 = v [ ( i + 1 ) % n ] [ 1 ] ; double A = ( x0 * y1 ) - ( x1 * y0 ) ; signedArea += A ; ans [ 0 ] += ( x0 + x1 ) * A ; ans [ 1 ] += ( y0 + y1 ) * A ; } signedArea *= 0.5 ; ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) ; ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) ; return ans ; }
int sumOfInternalAngles ( int n ) { if ( n < 3 ) return 0 ; return ( ( n - 2 ) * 180 ) ; }
int cntWays ( int n ) { if ( n % 2 == 1 ) { return 0 ; } else { return ( n - 2 ) / 4 ; } }
int noOfTriangles ( int n ) { int y = 4 * n ; return ( ( y * ( y - 2 ) * ( y - 1 ) ) - ( 4 * n * ( n - 2 ) * ( n - 1 ) ) ) / 6 ; }
int angle ( int n ) { return 2 * n ; }
boolean checkDiagonal ( int mat [ ] [ ] , int i , int j ) { int res = mat [ i ] [ j ] ; while ( ++ i < N && ++ j < M ) { if ( mat [ i ] [ j ] != res ) return false ; } return true ; }
boolean ifRight ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int a = ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ; int b = ( ( x1 - x3 ) * ( x1 - x3 ) ) + ( ( y1 - y3 ) * ( y1 - y3 ) ) ; int c = ( ( x2 - x3 ) * ( x2 - x3 ) ) + ( ( y2 - y3 ) * ( y2 - y3 ) ) ; if ( ( a == ( b + c ) && a != 0 && b != 0 && c != 0 ) || ( b == ( a + c ) && a != 0 && b != 0 && c != 0 ) || ( c == ( a + b ) && a != 0 && b != 0 && c != 0 ) ) { return true ; } return false ; }
void isValidCombination ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int x , y ; boolean possible = false ; if ( ifRight ( x1 , y1 , x2 , y2 , x3 , y3 ) ) { System . out . print ( "ALREADY RIGHT ANGLED" ) ; return ; } else { for ( int i = 0 ; i < 4 ; i ++ ) { x = dx [ i ] + x1 ; y = dy [ i ] + y1 ; if ( ifRight ( x , y , x2 , y2 , x3 , y3 ) ) { System . out . print ( "POSSIBLE" ) ; return ; } x = dx [ i ] + x2 ; y = dy [ i ] + y2 ; if ( ifRight ( x1 , y1 , x , y , x3 , y3 ) ) { System . out . print ( "POSSIBLE" ) ; return ; } x = dx [ i ] + x3 ; y = dy [ i ] + y3 ; if ( ifRight ( x1 , y1 , x2 , y2 , x , y ) ) { System . out . print ( "POSSIBLE" ) ; return ; } } } if ( ! possible ) System . out . println ( "NOT POSSIBLE" ) ; }
double area_of_regular_polygon ( double n , double len ) { double P = ( len * n ) ; double A = len / ( 2 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; double area = ( P * A ) / 2 ; return area ; }
double area_of_triangle_inscribed ( double n , double len ) { double area = area_of_regular_polygon ( n , len ) ; double triangle = area / n ; double ins_tri = ( triangle * 3 ) ; return ins_tri ; }
void maxRegions ( int n ) { int num ; num = n * ( n + 1 ) / 2 + 1 ; System . out . println ( num ) ; ; }
boolean pointsAreOnSameSideOfLine ( int a , int b , int c , int x1 , int y1 , int x2 , int y2 ) { fx1 = a * x1 + b * y1 - c ; fx2 = a * x2 + b * y2 - c ; if ( ( fx1 * fx2 ) > 0 ) return true ; return false ; }
float Area ( int d , int h1 , int h2 ) { float area ; area = ( float ) 0.5 * d * ( h1 + h2 ) ; return area ; }
float diagonal_length ( float a ) { float L ; L = a * ( float ) Math . sqrt ( 3 ) ; return L ; }
double find_area ( int r , int d ) { double R = d / PI ; R += Math . pow ( r , 2 ) ; R = Math . sqrt ( R ) ; double area = PI * Math . pow ( R , 2 ) ; return area ; }
int Valid ( int a , int b , int c , int d ) { if ( a + b + c + d == 360 ) return 1 ; return 0 ; }
int Valid ( int a , int b , int c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return 1 ; else return 0 ; }
double calculate_angle ( double n ) { double total_angle = 360 ; return total_angle / n ; }
float areaOfKite ( int a , int b , double angle ) { angle = angle * PI ; double area = a * b * Math . sin ( angle ) ; return ( float ) area ; }
float angleOncirCumference ( float z ) { return ( z / 2 ) ; }
void newvol ( double x ) { System . out . print ( "percentage increase " + "in the volume of the cube is " + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) ) ; System . out . print ( "%" ) ; }
void newvol ( double x ) { System . out . print ( "percentage increase in the" + " volume of the sphere is " + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) + "%" ) ; }
int countZeroes ( int mat [ ] [ ] ) { int row = N - 1 , col = 0 ; int count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] > 0 ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; }
void newvol ( double x ) { System . out . print ( "percentage increase " + "in the volume of the cylinder is " + x + "%" ) ; }
void radius ( double n , double d ) { System . out . print ( "The side of each square is " + d / ( ( n - 1 ) * Math . sqrt ( 2 ) ) ) ; }
void findTriangles ( int n ) { int num = n ; System . out . print ( num + " " ) ; System . out . print ( num * ( num - 4 ) * ( num - 5 ) / 6 ) ; }
void radius ( int n , int d ) { System . out . print ( "The radius of each circle is " + d / ( 2 * n - 2 ) ) ; }
void radius ( int n , int d ) { System . out . print ( "The side of each square is " + d / ( n - 1 ) ) ; }
double innerCirclearea ( double radius ) { if ( radius < 0 ) { return - 1 ; } double r = radius / 2 ; double Area = ( 3.14 * Math . pow ( r , 2 ) ) ; return Area ; }
double areaOfTriangle ( float d ) { float c = ( float ) ( 1.618 * d ) ; float s = ( d + c + c ) / 2 ; double area = Math . sqrt ( s * ( s - c ) * ( s - c ) * ( s - d ) ) ; return 5 * area ; }
double areaOfRegPentagon ( float d ) { double cal = 4 * Math . tan ( PI / 5 ) ; double area = ( 5 * d * d ) / cal ; return area ; }
double areaOfPentagram ( float d ) { return areaOfRegPentagon ( d ) + areaOfTriangle ( d ) ; }
void lengperpbisect ( double r1 , double r2 ) { double z = 2 * Math . sqrt ( ( r1 * r1 ) - ( ( r1 - r2 ) * ( r1 - r2 ) / 4 ) ) ; System . out . println ( "The length of the " + "perpendicular bisector is " + z ) ; }
void anglequichord ( int z ) { System . out . println ( "The angle is " + z + " degrees" ) ; }
void lengchord ( int z ) { System . out . println ( "The length is " + z ) ; }
void angleextcycquad ( int z ) { System . out . print ( "The exterior angle of the" + " cyclic quadrilateral is " + z + " degrees" ) ; }
void anglechordtang ( int z ) { System . out . print ( "The angle between tangent" + " and the chord is " + z + " degrees" ) ; }
void circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( int ) Math . sqrt ( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ) ; if ( distSq + r2 == r1 ) { System . out . println ( "The smaller circle lies completely" + " inside the bigger circle with " + "touching each other " + "at a point of circumference. " ) ; } else if ( distSq + r2 < r1 ) { System . out . println ( "The smaller circle lies completely" + " inside the bigger circle without" + " touching each other " + "at a point of circumference." ) ; } else { System . out . println ( "The smaller does not lies inside" + " the bigger circle completely." ) ; } }
int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; }
int countOdd ( int n ) { int coun = 0 , m , j , i ; for ( i = n - 2 ; i >= 1 ; i -- ) { if ( i >= 1 ) { m = ( n - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } else { m = ( ( n - 1 ) - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } } return coun ; }
int countEven ( int n ) { int coun = 0 , m , j , i ; for ( i = n - 2 ; i >= 1 ; i -- ) { if ( i >= 1 ) { m = ( ( n - 1 ) - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } else { m = ( n - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } } return coun ; }
int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; }
int GCD ( int a , int b ) { return ( b != 0 ? GCD ( b , a % b ) : a ) ; }
void ratiotang ( int r1 , int r2 ) { System . out . println ( "The ratio is " + r1 / GCD ( r1 , r2 ) + ":" + r2 / GCD ( r1 , r2 ) ) ; }
int Regions ( int Vertices , int Edges ) { int R = Edges + 2 - Vertices ; return R ; }
void ratiotang ( int r1 , int r2 ) { System . out . println ( "The ratio is " + r1 / GCD ( r1 , r2 ) + " : " + r2 / GCD ( r1 , r2 ) ) ; }
void lengthOfTangent ( double r1 , double r2 , double d ) { System . out . println ( "The length of the transverse" + " common tangent is " + Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 + r2 ) , 2 ) ) ) ; }
int remainingArea ( int N , int M , int K ) { while ( K -- > 0 && N > 0 && M > 0 ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; }
void lengtang ( double r1 , double r2 , double d ) { System . out . println ( "The length of the direct" + " common tangent is " + ( Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 - r2 ) , 2 ) ) ) ) ; }
void rad ( double d , double h ) { System . out . println ( "The radius of the circle is " + ( ( d * d ) / ( 8 * h ) + h / 2 ) ) ; }
void lengtang ( double r1 , double r2 ) { System . out . println ( "The length of the " + "direct common tangent is " + ( 2 * Math . sqrt ( r1 * r2 ) ) ) ; }
void diameter ( double r ) { System . out . println ( "The length of the longest chord" + " or diameter of the circle is " + 2 * r ) ; }
double dist ( double m , double b1 , double b2 ) { double d = Math . abs ( b2 - b1 ) / ( ( m * m ) - 1 ) ; return d ; }
double getSlope ( double m ) { return m ; }
int totalTriangles ( int h , int v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; int total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return total ; }
int findLargestPlus ( int mat [ ] [ ] ) { int left [ ] [ ] = new int [ N ] [ N ] ; int right [ ] [ ] = new int [ N ] [ N ] ; int top [ ] [ ] = new int [ N ] [ N ] ; int bottom [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { top [ 0 ] [ i ] = mat [ 0 ] [ i ] ; bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] ; left [ i ] [ 0 ] = mat [ i ] [ 0 ] ; right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ; else left [ i ] [ j ] = 0 ; if ( mat [ j ] [ i ] == 1 ) top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 ; else top [ j ] [ i ] = 0 ; j = N - 1 - j ; if ( mat [ j ] [ i ] == 1 ) bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 ; else bottom [ j ] [ i ] = 0 ; if ( mat [ i ] [ j ] == 1 ) right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 ; else right [ i ] [ j ] = 0 ; j = N - 1 - j ; } } int n = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int len = Math . min ( Math . min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , Math . min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) ; if ( len > n ) n = len ; } } if ( n > 0 ) return 4 * ( n - 1 ) + 1 ; return 0 ; }
void noOfSquares ( int x1 , int y1 , int x2 , int y2 ) { int dx = Math . abs ( x2 - x1 ) ; int dy = Math . abs ( y2 - y1 ) ; int ans = dx + dy - __gcd ( dx , dy ) ; System . out . println ( ans ) ; }
int countSteps ( int x , int y ) { if ( x < y ) { return x + y + 2 * ( ( y - x ) / 2 ) ; } else { return x + y + 2 * ( ( ( x - y ) + 1 ) / 2 ) ; } }
boolean isSlopeGood ( double slope , int arr [ ] , int n ) { Set < Double > setOfLines = new HashSet < Double > ( ) ; for ( int i = 0 ; i < n ; i ++ ) setOfLines . add ( arr [ i ] - slope * ( i ) ) ; return setOfLines . size ( ) == 2 ; }
boolean checkForParallel ( int arr [ ] , int n ) { boolean slope1 = isSlopeGood ( arr [ 1 ] - arr [ 0 ] , arr , n ) ; boolean slope2 = isSlopeGood ( arr [ 2 ] - arr [ 1 ] , arr , n ) ; boolean slope3 = isSlopeGood ( ( arr [ 2 ] - arr [ 0 ] ) / 2 , arr , n ) ; return ( slope1 == true slope2 == true slope3 == true ) ; }
long countPaths ( int x1 , int y1 , int x2 , int y2 ) { int m = Math . abs ( x1 - x2 ) ; int n = Math . abs ( y1 - y2 ) ; return ( binomialCoeff ( m + n , n ) ) ; }
Pair < Integer , Integer > findFourthVertex ( int n , int m , String s [ ] ) { HashMap < Integer , Integer > row = new HashMap < > ( ) ; HashMap < Integer , Integer > col = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( s [ i ] . charAt ( j ) == '*' ) { if ( row . containsKey ( i ) ) { row . put ( i , row . get ( i ) + 1 ) ; } else { row . put ( i , 1 ) ; } if ( col . containsKey ( j ) ) { col . put ( j , col . get ( j ) + 1 ) ; } else { col . put ( j , 1 ) ; } } } } int x = 0 , y = 0 ; for ( Map . Entry < Integer , Integer > entry : row . entrySet ( ) ) { if ( entry . getValue ( ) == 1 ) x = entry . getKey ( ) ; } for ( Map . Entry < Integer , Integer > entry : col . entrySet ( ) ) { if ( entry . getValue ( ) == 1 ) y = entry . getKey ( ) ; } Pair < Integer , Integer > ans = new Pair < > ( x + 1 , y + 1 ) ; return ans ; }
float sph ( float r , float R , float h ) { if ( r < 0 && R < 0 && h < 0 ) return - 1 ; float x = r ; float V = ( float ) ( 4 * 3.14f * Math . pow ( r , 3 ) ) / 3 ; return V ; }
float Area ( float a , float b ) { if ( a < 0 && b < 0 ) return - 1 ; float h = ( float ) Math . sqrt ( ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ) ; float A = ( float ) ( 0.70477 * Math . pow ( h , 2 ) ) ; return A ; }
int maxRectangles ( int L , int B , int l , int b ) { int horizontal = 0 , vertical = 0 ; if ( l <= L && b <= B ) { int columns = B / b ; int rows = L / l ; horizontal = rows * columns ; } if ( l <= B && b <= L ) { int columns = L / b ; int rows = B / l ; vertical = rows * columns ; } return Math . max ( horizontal , vertical ) ; }
float cone ( float a ) { if ( a < 0 ) return - 1 ; float r = ( float ) ( a * Math . sqrt ( 2 ) ) / 3 ; float h = ( 2 * a ) / 3 ; float V = ( float ) ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; }
float Area ( float a ) { if ( a < 0 ) return - 1 ; float h = ( float ) 1.268 * a ; float A = ( float ) ( 0.70477 * Math . pow ( h , 2 ) ) ; return A ; }
float Area ( float r ) { if ( r < 0 ) return - 1 ; float x = ( 2 * r ) / ( float ) ( Math . sqrt ( 5 ) ) ; float A = 0.70477f * ( float ) ( Math . pow ( x , 2 ) ) ; return A ; }
float Area ( float a ) { if ( a < 0 ) return - 1 ; float x = 0.464f * a ; float A = 0.70477f * ( float ) Math . pow ( x , 2 ) ; return A ; }
double areaCircle ( double b ) { double area = ( double ) 3.1415926 * b * b ; return area ; }
double areaSquare ( double side , double fold ) { double area = side * side ; return area * 1.0 / Math . pow ( 2 , fold ) ; }
boolean checkOrtho ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int m1 , m2 ; if ( x2 - x1 == 0 && x4 - x3 == 0 ) return false ; else if ( x2 - x1 == 0 ) { m2 = ( y4 - y3 ) / ( x4 - x3 ) ; if ( m2 == 0 ) return true ; else return false ; } else if ( x4 - x3 == 0 ) { m1 = ( y2 - y1 ) / ( x2 - x1 ) ; if ( m1 == 0 ) return true ; else return false ; } else { m1 = ( y2 - y1 ) / ( x2 - x1 ) ; m2 = ( y4 - y3 ) / ( x4 - x3 ) ; if ( m1 * m2 == - 1 ) return true ; else return false ; } }
double square ( double a ) { if ( a < 0 ) return - 1 ; double x = 0.464 * a ; return x ; }
double ReuleauxArea ( double r ) { if ( r < 0 ) return - 1 ; double A = 0.70477 * 2 * Math . pow ( r , 2 ) ; return A ; }
float cyl ( float a ) { if ( a < 0 ) return - 1 ; float r = ( 2 * a * ( float ) ( Math . sqrt ( 2 ) ) / 3 ) ; float h = ( 2 * a ) / 3 ; float V = ( 3.14f * ( float ) ( Math . pow ( r , 2 ) * h ) ) ; return V ; }
double Area ( double l , double b , double h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; double x = ( l * b ) / ( l + b ) ; double A = 0.70477 * Math . pow ( x , 2 ) ; return A ; }
boolean isPossible ( float x , float y , float z ) { float a = x * x + y * y + z * z ; if ( Math . ceil ( a ) == 1 && Math . floor ( a ) == 1 ) return true ; return false ; }
double polyapothem ( double n , double a ) { if ( a < 0 && n < 0 ) return - 1 ; return ( a / ( 2 * java . lang . Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ) ; }
float polydiagonal ( float n , float a ) { if ( a < 0 && n < 0 ) { return - 1 ; } return ( float ) ( 2 * a * Math . sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) ; }
double polyarea ( double n , double r ) { if ( r < 0 && n < 0 ) return - 1 ; double A = ( ( r * r * n ) * Math . sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; }
double decdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.902 * a ; return d ; }
double hexagonside ( double a ) { if ( a < 0 ) return - 1 ; double x = ( 0.5176 * a ) ; return x ; }
float hexagonside ( float a ) { if ( a < 0 ) return - 1 ; float x = a / 3 ; return x ; }
double hexDiagonal ( float a ) { if ( a < 0 ) return - 1 ; double d = ( double ) 1.73 * a ; return d ; }
double pentdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.22 * a ; return d ; }
double ReuleauxArea ( float a ) { if ( a < 0 ) return - 1 ; double A = ( double ) 0.70477 * Math . pow ( a , 2 ) ; return A ; }
double calculateSide ( double n , double r ) { double theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return 2 * r * Math . sin ( theta_in_radians / 2 ) ; }
float squareArea ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) ( Math . pow ( 1.268 , 2 ) * Math . pow ( a , 2 ) ) ; return area ; }
float hexagonArea ( float d ) { return ( float ) ( ( 3 * Math . sqrt ( 3 ) * d * d ) / 8 ) ; }
float cyl ( float r , float R , float h ) { if ( h < 0 && r < 0 && R < 0 ) return - 1 ; float r1 = r ; float h1 = h ; float V = ( float ) ( 3.14 * Math . pow ( r1 , 2 ) * h1 ) ; return V ; }
float findVolume ( float a ) { if ( a < 0 ) return - 1 ; float r = a / 2 ; float h = a ; float V = ( float ) ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; }
double length_rope ( double r ) { return ( ( 2 * PI * r ) + 6 * r ) ; }
float cube ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float a = ( float ) Math . pow ( h , 3 ) ; return a ; }
float sph ( float r , float h ) { if ( r < 0 && h < 0 ) return - 1 ; float R = r ; return R ; }
float cyl ( float R ) { if ( R < 0 ) return - 1 ; float V = ( float ) ( ( 2 * 3.14 * Math . pow ( R , 3 ) ) / ( 3 * Math . sqrt ( 3 ) ) ) ; return V ; }
float rod ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float l = ( float ) ( Math . sqrt ( Math . pow ( h , 2 ) + 4 * Math . pow ( r , 2 ) ) ) ; return l ; }
float coner ( float R ) { if ( R < 0 ) return - 1 ; float r = ( float ) ( 2 * Math . sqrt ( 2 ) * R ) / 3 ; return r ; }
float coneh ( float R ) { if ( R < 0 ) return - 1 ; float h = ( 4 * R ) / 3 ; return h ; }
float coneRadius ( float a ) { if ( a < 0 ) return - 1 ; float r = ( float ) ( a / Math . sqrt ( 2 ) ) ; return r ; }
float coneHeight ( float a ) { if ( a < 0 ) return - 1 ; float h = a ; return h ; }
float largestCube ( float r ) { if ( r < 0 ) return - 1 ; float a = ( 2 * r ) / ( float ) Math . sqrt ( 3 ) ; return a ; }
float sphere ( float a ) { if ( a < 0 ) return - 1 ; float r = a / 2 ; return r ; }
int numberOfCuts ( int M , int N ) { int result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; }
float maxVol ( float P , float A ) { float l = ( float ) ( P - Math . sqrt ( P * P - 24 * A ) ) / 12 ; float V = ( float ) ( l * ( A / 2.0 - l * ( P / 4.0 - l ) ) ) ; return V ; }
int maxArea ( float perimeter ) { int length = ( int ) Math . ceil ( perimeter / 4 ) ; int breadth = ( int ) Math . floor ( perimeter / 4 ) ; return length * breadth ; }
int findSegment ( int n , int m , int [ ] segment_length ) { double meet_point = ( 1.0 * n ) / 2.0 ; int sum = 0 ; int segment_number = 0 ; for ( int i = 0 ; i < m ; i ++ ) { sum += segment_length [ i ] ; if ( ( double ) sum == meet_point ) { segment_number = - 1 ; break ; } if ( sum > meet_point ) { segment_number = i + 1 ; break ; } } return segment_number ; }
long countMaxIntersect ( long n ) { return ( n ) * ( n - 1 ) / 2 ; }
void equation_parabola ( float x1 , float y1 , float a , float b , float c ) { float t = a * a + b * b ; float a1 = t - ( a * a ) ; float b1 = t - ( b * b ) ; float c1 = ( - 2 * t * x1 ) - ( 2 * c * a ) ; float d1 = ( - 2 * t * y1 ) - ( 2 * c * b ) ; float e1 = - 2 * a * b ; float f1 = ( - c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; System . out . println ( "equation of parabola is " + a1 + " x^2 + " + b1 + " y^2 + " + c1 + " x + " + d1 + " y + " + e1 + " xy + " + f1 + " = 0." ) ; }
int countRectangles ( int l , int w ) { int squareSide = __gcd ( l , w ) ; return ( l * w ) / ( squareSide * squareSide ) ; }
void section ( double x1 , double x2 , double y1 , double y2 , double z1 , double z2 , double m , double n ) { double x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) ; double y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) ; double z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) ; System . out . print ( "(" + x + ", " ) ; System . out . print ( y + ", " ) ; System . out . println ( z + ")" ) ; }
int Squares ( int n , int m , int a ) { return ( ( m + a - 1 ) / a ) * ( ( n + a - 1 ) / a ) ; }
float area ( float r ) { return ( float ) ( ( 0.5 ) * ( 3.14 ) * ( r * r ) ) ; }
boolean checkEquilibrium ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 ) { int resx = x1 + x2 + x3 ; int resy = y1 + y2 + y3 ; int resz = z1 + z2 + z3 ; if ( resx == 0 & resy == 0 & resz == 0 ) return true ; else return false ; }
float hexadiagonal ( float a ) { if ( a < 0 ) return - 1 ; return 2 * a ; }
double octadiagonal ( double a ) { if ( a < 0 ) return - 1 ; return a * Math . sqrt ( 4 + ( 2 * Math . sqrt ( 2 ) ) ) ; }
void CalPeri ( ) { int S = 5 , Perimeter ; Perimeter = 10 * S ; System . out . println ( "The Perimeter of Decagon is : " + Perimeter ) ; }
double octaside ( double a ) { if ( a < 0 ) return - 1 ; double s = a / ( Math . sqrt ( 2 ) + 1 ) ; return s ; }
double findEdges ( double s1 , double s2 , double s3 ) { double a = Math . sqrt ( s1 * s2 / s3 ) ; double b = Math . sqrt ( s3 * s1 / s2 ) ; double c = Math . sqrt ( s3 * s2 / s1 ) ; double sum = a + b + c ; return 4 * sum ; }
float findRadiusOfcircumcircle ( float n , float a ) { if ( n < 0 a < 0 ) return - 1 ; float radius = ( float ) ( a / Math . sqrt ( 2 - ( 2 * Math . cos ( 360 / n ) ) ) ) ; return radius ; }
float rhombusarea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; return ( l * b ) / 2 ; }
boolean Arrive ( int a , int b , int n ) { if ( n >= Math . abs ( a ) + Math . abs ( b ) && ( n - ( Math . abs ( a ) + Math . abs ( b ) ) ) % 2 == 0 ) return true ; return false ; }
boolean Move ( int a , int x , int b ) { if ( ( ( ( b - a ) % x == 0 ) || ( ( b - a - 1 ) % x == 0 ) && a + 1 != b ) && b >= a ) return true ; return false ; }
float area ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; float A = a * b ; return A ; }
double circle_inscribed ( int a ) { return PI * ( a * a ) / 12 ; }
float surfaceArea ( float a , float b , float h ) { return 5 * a * b + 5 * b * h ; }
float volume ( float b , float h ) { return ( 5 * b * h ) / 2 ; }
float findRadiusOfcircumcircle ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float radius = ( float ) Math . sqrt ( Math . pow ( l , 2 ) + Math . pow ( b , 2 ) ) / 2 ; return radius ; }
double circlearea ( double a , double b , double c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; double p = ( a + b + c ) / 2 ; double At = Math . sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; double A = 3.14 * Math . pow ( ( ( a * b * c ) / ( 4 * At ) ) , 2 ) ; return A ; }
float altitude ( float a , float b ) { return ( float ) ( Math . sqrt ( Math . pow ( a , 2 ) - ( Math . pow ( b , 2 ) / 4 ) ) ) ; }
int surfaceArea ( int b , int s ) { return 2 * b * s + ( int ) Math . pow ( b , 2 ) ; }
float trianglearea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float area = ( l * b ) / 2 ; return area ; }
float area ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) Math . sqrt ( a ) / 6 ; return area ; }
void halfsquare ( int n , int x , int y ) { int half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) System . out . println ( "NO" ) ; else System . out . println ( "YES" ) ; }
int checkpoint ( int h , int k , int x , int y , int a ) { int p = ( int ) Math . pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ; return p ; }
int checkpoint ( int h , int k , int x , int y , int a , int b ) { int p = ( ( int ) Math . pow ( ( x - h ) , 2 ) / ( int ) Math . pow ( a , 2 ) ) + ( ( int ) Math . pow ( ( y - k ) , 2 ) / ( int ) Math . pow ( b , 2 ) ) ; return p ; }
float area ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { double a = Math . pow ( ( y1 * z2 - y2 * z1 ) , 2 ) + Math . pow ( ( x1 * z2 - x2 * z1 ) , 2 ) + Math . pow ( ( x1 * y2 - x2 * y1 ) , 2 ) ; float area = ( float ) Math . sqrt ( a ) ; area = area / 2 ; return area ; }
float trianglearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; float area = ( float ) ( 3 * Math . sqrt ( 3 ) * Math . pow ( a , 2 ) ) / ( 4 * b ) ; return area ; }
float squarearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; float area = 4 * ( float ) ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ; return area ; }
double longestRodInCuboid ( int length , int breadth , int height ) { double result ; int temp ; temp = length * length + breadth * breadth + height * height ; result = Math . sqrt ( temp ) ; return result ; }
float trianglearea ( float r ) { if ( r < 0 ) return - 1 ; return r * r ; }
float squarearea ( float r ) { if ( r < 0 ) return - 1 ; float a = 4 * ( float ) ( Math . pow ( r , 2 ) / 5 ) ; return a ; }
float rectanglearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; return 2 * a * b ; }
float trapezoidarea ( float r ) { if ( r < 0 ) return - 1 ; float a = ( 3 * ( float ) Math . sqrt ( 3 ) * ( float ) Math . pow ( r , 2 ) ) / 4 ; return a ; }
float squareArea ( float l , float b , float h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; float a = ( l * b ) / ( l + b ) ; return a * a ; }
float circlearea ( double a , double b ) { if ( a < 0 b < 0 ) return - 1 ; float A = ( float ) ( ( 3.14 * Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) / ( 4 * ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) ) ) ; return A ; }
float circlearea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; if ( l < b ) return ( float ) ( 3.14 * Math . pow ( l / 2 , 2 ) ) ; else return ( float ) ( 3.14 * Math . pow ( b / 2 , 2 ) ) ; }
int maxLines ( int n , int x1 [ ] , int y1 [ ] , int x2 [ ] , int y2 [ ] ) { Set < Double > s = new HashSet < Double > ( ) ; double slope ; for ( int i = 0 ; i < n ; ++ i ) { if ( x1 [ i ] == x2 [ i ] ) slope = Integer . MAX_VALUE ; else slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) * 1.0 ; s . add ( slope ) ; } return s . size ( ) ; }
int squares ( int l , int b , int a ) { return ( int ) ( Math . ceil ( l / ( double ) a ) * Math . ceil ( b / ( double ) a ) ) ; }
int gcd ( int a , int b ) { if ( a == 0 b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
int squarearea ( int l , int b ) { if ( l < 0 b < 0 ) return - 1 ; int n = ( l * b ) / gcd ( l , b ) ; return n * n ; }
double angle_triangle ( int x1 , int x2 , int x3 , int y1 , int y2 , int y3 , int z1 , int z2 , int z3 ) { int num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) ; double den = Math . sqrt ( Math . pow ( ( x2 - x1 ) , 2 ) + Math . pow ( ( y2 - y1 ) , 2 ) + Math . pow ( ( z2 - z1 ) , 2 ) ) * Math . sqrt ( Math . pow ( ( x3 - x1 ) , 2 ) + Math . pow ( ( y3 - y1 ) , 2 ) + Math . pow ( ( z3 - z1 ) , 2 ) ) ; double angle = Math . acos ( num / den ) * ( 180.0 / 3.141592653589793238463 ) ; return angle ; }
void is_partition_possible ( int n , int x [ ] , int y [ ] , int w [ ] ) { Map < Integer , Integer > weight_at_x = new HashMap < Integer , Integer > ( ) ; int max_x = ( int ) - 2e3 , min_x = ( int ) 2e3 ; for ( int i = 0 ; i < n ; i ++ ) { int new_x = x [ i ] - y [ i ] ; max_x = Math . max ( max_x , new_x ) ; min_x = Math . min ( min_x , new_x ) ; if ( weight_at_x . containsKey ( new_x ) ) { weight_at_x . put ( new_x , weight_at_x . get ( new_x ) + w [ i ] ) ; } else { weight_at_x . put ( new_x , w [ i ] ) ; } } Vector < Integer > sum_till = new Vector < > ( ) ; sum_till . add ( 0 ) ; for ( int s = min_x ; s <= max_x ; s ++ ) { if ( weight_at_x . get ( s ) == null ) sum_till . add ( sum_till . lastElement ( ) ) ; else sum_till . add ( sum_till . lastElement ( ) + weight_at_x . get ( s ) ) ; } int total_sum = sum_till . lastElement ( ) ; int partition_possible = 0 ; for ( int i = 1 ; i < sum_till . size ( ) ; i ++ ) { if ( sum_till . get ( i ) == total_sum - sum_till . get ( i ) ) partition_possible = 1 ; if ( sum_till . get ( i - 1 ) == total_sum - sum_till . get ( i ) ) partition_possible = 1 ; } System . out . printf ( partition_possible == 1 ? "YES"   :   "NO" ) ; }
void makePolygon ( double a ) { double n = 360 / ( 180 - a ) ; if ( n == ( int ) n ) System . out . println ( "YES" ) ; else System . out . println ( "NO" ) ; }
boolean LiesInsieRectangle ( int a , int b , int x , int y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; }
float area ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { float area = ( float ) Math . sqrt ( Math . pow ( ( y1 * z2 - y2 * z1 ) , 2 ) + Math . pow ( ( x1 * z2 - x2 * z1 ) , 2 ) + Math . pow ( ( x1 * y2 - x2 * y1 ) , 2 ) ) ; return area ; }
void equation_plane ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 , int x , int y , int z ) { int a1 = x2 - x1 ; int b1 = y2 - y1 ; int c1 = z2 - z1 ; int a2 = x3 - x1 ; int b2 = y3 - y1 ; int c2 = z3 - z1 ; int a = b1 * c2 - b2 * c1 ; int b = a2 * c1 - a1 * c2 ; int c = a1 * b2 - b1 * a2 ; int d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) System . out . println ( "Coplanar" ) ; else System . out . println ( "Not Coplanar" ) ; }
int solve ( int M , int N , int s ) { if ( N % s == 0 ) { N = N / s ; } else { N = ( N / s ) + 1 ; } if ( M % s == 0 ) { M = M / s ; } else { M = ( M / s ) + 1 ; } return M * N ; }
int max_intersection ( int center [ ] , int length , int k ) { Arrays . sort ( center ) ; if ( center [ 2 ] - center [ 0 ] >= 2 * k + length ) { return 0 ; } else if ( center [ 2 ] - center [ 0 ] >= 2 * k ) { return ( 2 * k - ( center [ 2 ] - center [ 0 ] - length ) ) ; } else return length ; }
void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = Math . max ( x1 , x3 ) ; int y5 = Math . max ( y1 , y3 ) ; int x6 = Math . min ( x2 , x4 ) ; int y6 = Math . min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { System . out . println ( "No intersection" ) ; return ; } System . out . print ( "(" + x5 + ", " + y5 + ") " ) ; System . out . print ( "(" + x6 + ", " + y6 + ") " ) ; int x7 = x5 ; int y7 = y6 ; System . out . print ( "(" + x7 + ", " + y7 + ") " ) ; int x8 = x6 ; int y8 = y5 ; System . out . print ( "(" + x8 + ", " + y8 + ") " ) ; }
boolean FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; return false ; }
void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) { float x1 , y1 , z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { x1 = y1 = 0 ; z1 = - d1 / c1 ; d = Math . abs ( ( c2 * z1 + d2 ) ) / ( float ) ( Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; System . out . println ( "Perpendicular distance is " + d ) ; } else System . out . println ( "Planes are not parallel" ) ; }
void distance ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { float d = ( a1 * a2 + b1 * b2 + c1 * c2 ) ; float e1 = ( float ) Math . sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; float e2 = ( float ) Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = d / ( e1 * e2 ) ; float pi = ( float ) 3.14159 ; float A = ( 180 / pi ) * ( float ) ( Math . acos ( d ) ) ; System . out . println ( "Angle is " + A + " degree" ) ; }
double haversine ( double lat1 , double lon1 , double lat2 , double lon2 ) { double dLat = Math . toRadians ( lat2 - lat1 ) ; double dLon = Math . toRadians ( lon2 - lon1 ) ; lat1 = Math . toRadians ( lat1 ) ; lat2 = Math . toRadians ( lat2 ) ; double a = Math . pow ( Math . sin ( dLat / 2 ) , 2 ) + Math . pow ( Math . sin ( dLon / 2 ) , 2 ) * Math . cos ( lat1 ) * Math . cos ( lat2 ) ; double rad = 6371 ; double c = 2 * Math . asin ( Math . sqrt ( a ) ) ; return rad * c ; }
void equation_plane ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 ) { float a1 = x2 - x1 ; float b1 = y2 - y1 ; float c1 = z2 - z1 ; float a2 = x3 - x1 ; float b2 = y3 - y1 ; float c2 = z3 - z1 ; float a = b1 * c2 - b2 * c1 ; float b = a2 * c1 - a1 * c2 ; float c = a1 * b2 - b1 * a2 ; float d = ( - a * x1 - b * y1 - c * z1 ) ; System . out . println ( "equation of plane is " + a + " x + " + b + " y + " + c + " z + " + d + " = 0." ) ; }
float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; }
int countNumberOfTriangles ( int n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }
int countRectangles ( int radius ) { int rectangles = 0 ; int diameter = 2 * radius ; int diameterSquare = diameter * diameter ; for ( int a = 1 ; a < 2 * radius ; a ++ ) { for ( int b = 1 ; b < 2 * radius ; b ++ ) { int diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; }
int simi_aaa ( int a1 [ ] , int a2 [ ] ) { Arrays . sort ( a1 ) ; Arrays . sort ( a2 ) ; if ( a1 [ 0 ] == a2 [ 0 ] && a1 [ 1 ] == a2 [ 1 ] && a1 [ 2 ] == a2 [ 2 ] ) return 1 ; else return 0 ; }
int simi_sas ( int s1 [ ] , int s2 [ ] , int a1 [ ] , int a2 [ ] ) { Arrays . sort ( a1 ) ; Arrays . sort ( a2 ) ; Arrays . sort ( s1 ) ; Arrays . sort ( s2 ) ; if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] ) { if ( a1 [ 2 ] == a2 [ 2 ] ) return 1 ; } if ( s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] ) { if ( a1 [ 0 ] == a2 [ 0 ] ) return 1 ; } if ( s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) { if ( a1 [ 1 ] == a2 [ 1 ] ) return 1 ; } return 0 ; }
int simi_sss ( int s1 [ ] , int s2 [ ] ) { Arrays . sort ( s1 ) ; Arrays . sort ( s2 ) ; if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] && s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] && s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) return 1 ; return 0 ; }
long centeredDodecagonal ( long n ) { return 6 * n * ( n - 1 ) + 1 ; }
int heptagonalNumber ( int n ) { return ( ( 5 * n * n ) - ( 3 * n ) ) / 2 ; }
long centeredTridecagonalNum ( long n ) { return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; }
int pentagon_pyramidal ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; }
int pentagon_pyramidal ( int n ) { return n * n * ( n + 1 ) / 2 ; }
boolean checkConcurrent ( int a1 , int b1 , int c1 , int a2 , int b2 , int c2 , int a3 , int b3 , int c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }
int getQuadrant ( int X , int Y , int R , int PX , int PY ) { if ( PX == X && PY == Y ) return 0 ; int val = ( int ) Math . pow ( ( PX - X ) , 2 ) + ( int ) Math . pow ( ( PY - Y ) , 2 ) ; if ( val > Math . pow ( R , 2 ) ) return - 1 ; if ( PX > X && PY >= Y ) return 1 ; if ( PX <= X && PY > Y ) return 2 ; if ( PX < X && PY <= Y ) return 3 ; if ( PX >= X && PY < Y ) return 4 ; return 0 ; }
long center_pentadecagonal_num ( long n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; }
int icosidigonal_num ( int n ) { return ( 20 * n * n - 18 * n ) / 2 ; }
int center_nonadecagon_num ( int n ) { return ( 19 * n * n - 19 * n + 2 ) / 2 ; }
int center_octadecagon_num ( int n ) { return 9 * n * n - 9 * n + 1 ; }
int hendecagonal_num ( int n ) { return ( 9 * n * n - 7 * n ) / 2 ; }
int centereddecagonalnum ( int n ) { return ( 5 * n * n + 5 * n + 1 ) ; }
void Ksmallest ( int x , int y , int k ) { if ( x == 0 && y == 0 ) return ; else if ( x == 0 ) { y -- ; System . out . print ( "V" ) ; Ksmallest ( x , y , k ) ; } else if ( y == 0 ) { x -- ; System . out . print ( "H" ) ; Ksmallest ( x , y , k ) ; } else { if ( factorial ( x - 1 , y ) > k ) { System . out . print ( "H" ) ; Ksmallest ( x - 1 , y , k ) ; } else { System . out . print ( "V" ) ; Ksmallest ( x , y - 1 , k - factorial ( x - 1 , y ) ) ; } } }
int nthEnneadecagonal ( int n ) { return ( 17 * n * n - 15 * n ) / 2 ; }
void inorder ( node root ) { if ( root == null ) return ; inorder ( root . left ) ; System . out . print ( root . data + " " ) ; inorder ( root . right ) ; }
int centered_pentagonal_Num ( int n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; }
void findPoint ( int x1 , int y1 , int x2 , int y2 ) { System . out . println ( "(" + ( int ) ( 2 * x2 - x1 ) + "," + ( int ) ( 2 * y2 - y1 ) + " )" ) ; }
int pivotDis ( int x0 , int y0 , int x1 , int y1 ) { return ( int ) Math . sqrt ( ( x1 - x0 ) * ( x1 - x0 ) + ( y1 - y0 ) * ( y1 - y0 ) ) ; }
int minDis ( int D , int r1 , int r2 ) { return Math . max ( ( D - r1 - r2 ) , 0 ) ; }
int maxDis ( int D , int r1 , int r2 ) { return D + r1 + r2 ; }
double findPCSlope ( double m ) { return - 1.0 / m ; }
void otherEndPoint ( int x1 , int y1 , int m1 , int m2 ) { float x2 = ( float ) ( 2 * m1 - x1 ) ; float y2 = ( float ) ( 2 * m2 - y1 ) ; System . out . println ( "x2 = " + x2 + ", " + "y2 = " + y2 ) ; }
boolean isValid ( int [ ] arr , int i , int j , int m , int c ) { if ( i == j ) return false ; int lhs = arr [ j ] ; int rhs = m * arr [ i ] + c ; return ( lhs == rhs ) ; }
int findOrderedPoints ( int [ ] arr , int n , int m , int c ) { int counter = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int firstIndex = i , secondIndex = j ; if ( isValid ( arr , firstIndex , secondIndex , m , c ) ) counter ++ ; } } return counter ; }
int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
int overlappingArea ( Point l1 , Point r1 , Point l2 , Point r2 ) { int area1 = Math . abs ( l1 . x - r1 . x ) * Math . abs ( l1 . y - r1 . y ) ; int area2 = Math . abs ( l2 . x - r2 . x ) * Math . abs ( l2 . y - r2 . y ) ; int x_dist = ( Math . min ( r1 . x , r2 . x ) - Math . max ( l1 . x , l2 . x )  ; int y_dist = ( Math . min ( r1 . y , r2 . y ) - Math . max ( l1 . y , l2 . y )  ; int areaI = 0 ; if ( x_dist > 0 && y_dist > 0 ) { areaI = x_dist * y_dist ; } return ( area1 + area2 - areaI ) ; }
boolean checkOrigin ( int x1 , int y1 , int x2 , int y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; }
boolean checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { int dis = ( int ) Math . sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }
float areacircumscribed ( float a ) { float PI = 3.14159265f ; return ( a * a * ( PI / 2 ) ) ; }
double surface_area_octahedron ( double side ) { return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ; }
int find_Area ( int r ) { return ( 2 * r * r ) ; }
int checkValidity ( int a , int b , int c ) { if ( a + b <= c a + c <= b b + c <= a ) return 0 ; else return 1 ; }
boolean isRectangle ( int a , int b , int c , int d ) { if ( a == b && a == c && a == d && c == d && b == c && b == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; }
int nCk ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
int count_Straightlines ( int n , int m ) { return ( nCk ( n , 2 ) - nCk ( m , 2 ) + 1 ) ; }
boolean isBetween ( int a , int b , int c ) { return ( Math . min ( a , b ) <= c && c <= Math . max ( a , b ) ) ; }
boolean canJoin ( int x [ ] , int y [ ] , int i , int j , int k ) { return ( x [ k ] == x [ i ] x [ k ] == x [ j ] ) && isBetween ( y [ i ] , y [ j ] , y [ k ] ) || ( y [ k ] == y [ i ] y [ k ] == y [ j ] ) && isBetween ( x [ i ] , x [ j ] , x [ k ] ) ; }
int countLineSegments ( int x [ ] , int y [ ] ) { if ( ( x [ 0 ] == x [ 1 ] && x [ 1 ] == x [ 2 ] ) || ( y [ 0 ] == y [ 1 ] && y [ 1 ] == y [ 2 ] ) ) return 1 ; else if ( canJoin ( x , y , 0 , 1 , 2 ) || canJoin ( x , y , 0 , 2 , 1 ) || canJoin ( x , y , 1 , 2 , 0 ) ) return 2 ; else return 3 ; }
double vol_of_dodecahedron ( int side ) { return ( ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( Math . pow ( side , 3 ) ) ) ; }
int perimeter ( int diameter , int height ) { return 2 * ( diameter + height ) ; }
float area_of_segment ( float radius , float angle ) { float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * ( float ) Math . sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; }
void midpoint ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( x1 + x2 ) / 2 + " , " + ( y1 + y2 ) / 2 ) ; }
int contribution_height ( int current , int previous ) { return Math . abs ( current - previous ) ; }
int surfaceArea ( int A [ ] [ ] ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int up = 0 ; int left = 0 ; if ( i > 0 ) up = A [ i - 1 ] [ j ] ; if ( j > 0 ) left = A [ i ] [ j - 1 ] ; ans += contribution_height ( A [ i ] [ j ] , up ) + contribution_height ( A [ i ] [ j ] , left ) ; if ( i == N - 1 ) ans += A [ i ] [ j ] ; if ( j == M - 1 ) ans += A [ i ] [ j ] ; } } ans += N * M * 2 ; return ans ; }
double area_of_tetrahedron ( int side ) { return ( Math . sqrt ( 3 ) * ( side * side ) ) ; }
double vol_tetra ( int side ) { double volume = ( Math . pow ( side , 3 ) / ( 6 * Math . sqrt ( 2 ) ) ) ; return volume ; }
void overflow ( int H , int r , int h , int N , int R ) { double tank_cap = 3.14 * r * r * H ; double water_vol = 3.14 * r * r * h ; double balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; double vol = water_vol + balls_vol ; if ( vol > tank_cap ) { System . out . println ( "Overflow" ) ; } else { System . out . println ( "Not in overflow state" ) ; } }
float volume ( int radius , int height ) { return ( ( 22 / 7 ) * radius * radius * height ) ; }
int maxvolume ( int s ) { int maxvalue = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; maxvalue = Math . max ( maxvalue , i * j * k ) ; } } return maxvalue ; }
int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; }
float volumeOfEllipsoid ( float r1 , float r2 , float r3 ) { float pi = ( float ) 3.14 ; return ( float ) 1.33 * pi * r1 * r2 * r3 ; }
float slope ( float x1 , float y1 , float x2 , float y2 ) { if ( x1 == x2 ) return Integer . MAX_VALUE ; return ( y2 - y1 ) / ( x2 - x1 ) ; }
float cal_cos ( float n ) { float accuracy = 0.0001f , x1 ; float denominator , cosx , cosval ; n = n * ( 3.142f / 180.0f ) ; x1 = 1 ; cosx = x1 ; cosval = ( float ) Math . cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= Math . abs ( cosval - cosx ) ) ; return cosx ; }
float third_side ( int a , int b , float c ) { float angle = cal_cos ( c ) ; return ( float ) Math . sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) ; }
float volumeTriangular ( int a , int b , int h ) { float vol = ( float ) ( 0.1666 ) * a * b * h ; return vol ; }
float volumeSquare ( int b , int h ) { float vol = ( float ) ( 0.33 ) * b * b * h ; return vol ; }
float volumePentagonal ( int a , int b , int h ) { float vol = ( float ) ( 0.83 ) * a * b * h ; return vol ; }
float volumeHexagonal ( int a , int b , int h ) { float vol = ( float ) a * b * h ; return vol ; }
double areaOctagon ( double side ) { return ( float ) ( 2 * ( 1 + Math . sqrt ( 2 ) ) * side * side ) ; }
double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; }
double hexagonArea ( double s ) { return ( ( 3 * Math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ; }
int findCommon ( int mat [ ] [ ] ) { int column [ ] = new int [ M ] ; int min_row ; int i ; for ( i = 0 ; i < M ; i ++ ) column [ i ] = N - 1 ; min_row = 0 ; while ( column [ min_row ] >= 0 ) { for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) min_row = i ; } int eq_count = 0 ; for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) { if ( column [ i ] == 0 ) return - 1 ; column [ i ] -= 1 ; } else eq_count ++ ; } if ( eq_count == M ) return mat [ min_row ] [ column [ min_row ] ] ; } return - 1 ; }
int Circumference ( int a ) { return 4 * a ; }
double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { System . out . println ( "Angle cannot" + " be formed" ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }
void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) System . out . println ( "Angle not possible" ) ; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; System . out . println ( sector ) ; } }
int findCommon ( int mat [ ] [ ] ) { HashMap < Integer , Integer > cnt = new HashMap < Integer , Integer > ( ) ; int i , j ; for ( i = 0 ; i < M ; i ++ ) { if ( cnt . containsKey ( mat [ i ] [ 0 ] ) ) { cnt . put ( mat [ i ] [ 0 ] , cnt . get ( mat [ i ] [ 0 ] ) + 1 ) ; } else { cnt . put ( mat [ i ] [ 0 ] , 1 ) ; } for ( j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) if ( cnt . containsKey ( mat [ i ] [ j ] ) ) { cnt . put ( mat [ i ] [ j ] , cnt . get ( mat [ i ] [ j ] ) + 1 ) ; } else { cnt . put ( mat [ i ] [ j ] , 1 ) ; } } } for ( Map . Entry < Integer , Integer > ele : cnt . entrySet ( ) ) { if ( ele . getValue ( ) == M ) return ele . getKey ( ) ; } return - 1 ; }
double surfaceAreaCuboid ( double l , double h , double w ) { return ( 2 * l * w + 2 * w * h + 2 * l * h ) ; }
double surfaceCube ( double a ) { return ( 6 * a * a ) ; }
int minRadius ( int k , int [ ] x , int [ ] y , int n ) { int [ ] dis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; Arrays . sort ( dis ) ; return dis [ k - 1 ] ; }
int areaRectangle ( int a , int b ) { int area = a * b ; return area ; }
int perimeterRectangle ( int a , int b ) { int perimeter = 2 * ( a + b ) ; return perimeter ; }
int areaSquare ( int side ) { int area = side * side ; return area ; }
int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; }
long minPerimeter ( int n ) { int l = ( int ) Math . sqrt ( n ) ; int sq = l * l ; if ( sq == n ) return l * 4 ; else { long row = n / l ; long perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }
void checkCollision ( int a , int b , int c , int x , int y , int radius ) { double dist = ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ; if ( radius == dist ) System . out . println ( "Touch" ) ; else if ( radius > dist ) System . out . println ( "Intersect" ) ; else System . out . println ( "Outside" ) ; }
void possibleOrNot ( long a1 , long a2 , long b1 , long b2 , long c1 , long c2 ) { long dis1 = ( long ) Math . pow ( b1 - a1 , 2 ) + ( long ) Math . pow ( b2 - a2 , 2 ) ; long dis2 = ( long ) Math . pow ( c1 - b1 , 2 ) + ( long ) Math . pow ( c2 - b2 , 2 ) ; if ( dis1 != dis2 ) System . out . print ( "No" ) ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) System . out . print ( "No" ) ; else System . out . print ( "Yes" ) ; }
void replaceSurrounded ( char mat [ ] [ ] ) { for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] == 'O' ) mat [ i ] [ j ] = '-' ; for ( int i = 0 ; i < M ; i ++ ) if ( mat [ i ] [ 0 ] == '-' ) floodFillUtil ( mat , i , 0 , '-' , 'O' ) ; for ( int i = 0 ; i < M ; i ++ ) if ( mat [ i ] [ N - 1 ] == '-' ) floodFillUtil ( mat , i , N - 1 , '-' , 'O' ) ; for ( int i = 0 ; i < N ; i ++ ) if ( mat [ 0 ] [ i ] == '-' ) floodFillUtil ( mat , 0 , i , '-' , 'O' ) ; for ( int i = 0 ; i < N ; i ++ ) if ( mat [ M - 1 ] [ i ] == '-' ) floodFillUtil ( mat , M - 1 , i , '-' , 'O' ) ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] == '-' ) mat [ i ] [ j ] = 'X' ; }
void fitOrNotFit ( int R , int r , int x , int y , int rad ) { double val = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) System . out . println ( "Fits" ) ; else System . out . println ( "Doesn't Fit" ) ; }
boolean check ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 , int x , int y ) { float A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) + area ( x1 , y1 , x4 , y4 , x3 , y3 ) ; float A1 = area ( x , y , x1 , y1 , x2 , y2 ) ; float A2 = area ( x , y , x2 , y2 , x3 , y3 ) ; float A3 = area ( x , y , x3 , y3 , x4 , y4 ) ; float A4 = area ( x , y , x1 , y1 , x4 , y4 ) ; return ( A == A1 + A2 + A3 + A4 ) ; }
long rectCount ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; }
int countObtuseAngles ( int a , int b , int k ) { int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return min ( c1 , c2 ) ; }
int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= Math . sqrt ( n ) ; ++ length ) for ( int height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }
void isPolygonPossible ( int arr [ ] , int N ) { int limit = ( int ) Math . sqrt ( N ) ; for ( int i = 1 ; i <= limit ; i ++ ) { if ( N % i == 0 ) { if ( checkPolygonWithMidpoints ( arr , N , i ) || checkPolygonWithMidpoints ( arr , N , ( N / i ) ) ) return ; } } System . out . println ( "Not possible" ) ; }
double minRevolutions ( double r , int x1 , int y1 , int x2 , int y2 ) { double d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . ceil ( d / ( 2 * r ) ) ; }
boolean inside ( ArrayList < ArrayList < Integer > > A , ArrayList < Integer > p ) { ArrayList < Integer > mid = new ArrayList < Integer > ( Arrays . asList ( 0 , 0 ) ) ; int n = A . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mid . set ( 0 , mid . get ( 0 ) + A . get ( i ) . get ( 0 ) ) ; mid . set ( 1 , mid . get ( 1 ) + A . get ( i ) . get ( 1 ) ) ; } for ( int i = 0 , j ; i < n ; i ++ ) { j = ( i + 1 ) % n ; int x1 = A . get ( i ) . get ( 0 ) * n , x2 = A . get ( j ) . get ( 0 ) * n ; int y1 = A . get ( i ) . get ( 1 ) * n , y2 = A . get ( j ) . get ( 1 ) * n ; int a1 = y1 - y2 ; int b1 = x2 - x1 ; int c1 = x1 * y2 - y1 * x2 ; int for_mid = a1 * mid . get ( 0 ) + b1 * mid . get ( 1 ) + c1 ; int for_p = a1 * p . get ( 0 ) * n + b1 * p . get ( 1 ) * n + c1 ; if ( for_mid * for_p < 0 ) return false ; } return true ; }
void addPoint ( ArrayList < ArrayList < Integer > > a , ArrayList < Integer > p ) { if ( inside ( a , p ) ) return ; int ind = 0 ; int n = a . size ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( sqDist ( p , a . get ( i ) ) < sqDist ( p , a . get ( ind ) ) ) { ind = i ; } } int up = ind ; while ( orientation ( p , a . get ( up ) , a . get ( ( up + 1 ) % n ) ) >= 0 ) up = ( up + 1 ) % n ; int low = ind ; while ( orientation ( p , a . get ( low ) , a . get ( ( n + low - 1 ) % n ) ) <= 0 ) low = ( n + low - 1 ) % n ; ArrayList < ArrayList < Integer > > ret = new ArrayList < ArrayList < Integer > > ( ) ; int curr = up ; ret . add ( a . get ( curr ) ) ; while ( curr != low ) { curr = ( curr + 1 ) % n ; ret . add ( a . get ( curr ) ) ; } ret . add ( p ) ; a . clear ( ) ; for ( int i = 0 ; i < ret . size ( ) ; i ++ ) { a . add ( ret . get ( i ) ) ; } }
int getDistance ( int x1 , int y1 , int x2 , int y2 ) { return ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ; }
int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = Math . floorDiv ( base , 2 ) ; return base * ( base + 1 ) / 2 ; }
int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
void preprocess ( int p [ ] , int x [ ] , int y [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) p [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; Arrays . sort ( p ) ; }
int query ( int p [ ] , int n , int rad ) { int start = 0 , end = n - 1 ; while ( ( end - start ) > 1 ) { int mid = ( start + end ) / 2 ; double tp = Math . sqrt ( p [ mid ] ) ; if ( tp > ( rad * 1.0 ) ) end = mid - 1 ; else start = mid ; } double tp1 = Math . sqrt ( p [ start ] ) ; double tp2 = Math . sqrt ( p [ end ] ) ; if ( tp1 > ( rad * 1.0 ) ) return 0 ; else if ( tp2 <= ( rad * 1.0 ) ) return end + 1 ; else return start + 1 ; }
double getArea ( double base , double hypotenuse ) { double height = Math . sqrt ( hypotenuse * hypotenuse - base * base ) ; return 0.5 * base * height ; }
void printRightAngleTriangle ( int hypotenuse , int area ) { int hsquare = hypotenuse * hypotenuse ; double sideForMaxArea = Math . sqrt ( hsquare / 2.0 ) ; double maxArea = getArea ( sideForMaxArea , hypotenuse ) ; if ( area > maxArea ) { System . out . print ( "Not possible" ) ; return ; } double low = 0.0 ; double high = sideForMaxArea ; double base = 0 ; while ( Math . abs ( high - low ) > eps ) { base = ( low + high ) / 2.0 ; if ( getArea ( base , hypotenuse ) >= area ) { high = base ; } else { low = base ; } } double height = Math . sqrt ( hsquare - base * base ) ; System . out . println ( Math . round ( base ) + " " + Math . round ( height ) ) ; }
float squareRoot ( float n ) { float x = n ; float y = 1 ; float e = 0.000001f ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }
int findMaximumHeight ( int N ) { int n = 1 + 8 * N ; int maxH = ( int ) ( - 1 + squareRoot ( n ) ) / 2 ; return maxH ; }
double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int getCount ( Point p , Point q ) { if ( p . x == q . x ) return Math . abs ( p . y - q . y ) - 1 ; if ( p . y == q . y ) return Math . abs ( p . x - q . x ) - 1 ; return gcd ( Math . abs ( p . x - q . x ) , Math . abs ( p . y - q . y ) ) - 1 ; }
int getMinSteps ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int min = dp [ i - 1 ] ; if ( i % 2 == 0 ) { min = Math . min ( min , dp [ i / 2 ] ) ; } if ( i % 3 == 0 ) { min = Math . min ( min , dp [ i / 3 ] ) ; } dp [ i ] = min + 1 ; } return dp [ n ] ; }
int distSq ( Point p , Point q ) { return ( p . x - q . x ) * ( p . x - q . x ) + ( p . y - q . y ) * ( p . y - q . y ) ; }
double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; }
void youngify ( int mat [ ] [ ] , int i , int j ) { int downVal = ( i + 1 < N ) ? mat [ i + 1 ] [ j ] : INF ; int rightVal = ( j + 1 < N ) ? mat [ i ] [ j + 1 ] : INF ; if ( downVal == INF && rightVal == INF ) { return ; } if ( downVal < rightVal ) { mat [ i ] [ j ] = downVal ; mat [ i + 1 ] [ j ] = INF ; youngify ( mat , i + 1 , j ) ; } else { mat [ i ] [ j ] = rightVal ; mat [ i ] [ j + 1 ] = INF ; youngify ( mat , i , j + 1 ) ; } }
int extractMin ( int mat [ ] [ ] ) { int ret = mat [ 0 ] [ 0 ] ; mat [ 0 ] [ 0 ] = INF ; youngify ( mat , 0 , 0 ) ; return ret ; }
void printSorted ( int mat [ ] [ ] ) { System . out . println ( "Elements of matrix in sorted order n" ) ; for ( int i = 0 ; i < N * N ; i ++ ) { System . out . print ( extractMin ( mat ) + " " ) ; } }
double f ( double x , int p , double num ) { return Math . pow ( x , p ) - num ; }
double f_prime ( double x , int p ) { return p * Math . pow ( x , p - 1 ) ; }
int minimumAdditionOperation ( int N ) { int count = 0 ; while ( N > 0 ) { if ( N % 2 == 1 ) { count ++ ; } N = N >> 1 ; } return count ; }
int minimumOperations ( int arr [ ] , int N ) { int mini = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; while ( arr [ i ] % 2 == 0 ) { arr [ i ] = arr [ i ] / 2 ; count ++ ; } if ( mini > count ) { mini = count ; } } return mini ; }
int minimumSizeArr ( int A , int B ) { int currXor = 0 ; int reminder = ( A - 1 ) % 4 ; if ( reminder == 0 ) currXor = A - 1 ; else if ( reminder == 1 ) currXor = 1 ; else if ( reminder == 2 ) currXor = A ; int minSize = A ; if ( currXor == B ) return minSize ; else if ( ( currXor ^ B ) == A ) return minSize + 2 ; else return minSize + 1 ; }
void modifiedSieve ( ) { for ( int i = 0 ; i < maxn ; i ++ ) gpf [ i ] = 0 ; gpf [ 0 ] = 0 ; gpf [ 1 ] = 1 ; for ( int i = 2 ; i < maxn ; i ++ ) { if ( gpf [ i ] > 0 ) continue ; for ( int j = i ; j < maxn ; j += i ) { gpf [ j ] = Math . max ( i , gpf [ j ] ) ; } } }
int greatestValidInt ( int N ) { modifiedSieve ( ) ; for ( int i = N ; i > 0 ; i -- ) { if ( gpf [ i ] > Math . sqrt ( i ) ) { return i ; } } return - 1 ; }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < ( int ) 1e4 + 2 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < ( int ) 1e4 + 2 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i < ( int ) 1e4 + 2 ; i += p ) prime [ i ] = false ; } } }
int countMin ( int [ ] arr , int n ) { int cMinSwaps = 0 ; int cPrimeIndices = 0 ; int cPrimeNos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ i + 1 ] ) { cPrimeIndices ++ ; if ( prime [ arr [ i ] ] == false ) cMinSwaps ++ ; else cPrimeNos ++ ; } else if ( prime [ arr [ i ] ] ) { cPrimeNos ++ ; } } if ( cPrimeNos >= cPrimeIndices ) return cMinSwaps ; else return - 1 ; }
double subfactorial ( int N ) { double res = 0 , fact = 1 ; int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = fact * i ; if ( count % 2 == 0 ) res = res - ( 1 / fact ) ; else res = res + ( 1 / fact ) ; count ++ ; } return fact * ( 1 + res ) ; }
int minOperations ( int A [ ] , int B [ ] , int N ) { int cnt = 0 ; int i = 0 ; while ( i < N ) { int j = 0 ; while ( j < N && i < N ) { if ( B [ i ] == A [ j ] ) { i ++ ; } j ++ ; } cnt ++ ; } return cnt ; }
int countPairs ( int N ) { int res = 0 ; for ( int q = 1 ; q * q <= N ; q ++ ) { int maxP = Math . min ( 2 * N - q , N / q ) ; if ( maxP < q ) continue ; int cnt = maxP - q + 1 ; res += ( cnt / 2 + ( cnt & 1 ) ) ; } return res ; }
void largestSubset ( int a [ ] , int N ) { int bit [ ] = new int [ 32 ] ; for ( int i = 0 ; i < N ; i ++ ) { int x = 31 ; while ( a [ i ] > 0 ) { if ( ( int ) ( a [ i ] & 1 ) == ( int ) 1 ) { bit [ x ] ++ ; } a [ i ] = a [ i ] >> 1 ; x -- ; } } int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < 32 ; i ++ ) { max = Math . max ( max , bit [ i ] ) ; } System . out . println ( max ) ; }
int countDistinctSums ( int N , int L , int R ) { int minSum = L * N ; int maxSum = R * N ; return maxSum - minSum + 1 ; }
void setSumtoZero ( double arr [ ] , int N ) { int [ ] A = new int [ N ] ; int sum = 0 ; int m = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { sum += Math . ceil ( arr [ i ] ) ; A [ i ] = ( int ) Math . ceil ( arr [ i ] ) ; } if ( sum > 0 ) { m = Math . min ( sum , N ) ; for ( int i = 0 ; i < N && m > 0 ; i ++ ) { A [ i ] = ( int ) Math . floor ( arr [ i ] ) ; if ( A [ i ] != Math . floor ( arr [ i ] ) ) m -- ; } } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( A [ i ] + " " ) ; } }
int countDivisors ( int n ) { int divisors = 0 ; int i ; for ( i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) { divisors ++ ; } } if ( i - ( n / i ) == 1 ) { i -- ; } for ( ; i >= 1 ; i -- ) { if ( n % i == 0 ) { divisors ++ ; } } return divisors ; }
int possibleTriplets ( int N ) { int count = 0 ; for ( int i = 1 ; i < N ; i ++ ) { count += countDivisors ( N - i ) ; } return count ; }
long convertToBase9 ( long n ) { long ans = 0 ; long a = 1 ; while ( n > 0 ) { ans += ( a * ( n % 9 ) ) ; a *= 10 ; n /= 9 ; } return ans ; }
long getNthnumber ( long base9 , long K ) { long ans = 0 ; long a = 1 ; while ( base9 > 0 ) { int cur = ( int ) ( base9 % 10 ) ; if ( cur >= K ) { ans += a * ( cur + 1 ) ; } else { ans += a * cur ; } base9 /= 10 ; a *= 10 ; } return ans ; }
int UniqueGeometricTerms ( int N , int a1 , int r1 , int a2 , int r2 ) { HashSet < Integer > S = new HashSet < Integer > ( ) ; int p1 = a1 ; for ( int i = 0 ; i < N ; i ++ ) { S . add ( p1 ) ; p1 = ( p1 * r1 ) ; } int p2 = a2 ; for ( int i = 0 ; i < N ; i ++ ) { S . add ( p2 ) ; p2 = ( p2 * r2 ) ; } return S . size ( ) ; }
void nearestLeft ( int arr [ ] , int N , int [ ] steps ) { int L = - N ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { L = - ( N - i ) ; break ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { L = i ; } steps [ i ] = i - L ; } }
int findSum ( int arr [ ] , int N , int M , int K ) { int [ ] steps = new int [ N ] ; int sum = accumulate ( arr , 0 , N ) ; if ( sum == 0 ) { return 0 ; } nearestLeft ( arr , N , steps ) ; nearestRight ( arr , N , steps ) ; for ( int i = 0 ; i < N ; i ++ ) sum += 2 * K * Math . max ( 0 , M - steps [ i ] ) ; return sum ; }
int countPairs ( int L , int R ) { int cntPair = 0 ; for ( int a = L ; a <= R ; a ++ ) { for ( int b = a + 1 ; b <= R ; b ++ ) { int x = getProduct ( a ) ; int y = getProduct ( b ) ; if ( x != 0 && y != 0 && ( a * y ) == ( b * x ) ) { cntPair ++ ; } } } return cntPair ; }
int maxSum ( int [ ] [ ] matrix ) { int r = matrix . length ; int c = matrix [ 0 ] . length ; int sum = 0 ; int mini = Integer . MAX_VALUE ; int count = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { int k = matrix [ i ] [ j ] ; mini = Math . min ( mini , Math . abs ( k ) ) ; if ( k < 0 ) count ++ ; sum += Math . abs ( k ) ; } } if ( count % 2 == 0 ) { return sum ; } else { return ( sum - 2 * mini ) ; } }
int highestPowerof2 ( int n ) { int p = ( int ) Math . floor ( Math . log ( n ) / Math . log ( 2.0 ) ) ; if ( p % 2 == 0 ) p -= 1 ; int result = ( int ) ( Math . pow ( 2 , p ) ) ; return result ; }
int minStep ( int N , int X ) { if ( N % 2 != 0 && X == 0 ) return - 1 ; int size = 0 ; while ( X < N ) { N -= highestPowerof2 ( N ) ; size += 1 ; } if ( N != 0 ) size += 1 ; return size ; }
void transpose ( int A [ ] [ ] , int B [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; }
int canPossibleReplacement ( int N , int [ ] arr ) { int S = 0 ; int i ; for ( i = 0 ; i < arr . length ; i ++ ) S += arr [ i ] ; int P = 1 ; for ( i = 0 ; i < arr . length ; i ++ ) { P *= i ; } for ( int x : arr ) { int y = ( S - x ) / ( P / x - 1 ) ; if ( ( S - x + y ) == ( P * y ) / x ) return 1 ; } return 0 ; }
int positionAfterKJumps ( int X , int Y , int K ) { int addY = Y * ( K / 2 ) ; int reduceX = - 1 * X * ( K / 2 + K % 2 ) ; return addY + reduceX ; }
void predictTheWinner ( int K , int N ) { if ( N % ( K + 1 ) == 0 ) System . out . println ( "Bob" ) ; else System . out . println ( "Alice" ) ; }
void countTriplets ( int size , int queries , int [ ] arr , int [ ] [ ] Q ) { int [ ] arr_even = new int [ size + 1 ] ; int [ ] arr_odd = new int [ size + 1 ] ; int even = 0 ; int odd = 0 ; arr_even [ 0 ] = 0 ; arr_odd [ 0 ] = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd ++ ; } else { even ++ ; } arr_even [ i + 1 ] = even ; arr_odd [ i + 1 ] = odd ; } for ( int i = 0 ; i < queries ; i ++ ) { int l = Q [ i ] [ 0 ] , r = Q [ i ] [ 1 ] ; odd = arr_odd [ r ] - arr_odd [ l - 1 ] ; even = arr_even [ r ] - arr_even [ l - 1 ] ; int ans = ( even * ( even - 1 ) * ( even - 2 ) ) / 6 + ( odd * ( odd - 1 ) / 2 ) * even ; System . out . print ( ans + " " ) ; } }
void transpose ( int A [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) { int temp = A [ i ] [ j ] ; A [ i ] [ j ] = A [ j ] [ i ] ; A [ j ] [ i ] = temp ; } }
int findMaxK ( int N ) { int K = N ; for ( int i = N - 1 ; i >= 0 ; i -- ) { K &= i ; if ( K == 0 ) { return i ; } } return 0 ; }
int countPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( arr [ j ] % arr [ i ] == 0 ) && ( j + 1 ) % ( i + 1 ) == 0 && ( arr [ j ] / arr [ i ] == ( j + 1 ) / ( i + 1 ) ) ) { count ++ ; } } } return count ; }
int smallestMaximum ( int N , int K ) { int sum = ( ( N + K - 1 ) / K ) * K ; if ( sum % N != 0 ) return ( sum / N ) + 1 ; else return sum / N ; }
int findMinMax ( int [ ] a ) { int min_val = 1000000000 ; for ( int i = 1 ; i < a . length ; ++ i ) { min_val = Math . min ( min_val , a [ i ] * a [ i - 1 ] ) ; } return min_val ; }
void add ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; }
int nCr ( int n , int r , int f [ ] ) { if ( n < r ) { return 0 ; } return f [ n ] / ( f [ r ] * f [ n - r ] ) ; }
int Min_sum ( int arr [ ] , int N ) { int min_sum = 1000000 , maxGcd = 1 ; for ( int i = 0 ; i < N ; i ++ ) { int gcd ; if ( i == 0 ) gcd = arr [ 1 ] ; else { gcd = arr [ i - 1 ] ; } for ( int j = 0 ; j < N ; j ++ ) { if ( j != i ) gcd = gcdOfTwoNos ( gcd , arr [ j ] ) ; } int c = arr [ i ] ; if ( gcd > maxGcd ) maxGcd = gcd ; } return maxGcd ; }
void performQuery ( int arr [ ] , int Q [ ] [ ] ) { for ( int i = 0 ; i < Q . length ; i ++ ) { int or = 0 ; int x = Q [ i ] [ 0 ] ; arr [ x - 1 ] = Q [ i ] [ 1 ] ; for ( int j = 0 ; j < arr . length ; j ++ ) { or = or | arr [ j ] ; } System . out . print ( or + " " ) ; } }
void subtract ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; }
int countOddIntegers ( int arr [ ] , int N ) { int Fact [ ] = new int [ N ] ; Fact [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { Fact [ i ] = i * Fact [ i - 1 ] ; } int freq [ ] = new int [ 10 ] ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } int ans = 0 ; for ( int i = 1 ; i <= 9 ; i += 2 ) { if ( freq [ i ] == 0 ) continue ; freq [ i ] -- ; for ( int j = 1 ; j <= 9 ; j ++ ) { int cur_ans = 0 ; if ( freq [ j ] == 0 ) { continue ; } freq [ j ] -- ; cur_ans = Fact [ N - 2 ] ; for ( int k = 0 ; k <= 9 ; k ++ ) { cur_ans = cur_ans / Fact [ freq [ k ] ] ; } ans += cur_ans ; freq [ j ] ++ ; } freq [ i ] ++ ; } return ans ; }
int intCount ( int X , int K ) { int ans = 0 ; for ( int z = 0 ; z < Math . pow ( 10 , K ) ; z += ( Math . pow ( 10 , K ) - 1 ) / 9 ) { if ( z > X ) break ; ans += ( ( X - z ) / Math . pow ( 10 , K ) + 1 ) ; } return ans ; }
int intCountInRange ( int L , int R , int K ) { return ( intCount ( R , K ) - intCount ( L - 1 , K ) ) ; }
void findSum ( TreeNode root , int target , int K ) { sum = 0 ; kDistanceSum ( root , target , K ) ; System . out . print ( sum ) ; }
int CountPair ( int arr [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int val = arr [ i ] + sumOfDigits ( arr [ i ] ) ; if ( mp . containsKey ( val ) ) { mp . put ( val , mp . get ( val ) + 1 ) ; } else { mp . put ( val , 1 ) ; } } int count = 0 ; for ( Map . Entry < Integer , Integer > x : mp . entrySet ( ) ) { int val = x . getKey ( ) ; int times = x . getValue ( ) ; count += ( ( times * ( times - 1 ) ) / 2 ) ; } return count ; }
boolean isValid ( int x , int y1 , int y2 ) { return ( x >= 0 && x < R && y1 >= 0 && y1 < C && y2 >= 0 && y2 < C ) ; }
int getMaxUtil ( int arr [ ] [ ] , int mem [ ] [ ] [ ] , int x , int y1 , int y2 ) { if ( ! isValid ( x , y1 , y2 ) ) return Integer . MIN_VALUE ; if ( x == R - 1 && y1 == 0 && y2 == C - 1 ) return ( y1 == y2 ) ? arr [ x ] [ y1 ] : arr [ x ] [ y1 ] + arr [ x ] [ y2 ] ; if ( x == R - 1 ) return Integer . MIN_VALUE ; if ( mem [ x ] [ y1 ] [ y2 ] != - 1 ) return mem [ x ] [ y1 ] [ y2 ] ; int ans = Integer . MIN_VALUE ; int temp = ( y1 == y2 ) ? arr [ x ] [ y1 ] : arr [ x ] [ y1 ] + arr [ x ] [ y2 ] ; ans = Math . max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 , y2 - 1 ) ) ; ans = Math . max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 , y2 + 1 ) ) ; ans = Math . max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 , y2 ) ) ; ans = Math . max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 - 1 , y2 ) ) ; ans = Math . max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 - 1 , y2 - 1 ) ) ; ans = Math . max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 - 1 , y2 + 1 ) ) ; ans = Math . max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 + 1 , y2 ) ) ; ans = Math . max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 + 1 , y2 - 1 ) ) ; ans = Math . max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 + 1 , y2 + 1 ) ) ; return ( mem [ x ] [ y1 ] [ y2 ] = ans ) ; }
int geMaxCollection ( int arr [ ] [ ] ) { int [ ] [ ] [ ] mem = new int [ R ] [ C ] [ C ] ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { for ( int l = 0 ; l < C ; l ++ ) mem [ i ] [ j ] [ l ] = - 1 ; } } return getMaxUtil ( arr , mem , 0 , 0 , C - 1 ) ; }
void printFactors ( int n ) { for ( int i = 2 ; i <= ( int ) Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { int d1 = i , d2 = n ; while ( d2 % d1 == 0 ) { d2 = d2 / d1 ; } if ( d1 > 1 && d2 > 1 ) { System . out . print ( d1 + ", " + d2 ) ; return ; } } } System . out . print ( - 1 ) ; }
int countTriplets ( int arr [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; else even ++ ; } int c1 = odd * ( even * ( even - 1 ) ) / 2 ; int c2 = ( odd * ( odd - 1 ) * ( odd - 2 ) ) / 6 ; return c1 + c2 ; }
int maxUniqueElements ( int [ ] Arr , int N ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . containsKey ( Arr [ i ] ) ) { mp . put ( Arr [ i ] , mp . get ( Arr [ i ] ) + 1 ) ; } else { mp . put ( Arr [ i ] , 1 ) ; } } int cnt = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { if ( ( entry . getValue ( ) ) % 2 == 0 ) { cnt ++ ; } } int ans = mp . size ( ) ; if ( cnt % 2 == 1 ) { ans -- ; } return ans ; }
long countCells ( int n , int m , int s ) { int mx1 = - 1 ; int cont1 = 0 ; for ( int i = 0 ; i < s && i < n ; ++ i ) { int aux = ( n - ( i + 1 ) ) / s + 1 ; if ( aux > mx1 ) { mx1 = cont1 = aux ; } else if ( aux == mx1 ) cont1 += aux ; } int mx2 = - 1 ; int cont2 = 0 ; for ( int i = 0 ; i < s && i < m ; ++ i ) { int aux = ( m - ( i + 1 ) ) / s + 1 ; if ( aux > mx2 ) mx2 = cont2 = aux ; else if ( aux == mx2 ) cont2 += aux ; } return ( long ) ( cont1 * cont2 ) ; }
void build_tree ( int [ ] b , int [ ] seg_tree , int l , int r , int vertex ) { if ( l == r ) { seg_tree [ vertex ] = b [ l ] ; return ; } int mid = ( l + r ) / 2 ; build_tree ( b , seg_tree , l , mid , 2 * vertex ) ; build_tree ( b , seg_tree , mid + 1 , r , 2 * vertex + 1 ) ; seg_tree [ vertex ] = __gcd ( seg_tree [ 2 * vertex ] , seg_tree [ 2 * vertex + 1 ] ) ; }
int range_gcd ( int [ ] seg_tree , int v , int tl , int tr , int l , int r ) { if ( l > r ) return 0 ; if ( l == tl && r == tr ) return seg_tree [ v ] ; int tm = ( tl + tr ) / 2 ; return __gcd ( range_gcd ( seg_tree , 2 * v , tl , tm , l , Math . min ( tm , r ) ) , range_gcd ( seg_tree , 2 * v + 1 , tm + 1 , tr , Math . max ( tm + 1 , l ) , r ) ) ; }
void maxSubarrayLen ( int arr [ ] , int n ) { int [ ] seg_tree = new int [ 4 * ( n ) + 1 ] ; build_tree ( arr , seg_tree , 0 , n - 1 , 1 ) ; int maxLen = 0 ; int l = 0 , r = 0 ; while ( r < n && l < n ) { if ( range_gcd ( seg_tree , 1 , 0 , n - 1 , l , r ) == 1 ) { l ++ ; } maxLen = Math . max ( maxLen , r - l + 1 ) ; r ++ ; } System . out . print ( maxLen ) ; }
boolean can_empty ( int a , int b , int c ) { if ( ( a + b + c ) % 4 != 0 ) return false ; else { int m = Math . min ( a , Math . min ( b , c ) ) ; if ( m < ( ( a + b + c ) / 4 ) ) return false ; } return true ; }
int countTotalPairs ( int N , int K ) { if ( K == 0 ) { return N * N ; } int ans = 0 ; for ( int i = K + 1 ; i <= N ; i ++ ) { ans += ( N / i ) * ( i - K ) ; if ( ( N % i ) - K + 1 > 0 ) { ans += ( N % i ) - K + 1 ; } } return ans ; }
void maxFrequencySubarrayUtil ( int [ ] A , int N , int M ) { int i = 0 ; HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; int val = 0 ; for ( ; i < M ; i ++ ) { if ( m . containsKey ( A [ i ] ) ) { m . put ( A [ i ] , m . get ( A [ i ] ) + 1 ) ; } else { m . put ( A [ i ] , 1 ) ; } val = Math . max ( val , m . get ( A [ i ] ) ) ; } System . out . print ( val + " " ) ; for ( i = M ; i < N ; i ++ ) { if ( m . containsKey ( i - M ) ) { m . put ( i - M , m . get ( i - M ) - 1 ) ; } if ( m . containsKey ( A [ i ] ) ) { m . put ( A [ i ] , m . get ( A [ i ] ) + 1 ) ; } else { m . put ( A [ i ] , 1 ) ; } val = 0 ; for ( Map . Entry < Integer , Integer > x : m . entrySet ( ) ) { val = Math . max ( val , x . getValue ( ) ) ; } System . out . print ( val + " " ) ; } }
int smallest ( int k , int d ) { int cnt = 1 ; int m = d % k ; int [ ] v = new int [ k ] ; Arrays . fill ( v , 0 ) ; v [ m ] = 1 ; while ( 1 != 0 ) { if ( m == 0 ) return cnt ; m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k ; if ( v [ m ] == 1 ) return - 1 ; v [ m ] = 1 ; cnt ++ ; } }
int getPairsCount ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && Math . abs ( arr [ i ] - arr [ j ] ) >= Math . min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; }
int minSteps ( int N ) { int count = 1 , res = 0 ; for ( int i = 1 ; i <= N ; i += count ) { res = Math . max ( res , count ) ; count ++ ; } return res ; }
int countReachablePoints ( int X , int Y , int L , int R ) { int diff_arr [ ] = new int [ 100000 ] ; int count = 0 ; diff_arr [ X ] = 1 ; diff_arr [ X + 1 ] = - 1 ; for ( int i = X ; i <= Y ; i ++ ) { diff_arr [ i ] += diff_arr [ i - 1 ] ; if ( diff_arr [ i ] >= 1 ) { diff_arr [ i + L ] += 1 ; diff_arr [ i + R + 1 ] -= 1 ; count ++ ; } } return count ; }
int minimumSubarray ( int [ ] arr , int n , int m ) { int [ ] mapu = new int [ m + 1 ] ; Arrays . fill ( mapu , 0 ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mapu [ arr [ i ] ] ++ ; if ( mapu [ arr [ i ] ] == ( n / m ) + 1 ) c ++ ; } if ( c == 0 ) return 0 ; int ans = n ; int l = 0 , r = 0 ; while ( r < n ) { if ( -- mapu [ arr [ r ] ] == ( n / m ) ) c -- ; if ( c == 0 ) { while ( l <= r && c == 0 ) { ans = Math . min ( ans , r - l + 1 ) ; if ( ++ mapu [ arr [ l ] ] > ( n / m ) ) c ++ ; l ++ ; } } r ++ ; } return ans ; }
void findAandB ( int N ) { int K = ( int ) ( Math . log ( N ) / Math . log ( 2 ) ) ; int B = ( 1 << K ) ; int A = B ^ N ; System . out . println ( A + " " + B ) ; }
int pathCountRec ( int mat [ ] [ ] , int m , int n , int k ) { if ( m < 0 n < 0 ) { return 0 ; } if ( m == 0 && n == 0 && ( k == mat [ m ] [ n ] ) ) { return 1 ; } return pathCountRec ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountRec ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; }
int pathCount ( int mat [ ] [ ] , int k ) { return pathCountRec ( mat , R - 1 , C - 1 , k ) ; }
int minDistance ( int start [ ] , int end [ ] , int n , int d ) { int left = Integer . MIN_VALUE ; int right = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { left = Math . max ( left , start [ i ] ) ; right = Math . min ( right , end [ i ] ) ; } if ( left > right ) return - 1 ; if ( d >= left && d <= right ) return 0 ; if ( d < left ) return ( left - d ) ; if ( d > right ) return ( d - right ) ; return - 1 ; }
int power ( int x , int y ) { if ( y == 0 ) return 1 ; if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; }
int order ( int num ) { int count = 0 ; while ( num > 0 ) { count ++ ; num = num / 10 ; } return count ; }
int isArmstrong ( int N ) { int r = order ( N ) ; int temp = N , sum = 0 ; while ( temp > 0 ) { int d = temp % 10 ; sum += power ( d , r ) ; temp = temp / 10 ; } if ( sum == N ) return 1 ; return 0 ; }
int maxSum ( int [ ] arr , int N , int K ) { if ( N < K ) { return - 1 ; } int res = 0 ; for ( int i = 0 ; i < K ; i ++ ) { res += arr [ i ] ; } int curr_sum = res ; for ( int i = K ; i < N ; i ++ ) { curr_sum += arr [ i ] - arr [ i - K ] ; res = Math . max ( res , curr_sum ) ; } return res ; }
int maxArmstrong ( int [ ] arr , int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = isArmstrong ( arr [ i ] ) ; } return maxSum ( arr , N , K ) ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
void printArr ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int minDifference = 1000000007 ; int minIndex = - 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( minDifference > Math . abs ( arr [ i ] - arr [ i - 1 ] ) ) { minDifference = Math . abs ( arr [ i ] - arr [ i - 1 ] ) ; minIndex = i - 1 ; } } int Arr [ ] = new int [ n ] ; Arr [ 0 ] = arr [ minIndex ] ; Arr [ n - 1 ] = arr [ minIndex + 1 ] ; int pos = 1 ; for ( int i = minIndex + 2 ; i < n ; i ++ ) { Arr [ pos ++ ] = arr [ i ] ; } for ( int i = 0 ; i < minIndex ; i ++ ) { Arr [ pos ++ ] = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( Arr [ i ] + " " ) ; } }
void findValuesOfK ( int g ) { int count = 0 ; for ( int i = 1 ; i * i <= g ; i ++ ) { if ( g % i == 0 ) { if ( i != g / i ) { if ( i % 2 == 1 ) { count ++ ; } if ( ( g / i ) % 2 == 1 ) { count ++ ; } } else if ( i % 2 == 1 ) { count ++ ; } } } System . out . println ( count ) ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { res = res * i ; } return res ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
void countPairs ( int arr [ ] , int N ) { int answer = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] + arr [ j ] == i + j ) { answer ++ ; } } } System . out . println ( answer ) ; }
int pathCountDPRecDP ( int [ ] [ ] mat , int m , int n , int k ) { if ( m < 0 n < 0 ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m ] [ n ] ? 1 : 0 ) ; if ( dp [ m ] [ n ] [ k ] != - 1 ) return dp [ m ] [ n ] [ k ] ; dp [ m ] [ n ] [ k ] = pathCountDPRecDP ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountDPRecDP ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; return dp [ m ] [ n ] [ k ] ; }
void checkDistribution ( int R , int B , int D ) { if ( Math . max ( R , B ) <= Math . min ( R , B ) * ( D + 1 ) ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } }
int itemType ( int n ) { int count = 0 ; for ( int day = 1 ; ; day ++ ) { for ( int type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) return type ; } } }
Vector < pair > primeFactor ( int N ) { Vector < pair > v = new Vector < > ( ) ; int count = 0 ; while ( ( N % 2 ) == 0 ) { N >>= 1 ; count ++ ; } if ( count != 0 ) v . add ( new pair ( 2 , count ) ) ; for ( int i = 3 ; i <= Math . sqrt ( N ) ; i += 2 ) { count = 0 ; while ( N % i == 0 ) { count ++ ; N = N / i ; } if ( count != 0 ) { v . add ( new pair ( i , count ) ) ; } } if ( N > 2 ) v . add ( new pair ( N , 1 ) ) ; return v ; }
long ABS ( long x ) { return Math . max ( x , - x ) ; }
boolean isvalid ( int i , int j ) { if ( i < 0 j < 0 i >= R j >= C ) return false ; return true ; }
int getLenUtil ( char mat [ ] [ ] , int i , int j , char prev ) { if ( ! isvalid ( i , j ) || ! isadjacent ( prev , mat [ i ] [ j ] ) ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; int ans = 0 ; for ( int k = 0 ; k < 8 ; k ++ ) ans = Math . max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , mat [ i ] [ j ] ) ) ; return dp [ i ] [ j ] = ans ; }
String BaseConversion ( int N ) { String s = "" ; while ( N != 0 ) { if ( N % 2 == 0 ) { s = "0" + s ; } else { s = "1" + s ; N -- ; } N /= - 2 ; } if ( s == "" ) { s = "0" ; } return s ; }
void check ( int N ) { int twos = 0 , fives = 0 ; while ( N % 2 == 0 ) { N /= 2 ; twos ++ ; } while ( N % 5 == 0 ) { N /= 5 ; fives ++ ; } if ( N == 1 && twos <= fives ) { System . out . println ( 2 * fives - twos ) ; } else { System . out . println ( - 1 ) ; } }
String isMakeZero ( int arr [ ] , int N , int K ) { HashMap < Integer , Integer > MP = new HashMap < Integer , Integer > ( ) ; ArrayList < Integer > V = new ArrayList < Integer > ( ) ; int X = 1 ; int i ; while ( X > 0 && X < Integer . MAX_VALUE ) { V . add ( X ) ; X *= K ; } for ( i = 0 ; i < N ; i ++ ) { for ( int j = V . size ( ) - 1 ; j >= 0 ; j -- ) { if ( MP . containsKey ( V . get ( j ) ) == false && V . get ( j ) <= arr [ i ] ) { arr [ i ] -= V . get ( j ) ; MP . put ( V . get ( j ) , 1 ) ; } } if ( arr [ i ] != 0 ) break ; } if ( i < N ) return "No" ; else return "Yes" ; }
int countOperations ( int N , int M ) { boolean [ ] visited = new boolean [ 100001 ] ; Arrays . fill ( visited , false ) ; Queue < pair < Integer , Integer > > Q = new LinkedList < > ( ) ; Q . add ( make_pair ( N , 0 ) ) ; visited [ N ] = true ; while ( ! Q . isEmpty ( ) ) { int aux = Q . peek ( ) . first ; int cont = Q . peek ( ) . second ; Q . remove ( ) ; if ( aux == M ) return cont ; for ( int i = 2 ; i * i <= aux ; i ++ ) if ( aux % i == 0 ) { if ( aux + i <= M && ! visited [ aux + i ] ) { Q . add ( make_pair ( aux + i , cont + 1 ) ) ; visited [ aux + i ] = true ; } if ( aux + aux / i <= M && ! visited [ aux + aux / i ] ) { Q . add ( make_pair ( aux + aux / i , cont + 1 ) ) ; visited [ aux + aux / i ] = true ; } } } return - 1 ; }
double Avgdifference ( double arr [ ] , int N , int K ) { double min = 1000000 , max = - 1 ; for ( int i = 0 ; i <= N - K ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < K ; j ++ ) { sum += arr [ i + j ] ; } if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
double Avgdifference ( double arr [ ] , int N , int K ) { double sum = 0 ; for ( int i = 0 ; i < K ; i ++ ) sum += arr [ i ] ; double min = sum ; double max = sum ; for ( int i = K ; i <= N - K + 1 ; i ++ ) { sum += arr [ i ] - arr [ i - K ] ; if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
int minimumElement ( int arr [ ] , int N , int K ) { int minElement = arr [ 0 ] ; for ( int i = 0 ; i < N ; ++ i ) { minElement = Math . min ( minElement , arr [ i ] ) ; } int reqOperations = 0 ; for ( int i = 0 ; i < N ; ++ i ) { reqOperations += arr [ i ] - minElement ; } if ( reqOperations < K ) { K -= reqOperations ; minElement -= ( K + N - 1 ) / N ; } return minElement ; }
Vector < String > FractionSplit ( long n , long d ) { Vector < String > UnitFactions = new Vector < > ( ) ; while ( n > 0 ) { long x = ( d + n - 1 ) / n ; String s = "1/" + String . valueOf ( x ) ; UnitFactions . add ( s ) ; n = n * x - d ; d = d * x ; } return UnitFactions ; }
void findPermutation ( int N ) { int [ ] arr = new int [ N ] ; int temp ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = i + 1 ; } for ( int i = 1 ; i < N ; i += 2 ) { temp = arr [ i ] ; arr [ i ] = arr [ i - 1 ] ; arr [ i - 1 ] = temp ; } if ( N % 2 == 1 && N > 1 ) { temp = arr [ N - 1 ] ; arr [ N - 1 ] = arr [ N - 2 ] ; arr [ N - 2 ] = temp ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
void rangeSum ( int arr [ ] , int N , int L , int R ) { int sum = 0 ; for ( int i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; } System . out . println ( sum ) ; }
void rangeSum ( int arr [ ] , int N , int L , int R ) { int prefix [ ] = new int [ N + 1 ] ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } int leftsum = ( ( L - 1 ) / N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] ; int rightsum = ( R / N ) * prefix [ N ] + prefix [ R % N ] ; System . out . print ( rightsum - leftsum ) ; }
void addAP ( int A [ ] , int Q , int [ ] [ ] operations ) { for ( int j = 0 ; j < 2 ; ++ j ) { int L = operations [ j ] [ 0 ] , R = operations [ j ] [ 1 ] , a = operations [ j ] [ 2 ] , d = operations [ j ] [ 3 ] ; int curr = a ; for ( int i = L - 1 ; i < R ; i ++ ) { A [ i ] += curr ; curr += d ; } } for ( int i = 0 ; i < 4 ; ++ i ) System . out . print ( A [ i ] + " " ) ; }
void maximizeNumber ( int N , int K ) { String s = Integer . toString ( N ) ; int L = s . length ( ) ; String result = "" ; int i = 0 ; while ( ( i < L ) && ( K <= ( ( int ) s . charAt ( i ) - ( int ) '0' ) ) ) { result += ( s . charAt ( i ) ) ; ++ i ; } result += ( ( char ) ( K + ( int ) '0' ) ) ; while ( i < L ) { result += ( s . charAt ( i ) ) ; ++ i ; } System . out . println ( result ) ; }
void countArrays ( int N , int K ) { System . out . println ( ( int ) ( power ( N , K ) ) ) ; }
void minimumDistance ( int arr [ ] , int N ) { int ind = 0 ; int prev = arr [ ind ] ; int s = arr . length ; for ( int i = 0 ; i < N ; i ++ ) { int distance = Integer . MAX_VALUE ; if ( i < arr [ 0 ] ) { distance = arr [ 0 ] - i ; } else if ( i >= prev && ind + 1 < s && i <= arr [ ind + 1 ] ) { distance = Math . min ( i - prev , arr [ ind + 1 ] - i ) ; if ( i == arr [ ind + 1 ] ) { distance = 0 ; prev = arr [ ind + 1 ] ; ind ++ ; } } else { distance = i - prev ; } System . out . print ( distance + " " ) ; } }
int countOfPairs ( int arr [ ] , int N , int X ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( ( ( arr [ i ] ^ arr [ j ] ) & X ) == 0 ) count ++ ; } } return count ; }
int countOfPairs ( int [ ] arr , int N , int X ) { int count = 0 ; HashMap < Integer , Integer > M = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( M . containsKey ( arr [ i ] & X ) ) M . put ( ( arr [ i ] & X ) , M . get ( arr [ i ] & X ) + 1 ) ; else M . put ( arr [ i ] & X , 1 ) ; } for ( Integer entry : M . keySet ( ) ) { int p = M . get ( entry ) ; count += p * ( p - 1 ) / 2 ; } return count ; }
int ConcatenateArr ( int [ ] arr , int N ) { int ans = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { int l = ( int ) Math . floor ( Math . log10 ( arr [ i ] ) + 1 ) ; ans = ans * ( int ) Math . pow ( 10 , l ) ; ans += arr [ i ] ; } return ans ; }
int countXor ( int N ) { int cnt = ( int ) N / 2 + 1 ; return cnt ; }
int DistRecursion ( String S , int i , int dist ) { char [ ] ch = S . toCharArray ( ) ; if ( i == ch . length ) return Math . abs ( dist ) ; if ( ch [ i ] == 'L' ) return DistRecursion ( S , i + 1 , dist - 1 ) ; if ( ch [ i ] == 'R' ) return DistRecursion ( S , i + 1 , dist + 1 ) ; return Math . max ( DistRecursion ( S , i + 1 , dist - 1 ) , DistRecursion ( S , i + 1 , dist + 1 ) ) ; }
int maxDistance ( String S ) { return DistRecursion ( S , 0 , 0 ) ; }
int isPerfect ( long N ) { long sum = 1 ; for ( long i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { if ( i * i != N ) sum = sum + i + N / i ; else sum = sum + i ; } } if ( sum == N && N != 1 ) return 1 ; return 0 ; }
void Query ( int arr [ ] [ ] , int N ) { int [ ] prefix = new int [ MAX + 1 ] ; Arrays . fill ( prefix , 0 ) ; for ( int i = 2 ; i <= MAX ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + isPerfect ( i ) ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( prefix [ arr [ i ] [ 1 ] ] - prefix [ arr [ i ] [ 0 ] - 1 ] + " " ) ; } }
int ExpoFactorial ( int N ) { int res = 1 ; int mod = 1000000007 ; for ( int i = 2 ; i < N + 1 ; i ++ ) res = ( int ) Math . pow ( i , res ) % mod ; return res ; }
int maxSubArraySumRepeated ( int [ ] arr , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int curr = arr [ 0 ] ; int ans = arr [ 0 ] ; if ( K == 1 ) { for ( int i = 1 ; i < N ; i ++ ) { curr = Math . max ( arr [ i ] , curr + arr [ i ] ) ; ans = Math . max ( ans , curr ) ; } return ans ; } ArrayList < Integer > V = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < 2 * N ; i ++ ) { V . add ( arr [ i % N ] ) ; } int maxSuf = V . get ( 0 ) ; int maxPref = V . get ( 2 * N - 1 ) ; curr = V . get ( 0 ) ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr += V . get ( i ) ; maxPref = Math . max ( maxPref , curr ) ; } curr = V . get ( 2 * N - 1 ) ; for ( int i = 2 * N - 2 ; i >= 0 ; i -- ) { curr += V . get ( i ) ; maxSuf = Math . max ( maxSuf , curr ) ; } curr = V . get ( 0 ) ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr = Math . max ( V . get ( i ) , curr + V . get ( i ) ) ; ans = Math . max ( ans , curr ) ; } if ( sum > 0 ) { int temp = sum * ( K - 2 ) ; ans = Math . max ( ans , Math . max ( temp + maxPref , temp + maxSuf ) ) ; } return ans ; }
int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
long numOfNecklace ( int N ) { long ans = factorial ( N ) / ( factorial ( N / 2 ) * factorial ( N / 2 ) ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans /= 2 ; return ans ; }
int nthNumber ( int n ) { int divs [ ] = new int [ 1000000 ] ; boolean vis [ ] = new boolean [ 1000000 ] ; int cnt = 0 ; for ( int i = 2 ; cnt < n ; i ++ ) { if ( divs [ i ] == 0 ) { for ( int j = 2 * i ; j < 1000000 ; j += i ) { if ( vis [ j ] ) { continue ; } vis [ j ] = true ; int currNum = j ; int count = 0 ; while ( currNum % i == 0 ) { divs [ j ] ++ ; currNum = currNum / i ; count ++ ; } if ( currNum == 1 && count == 3 && divs [ j ] == 3 ) { cnt ++ ; } else if ( currNum != 1 && divs [ currNum ] == 0 && count == 1 && divs [ j ] == 1 ) { cnt ++ ; } if ( cnt == n ) { return j ; } } } } return - 1 ; }
int findkey ( int A , int B , int C ) { int ans = 0 ; int cur = 1 ; while ( A > 0 ) { int a = A % 10 ; int b = B % 10 ; int c = C % 10 ; A = A / 10 ; B = B / 10 ; C = C / 10 ; int m = Math . max ( a , Math . max ( c , b ) ) ; ans += cur * m ; cur = cur * 10 ; } return ans ; }
int SumOfPrimeDivisors ( int n ) { int sum = 0 ; if ( n % 2 == 0 ) { sum = sum + 2 ; } while ( n % 2 == 0 ) { n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { sum = sum + i ; } while ( n % i == 0 ) { n = n / i ; } } if ( n > 2 ) { sum = sum + n ; } return sum ; }
int countNumbers ( int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( ( i & 1 ) == 0 ) count += 1 ; } return count ; }
int countNumbers ( int l , int r ) { return ( ( r / 2 ) - ( l - 1 ) / 2 ) ; }
boolean isPerfectSquare ( int x ) { int s = ( int ) Math . sqrt ( x ) ; return ( s * s == x ) ; }
boolean isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
int contiguousFibonacciNumber ( int arr [ ] , int n ) { int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isFibonacci ( arr [ i ] ) ) { current_length ++ ; } else { current_length = 0 ; } max_length = Math . max ( max_length , current_length ) ; } return max_length ; }
int Kadane ( int arr [ ] , int n ) { int largestSum = 0 , currMax = 0 ; int currSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currSum += arr [ i ] ; currMax = Math . max ( currMax , arr [ i ] ) ; largestSum = Math . max ( largestSum , currMax * currSum ) ; if ( currSum < 0 ) { currMax = 0 ; currSum = 0 ; } } return largestSum ; }
int maximumWeight ( int arr [ ] , int n ) { int largestSum = Kadane ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = - arr [ i ] ; } largestSum = Math . max ( largestSum , Kadane ( arr , n ) ) ; return largestSum ; }
void evenOdd ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int even_digits = 0 ; int odd_digits = 0 ; int temp = arr [ i ] ; while ( temp > 0 ) { if ( ( temp % 10 ) % 2 != 0 ) odd_digits ++ ; else even_digits ++ ; temp /= 10 ; } if ( even_digits > odd_digits ) { int res = 0 ; while ( arr [ i ] > 0 ) { res += arr [ i ] % 10 ; arr [ i ] /= 10 ; } System . out . print ( res + " " ) ; } else if ( odd_digits > even_digits ) { int res = 1 ; while ( arr [ i ] > 0 ) { res *= arr [ i ] % 10 ; arr [ i ] /= 10 ; } System . out . print ( res + " " ) ; } else System . out . print ( arr [ i ] + " " ) ; } }
int sumOfFirstM ( int A [ ] , int N , int M ) { int sum = 0 ; for ( int i = 0 ; i < M ; i ++ ) { sum = sum + A [ i % N ] ; } return sum ; }
int findSmallestNumK ( int n ) { int cummAnd = n ; int i = n - 1 ; while ( cummAnd != 0 ) { cummAnd = cummAnd & i ; if ( cummAnd == 0 ) { return i ; } i -- ; } return - 1 ; }
int findMinInsertions ( char str [ ] , int l , int h ) { if ( l > h ) return Integer . MAX_VALUE ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( Integer . min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }
void canReach0toM ( int [ ] [ ] a , int n , int m ) { int [ ] rightMost = new int [ m + 1 ] ; int [ ] dp = new int [ m + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { rightMost [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { int a1 = a [ i ] [ 0 ] ; int b1 = a [ i ] [ 1 ] ; rightMost [ a1 ] = Math . max ( rightMost [ a1 ] , b1 ) ; } for ( int i = m ; i >= 0 ; i -- ) { dp [ i ] = i ; for ( int j = Math . min ( m , rightMost [ i ] ) ; j > i ; j -- ) { dp [ i ] = Math . max ( dp [ i ] , dp [ j ] ) ; } } if ( dp [ 0 ] >= m ) { System . out . print ( "Yes" ) ; } else { System . out . print ( "No" ) ; } }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void countPairs ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int x = 1 ; x <= arr [ i ] ; x ++ ) { for ( int y = x ; y <= arr [ i ] ; y ++ ) { if ( gcd ( x , y ) > 1 ) count ++ ; } } System . out . print ( count + " " ) ; } }
int maximumTurns ( int arr [ ] , int N ) { int Count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { while ( arr [ i ] % 2 == 0 ) { Count ++ ; arr [ i ] = arr [ i ] / 2 ; } } return Count ; }
void findSet ( int N , int K ) { ArrayList < Integer > a = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i != K ) a . add ( i ) ; } int MaxDistinct = ( N - K ) + ( K / 2 ) ; Collections . reverse ( a ) ; for ( int i = 0 ; i < MaxDistinct ; i ++ ) System . out . print ( a . get ( i ) + " " ) ; }
void linearCongruence ( long A , long B , long N ) { A = A % N ; B = B % N ; long u = 0 , v = 0 ; long person [ ] = ExtendedEuclidAlgo ( A , N ) ; long d = person [ 0 ] ; u = person [ 1 ] ; v = person [ 2 ] ; if ( B % d != 0 ) { System . out . println ( - 1 ) ; return ; } long x0 = ( u * ( B / d ) ) % N ; if ( x0 < 0 ) x0 += N ; for ( long i = 0 ; i <= d - 1 ; i ++ ) { long an = ( x0 + i * ( N / d ) ) % N ; System . out . print ( an + " " ) ; } }
int distinctGCDs ( int [ ] arr , int N ) { int M = - 1 , ans = 0 ; HashMap < Integer , Integer > Mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { M = Math . max ( M , arr [ i ] ) ; if ( Mp . containsKey ( arr [ i ] ) ) Mp . put ( arr [ i ] , 1 ) ; else Mp . put ( arr [ i ] , 0 ) ; } for ( int i = 1 ; i <= M ; i ++ ) { int currGcd = 0 ; for ( int j = i ; j <= M ; j += i ) { if ( Mp . containsKey ( j ) ) { currGcd = gcd ( currGcd , j ) ; if ( currGcd == i ) { ans ++ ; break ; } } } } return ans ; }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
void countSubarray ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int mxSubarray = 0 ; int mxOther = 0 ; for ( int k = i ; k <= j ; k ++ ) { mxSubarray = Math . max ( mxSubarray , arr [ k ] ) ; } for ( int k = 0 ; k < i ; k ++ ) { mxOther = Math . max ( mxOther , arr [ k ] ) ; } for ( int k = j + 1 ; k < n ; k ++ ) { mxOther = Math . max ( mxOther , arr [ k ] ) ; } if ( mxSubarray > ( 2 * mxOther ) ) count ++ ; } } System . out . println ( count ) ; }
void countSubarray ( int [ ] arr , int n ) { int L = 0 , R = 0 ; int mx = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) mx = Math . max ( mx , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] * 2 > mx ) { L = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] * 2 > mx ) { R = i ; break ; } } System . out . println ( ( L + 1 ) * ( n - R ) ) ; }
int factorialWithoutMul ( int N ) { int ans = N ; for ( int i = N - 1 ; i > 0 ; i -- ) { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ans ; ans = sum ; } return ans ; }
boolean isPrime ( int X ) { for ( int i = 2 ; i * i <= X ; i ++ ) if ( X % i == 0 ) return false ; return true ; }
int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { n = n & ( n - 1 ) ; count ++ ; } return count ; }
int minOperations ( int A , int B ) { int cnt1 = 0 , cnt2 = 0 ; cnt1 += countSetBits ( A ) ; cnt2 += countSetBits ( B ) ; if ( ( cnt1 + cnt2 ) % 2 != 0 ) return - 1 ; int oneZero = 0 , zeroOne = 0 ; int ans = 0 ; for ( int i = 0 ; i < Math . max ( cnt1 , cnt2 ) ; i ++ ) { int bitpos = 1 << i ; if ( ( ( bitpos & A ) == 0 ) && ( ( bitpos & B ) != 0 ) ) zeroOne ++ ; if ( ( ( bitpos & A ) != 0 ) && ( ( bitpos & B ) == 0 ) ) oneZero ++ ; } ans = ( zeroOne / 2 ) + ( oneZero / 2 ) ; if ( zeroOne % 2 != 0 ) ans += 2 ; return ans ; }
void sieveSundaram ( ) { ArrayList < Boolean > marked = new ArrayList < Boolean > ( MAX / 2 + 100 ) ; for ( int i = 0 ; i < MAX / 2 + 100 ; i ++ ) { marked . add ( false ) ; } for ( int i = 1 ; i <= ( Math . sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked . set ( j , true ) ; primes . add ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked . get ( i ) == false ) primes . add ( 2 * i + 1 ) ; }
Boolean isSmithBrotherPair ( int X , int Y ) { return isSmith ( X ) && isSmith ( Y ) && Math . abs ( X - Y ) == 1 ; }
Integer countSmithBrotherPairs ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) { if ( isSmithBrotherPair ( A [ i ] , A [ j ] ) ) count ++ ; } return count ; }
void tripletAndSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { ans += arr [ i ] & arr [ j ] & arr [ k ] ; } } } System . out . println ( ans ) ; }
void countPairs ( int arr [ ] , int N ) { int count = 0 , totalSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalSum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( totalSum % ( arr [ i ] + arr [ j ] ) == 0 ) { count += 1 ; } } } System . out . println ( count ) ; }
int countOfBase ( int N ) { int count = 0 ; for ( int i = 2 ; i <= N ; ++ i ) { int highestPower = ( int ) ( Math . log ( N ) / Math . log ( i ) ) ; int firstDigit = N / ( int ) Math . pow ( i , highestPower ) ; if ( firstDigit == 1 ) { ++ count ; } } return count ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
boolean PermuteAndFind ( int [ ] power , int idx , int SumSoFar , int target ) { if ( idx == power . length ) { if ( SumSoFar == target ) return true ; return false ; } boolean select = PermuteAndFind ( power , idx + 1 , SumSoFar , target ) ; boolean notselect = PermuteAndFind ( power , idx + 1 , SumSoFar + power [ idx ] , target ) ; return ( select notselect ) ; }
void DistinctPowersOf3 ( int N ) { int [ ] power = new int [ 16 ] ; power [ 0 ] = 1 ; for ( int i = 1 ; i < 16 ; i ++ ) power [ i ] = 3 * power [ i - 1 ] ; boolean found = PermuteAndFind ( power , 0 , 0 , N ) ; if ( found == true ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } }
HashMap < Integer , Integer > PrimeFactor ( int N ) { HashMap < Integer , Integer > primef = new HashMap < Integer , Integer > ( ) ; while ( N % 2 == 0 ) { if ( primef . containsKey ( 2 ) ) { primef . put ( 2 , primef . get ( 2 ) + 1 ) ; } else { primef . put ( 2 , 1 ) ; } N = N / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( N ) ; i ++ ) { while ( N % i == 0 ) { if ( primef . containsKey ( i ) ) { primef . put ( i , primef . get ( i ) + 1 ) ; } else { primef . put ( i , 1 ) ; } N = N / 2 ; } } if ( N > 2 ) { primef . put ( N , 1 ) ; } return primef ; }
int CountToMakeEqual ( int X , int Y ) { int gcdofXY = gcd ( X , Y ) ; int newX = Y / gcdofXY ; int newY = X / gcdofXY ; HashMap < Integer , Integer > primeX = PrimeFactor ( newX ) ; HashMap < Integer , Integer > primeY = PrimeFactor ( newY ) ; int ans = 0 ; for ( Map . Entry keys : primeX . entrySet ( ) ) { if ( X % ( int ) keys . getKey ( ) != 0 ) { return - 1 ; } ans += primeX . get ( keys . getKey ( ) ) ; } for ( Map . Entry keys : primeY . entrySet ( ) ) { if ( Y % ( int ) keys . getKey ( ) != 0 ) { return - 1 ; } ans += primeY . get ( keys . getKey ( ) ) ; } return ans ; }
void maximumSubsequenceSum ( int A [ ] , int N ) { int ans = 0 ; HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { mp . put ( A [ i ] - i , mp . getOrDefault ( A [ i ] - i , 0 ) + A [ i ] ) ; ans = Math . max ( ans , mp . get ( A [ i ] - i ) ) ; } System . out . println ( ans ) ; }
void getPermutation ( int N ) { if ( N <= 3 ) { System . out . print ( - 1 ) ; return ; } int i = N ; if ( N % 2 == 0 ) i -- ; while ( i >= 1 ) { System . out . print ( i + " " ) ; i -= 2 ; } System . out . print ( 4 + " " + 2 + " " ) ; i = 6 ; while ( i <= N ) { System . out . print ( i + " " ) ; i += 2 ; } }
int gcd ( int A , int B ) { if ( B == 0 ) return A ; else return gcd ( B , A % B ) ; }
int getDistinctValues ( int A , int B , int C ) { int g = gcd ( A , B ) ; int num_values = C / g ; return num_values ; }
void nearestPerfectSquare ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int sr = ( int ) Math . sqrt ( arr [ i ] ) ; int a = sr * sr ; int b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) System . out . print ( a + " " ) ; else System . out . print ( b + " " ) ; } }
int currSubArrayScore ( int [ ] a , int [ ] b , int l , int r ) { int straightScore = 0 ; int reverseScore = 0 ; for ( int i = l ; i <= r ; i ++ ) { straightScore += a [ i ] * b [ i ] ; reverseScore += a [ r - ( i - l ) ] * b [ i ] ; } return Math . max ( straightScore , reverseScore ) ; }
void maxScoreSubArray ( int [ ] a , int [ ] b , int n ) { int res = 0 , start = 0 , end = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int currScore = currSubArrayScore ( a , b , i , j ) ; if ( currScore > res ) { res = currScore ; start = i ; end = j ; } } } System . out . print ( res ) ; }
void maxScoreSubArray ( int [ ] a , int [ ] b , int n ) { int res = 0 ; for ( int mid = 0 ; mid < n ; mid ++ ) { int straightScore = a [ mid ] * b [ mid ] , reverseScore = a [ mid ] * a [ mid ] ; int prev = mid - 1 , next = mid + 1 ; res = Math . max ( res , Math . max ( straightScore , reverseScore ) ) ; while ( prev >= 0 && next < n ) { straightScore += ( a [ prev ] * b [ prev ] + a [ next ] * b [ next ] ) ; reverseScore += ( a [ prev ] * b [ next ] + a [ next ] * b [ prev ] ) ; res = Math . max ( res , Math . max ( straightScore , reverseScore ) ) ; prev -- ; next ++ ; } straightScore = 0 ; reverseScore = 0 ; prev = mid - 1 ; next = mid ; while ( prev >= 0 && next < n ) { straightScore += ( a [ prev ] * b [ prev ] + a [ next ] * b [ next ] ) ; reverseScore += ( a [ prev ] * b [ next ] + a [ next ] * b [ prev ] ) ; res = Math . max ( res , Math . max ( straightScore , reverseScore ) ) ; prev -- ; next ++ ; } } System . out . println ( res ) ; }
int minimumSizeSubarray ( int arr [ ] , int N ) { int i = 0 , j = N - 1 ; while ( i < N && arr [ i ] == 0 ) { i ++ ; } if ( i == N ) return 1 ; while ( j >= 0 && arr [ j ] == 0 ) { j -- ; } return ( j - i + 1 ) ; }
void countXorPartition ( int N ) { double a = Math . pow ( 2 , ( int ) ( N - Math . log ( N + 1 ) / Math . log ( 2 ) ) ) ; System . out . print ( a ) ; }
void countValues ( int A , int B , int C ) { if ( B >= A ) { System . out . println ( 0 ) ; return ; } if ( B == 0 ) { System . out . println ( C / A ) ; return ; } int ans = C / A ; if ( ans * A + B <= C ) { ans ++ ; } System . out . println ( ans ) ; }
void SieveOfEratosthenes ( int n ) { Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } }
int floorDifference ( int A [ ] , int N , int X ) { int totalSum = 0 ; int perElementSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalSum += A [ i ] ; perElementSum += A [ i ] / X ; } int totalFloorSum = totalSum / X ; return Math . abs ( totalFloorSum - perElementSum ) ; }
int maximumSum ( int arr [ ] , int N ) { int ans = 0 ; for ( int bit = 0 ; bit < 32 ; bit ++ ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & ( 1 << bit ) ) == 1 ) { sum += arr [ i ] ; } } ans = Math . max ( ans , sum ) ; } return ans ; }
void maxCount ( int arr [ ] , int N , int K ) { HashSet < Integer > st = new HashSet < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { st . add ( arr [ i ] ) ; } if ( N - st . size ( ) <= K ) { System . out . println ( "Yes" ) ; } else System . out . println ( "No" ) ; }
void kthDigitFromLast ( int n , int k ) { if ( k <= 0 ) { System . out . println ( - 1 ) ; return ; } while ( ( k - 1 ) > 0 && n > 0 ) { n = n / 10 ; k -- ; } if ( n == 0 ) { System . out . println ( - 1 ) ; } else { System . out . println ( n % 10 ) ; } }
void findWinner ( int X , int Y ) { int playerA = ( X ^ Y ) ; boolean flag = false ; for ( int i = 1 ; i <= X ; i ++ ) { for ( int j = 1 ; j <= Y ; j ++ ) { int val = ( i ^ j ) ; if ( val > playerA ) { flag = true ; break ; } } if ( flag ) { break ; } } if ( flag ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } }
void findWinner ( int X , int Y ) { int first = ( X ^ Y ) ; int second = ( X + Y ) ; if ( first == second ) { System . out . println ( "No" ) ; } else { System . out . println ( "Yes" ) ; } }
int countWays ( int arr [ ] , int N ) { int arr_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) arr_xor ^= arr [ i ] ; int pref_xor = 0 , suff_xor = 0 ; ArrayList < Integer > pref_ind = new ArrayList < > ( ) ; int [ ] suff_inds = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { pref_xor ^= arr [ i ] ; if ( pref_xor == arr_xor ) pref_ind . add ( i ) ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { suff_xor ^= arr [ i ] ; suff_inds [ i ] += suff_inds [ i + 1 ] ; if ( suff_xor == arr_xor ) suff_inds [ i ] ++ ; } int tot_ways = 0 ; for ( Integer idx : pref_ind ) { if ( idx < N - 1 ) tot_ways += suff_inds [ idx + 2 ] ; } return tot_ways ; }
int KthSmallest ( int A [ ] , int B [ ] , int N , int K ) { int M = 0 ; for ( int i = 0 ; i < N ; i ++ ) { M = Math . max ( A [ i ] , M ) ; } int freq [ ] = new int [ M + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { freq [ A [ i ] ] += B [ i ] ; } int sum = 0 ; for ( int i = 0 ; i <= M ; i ++ ) { sum += freq [ i ] ; if ( sum >= K ) { return i ; } } return - 1 ; }
int xorSumOfArray ( int arr [ ] , int n , int k , int count [ ] ) { int sum = 0 ; int p = 1 ; for ( int i = 0 ; i < 31 ; i ++ ) { int val = 0 ; if ( ( k & ( 1 << i ) ) != 0 ) { int not_set = n - count [ i ] ; val = ( ( not_set ) * p ) ; } else { val = ( count [ i ] * p ) ; } sum += val ; p = ( p * 2 ) ; } return sum ; }
void sumOfXors ( int arr [ ] , int n , int queries [ ] , int q ) { int [ ] count = new int [ 32 ] ; Arrays . fill ( count , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 31 ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) != 0 ) count [ j ] ++ ; } } for ( int i = 0 ; i < q ; i ++ ) { int k = queries [ i ] ; System . out . print ( xorSumOfArray ( arr , n , k , count ) + " " ) ; } }
int IsSumEqualsXor ( int i , int n , int bound , char [ ] s ) { if ( i == n ) return 1 ; if ( dp [ i ] [ bound ] != - 1 ) return dp [ i ] [ bound ] ; int ans = 0 ; if ( bound != 0 && s [ i ] == '0' ) { ans = IsSumEqualsXor ( i + 1 , n , 1 , s ) ; } else { ans = 2 * IsSumEqualsXor ( i + 1 , n , bound != 0 & ( s [ i ] == '1' ) ? 1 : 0 , s ) ; ans += IsSumEqualsXor ( i + 1 , n , 0 , s ) ; } return dp [ i ] [ bound ] = ans ; }
int findNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }
int findSmallest ( int M , int N ) { int x = findNum ( M , N ) ; return x - M ; }
int toDeci ( String str , int base ) { int len = str . length ( ) ; int power = 1 ; int num = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str . charAt ( i ) ) >= base ) { System . out . printf ( "Invalid Number" ) ; return - 1 ; } num += val ( str . charAt ( i ) ) * power ; power = power * base ; } return num ; }
int fact ( int N ) { if ( N == 1 N == 0 ) return 1 ; return N * fact ( N - 1 ) ; }
void prefixFactorialArray ( int [ ] arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { arr [ i ] += arr [ i - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = fact ( arr [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
void prefixFactorialArray ( int A [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) { A [ i ] += A [ i - 1 ] ; } int fact [ ] = new int [ A [ N - 1 ] + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= A [ N - 1 ] ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = fact [ A [ i ] ] ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( A [ i ] + " " ) ; } }
void countPairs ( int arr [ ] , int n , int x ) { int count = 0 ; HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp . put ( arr [ i ] - x * i , mp . getOrDefault ( arr [ i ] - x * i , 0 ) + 1 ) ; } for ( int v : mp . values ( ) ) { count += ( v * ( v - 1 ) ) / 2 ; } System . out . println ( count ) ; }
double findAverage ( int N ) { double S = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { S += i * i * i * i ; } return S / N ; }
double findAverage ( int N ) { double avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N * N ) + ( 10 * N * N ) - 1 ) / 30.0 ; return avg ; }
boolean ToCheckPowerofX ( int n , int x ) { while ( n > 0 ) { int rem = n % x ; if ( rem >= 2 ) { return false ; } n = n / x ; } return true ; }
int maximumOfTwo ( int N ) { int M = reverseBin ( N ) ; return Math . max ( N , M ) ; }
void findbitwiseOR ( int [ ] a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sub_array = a [ i ] ; res = res | curr_sub_array ; for ( int j = i ; j < n ; j ++ ) { curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } } System . out . println ( res ) ; }
void findbitwiseOR ( int [ ] a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res | a [ i ] ; System . out . println ( res ) ; }
void findDecimal ( double arr [ ] , int N ) { int bit , power = 0 , result = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { bit = Math . abs ( ( int ) Math . floor ( arr [ i ] ) - ( int ) Math . round ( arr [ i ] ) ) ; if ( bit != 0 ) result += Math . pow ( 2 , power ) ; power ++ ; } System . out . print ( result ) ; }
int totalMoney ( int N ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { ans += i / 7 ; ans += ( i % 7 + 1 ) ; } return ans ; }
int minTime ( int [ ] A , int n , int K ) { int max_ability = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { max_ability = Math . max ( max_ability , A [ i ] ) ; } int tmp [ ] = new int [ max_ability + 1 ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { tmp [ A [ i ] ] ++ ; } for ( int i = max_ability ; i >= 0 ; i -- ) { if ( tmp [ i ] != 0 ) { if ( tmp [ i ] * i < K ) { K -= ( i * tmp [ i ] ) ; tmp [ i / 2 ] += tmp [ i ] ; count += tmp [ i ] ; if ( K <= 0 ) { return count ; } } else { if ( K % i != 0 ) { count += ( K / i ) + 1 ; } else { count += ( K / i ) ; } return count ; } } } return - 1 ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void minimumRod ( int A [ ] , int N ) { System . out . println ( N * findlcm ( A , N ) ) ; }
void check ( int n ) { int sumOfDigit = 0 ; int prodOfDigit = 1 ; while ( n > 0 ) { int rem ; rem = n % 10 ; sumOfDigit += rem ; prodOfDigit *= rem ; n /= 10 ; } if ( sumOfDigit > prodOfDigit ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
boolean check ( int N , int D ) { while ( N > 0 ) { if ( findDigit ( N , D ) == true ) { return true ; } N -= D ; } return false ; }
int FindSum ( int [ ] arr , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int power = ( int ) ( Math . log ( arr [ i ] ) / Math . log ( 2 ) ) ; int LesserValue = ( int ) Math . pow ( 2 , power ) ; int LargerValue = ( int ) Math . pow ( 2 , power + 1 ) ; if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) { res += arr [ i ] ; } } return res ; }
int power ( int x , int y ) { int res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
void countRelations ( int N ) { System . out . print ( ( power ( 2 , N ) - 2 ) * power ( 2 , N * N - N ) ) ; }
int minOperations ( int N ) { int [ ] arr = new int [ N ] ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = ( 2 * i ) + 1 ; sum = sum + arr [ i ] ; } int mid = 0 ; if ( N % 2 == 0 ) { mid = sum / N ; } else { mid = arr [ N / 2 ] ; } int ans = 0 ; for ( int i = 0 ; i < N / 2 ; i ++ ) { ans += mid - arr [ i ] ; } return ans ; }
int minOperation ( int N ) { if ( N % 2 == 0 ) { return ( N / 2 ) * ( N / 2 ) ; } int k = ( N - 1 ) / 2 ; return k * ( k + 1 ) ; }
int findXORS ( int arr1 [ ] , int arr2 [ ] , int N , int M ) { int XORS1 = 0 ; int XORS2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { XORS1 ^= arr1 [ i ] ; } for ( int i = 0 ; i < M ; i ++ ) { XORS2 ^= arr2 [ i ] ; } return ( XORS1 & XORS2 ) ; }
void findPermutation ( int [ ] arr ) { int N = arr . length ; int i = N - 2 ; while ( i >= 0 && arr [ i ] <= arr [ i + 1 ] ) i -- ; if ( i == - 1 ) { System . out . print ( "-1" ) ; return ; } int j = N - 1 ; while ( j > i && arr [ j ] >= arr [ i ] ) j -- ; while ( j > i && arr [ j ] == arr [ j - 1 ] ) { j -- ; } int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; for ( int it : arr ) { System . out . print ( it + " " ) ; } }
boolean isPowerof2 ( int n ) { return ( ( n & ( n - 1 ) ) > 0 && n > 0 ) ; }
void countNum ( int N ) { int ans = ( int ) ( Math . log ( N ) / Math . log ( 2 ) ) + 1 ; System . out . println ( ans ) ; }
int nearestPow ( int x , int base1 ) { int k = ( int ) ( Math . log ( x ) / Math . log ( base1 ) ) ; if ( Math . abs ( Math . pow ( base1 , k ) - x ) < Math . abs ( Math . pow ( base1 , ( k + 1 ) ) - x ) ) return ( int ) Math . pow ( base1 , k ) ; else return ( int ) Math . pow ( base1 , ( k + 1 ) ) ; }
int ceilDifference ( int arr [ ] , int n , int x ) { int totalSum = 0 ; int perElementSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { totalSum += arr [ i ] ; perElementSum += Math . ceil ( ( double ) ( arr [ i ] ) / ( double ) ( x ) ) ; } int totalCeilSum = ( int ) Math . ceil ( ( double ) ( totalSum ) / ( double ) ( x ) ) ; return Math . abs ( perElementSum - totalCeilSum ) ; }
void computeTotient ( int N , int phi [ ] ) { for ( int p = 2 ; p <= N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i <= N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } }
void countPairs ( int N ) { int cnt_type1 = 0 , cnt_type2 = 0 ; int half_N = N / 2 ; cnt_type1 = ( half_N * ( half_N - 1 ) ) / 2 ; int [ ] phi = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { phi [ i ] = i ; } computeTotient ( N , phi ) ; for ( int i = ( N / 2 ) + 1 ; i <= N ; i ++ ) cnt_type2 += ( i - phi [ i ] - 1 ) ; System . out . print ( cnt_type1 + cnt_type2 ) ; }
int countTriplets ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i * j > N ) break ; ans += N / ( i * j ) ; } } return ans ; }
void findSumOfGP ( double a , double r ) { if ( Math . abs ( r ) >= 1 ) { System . out . print ( "Infinite" ) ; return ; } double sum = a / ( 1 - r ) ; System . out . print ( sum ) ; }
int power ( long x , int y ) { int res = 1 ; x = x % mod ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( int ) ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
int numberOfRelations ( int N ) { return power ( 3 , ( N * N - N ) / 2 ) ; }
void countNumbers ( int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( __gcd ( i , N ) != 1 ) count ++ ; } System . out . print ( count ) ; }
int phi ( int N ) { int result = N ; for ( int p = 2 ; p * p <= N ; ++ p ) { if ( N % p == 0 ) { while ( N % p == 0 ) N /= p ; result -= result / p ; } } if ( N > 1 ) result -= result / N ; return result ; }
void countNumbers ( int N ) { int count = N - phi ( N ) ; System . out . print ( count ) ; }
void Query ( int arr [ ] , int N , int Q [ ] [ ] ) { int mul = 1 ; int add = 0 ; for ( int i = 0 ; i < Q . length ; i ++ ) { if ( Q [ i ] [ 0 ] == 0 ) { add = add + Q [ i ] [ 1 ] ; } else if ( Q [ i ] [ 0 ] == 1 ) { mul = mul * Q [ i ] [ 1 ] ; add = add * Q [ i ] [ 1 ] ; } else { int ans = arr [ Q [ i ] [ 1 ] ] * mul + add ; System . out . print ( ans + " " ) ; } } }
int nearFibo ( int X ) { double a = ( Math . pow ( 5 , 0.5 ) + 1 ) / 2 ; int n = ( int ) ( Math . log ( ( Math . pow ( 5 , 0.5 ) ) * X ) / Math . log ( a ) ) ; int nth = nthFibo ( n ) ; int nplus = nthFibo ( n + 1 ) ; if ( Math . abs ( X - nth ) < Math . abs ( X - nplus ) ) return nth ; else return nplus ; }
void sieveOfEratosthenes ( int N , int s [ ] ) { boolean [ ] prime = new boolean [ N + 1 ] ; for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= N ; j += 2 ) { if ( ! prime [ i * j ] ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } }
int getMaxPairSum ( int [ ] arr , int N , int K ) { int [ ] preMax = new int [ N ] ; preMax [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { preMax [ i ] = Math . max ( preMax [ i - 1 ] , arr [ i ] ) ; } int res = Integer . MIN_VALUE ; for ( int i = K ; i < N ; i ++ ) { res = Math . max ( res , arr [ i ] + preMax [ i - K ] ) ; } return res ; }
void sumOfInfiniteAGP ( double a , double d , double r ) { double ans = a / ( 1 - r ) + ( d * r ) / ( 1 - r * r ) ; System . out . print ( ans ) ; }
int countPairs ( int arr [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 arr [ j ] % arr [ i ] == 0 ) { count ++ ; } } } return count ; }
int CountPairs ( int arr [ ] , int N ) { int res = 0 ; Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { Integer c = mp . get ( arr [ i ] ) ; mp . put ( arr [ i ] , ( c == null ) ? 1 : c + 1 ) ; } Iterator < Map . Entry < Integer , Integer > > itr = mp . entrySet ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { Map . Entry < Integer , Integer > entry = itr . next ( ) ; int x = ( int ) entry . getKey ( ) ; int y = ( int ) entry . getValue ( ) ; if ( x == 1 ) { res += N - 1 ; continue ; } res += ( y * ( y - 1 ) ) / 2 ; for ( int j = 2 ; j <= Math . sqrt ( x ) ; j ++ ) { if ( x % j == 0 ) { res += mp . get ( j ) ; if ( j != x / j ) res += mp . get ( ( int ) x / j ) ; } } } return res ; }
void findClosestTarget ( int i , int curr , int B [ ] , int M , int K ) { if ( Math . abs ( curr - K ) < mini ) { mini = Math . abs ( curr - K ) ; ans = curr ; } if ( Math . abs ( curr - K ) == mini ) { ans = Math . min ( ans , curr ) ; } if ( i >= M ) return ; findClosestTarget ( i + 1 , curr + B [ i ] , B , M , K ) ; findClosestTarget ( i + 1 , curr + 2 * B [ i ] , B , M , K ) ; findClosestTarget ( i + 1 , curr , B , M , K ) ; }
int findClosest ( int A [ ] , int B [ ] , int N , int M , int K ) { for ( int i = 0 ; i < N ; i ++ ) { findClosestTarget ( 0 , A [ i ] , B , M , K ) ; } return ans ; }
int countbits ( int n ) { int count = 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 ) count ++ ; n = n / 2 ; } return count ; }
int BitProduct ( int arr [ ] , int N ) { int product = 1 ; for ( int i = 0 ; i < N ; i ++ ) { int bits = countbits ( arr [ i ] ) ; product *= bits ; } return product ; }
int [ ] removeEveryKth ( int l [ ] , int k ) { for ( int i = 0 ; i < l . length ; i ++ ) { if ( i % k == 0 ) l [ i ] = 0 ; } ArrayList < Integer > list = new ArrayList < > ( ) ; list . add ( 0 ) ; for ( int i = 1 ; i < l . length ; i ++ ) { if ( l [ i ] != 0 ) list . add ( l [ i ] ) ; } return list . stream ( ) . mapToInt ( i -> i ) . toArray ( ) ; }
void printArray ( int l [ ] ) { for ( int i = 1 ; i < l . length ; i ++ ) System . out . print ( l [ i ] + " " ) ; System . out . println ( ) ; }
void printSequence ( int n , int k ) { int l [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) l [ i ] = i ; int x = 1 ; for ( int i = 0 ; i < k ; i ++ ) { int p = l [ x ] + l [ x + 1 ] ; l = removeEveryKth ( l , p ) ; x += 1 ; } printArray ( l ) ; }
void OddDivisorsSum ( int n , int q , int [ ] a , int [ ] [ ] Query ) { int [ ] DP = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = ( int ) ( Math . sqrt ( a [ i ] ) ) ; if ( x * x == a [ i ] ) DP [ i ] = a [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { DP [ i ] = DP [ i - 1 ] + DP [ i ] ; } for ( int i = 0 ; i < q ; i ++ ) { int l = Query [ i ] [ 0 ] ; int r = Query [ i ] [ 1 ] ; if ( l == 0 ) { System . out . print ( DP [ r ] + " " ) ; } else { System . out . print ( DP [ r ] - DP [ l - 1 ] + " " ) ; } } }
void findSubset ( int [ ] arr ) { int N = arr . length ; Map < Integer , Integer > map = new HashMap < > ( ) ; int totSum = 0 ; int s = 0 ; int flag = 0 ; ArrayList < Integer > ans = new ArrayList < > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { totSum += arr [ i ] ; map . put ( arr [ i ] , map . getOrDefault ( arr [ i ] , 0 ) + 1 ) ; } Arrays . sort ( arr ) ; int i = N - 1 ; while ( i >= 0 ) { int frq = map . get ( arr [ i ] ) ; if ( ( frq + ans . size ( ) ) < ( N - ( frq + ans . size ( ) ) ) ) { for ( int k = 0 ; k < frq ; k ++ ) { ans . add ( arr [ i ] ) ; totSum -= arr [ i ] ; s += arr [ i ] ; i -- ; } } else { i -= frq ; } if ( s > totSum ) { flag = 1 ; break ; } } if ( flag == 1 ) { for ( i = ans . size ( ) - 1 ; i >= 0 ; i -- ) { System . out . print ( ans . get ( i ) + " " ) ; } } else { System . out . print ( - 1 ) ; } }
int minStepK ( int arr [ ] , int N , int K ) { int E = 0 ; int S = 0 ; for ( int i = 0 ; i < N ; i ++ ) { S += arr [ i ] ; if ( arr [ i ] % 2 == 0 ) E += 1 ; } if ( S >= K ) return 0 ; else if ( S + E < K ) return - 1 ; else return K - S ; }
int Rotate ( int n , int f ) { int temp = n ; int maxi = n ; int mini = n ; for ( int idx = 0 ; idx < 7 ; idx ++ ) { if ( temp % 2 == 1 ) { temp >>= 1 ; temp += Math . pow ( 2 , 7 ) ; } else temp >>= 1 ; mini = Math . min ( mini , temp ) ; maxi = Math . max ( maxi , temp ) ; } if ( f == 1 ) return ( maxi ) ; else return ( mini ) ; }
void minimumDiff ( int [ ] arr , int N ) { int res = arr [ 0 ] , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int min_diff = sum ; for ( int i = 0 ; i < N ; i ++ ) { if ( Math . abs ( sum - ( arr [ i ] * N ) ) < min_diff ) { min_diff = Math . abs ( sum - ( arr [ i ] * N ) ) ; res = arr [ i ] ; } } System . out . println ( res ) ; }
int makeEqual ( int arr [ ] , int n ) { int fre0 [ ] = new int [ 33 ] ; int fre1 [ ] = new int [ 33 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; for ( int j = 0 ; j < 33 ; j ++ ) { if ( ( x & 1 ) != 0 ) { fre1 [ j ] += 1 ; } else { fre0 [ j ] += 1 ; } x = x >> 1 ; } } int ans = 0 ; for ( int i = 0 ; i < 33 ; i ++ ) { ans += Math . min ( fre0 [ i ] , fre1 [ i ] ) ; } return ans ; }
void check ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum == 0 ) System . out . println ( "Yes" ) ; else System . out . println ( "No" ) ; }
int primeDivisors ( int [ ] arr , int N ) { int K = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { K = Math . max ( K , arr [ i ] ) ; } int [ ] prime = new int [ K + 1 ] ; prime [ 0 ] = 1 ; prime [ 1 ] = 1 ; for ( int i = 2 ; i < K + 1 ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = 2 * i ; j < K + 1 ; j += i ) { prime [ j ] = 1 ; } } } int [ ] factor = new int [ K + 1 ] ; factor [ 0 ] = 0 ; factor [ 1 ] = 1 ; for ( int i = 2 ; i < K + 1 ; i ++ ) { factor [ i ] += 1 ; for ( int j = i ; j < K + 1 ; j += i ) { factor [ j ] += 1 ; } } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( prime [ factor [ arr [ i ] ] ] == 0 ) count ++ ; } return count ; }
int isPresent ( int n , int x ) { String num = String . valueOf ( n ) ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { if ( ( num . charAt ( i ) - '0' ) == x ) return i ; } return - 1 ; }
int removeDigit ( int n , int index ) { String num = String . valueOf ( n ) ; String ans = "" ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { if ( i != index ) ans += num . charAt ( i ) ; } if ( ans == "" || ( ans . length ( ) == 1 && ans . charAt ( 0 ) == '0' ) ) return - 1 ; int x = Integer . valueOf ( ans ) ; return x ; }
boolean reduceNtoX ( int a , int b , int d [ ] , int n ) { Queue < Integer > q = new LinkedList < > ( ) ; q . add ( a ) ; Map < Integer , Boolean > visited = new HashMap < > ( ) ; visited . put ( a , true ) ; while ( ! q . isEmpty ( ) ) { int top = q . peek ( ) ; q . poll ( ) ; if ( top < 0 ) continue ; if ( top == b ) return true ; for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] != 0 && top % d [ i ] == 0 && ! visited . getOrDefault ( top / d [ i ] , false ) ) { q . add ( top / d [ i ] ) ; visited . put ( top / d [ i ] , true ) ; } int index = isPresent ( top , d [ i ] ) ; if ( index != - 1 ) { int newElement = removeDigit ( top , index ) ; if ( newElement != - 1 && ( ! visited . getOrDefault ( newElement , false ) ) ) { q . add ( newElement ) ; visited . put ( newElement , true ) ; } } } } return false ; }
void SieveOfEratosthenes ( int n , boolean prime [ ] ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } }
int fact ( int n ) { if ( n == 1 n == 0 ) return 1 ; else return n * fact ( n - 1 ) ; }
int findValue ( int n , int r , int a ) { int k = ( a - 1 ) / fact ( n ) ; int answer = k ; for ( int i = 1 ; i < n + 1 ; i ++ ) answer = answer * ( n + r - i ) ; answer = answer + 1 ; return answer ; }
void expectedValue ( int P , int a , int b , int N ) { double expValue = P + ( N * 0.5 * ( a + b ) ) ; System . out . print ( expValue ) ; }
int startingPoint ( int A [ ] , int N ) { int sum = 0 ; int in = 0 ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( sum < min ) { min = sum ; in = i + 1 ; } } if ( sum < 0 ) { return - 1 ; } return in % N ; }
int findMinSum ( int mat [ ] [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int res = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( i != j ) { res |= mat [ i ] [ j ] ; } } sum += res ; } return sum ; }
void findMedian ( int Mean , int Mode ) { double Median = ( 2 * Mean + Mode ) / 3.0 ; System . out . print ( ( int ) Median ) ; }
void sumOfBinaryNumbers ( int n ) { int ans = 0 ; int one = 1 ; while ( true ) { if ( n <= 1 ) { ans = ( ans + n ) % MOD ; break ; } int x = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; int cur = 0 ; int add = ( int ) ( Math . pow ( 2 , ( x - 1 ) ) ) ; for ( int i = 1 ; i <= x ; i ++ ) { cur = ( cur + add ) % MOD ; add = ( add * 10 % MOD ) ; } ans = ( ans + cur ) % MOD ; int rem = n - ( int ) ( Math . pow ( 2 , x ) ) + 1 ; int p = ( int ) Math . pow ( 10 , x ) ; p = ( p * ( rem % MOD ) ) % MOD ; ans = ( ans + p ) % MOD ; n = rem - 1 ; } System . out . println ( ans ) ; }
void uniqueElementsLCM ( int arr [ ] , int N ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { freq . put ( arr [ i ] , freq . getOrDefault ( arr [ i ] , 0 ) + 1 ) ; } int lcm = 1 ; for ( Entry < Integer , Integer > i : freq . entrySet ( ) ) { if ( i . getValue ( ) == 1 ) { lcm = findLCM ( lcm , i . getKey ( ) ) ; } } if ( lcm == 1 ) lcm = - 1 ; System . out . print ( lcm ) ; }
int maxAdjacentDifference ( ArrayList < Integer > A ) { int diff = 0 ; for ( int i = 1 ; i < ( int ) A . size ( ) ; i ++ ) { diff = Math . max ( diff , A . get ( i ) - A . get ( i - 1 ) ) ; } return diff ; }
int MinimumValue ( int arr [ ] , int N ) { int MinValue = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { ArrayList < Integer > new_arr = new ArrayList < > ( ) ; for ( int j = 0 ; j < N ; j ++ ) { if ( i == j ) continue ; new_arr . add ( arr [ j ] ) ; } MinValue = Math . min ( MinValue , maxAdjacentDifference ( new_arr ) ) ; } return MinValue ; }
void findNode ( HashMap < Integer , Integer > map , int n ) { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = map . getOrDefault ( i + 1 , 0 ) ; } int count0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count0 ++ ; } } count0 -= 1 ; if ( count0 <= Math . floor ( ( ( double ) n ) / ( ( double ) 2 ) ) ) { System . out . println ( "Yes" ) ; } else System . out . println ( "No " ) ; }
int count ( int num ) { int ans = 0 ; while ( num > 0 ) { ans += num & 1 ; num >>= 1 ; } return ans ; }
void checkGoodMatrix ( int mat [ ] [ ] ) { ArrayList < Integer > P = new ArrayList < Integer > ( ) ; ArrayList < Integer > S = new ArrayList < Integer > ( ) ; ArrayList < Integer > MR = new ArrayList < Integer > ( ) ; ArrayList < Integer > MC = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < mat . length ; i ++ ) { for ( int j = 0 ; j < mat [ 0 ] . length ; j ++ ) { if ( i == j ) P . add ( mat [ i ] [ j ] ) ; if ( i + j == mat . length - 1 ) S . add ( mat [ i ] [ j ] ) ; if ( i == Math . floor ( ( mat . length - 1 ) / 2 ) ) MR . add ( mat [ i ] [ j ] ) ; if ( j == Math . floor ( ( mat . length - 1 ) / 2 ) ) MC . add ( mat [ i ] [ j ] ) ; } } Collections . reverse ( S ) ; int P0 = convert ( P ) ; int S0 = convert ( S ) ; int MR0 = convert ( MR ) ; int MC0 = convert ( MC ) ; int setBitsPS = count ( ( P0 & S0 ) ) ; int setBitsMM = count ( ( MR0 & MC0 ) ) ; if ( setBitsPS > setBitsMM ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
int power ( int x , int y ) { int res = 1 ; x = x % mod ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
int antisymmetricRelation ( int N ) { return ( power ( 2 , N ) * power ( 3 , ( N * N - N ) / 2 ) ) % mod ; }
int power ( int x , int y ) { int res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
int asymmetricRelation ( int N ) { return power ( 3 , ( N * N - N ) / 2 ) ; }
void crossProduct ( int vect_A [ ] , int vect_B [ ] , int cross_P [ ] ) { cross_P [ 0 ] = vect_A [ 1 ] * vect_B [ 2 ] - vect_A [ 2 ] * vect_B [ 1 ] ; cross_P [ 1 ] = vect_A [ 2 ] * vect_B [ 0 ] - vect_A [ 0 ] * vect_B [ 2 ] ; cross_P [ 2 ] = vect_A [ 0 ] * vect_B [ 1 ] - vect_A [ 1 ] * vect_B [ 0 ] ; }
void checkCollinearity ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { int A [ ] = { x1 , y1 , z1 } ; int B [ ] = { x2 , y2 , z2 } ; int cross_P [ ] = new int [ 3 ] ; crossProduct ( A , B , cross_P ) ; if ( cross_P [ 0 ] == 0 && cross_P [ 1 ] == 0 && cross_P [ 2 ] == 0 ) System . out . print ( "Yes" ) ; else System . out . print ( "No" ) ; }
double vectorMagnitude ( int x , int y , int z ) { int sum = x * x + y * y + z * z ; return Math . sqrt ( sum ) ; }
double kineticEnergy ( double M , double V ) { double KineticEnergy ; KineticEnergy = 0.5 * M * V * V ; return KineticEnergy ; }
double potentialEnergy ( double M , double H ) { double PotentialEnergy ; PotentialEnergy = M * 9.8 * H ; return PotentialEnergy ; }
int nearestPow ( int x , int y ) { if ( y == 1 ) return 1 ; int k = ( int ) ( Math . log10 ( x ) / Math . log10 ( y ) ) ; if ( Math . abs ( Math . pow ( y , k ) - x ) < Math . abs ( Math . pow ( y , ( k + 1 ) ) - x ) ) return ( int ) ( Math . pow ( y , k ) ) ; return ( int ) ( Math . pow ( y , ( k + 1 ) ) ) ; }
void countPairs ( int arr [ ] , int N ) { int even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; } if ( N - even >= 1 ) { System . out . println ( even ) ; return ; } System . out . println ( 0 ) ; }
void nearestFibonacci ( int num ) { if ( num == 0 ) { System . out . print ( 0 ) ; return ; } int first = 0 , second = 1 ; int third = first + second ; while ( third <= num ) { first = second ; second = third ; third = first + second ; } int ans = ( Math . abs ( third - num ) >= Math . abs ( second - num ) ) ? second : third ; System . out . print ( ans ) ; }
boolean checkPermutation ( int ans [ ] , int a [ ] , int n ) { int Max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { Max = Math . max ( Max , ans [ i ] ) ; if ( Max != a [ i ] ) return false ; } return true ; }
void findPermutation ( int a [ ] , int n ) { int ans [ ] = new int [ n ] ; HashMap < Integer , Integer > um = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! um . containsKey ( a [ i ] ) ) { ans [ i ] = a [ i ] ; um . put ( a [ i ] , i ) ; } } ArrayList < Integer > v = new ArrayList < > ( ) ; int j = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! um . containsKey ( i ) ) { v . add ( i ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ans [ i ] == 0 ) { ans [ i ] = v . get ( j ) ; j ++ ; } } if ( checkPermutation ( ans , a , n ) ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + " " ) ; } } else System . out . println ( "-1" ) ; }
boolean isPower ( int m , int y ) { int res1 = ( int ) Math . log ( y ) / ( int ) Math . log ( m ) ; double res2 = ( int ) Math . log ( y ) / ( int ) Math . log ( m ) ; return ( res1 == res2 ) ; }
int numSub ( int arr [ ] , int n , int m ) { int ans = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPower ( m , arr [ i ] ) ) { cnt ++ ; ans += ( cnt * ( cnt - 1 ) ) / 2 ; } else { cnt = 0 ; } } return ans ; }
void SieveOfEratosthenes ( int n ) { for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } }
void assignValues ( int Edges [ ] [ ] , int n ) { ArrayList < ArrayList < Integer > > tree = new ArrayList < > ( ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) tree . add ( new ArrayList < > ( ) ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int u = Edges [ i ] [ 0 ] ; int v = Edges [ i ] [ 1 ] ; tree . get ( u ) . add ( v ) ; tree . get ( v ) . add ( u ) ; } boolean [ ] visited = new boolean [ n + 1 ] ; int [ ] answer = new int [ n + 1 ] ; int K = 1 ; Queue < Integer > q = new LinkedList < > ( ) ; q . add ( 1 ) ; answer [ 1 ] = K ; while ( ! q . isEmpty ( ) ) { int node = q . peek ( ) ; q . poll ( ) ; visited [ node ] = true ; K = ( ( answer [ node ] == 1 ) ? 2 : 1 ) ; for ( Integer child : tree . get ( node ) ) { if ( ! visited [ child ] ) { q . add ( child ) ; answer [ child ] = K ; } } } for ( int i = 1 ; i <= n ; i ++ ) { System . out . print ( answer [ i ] + " " ) ; } }
void distribute ( int N , int K , int M , int arr [ ] ) { int distribution [ ] = new int [ N ] ; int ptr = K - 1 ; int rem = M ; while ( rem > 0 ) { if ( rem >= arr [ ptr ] ) { distribution [ ptr ] += arr [ ptr ] ; rem -= arr [ ptr ] ; } else { distribution [ ptr ] += rem ; rem = 0 ; } ptr = ( ptr + 1 ) % N ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( distribution [ i ] + " " ) ; } }
void sumOfSquaredDifferences ( int arr [ ] , int N ) { int ans = 0 ; int sumA = 0 , sumB = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sumA += ( arr [ i ] * arr [ i ] ) ; sumB += arr [ i ] ; } sumA = N * sumA ; sumB = ( sumB * sumB ) ; ans = sumA - sumB ; System . out . println ( ans ) ; }
boolean isPrime ( long n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( long i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
void findMinimumNumber ( long [ ] arr , long N ) { ArrayList < Long > primes = new ArrayList < Long > ( ) ; findPrime ( primes ) ; long ans = 2147483647 ; int n = primes . size ( ) ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { long temp = 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) > 0 ) { temp *= primes . get ( j ) ; } } boolean check = true ; for ( long k = 0 ; k < N ; k ++ ) { if ( gcd ( temp , arr [ ( int ) k ] ) == 1l ) { check = false ; break ; } } if ( check == true ) ans = Math . min ( ans , temp ) ; } System . out . print ( ans ) ; }
void waysToRemove ( int n , int m ) { int ans = 0 ; if ( m == 1 ) { System . out . println ( n ) ; return ; } for ( int d = 0 ; d >= 0 ; d ++ ) { int len = m + ( m - 1 ) * d ; if ( len > n ) break ; ans += ( n - len ) + 1 ; } System . out . println ( ans ) ; }
void countStairs ( int n , int x , int a , int b ) { int [ ] vis = new int [ n + 1 ] ; int [ ] moves = { + a , - a , + b , - b } ; Queue < Integer > q = new LinkedList < Integer > ( ) ; q . add ( x ) ; vis [ x ] = 1 ; while ( ! q . isEmpty ( ) ) { int currentStair = q . peek ( ) ; q . remove ( ) ; for ( int j = 0 ; j < 4 ; j ++ ) { int newStair = currentStair + moves [ j ] ; if ( newStair > 0 && newStair <= n && vis [ newStair ] == 0 ) { q . add ( newStair ) ; vis [ newStair ] = 1 ; } } } int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( vis [ i ] == 1 ) cnt ++ ; System . out . print ( cnt ) ; }
void minimumSteps ( int x , int y ) { int cnt = 0 ; while ( x != 0 && y != 0 ) { if ( x > y ) { cnt += x / y ; x %= y ; } else { cnt += y / x ; y %= x ; } } cnt -- ; if ( x > 1 y > 1 ) cnt = - 1 ; System . out . println ( cnt ) ; }
int cntPairs ( int arr [ ] , int N ) { int res = 0 ; int bit [ ] = new int [ 32 ] ; for ( int i = 0 ; i < N ; i ++ ) { int pos = ( int ) ( Math . log ( arr [ i ] ) / Math . log ( 2 ) ) ; bit [ pos ] ++ ; } for ( int i = 0 ; i < 32 ; i ++ ) { res += ( bit [ i ] * ( bit [ i ] - 1 ) ) / 2 ; } return res ; }
void minimumMEX ( int arr [ ] , int N , int K ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= N + 1 ; i ++ ) s . add ( i ) ; for ( int i = 0 ; i < K ; i ++ ) s . remove ( arr [ i ] ) ; int mex = s . iterator ( ) . next ( ) ; for ( int i = K ; i < N ; i ++ ) { s . remove ( arr [ i ] ) ; s . add ( arr [ i - K ] ) ; int firstElem = s . iterator ( ) . next ( ) ; mex = Math . min ( mex , firstElem ) ; } System . out . print ( mex + " " ) ; }
void smallerNumbers ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { count ++ ; } } System . out . print ( count + " " ) ; } }
int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; }
void minimumOperations ( int X , int Y ) { int GCD = gcd ( X , Y ) ; X = X / GCD ; Y = Y / GCD ; int count = 0 ; while ( X != Y ) { if ( Y > X ) { int t = X ; X = Y ; Y = t ; } if ( X % 2 == 0 ) { X = X / 2 ; } else if ( X % 3 == 0 ) { X = X / 3 ; } else if ( X % 5 == 0 ) { X = X / 5 ; } else { System . out . print ( "-1" ) ; return ; } count += 1 ; } System . out . println ( count ) ; }
int minOperations ( int a [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += a [ i ] ; } ans -= n ; for ( int x = 1 ; ; x ++ ) { int curPow = 1 , curCost = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curCost += Math . abs ( a [ i ] - curPow ) ; curPow *= x ; } if ( curPow / x > ans + a [ n - 1 ] ) break ; ans = Math . min ( ans , curCost ) ; } return ans ; }
int truncMod ( int a , int n ) { int q = a / n ; return a - n * q ; }
void addEdge ( ArrayList < Integer > Adj [ ] , int u , int v ) { Adj [ u ] . add ( v ) ; Adj [ v ] . add ( u ) ; }
void isPossible ( Node Arr [ ] , int N ) { @ SuppressWarnings ( "unchecked" ) ArrayList < Integer > [ ] Adj = ( ArrayList < Integer > [ ] ) new ArrayList [ N ] ; for ( int i = 0 ; i < N ; i ++ ) Adj [ i ] = new ArrayList < > ( ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] . R < Arr [ j ] . L Arr [ i ] . L > Arr [ j ] . R ) { continue ; } else { if ( Arr [ i ] . V == Arr [ j ] . V ) { addEdge ( Adj , i , j ) ; } } } } boolean visited [ ] = new boolean [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( visited [ i ] == false && Adj [ i ] . size ( ) > 0 ) { if ( check ( Adj , i , N , visited ) == false ) { System . out . println ( "No" ) ; return ; } } } System . out . println ( "Yes" ) ; }
void printArray ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " " ) ; } }
int bitOr ( int arr [ ] , int N ) { int count = 0 ; int length = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { length ++ ; } else { if ( length != 0 ) { count += ( ( length ) * ( length + 1 ) ) / 2 ; } length = 0 ; } } count += ( ( length ) * ( length + 1 ) ) / 2 ; return count ; }
Double mean ( int arr [ ] , int N ) { Double avg = 0.0 ; for ( int i = 0 ; i < N ; i ++ ) { avg += Double . valueOf ( ( arr [ i ] - avg ) / ( i + 1 ) ) ; } return avg ; }
int maximumAND ( int arr [ ] , int n , int m ) { int tot = 1 << n ; int mx = 0 ; for ( int bm = 0 ; bm < tot ; bm ++ ) { int andans = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ( ( bm >> i ) & 1 ) != 0 ) { if ( count == 0 ) { andans = arr [ i ] ; } else { andans = andans & arr [ i ] ; } count ++ ; } } if ( count == ( m + 1 ) ) { mx = Math . max ( mx , andans ) ; } } return mx ; }
void findTotalSum ( String ops [ ] ) { if ( ops . length == 0 ) { System . out . println ( 0 ) ; return ; } Stack < Integer > pts = new Stack < > ( ) ; int ans = 0 ; for ( int i = 0 ; i < ops . length ; i ++ ) { if ( ops [ i ] == "C" ) { ans -= pts . pop ( ) ; } else if ( ops [ i ] == "D" ) { pts . push ( pts . peek ( ) * 2 ) ; ans += pts . peek ( ) ; } else if ( ops [ i ] == "+" ) { int a = pts . pop ( ) ; int b = pts . peek ( ) ; pts . push ( a ) ; ans += ( a + b ) ; pts . push ( a + b ) ; } else { int n = Integer . parseInt ( ops [ i ] ) ; ans += n ; pts . push ( n ) ; } } System . out . println ( ans ) ; }
void findXOR ( int mat [ ] [ ] [ ] , int N ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) { if ( ( i == j && j == k ) ) { XOR ^= mat [ i ] [ j ] [ k ] ; XOR ^= mat [ i ] [ j ] [ N - k - 1 ] ; } } } } System . out . println ( XOR ) ; }
void findXOR ( int mat [ ] [ ] [ ] , int N ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { XOR ^= mat [ i ] [ i ] [ i ] ; XOR ^= mat [ i ] [ i ] [ N - i - 1 ] ; } System . out . println ( XOR ) ; }
int countSubtreesUtil ( int cur , int par ) { int res = 1 ; for ( int i = 0 ; i < graph . get ( cur ) . size ( ) ; i ++ ) { int v = graph . get ( cur ) . get ( i ) ; if ( v == par ) continue ; res = ( int ) ( ( res * ( countSubtreesUtil ( v , cur ) + 1 ) ) % mod ) ; } ans = ( int ) ( ( ans + res ) % mod ) ; return res ; }
void countSubtrees ( int N , int [ ] [ ] adj ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { int a = adj [ i ] [ 0 ] ; int b = adj [ i ] [ 1 ] ; graph . get ( a ) . add ( b ) ; graph . get ( b ) . add ( a ) ; } countSubtreesUtil ( 1 , 1 ) ; System . out . println ( ans + 1 ) ; }
void sieve ( ) { prime = new boolean [ limit + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= limit ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= limit ; i += p ) prime [ i ] = false ; } } }
int findOperations ( int arr [ ] , int n ) { sieve ( ) ; int minm = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { minm = Math . min ( minm , arr [ i ] ) ; } int val = minm ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == minm + 1 ) { val = minm - 2 ; break ; } } int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int D = arr [ i ] - val ; if ( D == 0 ) { continue ; } else if ( prime [ D ] == true ) { cnt += 1 ; } else if ( D % 2 == 0 ) { cnt += 2 ; } else { if ( prime [ D - 2 ] == true ) { cnt += 2 ; } else { cnt += 3 ; } } } return cnt ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int maximumRowValue ( int n , int m ) { return gcd ( n , m ) ; }
void checkCommonDivisor ( int [ ] arr , int N , int X ) { int G = 0 ; for ( int i = 0 ; i < N ; i ++ ) { G = gcd ( G , arr [ i ] ) ; } int copy_G = G ; for ( int divisor = 2 ; divisor <= X ; divisor ++ ) { while ( G % divisor == 0 ) { G = G / divisor ; } } if ( G <= X ) { System . out . println ( "Yes" ) ; for ( int i = 0 ; i < N ; i ++ ) System . out . print ( ( arr [ i ] / copy_G ) + " " ) ; System . out . println ( ) ; } else System . out . println ( "No" ) ; }
void countPairs ( int [ ] arr , int N ) { int count = 0 ; Map < Double , Integer > mp = new HashMap < Double , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { Double val = 1.0 * arr [ i ] ; Double idx = 1.0 * ( i + 1 ) ; if ( mp . containsKey ( val / idx ) ) count += mp . get ( val / idx ) ; if ( mp . containsKey ( val / idx ) ) mp . put ( val / idx , mp . getOrDefault ( val / idx , 0 ) + 1 ) ; else mp . put ( val / idx , 1 ) ; } System . out . print ( count ) ; }
void findConvolution ( int [ ] a , int [ ] b ) { int n = a . length , m = b . length ; int [ ] c = new int [ ( n + m - 1 ) ] ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { c [ i + j ] += ( a [ i ] * b [ j ] ) % MOD ; } } for ( int k = 0 ; k < c . length ; ++ k ) { c [ k ] %= MOD ; System . out . print ( c [ k ] + " " ) ; } }
int count1s ( int start_i , int start_j , int end_i , int end_j , int [ ] [ ] mat ) { int count = 0 ; for ( int x = start_i ; x < end_i ; x ++ ) { for ( int y = start_j ; y < end_j ; y ++ ) { if ( mat [ x ] [ y ] == 1 ) count ++ ; } } return count ; }
int findMinimumCount ( int N , int M , int A , int B , int [ ] [ ] mat ) { int minimum = ( int ) 1e9 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( i + A <= N && j + B <= M ) { int count = count1s ( i , j , i + A , j + B , mat ) ; minimum = Math . min ( count , minimum ) ; } if ( i + B <= N && j + A <= M ) { int count = count1s ( i , j , i + B , j + A , mat ) ; minimum = Math . min ( count , minimum ) ; } } } return minimum ; }
boolean checkEvenPower ( int n ) { int x = 0 ; while ( x < n ) { int value = ( int ) Math . pow ( 2 , x ) ; if ( value == n ) { if ( x % 2 == 0 ) return true ; else return false ; } x ++ ; } return false ; }
int getMaxUtil ( ArrayList < Integer > p , int arr [ ] , int ans , boolean chosen [ ] , int N ) { if ( p . size ( ) == N ) { ans = Math . max ( ans , calcScore ( p , arr ) ) ; return ans ; } for ( int i = 0 ; i < N ; i ++ ) { if ( chosen [ i ] ) { continue ; } chosen [ i ] = true ; p . add ( i ) ; ans = getMaxUtil ( p , arr , ans , chosen , N ) ; chosen [ i ] = false ; p . remove ( p . size ( ) - 1 ) ; } return ans ; }
void getMax ( int arr [ ] , int N ) { int ans = 0 ; boolean chosen [ ] = new boolean [ N ] ; ArrayList < Integer > p = new ArrayList < > ( ) ; int res = getMaxUtil ( p , arr , ans , chosen , N ) ; System . out . println ( res ) ; }
long multiplyByMersenne ( long N , long M ) { long x = ( int ) ( Math . log ( M + 1 ) / Math . log ( 2 ) ) ; return ( ( N << x ) - N ) ; }
void findSum ( int N , int K ) { int ans = 0 ; int i = 1 ; while ( i <= N ) { ans += N / i ; i = i * K ; } System . out . println ( ans ) ; }
void minimumInsertions ( int arr [ ] , int N , int K ) { boolean possible = true ; int res = 0 ; int last = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= K ) { possible = false ; break ; } if ( last + arr [ i ] > K ) res ++ ; last = arr [ i ] ; } if ( possible ) { System . out . print ( res ) ; } else { System . out . print ( "-1" ) ; } }
int maxSubSum ( int arr [ ] , int n , int k , int totalDistinct ) { if ( k > n ) return 0 ; int max = 0 , sum = 0 ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { sum = 0 ; Set < Integer > set = new HashSet < > ( ) ; for ( int j = i ; j < i + k ; j ++ ) { sum += arr [ j ] ; set . add ( arr [ j ] ) ; } if ( set . size ( ) == totalDistinct ) max = Math . max ( sum , max ) ; } return max ; }
int distinct ( int arr [ ] , int N ) { Set < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { set . add ( arr [ i ] ) ; } return set . size ( ) ; }
int maxSubarraySumUtil ( int arr [ ] , int N , int K , int totalDistinct ) { if ( K > N ) return 0 ; int max = 0 ; int sum = 0 ; Map < Integer , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { map . put ( arr [ i ] , map . getOrDefault ( arr [ i ] , 0 ) + 1 ) ; sum += arr [ i ] ; if ( i >= K ) { map . put ( arr [ i - K ] , map . get ( arr [ i - K ] ) - 1 ) ; sum -= arr [ i - K ] ; if ( map . get ( arr [ i - K ] ) == 0 ) map . remove ( arr [ i - K ] ) ; } if ( map . size ( ) == totalDistinct ) max = Math . max ( max , sum ) ; } return max ; }
void maxSubarraySum ( int arr [ ] , int K ) { int N = arr . length ; int totalDistinct = distinct ( arr , N ) ; System . out . println ( maxSubarraySumUtil ( arr , N , K , totalDistinct ) ) ; }
int irreflexiveRelation ( int N ) { return power ( 2 , N * N - N ) ; }
void countAPs ( long N ) { long count = 0 ; for ( long i = 1 ; i * i <= 2 * N ; i ++ ) { long res = 2 * N ; if ( res % i == 0 ) { long op = res / i - i + 1 ; if ( op % 2 == 0 ) { count ++ ; } if ( i * i != res && ( i - res / i + 1 ) % 2 == 0 ) { count ++ ; } } } System . out . println ( count - 1 ) ; }
int perfectSquare ( int num ) { int sr = ( int ) ( Math . sqrt ( num ) ) ; int a = sr * sr ; int b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( num - a ) < ( b - num ) ) { return a ; } else { return b ; } }
int powerOfTwo ( int num ) { int lg = ( int ) ( Math . log ( num ) / Math . log ( 2 ) ) ; int p = ( int ) ( Math . pow ( 2 , lg ) ) ; return p ; }
void uniqueElement ( int arr [ ] , int N ) { boolean ans = true ; HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq . containsKey ( arr [ i ] ) ) { freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . put ( arr [ i ] , 1 ) ; } } for ( Map . Entry < Integer , Integer > el : freq . entrySet ( ) ) { if ( el . getValue ( ) == 1 ) { ans = false ; int ps = perfectSquare ( el . getKey ( ) ) ; System . out . print ( powerOfTwo ( ps ) + " " ) ; } } if ( ans ) System . out . print ( "-1" ) ; }
boolean canExpress ( int N ) { int temp = N ; int n = 0 ; while ( N != 0 ) { N /= 10 ; n ++ ; } N = temp ; int sum = 0 ; while ( N != 0 ) { sum += ( ( int ) Math . pow ( N % 10 , n ) ) ; N /= 10 ; } if ( sum == temp ) return true ; return false ; }
void precompute ( ) { for ( int i = 1 ; i < R ; i ++ ) { if ( canExpress ( i ) ) { arr [ i ] = 1 ; } } for ( int i = 1 ; i < R ; i ++ ) { arr [ i ] += arr [ i - 1 ] ; } }
void countNumbers ( int [ ] [ ] queries , int N ) { precompute ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int L1 = queries [ i ] [ 0 ] ; int R1 = queries [ i ] [ 1 ] ; System . out . print ( ( arr [ R1 ] - arr [ L1 - 1 ] ) + " " ) ; } }
boolean isAnyPrime ( int first , int last ) { int num1 = first * 10 + last ; int num2 = last * 10 + first ; if ( sieve [ num1 ] == 1 sieve [ num2 ] == 1 ) return true ; else return false ; }
void sumOfNodeInAPath ( int node_value ) { int sum_of_node = 0 ; while ( node_value > 0 ) { sum_of_node += node_value ; node_value /= 2 ; } System . out . print ( sum_of_node ) ; }
void findSum ( ArrayList < Integer > Q ) { for ( int i = 0 ; i < Q . size ( ) ; i ++ ) { int node_value = Q . get ( i ) ; sumOfNodeInAPath ( node_value ) ; System . out . print ( " " ) ; } }
String oddDivisor ( int N ) { int X = N ; while ( N % 2 == 0 ) { N /= 2 ; } for ( int i = 3 ; i * i <= X ; i += 2 ) { if ( N % i == 0 ) { return "Yes" ; } } if ( N != X ) { return "Yes" ; } return "No" ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
void preprocess ( ) { for ( int i = 1 ; i <= 1000000 ; i ++ ) primes [ i ] = i ; for ( int i = 2 ; i * i <= 1000000 ; i ++ ) { if ( primes [ i ] == i ) { for ( int j = 2 * i ; j <= 1000000 ; j += i ) { if ( primes [ j ] == j ) primes [ j ] = i ; } } } }
int Steps ( int x , int m ) { int steps = 0 ; boolean flag = false ; while ( x > 1 ) { if ( primes [ x ] > m ) { flag = true ; break ; } x /= primes [ x ] ; steps ++ ; } if ( flag ) return - 1 ; return steps ; }
int minimumSteps ( int x , int y , int m ) { preprocess ( ) ; int g = gcd ( x , y ) ; x = x / g ; y = y / g ; int x_steps = Steps ( x , m ) ; int y_steps = Steps ( y , m ) ; if ( x_steps == - 1 y_steps == - 1 ) return - 1 ; return x_steps + y_steps ; }
int LongestNonDeficientSubsequence ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isNonDeficient ( arr [ i ] ) ) { res += 1 ; } } return res ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 , num = 2 ; i <= n ; num ++ ) { if ( countPrimeFactors ( num ) == 2 ) { sum += num ; i ++ ; } } return sum ; }
void check ( int n , int k ) { int s = findSum ( k - 1 ) ; if ( s >= n ) System . out . print ( "No" ) ; else System . out . print ( "Yes" ) ; }
int setBitCount ( int n ) { int ans = 0 ; while ( n != 0 ) { ans += n & 1 ; n >>= 1 ; } return ans ; }
boolean isPronic ( int n ) { int range = ( int ) Math . sqrt ( n ) ; for ( int i = 0 ; i < range + 1 ; i ++ ) { if ( i * ( i + 1 ) == n ) return true ; } return false ; }
int LOG ( int a , int b ) { return ( int ) ( Math . log ( a ) / Math . log ( b ) ) ; }
void countSubsequences ( int [ ] A ) { int odd = 0 ; int even = 0 ; for ( int el : A ) { if ( el % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 ) System . out . println ( 0 ) ; else System . out . println ( 1 << ( A . length - 1 ) ) ; }
int gcd ( int a , int b ) { while ( b > 0 ) { int rem = a % b ; a = b ; b = rem ; } return a ; }
int countNumberOfWays ( int n ) { if ( n == 1 ) return - 1 ; int g = 0 ; int power = 0 ; while ( n % 2 == 0 ) { power ++ ; n /= 2 ; } g = gcd ( g , power ) ; for ( int i = 3 ; i <= ( int ) Math . sqrt ( n ) ; i += 2 ) { power = 0 ; while ( n % i == 0 ) { power ++ ; n /= i ; } g = gcd ( g , power ) ; } if ( n > 2 ) g = gcd ( g , 1 ) ; int ways = 1 ; power = 0 ; while ( g % 2 == 0 ) { g /= 2 ; power ++ ; } ways *= ( power + 1 ) ; for ( int i = 3 ; i <= ( int ) Math . sqrt ( g ) ; i += 2 ) { power = 0 ; while ( g % i == 0 ) { power ++ ; g /= i ; } ways *= ( power + 1 ) ; } if ( g > 2 ) ways *= 2 ; return ways ; }
boolean coprime ( int a , int b ) { if ( GCD ( a , b ) == 1 ) return true ; return false ; }
void noOfCoPrimePairs ( int N , int d1 , int d2 ) { ArrayList < String > l = new ArrayList < String > ( ) ; l . add ( Integer . toString ( d1 ) ) ; l . add ( Integer . toString ( d2 ) ) ; Collections . sort ( l ) ; if ( N < Integer . parseInt ( l . get ( 1 ) ) ) return ; ArrayList < String > total = new ArrayList < String > ( l ) ; ArrayList < String > temp2 = new ArrayList < String > ( l ) ; int flag = 0 ; ArrayList < String > temp3 = new ArrayList < String > ( l ) ; while ( l . get ( 0 ) . length ( ) < 10 ) { for ( int i = 0 ; i < l . size ( ) ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { if ( Integer . parseInt ( l . get ( i ) + temp2 . get ( j ) ) > N ) { flag = 1 ; break ; } total . add ( l . get ( i ) + temp2 . get ( j ) ) ; temp3 . add ( l . get ( i ) + temp2 . get ( j ) ) ; } if ( flag == 1 ) break ; } if ( flag == 1 ) break ; l = temp3 ; temp3 . clear ( ) ; } int lenOfTotal = total . size ( ) ; int ans = numOfPairs ( total , lenOfTotal ) ; System . out . print ( ans ) ; }
void countEqualElementPairs ( int arr [ ] , int N ) { HashMap < Integer , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { Integer k = map . get ( arr [ i ] ) ; map . put ( arr [ i ] , ( k == null ) ? 1 : k + 1 ) ; } int total = 0 ; for ( Map . Entry < Integer , Integer > e : map . entrySet ( ) ) { total += ( e . getValue ( ) * ( e . getValue ( ) - 1 ) ) / 2 ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( total - ( map . get ( arr [ i ] ) - 1 ) + " " ) ; } }
void minDeletions ( int arr [ ] , int N ) { HashMap < Integer , Integer > map = new HashMap < > ( ) ; ; for ( int i = 0 ; i < N ; i ++ ) { Integer k = map . get ( arr [ i ] ) ; map . put ( arr [ i ] , ( k == null ) ? 1 : k + 1 ) ; } ArrayList < Integer > v = new ArrayList < > ( ) ; for ( Map . Entry < Integer , Integer > e : map . entrySet ( ) ) { v . add ( e . getValue ( ) ) ; } Collections . sort ( v ) ; int size = v . size ( ) ; int ans = N - ( v . get ( 0 ) * size ) ; for ( int i = 1 ; i < v . size ( ) ; i ++ ) { if ( v . get ( i ) != v . get ( i - 1 ) ) { int safe = v . get ( i ) * ( size - i ) ; ans = Math . min ( ans , N - safe ) ; } } System . out . println ( ans ) ; }
int countPairs ( int [ ] arr , int N ) { int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) odd ++ ; } int ans = ( N - odd + odd / 2 - 1 ) + odd / 2 ; return ans ; }
int countBit ( int n ) { return ( int ) ( ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ) ; }
int countSetBit ( int n ) { int ans = 0 ; while ( n > 0 ) { ans += ( n & 1 ) ; n >>= 1 ; } return ans ; }
int maximize ( int n ) { int bits = countBit ( n ) ; int setBits = countSetBit ( n ) ; int ans = 0 ; for ( int i = 0 ; i < bits ; i ++ ) { if ( i < setBits ) ans |= 1 ; if ( i != setBits - 1 ) ans <<= 1 ; } return ans ; }
int minimize ( int n ) { int setBits = countSetBit ( n ) ; int ans = 0 ; for ( int i = 0 ; i < setBits ; i ++ ) { ans |= 1 ; if ( i != setBits - 1 ) ans <<= 1 ; } return ans ; }
int maxDiff ( int [ ] arr ) { int caseOne = 0 ; int SumOfOdd = 0 ; int SumOfeven = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( ( i % 2 ) != 0 ) SumOfOdd += minimize ( arr [ i ] ) ; else SumOfeven += maximize ( arr [ i ] ) ; } caseOne = Math . abs ( SumOfOdd - SumOfeven ) ; int caseTwo = 0 ; SumOfOdd = 0 ; SumOfeven = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( ( i % 2 ) != 0 ) SumOfOdd += maximize ( arr [ i ] ) ; else SumOfeven += minimize ( arr [ i ] ) ; } caseTwo = Math . abs ( SumOfOdd - SumOfeven ) ; return Math . max ( caseOne , caseTwo ) ; }
boolean isVowel ( char c ) { String vowel = "aeiou" ; for ( int i = 0 ; i < vowel . length ( ) ; ++ i ) if ( vowel . charAt ( i ) == c ) return true ; return false ; }
boolean printRLE ( String str , String typed ) { int n = str . length ( ) , m = typed . length ( ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) != typed . charAt ( j ) ) return false ; if ( isVowel ( str . charAt ( i ) ) == false ) { j ++ ; continue ; } int count1 = 1 ; while ( i < n - 1 && str . charAt ( i ) == str . charAt ( i + 1 ) ) { count1 ++ ; i ++ ; } int count2 = 1 ; while ( j < m - 1 && typed . charAt ( j ) == str . charAt ( i ) ) { count2 ++ ; j ++ ; } if ( count1 > count2 ) return false ; } return true ; }
void findSplit ( int [ ] arr , int N ) { int l = 1 , r = N - 2 ; int lsum , msum , rsum ; int sum [ ] = new int [ N ] ; sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { sum [ i ] = sum [ i - 1 ] + arr [ i ] ; } while ( l < r ) { lsum = sum [ l - 1 ] ; msum = sum [ r - 1 ] - sum [ l ] ; rsum = sum [ N - 1 ] - sum [ r ] ; if ( lsum == msum && msum == rsum ) { System . out . println ( l + " " + r ) ; return ; } if ( lsum < rsum ) l ++ ; else if ( lsum > rsum ) r -- ; else { l ++ ; r -- ; } } System . out . println ( - 1 ) ; }
int solve ( int [ ] A , int n , int Q [ ] , int q ) { int one = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( A [ i ] == 1 ) one ++ ; int glows = 0 , count = 0 ; if ( one >= ( int ) Math . ceil ( n / 2 ) ) glows = 1 ; for ( int i = 0 ; i < q ; i ++ ) { int prev = glows ; if ( A [ Q [ i ] - 1 ] == 1 ) one -- ; if ( A [ Q [ i ] - 1 ] == 0 ) one ++ ; A [ Q [ i ] - 1 ] ^= 1 ; if ( one >= ( int ) Math . ceil ( n / 2.0 ) ) { glows = 1 ; } else { glows = 0 ; } if ( prev != glows ) count ++ ; } return count ; }
void elementsHavingDigitSumK ( int [ ] arr , int N , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; ++ i ) { if ( sumOfDigits ( arr [ i ] ) == K ) { count ++ ; } } System . out . println ( count ) ; }
int processDiagonal ( ArrayList < Integer > arr ) { int ans = 0 ; int getBit = 1 ; for ( int i = 0 ; i < 32 ; i ++ ) { int S = 0 ; int NS = 0 ; for ( int j : arr ) { if ( ( getBit & j ) != 0 ) S += 1 ; else NS += 1 ; } if ( S > NS ) ans += Math . pow ( 2 , i ) ; getBit <<= 1 ; } return ans ; }
int findSum ( int [ ] [ ] mat ) { int i = 0 ; int j = 0 ; ArrayList < Integer > priDiag = new ArrayList < Integer > ( ) ; while ( i < mat . length ) { priDiag . add ( mat [ i ] [ j ] ) ; i += 1 ; j += 1 ; } i = 0 ; j = mat . length - 1 ; ArrayList < Integer > secDiag = new ArrayList < Integer > ( ) ; while ( i < mat . length ) { secDiag . add ( mat [ i ] [ j ] ) ; i += 1 ; j -= 1 ; } return ( processDiagonal ( priDiag ) + processDiagonal ( secDiag ) ) ; }
void minimumDifference ( int N ) { int sum1 = ( 1 << N ) , sum2 = 0 ; for ( int i = 1 ; i < N / 2 ; i ++ ) sum1 += ( 1 << i ) ; for ( int i = N / 2 ; i < N ; i ++ ) sum2 += ( 1 << i ) ; System . out . println ( sum1 - sum2 ) ; }
