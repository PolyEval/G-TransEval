int isPerfect ( int N ) { int sumOfDivisors = 1 ; for ( int i = 2 ; i <= N / 2 ; ++ i ) { if ( N % i == 0 ) { sumOfDivisors += i ; } } if ( sumOfDivisors == N ) { return 1 ; } else return 0 ; }
void countPerfectNumbers ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; ++ i ) { if ( isPerfect ( arr [ i ] ) ) { int sum = sumOfDigits ( arr [ i ] ) ; if ( isPerfect ( sum ) ) { cout << arr [ i ] << " " ; } } } }
bool issafe ( int m , int n , int i , int j ) { if ( i < 0 ) return false ; if ( j < 0 ) return false ; if ( i >= m ) return false ; if ( j >= n ) return false ; return true ; }
pair < int , int > endpoints ( vector < vector < int > > arr , int m , int n ) { int i = 0 ; int j = 0 ; int current_i = 0 ; int current_j = 0 ; char current_d = 'r' ; map < char , char > rcd = { { 'l' , 'u' } , { 'u' , 'r' } , { 'r' , 'd' } , { 'd' , 'l' } } ; while ( issafe ( m , n , i , j ) ) { current_i = i ; current_j = j ; if ( arr [ i ] [ j ] == 1 ) { char move_in = rcd [ current_d ] ; arr [ i ] [ j ] = 0 ; if ( move_in == 'u' ) i -= 1 ; else if ( move_in == 'd' ) i += 1 ; else if ( move_in == 'l' ) j -= 1 ; else if ( move_in == 'r' ) j += 1 ; current_d = move_in ; } else { if ( current_d == 'u' ) i -= 1 ; else if ( current_d == 'd' ) i += 1 ; else if ( current_d == 'l' ) j -= 1 ; else if ( current_d == 'r' ) j += 1 ; } } return { current_i , current_j } ; }
int maxPresum ( vector < int > a , vector < int > b ) { int X = max ( a [ 0 ] , 0 ) ; for ( int i = 1 ; i < a . size ( ) ; i ++ ) { a [ i ] += a [ i - 1 ] ; X = max ( X , a [ i ] ) ; } int Y = max ( b [ 0 ] , 0 ) ; for ( int i = 1 ; i < b . size ( ) ; i ++ ) { b [ i ] += b [ i - 1 ] ; Y = max ( Y , b [ i ] ) ; } return X + Y ; }
int findSum ( TreeNode * root ) { queue < TreeNode * > que ; que . push ( root ) ; int ans = 0 ; while ( que . size ( ) ) { int leaf = 0 ; int nonleaf = 0 ; int length = que . size ( ) ; while ( length ) { auto temp = que . front ( ) ; que . pop ( ) ; if ( ! temp -> left && ! temp -> right ) leaf += temp -> val ; else nonleaf += temp -> val ; if ( temp -> left ) que . push ( temp -> left ) ; if ( temp -> right ) que . push ( temp -> right ) ; length -= 1 ; } ans += leaf & nonleaf ; } return ans ; }
void fizzBuzz ( int N ) { int count3 = 0 ; int count5 = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { count3 ++ ; count5 ++ ; bool flag = false ; if ( count3 == 3 ) { cout << "Fizz" ; count3 = 0 ; flag = true ; } if ( count5 == 5 ) { cout << "Buzz" ; count5 = 0 ; flag = true ; } if ( ! flag ) { cout << i ; } cout << " " ; } }
void checkElementsOnDiagonal ( vector < vector < int > > M , int N ) { int flag = 1 ; SieveOfEratosthenes ( 1000000 ) ; for ( int i = 0 ; i < N ; i ++ ) { flag &= ( prime [ M [ i ] [ i ] ] && prime [ M [ i ] [ N - 1 - i ] ] ) ; } if ( flag ) cout << "Yes" << endl ; else cout << "No" ; }
vector < int > circularPermutation ( int n , int start ) { vector < int > res = { 0 } ; vector < int > ret ; int index = -1 ; for ( int k = 0 , add = 1 << k ; k < n ; k ++ , add = 1 << k ) { for ( int i = res . size ( ) - 1 ; i >= 0 ; i -- ) { if ( res [ i ] + add == start ) index = res . size ( ) ; res . push_back ( res [ i ] + add ) ; } } if ( start == 0 ) return res ; while ( ret . size ( ) < res . size ( ) ) { ret . push_back ( res [ index ] ) ; index = ( index + 1 ) % res . size ( ) ; } return ret ; }
int countPairs ( int a [ ] , int n ) { int count = 0 ; map < double , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { int y = a [ i ] ; if ( y != 0 && y != 1 ) { double x = ( ( y * 1.0 ) / ( 1 - y ) ) * y ; count += mp [ x ] ; } mp [ y ] ++ ; } return count ; }
void sieveOfPrimes ( ) { memset ( sieve , 1 , sizeof ( sieve ) ) ; int N = 1000000 ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( sieve [ i ] == 0 ) continue ; for ( int j = i * i ; j <= N ; j += i ) sieve [ j ] = 0 ; } }
void getArray ( int * arr , int N ) { int A [ N ] = { 0 } ; vector < int > v ; sieveOfPrimes ( ) ; for ( int i = 2 ; i <= 1e5 ; i ++ ) if ( sieve [ i ] ) v . push_back ( i ) ; int j = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int ind = arr [ i ] ; if ( A [ i ] != 0 ) continue ; else if ( A [ ind ] != 0 ) A [ i ] = A [ ind ] ; else { int prime = v [ j ++ ] ; A [ i ] = prime ; A [ ind ] = A [ i ] ; } } for ( int i = 0 ; i < N ; i ++ ) { cout << A [ i ] << " " ; } }
bool contains ( int num , int K , int base ) { bool isThere = 0 ; while ( num ) { int remainder = num % base ; if ( remainder == K ) { isThere = 1 ; } num /= base ; } return isThere ; }
int numberOfTiles ( int N , int M ) { if ( N % 2 == 1 ) { return -1 ; } return ( N * 1LL * M ) / 2 ; }
void canMakeEqual ( int arr1 [ ] , int arr2 [ ] , int N ) { int count = 0 ; int arr1_one = 0 , arr1_zero = 0 ; int arr2_one = 0 , arr2_zero = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr1 [ i ] == 1 ) { arr1_one ++ ; } else if ( arr1 [ i ] == 0 ) { arr1_zero ++ ; } if ( arr2 [ i ] == 1 ) { arr2_one ++ ; } else if ( arr2 [ i ] == 0 ) { arr2_zero ++ ; } } if ( arr1_one != arr2_one arr1_zero != arr2_zero ) { cout << "No" ; return ; } for ( int i = 0 ; i < N ; i ++ ) { count = count + ( arr1 [ i ] - arr2 [ i ] ) ; if ( count < 0 ) { cout << "No" ; return ; } } cout << "Yes" ; }
long long findNthNumber ( long long N ) { long long result = 0 ; long long p = 1 ; while ( N > 0 ) { result += ( p * ( N % 9 ) ) ; N = N / 9 ; p = p * 10 ; } return result ; }
int cntMaxOperationToMakeN_1_0 ( int arr [ ] , int N ) { int cntOp = 0 ; priority_queue < int > PQ ; for ( int i = 0 ; i < N ; i ++ ) { PQ . push ( arr [ i ] ) ; } while ( PQ . size ( ) > 1 ) { int X = PQ . top ( ) ; PQ . pop ( ) ; int Y = PQ . top ( ) ; PQ . pop ( ) ; X -- ; Y -- ; if ( X != 0 ) { PQ . push ( X ) ; } if ( Y != 0 ) { PQ . push ( Y ) ; } cntOp += 1 ; } return cntOp ; }
void checkSamePosition ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { int temp = ( ( i + arr [ i ] ) % n + n ) % n ; if ( mp . find ( temp ) != mp . end ( ) ) { cout << "Yes" ; return ; } mp [ temp ] ++ ; } cout << "No" ; }
void sumFib ( int N ) { long num = ( long ) round ( pow ( ( sqrt ( 5 ) + 1 ) / 2.0 , N + 2 ) / sqrt ( 5 ) ) ; cout << ( num - 1 ) ; }
void sumFib ( int N ) { double num = ( 1 - sqrt ( 5 ) ) / 2 ; long val = round ( abs ( 1 / ( pow ( num , N + 2 ) + pow ( num , N + 1 ) + pow ( num , N ) + pow ( num , N - 1 ) ) ) - 1 ) ; cout << val ; }
void poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { cout << ceil ( log ( buckets ) / log ( ( minutesToTest / minutesToDie ) + 1 ) ) ; }
int countTrailingZeroes ( int N ) { int res = log2 ( N ^ ( N - 1 ) ) ; return res >= 0 ? res : 0 ; }
void maxProduct ( int arr [ ] , int N ) { int max_product = INT_MIN ; int prefix_sum = 0 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { prefix_sum += arr [ i ] ; int X = prefix_sum ; int Y = sum - prefix_sum ; max_product = max ( max_product , X * Y ) ; } cout << max_product ; }
int findMask ( int K ) { int mask = 1 ; while ( ( K & mask ) == 0 ) { mask = mask << 1 ; } return mask ; }
void sameRightSetBitPos ( int arr [ ] , int N , int K ) { int mask = findMask ( K ) ; int pos = ( K & mask ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & mask ) == pos ) cout << arr [ i ] << " " ; } }
void countPronic ( int A , int B ) { int count = 0 ; for ( int i = A ; i <= B ; i ++ ) { if ( checkPronic ( i ) ) { count ++ ; } } cout << count ; }
int pronic ( int num ) { int N = ( int ) sqrt ( num ) ; if ( N * ( N + 1 ) <= num ) { return N ; } return N - 1 ; }
int countPronic ( int A , int B ) { return pronic ( B ) - pronic ( A - 1 ) ; }
void sameProductQuadruples ( int nums [ ] , int N ) { unordered_map < int , int > umap ; int res = 0 ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = i + 1 ; j < N ; ++ j ) { int prod = nums [ i ] * nums [ j ] ; res += 8 * umap [ prod ] ; ++ umap [ prod ] ; } } cout << res ; }
void productExceptSelf ( int arr [ ] , int N ) { int product = 1 ; int z = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] ) product *= arr [ i ] ; z += ( arr [ i ] == 0 ) ; } int a = abs ( product ) , b ; for ( int i = 0 ; i < N ; i ++ ) { if ( z == 1 ) { if ( arr [ i ] ) arr [ i ] = 0 ; else arr [ i ] = product ; continue ; } else if ( z > 1 ) { arr [ i ] = 0 ; continue ; } int b = abs ( arr [ i ] ) ; int curr = round ( exp ( log ( a ) - log ( b ) ) ) ; if ( arr [ i ] < 0 && product < 0 ) arr [ i ] = curr ; else if ( arr [ i ] > 0 && product > 0 ) arr [ i ] = curr ; else arr [ i ] = -1 * curr ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << " " ; } }
int getMax ( vector < int > arr , int ans , vector < bool > chosen , int N ) { if ( arr . size ( ) == N ) { ans = max ( ans , calcScr ( arr ) ) ; return ans ; } for ( int i = 0 ; i < N ; i ++ ) { if ( chosen [ i ] ) continue ; chosen [ i ] = true ; arr . push_back ( i ) ; ans = getMax ( arr , ans , chosen , N ) ; chosen [ i ] = false ; arr . pop_back ( ) ; } return ans ; }
int singleDigitSubarrayCount ( int arr [ ] , int N ) { int res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } cout << res ; }
int maxSumAfterKReverse ( int arr [ ] , int K , int N ) { int sum = INT_MIN ; if ( K & 1 ) reverse ( arr , arr + N ) ; int currsum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { currsum += arr [ i ] ; sum = max ( sum , currsum ) ; } cout << sum ; }
bool isPossible ( int N ) { return ( ( N & ( N - 1 ) ) && N ) ; }
void countElements ( int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( isPossible ( i ) ) count ++ ; } cout << count ; }
void countElements ( int N ) { int Cur_Ele = 1 ; int Count = 0 ; while ( Cur_Ele <= N ) { Count ++ ; Cur_Ele = Cur_Ele * 2 ; } cout << N - Count ; }
void SubMasks ( int N ) { for ( int S = N ; S ; S = ( S - 1 ) & N ) { cout << S << " " ; } }
long long int power ( int x , int y ) { long long int res = 1 ; x = x % MOD ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % MOD ; y = y >> 1 ; x = ( x * x ) % MOD ; } return res ; }
void countPairs ( int N ) { long long int high = power ( 2 , N ) ; int count = 0 ; for ( int i = 0 ; i < high ; i ++ ) { for ( int j = 0 ; j < high ; j ++ ) { int X = ( i ^ j ) ; int Y = ( i j ) ; if ( X == Y ) { count ++ ; } } } cout << count % MOD << endl ; }
long long int power ( int x , int y ) { long long int res = 1 ; x = x % MOD ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % MOD ; y = y >> 1 ; x = ( x * x ) % MOD ; } return res ; }
void countPairs ( int N ) { cout << power ( 3 , N ) ; }
int minSum ( int A [ ] , int N ) { map < int , int > mp ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; mp [ A [ i ] ] ++ ; } int minSum = INT_MAX ; for ( auto it : mp ) { minSum = min ( minSum , sum - ( it . first * it . second ) ) ; } return minSum ; }
int minimumMoves ( int * a , int n ) { int min_element = INT_MAX ; int max_element = INT_MIN ; int min_ind = -1 ; int max_ind = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] <= min_element ) { min_element = a [ i ] ; min_ind = i ; } if ( a [ i ] > max_element ) { max_element = a [ i ] ; max_ind = i ; } } if ( max_ind == min_ind ) { return 0 ; } else if ( max_ind > min_ind ) { return max_ind + ( n - min_ind - 2 ) ; } else { return max_ind + n - min_ind - 1 ; } }
void isCycleExists ( int arr [ ] , int N ) { bool valley = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { cout << "Yes" << endl ; return ; } } cout << "No" ; }
int findIndex ( int arr [ ] , int n , int K ) { int sum = 0 ; int res = -1 ; int mini = 1e9 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { int temp = sum - arr [ i ] ; if ( temp % K == 0 ) { if ( res == -1 mini > arr [ i ] ) { res = i + 1 ; mini = arr [ i ] ; } } } return res ; }
int minimumIncrement ( int arr [ ] , int N ) { if ( N % 2 != 0 ) { cout << "-1" ; exit ( 0 ) ; } int cntEven = 0 ; int cntOdd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { cntEven += 1 ; } } cntOdd = N - cntEven ; return abs ( cntEven - cntOdd ) / 2 ; }
void divisionalArrays ( int arr [ 3 ] , int N ) { int sum = N ; unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } for ( auto x : mp ) { if ( x . second > 1 ) { sum += x . second - 1 ; } } cout << sum << endl ; }
void totalInversions ( int arr [ ] , int K , int N ) { int inv = 0 ; int X = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] > arr [ j ] and i < j ) inv ++ ; if ( arr [ i ] > arr [ j ] ) X ++ ; } } int totalInv = X * K * ( K - 1 ) / 2 + inv * K ; cout << totalInv << endl ; }
int findSize ( int N ) { if ( N == 0 ) return 1 ; if ( N == 1 ) return 1 ; int Size = 2 * findSize ( N / 2 ) + 1 ; return Size ; }
int CountOnes ( int N , int L , int R ) { if ( L > R ) { return 0 ; } if ( N <= 1 ) { return N ; } int ret = 0 ; int M = N / 2 ; int Siz_M = findSize ( M ) ; if ( L <= Siz_M ) { ret += CountOnes ( N / 2 , L , min ( Siz_M , R ) ) ; } if ( L <= Siz_M + 1 && Siz_M + 1 <= R ) { ret += N % 2 ; } if ( Siz_M + 1 < R ) { ret += CountOnes ( N / 2 , max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) ; } return ret ; }
long long int Fact ( int N ) { long long int result = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { result = ( result * i ) ; } return result ; }
void numberOfWays ( int M , int arr [ ] , int N ) { int B [ M ] = { 0 } ; int counter [ M + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != 0 ) { if ( B [ i % M ] == 0 ) { B [ i % M ] = arr [ i ] ; counter [ arr [ i ] ] ++ ; if ( counter [ arr [ i ] ] > 1 ) { cout << 0 << endl ; return ; } } else if ( B [ i % M ] != arr [ i ] ) { cout << 0 << endl ; return ; } } } int cnt = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( B [ i ] == 0 ) { cnt ++ ; } } cout << Fact ( cnt ) << endl ; }
int getMax ( int arr [ ] , int N , int K ) { for ( int i = 1 ; i < N ; i ++ ) { int cur_val = arr [ i ] ; while ( K >= i ) { if ( cur_val > 0 ) { arr [ 0 ] = arr [ 0 ] + 1 ; cur_val = cur_val - 1 ; K = K - i ; } else break ; } } cout << arr [ 0 ] ; }
int MaximumSum ( vector < vector < int > > & arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = 0 , y = i , sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ x ++ ] [ y ++ ] ; } if ( sum > ans ) ans = sum ; } for ( int i = 1 ; i < n ; i ++ ) { int x = i , y = 0 , sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ x ++ ] [ y ++ ] ; } if ( sum > ans ) ans = sum ; } return ans ; }
int numberOfIntegers ( int arr [ ] , int N ) { int cur_max = 0 , count = 0 ; if ( N == 1 ) { count = 1 ; } else { for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] > cur_max ) { cur_max = arr [ i ] ; if ( arr [ i ] > arr [ i + 1 ] ) { count ++ ; } } } if ( arr [ N - 1 ] > cur_max ) count ++ ; } cout << count ; }
int numberOfWays ( int n , int k ) { if ( n == 0 ) return 1 ; if ( k == 0 ) return 1 ; if ( n >= pow ( 2 , k ) ) { int curr_val = pow ( 2 , k ) ; return numberOfWays ( n - curr_val , k ) + numberOfWays ( n , k - 1 ) ; } else return numberOfWays ( n , k - 1 ) ; }
long long int possibleTriplets ( int arr [ ] , int N ) { int freq = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { freq ++ ; } } return ( freq * 1LL * ( freq - 1 ) * ( freq - 2 ) ) / 6 ; }
void build ( int tree [ ] , int arr [ ] , int start , int end , int index ) { if ( start == end ) { if ( start % 2 == 0 ) { tree [ index ] = arr [ start ] ; } else { tree [ index ] = - arr [ start ] ; } return ; } int mid = start + ( end - start ) / 2 ; build ( tree , arr , start , mid , 2 * index + 1 ) ; build ( tree , arr , mid + 1 , end , 2 * index + 2 ) ; tree [ index ] = tree [ 2 * index + 1 ] + tree [ 2 * index + 2 ] ; }
void update ( int tree [ ] , int index , int start , int end , int pos , int val ) { if ( start == end ) { if ( start % 2 == 0 ) { tree [ index ] = val ; } else { tree [ index ] = - val ; } return ; } int mid = start + ( end - start ) / 2 ; if ( mid >= pos ) { update ( tree , 2 * index + 1 , start , mid , pos , val ) ; } else { update ( tree , 2 * index + 2 , mid + 1 , end , pos , val ) ; } tree [ index ] = tree [ 2 * index + 1 ] + tree [ 2 * index + 2 ] ; }
int FindSum ( int tree [ ] , int start , int end , int L , int R , int index ) { if ( L > end R < start ) { return 0 ; } if ( L <= start && R >= end ) { return tree [ index ] ; } int mid = start + ( end - start ) / 2 ; int X = FindSum ( tree , start , mid , L , R , 2 * index + 1 ) ; int Y = FindSum ( tree , mid + 1 , end , L , R , 2 * index + 2 ) ; return X + Y ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int DistinctValues ( int arr [ ] , int N ) { int max_value = INT_MIN ; for ( int i = 0 ; i < N ; ++ i ) { max_value = max ( max_value , arr [ i ] ) ; } int GCDArr = arr [ 0 ] ; for ( int i = 1 ; i < N ; ++ i ) { GCDArr = gcd ( GCDArr , arr [ i ] ) ; } int answer = ( max_value / GCDArr ) + 1 ; return answer ; }
void findDay ( int Y , int B ) { int lyear , rest , totaldays , day ; Y = ( Y - 1 ) - B ; lyear = Y / 4 ; rest = Y - lyear ; totaldays = ( rest * 365 ) + ( lyear * 366 ) + 1 ; day = ( totaldays % 7 ) ; if ( day == 0 ) printf ( "Monday" ) ; else if ( day == 1 ) printf ( "Tuesday" ) ; else if ( day == 2 ) printf ( "Wednesday" ) ; else if ( day == 3 ) printf ( "Thursday" ) ; else if ( day == 4 ) printf ( "Friday" ) ; else if ( day == 5 ) printf ( "Saturday" ) ; else if ( day == 6 ) printf ( "Sunday" ) ; else printf ( "INPUT YEAR IS WRONG!" ) ; }
int maxPossibleDiff ( vector < int > & arr , int N ) { arr . push_back ( -1 ) ; reverse ( arr . begin ( ) , arr . end ( ) ) ; arr . push_back ( -1 ) ; reverse ( arr . begin ( ) , arr . end ( ) ) ; int maxDiff = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) { maxDiff += arr [ i ] ; } if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { maxDiff -= arr [ i ] ; } } cout << maxDiff ; }
void printArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << " " ; } }
void modifyArray ( int arr [ ] , int N , int Q [ ] [ 2 ] , int cntQuery ) { int arr1 [ N + 1 ] = { 0 } ; int arr2 [ N + 1 ] = { 0 } ; for ( int i = 0 ; i < cntQuery ; i ++ ) { int L = Q [ i ] [ 0 ] + 1 , R = Q [ i ] [ 1 ] + 1 ; arr1 [ L ] ++ ; arr1 [ R + 1 ] -- ; arr2 [ R + 1 ] -= R - L + 1 ; } for ( int i = 1 ; i <= N ; i ++ ) arr1 [ i ] += arr1 [ i - 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) arr2 [ i ] += arr2 [ i - 1 ] + arr1 [ i ] ; for ( int i = 1 ; i <= N ; i ++ ) arr [ i - 1 ] = arr2 [ i ] ; printArray ( arr , N ) ; }
int gcd ( int x , int y ) { if ( y == 0 ) return x ; return gcd ( y , x % y ) ; }
int lcm ( int x , int y ) { return ( x * y ) / gcd ( x , y ) ; }
int minimumCost ( int x , int y ) { int lcm_ = lcm ( x , y ) ; int costx = ( lcm_ - x ) / x ; int costy = ( lcm_ - y ) / y ; return costx + costy ; }
int findProduct ( int number_1 , int number_2 ) { if ( number_1 == INT_MIN or number_2 == INT_MIN ) return 0 ; else return number_1 * number_2 ; }
pair < int , int > calculateProduct ( vector < vector < int > > List , int index ) { int highest = * max_element ( List [ index ] . begin ( ) , List [ index ] . end ( ) ) ; int lowest = * min_element ( List [ index ] . begin ( ) , List [ index ] . end ( ) ) ; if ( index + 1 == List . size ( ) ) { if ( lowest < 0 and highest > = 0 ) return { highest , lowest } ; else if ( lowest <= 0 and highest <= 0 ) return { INT_MIN , lowest } ; else if ( lowest >= 0 and highest >= 0 ) return { highest , INT_MIN } ; } pair < int , int > temp = calculateProduct ( List , index + 1 ) ; int positive = temp . first ; int negative = temp . second ; int highPos = findProduct ( highest , positive ) ; int highNeg = findProduct ( highest , negative ) ; int lowPos = findProduct ( lowest , positive ) ; int lowNeg = findProduct ( lowest , negative ) ; if ( lowest < 0 and highest > = 0 ) return { max ( highPos , lowNeg ) , min ( highNeg , lowPos ) } ; else if ( lowest <= 0 and highest <= 0 ) return { lowNeg , lowPos } ; else if ( lowest >= 0 and highest >= 0 ) return { max ( lowPos , highPos ) , min ( lowNeg , highNeg ) } ; }
void calculateSpan ( int price [ ] , int n , int S [ ] ) { S [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { S [ i ] = 1 ; for ( int j = i - 1 ; ( j >= 0 ) && ( price [ i ] >= price [ j ] ) ; j -- ) S [ i ] ++ ; } }
long long int power ( long long a , long long n , long long int d ) { long long int res = 1 ; while ( n ) { if ( n % 2 ) { res = ( ( res % d ) * ( a % d ) ) % d ; } a = ( ( a % d ) * ( a % d ) ) % d ; n /= 2 ; } return res ; }
long long int gcd ( long long p , long long q , long long n ) { if ( p == q ) { return ( power ( p , n , mod ) + power ( q , n , mod ) ) % mod ; } long long int candidate = 1 ; long long int num = p - q ; long long int sq = sqrt ( num ) ; for ( long long i = 1 ; i <= sq ; ++ i ) { if ( num % i == 0 ) { long long int X = power ( p , n , i ) ; long long int Y = power ( q , n , i ) ; long long int temp = ( X + Y ) % i ; if ( temp == 0 ) { candidate = max ( candidate , i ) ; } temp = ( power ( p , n , num / i ) + power ( q , n , num / i ) ) % ( num / i ) ; if ( temp == 0 ) { candidate = max ( candidate , num / i ) ; } } } return candidate % mod ; }
void minimumSubarrays ( int arr [ ] , int n ) { char current = 'N' ; int answer = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( current == 'N' ) { if ( arr [ i ] < arr [ i - 1 ] ) { current = 'D' ; } else if ( arr [ i ] == arr [ i - 1 ] ) { current = 'N' ; } else { current = 'I' ; } } else if ( current == 'I' ) { if ( arr [ i ] >= arr [ i - 1 ] ) { current = 'I' ; } else { current = 'N' ; answer += 1 ; } } else { if ( arr [ i ] <= arr [ i - 1 ] ) { current = 'D' ; } else { current = 'N' ; answer += 1 ; } } } cout << answer ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int calculateK ( int x , int y ) { int g = gcd ( x , y ) ; int n = y / g ; int res = n ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { res -= ( res / i ) ; while ( n % i == 0 ) n /= i ; } } if ( n != 1 ) res -= ( res / n ) ; return res ; }
void nearestPowerOfTwo ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int lg = log2 ( arr [ i ] ) ; int a = pow ( 2 , lg ) ; int b = pow ( 2 , lg + 1 ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) cout << a << " " ; else cout << b << " " ; } }
void Conversion ( double centi ) { double pixels = ( 96 * centi ) / 2.54 ; cout << fixed << setprecision ( 2 ) << pixels ; }
int minSwaps ( vector < vector < int > > & b ) { int n = b . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( b [ 0 ] [ 0 ] ^ b [ 0 ] [ j ] ^ b [ i ] [ 0 ] ^ b [ i ] [ j ] ) return -1 ; } } int rowSum = 0 ; int colSum = 0 ; int rowSwap = 0 ; int colSwap = 0 ; for ( int i = 0 ; i < n ; i ++ ) { rowSum += b [ i ] [ 0 ] ; colSum += b [ 0 ] [ i ] ; rowSwap += b [ i ] [ 0 ] == i % 2 ; colSwap += b [ 0 ] [ i ] == i % 2 ; } if ( rowSum != n / 2 && rowSum != ( n + 1 ) / 2 ) return -1 ; if ( colSum != n / 2 && colSum != ( n + 1 ) / 2 ) return -1 ; if ( n % 2 == 1 ) { if ( colSwap % 2 ) colSwap = n - colSwap ; if ( rowSwap % 2 ) rowSwap = n - rowSwap ; } else { colSwap = min ( colSwap , n - colSwap ) ; rowSwap = min ( rowSwap , n - rowSwap ) ; } return ( rowSwap + colSwap ) / 2 ; }
void maxNumTrailNine ( int n , int d ) { int res = n ; int cntDigits = log10 ( n ) + 1 ; int p10 = 10 ; for ( int i = 1 ; i <= cntDigits ; i ++ ) { if ( n % p10 >= d ) { break ; } else { res = n - n % p10 - 1 ; } p10 = p10 * 10 ; } cout << res ; }
int MinimumNoOfWays ( int arr [ ] , int n ) { int mini_no_of_ways ; if ( n % 2 == 0 ) { mini_no_of_ways = n / 2 ; } else { mini_no_of_ways = n / 2 + 1 ; } return mini_no_of_ways ; }
void count_setbit ( int N ) { int result = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( 1 << i ) & N ) { result ++ ; } } cout << result << endl ; }
void cntWaysConsArray ( int A [ ] , int N ) { int total = 1 ; int oddArray = 1 ; for ( int i = 0 ; i < N ; i ++ ) { total = total * 3 ; if ( A [ i ] % 2 == 0 ) { oddArray *= 2 ; } } cout << total - oddArray << "\n" ; }
int invertBits ( int n ) { int x = log2 ( n ) ; int m = 1 << x ; m = m | m - 1 ; n = n ^ m ; return n ; }
void invertSum ( int A , int B ) { int temp = countSetBits ( A ) + countSetBits ( B ) ; cout << invertBits ( temp ) << endl ; }
int ValOfTheExpression ( int n ) { int factorial [ n ] = { 0 } ; factorial [ 0 ] = factorial [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { factorial [ i ] = ( ( factorial [ i - 1 ] % mod ) * ( i % mod ) ) % mod ; } int dp [ n ] = { 0 } ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = ( ( dp [ i - 1 ] % mod ) * ( factorial [ i ] % mod ) ) % mod ; } return dp [ n ] ; }
int minChocolates ( int a [ ] , int n ) { int i = 0 , j = 0 ; int res = 0 , val = 1 ; while ( j < n - 1 ) { if ( a [ j ] > a [ j + 1 ] ) { j += 1 ; continue ; } if ( i == j ) res += val ; else { res += get_sum ( val , i , j ) ; } if ( a [ j ] < a [ j + 1 ] ) val += 1 ; else val = 1 ; j += 1 ; i = j ; } if ( i == j ) res += val ; else res += get_sum ( val , i , j ) ; return res ; }
int get_sum ( int peak , int start , int end ) { int count = end - start + 1 ; peak = max ( peak , count ) ; int s = peak + ( ( ( count - 1 ) * count ) >> 1 ) ; return s ; }
vector < int > RemoveElemArr ( vector < int > & arr , int n , int k ) { if ( n == 0 n == 1 ) return arr ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( j < k arr [ i ] > arr [ j - k ] ) { arr [ j ++ ] = arr [ i ] ; } } while ( arr . size ( ) > j ) { arr . pop_back ( ) ; } return arr ; }
void printArray ( vector < int > & arr ) { for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { cout << arr [ i ] << " " ; } }
void UtilRemov ( vector < int > & arr , int n , int k ) { arr = RemoveElemArr ( arr , n , k ) ; printArray ( arr ) ; }
int countNumberHavingKthBitSet ( int N , int K ) { int numbers_rightmost_setbit_K ; for ( int i = 1 ; i <= K ; i ++ ) { int numbers_rightmost_bit_i = ( N + 1 ) / 2 ; N -= numbers_rightmost_bit_i ; if ( i == K ) { numbers_rightmost_setbit_K = numbers_rightmost_bit_i ; } } cout << numbers_rightmost_setbit_K ; }
void pairs_after_removing ( int arr [ ] , int N ) { int cntPairs = 0 ; unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } for ( auto element : mp ) { int i = element . first ; cntPairs += mp [ i ] * ( mp [ i ] - 1 ) / 2 ; } for ( int i = 0 ; i < N ; i ++ ) { int pairs_after_arr_i_removed = cntPairs + 1 - mp [ arr [ i ] ] ; cout << pairs_after_arr_i_removed << ' ' ; } return ; }
int minimumMaxDiff ( vector < int > & nums ) { set < int > s ; for ( int i = 0 ; i < nums . size ( ) ; i ++ ) { if ( nums [ i ] % 2 == 0 ) s . insert ( nums [ i ] ) ; else s . insert ( nums [ i ] * 2 ) ; } int res = * s . rbegin ( ) - * s . begin ( ) ; while ( * s . rbegin ( ) % 2 == 0 ) { int x = * s . rbegin ( ) ; s . erase ( x ) ; s . insert ( x / 2 ) ; res = min ( res , * s . rbegin ( ) - * s . begin ( ) ) ; } return res ; }
int bitwiseXorRange ( int n ) { if ( n % 4 == 0 ) return n ; if ( n % 4 == 1 ) return 1 ; if ( n % 4 == 2 ) return n + 1 ; return 0 ; }
int evenXorRange ( int l , int r ) { int xor_l ; int xor_r ; xor_r = 2 * bitwiseXorRange ( r / 2 ) ; xor_l = 2 * bitwiseXorRange ( ( l - 1 ) / 2 ) ; return xor_l ^ xor_r ; }
long double find_Variance ( int n ) { long long int numerator = n * n - 1 ; long double ans = ( numerator * 1.0 ) / 12 ; return ans ; }
void noOfArraysPossible ( ll N , ll M ) { ll ans = 1 ; for ( ll i = 0 ; i < N ; ++ i ) { ans = ans * ( M - i ) ; } cout << ans ; }
void findSum ( int a , int b , int n ) { int sum = 0 ; int x = a ^ b ; if ( n % 3 == 0 ) { sum = ( n / 3 ) * ( a + b + x ) ; } else if ( n % 3 == 1 ) { sum = ( n / 3 ) * ( a + b + x ) + a ; } else { sum = ( n / 3 ) * ( a + b + x ) + a + b ; } cout << sum ; }
void constructArrayWithGivenLCM ( int N ) { vector < int > newArr ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { newArr . push_back ( i ) ; if ( N / i != i ) { newArr . push_back ( N / i ) ; } } } sort ( newArr . begin ( ) , newArr . end ( ) ) ; for ( auto i : newArr ) { cout << i << " " ; } }
unsigned int onesComplement ( unsigned int n , int maxElement ) { int bits = floor ( log2 ( maxElement ) ) + 1 ; return ( ( 1 << bits ) - 1 ) ^ n ; }
vector < int > calculateFactorial ( int N ) { vector < int > fact ( N + 1 ) ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fact [ i ] = fact [ i - 1 ] * i ; } return fact ; }
int cntWaysSelection ( int arr [ ] , int N , int K , int L , int R ) { int cntWays = 0 ; int cntNum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= L && arr [ i ] <= R ) { cntNum ++ ; } } vector < int > fact = calculateFactorial ( cntNum ) ; for ( int i = K ; i <= cntNum ; i ++ ) { cntWays += fact [ cntNum ] / ( fact [ i ] * fact [ cntNum - i ] ) ; } return cntWays ; }
int TotalAndPair ( int arr [ ] , int N ) { int totalAND = ( 1 << 30 ) - 1 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { totalAND &= arr [ i ] & arr [ j ] ; } } return totalAND ; }
ll getPower ( int p ) { ll res = 1 ; while ( p -- ) { res *= 5 ; } return res ; }
void printFinalPrices ( vector < int > & arr ) { stack < int > minStk ; int n = arr . size ( ) ; vector < int > reduce ( n , 0 ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( ! minStk . empty ( ) ) { if ( minStk . top ( ) <= arr [ i ] ) { reduce [ i ] = minStk . top ( ) ; } else { while ( ! minStk . empty ( ) && ( minStk . top ( ) > arr [ i ] ) ) { minStk . pop ( ) ; } if ( ! minStk . empty ( ) ) { reduce [ i ] = minStk . top ( ) ; } } } minStk . push ( arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] - reduce [ i ] << " " ; }
int smallestDivisorGr1 ( int N ) { for ( int i = 2 ; i <= sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { return i ; } } return N ; }
int findValOfNWithOperat ( int N , int K ) { for ( int i = 1 ; i <= K ; i ++ ) { N += smallestDivisorGr1 ( N ) ; } return N ; }
int smallestDivisorGr1 ( int N ) { for ( int i = 2 ; i <= sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { return i ; } } return N ; }
long long findTripleSum ( long long A , long long B , long long C ) { long long sum = 0 ; for ( long long i = 1 ; i <= A ; i ++ ) { for ( long long j = 1 ; j <= B ; j ++ ) { for ( long long k = 1 ; k <= C ; k ++ ) { long long prod = ( ( ( i % M ) * ( j % M ) ) % M * ( k % M ) ) % M ; sum = ( sum + prod ) % M ; } } } return sum ; }
int getMaximum ( int N , int M , vector < vector < int > > mat ) { int global_max = INT_MIN ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int row_min = INT_MAX ; for ( int k = 0 ; k < M ; k ++ ) { int m = max ( mat [ i ] [ k ] , mat [ j ] [ k ] ) ; row_min = min ( row_min , m ) ; } global_max = max ( global_max , row_min ) ; } } return global_max ; }
void makeTree ( vector < int > tree [ ] , pair < int , int > edges [ ] , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { int u = edges [ i ] . first ; int v = edges [ i ] . second ; tree [ u ] . push_back ( v ) ; } }
void findTheGreatestX ( int P , int Q ) { map < int , int > divisiors ; for ( int i = 2 ; i * i <= Q ; i ++ ) { while ( Q % i == 0 and Q > 1 ) { Q /= i ; divisiors [ i ] ++ ; } } if ( Q > 1 ) divisiors [ Q ] ++ ; int ans = 0 ; for ( auto i : divisiors ) { int frequency = i . second ; int temp = P ; int cur = 0 ; while ( temp % i . first == 0 ) { temp /= i . first ; cur ++ ; } if ( cur < frequency ) { ans = P ; break ; } temp = P ; for ( int j = cur ; j >= frequency ; j -- ) { temp /= i . first ; } ans = max ( temp , ans ) ; } cout << ans ; }
int divisorCount ( int n ) { int x = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == n / i ) x ++ ; else x += 2 ; } } return x ; }
int minvalue_y ( int x ) { int a = divisorCount ( x ) ; int y = x + 1 ; while ( ( a & 1 ) == ( divisorCount ( y ) & 1 ) ) y ++ ; return y ; }
int minvalue_y ( int x ) { int n = sqrt ( x ) ; if ( n * n == x ) return x + 1 ; return pow ( n + 1 , 2 ) ; }
int alternatingSumOfFirst_N ( int N ) { int alternateSum = 0 ; if ( N % 2 == 0 ) { alternateSum = ( - N ) / 2 ; } else { alternateSum = ( N + 1 ) / 2 ; } return alternateSum ; }
int minStartValue ( vector < int > & nums ) { int minValue = 0 ; int sum = 0 ; for ( auto n : nums ) { sum += n ; minValue = min ( minValue , sum ) ; } int startValue = 1 - minValue ; return startValue ; }
int countSubArrayRemove ( int arr [ ] , int N ) { unordered_map < int , int > prefix_element_count , suffix_element_count ; int total_sum_of_elements = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { total_sum_of_elements += arr [ i ] ; suffix_element_count [ arr [ i ] ] ++ ; } int prefix_sum = 0 ; int suffix_sum = 0 ; int count_subarray_equal_sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { prefix_sum += arr [ i ] ; prefix_element_count [ arr [ i ] ] ++ ; suffix_sum = total_sum_of_elements - prefix_sum ; suffix_element_count [ arr [ i ] ] -- ; int difference = prefix_sum - suffix_sum ; int number_of_subarray_at_i_split = prefix_element_count [ difference ] + suffix_element_count [ - difference ] ; count_subarray_equal_sum += number_of_subarray_at_i_split ; } return count_subarray_equal_sum ; }
int countXORSetBitsAdjElemRange1_N ( int N ) { int total_set_bits = 0 ; int bit_Position = 1 ; while ( N ) { total_set_bits += ( ( N + 1 ) / 2 * bit_Position ) ; N -= ( N + 1 ) / 2 ; bit_Position ++ ; } return total_set_bits ; }
int checkPerfectSquare ( int N ) { if ( N <= 0 ) { return 0 ; } double sq = sqrt ( N ) ; if ( floor ( sq ) == ceil ( sq ) ) { return 1 ; } return 0 ; }
bool checktwoSidesareRighTriangle ( int A , int B ) { bool checkTriangle = false ; if ( checkPerfectSquare ( A * A + B * B ) ) { checkTriangle = true ; } if ( checkPerfectSquare ( A * A - B * B ) ) { checkTriangle = true ; } if ( checkPerfectSquare ( B * B - A * A ) ) { checkTriangle = true ; } return checkTriangle ; }
bool valid ( int i , int j ) { if ( i >= 0 && j >= 0 && i < r && j < c ) return 1 ; return 0 ; }
int find ( int i , int j , vector < vector < int > > & v ) { int s = 0 ; for ( auto x : dir ) { int ni = i + x [ 0 ] , nj = j + x [ 1 ] ; if ( valid ( ni , nj ) ) s += v [ ni ] [ nj ] ; } return s ; }
void findsumofneighbors ( vector < vector < int > > & M ) { vector < vector < int > > v ( r , vector < int > ( c , 0 ) ) ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { v [ i ] [ j ] = find ( i , j , M ) ; cout << v [ i ] [ j ] << " " ; } cout << "\n" ; } }
int TotalBitwiseORPair ( int arr [ ] , int N ) { int totalOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalOR |= arr [ i ] ; } return totalOR ; }
void checkSolveable ( int n , int m ) { if ( n == 1 or m == 1 ) cout << "YES" ; else if ( m == 2 and n == 2 ) cout << "YES" ; else cout << "NO" ; }
int printFinalArray ( int * a , int n , int * operations , int p , int capacity ) { int i , curr = 0 ; bool picked = false ; for ( i = 0 ; i < p ; i ++ ) { int s = operations [ i ] ; bool flag = false ; switch ( s ) { case 1 : if ( curr != 0 ) curr -- ; break ; case 2 : if ( curr != n - 1 ) curr ++ ; break ; case 3 : if ( picked == false && a [ curr ] != 0 ) { picked = true ; a [ curr ] -- ; } break ; case 4 : if ( picked == true && a [ curr ] != capacity ) { picked = false ; a [ curr ] ++ ; } break ; default : flag = true ; } if ( flag == true ) break ; } for ( i = 0 ; i < n ; i ++ ) { cout << a [ i ] << " " ; } }
void constructArray ( int A [ ] , int N ) { int left [ N + 1 ] = { 0 } ; int right [ N + 1 ] = { 0 } ; int X [ N + 1 ] = { 0 } , Y [ N + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { X [ i ] = left [ A [ i ] ] ; left [ A [ i ] ] ++ ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { Y [ i ] = right [ A [ i ] ] ; right [ A [ i ] ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { cout << Y [ i ] - X [ i ] << " " ; } }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int largestElement ( struct Node * head_ref ) { int Max = INT_MIN ; Node * head = head_ref ; while ( head != NULL ) { if ( Max < head -> data ) { Max = head -> data ; } head = head -> next ; } return Max ; }
void probablityPrimeprod ( long long int N ) { long long int N_E = 3 * N ; long long int N_S = power ( 6 , N ) ; cout << N_E << " / " << N_S ; }
bool checkPalindrome ( int N ) { int rev = 0 ; int temp = N ; while ( N != 0 ) { rev = rev * 10 + N % 10 ; N = N / 10 ; } N = temp ; if ( N == rev ) { return true ; } return false ; }
int closestSmallerPalindrome ( int N ) { do { N -- ; } while ( N >= 0 && ! checkPalindrome ( N ) ) ; return N ; }
int MinimumOperationReq ( int N ) { int cntDecr = 0 ; int temp = N ; while ( temp > 0 ) { int X = sqrt ( temp ) ; if ( X * X == temp ) { break ; } temp = temp - 2 ; cntDecr += 1 ; } int cntIncr = 0 ; while ( true ) { int X = sqrt ( N ) ; if ( X * X == N ) { break ; } N = N + 2 ; cntIncr += 1 ; } return min ( cntIncr , cntDecr ) ; }
long long power ( long long x , long long N ) { long long res = 1 ; while ( N > 0 ) { if ( N & 1 ) { res = ( res * x ) % M ; } x = ( x * x ) % M ; N = N >> 1 ; } return res ; }
long long moduloInverse ( long long X ) { return power ( X , M - 2 ) ; }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; else return GCD ( b , a % b ) ; }
void check ( int x , int y ) { if ( GCD ( x , y ) == 1 ) { cout << "Yes" ; } else { cout << "No" ; } }
void findSubArray ( vector < int > arr , int k ) { pair < int , int > ans ; int i , sum = 0 ; for ( i = 0 ; i < k ; i ++ ) { sum += arr [ i ] ; } int found = 0 ; if ( sum % 3 == 0 ) { ans = make_pair ( 0 , i - 1 ) ; found = 1 ; } for ( int j = i ; j < arr . size ( ) ; j ++ ) { if ( found == 1 ) break ; sum = sum + arr [ j ] - arr [ j - k ] ; if ( sum % 3 == 0 ) { ans = make_pair ( j - k + 1 , j ) ; found = 1 ; } } if ( found == 0 ) ans = make_pair ( -1 , 0 ) ; if ( ans . first == -1 ) { cout << -1 ; } else { for ( i = ans . first ; i <= ans . second ; i ++ ) { cout << arr [ i ] << " " ; } } }
int sumOfProd ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } return sum * sum ; }
int rev ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }
bool check ( int n ) { int x = ( n + 7 ) / 8 ; if ( ( n + 7 ) % 8 == 0 && isPower ( 10 , x ) ) return true ; else return false ; }
void mul_2 ( int K ) { int temp [ K + 1 ] [ K + 1 ] ; memset ( temp , 0 , sizeof temp ) ; for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 1 ; j <= K ; j ++ ) { for ( int k = 1 ; k <= K ; k ++ ) { temp [ i ] [ j ] = ( temp [ i ] [ j ] + ( T [ i ] [ k ] * T [ k ] [ j ] ) % mod ) % mod ; } } } for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 1 ; j <= K ; j ++ ) { T [ i ] [ j ] = temp [ i ] [ j ] ; } } }
void mul_1 ( int K ) { int temp [ K + 1 ] [ K + 1 ] ; memset ( temp , 0 , sizeof temp ) ; for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 1 ; j <= K ; j ++ ) { for ( int k = 1 ; k <= K ; k ++ ) { temp [ i ] [ j ] = ( temp [ i ] [ j ] + ( result [ i ] [ k ] * T [ k ] [ j ] ) % mod ) % mod ; } } } for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 1 ; j <= K ; j ++ ) { result [ i ] [ j ] = temp [ i ] [ j ] ; } } }
void matrix_pow ( int K , int n ) { for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 1 ; j <= K ; j ++ ) { if ( i == j ) result [ i ] [ j ] = 1 ; } } while ( n > 0 ) { if ( n % 2 == 1 ) mul_1 ( K ) ; mul_2 ( K ) ; n /= 2 ; } }
int countFreq ( int arr [ ] , int n ) { unordered_map < int , int > mp1 ; for ( int i = 0 ; i < n ; ++ i ) { mp1 [ arr [ i ] ] ++ ; } unordered_map < int , int > mp2 ; for ( auto it : mp1 ) { mp2 [ it . second ] ++ ; } int M = INT_MIN ; for ( auto it : mp2 ) { M = max ( M , it . second ) ; } for ( auto it : mp2 ) { if ( M == it . second ) { return it . first ; } } return 0 ; }
int computeSalary ( int basic , char grade ) { int allowance ; double hra , da , pf ; hra = 0.2 * basic ; da = 0.5 * basic ; pf = 0.11 * basic ; if ( grade == 'A' ) { allowance = 1700 ; } else if ( grade == 'B' ) { allowance = 1500 ; } else { allowance = 1300 ; } int gross ; gross = round ( basic + hra + da + allowance - pf ) ; return gross ; }
int maxDisconnected ( int N , int E ) { int curr = 1 ; int rem = E ; while ( rem > 0 ) { rem = rem - min ( curr , rem ) ; curr ++ ; } if ( curr > 1 ) { return N - curr ; } else { return N ; } }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findSum ( unsigned int N ) { unsigned int sum = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( gcd ( i , N ) == 1 ) { sum += i ; } } return sum ; }
void solve ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] ++ ; } int cnt = 0 ; for ( auto x : mp ) { cnt += ( ( x . second ) * ( x . second - 1 ) / 2 ) ; } int ans [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ans [ i ] = cnt - ( mp [ arr [ i ] ] - 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << " " ; } }
double nthRoot ( int A , int N ) { double xPre = rand ( ) % 10 ; double eps = 1e-3 ; double delX = INT_MAX ; double xK ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + ( double ) A / pow ( xPre , N - 1 ) ) / ( double ) N ; delX = abs ( xK - xPre ) ; xPre = xK ; } return xK ; }
float RMNValue ( int arr [ ] , int n , int k ) { int Nth = 0 ; float mean = 0.0 , root = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) { Nth += pow ( arr [ i ] , k ) ; } mean = ( Nth / ( float ) ( n ) ) ; root = nthRoot ( mean , k ) ; return root ; }
int xor_operations ( int N , int arr [ ] , int M , int K ) { if ( M < 0 or M > = N ) return -1 ; if ( K < 0 or K >  = N - M ) return -1 ; for ( int p = 0 ; p < M ; p ++ ) { vector < int > temp ; for ( int i = 0 ; i < N ; i ++ ) { int value = arr [ i ] ^ arr [ i + 1 ] ; temp . push_back ( value ) ; arr [ i ] = temp [ i ] ; } } int ans = arr [ K ] ; return ans ; }
int checkPalindromeB ( int N , int B ) { int rev = 0 ; int N1 = N ; while ( N1 ) { rev = rev * B + N1 % B ; N1 = N1 / B ; } return N == rev ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findProduct ( unsigned int N ) { unsigned int result = 1 ; for ( int i = 2 ; i < N ; i ++ ) { if ( gcd ( i , N ) == 1 ) { result *= i ; } } return result ; }
int countEqual ( int n ) { return ( n + 1 ) / 2 ; }
int smallSubarray ( int arr [ ] , int n , int total_sum ) { unordered_map < int , int > m ; int length = INT_MAX ; int prefixSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { prefixSum += arr [ i ] ; if ( prefixSum == total_sum ) { length = min ( length , i + 1 ) ; } m [ prefixSum ] = i ; if ( m . count ( prefixSum - total_sum ) ) { length = min ( length , i - m [ prefixSum - total_sum ] ) ; } } return length ; }
int smallestSubarrayremoved ( int arr [ ] , int n , int k ) { int total_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > k ) { arr [ i ] = 1 ; } else if ( arr [ i ] < k ) { arr [ i ] = -1 ; } else { arr [ i ] = 0 ; } total_sum += arr [ i ] ; } if ( total_sum == 0 ) { return 0 ; } else { return smallSubarray ( arr , n , total_sum ) ; } }
int find ( int par [ ] , int x ) { if ( par [ x ] == x ) return x ; else return par [ x ] = find ( par , par [ x ] ) ; }
int functionMax ( int arr [ ] , int n ) { vector < int > setBit [ 32 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < size_int ; j ++ ) { if ( arr [ i ] & ( 1 << j ) ) setBit [ j ] . push_back ( i ) ; } } for ( int i = size_int ; i >= 0 ; i -- ) { if ( setBit [ i ] . size ( ) == 1 ) { swap ( arr [ 0 ] , arr [ setBit [ i ] [ 0 ] ] ) ; break ; } } int maxAnd = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { maxAnd = maxAnd & ( ~ arr [ i ] ) ; } return maxAnd ; }
ll modexp ( ll x , ll n , ll m ) { if ( n == 0 ) { return 1 ; } else if ( n % 2 == 0 ) { return modexp ( ( x * x ) % m , n / 2 , m ) ; } else { return ( x * modexp ( ( x * x ) % m , ( n - 1 ) / 2 , m ) % m ) ; } }
ll modInverse ( ll x , ll m ) { return modexp ( x , m - 2 , m ) ; }
void countNumbers ( string N ) { ll m = 1000000007 ; ll factorial [ 100001 ] ; factorial [ 0 ] = 1 ; for ( ll i = 1 ; i < 100001 ; i ++ ) { factorial [ i ] = ( factorial [ i - 1 ] * i ) % m ; } ll count [ 10 ] ; for ( ll i = 0 ; i < 10 ; i ++ ) { count [ i ] = 0 ; } ll length = N . length ( ) ; for ( ll i = 0 ; i < length ; i ++ ) count [ N [ i ] - '0' ] ++ ; ll result = factorial [ length ] ; for ( ll i = 0 ; i < 10 ; i ++ ) { result = ( result * modInverse ( factorial [ count [ i ] ] , m ) ) % m ; } cout << result ; }
void max_valid_triplet ( int A [ ] , int n ) { int ans = -1 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( A [ i ] < A [ j ] && A [ j ] < A [ k ] ) { int value = A [ i ] + A [ j ] * A [ k ] ; if ( value > ans ) { ans = value ; } } } } } cout << ( ans ) ; }
int productOfProperDivi ( int num ) { return ans [ num ] ; }
int findlcm ( int n ) { int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ( ( ( i * ans ) ) / ( __gcd ( i , ans ) ) ) ; return ans ; }
int highestPower ( int n ) { int lcm = findlcm ( n ) ; int ans = 0 ; for ( int i = 1 ; ; i ++ ) { int x = pow ( 2 , i ) ; if ( lcm % x == 0 ) { ans = i ; } if ( x > n ) break ; } return ans ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int countofPermutations ( int N ) { return int ( 3 * pow ( 2 , N - 1 ) ) ; }
void answer ( int L , int R ) { if ( 2 * L <= R ) cout << L << ", " << 2 * L << "\n" ; else cout << -1 ; }
void spf_array ( int spf [ ] ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < 1000 ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < 1000 ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < 1000 ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < 1000 ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } }
void frequent_prime ( int arr [ ] , int N , int K ) { spf_array ( spf ) ; unordered_map < int , int > Hmap ; vector < int > result ; int i = 0 ; int c = 0 ; for ( i = 0 ; i < N ; i ++ ) { int x = arr [ i ] ; while ( x != 1 ) { Hmap [ spf [ x ] ] = Hmap [ spf [ x ] ] + 1 ; x = x / spf [ x ] ; } } Hmap . erase ( 1 ) ; for ( auto x : Hmap ) { int primeNum = x . first ; int frequency = x . second ; if ( frequency % K == 0 ) { result . push_back ( primeNum ) ; } } if ( result . size ( ) > 0 ) { for ( auto & it : result ) { cout << it << ' ' ; } } else { cout << "{}" ; } }
void initialize_xor ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { total_xor = total_xor ^ arr [ i ] ; } }
int gcd ( int x , int y ) { if ( x % y == 0 ) return y ; else return gcd ( y , x % y ) ; }
int countPairwiseCoprime ( int N , int M ) { int answer = 1 ; int g = gcd ( N , M ) ; int temp = g ; for ( int i = 2 ; i * i <= g ; i ++ ) { if ( temp % i == 0 ) { answer ++ ; while ( temp % i == 0 ) temp /= i ; } } if ( temp != 1 ) answer ++ ; return answer ; }
void countCoprimePair ( int arr [ ] [ 2 ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { cout << countPairwiseCoprime ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) << ' ' ; } }
bool prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
int getProduct ( int a [ ] , int n ) { int p = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { p *= abs ( a [ i ] - a [ j ] ) ; } } return p ; }
bool isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; }
bool diffCube ( int N ) { return isPerfectSquare ( 12 * N - 3 ) ; }
int totalCountDifference ( int n ) { if ( n == 1 ) return 1 ; return n + totalCountDifference ( n / 2 ) ; }
int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; }
void findLCM ( vector < int > & arr ) { int nth_lcm = arr [ 0 ] ; for ( int i = 1 ; i < arr . size ( ) ; i ++ ) nth_lcm = lcm ( nth_lcm , arr [ i ] ) ; Landau = max ( Landau , nth_lcm ) ; }
void findWays ( vector < int > & arr , int i , int n ) { if ( n == 0 ) findLCM ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . push_back ( j ) ; findWays ( arr , j , n - j ) ; arr . pop_back ( ) ; } }
void Landau_function ( int n ) { vector < int > arr ; findWays ( arr , 1 , n ) ; cout << Landau ; }
int findSum ( int arr [ ] , int n , int left , int right ) { int k = right - left + 1 ; int d = arr [ 1 ] / arr [ 0 ] ; int ans = arr [ left - 1 ] ; if ( d == 1 ) ans = ans * d * k ; else ans = ans * ( ( int ) pow ( d , k ) - 1 / ( d - 1 ) ) ; return ans ; }
int countRepeatingDigits ( int N ) { int res = 0 ; int cnt [ 10 ] = { 0 } ; while ( N > 0 ) { int rem = N % 10 ; cnt [ rem ] ++ ; N = N / 10 ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( cnt [ i ] > 1 ) { res ++ ; } } return res ; }
int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
int solve ( int n , int m , int k ) { int sum = 0 ; for ( int i = 0 ; i <= k ; i ++ ) sum += nCr ( n , i ) * nCr ( m , k - i ) ; return sum ; }
int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
ll modPower ( ll a , ll b , ll M ) { ll res = 1 ; while ( b ) { if ( b & 1 ) res = res * a % M ; a = a * a % M ; b >>= 1 ; } return res ; }
int Cal_min ( int arr [ ] , int n , int k ) { set < int > diff_mod ; map < int , int > count_mod ; for ( int i = 0 ; i < n ; i ++ ) { diff_mod . insert ( arr [ i ] % k ) ; count_mod [ arr [ i ] % k ] ++ ; } return Find_min ( diff_mod , count_mod , k ) ; }
void canBreakN ( long long n ) { for ( long long i = 2 ; ; i ++ ) { long long m = i * ( i + 1 ) / 2 ; if ( m > n ) break ; long long k = n - m ; if ( k % i ) continue ; cout << i << endl ; return ; } cout << "-1" ; }
void minimumSteps ( int arr [ ] , int n ) { int i , dat [ n + 1 ] ; for ( i = 1 ; i <= n ; i ++ ) dat [ arr [ i - 1 ] ] = i ; int b [ n + 1 ] , j = 0 , c ; for ( i = 1 ; i <= n ; i ++ ) { c = 1 ; j = dat [ i ] ; while ( j != i ) { c ++ ; j = dat [ j ] ; } b [ i ] = c ; } cout << findlcm ( b , n ) ; }
double maximum ( double a , double b ) { if ( a > b ) return a ; return b ; }
void check ( long num ) { long root = ( long ) sqrt ( num ) ; long poww = ( long ) ( log ( root ) / log ( 2 ) ) ; if ( num == ( long ) ( pow ( 2 , poww ) * ( pow ( 2 , poww + 1 ) - 1 ) ) ) { if ( isPrime ( poww + 1 ) ) { if ( isPrime ( ( long ) pow ( 2 , poww + 1 ) - 1 ) ) cout << "Yes" << endl ; else cout << "No" << endl ; } else cout << "No" << endl ; } else cout << "No" << endl ; }
bool isPrime ( long n ) { if ( n <= 1 ) return false ; else if ( n == 2 n == 3 ) return true ; else { if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( long i = 5 ; i <= sqrt ( n ) ; i += 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; } return true ; } }
bool isTriplet ( int ar [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( abs ( ar [ i ] - ar [ j ] ) == 1 || abs ( ar [ j ] - ar [ k ] ) == 1 || abs ( ar [ i ] - ar [ k ] ) == 1 ) { int x = ar [ i ] * ar [ i ] , y = ar [ j ] * ar [ j ] , z = ar [ k ] * ar [ k ] ; if ( x == y + z y == x + z z == x + y ) return true ; } } } } return false ; }
void closestDivisors ( int n ) { for ( int i = sqrt ( n + 2 ) ; i > 0 ; i -- ) { if ( ( n + 1 ) % i == 0 ) { cout << i << ", " << ( n + 1 ) / i ; break ; } if ( ( n + 2 ) % i == 0 ) { cout << i << ", " << ( n + 2 ) / i ; break ; } } }
int count ( int n ) { int phi [ n + 1 ] = { 0 } ; int divs [ n + 1 ] = { 0 } ; for ( int i = 1 ; i <= n ; i ++ ) { phi [ i ] += i ; for ( int j = i * 2 ; j <= n ; j += i ) phi [ j ] -= phi [ i ] ; for ( int j = i ; j <= n ; j += i ) divs [ j ] ++ ; } return ( n - phi [ n ] - divs [ n ] + 1 ) ; }
void inorder ( Node * node ) { if ( node == NULL ) return ; inorder ( node -> left ) ; cout << node -> data << " " ; inorder ( node -> right ) ; }
int MinimumString ( int x ) { int b = 1 ; double left_lim = sqrt ( x ) + 1.0 ; double right_lim = sqrt ( x ) + 2.0 ; int r ; for ( int i = left_lim ; i <= right_lim ; i ++ ) { if ( i > left_lim and i < right_lim ) { r = i ; break ; } } return b + r ; }
bool isPerfectSquare ( int N ) { int floorSqrt = sqrt ( N ) ; return ( N == floorSqrt * floorSqrt ) ; }
bool legendreFunction ( int N ) { while ( N % 4 == 0 ) N /= 4 ; if ( N % 8 != 7 ) return true ; else return false ; }
int minSquares ( int N ) { if ( isPerfectSquare ( N ) ) return 1 ; for ( int i = 1 ; i * i < N ; i ++ ) { if ( isPerfectSquare ( N - i * i ) ) return 2 ; } if ( legendreFunction ( N ) ) return 3 ; return 4 ; }
bool is_distinct ( long long n , long long k ) { unordered_set < long long > s ; for ( int i = 1 ; i <= k ; i ++ ) { long long tmp = n % i ; if ( s . find ( tmp ) != s . end ( ) ) { return false ; } s . insert ( tmp ) ; } return true ; }
static int getDivisors ( int min , int n ) { int total = 0 ; for ( int i = min ; i < n ; ++ i ) { if ( n % i == 0 && n / i >= i ) { ++ total ; if ( n / i > i ) total += getDivisors ( i , n / i ) ; } } return total ; }
void findWays ( vector < int > & arr , int i , int n ) { if ( n == 0 ) printVector ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . push_back ( j ) ; findWays ( arr , j , n - j ) ; arr . pop_back ( ) ; } }
void spt_function ( int n ) { vector < int > arr ; findWays ( arr , 1 , n ) ; cout << spt ; }
int isUgly ( int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; if ( n % 2 == 0 ) { return ( isUgly ( n / 2 ) ) ; } if ( n % 3 == 0 ) { return ( isUgly ( n / 3 ) ) ; } if ( n % 5 == 0 ) { return ( isUgly ( n / 5 ) ) ; } return 0 ; }
int findMinDenomin ( int n ) { return log2 ( n ) + 1 ; }
long long calculate ( long long p , long long q ) { long long mod = 998244353 , expo ; expo = mod - 2 ; while ( expo ) { if ( expo & 1 ) { p = ( p * q ) % mod ; } q = ( q * q ) % mod ; expo >>= 1 ; } return p ; }
int powerOptimised ( int a , int n ) { int ans = 1 ; while ( n > 0 ) { int last_bit = ( n & 1 ) ; if ( last_bit ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; }
int maxGCD ( int N ) { for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return N / i ; } } return 1 ; }
int findMaximumGcd ( int n ) { int max_gcd = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i > max_gcd ) max_gcd = i ; if ( ( n / i != i ) && ( n / i != n ) && ( ( n / i ) > max_gcd ) ) max_gcd = n / i ; } } return max_gcd ; }
int findContent ( int arr [ ] , int n ) { int content = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { content = __gcd ( content , arr [ i ] ) ; } return content ; }
void inverseEqual ( int arr [ ] , int n ) { int brr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int present_index = arr [ i ] - 1 ; brr [ present_index ] = i + 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != brr [ i ] ) { cout << "No" << endl ; return ; } } cout << "Yes" << endl ; }
void linearCongruentialMethod ( int Xo , int m , int a , int c , vector < int > & randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( ( randomNums [ i - 1 ] * a ) + c ) % m ; } }
void multiplicativeCongruentialMethod ( int Xo , int m , int a , vector < int > & randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] * a ) % m ; } }
void additiveCongruentialMethod ( int Xo , int m , int c , vector < int > & randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] + c ) % m ; } }
int power ( int a , int b , int m ) { a %= m ; int res = 1 ; while ( b > 0 ) { if ( b & 1 ) res = ( ( res % m ) * ( a % m ) ) % m ; a = ( ( a % m ) * ( a % m ) ) % m ; b >>= 1 ; } return res % m ; }
int productOfDivisors ( int p [ ] , int n ) { map < int , int > prime ; for ( int i = 0 ; i < n ; i ++ ) { prime [ p [ i ] ] ++ ; } int product = 1 , d = 1 ; for ( auto itr : prime ) { int val = power ( itr . first , ( itr . second ) * ( itr . second + 1 ) / 2 , MOD ) ; product = ( power ( product , itr . second + 1 , MOD ) * power ( val , d , MOD ) ) % MOD ; d = ( d * ( itr . second + 1 ) ) % ( MOD - 1 ) ; } return product ; }
int numberOfObjects ( int N , int M ) { int initial = min ( N , M ) ; int final = ( N + M ) / 3 ; return min ( initial , final ) ; }
int MaxSubarrayLength ( int arr [ ] , int n , int k ) { int left = -1 ; int right ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % k ) != 0 ) { if ( left == -1 ) { left = i ; } right = i ; } sum += arr [ i ] ; } if ( ( sum % k ) != 0 ) { return n ; } else if ( left == -1 ) { return -1 ; } else { int prefix_length = left + 1 ; int suffix_length = n - right ; return n - min ( prefix_length , suffix_length ) ; } }
int findDistinct ( int arr [ ] , int n ) { int maximum = * max_element ( arr , arr + n ) ; if ( n == 1 ) return 1 ; if ( n == 2 ) { return ( maximum / gcd ( arr [ 0 ] , arr [ 1 ] ) ) ; } int k = gcd ( arr [ 0 ] , arr [ 1 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { k = gcd ( k , arr [ i ] ) ; } return ( maximum / k ) ; }
int power ( int a , int b ) { if ( b == 0 ) return 1 ; if ( b == 1 ) return a ; int tmp = power ( a , b / 2 ) ; int result = tmp * tmp ; if ( b % 2 == 1 ) result *= a ; return result ; }
int solve ( int X , int Y ) { if ( X > Y ) { int temp = X ; X = Y ; Y = temp ; } if ( X == Y ) cout << 0 << endl ; else if ( Y % X == 0 ) cout << 1 << endl ; else cout << 2 << endl ; }
void findWinner ( int n , int k ) { int cnt = 0 ; if ( n == 1 ) cout << "No" << endl ; else if ( ( n & 1 ) or n == 2 ) cout << "Yes" << endl ; else { int tmp = n ; int val = 1 ; while ( tmp > k and tmp % 2 == 0 ) { tmp /= 2 ; val *= 2 ; } for ( int i = 3 ; i <= sqrt ( tmp ) ; i ++ ) { while ( tmp % i == 0 ) { cnt ++ ; tmp /= i ; } } if ( tmp > 1 ) cnt ++ ; if ( val == n ) cout << "No" << endl ; else if ( n / tmp == 2 and cnt == 1 ) cout << "No" << endl ; else cout << "Yes" << endl ; } }
ll countQuadraples ( ll N ) { ll cnt = 0 ; map < ll , ll > m ; for ( ll a = 1 ; a <= N ; a ++ ) { for ( ll b = 1 ; b <= N ; b ++ ) { ll x = a * a + b * b ; m [ x ] += 1 ; } } for ( ll c = 1 ; c <= N ; c ++ ) { for ( ll d = 1 ; d <= N ; d ++ ) { ll x = c * c + d * d ; if ( m . find ( x ) != m . end ( ) ) cnt += m [ x ] ; } } return cnt ; }
int numberOfPairs ( int * a , int * b , int n ) { int c [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = a [ i ] - b [ i ] ; } sort ( c , c + n ) ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( c [ i ] <= 0 ) continue ; int pos = lower_bound ( c , c + n , - c [ i ] + 1 ) - c ; answer += ( i - pos ) ; } return answer ; }
void isEqualFactors ( lli N ) { if ( ( N % 2 == 0 ) and ( N % 4 != 0 ) ) cout << "YES" << endl ; else cout << "NO" << endl ; }
int count_crazy_primes ( int L , int R ) { int prime [ R + 1 ] = { 0 } ; int countPrime [ R + 1 ] = { 0 } ; int freqPrime [ R + 1 ] = { 0 } ; prime [ 0 ] = prime [ 1 ] = 1 ; for ( int p = 2 ; p * p <= R ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * p ; i <= R ; i += p ) prime [ i ] = 1 ; } } for ( int i = 1 ; i <= R ; i ++ ) { countPrime [ i ] = countPrime [ i - 1 ] ; if ( ! prime [ i ] ) { countPrime [ i ] ++ ; } } for ( int i = 1 ; i <= R ; i ++ ) { freqPrime [ i ] = freqPrime [ i - 1 ] ; if ( ! prime [ countPrime [ i ] ] ) { freqPrime [ i ] ++ ; } } return ( freqPrime [ R ] - freqPrime [ L - 1 ] ) ; }
void findNumbers ( int n , int b ) { int largest = pow ( b , n ) - 1 ; cout << largest << endl ; }
void maximizedArray ( int arr [ ] , int N ) { int num , i = 0 ; while ( N -- ) { num = arr [ i ] ; int one = 0 ; int zero = 0 ; while ( num ) { if ( num % 2 == 0 ) { zero ++ ; } else { one ++ ; } num = num >> 1 ; } for ( int j = zero ; j < ( one + zero ) ; j ++ ) { num += ( 1 << j ) ; } cout << num ; i ++ ; if ( N > 0 ) cout << ", " ; } }
void sieve ( ) { v [ 1 ] = 1 ; for ( long long int i = 2 ; i < x ; i ++ ) v [ i ] = i ; for ( long long int i = 4 ; i < x ; i += 2 ) v [ i ] = 2 ; for ( long long int i = 3 ; i * i < x ; i ++ ) { if ( v [ i ] == i ) { for ( long long int j = i * i ; j < x ; j += i ) { if ( v [ j ] == j ) { v [ j ] = i ; } } } } }
long long int prime_factors ( long long n ) { set < long long int > s ; while ( n != 1 ) { s . insert ( v [ n ] ) ; n = n / v [ n ] ; } return s . size ( ) ; }
void distinctPrimes ( long long int m , long long int k ) { vector < long long int > result ; for ( long long int i = 14 ; i < m + k ; i ++ ) { long long count = prime_factors ( i ) ; if ( count == k ) { result . push_back ( i ) ; } } long long int p = result . size ( ) ; for ( long long int index = 0 ; index < p - 1 ; index ++ ) { long long element = result [ index ] ; long long count = 1 , z = index ; while ( z < p - 1 && count <= k && result [ z ] + 1 == result [ z + 1 ] ) { count ++ ; z ++ ; } if ( count >= k ) cout << element << ' ' ; } }
int findGCD ( int arr [ ] , int n ) { int gcd = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { gcd = __gcd ( arr [ i ] , gcd ) ; if ( gcd == 1 ) { return 1 ; } } return gcd ; }
int findLCM ( int arr [ ] , int n ) { int lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { lcm = ( ( ( arr [ i ] * lcm ) ) / ( __gcd ( arr [ i ] , lcm ) ) ) ; } return lcm ; }
void compute ( int a [ ] , int N , int K ) { map < long , long > eqVal ; long maxX = 0 ; for ( int i = 0 ; i < N ; i ++ ) { long val = a [ i ] % K ; val = ( val == 0 ? 0 : K - val ) ; if ( val == 0 ) continue ; if ( eqVal . find ( val ) != eqVal . end ( ) ) { long numVal = eqVal [ val ] ; maxX = max ( maxX , val + ( K * numVal ) ) ; eqVal [ val ] ++ ; } else { eqVal [ val ] ++ ; maxX = max ( maxX , val ) ; } } cout << ( maxX == 0 ? 0 : maxX + 1 ) << endl ; }
int print_h_index ( int arr [ ] , int N ) { multiset < int > ms ; for ( int i = 0 ; i < N ; i ++ ) { ms . insert ( arr [ i ] ) ; if ( * ms . begin ( ) < ms . size ( ) ) { ms . erase ( ms . begin ( ) ) ; } cout << ms . size ( ) << " " ; } }
void pen_hex ( long long n ) { long long pn = 1 ; for ( long long int i = 1 ; ; i ++ ) { pn = i * ( 3 * i - 1 ) / 2 ; if ( pn > n ) break ; long double seqNum = ( 1 + sqrt ( 8 * pn + 1 ) ) / 4 ; if ( seqNum == long ( seqNum ) ) cout << pn << ", " ; } }
int min_value ( int arr [ ] , int N ) { int x , X , K ; set < int > S ; for ( int i = 0 ; i < N ; i ++ ) { S . insert ( arr [ i ] ) ; } int count = 0 ; for ( int i = 1 ; i <= 1024 ; i ++ ) { count = 0 ; for ( auto it = S . begin ( ) ; it != S . end ( ) ; it ++ ) { X = ( ( i * it ) - ( i & * it ) ) ; if ( S . find ( X ) != S . end ( ) ) { count ++ ; } } if ( count == S . size ( ) ) { K = i ; return K ; } } return -1 ; }
int prefixProduct ( int a [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i ] * a [ i - 1 ] ; } for ( int j = 0 ; j < n ; j ++ ) { cout << a [ j ] << ", " ; } return 0 ; }
void sumOfTheArrayForQuery ( int * A , int N , int * X , int * Y , int Q ) { int sum = 0 ; unordered_map < int , int > count ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; count [ A [ i ] ] ++ ; } for ( int i = 0 ; i < Q ; i ++ ) { int x = X [ i ] , y = Y [ i ] ; sum -= count [ X [ i ] ] * X [ i ] ; sum += count [ X [ i ] ] * Y [ i ] ; count [ Y [ i ] ] += count [ X [ i ] ] ; count [ X [ i ] ] = 0 ; cout << sum << " " ; } }
int maxOR ( int arr [ ] , int n ) { int max_value = * max_element ( arr , arr + n ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = max ( ans , ( max_value arr [ i ] ) ) ; } return ans ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
void generateArr ( int A [ ] , int n ) { int B [ n ] ; int maxi = * max_element ( A , A + n ) ; int count [ maxi + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { B [ i ] = count [ A [ i ] ] ; IncrementFactors ( count , A [ i ] ) ; } printArr ( B , n ) ; }
vector < int > SieveOfEratosthenes ( int n ) { bool prime [ 2 * n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= 2 * n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= 2 * n ; i += p ) prime [ i ] = false ; } } vector < int > primes ; for ( int p = 2 ; p <= 2 * n ; p ++ ) if ( prime [ p ] ) primes . push_back ( p ) ; return primes ; }
int minChanges ( vector < int > arr ) { int n = arr . size ( ) ; int ans = 0 ; int maxi = * max_element ( arr . begin ( ) , arr . end ( ) ) ; vector < int > primes = SieveOfEratosthenes ( maxi ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = lower_bound ( primes . begin ( ) , primes . end ( ) , arr [ i ] ) - primes . begin ( ) ; int minm = abs ( primes [ x ] - arr [ i ] ) ; if ( x > 1 ) { minm = min ( minm , abs ( primes [ x - 1 ] - arr [ i ] ) ) ; } ans += minm ; } return ans ; }
int findSum ( int * a , int n , int L , int R ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( L % a [ i ] == 0 && L != 0 ) { sum += calcSum ( a [ i ] , R / a [ i ] ) - calcSum ( a [ i ] , ( L - 1 ) / a [ i ] ) ; } else { sum += calcSum ( a [ i ] , R / a [ i ] ) - calcSum ( a [ i ] , L / a [ i ] ) ; } } return sum ; }
void findPrimes ( ) { for ( int i = 1 ; i <= maxN ; i ++ ) arr [ i ] = 1 ; arr [ 0 ] = 0 , arr [ 1 ] = 0 ; for ( int i = 2 ; i * i <= maxN ; i ++ ) { if ( arr [ i ] == 1 ) { for ( int j = i * i ; j <= maxN ; j += i ) { arr [ j ] = 0 ; } } } int sum = 0 ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= maxN ; i ++ ) { if ( arr [ i ] == 1 ) { int temp = i ; sum = 0 ; while ( temp > 0 ) { int x = temp % 10 ; sum += x ; temp = temp / 10 ; if ( arr [ sum ] == 1 ) { prefix [ i ] = 1 ; } else { prefix [ i ] = 0 ; } } } } for ( int i = 1 ; i <= maxN ; i ++ ) { prefix [ i ] += prefix [ i - 1 ] ; } }
void print_product ( int a , int b , int c , int d ) { int prod1 = a * c ; int prod2 = b * d ; int prod3 = ( a + b ) * ( c + d ) ; int real = prod1 - prod2 ; int imag = prod3 - ( prod1 + prod2 ) ; cout << real << " + " << imag << "i" ; }
int countWays ( int N ) { if ( N < 4 ) return 0 ; int ans = ( ( N - 1 ) * ( N - 2 ) ) / 2 ; int s = 0 ; for ( int i = 2 ; i <= N - 3 ; i ++ ) { for ( int j = 1 ; j < i ; j ++ ) { if ( N == 2 * i + j ) s ++ ; } } if ( N % 3 == 0 ) s = 3 * s + 1 ; else s = 3 * s ; return ans - s ; }
double get_concentration ( double mass , double volume ) { if ( volume == 0 ) return -1 ; else return ( mass / volume ) * 1000 ; }
bool isSubsetSum ( vector < int > & set , int n , int sum ) { bool subset [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ] ; } } return subset [ n ] [ sum ] ; }
bool isPractical ( int N ) { vector < int > div ; storeDivisors ( N , div ) ; for ( int i = 1 ; i < N ; i ++ ) { if ( ! isSubsetSum ( div , div . size ( ) , i ) ) return false ; } return true ; }
bool isJunction ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i + sum ( i ) == n ) count ++ ; } return count >= 2 ; }
bool isDivBySubsetSums ( vector < int > arr , int num ) { int n = arr . size ( ) ; long long total = 1 << n ; for ( long long i = 0 ; i < total ; i ++ ) { long long sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( i & ( 1 << j ) ) sum += arr [ j ] ; if ( sum != 0 && num % sum != 0 ) return false ; } return true ; }
bool isSuperNivenNum ( int n ) { int temp = n ; vector < int > digits ; while ( n != 0 ) { int digit = n % 10 ; digits . push_back ( digit ) ; n = n / 10 ; } return isDivBySubsetSums ( digits , temp ) ; }
int divCount ( int n ) { bool hash [ n + 1 ] ; memset ( hash , true , sizeof ( hash ) ) ; for ( int p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( int i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; int total = 1 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { int count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = n / p ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }
bool isHighlyCompositeNumber ( int N ) { int NdivCount = divCount ( N ) ; for ( int i = 1 ; i < N ; i ++ ) { int idivCount = divCount ( i ) ; if ( idivCount >= NdivCount ) return false ; } return true ; }
bool isInsolite ( int n ) { int N = n ; int sum = 0 ; int product = 1 ; while ( n != 0 ) { int r = n % 10 ; sum = sum + r * r ; product = product * r * r ; n = n / 10 ; } return ( N % sum == 0 ) && ( N % product == 0 ) ; }
bool isSaintExuperyNum ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n / i / j ; if ( i * i + j * j == k * k ) { if ( i * j * k == n ) return true ; ; } } } return false ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool isMagnanimous ( int N ) { string s = to_string ( N ) ; int l = s . length ( ) ; if ( l < 2 ) return false ; for ( int i = 0 ; i < l - 1 ; i ++ ) { string left = s . substr ( 0 , i + 1 ) ; string right = s . substr ( i + 1 ) ; int x = stoi ( left ) ; int y = stoi ( right ) ; if ( ! isPrime ( x + y ) ) return false ; } return true ; }
int digProduct ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int nextPrime ( int N ) { if ( N <= 1 ) return 2 ; int prime = N ; bool found = false ; while ( ! found ) { prime ++ ; if ( isPrime ( prime ) ) found = true ; } return prime ; }
bool isPointerPrime ( int n ) { if ( isPrime ( n ) && ( n + digProduct ( n ) == nextPrime ( n ) ) ) return true ; else return false ; }
void sieve ( ) { position [ 0 ] = -1 , position [ 1 ] = -1 ; int pos = 0 ; for ( int i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( int j = i * 2 ; j <= limit ; j += i ) position [ j ] = -1 ; } } }
int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
int power ( int x , unsigned int y ) { if ( y == 0 ) { return 1 ; } if ( y % 2 == 0 ) { return ( power ( x , y / 2 ) * power ( x , y / 2 ) ) ; } return ( x * power ( x , y / 2 ) * power ( x , y / 2 ) ) ; }
bool isPerfectDigitalInvariant ( int x ) { for ( int fixed_power = 1 ; ; fixed_power ++ ) { int temp = x , sum = 0 ; while ( temp ) { int r = temp % 10 ; sum += power ( r , fixed_power ) ; temp = temp / 10 ; } if ( sum == x ) { return true ; } if ( sum > x ) { return false ; } } }
bool isWasteful ( int n ) { if ( n == 1 ) return false ; int original_no = n ; int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits ++ ; original_no = original_no / 10 ; } int pDigit = 0 , count_exp = 0 , p ; for ( int i = 0 ; primes [ i ] <= n / 2 ; i ++ ) { while ( n % primes [ i ] == 0 ) { p = primes [ i ] ; n = n / p ; count_exp ++ ; } while ( p > 0 ) { pDigit ++ ; p = p / 10 ; } while ( count_exp > 1 ) { pDigit ++ ; count_exp = count_exp / 10 ; } } if ( n != 1 ) { while ( n > 0 ) { pDigit ++ ; n = n / 10 ; } } return ( pDigit > sumDigits ) ; }
void Solve ( int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( isWasteful ( i ) ) { cout << i << " " ; } } }
int isDNum ( int n ) { if ( n < 4 ) return false ; int numerator , hcf ; for ( int k = 2 ; k <= n ; k ++ ) { numerator = pow ( k , n - 2 ) - k ; hcf = __gcd ( n , k ) ; } if ( hcf == 1 && ( numerator % n ) != 0 ) return false ; return true ; }
bool isComposite ( int n ) { if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }
bool isEnlightened ( int N ) { if ( ! isComposite ( N ) ) return false ; char num = char ( N ) ; char prefixConc = concatenatePrimeFactors ( N ) ; return int ( prefixConc ) ; }
bool isIdoneal ( int n ) { for ( int a = 1 ; a <= n ; a ++ ) { for ( int b = a + 1 ; b <= n ; b ++ ) { for ( int c = b + 1 ; c <= n ; c ++ ) { if ( a * b + b * c + c * a == n ) return false ; } } } return true ; }
bool isAllDigitsDivide ( int n ) { int temp = n ; while ( temp > 0 ) { int digit = temp % 10 ; if ( ! ( checkDivisibility ( n , digit ) ) ) return false ; temp /= 10 ; } return true ; }
bool isAllDigitsDistinct ( int n ) { bool arr [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; }
bool isLynchBell ( int n ) { return isAllDigitsDivide ( n ) && isAllDigitsDistinct ( n ) ; }
int printhexaRec ( int n ) { if ( n == 0 n == 1 n == 2 n == 3 n == 4 n == 5 ) return 0 ; else if ( n == 6 ) return 1 ; else return ( printhexaRec ( n - 1 ) + printhexaRec ( n - 2 ) + printhexaRec ( n - 3 ) + printhexaRec ( n - 4 ) + printhexaRec ( n - 5 ) + printhexaRec ( n - 6 ) ) ; }
void printhexa ( int n ) { if ( n < 0 ) return ; int first = 0 ; int second = 0 ; int third = 0 ; int fourth = 0 ; int fifth = 0 ; int sixth = 1 ; int curr = 0 ; if ( n < 6 ) cout << first << endl ; else if ( n == 6 ) cout << sixth << endl ; else { for ( int i = 6 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth + sixth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = sixth ; sixth = curr ; } } cout << curr << endl ; }
bool isGapful ( int n ) { int first_dig = firstDigit ( n ) ; int last_dig = lastDigit ( n ) ; int concatenation = first_dig * 10 + last_dig ; return ( n % concatenation == 0 ) ; }
bool check ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; }
bool isPossible ( int A , int B , int N , int K , int L ) { int needa , needb ; if ( A % K == 0 ) needa = A / K ; else needa = A / K + 1 ; if ( B % L == 0 ) needb = B / L ; else needb = B / L + 1 ; int total = needa + needb ; if ( total > N ) return false ; else return true ; }
void CountTotalfactors ( ) { tfactor [ 1 ] = pre [ 1 ] = 1 ; for ( lli i = 2 ; i <= MAX ; i ++ ) { lli mspf = spf [ i ] ; lli prim = mspf ; lli temp = i ; lli cnt = 0 ; while ( temp % mspf == 0 ) { temp /= mspf ; cnt += 1 ; prim = prim * mspf ; } tfactor [ i ] = ( cnt + 1 ) * tfactor [ temp ] ; pre [ i ] = pre [ i - 1 ] + tfactor [ i ] ; } }
lli BinarySearch ( lli X ) { lli start = 1 ; lli end = MAX - 1 ; while ( start < end ) { lli mid = ( start + end ) / 2 ; if ( pre [ mid ] == X ) return mid ; else if ( pre [ mid ] < X ) start = mid + 1 ; else end = mid ; } return start ; }
void buildSieve ( int sum ) { prime = vector < bool > ( sum + 1 , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < ( sum + 1 ) ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < ( sum + 1 ) ; i += p ) prime [ i ] = false ; } } }
int getSum ( int a [ 4 ] [ 5 ] ) { int s = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 5 ; j ++ ) s += a [ i ] [ j ] ; return s ; }
bool checkIndex ( int n , int m , int a [ 4 ] [ 5 ] ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) { if ( prime [ i + j ] && ! prime [ a [ i ] [ j ] ] ) { return false ; } } return true ; }
int takeSum ( int a [ N ] [ M ] ) { int s = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) s += a [ i ] [ j ] ; return s ; }
static long sumOfSumSeries ( int N ) { long sum = 0L ; for ( int i = 1 ; i <= N ; i ++ ) { sum = sum + ( i * ( i + 1 ) ) / 2 ; } return sum ; }
bool isPrime ( int n ) { if ( n == 1 ) return true ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
void checkExpression ( int n ) { if ( isPrime ( n ) ) cout << "Yes" ; else cout << "No" ; }
int placeValue ( int N , int num ) { int total = 1 , value = 0 , rem = 0 ; while ( true ) { rem = N % 10 ; N = N / 10 ; if ( rem == num ) { value = total * rem ; break ; } total = total * 10 ; } return value ; }
bool isContaindigit ( int n ) { while ( n > 0 ) { if ( ! ( n % 10 == 0 n % 10 == 1 n % 10 == 8 ) ) return false ; n = n / 10 ; } return true ; }
bool ispalindrome ( int n ) { string temp = to_string ( n ) ; int l = temp . length ( ) ; for ( int i = 0 ; i < l / 2 ; i ++ ) { if ( temp [ i ] != temp [ l - i - 1 ] ) return false ; } return true ; }
void printTetradicPrimesLessThanN ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; int p = 2 ; while ( p * p <= n ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i < n + 1 ; i += p ) prime [ i ] = false ; } p += 1 ; } for ( p = 2 ; p < n + 1 ; p ++ ) { if ( prime [ p ] && isTetradic ( p ) ) cout << p << " " ; } }
void BeattySequence ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { double ans = floor ( i * sqrt ( 2 ) ) ; cout << ans << ", " ; } }
int concat ( int a , int b ) { string s1 = to_string ( a ) ; string s2 = to_string ( b ) ; string s = s1 + s2 ; int c = stoi ( s ) ; return c ; }
bool isAstonishing ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += j ; if ( sum == n ) { int concatenation = concat ( i , j ) ; if ( concatenation == n ) { return true ; } } } } return false ; }
int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
bool isSelfNum ( int n ) { for ( int m = 1 ; m <= n ; m ++ ) { if ( m + getSum ( m ) == n ) return false ; } return true ; }
int Sum ( int N ) { int SumOfPrimeDivisors [ N + 1 ] = { 0 } ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! SumOfPrimeDivisors [ i ] ) { for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; }
bool RuthAaronNumber ( int n ) { if ( Sum ( n ) == Sum ( n + 1 ) ) return true ; else return false ; }
int binomialCoeff ( int n , int k ) { int C [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
bool SieveOfEratosthenes ( int n , bool isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } }
int countDigit ( long long n ) { return floor ( log10 ( n ) + 1 ) ; }
stack < int > sortStack ( stack < int > input ) { stack < int > tmpStack ; while ( ! input . empty ( ) ) { int tmp = input . top ( ) ; input . pop ( ) ; while ( ! tmpStack . empty ( ) && tmpStack . top ( ) < tmp ) { input . push ( tmpStack . top ( ) ) ; tmpStack . pop ( ) ; } tmpStack . push ( tmp ) ; } return tmpStack ; }
void sortArrayUsingStacks ( int arr [ ] , int n ) { stack < int > input ; for ( int i = 0 ; i < n ; i ++ ) input . push ( arr [ i ] ) ; stack < int > tmpStack = sortStack ( input ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = tmpStack . top ( ) ; tmpStack . pop ( ) ; } }
int getSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum ; }
bool MultiplyPerfectNumber ( int n ) { if ( getSum ( n ) % n == 0 ) return true ; else return false ; }
int phi ( int n ) { int result = n ; for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result -= result / p ; } } if ( n > 1 ) result -= result / n ; return result ; }
bool isPower ( int a ) { if ( a == 1 ) return true ; for ( int i = 2 ; i * i <= a ; i ++ ) { double val = log ( a ) / log ( i ) ; if ( ( val - ( int ) val ) < 0.00000001 ) return true ; } return false ; }
bool isCunningham ( int n ) { return isPower ( n - 1 ) || isPower ( n + 1 ) ; }
int checkSame ( int n , int b ) { map < int , int > m ; while ( n != 0 ) { int r = n % b ; n = n / b ; m [ r ] ++ ; } int last = -1 ; for ( auto i = m . begin ( ) ; i != m . end ( ) ; i ++ ) { if ( last != -1 && i -> second != last ) { return false ; } else { last = i -> second ; } } }
long int SubArrayProdct ( int arr [ ] , int n ) { long int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) result *= pow ( arr [ i ] , ( i + 1 ) * ( n - i ) ) ; return result ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int countWays ( int m , int n , int x , int y ) { return nCr ( m + n , m ) - nCr ( x + y , x ) * nCr ( m + n - x - y , m - x ) ; }
double averageRuns ( int runs , int matches , int notout ) { int out = matches - notout ; if ( out == 0 ) return -1 ; double avg = double ( runs ) / out ; return avg ; }
int seriesSum ( int n ) { int sum = 0 ; int currProd = 1 ; int currSum = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { currProd *= i ; currSum += i ; sum += currProd - currSum ; } return sum ; }
int seriesSumUtil ( int k , int n , int prevSum , int multi , int add ) { if ( k == n + 1 ) { return prevSum ; } multi = multi * k ; add = add + k ; prevSum = prevSum + multi - add ; return seriesSumUtil ( k + 1 , n , prevSum , multi , add ) ; }
int seriesSum ( int n ) { if ( n == 1 ) return 0 ; int prevSum = 0 ; int multi = 1 ; int add = 1 ; return seriesSumUtil ( 2 , n , prevSum , multi , add ) ; }
void Is_possible ( long long int N ) { int C = 0 ; int D = 0 ; while ( N % 10 == 0 ) { N = N / 10 ; C += 1 ; } if ( pow ( 2 , ( int ) log2 ( N ) ) == N ) { D = ( int ) log2 ( N ) ; if ( C >= D ) cout << "YES" ; else cout << "NO" ; } else cout << "NO" ; }
int maximumAND ( int L , int R ) { return R ; }
int count ( int a [ ] , int n ) { int countElements = 0 ; for ( int i = 0 ; i < n ; i ++ ) { bool flag = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; if ( a [ i ] % a [ j ] == 0 ) { flag = false ; break ; } } if ( flag == true ) ++ countElements ; } return countElements ; }
int countEle ( int a [ ] , int n ) { int len = 0 ; unordered_map < int , int > hmap ; for ( int i = 0 ; i < n ; i ++ ) { len = max ( len , a [ i ] ) ; hmap [ a [ i ] ] ++ ; } bool v [ len + 1 ] ; for ( int i = 0 ; i <= len ; i ++ ) { v [ i ] = true ; } for ( int i = 0 ; i < n ; i ++ ) { if ( v [ a [ i ] ] == false ) continue ; for ( int j = 2 * a [ i ] ; j <= len ; j += a [ i ] ) { v [ j ] = false ; } } int count = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { if ( v [ i ] == true && hmap . count ( i ) == 1 && hmap [ i ] == 1 ) { count += 1 ; } } return count ; }
int find_min_sum ( int a , int b , int c ) { int x , y , g ; if ( ! possible_solution ( a , b , c , & x , & y , & g ) ) return -1 ; a /= g ; b /= g ; int sign_a = a > 0 ? +1 : -1 ; int sign_b = b > 0 ? +1 : -1 ; shift_solution ( & x , & y , a , b , - x / b ) ; if ( x < 0 ) shift_solution ( & x , & y , a , b , sign_b ) ; int minx1 = x ; shift_solution ( & x , & y , a , b , y / a ) ; if ( y < 0 ) shift_solution ( & x , & y , a , b , - sign_a ) ; int minx2 = x ; if ( minx2 > x ) swap ( minx2 , x ) ; int minx = max ( minx1 , minx2 ) ; if ( minx > x ) return -1 ; int miny = ( c - a * x ) / b ; return ( miny + minx ) ; }
int countPairs ( int A [ ] , int n ) { int count = 0 , i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( A [ i ] % 2 == 0 && A [ j ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ j ] % 2 != 0 ) ) count ++ ; } } return count ; }
int smallestNumber ( int N ) { return N * ceil ( pow ( 10 , ( N - 1 ) ) / N ) ; }
int maxPrimefactorNum ( int N ) { int arr [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) arr [ i ] = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( arr [ i ] == 1 ) { for ( int j = i ; j <= N ; j += i ) { arr [ j ] *= i ; } } } int maxValue = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( arr [ i ] > maxValue ) { maxValue = i ; } } return maxValue ; }
int linearSum ( int n ) { return ( n * ( n + 1 ) / 2 ) % mod ; }
int rangeSum ( int b , int a ) { return ( linearSum ( b ) - linearSum ( a ) ) % mod ; }
int totalSum ( int n ) { int result = 0 ; int i = 1 ; while ( true ) { result += rangeSum ( n / i , n / ( i + 1 ) ) * ( i % mod ) % mod ; result %= mod ; if ( i == n ) break ; i = n / ( n / ( i + 1 ) ) ; } return result ; }
int CountPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] % 2 == 0 arr [ j ] % 2 == 0 ) count ++ ; } } return count ; }
bool isPal ( int a [ 3 ] [ 3 ] , int n , int m ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) return false ; } } return true ; }
int smallestNum ( int n ) { cout << pow ( 10 , n * n / 9 ) << endl ; return ( n * n % 9 + 1 ) * pow ( 10 , n * n / 9 ) - 1 ; }
void smallestNumber ( int N ) { cout << ( N % 9 + 1 ) * pow ( 10 , ( N / 9 ) ) - 1 ; }
void findNthTerm ( int n ) { cout << n * ( 5 * n + 3 ) / 2 << endl ; }
void findNthTerm ( int n ) { cout << n * ( 2 * n + 1 ) << endl ; }
int reversDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }
bool isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; }
bool isRare ( int N ) { int reverseN = reversDigits ( N ) ; if ( reverseN == N ) return false ; return isPerfectSquare ( N + reverseN ) && isPerfectSquare ( N - reverseN ) ; }
int getProduct ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; }
bool isDouble ( int num ) { string s = to_string ( num ) ; int l = s . length ( ) ; if ( s [ 0 ] == s [ 1 ] ) return false ; if ( l % 2 == 1 ) { s = s + s [ 1 ] ; l ++ ; } string s1 = s . substr ( 0 , l / 2 ) ; string s2 = s . substr ( l / 2 ) ; return s1 == s2 ; }
bool isNontrivialUndulant ( int N ) { return N > 100 && isDouble ( N ) ; }
void findNthTerm ( int n ) { cout << n * ( 4 * n + 3 ) << endl ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
bool isAdditivePrime ( int n ) { if ( ! isPrime ( n ) ) return false ; return isPrime ( getSum ( n ) ) ; }
bool isStraighLineNum ( int N ) { if ( N <= 99 ) return false ; string str = to_string ( N ) ; int d = str [ 1 ] - str [ 0 ] ; for ( int i = 2 ; i < str . length ( ) ; i ++ ) if ( str [ i ] - str [ i - 1 ] != d ) return false ; return true ; }
void findNthTerm ( int n ) { cout << pow ( 2 , n ) - 2 * n << endl ; }
bool isEvenOddForm ( string s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 && s [ i ] % 2 != 0 ) return false ; if ( i % 2 == 1 && s [ i ] % 2 != 1 ) return false ; } return true ; }
bool isOddEvenForm ( string s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 && s [ i ] % 2 != 1 ) return false ; if ( i % 2 == 1 && s [ i ] % 2 != 0 ) return false ; } return true ; }
bool isAlternating ( int n ) { string str = to_string ( n ) ; return ( isEvenOddForm ( str ) || isOddEvenForm ( str ) ) ; }
void findNthTerm ( int n ) { cout << n * n - n + 1 << endl ; }
bool isDroll ( int n ) { if ( n == 1 ) return false ; int sum_even = 0 ; int sum_odd = 0 ; while ( n % 2 == 0 ) { sum_even += 2 ; n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { sum_odd += i ; n = n / i ; } } if ( n > 2 ) sum_odd += n ; return sum_even == sum_odd ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool areAnagrams ( int a , int b ) { int freqA [ TEN ] = { 0 } ; int freqB [ TEN ] = { 0 } ; updateFreq ( a , freqA ) ; updateFreq ( b , freqB ) ; for ( int i = 0 ; i < TEN ; i ++ ) { if ( freqA [ i ] != freqB [ i ] ) return false ; } return true ; }
int DecakismyriagonNum ( int N ) { return ( 99998 * N * N - 99996 * N ) / 2 ; }
bool iszygodromeNum ( int N ) { string s = to_string ( N ) ; s = ' ' + s + ' ' ; for ( int i = 1 ; i < s . size ( ) - 1 ; i ++ ) { if ( s [ i ] != s [ i - 1 ] && s [ i ] != s [ i + 1 ] ) { return false ; } } return true ; }
bool isLoeschian ( int n ) { for ( int x = 1 ; x <= sqrt ( n ) ; x ++ ) { for ( int y = 1 ; y <= sqrt ( n ) ; y ++ ) { if ( x * x + x * y + y * y == n ) return true ; } } return false ; }
void printSeries ( int N ) { int ith_term = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ith_term = ( 13 * i * ( i - 1 ) ) / 2 + 2 ; cout << ith_term << ", " ; } }
void printSeries ( int n , int a , int b , int c ) { int d ; if ( n == 1 ) { cout << a << " " ; return ; } if ( n == 2 ) { cout << a << " " << b << " " ; return ; } cout << a << " " << b << " " << c << " " ; for ( int i = 4 ; i <= n ; i ++ ) { d = a + b + c ; cout << d << " " ; a = b ; b = c ; c = d ; } }
void sieveSundaram ( ) { bool marked [ MAX / 2 + 1 ] = { 0 } ; for ( int i = 1 ; i <= ( sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j += 2 * i + 1 ) marked [ j ] = true ; primes . push_back ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . push_back ( 2 * i + 1 ) ; }
vector < pair < int , int > > Pairs ( int C ) { vector < pair < int , int > > ans ; for ( int i = 1 ; i < C ; i ++ ) { for ( int j = i + 1 ; j < C ; j ++ ) { if ( ( i * i ) + ( j * j ) == ( C * C ) ) { ans . push_back ( make_pair ( i , j ) ) ; } } } return ans ; }
float strikerate ( int bowls , int runs ) { float z ; z = ( float ( runs ) / bowls ) * 100 ; return z ; }
int factorize ( int N ) { int count = 0 ; int cnt = 0 ; while ( ( N % 2 ) == 0 ) { N = N / 2 ; count ++ ; } cnt = cnt + count ; for ( int i = 3 ; i <= sqrt ( N ) ; i += 2 ) { count = 0 ; while ( N % i == 0 ) { count ++ ; N = N / i ; } cnt = cnt + count ; } if ( N > 2 ) cnt = cnt + 1 ; return cnt ; }
void ifNumberExists ( int X , int Y ) { int C , dsum ; C = X - Y - 1 ; dsum = factorize ( X ) ; if ( dsum >= C ) cout << "YES \n" ; else cout << "NO \n" ; }
bool checkArray ( int n , int k , int arr [ ] ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; }
void print_nearest_prime ( int arr [ ] , int N ) { int maxm = * max_element ( arr , arr + N ) ; SieveOfEratosthenes ( maxm ) ; vector < int > primes ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! prime [ arr [ i ] ] ) primes . push_back ( i ) ; } if ( primes . size ( ) == 0 ) { for ( int i = 0 ; i < N ; i ++ ) { cout << -1 << " " ; } return ; } int curr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( curr == primes . size ( ) - 1 || i <= primes [ curr ] ) { cout << arr [ primes [ curr ] ] << " " ; continue ; } if ( abs ( primes [ curr ] - i ) < abs ( primes [ curr + 1 ] - i ) ) { cout << arr [ primes [ curr ] ] << " " ; } else { curr ++ ; cout << arr [ primes [ curr ] ] << " " ; } } }
int CountPairs ( int n ) { int cnt = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int div1 = i ; int div2 = n / i ; int sum = div1 + div2 ; if ( gcd ( sum , n ) == 1 ) cnt += 1 ; } } return cnt ; }
void allQuotients ( int N ) { set < int > s ; for ( int k = 1 ; k <= N + 1 ; k ++ ) { s . insert ( N / k ) ; } for ( auto it : s ) cout << it << " " ; }
void findPosition ( int n ) { int i = 0 ; int pos = 0 ; while ( n > 0 ) { if ( n % 10 == 7 ) { pos = pos + pow ( 2 , i + 1 ) ; } else { pos = pos + pow ( 2 , i ) ; } i ++ ; n = n / 10 ; } cout << pos ; }
int greatestOddFactor ( int n ) { int pow_2 = ( int ) ( log ( n ) ) ; int i = 1 ; while ( i <= pow_2 ) { int fac_2 = ( 2 * i ) ; if ( n % fac_2 == 0 ) { if ( ( n / fac_2 ) % 2 == 1 ) { return ( n / fac_2 ) ; } } i += 1 ; } }
void countSmaller ( string str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] < str [ i ] ) { cnt += 1 ; } } cout << cnt << " " ; } }
int sum_star_num ( int n ) { int summ = 2 * n * ( n + 1 ) * ( n - 1 ) + n ; return summ ; }
void solve ( int n , const vector < pair < int , int > > & vec ) { vector < int > a , b ; for ( auto pr : vec ) { a . push_back ( pr . first ) ; b . push_back ( pr . second ) ; } sort ( a . begin ( ) , a . end ( ) ) ; sort ( b . begin ( ) , b . end ( ) ) ; int left , right , ans ; if ( ( n & 1 ) ) { left = a [ n / 2 ] ; right = b [ n / 2 ] ; ans = right - left + 1 ; } else { left = ( a [ n / 2 ] + a [ n / 2 - 1 ] ) ; right = ( b [ n / 2 ] + b [ n / 2 - 1 ] ) ; ans = right - left + 1 ; } cout << ans << endl ; }
int find_pairs ( int ar [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mp [ ar [ i ] ] ++ ; } for ( auto i : mp ) { int count = i . second ; if ( count > 1 ) { ans += ( ( count * ( count - 1 ) ) / 2 ) ; } } return ans ; }
string Majority_in_linklist ( node * head ) { string s = "" , t = "" ; int p = 0 , q = 0 ; node * ptr = NULL ; while ( head != NULL ) { if ( s . compare ( head -> i ) == 0 ) { p = p + 1 ; } else { if ( t . compare ( head -> i ) == 0 ) { q = q + 1 ; } else { if ( p == 0 ) { s = head -> i ; p = 1 ; } else { if ( q == 0 ) { t = head -> i ; q = 1 ; } else { p = p - 1 ; q = q - 1 ; } } } } head = head -> next ; } head = ptr ; p = 0 ; q = 0 ; while ( head != NULL ) { if ( s . compare ( head -> i ) == 0 ) { p = 1 ; } else { if ( t . compare ( head -> i ) == 0 ) { q = 1 ; } } head = head -> next ; } if ( p > q ) { return s ; } else { return t ; } }
int gonNum65537 ( int n ) { return ( 65535 * n * n - 65533 * n ) / 2 ; }
int MegagonNum ( int n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; }
int gonNum120 ( int n ) { return ( 118 * n * n - 116 * n ) / 2 ; }
int TetracontaoctagonalNum ( int n ) { return ( 46 * n * n - 44 * n ) / 2 ; }
int TetracontadigonalNum ( int n ) { return ( 40 * n * n - 38 * n ) / 2 ; }
int HexacontatetragonNum ( int n ) { return ( 62 * n * n - 60 * n ) / 2 ; }
int binpow ( int a , int b ) { int res = 1 ; while ( b ) { if ( b & 1 ) res = res * a ; a = a * a ; b /= 2 ; } return res ; }
bool checkOverlapping ( vector < int > a , vector < int > b ) { if ( a [ 0 ] < b [ 0 ] ) { a . swap ( b ) ; } if ( b [ 0 ] <= a [ 0 ] <= b [ 1 ] ) return true ; return false ; }
int find ( int a [ ] , int i ) { if ( a [ i ] == i ) return i ; a [ i ] = find ( a , a [ i ] ) ; return a [ i ] ; }
bool checkNonOverlapping ( vector < vector < int > > arr , int n ) { int dsu [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) dsu [ i ] = i ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( checkOverlapping ( arr [ i ] , arr [ j ] ) ) { if ( Union ( dsu , i , j ) ) { return false ; } } } } return true ; }
bool isPossible ( int A , int B ) { return ( A - B > 1 ) ; }
int minDivisorDifference ( int n ) { int num1 ; int num2 ; for ( int i = sqrt ( n ) ; i <= n ; i ++ ) { if ( n % i == 0 ) { num1 = i ; num2 = n / i ; break ; } } return abs ( num1 - num2 ) ; }
int dfs ( vector < int > g [ ] , int u , int par ) { sub [ u ] = minDivisorDifference ( u ) ; int mx = 0 ; for ( auto c : g [ u ] ) { if ( c != par ) { int ans = dfs ( g , c , u ) ; mx = max ( mx , ans ) ; } } sub [ u ] += mx ; return sub [ u ] ; }
int findLCMPrime ( int a , int b ) { if ( a == b ) { return a ; } return a * b ; }
void smallestNumber ( int N ) { cout << N * ceil ( pow ( 2 , ( N - 1 ) ) / N ) ; }
void smallestNumber ( int N ) { cout << N * floor ( ( pow ( 10 , N ) - 1 ) / N ) ; }
bool istriacontagonal ( int N ) { float n = ( 26 + sqrt ( 224 * N + 676 ) ) / 56 ; return ( n - ( int ) n ) == 0 ; }
void checkSolution ( int a , int b , int c ) { if ( a == c ) cout << "Yes" ; else cout << "No" ; }
bool isComposite ( int n ) { if ( n <= 3 ) return false ; if ( n % 2 == 0 or n % 3 == 0 ) return true ; int i = 5 ; while ( i * i <= n ) { if ( n % i == 0 or n % ( i + 2 ) == 0 ) return true ; i = i + 6 ; } return false ; }
void Compositorial_list ( int n ) { int l = 0 ; for ( int i = 4 ; i < 1000000 ; i ++ ) { if ( l < n ) { if ( isComposite ( i ) ) { compo . push_back ( i ) ; l += 1 ; } } } }
int calculateCompositorial ( int n ) { int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) result = result * compo [ i ] ; return result ; }
void numberOfDigits ( int N ) { int nod = floor ( log10 ( N ) + 1 ) ; int toDecrease = ( pow ( 10 , nod ) - 1 ) / 9 ; cout << ( N + 1 ) * nod - toDecrease << endl ; }
void Maxlength ( int arr [ ] , int N ) { vector < int > zeroindex ; int maxlen ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zeroindex . push_back ( i ) ; } if ( zeroindex . size ( ) == 0 ) { maxlen = N ; } else { maxlen = zeroindex [ 0 ] ; for ( int i = 0 ; i < zeroindex . size ( ) - 1 ; i ++ ) { if ( zeroindex [ i + 1 ] - zeroindex [ i ] - 1 > maxlen ) { maxlen = zeroindex [ i + 1 ] - zeroindex [ i ] - 1 ; } } if ( N - zeroindex [ zeroindex . size ( ) - 1 ] - 1 > maxlen ) { maxlen = N - zeroindex [ zeroindex . size ( ) - 1 ] - 1 ; } } cout << maxlen << endl ; }
bool isPossible ( int arr [ ] , int N , int K ) { int oddCount = 0 , evenCount = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) evenCount ++ ; else oddCount ++ ; } if ( evenCount == N || ( oddCount == N && K % 2 == 0 ) || ( K == N && oddCount % 2 == 0 ) ) return false ; else return true ; }
float productOfGP ( float a , float r , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = product * a ; a = a * r ; } return product ; }
float productOfGP ( float a , float r , int n ) { return pow ( a , n ) * pow ( r , n * ( n - 1 ) / 2 ) ; }
float productOfGP ( float a , float r , int n ) { int an = a * pow ( r , n - 1 ) ; return sqrt ( pow ( a * an , n ) ) ; }
bool is_Chiliagon ( int N ) { float n = ( 996 + sqrt ( 7984 * N + 992016 ) ) / 1996 ; return ( n - ( int ) n ) == 0 ; }
int commonSubarrays ( int * A , int * B , int N ) { int Map [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) Map [ * ( A + i ) ] = i ; for ( int i = 0 ; i < N ; i ++ ) { * ( B + i ) = Map [ * ( B + i ) ] ; } int count = 0 ; int i = 0 , K ; while ( i < N ) { K = 1 ; i += 1 ; while ( i < N && B [ i ] == B [ i - 1 ] + 1 ) { i += 1 ; K += 1 ; } count = count + ( ( K ) * ( K + 1 ) ) / 2 ; } return count ; }
void getArrayOfSizeK ( int n , int k ) { vector < int > ans ; int odd = n - ( ( k - 1 ) * 1 ) ; if ( odd > 0 && odd % 2 != 0 ) { for ( int i = 0 ; i < k - 1 ; i ++ ) { ans . push_back ( 1 ) ; } ans . push_back ( odd ) ; } int even = n - ( ( k - 1 ) * 2 ) ; if ( even > 0 && even % 2 == 0 && ans . size ( ) == 0 ) { for ( int i = 0 ; i < k - 1 ; i ++ ) { ans . push_back ( 2 ) ; } ans . push_back ( even ) ; } if ( ans . size ( ) > 0 ) { for ( int i = 0 ; i < k ; i ++ ) { cout << ans [ i ] << " " ; } } else { cout << "NO" << endl ; } }
bool checkDivisbility ( int num ) { int digit ; int N = num ; while ( num != 0 ) { digit = num % 10 ; num = num / 10 ; if ( digit == 0 N % digit != 0 ) return false ; } return true ; }
int inv ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; }
int derivative ( int x ) { return 3 * x * x ; }
int Image ( int x , int k ) { return x * x * x - k ; }
int next_power ( int a_t , int t , int a1 , int prime , int k ) { int power_p = ( int ) pow ( prime , t + 1 ) ; int next_a = ( a_t - Image ( a_t , k ) * inv ( derivative ( a1 ) , prime ) ) % power_p ; if ( next_a < 0 ) return next_a += power_p ; return next_a ; }
int powerOfPrime ( int prime , int power , int k , int a1 ) { if ( derivative ( a1 ) != 0 ) { int a_t = a1 ; for ( int p = 1 ; p < power ; p ++ ) { a_t = next_power ( a_t , p , a1 , prime , k ) ; } return a_t ; } return -1 ; }
int findlcm ( int arr [ ] , int n ) { int ans = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { ans = ( ( ( arr [ i ] * ans ) ) / ( gcd ( arr [ i ] , ans ) ) ) ; } return ans ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int minLCM ( int arr [ ] , int n ) { int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int g = gcd ( arr [ i ] , arr [ j ] ) ; int lcm = arr [ i ] / g * arr [ j ] ; ans = min ( ans , lcm ) ; } } return ans ; }
int minLCM ( int arr [ ] , int n ) { int mx = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mx = max ( mx , arr [ i ] ) ; } vector < vector < int > > mul ( mx + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mul [ arr [ i ] ] . size ( ) > 1 ) { continue ; } mul [ arr [ i ] ] . push_back ( arr [ i ] ) ; } for ( int i = 1 ; i <= mx ; i ++ ) { for ( int j = i + i ; j <= mx ; j += i ) { if ( mul [ i ] . size ( ) > 1 ) { break ; } for ( int k : mul [ j ] ) { if ( mul [ i ] . size ( ) > 1 ) break ; mul [ i ] . push_back ( k ) ; } } } int ans = INT_MAX ; for ( int i = 1 ; i <= mx ; i ++ ) { if ( mul [ i ] . size ( ) <= 1 ) continue ; int a = mul [ i ] [ 0 ] , b = mul [ i ] [ 1 ] ; int lcm = ( a * b ) / i ; ans = min ( ans , lcm ) ; } return ans ; }
bool isSuffix ( string s1 , string s2 ) { int n1 = s1 . length ( ) ; int n2 = s2 . length ( ) ; if ( n1 > n2 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; }
bool CheckBinaryEquivalent ( int N ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; int c = pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } string bin = to_string ( B_Number ) ; return isSuffix ( "001" , bin ) ; }
bool CheckBinaryEquivalent ( int N ) { return ( N - 1 ) % 8 == 0 ; }
void print_practica_No ( int A , int B ) { for ( int i = A ; i <= B ; i ++ ) { if ( Is_Practical ( i ) == true ) { cout << i << " " ; } } }
float maxDivision ( int arr [ ] , int n ) { sort ( arr , arr + n , greater < int > ( ) ) ; float mxdiv = arr [ 1 ] ; for ( int i = 2 ; i < n ; ++ i ) mxdiv = mxdiv / arr [ i ] ; return arr [ 0 ] / mxdiv ; }
void solve ( int n ) { int upper_limit = ceil ( pow ( n , 1.0 / 4 ) ) ; for ( int x = 0 ; x <= upper_limit ; x ++ ) { for ( int y = 0 ; y <= upper_limit ; y ++ ) { int num1 = x * x * x * x ; int num2 = y * y * y * y ; if ( num1 - num2 == n ) { cout << "x = " << x << ", y = " << y ; return ; } } } cout << -1 << endl ; }
int productPairs ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; }
int power ( int x , unsigned int y ) { int p = 1000000007 ; int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
ll productPairs ( ll arr [ ] , ll n ) { ll product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = ( product % mod * ( int ) power ( arr [ i ] , ( 2 * n ) ) % mod ) % mod ; } return product % mod ; }
int numPairsWithPrimeSum ( int * arr , int n ) { int N = 2 * 1000000 ; bool * isPrime = sieveOfEratosthenes ( N ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( isPrime [ sum ] ) { count ++ ; } } } return count ; }
void constructArray ( int N ) { int arr [ N ] ; for ( int i = 1 ; i <= N ; i ++ ) { arr [ i - 1 ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << ", " ; } }
void digitsPresent ( int n ) { int lastDigit ; while ( n != 0 ) { lastDigit = n % 10 ; digit [ lastDigit ] = true ; n /= 10 ; } }
int checkLastDigit ( int num ) { int count = 0 ; int lastDigit ; lastDigit = num % 10 ; if ( digit [ lastDigit ] == true ) count ++ ; return count ; }
bool divisorsSame ( int n ) { int even_div = 0 , odd_div = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { if ( i % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } } else { if ( i % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } if ( n / i % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } } } } return ( even_div == odd_div ) ; }
void sieveoferanthones ( ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( long long int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( prime [ i ] ) for ( long long int j = i * i ; j <= n ; j += i ) { prime [ j ] = false ; } } for ( long long int i = 2 ; i < n ; i ++ ) { if ( prime [ i ] ) v . push_back ( i ) ; } }
int find ( int K , int N ) { N -- ; while ( N -- ) { int curr_term = K ; int min_d = 9 ; int max_d = 0 ; while ( curr_term > 0 ) { int r = curr_term % 10 ; min_d = min ( min_d , r ) ; max_d = max ( max_d , r ) ; curr_term = curr_term / 10 ; } if ( min_d == 0 ) { break ; } K = K + min_d * max_d ; } return K ; }
double Convert ( double degree ) { double pi = 3.14159265359 ; return ( degree * ( pi / 180 ) ) ; }
lli countSubarrays ( int arr [ ] , int n ) { unordered_map < int , int > mp ; int prefixSum [ n ] ; int prefixMin = 0 ; prefixSum [ 0 ] = arr [ 0 ] ; prefixMin = min ( prefixMin , prefixSum [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] ; prefixMin = min ( prefixMin , prefixSum [ i ] ) ; } lli countSubs = 0 ; mp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; prefixSum [ i ] - j * j >= prefixMin ; j ++ ) { if ( mp . find ( prefixSum [ i ] - j * j ) != mp . end ( ) ) countSubs += mp [ prefixSum [ i ] - j * j ] ; } mp [ prefixSum [ i ] ] ++ ; } return countSubs ; }
bool checkSolution ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { return ( a1 / a2 ) == ( b1 / b2 ) && ( b1 / b2 ) == ( c1 / c2 ) ; }
int chiliagonNum ( int n ) { return ( 998 * n * n - 996 * n ) / 2 ; }
void checkSolution ( int a , int b , int c ) { if ( b == 0 ) cout << "Yes" ; else cout << "No" ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool isBalancedPrime ( int n ) { if ( ! isPrime ( n ) n == 2 ) return false ; int previous_prime = n - 1 ; int next_prime = n + 1 ; while ( ! isPrime ( next_prime ) ) next_prime ++ ; while ( ! isPrime ( previous_prime ) ) previous_prime -- ; int mean = ( previous_prime + next_prime ) / 2 ; if ( n == mean ) return true ; else return false ; }
int pentacontagonNum ( int n ) { return ( 48 * n * n - 46 * n ) / 2 ; }
void positiveProduct ( int arr [ ] , int n ) { int even_count = 0 ; int odd_count = 0 ; int total_count = 0 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( total_count % 2 == 0 ) even_count ++ ; else odd_count ++ ; if ( arr [ i ] < 0 ) total_count ++ ; if ( total_count % 2 == 0 ) ans += even_count ; else ans += odd_count ; } cout << ans << "\n" ; }
int sumOfGCDofPairs ( int n ) { int res = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int d1 = i ; int d2 = n / i ; res += d1 * getCount ( d1 , n ) ; if ( d1 != d2 ) res += d2 * getCount ( d2 , n ) ; } } return res ; }
bool checkIsFibonacci ( int arr [ ] , int n ) { if ( n == 1 n == 2 ) return true ; sort ( arr , arr + n ) ; for ( int i = 2 ; i < n ; i ++ ) if ( ( arr [ i - 1 ] + arr [ i - 2 ] ) != arr [ i ] ) return false ; return true ; }
int lastDigitFactorial ( unsigned int n ) { if ( n == 0 ) return 1 ; else if ( n <= 2 ) return n ; else if ( n == 3 ) return 6 ; else if ( n == 4 ) return 4 ; else return 0 ; }
int lastDigit2PowerN ( int n ) { if ( n == 0 ) return 1 ; else if ( n % 4 == 1 ) return 2 ; else if ( n % 4 == 2 ) return 4 ; else if ( n % 4 == 3 ) return 8 ; else }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int sumSubsequences ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int kLengthSubSequence ; kLengthSubSequence = nCr ( n , k ) ; int ans = sum * ( ( k * kLengthSubSequence ) / n ) ; return ans ; }
bool hasOddNumberOfDivisors ( int n ) { if ( ( double ) sqrt ( n ) == ( int ) sqrt ( n ) ) return true ; return false ; }
int dfs ( int node , int parent ) { int count = 0 ; for ( auto i = adj [ node ] . begin ( ) ; i != adj [ node ] . end ( ) ; ++ i ) { if ( * i != parent ) { count += dfs ( * i , node ) ; } } if ( hasOddNumberOfDivisors ( a [ node ] ) ) ++ count ; ans [ node ] = count ; return count ; }
int costCalculation ( int current , int arr [ ] , int n , int pref [ ] , int a , int r , int minimum ) { int index = lower_bound ( arr , arr + n , current ) - arr ; int left = index * current - pref [ index ] ; int right = pref [ n ] - pref [ index ] - ( n - index ) * current ; int res = min ( left , right ) ; left -= res ; right -= res ; int total = res * minimum ; total += left * a ; total += right * r ; return total ; }
void solve ( int arr [ ] , int n , int a , int r , int m ) { sort ( arr , arr + n ) ; int minimum = min ( a + r , m ) ; int pref [ n + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) pref [ i + 1 ] = pref [ i ] + arr [ i ] ; int ans = 10000 ; for ( int i = 0 ; i < n ; i ++ ) ans = min ( ans , costCalculation ( arr [ i ] , arr , n , pref , a , r , minimum ) ) ; ans = min ( ans , costCalculation ( pref [ n ] / n , arr , n , pref , a , r , minimum ) ) ; ans = min ( ans , costCalculation ( pref [ n ] / n + 1 , arr , n , pref , a , r , minimum ) ) ; cout << ans << "\n" ; }
int findSum ( int n , int k ) { int val = ( k / ( n - 1 ) ) * n ; int rem = k % ( n - 1 ) ; if ( rem == 0 ) { val = val - 1 ; } else { val = val + rem ; } int sum = ( val * ( val + 1 ) ) / 2 ; int x = k / ( n - 1 ) ; int sum_of_multiples = ( x * ( x + 1 ) * n ) / 2 ; sum -= sum_of_multiples ; return sum ; }
vector < int > getFactorization ( int x ) { int count = 0 ; vector < int > v ; while ( x % 2 == 0 ) { count ++ ; x = x / 2 ; } if ( count != 0 ) v . push_back ( count ) ; for ( int i = 3 ; i <= sqrt ( x ) ; i += 2 ) { count = 0 ; while ( x % i == 0 ) { count ++ ; x /= i ; } if ( count != 0 ) v . push_back ( count ) ; } if ( x > 1 ) { v . push_back ( 1 ) ; } return v ; }
int nonPrimeDivisors ( int N ) { vector < int > v = getFactorization ( N ) ; int ret = 1 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) ret = ret * ( v [ i ] + 1 ) ; ret = ret - v . size ( ) ; return ret ; }
bool isPerfectSquare ( int x ) { int s = sqrt ( x ) ; return ( s * s == x ) ; }
bool isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
bool checkDigits ( int n ) { while ( n ) { int dig = n % 10 ; if ( dig == 4 && dig == 6 && dig == 7 && dig == 9 ) return false ; n /= 10 ; } return true ; }
int isFullfibonacci ( int n ) { return ( checkDigits ( n ) && isFibonacci ( n ) ) ; }
bool checksilverRatio ( float a , float b ) { if ( a < b ) swap ( a , b ) ; float ratio1 = ( ( a / b ) * 1000.0 ) / 1000.0 ; float ratio2 = ( int ) ( ( ( 2 * a + b ) / a ) * 1000 ) ; ratio2 = ratio2 / 1000 ; if ( ratio1 == ratio2 && ( int ) ( ratio1 - 2.414 ) == 0 ) { cout << "Yes\n" ; return true ; } else { cout << "No\n" ; return false ; } }
int MIN ( int n ) { int ans = 11 ; while ( n ) { ans = min ( ans , n % 10 ) ; n /= 10 ; } return ans ; }
int MAX ( int n ) { int ans = -1 ; while ( n ) { ans = max ( ans , n % 10 ) ; n /= 10 ; } return ans ; }
void Find_value ( int n , int k ) { k -- ; int x = 0 ; int y = 0 ; while ( k -- ) { x = MIN ( n ) ; y = MAX ( n ) ; if ( y - x == 0 ) break ; n *= ( y - x ) ; } cout << n ; }
int countBinaries ( int N ) { int ctr = 1 ; int ans = 0 ; while ( N > 0 ) { if ( N % 10 == 1 ) { ans += pow ( 2 , ctr - 1 ) ; } else if ( N % 10 > 1 ) { ans = pow ( 2 , ctr ) - 1 ; } ctr ++ ; N /= 10 ; } return ans ; }
int countBinaries ( int N ) { vector < int > powersOfTwo ( 11 ) ; powersOfTwo [ 0 ] = 1 ; for ( int i = 1 ; i < 11 ; i ++ ) { powersOfTwo [ i ] = powersOfTwo [ i - 1 ] * 2 ; } int ctr = 1 ; int ans = 0 ; while ( N > 0 ) { if ( N % 10 == 1 ) { ans += powersOfTwo [ ctr - 1 ] ; } else if ( N % 10 > 1 ) { ans = powersOfTwo [ ctr ] - 1 ; } ctr ++ ; N /= 10 ; } return ans ; }
int sum_Centered_Hexadecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Hexadecagonal_num ( i ) ; } return summ ; }
int heptadecagonal_num ( int n ) { return ( ( 15 * n * n ) - 13 * n ) / 2 ; }
int sum_heptadecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += heptadecagonal_num ( i ) ; } return summ ; }
int center_heptagonal_num ( int n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; }
int sum_center_heptagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += center_heptagonal_num ( i ) ; } return summ ; }
int Centered_Dodecagonal_num ( int n ) { return 6 * n * ( n - 1 ) + 1 ; }
int sum_Centered_Dodecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Dodecagonal_num ( i ) ; } return summ ; }
int center_Octagonal_num ( int n ) { return ( 4 * n * n - 4 * n + 1 ) ; }
int sum_center_Octagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += center_Octagonal_num ( i ) ; } return summ ; }
int Centered_decagonal_num ( int n ) { return ( 5 * n * n - 5 * n + 1 ) ; }
int sum_Centered_decagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_decagonal_num ( i ) ; } return summ ; }
int center_octadecagon_num ( int n ) { return ( 9 * n * n - 9 * n + 1 ) ; }
int sum_center_octadecagon_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += center_octadecagon_num ( i ) ; } return summ ; }
int Centered_Pentadecagonal_num ( int n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; }
int sum_Centered_Pentadecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Pentadecagonal_num ( i ) ; } return summ ; }
bool isMyriagon ( int N ) { float n = ( 9996 + sqrt ( 79984 * N + 99920016 ) ) / 19996 ; return ( n - ( int ) n ) == 0 ; }
bool isOctadecagon ( int N ) { float n = ( 14 + sqrt ( 128 * N + 196 ) ) / 32 ; return ( n - ( int ) n ) == 0 ; }
bool isoctagonal ( int N ) { float n = ( 2 + sqrt ( 12 * N + 4 ) ) / 6 ; return ( n - ( int ) n ) == 0 ; }
bool isheptagonal ( int N ) { float n = ( 3 + sqrt ( 40 * N + 9 ) ) / 10 ; return ( n - ( int ) n ) == 0 ; }
bool isPentadecagon ( int N ) { float n = ( 11 + sqrt ( 104 * N + 121 ) ) / 26 ; return ( n - ( int ) n ) == 0 ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int countSubsequences ( int arr [ ] , int n , int k ) { int countPrime = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime ( arr [ i ] ) ) countPrime ++ ; } if ( countPrime < k ) return 0 ; return nCr ( countPrime , k ) * pow ( 2 , ( n - countPrime ) ) ; }
int longestEvenOddSubarray ( int a [ ] , int n ) { int longest = 1 ; int cnt = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] + a [ i + 1 ] ) % 2 == 1 ) { cnt ++ ; } else { longest = max ( longest , cnt ) ; cnt = 1 ; } } if ( longest == 1 ) return 0 ; return max ( cnt , longest ) ; }
int digSum ( int a ) { int sum = 0 ; while ( a ) { sum += a % 10 ; a = a / 10 ; } return sum ; }
bool isPrime ( int r ) { bool s = true ; for ( int i = 2 ; i * i <= r ; i ++ ) { if ( r % i == 0 ) { s = false ; break ; } } return s ; }
bool istetradecagonal ( int N ) { float n = ( 10 + sqrt ( 96 * N + 100 ) ) / 24 ; return ( n - ( int ) n ) == 0 ; }
bool ishexadecagonal ( int N ) { float n = ( 12 + sqrt ( 112 * N + 144 ) ) / 28 ; return ( n - ( int ) n ) == 0 ; }
bool isnonagonal ( int N ) { float n = ( 5 + sqrt ( 56 * N + 25 ) ) / 14 ; return ( n - ( int ) n ) == 0 ; }
int nCr ( int n , int r ) { if ( r > n ) return 0 ; return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int countSubsequences ( int arr [ ] , int n , int k ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) countOdd ++ ; } int ans = nCr ( n , k ) - nCr ( countOdd , k ) ; return ans ; }
int divParts ( int N ) { if ( N % 2 == 0 ) cout << ( N / 2 ) - 1 << endl ; else cout << N / 2 << endl ; }
int solve ( string s , int n ) { int left = 0 , right = 0 , maxlength = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '(' ) left ++ ; else right ++ ; if ( left == right ) maxlength = max ( maxlength , 2 * right ) ; else if ( right > left ) left = right = 0 ; } left = right = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '(' ) left ++ ; else right ++ ; if ( left == right ) maxlength = max ( maxlength , 2 * left ) ; else if ( left > right ) left = right = 0 ; } return maxlength ; }
int Icosagonal_num ( int n ) { return ( 18 * n * n - 16 * n ) / 2 ; }
int sum_Icosagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { summ += Icosagonal_num ( i ) ; } return summ ; }
int Centered_Pentagonal_num ( int n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; }
int sum_Centered_Pentagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Pentagonal_num ( i ) ; } return summ ; }
int Centered_tridecagonal_num ( int n ) { return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; }
int sum_Centered_tridecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { summ += Centered_tridecagonal_num ( i ) ; } return summ ; }
int getMinSteps ( int n , int jump ) { int quotient = n / jump ; int remainder = n % jump ; int steps = quotient + remainder ; return steps ; }
int Betrothed_Sum ( int n ) { vector < int > Set ; for ( int number_1 = 1 ; number_1 < n ; number_1 ++ ) { int sum_divisor_1 = 1 ; int i = 2 ; while ( i * i <= number_1 ) { if ( number_1 % i == 0 ) { sum_divisor_1 = sum_divisor_1 + i ; if ( i * i != number_1 ) sum_divisor_1 += number_1 / i ; } i ++ ; } if ( sum_divisor_1 > number_1 ) { int number_2 = sum_divisor_1 - 1 ; int sum_divisor_2 = 1 ; int j = 2 ; while ( j * j <= number_2 ) { if ( number_2 % j == 0 ) { sum_divisor_2 += j ; if ( j * j != number_2 ) sum_divisor_2 += number_2 / j ; } j = j + 1 ; } if ( sum_divisor_2 == number_1 + 1 and number_1 <= n && number_2 <= n ) { Set . push_back ( number_1 ) ; Set . push_back ( number_2 ) ; } } } int Summ = 0 ; for ( auto i : Set ) { if ( i <= n ) Summ += i ; } return Summ ; }
void constructArray ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { cout << i << " " ; } }
int prod_of_max_min ( int n ) { int largest = 0 ; int smallest = 10 ; while ( n ) { int r = n % 10 ; largest = max ( r , largest ) ; smallest = min ( r , smallest ) ; n = n / 10 ; } return largest * smallest ; }
int formed_no ( int N , int K ) { if ( K == 1 ) { return N ; } int answer = N ; while ( K -- ) { int a_current = prod_of_max_min ( answer ) ; if ( a_current == 0 ) break ; answer += a_current ; } return answer ; }
bool isCenteredtridecagonal ( int N ) { float n = ( 13 + sqrt ( 104 * N + 65 ) ) / 26 ; return ( n - ( int ) n ) == 0 ; }
bool isCenteredpentagonal ( int N ) { float n = ( 5 + sqrt ( 40 * N - 15 ) ) / 10 ; return ( n - ( int ) n ) == 0 ; }
bool isCentereddecagonal ( int N ) { float n = ( 5 + sqrt ( 20 * N + 5 ) ) / 10 ; return ( n - ( int ) n ) == 0 ; }
bool isdodecagonal ( int N ) { float n = ( 4 + sqrt ( 20 * N + 16 ) ) / 10 ; return ( n - ( int ) n ) == 0 ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i += 6 ) { if ( n % i == 0 || n % ( i + 6 ) == 0 ) { return false ; } } return true ; }
bool SexyPrime ( int n1 , int n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && abs ( n1 - n2 ) == 6 ) ; }
int countSexyPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( SexyPrime ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; }
void computePrime ( int N ) { Prime . resize ( N + 1 , true ) ; Prime [ 0 ] = Prime [ 1 ] = false ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( Prime [ i ] ) { for ( int j = i * i ; j < N ; j += i ) { Prime [ j ] = false ; } } } }
int countSexyPairs ( int arr [ ] , int n ) { int maxE = * max_element ( arr , arr + n ) ; computePrime ( maxE ) ; int count = 0 ; int freq [ maxE + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( Prime [ arr [ i ] ] ) { if ( freq [ arr [ i ] + 6 ] > 0 && Prime [ arr [ i ] + 6 ] ) { count ++ ; } } } return count ; }
void nDigitPerfectSquares ( int n , int b ) { int largest = pow ( ceil ( sqrt ( pow ( b , n ) ) ) - 1 , 2 ) ; cout << largest ; }
void findNum ( int n , int k ) { int q = k / ( n - 1 ) ; int r = k % ( n - 1 ) ; int a ; if ( r != 0 ) a = ( n * q ) + r ; else a = ( n * q ) - 1 ; cout << a ; }
double cubeRoot ( double n ) { double ans = pow ( 3 , ( 1.0 / 3 ) * ( log ( n ) / log ( 3 ) ) ) ; return ans ; }
int floorMax ( int A , int B , int N ) { int x = min ( B - 1 , N ) ; return ( A * x ) / B ; }
int calculateMoves ( int n ) { int count = 0 ; int layers = n / 2 ; for ( int k = 1 ; k < layers + 1 ; k ++ ) { count += 8 * k * k ; } return count ; }
void countWays ( int n ) { if ( n <= 2 ) cout << "-1" ; else { int ans = ( n - 1 ) * ( n - 2 ) / 2 ; cout << ans ; } }
bool isSumSquare ( int N ) { float n = ( 2 + sqrt ( 8 * N - 4 ) ) / 2 ; return ( n - ( int ) n ) == 0 ; }
bool isCenteredheptagonal ( int N ) { float n = ( 7 + sqrt ( 56 * N - 7 ) ) / 14 ; return ( n - ( int ) n ) == 0 ; }
bool isCenterednonadecagonal ( int N ) { float n = ( 19 + sqrt ( 152 * N + 209 ) ) / 38 ; return ( n - ( int ) n ) == 0 ; }
bool isCenteredOctadecagonal ( int N ) { float n = ( 9 + sqrt ( 36 * N + 45 ) ) / 18 ; return ( n - ( int ) n ) == 0 ; }
int countDigit ( long long n ) { return floor ( log10 ( n ) + 1 ) ; }
bool isPower ( int N , int K ) { int res1 = log ( N ) / log ( K ) ; double res2 = log ( N ) / log ( K ) ; return ( res1 == res2 ) ; }
int prevPowerofK ( int n , int k ) { int p = ( int ) ( log ( n ) / log ( k ) ) ; return ( int ) pow ( k , p ) ; }
int nextPowerOfK ( int n , int k ) { return prevPowerofK ( n , k ) * k ; }
int subarray ( int arr [ ] , int n ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { ++ temp ; } else { ans = max ( ans , temp ) ; temp = 1 ; } } ans = max ( ans , temp ) ; return ans ; }
void findMaxMinSubArray ( int arr [ ] , int K , int n ) { int min = n ; int max = 0 ; int left ; int right ; int tmp ; for ( int i = 0 ; i < n ; i ++ ) { tmp = 1 ; left = i ; while ( left - 1 >= 0 && abs ( arr [ left ] - arr [ left - 1 ] ) <= K ) { left -- ; tmp ++ ; } right = i ; while ( right + 1 <= n - 1 && abs ( arr [ right ] - arr [ right + 1 ] ) <= K ) { right ++ ; tmp ++ ; } if ( min > tmp ) min = tmp ; if ( max < tmp ) max = tmp ; } cout << min << ", " << max << endl ; }
int countElement ( int arr [ ] , int n ) { map < int , int > freq ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { int tmpsum = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { tmpsum += arr [ j ] ; if ( freq . find ( tmpsum ) != freq . end ( ) ) { ans += freq [ tmpsum ] ; } } } return ans ; }
void first_digit ( int x , int y ) { int length = log ( x ) / log ( y ) + 1 ; int first_digit = x / pow ( y , length - 1 ) ; cout << first_digit ; }
double kthRoot ( double n , int k ) { return pow ( k , ( 1.0 / k ) * ( log ( n ) / log ( k ) ) ) ; }
void checksum ( int n , int k ) { float first_term = ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 ; if ( first_term - int ( first_term ) == 0 ) { for ( int i = first_term ; i <= first_term + k - 1 ; i ++ ) { cout << i << " " ; } } else cout << "-1" ; }
void distributeN ( int A , int B , int C , int n ) { int max1 = max ( A , B ) ; int max2 = max ( B , C ) ; int maximum = max ( max1 , max2 ) ; int sum = A + B + C ; int p = ( 3 * maximum ) - sum ; int diff = n - p ; if ( diff < 0 diff % 3  ) cout << "No" ; else cout << "Yes" ; }
int minimumSteps ( int a , int b , int c ) { if ( a < 1 b < 1  ) return -1 ; if ( a == 1 && b == 1 ) return c ; if ( a < b ) { a = a + b ; b = a - b ; a = a - b ; } return minimumSteps ( a - b , b , c + 1 ) ; }
int count_pairs ( int x ) { int ans = 1 ; while ( x > 0 ) { if ( x % 2 == 1 ) ans = ans * 3 ; x = x / 2 ; } return ans ; }
bool isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; }
int countSquares ( int n ) { int cnt = 0 ; for ( int i = pow ( 10 , ( n - 1 ) ) ; i < pow ( 10 , n ) ; i ++ ) { if ( i != 0 && isPerfectSquare ( i ) ) cnt ++ ; } return cnt ; }
int countSquares ( int n ) { int r = ceil ( sqrt ( pow ( 10 , n ) ) ) ; int l = ceil ( sqrt ( pow ( 10 , n - 1 ) ) ) ; return r - l ; }
int summation ( int N ) { int co = ( N + 1 ) / 2 ; int ce = ( N ) / 2 ; int se = 2 * ( ( ce * ( ce + 1 ) ) * ( ce * ( ce + 1 ) ) ) ; int so = ( co * co ) * ( 2 * ( ( co * co ) ) - 1 ) ; return so - se ; }
bool isStar ( int N ) { float n = ( 6 + sqrt ( 24 * N + 12 ) ) / 6 ; return ( n - ( int ) n ) == 0 ; }
void sumEvenNumbers ( int N , int K ) { int check = N - 2 * ( K - 1 ) ; if ( check > 0 && check % 2 == 0 ) { for ( int i = 0 ; i < K - 1 ; i ++ ) { cout << "2 " ; } cout << check ; } else { cout << "-1" ; } }
int findMinDivisor ( int arr [ ] , int n , int limit ) { int low = 0 , high = 1e9 ; while ( low < high ) { int mid = ( low + high ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ceil ( ( double ) arr [ i ] / ( double ) mid ) ; } if ( sum <= limit ) high = mid ; else low = mid + 1 ; } return low ; }
int getCount ( int arr [ ] , int n ) { int count = 0 ; for ( int j = 1 ; j < n - 1 ; j ++ ) { int p = 0 , q = 0 ; for ( int i = 0 ; i < j ; i ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) p ++ ; } for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ k ] % arr [ j ] == 0 ) q ++ ; } count += p * q ; } return count ; }
float computeMaxValue ( float arr [ ] , int n ) { float ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { float val = max ( arr [ i ] / arr [ j ] , arr [ j ] / arr [ i ] ) ; ans = max ( ans , val ) ; } } return ans ; }
void kthNonDivisible ( int N , int K ) { int L = 1 ; int H = INT_MAX ; int ans = 0 ; while ( L <= H ) { int mid = ( L + H ) / 2 ; int sol = mid - mid / N ; if ( sol > K ) { H = mid - 1 ; } else if ( sol < K ) { L = mid + 1 ; } else { ans = mid ; H = mid - 1 ; } } cout << ans ; }
int kthNonDivisible ( int N , int K ) { return K + floor ( ( K - 1 ) / ( N - 1 ) ) ; }
bool isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; }
void checkSunnyNumber ( int N ) { if ( isPerfectSquare ( N + 1 ) ) { cout << "Yes\n" ; } else { cout << "No\n" ; } }
void findPairEvenParity ( int arr [ ] , int len ) { int firstMaximum = INT_MIN ; int secondMaximum = INT_MIN ; for ( int i = 0 ; i < len ; i ++ ) { if ( isEvenParity ( arr [ i ] ) ) { if ( arr [ i ] >= firstMaximum ) { secondMaximum = firstMaximum ; firstMaximum = arr [ i ] ; } else if ( arr [ i ] >= secondMaximum ) { secondMaximum = arr [ i ] ; } } } cout << firstMaximum << " " << secondMaximum ; }
bool isHexagonal ( int N ) { float val = 8 * N + 1 ; float x = 1 + sqrt ( val ) ; float n = ( x ) / 4 ; if ( ( n - ( int ) n ) == 0 ) return true ; else return false ; }
void NumbertoCharacter ( int n ) { int rev = 0 , r = 0 ; while ( n > 0 ) { r = n % 10 ; rev = rev * 10 + r ; n = n / 10 ; } while ( rev > 0 ) { r = rev % 10 ; switch ( r ) { case 1 : cout << "one " ; break ; case 2 : cout << "two " ; break ; case 3 : cout << "three " ; break ; case 4 : cout << "four " ; break ; case 5 : cout << "five " ; break ; case 6 : cout << "six " ; break ; case 7 : cout << "seven " ; break ; case 8 : cout << "eight " ; break ; case 9 : cout << "nine " ; break ; case 0 : cout << "zero " ; break ; default : cout << "UnValid " ; break ; } rev = rev / 10 ; } }
int Solve ( int arr [ ] , int n ) { int temp = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; if ( ( temp + 2 ) % 4 != 0 ) count ++ ; } } return count ; }
void nCr ( lli n , lli p , lli f [ ] [ m + 1 ] ) { for ( lli i = 0 ; i <= n ; i ++ ) { for ( lli j = 0 ; j <= m ; j ++ ) { if ( j > i ) f [ i ] [ j ] = 0 ; else if ( j == 0 j == i ) f [ i ] [ j ] = 1 ; else f [ i ] [ j ] = ( f [ i - 1 ] [ j ] + f [ i - 1 ] [ j - 1 ] ) % p ; } } }
bool prodSquare ( int n ) { for ( long i = 2 ; i * i <= n ; i ++ ) for ( long j = 2 ; j <= n ; j ++ ) if ( i * i * j * j == n ) return true ; return false ; }
bool prodSquare ( int n ) { unordered_map < float , float > s ; for ( int i = 2 ; i * i <= n ; ++ i ) { s [ i * i ] = 1 ; if ( s . find ( n / ( i * i ) ) != s . end ( ) ) return true ; } return false ; }
void printPair ( int n ) { cout << 1 << " " << n - 1 ; }
bool isAutoBiographyNum ( int number ) { int count = 0 , position , size , digit ; string NUM ; NUM = to_string ( number ) ; size = NUM . length ( ) ; for ( int i = 0 ; i < size ; i ++ ) { position = NUM [ i ] - '0' ; count = 0 ; for ( int j = 0 ; j < size ; j ++ ) { digit = NUM [ j ] - '0' ; if ( digit == i ) count ++ ; } if ( position != count ) return false ; } return true ; }
int checkArray ( int arr [ ] , int n ) { int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isAutoBiographyNum ( arr [ i ] ) ) current_length ++ ; else current_length = 0 ; max_length = max ( max_length , current_length ) ; } return max_length ; }
int GetSum ( int n ) { vector < int > divisors ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { divisors . push_back ( i ) ; if ( i != n / i ) { divisors . push_back ( n / i ) ; } } } int ans = 1 ; for ( auto i : divisors ) { ans *= ( i + 1 ) ; } ans = ans - 1 ; return ans ; }
vector < int > calculateWays ( int N ) { int x = 0 ; vector < int > v ; for ( int i = 0 ; i < N ; i ++ ) v . push_back ( 0 ) ; for ( int i = 0 ; i <= N / 2 ; i ++ ) { if ( N % 2 == 0 && i == N / 2 ) break ; x = N * ( i + 1 ) - ( i + 1 ) * i ; v [ i ] = x ; v [ N - i - 1 ] = x ; } return v ; }
bool isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; }
int longestPowerfulSubsequence ( int arr [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerful ( arr [ i ] ) ) answer ++ ; } return answer ; }
int maxOR ( int arr [ ] , int n ) { int max_value = * max_element ( arr , arr + n ) ; int number_of_bits = floor ( log2 ( max_value ) ) + 1 ; int complement = ( ( 1 << number_of_bits ) - 1 ) ^ max_value ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != max_value ) { c = max ( c , ( complement & arr [ i ] ) ) ; } } return ( max_value + c ) ; }
void update ( int res [ ] , int L , int R , int K ) { L -= 1 ; R -= 1 ; res [ L ] ^= K ; res [ R + 1 ] ^= K ; }
bool check ( int a [ ] , int n , int k ) { map < int , int > m ; int extra = 0 ; for ( int i = k ; i < n ; i ++ ) m [ a [ i ] ] ++ ; for ( auto x : m ) extra += x . second - 1 ; if ( extra == 0 ) return true ; for ( int i = 1 ; i + k - 1 < n ; i ++ ) { if ( m [ a [ i + k - 1 ] ] > 1 ) extra -- ; m [ a [ i + k - 1 ] ] -- ; m [ a [ i - 1 ] ] ++ ; if ( m [ a [ i - 1 ] ] > 1 ) extra ++ ; if ( extra == 0 ) return true ; } return false ; }
int minlength ( int a [ ] , int n ) { int lo = 0 , hi = n + 1 ; int ans = 0 ; while ( lo < hi ) { int mid = ( lo + hi ) / 2 ; if ( check ( a , n , mid ) ) { ans = mid ; hi = mid ; } else lo = mid + 1 ; } return ans ; }
void SieveOfEratosthenes ( ) { int i , j ; Prime [ 0 ] = Prime [ 1 ] = false ; for ( i = 2 ; i * i <= MAX ; i ++ ) { if ( Prime [ i ] ) { for ( j = 2 * i ; j < MAX ; j += i ) { Prime [ j ] = false ; } } } }
void dfs ( int node , int parent , int h ) { height [ node ] = h ; for ( int to : graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node , h + 1 ) ; } }
void primeHeightNode ( int N ) { SieveOfEratosthenes ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( Prime [ height [ i ] ] ) { cout << i << " " ; } } }
int sumOfDigits ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += n % 10 ; n /= 10 ; } return sum ; }
int smallestNum ( int X , int Y ) { int res = -1 ; for ( int i = X ; i < MAXN ; i ++ ) { int sum_of_digit = sumOfDigits ( i ) ; if ( sum_of_digit % Y == 0 ) { res = i ; break ; } } return res ; }
int calculateBill ( int units ) { if ( units <= 100 ) { return units * 10 ; } else if ( units <= 200 ) { return ( 100 * 10 ) + ( units - 100 ) * 15 ; } else if ( units <= 300 ) { return ( 100 * 10 ) + ( 100 * 15 ) + ( units - 200 ) * 20 ; } else if ( units > 300 ) { return ( 100 * 10 ) + ( 100 * 15 ) + ( 100 * 20 ) + ( units - 300 ) * 25 ; } return 0 ; }
int countValues ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int k = n ; while ( k >= i ) { if ( k % i == 0 ) k /= i ; else k -= i ; } if ( k == 1 ) answer ++ ; } return answer ; }
int countValues ( int N ) { vector < int > div ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { div . push_back ( i ) ; if ( N != i * i ) { div . push_back ( N / i ) ; } } } int answer = 0 ; for ( int i = 1 ; i * i <= N - 1 ; i ++ ) { if ( ( N - 1 ) % i == 0 ) { if ( i * i == N - 1 ) answer ++ ; else answer += 2 ; } } for ( auto d : div ) { int K = N ; while ( K % d == 0 ) K /= d ; if ( ( K - 1 ) % d == 0 ) answer ++ ; } return answer ; }
int reverse ( int a ) { int rev = 0 ; while ( a != 0 ) { int r = a % 10 ; rev = rev * 10 + r ; a = a / 10 ; } return ( rev ) ; }
int prime ( int a ) { int k = 0 ; for ( int i = 2 ; i < a ; i ++ ) { if ( a % i == 0 ) { k = 1 ; break ; } } if ( k == 1 ) { return ( 0 ) ; } else { return ( 1 ) ; } }
int adam ( int a ) { int r1 = reverse ( a ) ; int s1 = a * a ; int s2 = r1 * r1 ; int r2 = reverse ( s2 ) ; if ( s1 == r2 ) { return ( 1 ) ; } else { return ( 0 ) ; } }
void sieve ( ) { for ( int i = 1 ; i <= MAX ; ++ i ) { for ( int j = i ; j <= MAX ; j += i ) divisor [ j ] . push_back ( i ) ; } }
int countPrimeFactors ( int n ) { if ( n == 1 ) return 0 ; int cnt = 0 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { cnt ++ ; n = n / i ; } } if ( n > 2 ) cnt ++ ; return cnt ; }
int isComposite ( int n ) { if ( n <= 1 ) return 0 ; if ( n <= 3 ) return 0 ; if ( n % 2 == 0 n % 3 == 0 ) return n ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return n ; return 0 ; }
void preCompute ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isComposite ( i ) ; } }
int countPalindromic ( int n ) { int count ; if ( n % 2 == 1 ) { count = pow ( 9 , ( n - 1 ) / 2 ) ; } else { count = pow ( 9 , ( n - 2 ) / 2 ) ; } return count ; }
int countSubArrayWithOddProduct ( int * A , int N ) { int count = 0 ; int last = -1 ; int K = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) { K = ( i - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; last = i ; } } K = ( N - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; return count ; }
double CgpaCalc ( double marks [ ] , int n ) { double grade [ n ] ; double cgpa , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { grade [ i ] = ( marks [ i ] / 10 ) ; } for ( int i = 0 ; i < n ; i ++ ) { sum += grade [ i ] ; } cgpa = sum / n ; return cgpa ; }
void printMaxPair ( int arr [ ] , int n ) { int largest = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { int number = stoi ( getNumber ( arr [ i ] , arr [ j ] ) ) ; largest = max ( largest , number ) ; } cout << largest ; }
void printKNumbers ( int N , int K ) { for ( int i = 0 ; i < K - 1 ; i ++ ) cout << 1 << " " ; cout << ( N - K + 1 ) ; }
int minNum ( int n , int k ) { int x = ( int ) ( log ( n ) / log ( k ) ) + 1 ; int mn = pow ( k , x ) - n ; return mn ; }
int previousPerfectCube ( int N ) { int prevN = floor ( cbrt ( N ) ) ; if ( prevN * prevN * prevN == N ) prevN -= 1 ; return prevN * prevN * prevN ; }
int findCount ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] % 2 == 0 ) && ( arr [ j ] % 2 == 1 ) ) { res ++ ; } return res ; }
int findCount ( int arr [ ] , int n ) { int count = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count ++ ; else ans = ans + count ; } return ans ; }
int sumDig ( int n ) { int s = 0 ; while ( n != 0 ) { s = s + ( n % 10 ) ; n = n / 10 ; } return s ; }
bool Pec ( int n ) { int dup = n ; int dig = sumDig ( n ) ; if ( dig * 3 == dup ) return true ; else return false ; }
long long int power ( long long int a , long long int b ) { if ( b == 0 ) return 1 ; long long int temp = power ( a , b / 2 ) ; temp = ( temp * temp ) % MOD ; if ( b % 2 != 0 ) { temp = ( temp * a ) % MOD ; } return temp ; }
int joinNumbers ( int numA , int numB ) { int revB = 0 ; while ( numB > 0 ) { revB = revB * 10 + ( numB % 10 ) ; numB = numB / 10 ; } while ( revB > 0 ) { numA = numA * 10 + ( revB % 10 ) ; revB = revB / 10 ; } return numA ; }
int reverse ( int n ) { int r = 0 ; while ( n != 0 ) { r = r * 10 ; r = r + n % 10 ; n = n / 10 ; } return ( r ) ; }
void operation ( int n ) { int i = 1 , a , count = 0 , r ; while ( count < n ) { a = digit_sum ( i ) ; r = reverse ( i ) ; if ( i % a == 0 && r % a == 0 ) { cout << i << " " ; count ++ ; i ++ ; } else i ++ ; } }
int calcCount ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( k % arr [ i ] == 0 ) count ++ ; } return count ; }
bool isPerfect ( long long int n ) { long long int sum = 1 ; for ( long long int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
int contiguousPerfectNumber ( int arr [ ] , int n ) { int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPerfect ( arr [ i ] ) ) current_length ++ ; else current_length = 0 ; max_length = max ( max_length , current_length ) ; } return max_length ; }
bool isPerfect ( long long int n ) { long long int sum = 1 ; for ( long long int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
bool isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; }
void dfs ( int node , int parent ) { if ( isPowerful ( weight [ node ] ) ) ans += 1 ; for ( int to : graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; } }
bool isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; }
int contiguousPowerfulNumber ( int arr [ ] , int n ) { int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerful ( arr [ i ] ) ) current_length ++ ; else current_length = 0 ; max_length = max ( max_length , current_length ) ; } return max_length ; }
int maxSum ( int arr [ ] , int K , int start , int end , int max_sum ) { if ( K == 0 ) return max_sum ; int max_sum_start = max_sum + arr [ start ] ; int max_sum_end = max_sum + arr [ end ] ; int ans = max ( maxSum ( arr , K - 1 , start + 1 , end , max_sum_start ) , maxSum ( arr , K - 1 , start , end - 1 , max_sum_end ) ) ; return ans ; }
void maximizeSum ( int arr [ ] , int K , int n ) { int max_sum = 0 ; int start = 0 ; int end = n - 1 ; cout << maxSum ( arr , K , start , end , max_sum ) ; }
int maxPointCount ( int arr [ ] , int K , int size ) { int curr_points = 0 ; int max_points = 0 ; for ( int i = 0 ; i < K ; i ++ ) curr_points += arr [ i ] ; max_points = curr_points ; int j = size - 1 ; for ( int i = K - 1 ; i >= 0 ; i -- ) { curr_points = curr_points + arr [ j ] - arr [ i ] ; max_points = max ( curr_points , max_points ) ; j -- ; } return max_points ; }
int count ( int N , int B ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( B - 1 ) * pow ( B , i - 1 ) ; } return sum ; }
int GetMinCost ( int N ) { priority_queue < int , vector < int > , greater < int > > pq ; for ( int i = 1 ; i <= N ; i ++ ) { pq . push ( i ) ; } int cost = 0 ; while ( pq . size ( ) > 1 ) { int mini = pq . top ( ) ; pq . pop ( ) ; int secondmini = pq . top ( ) ; pq . pop ( ) ; int current = mini * secondmini ; cost += current ; pq . push ( current ) ; } return cost ; }
int CountWays ( int N , int M ) { int count = 1 ; count = pow ( 3 , M + N ) ; count *= pow ( 2 , M * N ) ; return count ; }
int minCost ( int arr [ ] , int n , int circumference ) { sort ( arr , arr + n ) ; int arr2 [ 2 * n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr2 [ i ] = arr [ i ] ; arr2 [ i + n ] = arr [ i ] + circumference ; } int res = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) res = min ( res , arr2 [ i + ( n - 1 ) ] - arr2 [ i ] ) ; return res ; }
int CountWays ( int n ) { int ans = ( n - 1 ) / 2 ; return ans ; }
int findUniqueElements ( int arr [ ] , int N , int K ) { unordered_set < int > s ( arr , arr + N ) ; int arr_sum = accumulate ( arr , arr + N , 0 ) ; int set_sum = accumulate ( s . begin ( ) , s . end ( ) , 0 ) ; cout << ( K * set_sum - arr_sum ) / ( K - 1 ) ; }
int findunique ( vector < int > & a , int k ) { int res = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { int p = 0 ; for ( int j = 0 ; j < a . size ( ) ; j ++ ) { p += ( abs ( a [ j ] ) & ( 1 << i ) ) != 0 ? 1 : 0 ; } p %= k ; res += pow ( 2 , i ) * p ; } int c = 0 ; for ( auto x : a ) if ( x == res ) { c = 1 ; break ; } return c == 1 ? res : - res ; }
int stepRequired ( int N ) { int cnt = 0 ; while ( N ) { N = N & ( N - 1 ) ; cnt ++ ; } return cnt ; }
bool isPerfectSquare ( int x ) { int s = sqrt ( x ) ; return ( s * s == x ) ; }
bool isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
void findEquation ( int a , int b , int c ) { int X = ( a + b + c ) ; int Y = ( a * b ) + ( b * c ) + ( c * a ) ; int Z = a * b * c ; cout << "x^3 - " << X << "x^2 + " << Y << "x - " << Z << " = 0" ; }
float dydx ( float x , float y ) { return ( x - y ) / 2 ; }
int numPrimeArrangements ( int n ) { vector < bool > prime ( n + 1 , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( prime [ i ] ) for ( int factor = 2 ; factor * i <= n ; factor ++ ) prime [ factor * i ] = false ; } int primeIndices = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( prime [ i ] ) primeIndices ++ ; int mod = 1e9 + 7 , res = 1 ; for ( int i = 1 ; i <= primeIndices ; i ++ ) res = ( 1LL * res * i ) % mod ; for ( int i = 1 ; i <= ( n - primeIndices ) ; i ++ ) res = ( 1LL * res * i ) % mod ; return res ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
double count_heads ( int n , int r ) { double output ; output = fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; output = output / ( pow ( 2 , n ) ) ; return output ; }
void PrintReverseOrder ( int N ) { if ( N <= 0 ) { return ; } else { cout << N << " " ; PrintReverseOrder ( N - 1 ) ; } }
int findAns ( int a , int b , int n ) { int lcm = ( a * b ) / __gcd ( a , b ) ; int multiples = ( n / lcm ) + 1 ; int answer = max ( a , b ) * multiples ; int lastvalue = lcm * ( n / lcm ) + max ( a , b ) ; if ( lastvalue > n ) answer = answer - ( lastvalue - n - 1 ) ; return answer ; }
int modInverse ( int n , int p ) { return power ( n , p - 2 , p ) ; }
int nCrModPFermat ( int n , int r , int p ) { if ( r == 0 ) return 1 ; if ( n < r ) return 0 ; int fac [ n + 1 ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p ; }
int SumOfXor ( int a [ ] , int n ) { int mod = 10037 ; int answer = 0 ; for ( int k = 0 ; k < 32 ; k ++ ) { int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] & ( 1 << k ) ) x ++ ; else y ++ ; } answer += ( ( 1 << k ) % mod * ( nCrModPFermat ( x , 3 , mod ) + x * nCrModPFermat ( y , 2 , mod ) ) % mod ) % mod ; } return answer ; }
void movesRequired ( int a , int b ) { int total_moves = a % b ; cout << total_moves << "\n" ; }
float Volume_of_cone ( float R ) { float V = ( 1 / 3.0 ) * ( 3.14 ) * ( 2 * ( R * R ) ) * ( 4 * R ) ; return V ; }
int maximumComponentSize ( int a [ ] , int n ) { vector < int > adj [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( __gcd ( a [ i ] , a [ j ] ) > 1 ) adj [ i ] . push_back ( j ) ; adj [ j ] . push_back ( i ) ; } } int answer = 0 ; int vis [ n ] ; for ( int k = 0 ; k < n ; k ++ ) { vis [ k ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ! vis [ i ] ) { answer = max ( answer , dfs ( i , adj , vis ) ) ; } } return answer ; }
void sieve ( ) { for ( int i = 2 ; i < 100005 ; i ++ ) { if ( spf [ i ] == 0 ) { spf [ i ] = i ; for ( int j = 2 * i ; j < 100005 ; j += i ) { if ( spf [ j ] == 0 ) spf [ j ] = i ; } } } }
void factorize ( int n , set < int > & s ) { while ( n > 1 ) { int z = spf [ n ] ; s . insert ( z ) ; while ( n % z == 0 ) n /= z ; } }
int root ( int i ) { if ( par [ i ] == i ) return i ; else return par [ i ] = root ( par [ i ] ) ; }
void merge ( int a , int b ) { int p = root ( a ) ; int q = root ( b ) ; if ( p == q ) return ; if ( sizeContainer [ p ] > sizeContainer [ q ] ) swap ( p , q ) ; par [ p ] = q ; sizeContainer [ q ] += sizeContainer [ p ] ; }
int maximumComponentsizeContainer ( int a [ ] , int n ) { for ( int i = 0 ; i < 100005 ; i ++ ) { par [ i ] = i ; sizeContainer [ i ] = 1 ; } sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) { set < int > s ; factorize ( a [ i ] , s ) ; for ( auto it : s ) { if ( id [ it ] == 0 ) id [ it ] = i + 1 ; else merge ( i + 1 , id [ it ] ) ; } } int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) answer = max ( answer , sizeContainer [ i ] ) ; return answer ; }
bool check ( int X , int K ) { int prime , temp , sqr , i ; prime = 0 ; temp = X ; sqr = sqrt ( X ) ; for ( i = 2 ; i <= sqr ; i ++ ) { while ( temp % i == 0 ) { temp = temp / i ; prime ++ ; } } if ( temp > 2 ) prime ++ ; if ( X == 1 ) return false ; if ( prime == 1 && K == 1 ) return true ; else if ( prime >= K ) return true ; else return false ; }
void precompute ( ) { phi [ 1 ] = 0 ; for ( int i = 2 ; i < N ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p < N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i < N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int maxAlternatingSum ( int arr [ ] , int n ) { int max_sum = 0 ; int i = 0 ; while ( i < n ) { int current_max = arr [ i ] ; int k = i ; while ( k < n && ( ( arr [ i ] > 0 && arr [ k ] > 0 ) || ( arr [ i ] < 0 && arr [ k ] < 0 ) ) ) { current_max = max ( current_max , arr [ k ] ) ; k += 1 ; } max_sum += current_max ; i = k ; } return max_sum ; }
int subarrayLength ( int A [ ] , int R [ ] [ 2 ] , int N , int M ) { for ( int i = 0 ; i < M ; ++ i ) { int l = R [ i ] [ 0 ] , r = R [ i ] [ 1 ] + 1 ; l -- ; r -- ; A [ l ] ++ ; if ( r < N ) A [ r ] -- ; } for ( int i = 1 ; i < N ; ++ i ) { A [ i ] += A [ i - 1 ] ; } int count = 0 ; unordered_set < int > s ; for ( int i = 0 ; i < N ; ++ i ) { if ( s . find ( A [ i ] ) == s . end ( ) ) count ++ ; s . insert ( A [ i ] ) ; } vector < int > repeat ( count + 1 , 0 ) ; int ans = N ; int counter = 0 , left = 0 , right = 0 ; while ( right < N ) { int cur_element = A [ right ] ; repeat [ cur_element ] += 1 ; if ( repeat [ cur_element ] == 1 ) ++ counter ; while ( counter == count ) { ans = min ( ans , right - left + 1 ) ; cur_element = A [ left ] ; repeat [ cur_element ] -= 1 ; ++ left ; if ( repeat [ cur_element ] == 0 ) -- counter ; } ++ right ; } return ans ; }
void ModifiedSieveOfEratosthenes ( int N , bool Expo_Prime [ ] ) { bool primes [ N ] ; memset ( primes , true , sizeof ( primes ) ) ; for ( int i = 2 ; i < N ; i ++ ) { if ( primes [ i ] ) { int no = i ; while ( no <= N ) { Expo_Prime [ no ] = true ; no *= i ; } for ( int j = i * i ; j < N ; j += i ) primes [ j ] = false ; } } }
void FindExpoPrime ( int arr [ ] , int n ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) max = arr [ i ] ; } bool Expo_Prime [ max + 1 ] ; memset ( Expo_Prime , false , sizeof ( Expo_Prime ) ) ; ModifiedSieveOfEratosthenes ( max + 1 , Expo_Prime ) ; Display ( arr , Expo_Prime , n ) ; }
double nthRoot ( ll A , ll N ) { double xPre = 7 ; double eps = 1e-3 ; double delX = INT_MAX ; double xK ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + ( double ) A / pow ( xPre , N - 1 ) ) / ( double ) N ; delX = abs ( xK - xPre ) ; xPre = xK ; } return xK ; }
bool check ( ll no , int k ) { double kth_root = nthRoot ( no , k ) ; ll num = kth_root ; if ( abs ( num - kth_root ) < 1e-4 ) return true ; return false ; }
void printExpo ( ll arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( check ( arr [ i ] , k ) ) cout << arr [ i ] << " " ; } }
void SieveOfEratosthenes ( ) { bool check [ N + 1 ] ; memset ( check , true , sizeof ( check ) ) ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( check [ p ] == true ) { prime . push_back ( p ) ; for ( int i = p * p ; i <= N ; i += p ) check [ i ] = false ; } } }
bool isPathCo_Prime ( vector < int > & path ) { int max = 0 ; for ( auto x : path ) { if ( max < x ) max = x ; } for ( int i = 0 ; i * prime [ i ] <= max / 2 ; i ++ ) { int ct = 0 ; for ( auto x : path ) { if ( x % prime [ i ] == 0 ) ct ++ ; } if ( ct > 1 ) { return false ; } } return true ; }
int CntcontSubs ( int a [ ] , int n ) { int c = 0 , d = 0 , i , sum = 1 , j ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 != 0 a [ i ] % 4 == 0 ) d ++ ; sum = a [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { sum = sum * a [ j ] ; if ( sum % 2 != 0 sum % 4 == 0 ) c ++ ; } sum = 1 ; } return c + d ; }
int CntcontSubs ( int a [ ] , int n ) { int prod = 1 ; vector < pair < int , int > > vect ; vect . push_back ( make_pair ( 0 , 2 ) ) ; vector < int > two , zero ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = a [ i ] % 4 ; if ( a [ i ] < 0 ) a [ i ] = a [ i ] + 4 ; if ( a [ i ] == 2 ) two . push_back ( i + 1 ) ; if ( a [ i ] == 0 ) zero . push_back ( i + 1 ) ; if ( a [ i ] == 0 a [ i ] == 2 ) vect . push_back ( make_pair ( i + 1 , a [ i ] ) ) ; } vect . push_back ( make_pair ( n + 1 , 2 ) ) ; int total = ( n * ( n + 1 ) ) / 2 ; if ( two . empty ( ) ) return total ; else { int sum = 0 ; int pos1 = -1 , pos2 = -1 , pos3 = -1 ; int sz = vect . size ( ) ; for ( int i = 1 ; i + 1 < sz ; i ++ ) { if ( vect [ i ] . second == 2 ) { sum += ( vect [ i ] . first - vect [ i - 1 ] . first ) * ( vect [ i + 1 ] . first - vect [ i ] . first ) - 1 ; } } return total - sum - two . size ( ) ; } }
int countSubarray ( int n ) { return ( ( n ) * ( n + 1 ) ) / 2 ; }
int countSubsequence ( int n ) { return pow ( 2 , n ) ; }
float y ( float x ) { return ( 1 / ( 1 + x ) ) ; }
float BooleRule ( float a , float b ) { int n = 4 ; int h ; h = ( ( b - a ) / n ) ; float sum = 0 ; float bl = ( ( 7 * y ( a ) + 32 * y ( a + h ) + 12 * y ( a + 2 * h ) + 32 * y ( a + 3 * h ) + 7 * y ( a + 4 * h ) ) * 2 * h / 45 ) ; sum = sum + bl ; return sum ; }
int countSubsets ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int bitwiseAND = -1 ; int bitwiseOR = 0 ; int bitwiseXOR = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( i & ( 1 << j ) ) { if ( bitwiseAND == -1 ) bitwiseAND = a [ j ] ; else bitwiseAND &= a [ j ] ; bitwiseOR |= a [ j ] ; bitwiseXOR ^= a [ j ] ; } } if ( bitwiseAND == bitwiseOR && bitwiseOR == bitwiseXOR ) answer = ( answer + 1 ) % mod ; } return answer ; }
int countSubsets ( int a [ ] , int n ) { int answer = 0 ; int powerOfTwo [ 100005 ] ; powerOfTwo [ 0 ] = 1 ; for ( int i = 1 ; i < 100005 ; i ++ ) powerOfTwo [ i ] = ( powerOfTwo [ i - 1 ] * 2 ) % mod ; unordered_map < int , int > frequency ; for ( int i = 0 ; i < n ; i ++ ) frequency [ a [ i ] ] ++ ; for ( auto el : frequency ) { if ( el . first != 0 ) answer = ( answer % mod + powerOfTwo [ el . second - 1 ] ) % mod ; else answer = ( answer % mod + powerOfTwo [ el . second ] - 1 + mod ) % mod ; } return answer ; }
int count ( int arr [ ] , int N , int K ) { int count = 0 , ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) { count = count + 1 ; } else { ans += ( count * ( count + 1 ) ) / 2 ; count = 0 ; } } ans = ans + ( count * ( count + 1 ) ) / 2 ; return ans ; }
void precomputation ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isPerfect ( i ) ; } }
void convertToTernary ( int N ) { if ( N == 0 ) return ; int x = N % 3 ; N /= 3 ; if ( x < 0 ) N += 1 ; convertToTernary ( N ) ; if ( x < 0 ) cout << x + ( 3 * -1 ) ; else cout << x ; }
bool isPerfectSquare ( int N ) { double sr = sqrt ( N ) ; return ( sr - floor ( sr ) ) == 0 ; }
int EulerTotientFunction ( int limit ) { int copy = limit ; vector < int > primes ; for ( int i = 2 ; i * i <= limit ; i ++ ) { if ( limit % i == 0 ) { while ( limit % i == 0 ) { limit /= i ; } primes . push_back ( i ) ; } } if ( limit >= 2 ) { primes . push_back ( limit ) ; } int ans = copy ; for ( auto it : primes ) { ans = ( ans / it ) * ( it - 1 ) ; } return ans ; }
long long product ( vector < vector < int > > & mat , int n ) { long long d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += mat [ i ] [ i ] ; d2 += mat [ i ] [ n - i - 1 ] ; } return 1LL * d1 * d2 ; }
float getPercentile ( int rank , int students ) { float result = float ( students - rank ) / students * 100 ; return result ; }
int fib ( int n ) { double phi = ( 1 + sqrt ( 5 ) ) / 2 ; return round ( pow ( phi , n ) / sqrt ( 5 ) ) ; }
int calculateSum ( int l , int r ) { int sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; }
int sumFibonacci ( int k ) { int l = ( k * ( k - 1 ) ) / 2 ; int r = l + k ; int sum = calculateSum ( l , r - 1 ) ; return sum ; }
int NthSmallest ( int K ) { queue < int > Q ; int x ; for ( int i = 1 ; i < 10 ; i ++ ) Q . push ( i ) ; for ( int i = 1 ; i <= K ; i ++ ) { x = Q . front ( ) ; Q . pop ( ) ; if ( x % 10 != 0 ) { Q . push ( x * 10 + x % 10 - 1 ) ; } Q . push ( x * 10 + x % 10 ) ; if ( x % 10 != 9 ) { Q . push ( x * 10 + x % 10 + 1 ) ; } } return x ; }
void sumOfPrevK ( int N , int K ) { int arr [ N ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { int j = i - 1 , count = 0 , sum = 0 ; while ( j >= 0 && count < K ) { sum += arr [ j ] ; j -- ; count ++ ; } arr [ i ] = sum ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << " " ; } }
int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; }
int findSum ( int * arr , int n , int left , int right ) { int k = right - left ; int d = arr [ 1 ] - arr [ 0 ] ; int ans = arr [ left - 1 ] * ( k + 1 ) ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; return ans ; }
int get ( int x , int y , int z ) { if ( x > z ) return -1 ; int val = z - x ; int div = ( z - x ) / y ; int ans = div * y + x ; return ans ; }
int subarrayPossible ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum <= 0 ) return 1 ; } sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { sum += arr [ i ] ; if ( sum <= 0 ) return 1 ; } return 0 ; }
int probability ( int N ) { int a = 2 ; int b = 3 ; if ( N == 1 ) { return a ; } else if ( N == 2 ) { return b ; } else { for ( int i = 3 ; i <= N ; i ++ ) { int c = a + b ; a = b ; b = c ; } return b ; } }
float y ( float x ) { float num = 1 ; float denom = 1.0 + x * x ; return num / denom ; }
float WeedleRule ( float a , float b ) { double h = ( b - a ) / 6 ; float sum = 0 ; sum = sum + ( ( ( 3 * h ) / 10 ) * ( y ( a ) + y ( a + 2 * h ) + 5 * y ( a + h ) + 6 * y ( a + 3 * h ) + y ( a + 4 * h ) + 5 * y ( a + 5 * h ) + y ( a + 6 * h ) ) ) ; return sum ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int findSmallest ( int N ) { if ( N == 0 ) return 2 ; if ( N == 1 ) return 1 ; int prime = N , counter = 0 ; bool found = false ; while ( ! found ) { if ( isPrime ( prime ) ) found = true ; else { prime ++ ; counter ++ ; } } return counter ; }
double maxSubArraySum ( double a [ ] , int size ) { double max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int findRemainder ( int n ) { int x = n & 3 ; return x ; }
int reverse ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }
int countReverse ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( reverse ( arr [ i ] ) == arr [ j ] ) { res ++ ; } return res ; }
int reverse ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }
int countReverse ( int arr [ ] , int n ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; ++ i ) ++ freq [ arr [ i ] ] ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { -- freq [ arr [ i ] ] ; res += freq [ reverse ( arr [ i ] ) ] ; } return res ; }
int rangeSum ( int l , int r ) { int a = 1 , b = 9 , res = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int L = max ( l , a ) ; int R = min ( r , b ) ; if ( L <= R ) { int sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += pow ( i , i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
int TrialDivision ( int N ) { int i = 2 ; int k = ceil ( sqrt ( N ) ) ; while ( i <= k ) { if ( N % i == 0 ) return 0 ; i += 1 ; } return 1 ; }
void isPossible ( int A [ ] , int n , int k ) { int countOfTwo = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] % 2 == 0 ) { countOfTwo ++ ; } } if ( k == 0 && countOfTwo == n ) cout << "NO\n" ; else if ( countOfTwo >= k ) { cout << "Yes\n" ; } else cout << "No\n" ; }
int countWays ( int A , int B , int C ) { int minAddA = max ( 0 , ( C + B - A + 2 ) / 2 ) ; int count_ways = max ( C - minAddA + 1 , 0 ) ; return count_ways ; }
void createHash ( set < int > & hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . insert ( prev ) ; hash . insert ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . insert ( temp ) ; prev = curr ; curr = temp ; } }
void printSeries ( int N ) { int ith_term = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ith_term = i % 2 == 0 ? 2 * i * i + 1 : 2 * i * i - 1 ; cout << ith_term << ", " ; } }
void sieve ( int a , int b ) { prime [ 1 ] = 1 ; for ( int i = 2 ; i * i < size ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * 2 ; j < size ; j += i ) prime [ j ] = 1 ; } } for ( int p = 1 ; p < size ; p ++ ) { for ( int q = 1 ; q < size ; q ++ ) { if ( prime [ p ] == 0 && prime [ q ] == 0 && a * p + b * q < size ) { freq [ a * p + b * q ] ++ ; } } } }
void SieveOfEratosthenes ( ) { bool check [ N + 1 ] ; memset ( check , true , sizeof ( check ) ) ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( check [ p ] == true ) { prime . push_back ( p ) ; for ( int i = p * p ; i <= N ; i += p ) check [ i ] = false ; } } }
void printSumSeries ( int N ) { float sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += 1.0 / ( 2 * i - 1 ) ; } cout << sum << endl ; }
void printSeriesSum ( int N ) { double sum = 0 ; int a = 1 ; int cnt = 0 ; bool flag = true ; sum += a ; while ( cnt < N ) { int nextElement ; if ( flag ) { nextElement = a * 2 ; sum += nextElement ; flag = ! flag ; } else { nextElement = a * 3 / 2 ; sum += nextElement ; flag = ! flag ; } a = nextElement ; cnt ++ ; } cout << sum << endl ; }
void MinimumSwapOperations ( string s ) { bool zero_exist = false ; bool multiple_of_2 = false ; int sum = 0 ; int index_of_zero ; bool more_zero = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int val = s [ i ] - '0' ; if ( zero_exist == true ) more_zero = true ; if ( val == 0 ) { zero_exist = true ; index_of_zero = i ; } sum += val ; } if ( zero_exist == false sum % 3 != 0 ) { cout << "-1" << "\n" ; return ; } for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int val = s [ i ] - '0' ; if ( val % 2 == 0 && i != index_of_zero ) multiple_of_2 = true ; } if ( multiple_of_2 == false ) { cout << "-1" << "\n" ; return ; } int last_val = s [ s . length ( ) - 1 ] - '0' ; int second_last_val = s [ s . length ( ) - 2 ] - '0' ; if ( last_val == 0 && second_last_val % 2 == 0 ) cout << 0 << "\n" ; else if ( ( last_val == 0 && second_last_val % 2 != 0 ) || ( last_val % 2 == 0 && second_last_val == 0 ) ) cout << 1 << "\n" ; else if ( more_zero == true && ( last_val == 0 && second_last_val % 2 != 0 ) ) cout << 1 << "\n" ; else cout << 2 << "\n" ; }
void sieve ( int n ) { for ( int i = 2 ; i <= n ; ++ i ) { if ( min_prime [ i ] > 0 ) { continue ; } min_prime [ i ] = i ; max_prime [ i ] = i ; int j = i + i ; while ( j <= n ) { if ( min_prime [ j ] == 0 ) { min_prime [ j ] = i ; } max_prime [ j ] = i ; j += i ; } } }
int findCost ( int A , int B , int C , int X ) { sieve ( MAX ) ; int N , M ; if ( X == 1 ) { return -1 ; } int min_cost = C + X ; int cost_for_prime = A ; N = max_prime [ X ] ; if ( N != X ) { M = X / N ; cost_for_prime += M ; min_cost = min ( min_cost , cost_for_prime ) ; } M = min_prime [ X ] ; N = X / M ; if ( N != min_prime [ N ] ) { int cost_for_comp = B + M ; min_cost = min ( min_cost , cost_for_comp ) ; } return min_cost ; }
long long int minOperations ( long long int A , long long int B ) { if ( A > B ) swap ( A , B ) ; B = B / __gcd ( A , B ) ; return B - 1 ; }
void quadrant ( string s ) { int l = s . length ( ) ; int i ; if ( s . find ( '+' ) < l ) { i = s . find ( '+' ) ; } else { i = s . find ( '-' ) ; } string real = s . substr ( 0 , i ) ; string imaginary = s . substr ( i + 1 , l - 1 ) ; int x = stoi ( real ) ; int y = stoi ( imaginary ) ; if ( x > 0 and y > 0 ) cout << "Quadrant 1" ; else if ( x < 0 and y > 0 ) cout << "Quadrant 2" ; else if ( x < 0 and y < 0 ) cout << "Quadrant 3" ; else if ( x > 0 and y < 0 ) cout << "Quadrant 4" ; else if ( x == 0 and y > 0 ) cout << "Lies on positive" << " Imaginary axis" ; else if ( x == 0 and y < 0 ) cout << "Lies on negative" << " Imaginary axis" ; else if ( y == 0 and x < 0 ) cout << "Lies on negative" << " X-axis" ; else if ( y == 0 and x > 0 ) cout << "Lies on positive" << " X-axis" ; else cout << "Lies on the Origin" ; }
int highestPower ( int n , int k ) { int i = 0 ; int a = pow ( n , i ) ; while ( a <= k ) { i += 1 ; a = pow ( n , i ) ; } return i - 1 ; }
int PowerArray ( int n , int k ) { while ( k ) { int t = highestPower ( n , k ) ; if ( b [ t ] ) { cout << -1 ; return 0 ; } else b [ t ] = 1 ; k -= pow ( n , t ) ; } for ( int i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] ) { cout << i << ", " ; } } }
int PowerArray ( int n , int k ) { int count = 0 ; while ( k ) { if ( k % n == 0 ) { k /= n ; count ++ ; } else if ( k % n == 1 ) { k -= 1 ; b [ count ] ++ ; if ( b [ count ] > 1 ) { cout << -1 ; return 0 ; } } else { cout << -1 ; return 0 ; } } for ( int i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] ) { cout << i << ", " ; } } }
int countdigits ( int n , int k ) { if ( n == 0 ) return 0 ; int digit = n % 10 ; if ( digit == k ) return 1 + countdigits ( n / 10 , k ) ; return countdigits ( n / 10 , k ) ; }
int largestElement ( struct Node * head_ref ) { int max = INT_MIN ; Node * head = head_ref ; while ( head != NULL ) { if ( max < head -> data ) max = head -> data ; head = head -> next ; } return max ; }
void createHash ( set < int > & hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . insert ( prev ) ; hash . insert ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . insert ( temp ) ; prev = curr ; curr = temp ; } }
void printModulus ( int X , int Y ) { int n = max ( X , Y ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( X % i == Y % i ) cout << i << " " ; } }
void printModulus ( int X , int Y ) { int d = abs ( X - Y ) ; int i = 1 ; while ( i * i <= d ) { if ( d % i == 0 ) { cout << i << " " ; if ( d / i != i ) cout << d / i << " " ; } i ++ ; } }
bool difSquare ( int n ) { if ( n % 4 != 2 ) { return true ; } return false ; }
int countFibonacciDivisors ( int n ) { set < int > hash ; createHash ( hash , n ) ; int cnt = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( ( n / i == i ) && ( hash . find ( n / i ) != hash . end ( ) ) ) cnt ++ ; else { if ( hash . find ( n / i ) != hash . end ( ) ) cnt ++ ; if ( hash . find ( n / ( n / i ) ) != hash . end ( ) ) cnt ++ ; } } } return cnt ; }
int findCount ( Node * root , int K ) { int res = 0 ; rec ( root , res , K ) ; return res ; }
void makearrayequal ( int arr [ ] , int n ) { int x = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x += arr [ i ] & 1 ; } cout << min ( x , n - x ) << endl ; }
void SieveOfEratosthenes ( vector < bool > & composite ) { for ( int i = 0 ; i < N ; i ++ ) composite [ i ] = false ; for ( int p = 2 ; p * p < N ; p ++ ) { if ( ! composite [ p ] ) { for ( int i = p * 2 ; i < N ; i += p ) composite [ i ] = true ; } } }
int sumOfElements ( int arr [ ] , int n ) { vector < bool > composite ( N ) ; SieveOfEratosthenes ( composite ) ; unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; int sum = 0 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( composite [ it -> second ] ) { sum += ( it -> first ) ; } } return sum ; }
int val ( char c ) { if ( c >= '0' && c <= '9' ) return ( int ) c - '0' ; else return ( int ) c - 'A' + 10 ; }
int toDeci ( string str , int base ) { int len = str . length ( ) ; int power = 1 ; int num = 0 ; int i ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str [ i ] ) >= base ) { cout << "Invalid Number" ; return -1 ; } num += val ( str [ i ] ) * power ; power = power * base ; } return num ; }
bool isEven ( string num , int N ) { int deci = toDeci ( num , N ) ; return ( deci % 2 == 0 ) ; }
int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d == 2 d == 3 d == 5 d == 7 ) count ++ ; } return count ; }
void remove ( int arr [ ] , int n ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { m [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( m [ arr [ i ] ] & 1 ) ) continue ; cout << arr [ i ] << ", " ; } }
void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
int longestPrimeSubsequence ( int arr [ ] , int n ) { bool prime [ N + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , N ) ; int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { answer ++ ; } } return answer ; }
void checkPalindrome ( int num ) { string str = to_string ( num ) ; int l = 0 , r = str . length ( ) - 1 ; while ( l < r ) { if ( str [ l ] != str [ r ] ) { cout << "No" ; return ; } l ++ ; r -- ; } cout << "Yes" ; return ; }
float dydx ( float x , float y ) { return ( x + y - 2 ) ; }
float rungeKutta ( float x0 , float y0 , float x , float h ) { int n = ( int ) ( ( x - x0 ) / h ) ; float k1 , k2 ; float y = y0 ; for ( int i = 1 ; i <= n ; i ++ ) { k1 = h * dydx ( x0 , y ) ; k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) ; y = y + ( 1.0 / 6.0 ) * ( k1 + 2 * k2 ) ; x0 = x0 + h ; } return y ; }
bool isPerfectSquare ( int x ) { int s = sqrt ( x ) ; return ( s * s == x ) ; }
int isFibonacci ( int n ) { if ( isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ) return 1 ; return 0 ; }
void compute ( int a , int b ) { for ( int i = 1 ; i < 100010 ; i ++ ) { fib [ i ] = isFibonacci ( i ) ; } for ( int x = 1 ; x < 100010 ; x ++ ) { for ( int y = 1 ; y < size ; y ++ ) { if ( fib [ x ] == 1 && fib [ y ] == 1 && a * x + b * y < 100010 ) { freq [ a * x + b * y ] ++ ; } } } }
void findMaxSum ( int n1 , int n2 ) { int arr1 [ MAX ] = { 0 } , arr2 [ MAX ] = { 0 } ; int l1 = 0 , l2 = 0 ; int max1 = max ( n1 , n2 ) ; int min1 = min ( n1 , n2 ) ; for ( int i = max1 ; i > 0 ; i /= 10 ) arr1 [ l1 ++ ] = ( i % 10 ) ; for ( int i = min1 ; i > 0 ; i /= 10 ) arr2 [ l2 ++ ] = ( i % 10 ) ; int f = 0 ; if ( l1 != l2 ) { int index = ( max_element ( arr2 , arr2 + l2 ) - arr2 ) ; for ( int i = l1 - 1 ; i > ( l2 - 1 ) ; i -- ) { if ( arr1 [ i ] < arr2 [ index ] ) { swap ( arr1 [ i ] , arr2 [ index ] ) ; f = 1 ; break ; } } } if ( f != 1 ) { int index1 = 0 , index2 = 0 ; int diff1 = 0 , diff2 = 0 ; for ( int i = l2 - 1 ; i >= 0 ; i -- ) { index1 = ( max_element ( arr1 , arr1 + i ) - arr1 ) ; index2 = ( max_element ( arr2 , arr2 + i ) - arr2 ) ; diff1 = ( arr2 [ index2 ] - arr1 [ i ] ) ; diff2 = ( arr1 [ index1 ] - arr2 [ i ] ) ; if ( diff1 > 0 diff2 > 0 ) { if ( diff1 > diff2 ) { swap ( arr1 [ i ] , arr2 [ index2 ] ) ; break ; } else if ( diff2 > diff1 ) { swap ( arr2 [ i ] , arr1 [ index1 ] ) ; break ; } else if ( diff1 == diff2 ) { if ( index1 <= index2 ) { swap ( arr2 [ i ] , arr1 [ index1 ] ) ; break ; } else if ( index2 <= index1 ) { swap ( arr1 [ i ] , arr2 [ index2 ] ) ; break ; } } } } } int f_n1 = 0 , f_n2 = 0 ; for ( int i = l1 - 1 ; i >= 0 ; i -- ) { f_n1 = ( f_n1 * 10 ) + arr1 [ i ] ; f_n2 = ( f_n2 * 10 ) + arr2 [ i ] ; } cout << ( f_n1 + f_n2 ) << "\n" ; }
void checkCube ( int a , int b ) { string s1 = to_string ( a ) ; string s2 = to_string ( b ) ; int c = stoi ( s1 + s2 ) ; if ( isPerfectCube ( c ) ) { cout << "Yes" ; } else { cout << "No" ; } }
bool isDivisible ( int n ) { int d ; while ( n / 100 ) { d = n % 10 ; n /= 10 ; n = abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; }
string even_or_odd ( string N ) { int len = N . size ( ) ; if ( N [ len - 1 ] == '0' N [ len - 1 ] == '2' N [ len - 1 ] == '4' N [ len - 1 ] == '6' N [ len - 1 ] == '8' N [ len - 1 ] == 'A' N [ len - 1 ] == 'C' N [ len - 1 ] == 'E' ) return ( "Even" ) ; else return ( "Odd" ) ; }
bool isDivisible ( int n ) { int d ; while ( n / 100 ) { d = n % 10 ; n /= 10 ; n = abs ( n - ( d * 3 ) ) ; } return ( n % 31 == 0 ) ; }
bool isPerfectSquare ( int x ) { int s = sqrt ( x ) ; return ( s * s == x ) ; }
bool isFibonacci ( int N ) { return isPerfectSquare ( 5 * N * N + 4 ) || isPerfectSquare ( 5 * N * N - 4 ) ; }
int nextNonFibonacci ( int N ) { if ( N <= 3 ) return 4 ; if ( isFibonacci ( N + 1 ) ) return N + 2 ; else return N + 1 ; }
bool isDivisible ( int n ) { int d ; while ( n / 100 ) { d = n % 10 ; n /= 10 ; n = abs ( n - ( d * 7 ) ) ; } return ( n % 71 == 0 ) ; }
int findDigits ( int n ) { int count = 0 ; while ( n != 0 ) { digit [ count ] = n % 10 ; n = n / 10 ; ++ count ; } return count ; }
int OR_of_Digits ( int n , int count ) { int ans = 0 ; for ( int i = 0 ; i < count ; i ++ ) { ans = ans | digit [ i ] ; } return ans ; }
int AND_of_Digits ( int n , int count ) { int ans = 0 ; for ( int i = 0 ; i < count ; i ++ ) { ans = ans & digit [ i ] ; } return ans ; }
int XOR_of_Digits ( int n , int count ) { int ans = 0 ; for ( int i = 0 ; i < count ; i ++ ) { ans = ans ^ digit [ i ] ; } return ans ; }
void preCompute ( ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i < 18 ; i ++ ) fact [ i ] = ( fact [ i - 1 ] * i ) ; }
void nextFactorial ( int N ) { for ( int i = 0 ; i < 21 ; i ++ ) { if ( N < fact [ i ] ) { cout << fact [ i ] ; break ; } } }
int largest_sum ( int arr [ ] , int n ) { int maximum = -1 ; map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { m [ arr [ i ] ] ++ ; } for ( auto j : m ) { if ( j . second > 1 ) { m [ 2 * j . first ] = m [ 2 * j . first ] + j . second / 2 ; if ( 2 * j . first > maximum ) maximum = 2 * j . first ; } } return maximum ; }
int maxLength ( int arr [ ] , int N ) { int product = 1 , len = 0 ; for ( int i = 0 ; i < N ; i ++ ) { product *= arr [ i ] ; } if ( product >= 0 ) { return N ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 0 ) { len = max ( len , max ( N - i - 1 , i ) ) ; } } return len ; }
void findNumbers ( int N ) { int i = 1 ; while ( i <= N ) { cout << ( i * i * i ) << " " ; i ++ ; } }
int properDivisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; }
int properDivisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum - n * ( n + 1 ) / 2 ; }
void findMinimumOperation ( int n , int d , int arrays [ 3 ] [ 2 ] ) { int cnt = 0 ; int first = INT_MIN , end = INT_MAX ; while ( n -- ) { int arr [ 2 ] = { arrays [ cnt ] [ 0 ] , arrays [ cnt ] [ 1 ] } ; sort ( arr , arr + 2 ) ; first = max ( first , arr [ 0 ] ) ; end = min ( end , arr [ 1 ] ) ; cnt ++ ; } if ( first > end ) cout << "-1" ; else { if ( d >= first && d <= end ) { cout << "0" ; } else cout << min ( abs ( first - d ) , abs ( d - end ) ) ; } }
ll mult ( ll a , ll b ) { return ( ( a % mod ) * ( b % mod ) ) % mod ; }
ll calculate_factors ( ll n ) { ll ans , cnt ; cnt = 0 ; ans = 1 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } if ( cnt ) { ans = mult ( ans , ( cnt + 1 ) ) ; } for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { cnt = 0 ; while ( n % i == 0 ) { cnt ++ ; n = n / i ; } if ( cnt ) { ans = mult ( ans , ( cnt + 1 ) ) ; } } if ( n > 2 ) { ans = mult ( ans , ( 2 ) ) ; } return ans % mod ; }
void getmax ( int arr [ ] , int n , int x ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } cout << min ( s , x ) ; }
void generatePrime ( ) { int i , j ; memset ( isPrime , true , sizeof ( isPrime ) ) ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } }
void Pair_of_PrimeXor ( int A [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( isPrime [ ( A [ i ] ^ A [ j ] ) ] ) { cout << "(" << A [ i ] << ", " << A [ j ] << ") " ; } } } }
vector < int > primeFactors ( int n ) { int i , j ; vector < int > Prime ; if ( n % 2 == 0 ) { Prime . push_back ( 2 ) ; } while ( n % 2 == 0 ) { n = n / 2 ; } for ( i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { Prime . push_back ( i ) ; } while ( n % i == 0 ) { n = n / i ; } } if ( n > 2 ) { Prime . push_back ( n ) ; } return Prime ; }
void checkDistinctPrime ( int n ) { vector < int > Prime = primeFactors ( n ) ; int product = 1 ; for ( auto i : Prime ) { product *= i ; } if ( product == n ) cout << "YES" ; else cout << "NO" ; }
double nthRoot ( int A , int N ) { double xPre = rand ( ) % 10 ; double eps = 1e-3 ; double delX = INT_MAX ; double xK ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + ( double ) A / pow ( xPre , N - 1 ) ) / ( double ) N ; delX = abs ( xK - xPre ) ; xPre = xK ; } return xK ; }
int countPowers ( int a , int b , int k ) { return ( floor ( nthRoot ( b , k ) ) - ceil ( nthRoot ( a , k ) ) + 1 ) ; }
long long findDigits ( int n , int b ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ) / ( log10 ( b ) ) ; return floor ( x ) + 1 ; }
bool isPrime ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; }
int findSum ( int N , int k ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += pow ( i , k ) ; } return sum ; }
bool isPerfectSquare ( int x ) { int s = sqrt ( x ) ; return ( s * s == x ) ; }
int isNonFibonacci ( int n ) { if ( isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ) return 0 ; else return n ; }
void compute ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isNonFibonacci ( i ) ; } }
void printSum ( int L , int R ) { int sum = pref [ R ] - pref [ L - 1 ] ; cout << sum << " " ; }
void checkArray ( int a [ ] , int b [ ] , int n ) { int operations = 0 ; int i = 0 ; while ( i < n ) { if ( a [ i ] - b [ i ] == 0 ) { i ++ ; continue ; } int diff = a [ i ] - b [ i ] ; i ++ ; while ( i < n && a [ i ] - b [ i ] == diff ) { i ++ ; } operations ++ ; } cout << operations << "\n" ; }
bool isPerfectSquare ( int x ) { int s = sqrt ( x ) ; return ( s * s == x ) ; }
bool isFibonacci ( int n ) { return ( isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ) ; }
int countFibonacciPairs ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( isFibonacci ( arr [ i ] ) && isFibonacci ( arr [ j ] ) ) { int prevFib = previousFibonacci ( arr [ i ] ) ; int nextFib = nextFibonacci ( arr [ i ] ) ; if ( prevFib == arr [ j ] nextFib == arr [ j ] ) { res ++ ; } } return res ; }
int countPairsWithProductK ( int arr [ ] , int n , int k ) { int count = 0 ; bool hashmap [ MAX ] = { false } ; for ( int i = 0 ; i < n ; i ++ ) hashmap [ arr [ i ] ] = true ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; double index = 1.0 * k / arr [ i ] ; if ( index >= 0 && ( ( index - ( int ) ( index ) ) == 0 ) && hashmap [ k / x ] ) count ++ ; hashmap [ x ] = false ; } return count ; }
void simpleSieve ( int limit , vector < int > & prime ) { bool mark [ limit + 1 ] ; memset ( mark , false , sizeof ( mark ) ) ; for ( int i = 2 ; i <= limit ; ++ i ) { if ( mark [ i ] == false ) { prime . push_back ( i ) ; for ( int j = i ; j <= limit ; j += i ) { mark [ j ] = true ; } } } }
void primesInRange ( int low , int high ) { int limit = floor ( sqrt ( high ) ) + 1 ; vector < int > prime ; simpleSieve ( limit , prime ) ; int n = high - low + 1 ; bool mark [ n + 1 ] ; memset ( mark , false , sizeof ( mark ) ) ; for ( int i = 0 ; i < prime . size ( ) ; i ++ ) { int loLim = floor ( low / prime [ i ] ) ; loLim *= prime [ i ] ; if ( loLim < low ) { loLim += prime [ i ] ; } if ( loLim == prime [ i ] ) { loLim += prime [ i ] ; } for ( int j = loLim ; j <= high ; j += prime [ i ] ) mark [ j - low ] = true ; } for ( int i = low ; i <= high ; i ++ ) { if ( ! mark [ i - low ] ) { allPrimes . insert ( i ) ; } } }
int maxPrimeSubarray ( int arr [ ] , int n ) { int current_max = 0 ; int max_so_far = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! allPrimes . count ( arr [ i ] ) ) current_max = 0 ; else { current_max ++ ; max_so_far = max ( current_max , max_so_far ) ; } } return max_so_far ; }
int search ( int a [ ] , int k , int x ) { int j ; for ( j = k - 1 ; j > -1 ; j -- ) { if ( a [ j ] == x ) return j ; } return -1 ; }
int countPairsWith ( int n , vector < int > perfectcubes , vector < int > nums ) { int count = 0 ; int len = perfectcubes . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) { int temp = perfectcubes [ i ] - n ; if ( temp > n ) { for ( auto j = nums . begin ( ) ; j != nums . end ( ) ; j ++ ) { if ( ( * j ) == temp ) count += 1 ; } } } return count ; }
int countCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) for ( int j = 1 ; j * j * j <= i ; j ++ ) if ( j * j * j == i ) cnt ++ ; return cnt ; }
int countCubes ( int a , int b ) { return ( floor ( cbrt ( b ) ) - ceil ( cbrt ( a ) ) + 1 ) ; }
static int checkArmstrong ( int x ) { int n = to_string ( x ) . size ( ) ; int sum1 = 0 ; int temp = x ; while ( temp > 0 ) { int digit = temp % 10 ; sum1 += pow ( digit , n ) ; temp /= 10 ; } if ( sum1 == x ) return x ; return 0 ; }
void printSumarmstrong ( int arr [ 2 ] [ 2 ] , int Q ) { preCompute ( ) ; for ( int i = 0 ; i < Q ; i ++ ) { printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ; } }
bool isArmstrong ( int x , int n ) { int sum1 = 0 ; int temp = x ; while ( temp > 0 ) { int digit = temp % 10 ; sum1 += ( int ) pow ( digit , n ) ; temp /= 10 ; } return sum1 == x ; }
void perfectCube ( int N ) { int cube_root ; cube_root = round ( cbrt ( N ) ) ; if ( cube_root * cube_root * cube_root == N ) { cout << "Yes" ; return ; } else { cout << "NO" ; return ; } }
map < int , int > primeFactors ( int n ) { map < int , int > primeFact ; while ( n % 2 == 0 ) { primeFact = insertPF ( primeFact , 2 ) ; n /= 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { primeFact = insertPF ( primeFact , i ) ; n /= i ; } } if ( n > 2 ) primeFact = insertPF ( primeFact , n ) ; return primeFact ; }
bool check ( int arr [ ] , int N ) { int even = 0 ; int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) { odd ++ ; } else { even ++ ; } } if ( even == N odd == N ) cout << "Yes" ; else cout << "No" ; }
void findSum ( int N ) { int sum = ( N ) * ( N + 1 ) / 2 ; int r = log2 ( N ) + 1 ; int expSum = pow ( 2 , r ) - 1 ; cout << sum - expSum << endl ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i += 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
bool twinPrime ( int n1 , int n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && abs ( n1 - n2 ) == 2 ) ; }
int countTwinPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( twinPrime ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; }
int findMinNumber ( int n ) { int count = 0 , ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 3 != 0 ) ans *= pow ( 2 , ( count % 3 ) ) ; for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 3 != 0 ) ans *= pow ( i , ( count % 3 ) ) ; } if ( n > 2 ) ans *= n ; return ans ; }
void printPairs ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << "(" << arr [ i ] << ", " << arr [ j ] << ")" << ", " ; } } }
int countSteps ( int n ) { int steps = 0 ; while ( n ) { int largest = cbrt ( n ) ; n -= ( largest * largest * largest ) ; steps ++ ; } return steps ; }
int product ( int N ) { int ans = 1 ; int val = pow ( 2 , N - 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) { ans *= pow ( i , val ) ; } return ans ; }
int nearest ( int n ) { int prevSquare = sqrt ( n ) ; int nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; int ans = ( n - prevSquare ) < ( nextSquare - n ) ? ( prevSquare - n ) : ( nextSquare - n ) ; return ans ; }
int ways ( int n ) { if ( n < 3 ) { return 0 ; } int c2 = 0 ; int c1 = n - 3 ; int l = c1 + 1 ; int s = 0 ; int exp_c2 = c1 / 2 ; while ( exp_c2 >= c2 ) { int f1 = factorial ( l ) ; int f2 = factorial ( c1 ) ; int f3 = factorial ( c2 ) ; int f4 = ( f2 * f3 ) ; s += f1 / f4 ; c2 += 1 ; c1 -= 2 ; l -= 1 ; } return s ; }
bool isPerfectCube ( int x ) { int cr = round ( cbrt ( x ) ) ; return ( cr * cr * cr == x ) ; }
int sqrtSearch ( int low , int high , int N ) { if ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( mid * mid <= N ) && ( ( mid + 1 ) * ( mid + 1 ) > N ) ) { return mid ; } else if ( mid * mid < N ) { return sqrtSearch ( mid + 1 , high , N ) ; } else { return sqrtSearch ( low , mid - 1 , N ) ; } } return low ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void printAllDivisors ( int arr [ ] , int N ) { int g = arr [ 0 ] ; set < int > divisors ; for ( int i = 1 ; i < N ; i ++ ) { g = gcd ( arr [ i ] , g ) ; } for ( int i = 1 ; i * i <= g ; i ++ ) { if ( g % i == 0 ) { divisors . insert ( i ) ; if ( g / i != i ) divisors . insert ( g / i ) ; } } for ( auto & it : divisors ) cout << it << " " ; }
int getSmallestPrimefactor ( int n ) { for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return i ; } }
bool ispalin ( int num ) { string s = to_string ( num ) ; int st = 0 , ed = s . size ( ) - 1 ; while ( st <= ed ) { if ( s [ st ] != s [ ed ] ) return false ; st ++ ; ed -- ; } return true ; }
void CalculateXORandOR ( int n ) { int CalculateXOR = 0 ; int CalculateOR = 0 ; int start = pow ( 10 , n - 1 ) ; int end = pow ( 10 , n ) - 1 ; for ( int i = start ; i <= end ; i ++ ) { if ( ispalin ( i ) ) { CalculateXOR = CalculateXOR ^ i ; CalculateOR = CalculateOR | i ; } } cout << "XOR = " << CalculateXOR ; cout << " OR = " << CalculateOR ; }
int checkPalindrome ( int num ) { string str = to_string ( num ) ; int l = 0 , r = str . length ( ) - 1 ; while ( l < r ) { if ( str [ l ] != str [ r ] ) { return 0 ; } l ++ ; r -- ; } return num ; }
void preCompute ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + checkPalindrome ( i ) ; } }
void Sieve ( ) { for ( int i = 1 ; i < 100001 ; i ++ ) k [ i ] = i ; for ( int i = 2 ; i < 100001 ; i ++ ) { if ( prime [ i ] == 0 ) for ( int j = i ; j < 100001 ; j += i ) { prime [ j ] = 1 ; while ( k [ j ] % ( i * i ) == 0 ) k [ j ] /= ( i * i ) ; } } }
int countPairs ( int arr [ ] , int n ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) { freq [ k [ arr [ i ] ] ] ++ ; } int sum = 0 ; for ( auto i : freq ) { sum += ( ( i . second - 1 ) * i . second ) / 2 ; } return sum ; }
int powOfPositive ( int n ) { int pos = floor ( log2 ( n ) ) ; return pow ( 2 , pos ) ; }
int powOfNegative ( int n ) { int pos = ceil ( log2 ( n ) ) ; return ( -1 * pow ( 2 , pos ) ) ; }
void highestPowerOf2 ( int n ) { if ( n > 0 ) { cout << powOfPositive ( n ) ; } else { n = - n ; cout << powOfNegative ( n ) ; } }
int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 1 ) sum += ( i * i ) ; else sum -= ( i * i ) ; } return sum ; }
int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y + x ) % ( y ^ x ) == 0 ) count ++ ; } } return count ; }
bool isPower ( int x , int y ) { int res1 = log ( y ) / log ( x ) ; double res2 = log ( y ) / log ( x ) ; return ( res1 == res2 ) ; }
int countPower ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( isPower ( arr [ i ] , arr [ j ] ) || isPower ( arr [ j ] , arr [ i ] ) ) res ++ ; return res ; }
int xor_all_elements ( int n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } }
int precompute ( ) { ll fact = 1 ; for ( ll i = 1 ; i <= 18 ; i ++ ) { fact = fact * i ; m [ fact ] = i ; } }
int sumOfParts ( int * arr , int N ) { int sum_part1 = 0 , sum_part2 = 0 , sum_part3 = 0 , sum_part4 = 0 ; int totalsum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i + j < N - 1 ) { if ( i < j and i != j and i + j ) sum_part1 += ( arr + i * N ) [ j ] ; else if ( i != j ) sum_part2 += ( arr + i * N ) [ j ] ; } else { if ( i > j and i + j != N - 1 ) sum_part3 += ( arr + i * N ) [ j ] ; else { if ( i + j != N - 1 and i != j ) sum_part4 += ( arr + i * N ) [ j ] ; } } } } totalsum = sum_part1 + sum_part2 + sum_part3 + sum_part4 ; return totalsum ; }
int noOfCards ( int n ) { return n * ( 3 * n + 1 ) / 2 ; }
int subsetSum ( int arr [ ] , int n , int i , int sum , int count ) { if ( i == n ) { if ( sum == 0 ) { count ++ ; } return count ; } count = subsetSum ( arr , n , i + 1 , sum - arr [ i ] , count ) ; count = subsetSum ( arr , n , i + 1 , sum , count ) ; return count ; }
void ifPossible ( int X , int Y ) { if ( X > Y ) swap ( X , Y ) ; if ( ( X + Y ) % 5 == 0 and 3 * X >= 2 * Y ) cout << "Yes" ; else cout << "No" ; }
int isPerfectCube ( long long int x ) { long double cr = round ( cbrt ( x ) ) ; return ( cr * cr * cr == x ) ? x : 0 ; }
void printSum ( int L , int R ) { int sum = pref [ R ] - pref [ L - 1 ] ; cout << sum << " " ; }
int binomialCoeff ( int n , int k ) { int C [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
vector < int > sieve ( int n ) { vector < int > prime ( n + 1 , 0 ) ; int p = 2 ; while ( p * p <= n ) { if ( prime [ p ] == 0 ) { for ( int i = 2 * p ; i < n + 1 ; i += p ) prime [ i ] = 1 ; } p += 1 ; } vector < int > allPrimes ; for ( int i = 2 ; i < n ; i ++ ) if ( prime [ i ] == 0 ) allPrimes . push_back ( i ) ; return allPrimes ; }
int log_a_to_base_b ( int a , int b ) { return log ( a ) / log ( b ) ; }
string findSmallest ( int N ) { string smallest = "1" + string ( ( N - 1 ) , '0' ) ; return smallest ; }
void heapify ( int arr [ ] , int n , int i ) { int largest = i ; int l = 2 * i + 1 ; int r = 2 * i + 2 ; if ( l < n && arr [ l ] > arr [ largest ] ) largest = l ; if ( r < n && arr [ r ] > arr [ largest ] ) largest = r ; if ( largest != i ) { swap ( arr [ i ] , arr [ largest ] ) ; heapify ( arr , n , largest ) ; } }
int count ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += 7 * pow ( 8 , i - 1 ) ; } return sum ; }
int nextPowerOfK ( int n , int k ) { return prevPowerofK ( n , k ) * k ; }
bool isPalindrome ( int n ) { string str = to_string ( n ) ; int s = 0 , e = str . length ( ) - 1 ; while ( s < e ) { if ( str [ s ] != str [ e ] ) { return false ; } s ++ ; e -- ; } return true ; }
void palindromicDivisors ( int n ) { vector < int > PalindromDivisors ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { if ( isPalindrome ( i ) ) { PalindromDivisors . push_back ( i ) ; } } else { if ( isPalindrome ( i ) ) { PalindromDivisors . push_back ( i ) ; } if ( isPalindrome ( n / i ) ) { PalindromDivisors . push_back ( n / i ) ; } } } } sort ( PalindromDivisors . begin ( ) , PalindromDivisors . end ( ) ) ; for ( int i = 0 ; i < PalindromDivisors . size ( ) ; i ++ ) { cout << PalindromDivisors [ i ] << " " ; } }
int isPerfectSquare ( long long int x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ? x : 0 ; }
void compute ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isPerfectSquare ( i ) ; } }
void printSum ( int L , int R ) { int sum = pref [ R ] - pref [ L - 1 ] ; cout << sum << " " ; }
void factors ( int n , int i ) { if ( i <= n ) { if ( n % i == 0 ) { cout << i << " " ; } factors ( n , i + 1 ) ; } }
int solve ( int n ) { int ans = ( n * n / 4 ) ; return ans ; }
void solve ( int arr [ ] , int n ) { set < int > unfilled_indices ; set < int > missing ; for ( int i = 1 ; i < n ; i ++ ) missing . insert ( i ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) unfilled_indices . insert ( i ) ; else { auto it = missing . find ( arr [ i ] ) ; missing . erase ( it ) ; } } auto it2 = missing . end ( ) ; it2 -- ; for ( auto it = unfilled_indices . begin ( ) ; it != unfilled_indices . end ( ) ; it ++ , it2 -- ) { arr [ * it ] = * it2 ; } int pos = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == i ) { pos = i ; } } int x ; if ( pos != 0 ) { for ( int i = 1 ; i < n ; i ++ ) { if ( pos != i ) { if ( unfilled_indices . find ( i ) != unfilled_indices . end ( ) ) { x = arr [ i ] ; arr [ i ] = pos ; arr [ pos ] = x ; break ; } } } } printArray ( arr , n ) ; }
void printArray ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
int maximum ( int x , int y ) { return ( ( x + y + abs ( x - y ) ) / 2 ) ; }
int minimum ( int x , int y ) { return ( ( x + y - abs ( x - y ) ) / 2 ) ; }
void SubarraysWithSumS ( int n , int k , int s ) { for ( int i = 0 ; i < k ; i ++ ) cout << s << " " ; for ( int i = k ; i < n ; i ++ ) cout << s + 1 << " " ; }
bool check ( long long x , vector < int > & pos , vector < int > & neg , int k ) { long long pairs = 0 ; int p = neg . size ( ) - 1 ; int nn = neg . size ( ) - 1 ; int pp = pos . size ( ) - 1 ; for ( int i = 0 ; i < neg . size ( ) ; i ++ ) { while ( p >= 0 and neg [ i ] * neg [ p ] <= x ) p -- ; pairs += min ( nn - p , nn - i ) ; } p = 0 ; for ( int i = pos . size ( ) - 1 ; i >= 0 ; i -- ) { while ( p < pos . size ( ) and pos [ i ] * pos [ p ] <= x ) p ++ ; pairs += min ( p , i ) ; } p = pos . size ( ) - 1 ; for ( int i = neg . size ( ) - 1 ; i >= 0 ; i -- ) { while ( p >= 0 and neg [ i ] * pos [ p ] <= x ) p -- ; pairs += pp - p ; } return ( pairs >= k ) ; }
int pay ( int n ) { int cuts = int ( log ( n ) / log ( 2 ) ) ; return cuts ; }
void sieve ( int n ) { for ( int i = 2 ; i <= n ; ++ i ) { if ( min_prime [ i ] > 0 ) { continue ; } min_prime [ i ] = i ; max_prime [ i ] = i ; int j = i + i ; while ( j <= n ) { if ( min_prime [ j ] == 0 ) { min_prime [ j ] = i ; } max_prime [ j ] = i ; j += i ; } } }
int pairCount ( int n , int m ) { int cnt = 0 , b , a ; for ( b = 0 ; b <= sqrt ( m ) ; b ++ ) { a = m - b * b ; if ( a * a + b == n ) { cnt ++ ; } } return cnt ; }
void Calc_Max_Div ( int arr [ ] , int n ) { bool vis [ maxin ] ; memset ( vis , 1 , maxin ) ; vis [ 0 ] = vis [ 1 ] = 0 ; for ( int i = 1 ; i <= maxin ; i ++ ) divisors [ i ] = i ; for ( int i = 4 ; i <= maxin ; i += 2 ) { vis [ i ] = 0 ; divisors [ i ] = i / 2 ; } for ( int i = 3 ; i <= maxin ; i += 2 ) { if ( divisors [ i ] != i ) { divisors [ i ] = i / divisors [ i ] ; } if ( vis [ i ] == 1 ) { for ( int j = i * i ; j < maxin ; j += i ) { vis [ j ] = 0 ; if ( divisors [ j ] == j ) divisors [ j ] = i ; } } } for ( int i = 0 ; i < n ; i ++ ) { if ( divisors [ arr [ i ] ] == arr [ i ] ) cout << "-1 " ; else cout << divisors [ arr [ i ] ] << " " ; } }
int sumOfDigit ( int n , int b ) { int unitDigit , sum = 0 ; while ( n > 0 ) { unitDigit = n % b ; sum += unitDigit ; n = n / b ; } return sum ; }
int nthDigit ( int a , int n , int b ) { for ( int i = 1 ; i < n ; i ++ ) a = a / b ; return a % b ; }
int countSum ( int N , int L , int R ) { if ( L > R ) { return 0 ; } if ( N == 1 ) { return R - L + 1 ; } if ( N > 1 ) { return ( N - 2 ) * ( R - L ) + 1 ; } }
lli solve ( lli arr [ ] , lli n , lli k ) { lli i , minx = INT_MAX ; for ( i = 0 ; i < n ; i ++ ) { minx = min ( minx , arr [ i ] ) ; } lli decrements = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] - minx ) % k != 0 ) { return -1 ; } else { decrements += ( ( arr [ i ] - minx ) / k ) ; } } return decrements ; }
int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
int count_of_subarrays ( int N ) { int count = binomialCoeff ( 2 * N - 1 , N ) ; return count ; }
void distribution ( int n , int k , int l , int r , int S , int Sk ) { int a [ n ] ; int len = k , temp , rem , s ; int diff = S - Sk ; for ( int i = 0 ; i < len ; i ++ ) { temp = Sk / k ; rem = Sk % k ; if ( temp + rem >= l && temp + rem <= r ) { a [ i ] = temp ; } else if ( temp + rem > r ) { a [ i ] = r ; } else if ( temp + rem < r ) { cout << "-1" ; return ; } Sk = Sk - a [ i ] ; k = k - 1 ; } if ( Sk > 0 ) { cout << "-1" ; return ; } if ( len ) { k = n - len ; for ( int i = len ; i < n ; i ++ ) { temp = diff / k ; rem = diff % k ; if ( temp + rem >= l && temp + rem <= r ) { a [ i ] = temp ; } else if ( temp + rem > r ) { a [ i ] = r ; } else if ( temp + rem < r ) { cout << "-1" ; return ; } diff = diff - a [ i ] ; k = k - 1 ; } if ( diff ) { cout << "-1" ; return ; } } for ( int i = 0 ; i < n ; i ++ ) { cout << a [ i ] << " " ; } }
int countDigit ( int n ) { int c = 0 ; while ( n ) { int r = n % 10 ; c ++ ; n /= 10 ; } return c ; }
int min_index ( int p [ ] , int n ) { int ans = 0 ; int mini = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] <= mini ) mini = p [ i ] ; if ( mini == p [ i ] ) ans ++ ; } return ans ; }
int equal_xor_sum ( int arr [ ] , int n ) { int Sum = 0 ; int Xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum = Sum + arr [ i ] ; Xor = Xor ^ arr [ i ] ; } if ( Sum == Xor ) cout << "YES" ; else cout << "NO" ; return 0 ; }
int Count_subarray ( int arr [ ] , int n ) { int subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { subarray_sum = 0 ; remaining_sum = 0 ; for ( int k = i ; k <= j ; k ++ ) { subarray_sum += arr [ k ] ; } for ( int l = 0 ; l < i ; l ++ ) { remaining_sum += arr [ l ] ; } for ( int l = j + 1 ; l < n ; l ++ ) { remaining_sum += arr [ l ] ; } if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; }
int set_bits ( int n ) { int count = 0 ; while ( n ) { count += n % 2 ; n /= 2 ; } return count ; }
int minSteps ( int n ) { int ans = 0 ; while ( n != 1 ) { if ( n % 2 == 0 ) n /= 2 ; else if ( n == 3 or set_bits ( n - 1 ) < set_bits ( n + 1 ) ) n -- ; else n ++ ; ans ++ ; } return ans ; }
int minimumNo ( int n ) { int ans = 0 ; stack < int > stack1 ; stack < int > stack2 ; while ( n != 0 ) { int r = n % 10 ; if ( r % 2 == 0 ) { stack1 . push ( r ) ; } else { stack2 . push ( r ) ; } n = n / 10 ; } while ( ! stack1 . empty ( ) && ! stack2 . empty ( ) ) { if ( stack1 . top ( ) < stack2 . top ( ) ) { ans = ans * 10 + stack1 . top ( ) ; stack1 . pop ( ) ; } else { ans = ans * 10 + stack2 . top ( ) ; stack2 . pop ( ) ; } } while ( ! stack1 . empty ( ) ) { ans = ans * 10 + stack1 . top ( ) ; stack1 . pop ( ) ; } while ( ! stack2 . empty ( ) ) { ans = ans * 10 + stack2 . top ( ) ; stack2 . pop ( ) ; } return ans ; }
void findNums ( int x ) { int ans ; for ( int i = 1 ; i <= sqrt ( x ) ; i ++ ) { if ( x % i == 0 && lcm ( i , x / i ) == x ) { ans = i ; } } cout << ans << " " << ( x / ans ) ; }
int maxCommonElement ( int A [ ] , int D [ ] , int N ) { int cnt [ MAXN ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = A [ i ] ; j < MAXN ; j += D [ i ] ) cnt [ j ] ++ ; } int com = max_element ( cnt , cnt + MAXN ) - cnt ; return com ; }
int findTrailingZeros ( int n ) { if ( n & 1 ) return 0 ; else { int ans = 0 ; n /= 2 ; while ( n ) { ans += n / 5 ; n /= 5 ; } return ans ; } }
int maxGCD ( int N , int K ) { int minSum = ( K * ( K + 1 ) ) / 2 ; if ( N < minSum ) return -1 ; int i = sqrt ( N ) ; int res = 1 ; while ( i >= 1 ) { if ( N % i == 0 ) { if ( i >= minSum ) res = max ( res , N / i ) ; if ( N / i >= minSum ) res = max ( res , i ) ; } i -- ; } return res ; }
int findNumberOfEvenCells ( int n , int q [ ] [ 2 ] , int size ) { int row [ n ] = { 0 } ; int col [ n ] = { 0 } ; for ( int i = 0 ; i < size ; i ++ ) { int x = q [ i ] [ 0 ] ; int y = q [ i ] [ 1 ] ; row [ x - 1 ] ++ ; col [ y - 1 ] ++ ; } int r1 = 0 , r2 = 0 ; int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( row [ i ] % 2 == 0 ) { r1 ++ ; } if ( row [ i ] % 2 == 1 ) { r2 ++ ; } if ( col [ i ] % 2 == 0 ) { c1 ++ ; } if ( col [ i ] % 2 == 1 ) { c2 ++ ; } } int count = r1 * c1 + r2 * c2 ; return count ; }
int fastmod ( int base , int exp , int mod ) { if ( exp == 0 ) return 1 ; else if ( exp % 2 == 0 ) { int ans = fastmod ( base , exp / 2 , mod ) ; return ( ans % mod * ans % mod ) % mod ; } else return ( fastmod ( base , exp - 1 , mod ) % mod * base % mod ) % mod ; }
int findPowerSum ( int n , int ar [ ] ) { const int mod = 1e9 + 7 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int base = __builtin_popcount ( ar [ i ] ) ; int exp = ar [ i ] ; sum += fastmod ( base , exp , mod ) ; sum %= mod ; } return sum ; }
int maxHeight ( int h1 , int h2 ) { return ( ( h1 * h2 ) - h1 - h2 ) ; }
double area ( double a , double b , double c ) { double p = ( a + b + c ) / 2 ; return sqrt ( p ) * sqrt ( p - a ) * sqrt ( p - b ) * sqrt ( p - c ) ; }
double binary_search ( ) { double s = area ( r1 + r2 , r2 + r3 , r3 + r1 ) ; double l = 0 , h = s / ( r1 + r2 + r3 ) ; while ( h - l >= 1.e-7 ) { double mid = ( l + h ) / 2 ; double s1 = area ( mid + r1 , mid + r2 , r1 + r2 ) ; double s2 = area ( mid + r1 , mid + r3 , r1 + r3 ) ; double s3 = area ( mid + r2 , mid + r3 , r2 + r3 ) ; if ( s1 + s2 + s3 < s ) { l = mid ; } else { h = mid ; } } return ( l + h ) / 2 ; }
bool subArray ( ll * arr , ll n , ll m ) { ll i ; unordered_map < ll , ll > mp ; for ( i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] = i + 1 ; } ll sumcur = 0 ; ll p = INT_MAX ; vector < ll > ans ; for ( i = 1 ; i <= m ; i ++ ) { sumcur += mp [ i ] ; p = min ( p , mp [ i ] ) ; ll val = p * i - i + ( i * ( i + 1 ) ) / 2 ; if ( i == m ) { if ( val == sumcur ) { return true ; } else return false ; } } }
bool isPalindrome ( string & s ) { int left = 0 , right = s . size ( ) - 1 ; while ( left <= right ) { if ( s [ left ] != s [ right ] ) { return false ; } left ++ ; right -- ; } return true ; }
int cntSubSeq ( int arr [ ] , int n ) { int pos_count = 0 ; int neg_count = 0 ; int result ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= pow ( 2 , neg_count - 1 ) ; result -= 1 ; return result ; }
void FermatFactors ( int n ) { if ( n <= 0 ) { cout << "[" << n << "]" ; return ; } if ( ( n & 1 ) == 0 ) { cout << "[" << n / 2.0 << "," << 2 << "]" ; return ; } int a = ceil ( sqrt ( n ) ) ; if ( a * a == n ) { cout << "[" << a << "," << a << "]" ; return ; } int b ; while ( true ) { int b1 = a * a - n ; b = ( int ) sqrt ( b1 ) ; if ( b * b == b1 ) break ; else a += 1 ; } cout << "[" << ( a - b ) << "," << ( a + b ) << "]" ; return ; }
void findNums ( int arr [ ] , int n ) { int S = 0 , X = 0 ; for ( int i = 0 ; i < n ; i ++ ) { S += arr [ i ] ; X ^= arr [ i ] ; } cout << X << " " << ( X + S ) ; }
void decBinary ( int arr [ ] , int n ) { int k = log2 ( n ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } }
int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; }
int getNum ( int n , int k ) { int l = log2 ( n ) + 1 ; int a [ l ] = { 0 } ; decBinary ( a , n ) ; if ( k > l ) return n ; a [ k - 1 ] = ( a [ k - 1 ] == 0 ) ? 1 : 0 ; return binaryDec ( a , l ) ; }
void solve ( int A , int B ) { double p = B / 2.0 ; int M = ceil ( 4 * p ) ; int N = 1 ; int O = - 2 * A ; int Q = ceil ( A * A + 4 * p * p ) ; cout << M << " " << N << " " << O << " " << Q ; }
int findMin ( int * arr , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) m = max ( m , arr [ i ] ) ; int freq [ m + 2 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; for ( int i = 1 ; i <= m + 1 ; i ++ ) { int j = i ; int cnt = 0 ; while ( j <= m ) { cnt += freq [ j ] ; j += i ; } if ( ! cnt ) return i ; } return m + 1 ; }
int findMin ( int * arr , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) m = max ( m , arr [ i ] ) ; int cnt [ m + 2 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j * j <= arr [ i ] ; j ++ ) { if ( arr [ i ] % j == 0 ) { if ( j * j == arr [ i ] ) cnt [ j ] ++ ; else cnt [ j ] ++ , cnt [ arr [ i ] / j ] ++ ; } } } for ( int i = 1 ; i <= m + 1 ; i ++ ) if ( cnt [ i ] == 0 ) { return i ; } return -1 ; }
void find_composite_nos ( int n ) { cout << 9 * n << " " << 8 * n ; }
int maxXOR ( int * arr , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = max ( ans , ( xorArr ^ arr [ i ] ) ) ; return ans ; }
int findLargest ( int * arr , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = __gcd ( arr [ i ] , gcd ) ; return gcd ; }
void sieve ( ) { memset ( isPrime , true , sizeof ( isPrime ) ) ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } }
void removePrimes ( int arr [ ] , int len ) { sieve ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( isPrime [ arr [ i ] ] ) { for ( int j = i ; j < len ; j ++ ) { arr [ j ] = arr [ j + 1 ] ; } i -- ; len -- ; } } printArray ( arr , len ) ; }
int minOR ( int * arr , int n ) { if ( n == 1 ) return 0 ; int pre [ n ] , suf [ n ] ; pre [ 0 ] = arr [ 0 ] , suf [ n - 1 ] = arr [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = ( suf [ i + 1 ] arr [ i ] ) ; int ans = min ( pre [ n - 2 ] , suf [ 1 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) ans = min ( ans , ( pre [ i - 1 ] suf [ i + 1 ] ) ) ; return ans ; }
int subgrids ( int N , int Z , int row [ ] , int col [ ] , int r , int c ) { vector < int > conrow ; vector < int > concol ; int K = sqrt ( Z ) ; conrow . push_back ( row [ 0 ] - 0 - 1 ) ; conrow . push_back ( N + 1 - row [ r - 1 ] - 1 ) ; for ( int i = 1 ; i < r ; i ++ ) { conrow . push_back ( row [ i ] - row [ i - 1 ] - 1 ) ; } concol . push_back ( col [ 0 ] - 0 - 1 ) ; concol . push_back ( N + 1 - col - 1 ) ; for ( int i = 1 ; i < c ; i ++ ) { concol . push_back ( col [ i ] - col [ i - 1 ] - 1 ) ; } int row_size = conrow . size ( ) ; int col_size = concol . size ( ) ; int answer = 0 ; for ( int i = 0 ; i < row_size ; i ++ ) { for ( int j = 0 ; j < col_size ; j ++ ) { int total = ( concol [ j ] / K ) * ( conrow [ i ] / K ) ; answer += ( total ) ; } } return answer ; }
int sub_arrays ( int a [ ] , int n , int k ) { int sum [ n + 2 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] -- ; a [ i ] %= k ; sum [ i + 1 ] += sum [ i ] + a [ i ] ; sum [ i + 1 ] %= k ; } int ans = 0 , l = 0 , r = 0 ; map < int , int > mp ; for ( int i = 0 ; i < n + 1 ; i ++ ) { ans += mp [ sum [ i ] ] ; mp [ sum [ i ] ] ++ ; r ++ ; if ( r - l >= k ) { mp [ sum [ l ] ] -- ; l ++ ; } } return ans ; }
int findCount ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( digitDividesK ( i , k ) ) count ++ ; } return count ; }
int digitSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } return sum ; }
bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; }
bool isDigitSumPalindrome ( int n ) { int sum = digitSum ( n ) ; if ( isPalindrome ( sum ) ) return true ; return false ; }
int countDigits ( int n ) { int cnt = 0 ; while ( n > 0 ) { cnt ++ ; n /= 10 ; } return cnt ; }
int digitPowSum ( int n ) { int sum = 0 ; int pw = countDigits ( n ) ; while ( n > 0 ) { int d = n % 10 ; sum += pow ( d , pw ) ; pw -- ; n /= 10 ; } return sum ; }
int countNum ( int n ) { int count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == digitPowSum ( i ) ) { count ++ ; } } return count ; }
void perfectSquares ( float l , float r ) { for ( int i = l ; i <= r ; i ++ ) { if ( sqrt ( i ) == ( int ) sqrt ( i ) ) cout << i << " " ; } }
void perfectSquares ( float l , float r ) { int number = ceil ( sqrt ( l ) ) ; int n2 = number * number ; number = ( number * 2 ) + 1 ; while ( ( n2 >= l && n2 <= r ) ) { cout << n2 << " " ; n2 = n2 + number ; number += 2 ; } }
int xorK ( int n , int k ) { if ( k % 2 == 1 ) return n ; return 0 ; }
void findRemainders ( ll n ) { set < ll > vc ; for ( ll i = 1 ; i <= ceil ( sqrt ( n ) ) ; i ++ ) vc . insert ( n / i ) ; for ( ll i = n / ceil ( sqrt ( n ) ) - 1 ; i >= 0 ; i -- ) vc . insert ( i ) ; for ( auto it : vc ) cout << it << " " ; }
void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
int countPrimes ( int n ) { SieveOfEratosthenes ( ) ; int cnt = 0 ; for ( int i = 2 ; i < n ; i ++ ) { if ( prime [ i ] && prime [ i - 2 ] ) cnt ++ ; } return cnt ; }
int power ( int a , int m1 ) { if ( m1 == 0 ) return 1 ; else if ( m1 == 1 ) return a ; else if ( m1 == 2 ) return ( 1LL * a * a ) % mod ; else if ( m1 & 1 ) return ( 1LL * a * power ( power ( a , m1 / 2 ) , 2 ) ) % mod ; else return power ( power ( a , m1 / 2 ) , 2 ) % mod ; }
void factorialfun ( ) { factorial [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) factorial [ i ] = ( 1LL * factorial [ i - 1 ] * i ) % mod ; }
void modinversefun ( ) { modinverse [ N - 1 ] = power ( factorial [ N - 1 ] , mod - 2 ) % mod ; for ( int i = N - 2 ; i >= 0 ; i -- ) modinverse [ i ] = ( 1LL * modinverse [ i + 1 ] * ( i + 1 ) ) % mod ; }
int binomial ( int n , int r ) { if ( r > n ) return 0 ; int a = ( 1LL * factorial [ n ] * modinverse [ n - r ] ) % mod ; a = ( 1LL * a * modinverse [ r ] ) % mod ; return a ; }
int arrange ( int n , int m , int k ) { factorialfun ( ) ; modinversefun ( ) ; long long ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) ans += ( 1LL * i * ( n - i ) * m * m ) % mod ; for ( int i = 1 ; i < m ; i ++ ) ans += ( 1LL * i * ( m - i ) * n * n ) % mod ; ans = ( ans * binomial ( n * m - 2 , k - 2 ) ) % mod ; return ( int ) ans ; }
int findK ( int l , int r ) { int maxExp = INT_MIN ; int k = -1 ; for ( int i = l ; i <= r ; i ++ ) { if ( distinctDigits ( i ) ) { int exp = ( l - i ) * ( i - r ) ; if ( exp >= maxExp ) { k = i ; maxExp = exp ; } } } return k ; }
void findWinner ( int n ) { if ( ( n - 1 ) % 6 == 0 ) { cout << "Second Player wins the game" ; } else { cout << "First Player wins the game" ; } }
int countIndices ( int arr [ ] , int n ) { int cnt = 0 ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) { max = arr [ i ] ; cnt ++ ; } } return cnt ; }
int min_changes ( int a [ ] , int n ) { int ans_a = 0 , ans_b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { if ( a [ i ] == 0 ) ans_a ++ ; else ans_b ++ ; } else { if ( a [ i ] == 0 ) ans_b ++ ; else ans_a ++ ; } } return min ( ans_a , ans_b ) ; }
void ans ( int n ) { if ( n == 1 ) cout << "1" ; else cout << "0" ; }
void sieve ( bool prime [ ] , int n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } }
int sumPrime ( int d ) { int maxVal = pow ( 2 , d ) - 1 ; bool prime [ maxVal + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; sieve ( prime , maxVal ) ; int sum = 0 ; for ( int i = 2 ; i <= maxVal ; i ++ ) { if ( prime [ i ] ) { sum += i ; } } return sum ; }
int isPossible ( int w , int h , int x , int y ) { if ( x * 2 == w && y * 2 == h ) return true ; return false ; }
int findNthDigit ( int p , int q , int N ) { int res ; while ( N > 0 ) { N -- ; p *= 10 ; res = p / q ; p %= q ; } return res ; }
int minsteps ( int n , int m ) { if ( m > n ) { return -1 ; } else { return ( ( n + 1 ) / 2 + m - 1 ) / m * m ; } }
int compare ( struct Node * a , struct Node * b ) { a = removeLeadingZeros ( a ) ; b = removeLeadingZeros ( b ) ; int lenA = getSize ( a ) ; int lenB = getSize ( b ) ; if ( lenA > lenB ) { return 1 ; } else if ( lenB > lenA ) { return -1 ; } while ( a != NULL && b != NULL ) { if ( a -> data > b -> data ) return 1 ; else if ( a -> data < b -> data ) return -1 ; a = a -> next ; b = b -> next ; } return 0 ; }
int power ( int a , int m1 ) { if ( m1 == 0 ) return 1 ; else if ( m1 == 1 ) return a ; else if ( m1 == 2 ) return ( 1LL * a * a ) % mod ; else if ( m1 & 1 ) return ( 1LL * a * power ( power ( a , m1 / 2 ) , 2 ) ) % mod ; else return power ( power ( a , m1 / 2 ) , 2 ) % mod ; }
void factorialfun ( ) { factorial [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) factorial [ i ] = ( 1LL * factorial [ i - 1 ] * i ) % mod ; }
void modinversefun ( ) { modinverse [ N - 1 ] = power ( factorial [ N - 1 ] , mod - 2 ) % mod ; for ( int i = N - 2 ; i >= 0 ; i -- ) modinverse [ i ] = ( 1LL * modinverse [ i + 1 ] * ( i + 1 ) ) % mod ; }
int binomial ( int n , int r ) { if ( r > n ) return 0 ; int a = ( 1LL * factorial [ n ] * modinverse [ n - r ] ) % mod ; a = ( 1LL * a * modinverse [ r ] ) % mod ; return a ; }
int maxFreq ( string s ) { string binary = "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { binary += bin [ s [ i ] - '0' ] ; } binary = binary . substr ( 0 , binary . length ( ) - 1 ) ; int count = 1 , prev = -1 , i , j = 0 ; for ( i = binary . length ( ) - 1 ; i >= 0 ; i -- , j ++ ) if ( binary [ i ] == '1' ) { count = max ( count , j - prev ) ; prev = j ; } return count ; }
int sumArr ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
int sumModArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { int subSum = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { subSum += arr [ j ] ; } arr [ i ] -= subSum ; } return sumArr ( arr , n ) ; }
int sumArr ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
int sumModArr ( int arr [ ] , int n ) { int subSum = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int curr = arr [ i ] ; arr [ i ] -= subSum ; subSum += curr ; } return sumArr ( arr , n ) ; }
int lcm ( int a , int b ) { int GCD = __gcd ( a , b ) ; return ( a * b ) / GCD ; }
int MinLCM ( int a [ ] , int n ) { int Prefix [ n + 2 ] ; int Suffix [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = lcm ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = lcm ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = min ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = min ( ans , lcm ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; }
unsigned long findNum ( unsigned long x ) { for ( int i = 0 ; i < NumUnsignBits - 1 ; i ++ ) { if ( ( ( x >> i ) & 1 ) != ( ( x >> ( i + 1 ) ) & 1 ) ) { x ^= ( 1 << i ) | ( 1 << ( i + 1 ) ) ; return x ; } } }
int minHealth ( int health [ ] , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { gcd = __gcd ( gcd , health [ i ] ) ; } return gcd ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
void constructArr ( int pair [ ] , int n ) { int size = ( 1 + ( int ) sqrt ( 1 + 8 * n ) ) / 2 ; int arr [ size ] ; arr [ 0 ] = sqrt ( ( pair [ 0 ] * pair [ 1 ] ) / pair [ size - 1 ] ) ; for ( int i = 1 ; i < size ; i ++ ) arr [ i ] = pair [ i - 1 ] / arr [ 0 ] ; printArr ( arr , size ) ; }
int countWays ( int n , int m ) { return factMod ( m ) ; }
unsigned long int Fuss_catalan ( unsigned int n ) { unsigned long int c = binomialCoeff ( 3 * n , n ) ; return c / ( 2 * n + 1 ) ; }
bool isComposite ( int n ) { for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return true ; } return false ; }
int Power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; }
void sieve ( ) { memset ( isPrime , true , sizeof ( isPrime ) ) ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } }
int findCnt ( int * arr , int n , int k ) { int ret = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n and arr [ j ] > = arr [ j - 1 ] ) j ++ ; int x = max ( 0 , j - i - k + 1 )  ; ret += ( x * ( x + 1 ) ) / 2 ; i = j ; } return ret ; }
bool isHeap ( int arr [ ] , int n ) { for ( int i = 0 ; i <= ( n - 2 ) / 2 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false ; if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) return false ; } return true ; }
int reverse ( int num ) { int rev = 0 ; while ( num > 0 ) { rev = rev * 10 + num % 10 ; num = num / 10 ; } return rev ; }
bool isPalindrome ( int num ) { if ( num == reverse ( num ) ) return true ; return false ; }
void printPalindromes ( int d ) { if ( d <= 0 ) return ; int smallest = pow ( 10 , d - 1 ) ; int largest = pow ( 10 , d ) - 1 ; for ( int i = smallest ; i <= largest ; i ++ ) { if ( isPalindrome ( i ) ) cout << i << " " ; } }
int countElements ( int p [ ] , int n ) { int ans = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( p [ i - 1 ] > p [ i ] and p [ i ] > p [ i + 1 ] ) ans ++ ; else if ( p [ i - 1 ] < p [ i ] and p [ i ] < p [ i + 1 ] ) ans ++ ; } return ans ; }
int countNums ( int a , int b , int c , int d ) { int x = b / c - ( a - 1 ) / c ; int y = b / d - ( a - 1 ) / d ; int k = ( c * d ) / __gcd ( c , d ) ; int z = b / k - ( a - 1 ) / k ; return b - a + 1 - x - y + z ; }
int cntSubArrays ( int * arr , int n , int k ) { int res = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n and arr [ j ] > = arr [ j - 1 ] ) j ++ ; res += max ( j - i - k + 1 , 0 )  ; i = j ; } return res ; }
int maxLen ( int * arr , int n ) { int min_val = * min_element ( arr , arr + n ) ; int freq = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == min_val ) freq ++ ; } return freq ; }
void print_primes_till_N ( int N ) { int i , j , flag ; cout << "Primenumbersbetween1and" << N < < " are:\n" ; for ( i = 1 ; i <= N ; i ++ ) { if ( i == 1 i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) cout << i << " " ; } }
void last_digit ( int X , int Y ) { cout << X % Y ; }
void sieve ( ) { memset ( isPrime , true , sizeof ( isPrime ) ) ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } }
void findPrimesD ( int d ) { int left = pow ( 10 , d - 1 ) ; int right = pow ( 10 , d ) - 1 ; for ( int i = left ; i <= right ; i ++ ) { if ( isPrime [ i ] ) { cout << i << " " ; } } }
int geometricMean ( int n ) { return sqrt ( n ) ; }
int two_sets ( int a [ ] , int n ) { sort ( a , a + n ) ; return a [ n / 2 ] - a [ ( n / 2 ) - 1 ] ; }
int min_moves ( int n ) { int ans = INT_MAX ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { ans = min ( ans , i + n / i - 2 ) ; } } return ans ; }
int findX ( int A , int B ) { int X = 0 ; for ( int bit = 0 ; bit < MAX ; bit ++ ) { int tempBit = 1 << bit ; int bitOfX = A & B & tempBit ; X += bitOfX ; } return X ; }
int cntPairs ( int a [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd ++ ; else if ( ( a [ i ] / 2 ) % 2 == 1 ) even ++ ; } int ans = odd * even + ( odd * ( odd - 1 ) ) / 2 ; return ans ; }
int min_modulo ( int l , int r ) { if ( r - l >= MOD ) return 0 ; else { int ans = MOD - 1 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { ans = min ( ans , ( i * j ) % MOD ) ; } } return ans ; } }
int kthNum ( int n , int k ) { int a = ( n + 1 ) / 2 ; if ( k > a ) return ( 2 * ( k - a ) ) ; return ( 2 * k - 1 ) ; }
void find_numbers ( int N ) { if ( N == 1 ) { cout << -1 ; } else { cout << N << " " << N + 1 << " " << N * ( N + 1 ) ; } }
void findNum ( int a [ ] , int n , int b [ ] , int m ) { int x = * max_element ( a , a + n ) ; int y = * max_element ( b , b + m ) ; cout << x << " " << y ; }
int find_k ( int a , int b ) { if ( ( a + b ) % 2 == 0 ) return ( ( a + b ) / 2 ) ; return -1 ; }
int odd_digits ( int n ) { if ( n < 10 ) return n ; else if ( n / 10 < 10 ) return 9 ; else if ( n / 100 < 10 ) return 9 + n - 99 ; else if ( n / 1000 < 10 ) return 9 + 900 ; else if ( n / 10000 < 10 ) return 909 + n - 9999 ; else return 90909 ; }
int nDigitPalindromes ( int n ) { return ( 9 * pow ( 10 , ( n - 1 ) / 2 ) ) ; }
int maxLCM ( int n ) { return ( n * ( n - 1 ) ) ; }
int cntSubSets ( int arr [ ] , int n ) { int maxVal = * max_element ( arr , arr + n ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; } return ( pow ( 2 , cnt ) - 1 ) ; }
int getSum ( int n ) { return ( ( n - 1 ) + pow ( n , 2 ) ) ; }
int cntEdges ( int n ) { int edges = pow ( 2 , n ) - 2 ; return edges ; }
int count ( int n ) { return n * ( 3 * n - 1 ) / 2 ; }
int findSum ( int n ) { return pow ( n , 3 ) ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
void generateArr ( int arr [ ] , int n ) { bool flip = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) { if ( flip ^= true ) cout << ceil ( ( float ) ( arr [ i ] ) / 2.0 ) << " " ; else cout << floor ( ( float ) ( arr [ i ] ) / 2.0 ) << " " ; } else { cout << arr [ i ] / 2 << " " ; } } }
int count ( int n ) { return 15 * pow ( 16 , n - 1 ) ; }
int nth_term ( int a , int b , int n ) { int z = 0 ; if ( n % 6 == 1 ) z = a ; else if ( n % 6 == 2 ) z = b ; else if ( n % 6 == 3 ) z = b - a ; else if ( n % 6 == 4 ) z = - a ; else if ( n % 6 == 5 ) z = - b ; if ( n % 6 == 0 ) z = - ( b - a ) ; return z ; }
int cntSubSeq ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int num = arr [ k - 1 ] ; int Y = 0 ; for ( int i = k - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] == num ) Y ++ ; } int cntX = Y ; for ( int i = k ; i < n ; i ++ ) { if ( arr [ i ] == num ) cntX ++ ; } return binomialCoeff ( cntX , Y ) ; }
bool inProportion ( int arr [ ] ) { int n = 4 ; sort ( arr , arr + n ) ; long extremes = ( long ) arr [ 0 ] * ( long ) arr [ 3 ] ; long means = ( long ) arr [ 1 ] * ( long ) arr [ 2 ] ; if ( extremes == means ) return true ; return false ; }
float findProb ( int arr [ ] , int n ) { long maxSum = INT_MIN , maxCount = 0 , totalPairs = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( sum == maxSum ) { maxCount ++ ; } else if ( sum > maxSum ) { maxSum = sum ; maxCount = 1 ; } totalPairs ++ ; } } float prob = ( float ) maxCount / ( float ) totalPairs ; return prob ; }
int findMissing ( int arr [ ] , int n , int k , int avg ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int num = ( avg * ( n + k ) ) - sum ; int den = k ; if ( num % den != 0 ) return -1 ; return ( num / den ) ; }
int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
int countNum ( int n ) { if ( n > 10 ) return 0 ; return ( 9 * factorial ( 9 ) / factorial ( 10 - n ) ) ; }
int binomialCoeff ( int n , int k ) { int C [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
int findMax ( int n ) { return binomialCoeff ( n , n / 2 ) ; }
int count ( int n ) { return int ( ( -1 + sqrt ( 1 + 8 * n ) ) / 2 ) ; }
void findEquation ( int a , int b ) { int sum = ( a + b ) ; int product = ( a * b ) ; cout << "x^2 - (" << sum << "x) + (" << product << ") = 0" ; }
int cal ( int n ) { double res = pow ( ceil ( ( pow ( pow ( 10 , ( n - 1 ) ) , 1 / 4 ) ) ) , 4 ) ; return ( int ) res ; }
int count ( int n ) { return 3 * n * ( n - 1 ) + 1 ; }
lli binomialCoeff ( lli n , lli k ) { if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }
lli fact ( lli n ) { if ( n >= 1 ) return n * fact ( n - 1 ) ; else return 1 ; }
bool isVowel ( char ch ) { if ( ch == 'a' ch == 'e' ch == 'i' ch == 'o' ch == 'u' ) { return true ; } return false ; }
lli countWords ( string s , int p , int q ) { lli countc = 0 , countv = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( isVowel ( s [ i ] ) ) countv ++ ; else countc ++ ; } lli a = binomialCoeff ( countc , p ) ; lli b = binomialCoeff ( countv , q ) ; lli c = fact ( p + q ) ; lli ans = ( a * b ) * c ; return ans ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
void generateArr ( int A [ ] , int n ) { int B [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < i ; j ++ ) { if ( A [ j ] % A [ i ] == 0 ) cnt ++ ; } B [ i ] = cnt ; } printArr ( B , n ) ; }
int count ( int n ) { return pow ( 2 , n - 1 ) ; }
int nextFibonacci ( int n ) { double a = n * ( 1 + sqrt ( 5 ) ) / 2.0 ; return round ( a ) ; }
int product ( int a [ ] , int n ) { int ans = 1 ; int val = pow ( 2 , n - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { ans *= pow ( a [ i ] , val ) ; } return ans ; }
int max_distinct_char ( string str , int n ) { int count [ NO_OF_CHARS ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ str [ i ] ] ++ ; int max_distinct = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count [ i ] != 0 ) max_distinct ++ ; return max_distinct ; }
int smallesteSubstr_maxDistictChar ( string str ) { int n = str . size ( ) ; int max_distinct = max_distinct_char ( str , n ) ; int minl = n ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { string subs = str . substr ( i , j ) ; int subs_lenght = subs . size ( ) ; int sub_distinct_char = max_distinct_char ( subs , subs_lenght ) ; if ( subs_lenght < minl && max_distinct == sub_distinct_char ) { minl = subs_lenght ; } } } return minl ; }
void findPair ( int arr [ ] , int n ) { if ( n < 2 ) { cout << "-1" ; return ; } int i , first , second ; first = second = -1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { second = arr [ i ] ; } } cout << "n = " << first << " and r = " << second ; }
int sum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum = sum * pow ( 2 , n - 1 ) ; return sum ; }
int maxHeight ( int n ) { return ( ( ( int ) sqrt ( 1 + 8.0 * n ) ) - 1 ) / 2 ; }
int ways ( int n ) { return n / 2 ; }
int prevPowerof2 ( int n ) { int p = ( int ) log2 ( n ) ; return ( int ) pow ( 2 , p ) ; }
int nextPowerOf2 ( int n ) { int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
int minDiff ( int n ) { int low = prevPowerof2 ( n ) ; int high = nextPowerOf2 ( n ) ; return min ( n - low , high - n ) ; }
bool isPossible ( int x , int y , int k ) { int minMoves = abs ( x ) + abs ( y ) ; if ( k >= minMoves && ( k - minMoves ) % 2 == 0 ) return true ; return false ; }
int countPairs ( int arr [ ] , int n ) { unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) map [ arr [ i ] - i ] ++ ; int res = 0 ; for ( auto x : map ) { int cnt = x . second ; res += ( ( cnt * ( cnt - 1 ) ) / 2 ) ; } return res ; }
int findMinValue ( int arr [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( ( sum / n ) + 1 ) ; }
bool isFactorion ( int n ) { int fact [ MAX ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; int org = n ; int sum = 0 ; while ( n > 0 ) { int d = n % 10 ; sum += fact [ d ] ; n /= 10 ; } if ( sum == org ) return true ; return false ; }
int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; }
long long int minOperations ( long long int n ) { long long int count = 0 ; long long int d = 0 ; if ( n == 1 ) return 0 ; while ( n > 9 ) { d = max ( n % 10 , d ) ; n /= 10 ; count += 10 ; } d = max ( d , n - 1 ) ; count += abs ( d ) ; return count - 1 ; }
int maxCommonFactors ( int a , int b ) { int gcd = __gcd ( a , b ) ; int ans = 1 ; for ( int i = 2 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { ans ++ ; while ( gcd % i == 0 ) gcd /= i ; } } if ( gcd != 1 ) ans ++ ; return ans ; }
void updateFreq ( int n , int freq [ ] ) { while ( n ) { int digit = n % TEN ; freq [ digit ] ++ ; n /= TEN ; } }
bool areAnagrams ( int a , int b ) { int freqA [ TEN ] = { 0 } ; int freqB [ TEN ] = { 0 } ; updateFreq ( a , freqA ) ; updateFreq ( b , freqB ) ; for ( int i = 0 ; i < TEN ; i ++ ) { if ( freqA [ i ] != freqB [ i ] ) return false ; } return true ; }
int dayOfYear ( string date ) { int year = stoi ( date . substr ( 0 , 4 ) ) ; int month = stoi ( date . substr ( 5 , 2 ) ) ; int day = stoi ( date . substr ( 8 ) ) ; if ( month > 2 && year % 4 == 0 && ( year % 100 != 0 year % 400 == 0 ) ) { ++ day ; } while ( month -- > 0 ) { day = day + days [ month - 1 ] ; } return day ; }
int Max_Sum ( int n ) { return ( n * ( n - 1 ) ) / 2 ; }
void convertToBinary ( int num , int a [ ] , int n ) { int pointer = n - 1 ; while ( num > 0 ) { a [ pointer ] = num % 2 ; num = num / 2 ; pointer -- ; } }
void print_seq ( int m ) { int n = ( 2 * m ) ; int a [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { a [ j ] = 0 ; } for ( int i = 0 ; i < ( int ) pow ( 2 , n ) ; i ++ ) { convertToBinary ( i , a , n ) ; checkforsum ( a , n ) ; } }
bool isDivisible ( int arr [ ] , int n ) { int lastDigit = arr [ n - 1 ] % 10 ; if ( lastDigit == 0 ) return true ; return false ; }
int solve ( int ang , int n ) { if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) { return 0 ; } else if ( ( ang * n ) % 180 != 0 ) { return 0 ; } int ans = 1 ; int freq = ( ang * n ) / 180 ; ans = ans * ( n - 1 - freq ) ; ans = ans * n ; return ans ; }
void preCompute ( ) { fact [ 0 ] = 1 ; result [ 0 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) { fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD ; result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD ; } }
bool prime ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
void thirdNumber ( int a , int b ) { int sum = 0 , temp = 0 ; sum = a + b ; temp = 1 ; if ( sum & 1 ) { temp = 2 ; } while ( ! prime ( sum + temp ) ) { temp += 2 ; } cout << temp ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
long divTermCount ( long a , long b , long c , long num ) { return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( ( ( a * b ) / gcd ( a , b ) ) * c ) / gcd ( ( ( a * b ) / gcd ( a , b ) ) , c ) ) ) ) ; }
int findNthTerm ( int a , int b , int c , long n ) { long low = 1 , high = LONG_MAX , mid ; while ( low < high ) { mid = low + ( high - low ) / 2 ; if ( divTermCount ( a , b , c , mid ) < n ) low = mid + 1 ; else high = mid ; } return low ; }
int nCr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; }
long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
long divTermCount ( long a , long b , long c , long num ) { return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( a * b * c ) / gcd ( gcd ( a , b ) , c ) ) ) ) ; }
double calculate_angle ( int n , int i , int j , int k ) { int x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; double ang1 = ( 180 * x ) / n ; double ang2 = ( 180 * y ) / n ; double ans = 180 - ang1 - ang2 ; return ans ; }
void getIndex ( int n , int shuffle [ ] [ N ] ) { for ( int i = 0 ; i < 3 ; i ++ ) { if ( shuffle [ i ] [ 0 ] == n ) n = shuffle [ i ] [ 1 ] ; else if ( shuffle [ i ] [ 1 ] == n ) n = shuffle [ i ] [ 0 ] ; } cout << n ; }
int calculate ( ll int n , ll int k , ll int m , ll int power ) { if ( n > m ) { if ( power == 0 ) return 0 ; else return power - 1 ; } else if ( n == m ) return power ; else return calculate ( n * k , k , m , power + 1 ) ; }
void printNumber ( int holes ) { if ( holes == 0 ) cout << "1" ; else if ( holes == 1 ) cout << "0" ; else { int rem = 0 , quo = 0 ; rem = holes % 2 ; quo = holes / 2 ; if ( rem == 1 ) cout << "4" ; for ( int i = 0 ; i < quo ; i ++ ) cout << "8" ; } }
long long power ( int p ) { long long res = 1 ; for ( int i = 1 ; i <= p ; ++ i ) { res *= 2 ; res %= mod ; } return res % mod ; }
long long subset_square_sum ( vector < int > & A ) { int n = ( int ) A . size ( ) ; long long ans = 0 ; for ( int i : A ) { ans += ( 1LL * i * i ) % mod ; ans %= mod ; } return ( 1LL * ans * power ( n - 1 ) ) % mod ; }
long long fact ( int n ) { long long res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
long long nCr ( int n , int r ) { return fact ( n ) / ( 1LL * fact ( r ) * fact ( n - r ) ) ; }
long long number_of_subsequences ( int arr [ ] , int k , int n ) { long long s = 0 ; map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { m [ arr [ i ] ] ++ ; } for ( auto j : m ) { s = s + 1LL * nCr ( j . second , k ) ; } return s ; }
int minCost ( int arr [ ] , int n ) { int count_even = 0 ; int count_odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count_even ++ ; else count_odd ++ ; } return min ( count_even , count_odd ) ; }
int coprime ( int a , int b ) { if ( __gcd ( a , b ) == 1 ) return true ; else return false ; }
void findNumbers ( int a , int b , int n ) { bool possible = true ; if ( ! coprime ( a , b ) ) possible = false ; int c1 = 1 ; int c2 = 1 ; int num1 , num2 ; set < int > st ; if ( possible ) { while ( ( int ) st . size ( ) != n ) { num1 = a + ( c1 * b ) ; if ( isPrime ( num1 ) ) { st . insert ( num1 ) ; } c1 ++ ; num2 = b + ( c2 * a ) ; if ( isPrime ( num2 ) ) { st . insert ( num2 ) ; } c2 ++ ; } for ( int i : st ) cout << i << " " ; } else cout << "-1" ; }
int sumPairs ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] * ( 2 * n ) ) ; } return sum ; }
int minSum ( int arr [ ] , int n ) { int sum = 0 ; sort ( arr , arr + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 4 < 2 ) sum = sum + arr [ i ] ; } return sum ; }
long long getCount ( int A , int B2 , int C ) { long long count = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { long long j = ( B2 / i ) + 1 ; if ( C >= j ) count = ( count + C - j + 1 ) ; if ( A >= j && C >= i ) count = ( count + ( C - i + 1 ) * ( A - j + 1 ) ) ; if ( A >= j ) A = j - 1 ; } return count ; }
int negProdSubArr ( int arr [ ] , int n ) { int positive = 1 , negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = -1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; }
int posProdSubArr ( int arr [ ] , int n ) { int total = ( n * ( n + 1 ) ) / 2 ; int cntNeg = negProdSubArr ( arr , n ) ; return ( total - cntNeg ) ; }
int distinctRemainders ( int n ) { if ( n % 2 == 0 ) return ( n / 2 ) ; return ( 1 + ( n / 2 ) ) ; }
int countUnsetBits ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int temp = i ; while ( temp ) { if ( temp % 2 == 0 ) cnt ++ ; temp = temp / 2 ; } } return cnt ; }
void least_prime_factor ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( ! lpf [ i ] ) for ( int j = i ; j < N ; j += i ) if ( ! lpf [ j ] ) lpf [ j ] = i ; }
void Mobius ( ) { for ( int i = 1 ; i < N ; i ++ ) { if ( i == 1 ) mobius [ i ] = 1 ; else { if ( lpf [ i / lpf [ i ] ] == lpf [ i ] ) mobius [ i ] = 0 ; else mobius [ i ] = -1 * mobius [ i / lpf [ i ] ] ; } } }
int gcd_pairs ( int a [ ] , int n ) { int maxi = 0 ; int fre [ N ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { fre [ a [ i ] ] ++ ; maxi = max ( a [ i ] , maxi ) ; } least_prime_factor ( ) ; Mobius ( ) ; int ans = 0 ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( ! mobius [ i ] ) continue ; int temp = 0 ; for ( int j = i ; j <= maxi ; j += i ) temp += fre [ j ] ; ans += temp * ( temp - 1 ) / 2 * mobius [ i ] ; } return ans ; }
void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
int xorFirstNPrime ( int n ) { int count = 0 , num = 1 ; int xorVal = 0 ; while ( count < n ) { if ( prime [ num ] ) { xorVal ^= num ; count ++ ; } num ++ ; } return xorVal ; }
int negProdSubArr ( int arr [ ] , int n ) { int positive = 1 , negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = -1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; }
int sum ( int n ) { int sum = ( n * ( n + 1 ) ) / 2 ; return sum ; }
int repeatedSum ( int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { n = sum ( n ) ; } return n ; }
bool isDivisible ( long long int n ) { long long int temp = n ; int sum = 0 ; while ( n ) { int digit = n % 10 ; sum += digit ; n /= 10 ; } n = temp ; while ( n ) { int digit = n % 10 ; if ( sum % digit != 0 ) return false ; n /= 10 ; } return true ; }
void least_prime_factor ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( ! lpf [ i ] ) for ( int j = i ; j < N ; j += i ) if ( ! lpf [ j ] ) lpf [ j ] = i ; }
void Mobius ( int n ) { int mobius [ N ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( i == 1 ) mobius [ i ] = 1 ; else { if ( lpf [ i / lpf [ i ] ] == lpf [ i ] ) mobius [ i ] = 0 ; else mobius [ i ] = -1 * mobius [ i / lpf [ i ] ] ; } } for ( int i = 1 ; i <= n ; i ++ ) cout << mobius [ i ] << " " ; }
int getBest ( int prev , int cur ) { int maximum = max ( MIN , prev ) ; for ( int i = maximum ; i <= MAX ; i ++ ) { int cnt = 0 ; int a = i ; int b = cur ; for ( int k = 0 ; k < DIGITS ; k ++ ) { if ( a % 10 != b % 10 ) cnt += 1 ; a /= 10 ; b /= 10 ; } if ( cnt <= 1 ) return i ; } return -1 ; }
void getList ( int arr [ ] , int n ) { vector < int > myList ; int i , cur ; bool possible = true ; myList . push_back ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) { cur = arr [ i ] ; myList . push_back ( getBest ( myList . back ( ) , cur ) ) ; if ( myList . back ( ) == -1 ) { possible = false ; break ; } } if ( possible ) { for ( i = 1 ; i < myList . size ( ) ; i ++ ) cout << myList [ i ] << " " ; } else cout << "-1" ; }
int maxItems ( int x , int y , int z ) { int type1 = x / COST ; x %= COST ; int type2 = y / COST ; y %= COST ; int type3 = z / COST ; z %= COST ; int type4 = min ( x , min ( y , z ) ) ; int maxItems = type1 + type2 + type3 + type4 ; return maxItems ; }
int countFactors ( int n , int p ) { int pwr = 0 ; while ( n > 0 && n % p == 0 ) { n /= p ; pwr ++ ; } return pwr ; }
int getCount ( int l , int r , int p ) { int cnt = 0 ; for ( int i = l ; i <= r ; i ++ ) { cnt += countFactors ( i , p ) ; } return cnt ; }
bool topsyTurvy ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == '2' str [ i ] == '4' str [ i ] == '5' str [ i ] == '6' str [ i ] == '7' str [ i ] == '9' ) { return false ; } } return true ; }
int countSubSeq ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { count ++ ; } } return ( pow ( 2 , count ) - 1 ) ; }
int countNum ( int N , int K ) { int sumPF [ MAX ] = { 0 } ; for ( int i = 2 ; i < N ; i ++ ) { if ( sumPF [ i ] == 0 ) { for ( int j = i ; j < N ; j += i ) { sumPF [ j ] += i ; } } } int count = 0 ; for ( int i = 2 ; i < N ; i ++ ) { if ( sumPF [ i ] == K ) count ++ ; } return count ; }
void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
int smallestPrime ( int d ) { int l = pow ( 10 , d - 1 ) ; int r = pow ( 10 , d ) - 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( prime [ i ] ) { return i ; } } return -1 ; }
int largestPrime ( int d ) { int l = pow ( 10 , d - 1 ) ; int r = pow ( 10 , d ) - 1 ; for ( int i = r ; i >= l ; i -- ) { if ( prime [ i ] ) { return i ; } } return -1 ; }
void findNumbers ( int a , int b ) { int gcd = __gcd ( a , b ) ; cout << ( a / gcd ) << " " << ( b / gcd ) ; }
bool possible ( int n ) { if ( n > 3 ) { int sum = ( n * ( n + 1 ) ) / 2 ; if ( sum % 3 == 0 ) { return true ; } } return false ; }
int findNthNumber ( int A , int B , int N ) { int sum = 0 ; for ( int i = 2 ; i < N ; i ++ ) { sum = A + B ; A = B ; B = sum ; } return sum ; }
long long int modulo ( string num ) { long long int res = 0 ; for ( long long int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( long long int ) num [ i ] - '0' ) % mod ; return res ; }
long long int findSum ( string L , string R ) { long long int a , b , l , r , ret ; a = modulo ( L ) ; b = modulo ( R ) ; l = ( ( a * ( a - 1 ) ) % mod * inv2 ) % mod ; r = ( ( b * ( b + 1 ) ) % mod * inv2 ) % mod ; ret = ( r % mod - l % mod ) ; if ( ret < 0 ) ret = ret + mod ; else ret = ret % mod ; return ret ; }
void heapSort ( int arr [ ] , int n ) { for ( int i = n / 2 - 1 ; i >= 0 ; i -- ) heapify ( arr , n , i ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { swap ( arr [ 0 ] , arr [ i ] ) ; heapify ( arr , i , 0 ) ; } }
void checkType ( int arr [ ] , int n ) { if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) cout << "Increasing" ; else if ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) cout << "Decreasing" ; else if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) cout << "Increasing then decreasing" ; else cout << "Decreasing then increasing" ; }
void cal_IST ( int h , float r ) { float IST = ( h * r * 1.0 ) / 360 ; int int_IST = ( int ) IST ; int float_IST = ceil ( ( IST - int_IST ) * 60 ) ; cout << int_IST << ":" << float_IST ; }
bool isPossible ( int arr [ ] , int p , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < p ; i ++ ) sum += arr [ i ] ; if ( sum == ( n * m ) ) return true ; return false ; }
int maxSubArraySum ( int a [ ] , int n , int k , int i ) { int max_so_far = INT_MIN , max_ending_here = 0 ; while ( i < n ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; i += k ; } return max_so_far ; }
int find ( int arr [ ] , int n , int k ) { int maxSum = 0 ; for ( int i = 0 ; i <= min ( n , k ) ; i ++ ) { int sum = 0 ; maxSum = max ( maxSum , maxSubArraySum ( arr , n , k , i ) ) ; } return maxSum ; }
void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
void solve ( int n ) { int count = 0 ; for ( int i = 3 ; count < n ; i ++ ) { if ( prime [ i ] ) { cout << i << " " ; count ++ ; } } }
int sum ( int n ) { int sum = 0 ; while ( n ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; }
void firstN ( int n ) { int num = 19 , cnt = 1 ; while ( cnt != n ) { if ( sum ( num ) == 10 ) { cout << num << " " ; cnt ++ ; } num += 9 ; } }
void compareVal ( int x , int y ) { long double a = y * log ( x ) ; long double b = x * log ( y ) ; if ( a > b ) cout << x << "^" << y << " > " << y << "^" << x ; else if ( a < b ) cout << x << "^" << y << " < " << y << "^" << x ; else if ( a == b ) cout << x << "^" << y << " = " << y << "^" << x ; }
int countWays ( int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { ans *= 2 ; ans %= MOD ; } return ( ( ans - 1 + MOD ) % MOD ) ; }
void findIntegers ( int n , int a [ ] , int x , int t1 , int t2 ) { bool flag = true ; for ( int i = 0 ; i < n ; i ++ ) { int temp = pow ( a [ i ] , 2 ) + x ; if ( temp % 10 != t1 && temp % 10 != t2 ) { cout << temp << " " ; flag = false ; } } if ( flag ) cout << "-1" ; }
void findMin ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sort ( arr , arr + n ) ; int min = arr [ 0 ] ; int max = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int num = arr [ i ] ; int total = num + min ; int j ; for ( j = 2 ; j <= num ; j ++ ) { if ( num % j == 0 ) { int d = j ; int now = ( num / d ) + ( min * d ) ; int reduce = total - now ; if ( reduce > max ) max = reduce ; } } } cout << ( sum - max ) ; }
bool Survives ( int n ) { int i ; for ( int i = 2 ; ; i ++ ) { if ( i > n ) return true ; if ( n % i == 0 ) return false ; n -= n / i ; } }
int digitSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += n % TEN ; n /= TEN ; } return sum ; }
int getNthTerm ( int n ) { int sum = digitSum ( n ) ; if ( sum % TEN == 0 ) return ( n * TEN ) ; int extra = TEN - ( sum % TEN ) ; return ( ( n * TEN ) + extra ) ; }
void firstNTerms ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) cout << getNthTerm ( i ) << " " ; }
int nthXorFib ( int n , int a , int b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return ( a ^ b ) ; return nthXorFib ( n % 3 , a , b ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void flip ( int a , int b ) { int lcm = ( a * b ) / gcd ( a , b ) ; a = lcm / a ; b = lcm / b ; cout << a - 1 << " " << b - 1 ; }
void findRemainder ( int n ) { int l = n % 10 ; while ( n >= 10 ) n /= 10 ; int f = n ; int remainder = f % l ; cout << remainder << endl ; }
double increaseInVol ( double l , double b , double h ) { double percentInc = ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ; percentInc -= 1 ; percentInc *= 100 ; return percentInc ; }
long long int countOccurrances ( long long int n , int d ) { long long int count = 0 ; while ( n > 0 ) { count = ( n % 10 == d ) ? count + 1 : count ; n = n / 10 ; } return count ; }
void findFactors ( int a , int b ) { int c ; c = a + b - 1 ; cout << c ; }
int countKdivPairs ( int A [ ] , int n , int K ) { int freq [ K ] = { 0 } ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int rem = A [ i ] % K ; ans += freq [ ( K - rem ) % K ] ; freq [ rem ] ++ ; } return ans ; }
void expressDigit ( int arr [ ] , int n ) { int min = 9 , index = 0 , temp = 0 ; temp = arr [ 0 ] ; for ( int i = 1 ; i < 10 ; i ++ ) { if ( arr [ i ] < min ) { min = arr [ i ] ; index = i ; } } if ( temp < min ) { cout << 1 ; for ( int i = 1 ; i <= temp + 1 ; i ++ ) cout << 0 ; } else { for ( int i = 0 ; i < min ; i ++ ) cout << index ; cout << index ; } }
int countDigits ( int num ) { int cnt = 0 ; while ( num > 0 ) { cnt ++ ; num /= 10 ; } return cnt ; }
int sumFromStart ( int num , int n , int rem ) { num /= ( ( int ) pow ( 10 , rem ) ) ; int sum = 0 ; while ( num > 0 ) { sum += ( num % 10 ) ; num /= 10 ; } return sum ; }
int sumFromEnd ( int num , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ( num % 10 ) ; num /= 10 ; } return sum ; }
float getAverage ( int n , int k , int l ) { int totalDigits = countDigits ( n ) ; if ( totalDigits < ( k + l ) ) return -1 ; int sum1 = sumFromEnd ( n , l ) ; int sum2 = sumFromStart ( n , k , totalDigits - k ) ; return ( ( float ) ( sum1 + sum2 ) / ( float ) ( k + l ) ) ; }
int totalways ( int * arr , int n ) { unordered_map < int , int > cnt ; for ( int i = 0 ; i < n ; ++ i ) { cnt [ arr [ i ] ] ++ ; } if ( n % 2 == 1 ) { int start = 0 , endd = n - 1 ; for ( int i = start ; i <= endd ; i = i + 2 ) { if ( i == 0 ) { if ( cnt [ i ] != 1 ) { return 0 ; } } else { if ( cnt [ i ] != 2 ) { return 0 ; } } } int ways = 1 ; start = 2 , endd = n - 1 ; for ( int i = start ; i <= endd ; i = i + 2 ) { ways = ways * 2 ; } return ways ; } else if ( n % 2 == 0 ) { int start = 1 , endd = n - 1 ; for ( int i = 1 ; i <= endd ; i = i + 2 ) { if ( cnt [ i ] != 2 ) return 0 ; } int ways = 1 ; for ( int i = start ; i <= endd ; i = i + 2 ) { ways = ways * 2 ; } return ways ; } }
int proizvolov ( int a [ ] , int b [ ] , int n ) { return n * n ; }
void compareValues ( int a , int b , int c , int d ) { double log1 = log10 ( a ) ; double num1 = log1 * b ; double log2 = log10 ( c ) ; double num2 = log2 * d ; if ( num1 > num2 ) cout << a << "^" << b ; else cout << c << "^" << d ; }
double sum ( double a , double b , double c , double d , double x ) { double ans = ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ; return ans ; }
double calculateLnx ( double n ) { double num , mul , cal , sum = 0 ; num = ( n - 1 ) / ( n + 1 ) ; for ( int i = 1 ; i <= 1000 ; i ++ ) { mul = ( 2 * i ) - 1 ; cal = pow ( num , mul ) ; cal = cal / mul ; sum = sum + cal ; } sum = 2 * sum ; return sum ; }
double calculateLogx ( double lnx ) { return ( lnx / 2.303 ) ; }
void printRoots ( long a , long b , long c ) { cout << 1 << ", " << c / ( a * 1.0 ) ; }
int permutation ( string str1 , int i , int n , int p ) { if ( i == n ) { int q = stoi ( str1 ) ; if ( q - p > 0 && q < min1 ) { min1 = q ; _count = 1 ; } } else { for ( int j = i ; j <= n ; j ++ ) { swap ( str1 [ i ] , str1 [ j ] ) ; permutation ( str1 , i + 1 , n , p ) ; swap ( str1 [ i ] , str1 [ j ] ) ; } } return min1 ; }
int longestAlternativeSequence ( int a [ ] , int n ) { int maxi1 = 0 ; int f1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! f1 ) { if ( a [ i ] % 2 ) { f1 = 1 ; maxi1 ++ ; } } else { if ( a [ i ] % 2 == 0 ) { maxi1 ++ ; f1 = 0 ; } } } int maxi2 = 0 ; int f2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( f2 ) { if ( a [ i ] % 2 ) { f2 = 1 ; maxi2 ++ ; } } else { if ( a [ i ] % 2 == 0 ) { maxi2 ++ ; f2 = 0 ; } } } return max ( maxi1 , maxi2 ) ; }
int Cells ( int n , int x ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && x / i <= n ) ans ++ ; return ans ; }
int Cells ( int n , int x ) { if ( n <= 0 x <= 0 x > n * n ) return 0 ; int i = 0 , count = 0 ; while ( ++ i * i < x ) if ( x % i == 0 && x <= n * i ) count += 2 ; return i * i == x ? count + 1 : count ; }
void ZigZag ( int n ) { long long fact [ n + 1 ] , zig [ n + 1 ] = { 0 } ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; zig [ 0 ] = 1 ; zig [ 1 ] = 1 ; cout << "zig zag numbers: " ; cout << zig [ 0 ] << " " << zig [ 1 ] << " " ; for ( int i = 2 ; i < n ; i ++ ) { long long sum = 0 ; for ( int k = 0 ; k <= i - 1 ; k ++ ) { sum += ( fact [ i - 1 ] / ( fact [ i - 1 - k ] * fact [ k ] ) ) * zig [ k ] * zig [ i - 1 - k ] ; } zig [ i ] = sum / 2 ; cout << sum / 2 << " " ; } }
int evenNumSubstring ( char str [ ] ) { int len = strlen ( str ) ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str [ i ] - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
float Depreciation ( float v , float r , float t ) { float D = v * pow ( ( 1 - r / 100 ) , t ) ; return D ; }
int nextPowerOfFour ( int n ) { int x = floor ( sqrt ( sqrt ( n ) ) ) ; if ( pow ( x , 4 ) == n ) return n ; else { x = x + 1 ; return pow ( x , 4 ) ; } }
int Alcuin ( int n ) { double _n = n , ans ; ans = round ( ( _n * _n ) / 12 ) - floor ( _n / 4 ) * floor ( ( _n + 2 ) / 4 ) ; return ans ; }
void solve ( int n ) { int i = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { cout << Alcuin ( i ) << ", " ; } }
int find_count ( vector < int > ele ) { int count = 0 ; for ( int i = 0 ; i < ele . size ( ) ; i ++ ) { vector < int > p ; int c = 0 ; for ( int j = ele . size ( ) - 1 ; j >= ( ele . size ( ) - 1 - i ) && j >= 0 ; j -- ) p . push_back ( ele [ j ] ) ; int j = ele . size ( ) - 1 , k = 0 ; while ( j >= 0 ) { if ( ele [ j ] != p [ k ] ) break ; j -- ; k ++ ; if ( k == p . size ( ) ) { c ++ ; k = 0 ; } } count = max ( count , c ) ; } return count ; }
void solve ( int n ) { int count = 1 ; vector < int > ele ; for ( int i = 0 ; i < n ; i ++ ) { cout << count << ", " ; ele . push_back ( count ) ; count = find_count ( ele ) ; } }
float speedOfTrain ( float X , float Y ) { float Speed = 0 ; Speed = 1188 * ( ( X - Y ) / Y ) ; return Speed ; }
int Division ( int a [ ] , int n ) { int maxi = INT_MIN , mini = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { maxi = max ( a [ i ] , maxi ) ; mini = min ( a [ i ] , mini ) ; } return maxi / mini ; }
vector < int > addPrimes ( ) { int n = MAX ; bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } vector < int > ans ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) ans . push_back ( p ) ; return ans ; }
int find_Sum ( int n ) { int sum = 0 ; vector < int > v = addPrimes ( ) ; for ( int i = 0 ; i < v . size ( ) and n ; i ++ ) { int flag = 1 ; int a = v [ i ] ; while ( a != 0 ) { int d = a % 10 ; a = a / 10 ; if ( is_prime ( d ) ) { flag = 0 ; break ; } } if ( flag == 1 ) { n -- ; sum = sum + v [ i ] ; } } return sum ; }
vector < int > addPrimes ( ) { int n = MAX ; bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } vector < int > ans ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) ans . push_back ( p ) ; return ans ; }
int pi ( int x , vector < int > v ) { int l = 0 , r = v . size ( ) - 1 , m , in = -1 ; while ( l <= r ) { m = ( l + r ) / 2 ; if ( v [ m ] <= x ) { in = m ; l = m + 1 ; } else { r = m - 1 ; } } return in + 1 ; }
int Ramanujan ( int n , vector < int > v ) { int upperbound = 4 * n * ( log ( 4 * n ) / log ( 2 ) ) ; for ( int i = upperbound ; ; i -- ) { if ( pi ( i , v ) - pi ( i / 2 , v ) < n ) return 1 + i ; } }
void Ramanujan_Numbers ( int n ) { int c = 1 ; vector < int > v = addPrimes ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { cout << Ramanujan ( i , v ) ; if ( i != n ) cout << ", " ; } }
void solveEven ( int n , int * arr , int * b ) { int left = n - 1 ; for ( int i = 0 ; i < ( n / 2 ) ; ++ i ) { b [ i ] = arr [ left ] ; left = left - 2 ; if ( left < 0 ) break ; } int right = 0 ; for ( int i = n / 2 ; i <= n - 1 ; ++ i ) { b [ i ] = arr [ right ] ; right = right + 2 ; if ( right > n - 2 ) break ; } }
void solve ( int n , int * arr ) { int b [ n ] ; if ( n % 2 == 0 ) solveEven ( n , arr , b ) ; else solveOdd ( n , arr , b ) ; for ( int i = 0 ; i <= n - 1 ; ++ i ) { cout << b [ i ] << " " ; } }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
int NumberOfWays ( int X , int Y , int M , int N ) { return fact ( X + Y ) * nCr ( M , X ) * nCr ( N , Y ) ; }
int Wedderburn ( int n ) { if ( n <= 2 ) return store [ n ] ; else if ( n % 2 == 0 ) { int x = n / 2 , ans = 0 ; for ( int i = 1 ; i < x ; i ++ ) { ans += store [ i ] * store [ n - i ] ; } ans += ( store [ x ] * ( store [ x ] + 1 ) ) / 2 ; store [ n ] = ans ; return ans ; } else { int x = ( n + 1 ) / 2 , ans = 0 ; for ( int i = 1 ; i < x ; i ++ ) { ans += store [ i ] * store [ n - i ] ; } store [ n ] = ans ; return ans ; } }
void Wedderburn_Etherington ( int n ) { store [ 0 ] = 0 ; store [ 1 ] = 1 ; store [ 2 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { cout << Wedderburn ( i ) ; if ( i != n - 1 ) cout << ", " ; } }
int factorial ( int n ) { if ( n <= 1 ) return 1 ; return n * factorial ( n - 1 ) ; }
int nCr ( int n , int r ) { return factorial ( n ) / ( factorial ( n - r ) * factorial ( r ) ) ; }
int NumberOfWays ( int n , int x , int y ) { return nCr ( 2 * n - x - y , n - x ) * factorial ( n ) * factorial ( n ) ; }
int fact ( int n ) { int i = 1 , fac = 1 ; for ( i = 1 ; i <= n ; i ++ ) fac = fac * i ; return fac ; }
double log_Expansion ( double x , int n ) { double sum = 0 ; int i = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum = sum + pow ( x , 2 * i ) / fact ( 2 * i ) ; } return sum ; }
void prime_range ( int start , int end , int * a ) { for ( int i = start ; i < end ; i ++ ) { if ( prime ( a [ i ] ) ) cout << a [ i ] << " " ; } }
int countElements ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; float mean = ( float ) sum / n ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { float newMean = ( float ) ( sum - arr [ i ] ) / ( n - 1 ) ; if ( newMean == mean ) cnt ++ ; } return cnt ; }
bool Prime ( int n ) { for ( int j = 2 ; j <= sqrt ( n ) ; j ++ ) if ( n % j == 0 ) return false ; return true ; }
int find_prime ( int x , int xsqmodp , int y , int ysqmodp ) { int n = x * x - xsqmodp ; int n1 = y * y - ysqmodp ; for ( int j = 2 ; j <= max ( sqrt ( n ) , sqrt ( n1 ) ) ; j ++ ) { if ( n % j == 0 && ( x * x ) % j == xsqmodp && n1 % j == 0 && ( y * y ) % j == ysqmodp ) if ( Prime ( j ) ) return j ; int j1 = n / j ; if ( n % j1 == 0 && ( x * x ) % j1 == xsqmodp && n1 % j1 == 0 && ( y * y ) % j1 == ysqmodp ) if ( Prime ( j1 ) ) return j1 ; j1 = n1 / j ; if ( n % j1 == 0 && ( x * x ) % j1 == xsqmodp && n1 % j1 == 0 && ( y * y ) % j1 == ysqmodp ) if ( Prime ( j1 ) ) return j1 ; } if ( n == n1 ) return n ; }
int numberOfMinutes ( int S , int S1 ) { int Min = 0 ; Min = ( ( S - S1 ) / floor ( S ) ) * 60 ; return Min ; }
int FindElement ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + a [ i ] ; if ( sum % n == 0 ) { int m = sum / n ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == m ) return m ; } return -1 ; }
int fac ( int num ) { if ( num == 0 ) return 1 ; int fact = 1 ; for ( int i = 1 ; i <= num ; i ++ ) fact = fact * i ; return fact ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int Max_sum ( int a [ ] , int n ) { int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) pos = 1 ; else if ( a [ i ] < 0 ) neg = 1 ; if ( pos == 1 and neg == 1 ) break ; } int sum = 0 ; if ( pos == 1 and neg == 1 ) { for ( int i = 0 ; i < n ; i ++ ) sum += abs ( a [ i ] ) ; } else if ( pos == 1 ) { int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } else if ( neg == 1 ) { for ( int i = 0 ; i < n ; i ++ ) a [ i ] = abs ( a [ i ] ) ; int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } return sum ; }
bool checkcomposite ( int n ) { for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return 1 ; } return 0 ; }
int power ( int x , int y , int mod ) { int res = 1 ; while ( y ) { if ( y & 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
bool Check ( int n , int a ) { if ( a > 1 && checkcomposite ( n ) && power ( a , n - 1 , n ) == 1 ) return 1 ; return 0 ; }
int count ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int cnt = 0 ; int i = 0 , j = 1 ; while ( i < n && j < n ) { j = ( j <= i ) ? ( i + 1 ) : j ; while ( j < n && ( arr [ j ] - arr [ i ] ) < k ) j ++ ; cnt += ( n - j ) ; i ++ ; } return cnt ; }
int factorial ( int n ) { if ( n <= 1 ) return 1 ; return n * factorial ( n - 1 ) ; }
int nCr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; }
float Probability ( int M , int N , int X ) { return ( float ) ( nCr ( M - N - 1 , X - 2 ) / ( nCr ( M - 1 , X - 1 ) * 1.0 ) ) ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int Count_number ( int N ) { return ( N * fact ( N ) ) ; }
int fact ( int n ) { if ( n <= 1 ) return 1 ; return n * fact ( n - 1 ) ; }
int nPr ( int n , int r ) { return fact ( n ) / fact ( n - r ) ; }
void decimalToBinary ( int n ) { if ( n == 0 ) { cout << "0" ; return ; } decimalToBinary ( n / 2 ) ; cout << n % 2 ; }
void MinimumValue ( int x , int y ) { if ( x > y ) swap ( x , y ) ; int a = 1 ; int b = x - 1 ; int c = y - b ; cout << a << " " << b << " " << c ; }
int getHeight ( int X ) { return ( 2 * X ) ; }
double volumeRec ( double a , double b , double e , double h ) { return ( ( ( b * h ) / 6 ) * ( 2 * a + e ) ) ; }
int firstSetBit ( int n ) { int x = n & ( n - 1 ) ; return ( n ^ x ) ; }
int NoofSequences ( int N , int M ) { unordered_map < int , int > prime ; for ( int i = 2 ; i <= sqrt ( M ) ; i += 1 ) { while ( M % i == 0 ) { prime [ i ] += 1 ; M /= i ; } } if ( M > 1 ) { prime [ M ] += 1 ; } int ans = 1 ; for ( auto it : prime ) { ans *= ( ncr ( N + it . second - 1 , N - 1 ) ) ; } return ans ; }
int findHours ( int a , int b , int k ) { if ( a >= b ) return -1 ; int time = k / ( b - a ) ; time = time + 1 ; return time ; }
int countQuadruples ( int N , int K ) { int M = N / K ; int answer = nCr ( M ) ; for ( int i = 2 ; i < M ; i ++ ) { int j = i ; int temp2 = M / i ; int count = 0 ; int check = 0 ; int temp = j ; while ( j % 2 == 0 ) { count ++ ; j /= 2 ; if ( count >= 2 ) break ; } if ( count >= 2 ) { check = 1 ; } for ( int k = 3 ; k <= sqrt ( temp ) ; k += 2 ) { int cnt = 0 ; while ( j % k == 0 ) { cnt ++ ; j /= k ; if ( cnt >= 2 ) break ; } if ( cnt >= 2 ) { check = 1 ; break ; } else if ( cnt == 1 ) count ++ ; } if ( j > 2 ) { count ++ ; } if ( check ) continue ; else { if ( count % 2 == 1 ) { answer -= nCr ( temp2 ) ; } else { answer += nCr ( temp2 ) ; } } } return answer ; }
int minimum_sum ( int n , int k ) { if ( k % n == 0 ) return 0 ; return 1 ; }
int ncr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; }
int NoOfDistributions ( int N , int R ) { return ncr ( N - 1 , R - 1 ) ; }
int ncr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; }
int NoOfDistributions ( int N , int R ) { return ncr ( N + R - 1 , R - 1 ) ; }
int maxElement ( int a [ ] , int n ) { if ( n < 3 ) return -1 ; int maxElement = a [ 0 ] ; int maxProd = a [ n - 1 ] * a [ 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { int currProd = a [ i - 1 ] * a [ ( i + 1 ) % n ] ; if ( currProd > maxProd ) { maxProd = currProd ; maxElement = a [ i ] ; } else if ( currProd == maxProd ) { maxElement = max ( maxElement , a [ i ] ) ; } } return maxElement ; }
int totalWays ( int X , int Y , int M , int W ) { return ( ncr ( M , X ) * ncr ( W , Y ) ) ; }
bool checkPerfectcube ( int n ) { int d = cbrt ( n ) ; if ( d * d * d == n ) return true ; return false ; }
int smallestPerfectCube ( int a [ ] , int n ) { int mini = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkPerfectcube ( a [ i ] ) ) { mini = min ( a [ i ] , mini ) ; } } return mini ; }
int Vertices ( int x , int y ) { int val = abs ( x ) + abs ( y ) ; cout << val * ( x < 0 ? -1 : 1 ) << " 0 " ; cout << "0 " << val * ( y < 0 ? -1 : 1 ) ; }
double SumofInverseDivisors ( int N , int Sum ) { double ans = ( double ) ( Sum ) * 1.0 / ( double ) ( N ) ; return ans ; }
void CheckSubarray ( int arr [ ] , int N ) { int presum [ N + 1 ] = { 0 } ; for ( int i = 1 ; i <= N ; i += 1 ) { presum [ i ] = presum [ i - 1 ] + arr [ i - 1 ] ; } for ( int i = 1 ; i <= N ; i += 1 ) { for ( int j = i ; j <= N ; j += 1 ) { if ( ( presum [ j ] - presum [ i - 1 ] ) % N == 0 ) { cout << i - 1 << " " << j - 1 ; return ; } } } cout << -1 ; }
void CheckSubarray ( int arr [ ] , int N ) { int presum [ N + 1 ] = { 0 } ; for ( int i = 1 ; i <= N ; i += 1 ) { presum [ i ] = presum [ i - 1 ] + arr [ i - 1 ] ; } vector < int > moduloclass [ N ] ; for ( int i = 1 ; i <= N ; i += 1 ) { moduloclass [ presum [ i ] % N ] . push_back ( i - 1 ) ; } if ( moduloclass [ 0 ] . size ( ) > 0 ) { cout << 0 << " " << moduloclass [ 0 ] [ 0 ] ; return ; } for ( int i = 1 ; i < N ; i += 1 ) { if ( moduloclass [ i ] . size ( ) >= 2 ) { cout << moduloclass [ i ] [ 0 ] + 1 << " " << moduloclass [ i ] [ 1 ] ; return ; } } }
int findNearestNumber ( int n ) { int cnt = countBits ( n ) ; cnt -= 1 ; if ( cnt % 2 ) { return 1 << ( cnt + 1 ) ; } else { int tempnum = 0 ; for ( int i = 0 ; i <= cnt ; i += 2 ) tempnum += 1 << i ; if ( tempnum < n ) { return ( 1 << ( cnt + 2 ) ) ; } else if ( tempnum == n ) return n ; for ( int i = 0 ; i <= cnt ; i += 2 ) { tempnum -= ( 1 << i ) ; if ( tempnum < n ) return tempnum += ( 1 << i ) ; } } }
int getX ( int a , int b , int c , int d ) { int X = ( b * c - a * d ) / ( d - c ) ; return X ; }
int NoofTriplets ( int N , int K ) { int cnt [ K ] ; memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int i = 1 ; i <= N ; i += 1 ) { cnt [ i % K ] += 1 ; } if ( K & 1 ) return cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] ; else { return ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K / 2 ] * cnt [ K / 2 ] * cnt [ K / 2 ] ) ; } }
int countNum ( int n ) { if ( n == 1 ) return 1 ; int count = pow ( 2 , n - 2 ) ; return count ; }
ll binaryToDecimal ( string n ) { string num = n ; ll dec_value = 0 ; ll base = 1 ; ll len = num . length ( ) ; for ( ll i = len - 1 ; i >= 0 ; i -- ) { if ( num [ i ] == '1' ) dec_value += base ; base = base * 2 ; } return dec_value ; }
ll findNumber ( ll n ) { string s = constructString ( n - 1 ) ; ll num = binaryToDecimal ( s ) ; return num ; }
ll findNumber ( int n ) { ll num = n - 1 ; num = 2 * ( ll ) pow ( 4 , num ) ; num = floor ( num / 3.0 ) ; return num ; }
int bitonic_point ( Node * node ) { if ( node == NULL ) return -1 ; if ( node -> next == NULL ) return -1 ; if ( node -> data > node -> next -> data ) return -1 ; while ( node -> next != NULL ) { if ( node -> data > node -> next -> data ) break ; node = node -> next ; } int bitonicPoint = node -> data ; while ( node -> next != NULL ) { if ( node -> data < node -> next -> data ) return -1 ; node = node -> next ; } return bitonicPoint ; }
int minSum ( int a [ ] , int n ) { sort ( a , a + n ) ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }
bool canConvert ( int a , int b ) { while ( b > a ) { if ( b % 10 == 1 ) { b /= 10 ; continue ; } if ( b % 2 == 0 ) { b /= 2 ; continue ; } return false ; } if ( b == a ) return true ; return false ; }
int MinRemove ( int a [ ] , int n , int k ) { vector < int > cnt ( k , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) cnt [ 0 ] ++ ; else if ( cnt [ a [ i ] - 1 ] > 0 ) { cnt [ a [ i ] - 1 ] -- ; cnt [ a [ i ] ] ++ ; } } return n - ( k * cnt [ k - 1 ] ) ; }
int mosaic ( int n ) { int i , ans = 1 ; for ( i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 && n > 0 ) { int count = 0 ; while ( n % i == 0 ) { n /= i ; count ++ ; } ans *= count * i ; } } return ans ; }
void nMosaicNumbers ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) cout << mosaic ( i ) << " " ; }
int mosaic ( int n ) { int i , ans = 1 ; for ( i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 && n > 0 ) { int count = 0 ; while ( n % i == 0 ) { n /= i ; count ++ ; } ans *= count * i ; } } return ans ; }
void lowerWythoff ( int n ) { double phi = ( 1 + sqrt ( 5 ) ) / 2.0 ; for ( int i = 1 ; i <= n ; i ++ ) { double ans = floor ( i * phi ) ; cout << ans ; if ( i != n ) cout << ", " ; } }
int Total_Ways ( int n ) { int fac = 1 ; for ( int i = 2 ; i <= n - 1 ; i ++ ) { fac = fac * i ; } return ( fac * 2 ) ; }
int MaxNumbers ( int a [ ] , int n ) { int fre [ 3 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] %= 3 ; fre [ a [ i ] ] ++ ; } int ans = fre [ 0 ] ; int k = min ( fre [ 1 ] , fre [ 2 ] ) ; ans += k ; fre [ 1 ] -= k ; fre [ 2 ] -= k ; ans += fre [ 1 ] / 3 + fre [ 2 ] / 3 ; return ans ; }
unsigned int countSetBits ( int n ) { unsigned int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
int pairs ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = countSetBits ( arr [ i ] ) + countSetBits ( arr [ j ] ) ; if ( sum == k ) count ++ ; } } return count ; }
unsigned int countSetBits ( int n ) { unsigned int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
int pairs ( int arr [ ] , int n , int k ) { int count = 0 ; int f [ MAX + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) f [ countSetBits ( arr [ i ] ) ] ++ ; for ( int i = 0 ; i <= MAX ; i ++ ) { for ( int j = i ; j <= MAX ; j ++ ) { if ( i + j == k ) { if ( i == j ) count += ( ( f [ i ] * ( f [ i ] - 1 ) ) / 2 ) ; else count += ( f [ i ] * f [ j ] ) ; } } } return count ; }
int composite_factors ( int n ) { int count = 0 ; int i , j ; int a [ n + 1 ] = { 0 } ; for ( i = 1 ; i <= n ; ++ i ) { if ( n % i == 0 ) { a [ i ] = i ; } } for ( i = 2 ; i <= n ; i ++ ) { j = 2 ; int p = 1 ; while ( j < a [ i ] ) { if ( a [ i ] % j == 0 ) { p = 0 ; break ; } j ++ ; } if ( p == 0 && a [ i ] != 0 ) { count ++ ; } } return count ; }
int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; }
void specialSieve ( int n ) { int cnt = 0 ; int prime [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! prime [ i ] ) { cnt ++ ; for ( int j = i ; j <= n ; j += i ) prime [ j ] = cnt ; } } for ( int i = 2 ; i <= n ; i ++ ) cout << prime [ i ] << " " ; }
int sumOfMersenne ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 && isMersenne ( arr [ i ] ) ) { sum += arr [ i ] ; } } return sum ; }
int sumOfFactors ( int n ) { int sum = 0 ; for ( int f = 1 ; f <= n / 2 ; f ++ ) { if ( n % f == 0 ) { sum += f ; } } return sum ; }
bool sameLength ( int A , int B ) { while ( A > 0 && B > 0 ) { A = A / 10 ; B = B / 10 ; } if ( A == 0 && B == 0 ) return true ; return false ; }
void preProcess ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) cnt_neg ++ ; if ( arr [ i ] == 0 ) exists_zero = true ; } }
int FindXorSum ( int arr [ ] , int k , int n ) { if ( n < k ) return 0 ; int x [ n ] = { 0 } ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 ) x [ i ] = x [ i - 1 ] ^ arr [ i ] ; else x [ i ] = arr [ i ] ; if ( i >= k - 1 ) { int sum = 0 ; sum = x [ i ] ; if ( i - k > -1 ) sum ^= x [ i - k ] ; result += sum ; } } return result ; }
int reverse ( int n ) { int rev = 0 ; while ( n > 0 ) { int d = n % 10 ; rev = rev * 10 + d ; n = n / 10 ; } return rev ; }
bool isPalin ( int n ) { return ( n == reverse ( n ) ) ; }
int countDigits ( int n ) { int c = 0 ; while ( n > 0 ) { n = n / 10 ; c ++ ; } return c ; }
int countPalinDigits ( int arr [ ] , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 10 || isPalin ( arr [ i ] ) ) { s += countDigits ( arr [ i ] ) ; } } return s ; }
int reverse ( int n ) { int d = 0 , s = 0 ; while ( n > 0 ) { d = n % 10 ; s = s * 10 + d ; n = n / 10 ; } return s ; }
bool isPalin ( int n ) { return n == reverse ( n ) ; }
int sumOfArray ( int arr [ ] , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] > 10 ) && isPalin ( arr [ i ] ) ) { s += arr [ i ] ; } } return s ; }
bool isVowel ( char ch ) { if ( ch == 'a' ch == 'e' ch == 'i' ch == 'o' ch == 'u' ) return true ; else return false ; }
ll fact ( ll n ) { if ( n < 2 ) return 1 ; return n * fact ( n - 1 ) ; }
ll only_vowels ( map < char , int > & freq ) { ll denom = 1 ; ll cnt_vwl = 0 ; for ( auto itr = freq . begin ( ) ; itr != freq . end ( ) ; itr ++ ) { if ( isVowel ( itr -> first ) ) { denom *= fact ( itr -> second ) ; cnt_vwl += itr -> second ; } } return fact ( cnt_vwl ) / denom ; }
ll all_vowels_together ( map < char , int > & freq ) { ll vow = only_vowels ( freq ) ; ll denom = 1 ; ll cnt_cnst = 0 ; for ( auto itr = freq . begin ( ) ; itr != freq . end ( ) ; itr ++ ) { if ( ! isVowel ( itr -> first ) ) { denom *= fact ( itr -> second ) ; cnt_cnst += itr -> second ; } } ll ans = fact ( cnt_cnst + 1 ) / denom ; return ( ans * vow ) ; }
ll no_vowels_together ( string & word ) { map < char , int > freq ; for ( int i = 0 ; i < word . size ( ) ; i ++ ) { char ch = tolower ( word [ i ] ) ; freq [ ch ] ++ ; } ll total = total_permutations ( freq ) ; ll vwl_tgthr = all_vowels_together ( freq ) ; ll res = total - vwl_tgthr ; return res ; }
void updatePrimes ( ) { for ( int i = 2 ; i <= MAX ; i ++ ) { prime [ i ] = 1 ; } prime [ 0 ] = prime [ 1 ] = 0 ; for ( int i = 2 ; i * i <= MAX ; i ++ ) { if ( prime [ i ] == 1 ) { for ( int j = i * i ; j <= MAX ; j += i ) { prime [ j ] = 0 ; } } } for ( int i = 1 ; i <= MAX ; i ++ ) { prime [ i ] += prime [ i - 1 ] ; } }
int getDifference ( int l , int r ) { int total = r - l + 1 ; int primes = prime [ r ] - prime [ l - 1 ] ; int composites = total - primes ; return ( abs ( primes - composites ) ) ; }
double e ( int x , int n ) { static double p = 1 , f = 1 ; double r ; if ( n == 0 ) return 1 ; r = e ( x , n - 1 ) ; p = p * x ; f = f * n ; return ( r + p / f ) ; }
void constructSieve ( ) { for ( int i = 2 ; i <= MAX ; i ++ ) { if ( Sieve [ i ] == 0 ) { for ( int j = 2 * i ; j <= MAX ; j += i ) { int temp = j ; while ( temp > 1 && temp % i == 0 ) { Sieve [ j ] ++ ; temp = temp / i ; } } } } }
void checkElements ( int A [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( Sieve [ A [ i ] ] == k ) { cout << "YES\n" ; } else { cout << "NO\n" ; } } }
long long modularexpo ( long long x , long long y , long long p ) { long long res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
void multiply ( long long F [ 2 ] [ 2 ] , long long M [ 2 ] [ 2 ] , long long m ) { long long x = ( ( F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] ) % m + ( F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ) % m ) % m ; long long y = ( ( F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] ) % m + ( F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ) % m ) % m ; long long z = ( ( F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] ) % m + ( F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ) % m ) % m ; long long w = ( ( F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] ) % m + ( F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ) % m ) % m ; F [ 0 ] [ 0 ] = x ; F [ 0 ] [ 1 ] = y ; F [ 1 ] [ 0 ] = z ; F [ 1 ] [ 1 ] = w ; }
void power ( long long F [ 2 ] [ 2 ] , long long n , long long m ) { if ( n == 0 n == 1 ) return ; long long M [ 2 ] [ 2 ] = { { 1 , 1 } , { 1 , 0 } } ; power ( F , n / 2 , m ) ; multiply ( F , F , m ) ; if ( n % 2 != 0 ) multiply ( F , M , m ) ; }
long long fib ( long long n , long long m ) { long long F [ 2 ] [ 2 ] = { { 1 , 1 } , { 1 , 0 } } ; if ( n == 0 ) return 0 ; power ( F , n - 1 , m ) ; return F [ 0 ] [ 0 ] ; }
int cntWays ( int arr [ ] , int n ) { if ( n == 1 ) return 0 ; int tot_sum = 0 , sum = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) tot_sum += arr [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum += arr [ i ] ; if ( sum == tot_sum / 2 ) ans ++ ; } return ans ; }
void power_2 ( ) { ll ans = 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { pow2 [ i ] = ans ; ans *= 2 ; } }
int countSetBits ( ll x ) { int setBits = 0 ; while ( x != 0 ) { x = x & ( x - 1 ) ; setBits ++ ; } return setBits ; }
void add ( ll num ) { int point = 0 ; ll value = 0 ; for ( ll i = 0 ; i < MAX ; i ++ ) { if ( visited [ i ] ) continue ; else { if ( num & 1 ) { value += ( 1 << i ) ; } num /= 2 ; } } ans . push_back ( value ) ; }
void solve ( ll n , ll k ) { ans . push_back ( k ) ; int countk = countSetBits ( k ) ; if ( pow2 [ countk ] < n ) { cout << -1 ; return ; } int count = 0 ; for ( ll i = 0 ; i < pow2 [ countk ] - 1 ; i ++ ) { add ( i ) ; count ++ ; if ( count == n ) break ; } for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << " " ; } }
int numberOfMen ( int D , int m , int d ) { int Men = ( m * ( D - d ) ) / d ; return Men ; }
ll sumPowersK ( ll n , ll k ) { ll sum = 0 , num = 1 ; while ( num <= n ) { sum += num ; num *= k ; } return sum ; }
ll getSum ( ll n , ll k ) { ll pwrK = sumPowersK ( n , k ) ; ll sumAll = ( n * ( n + 1 ) ) / 2 ; return ( sumAll - pwrK ) ; }
int maxPeople ( int p ) { int tmp = 0 , count = 0 ; for ( int i = 1 ; i * i <= p ; i ++ ) { tmp = tmp + ( i * i ) ; if ( tmp <= p ) count ++ ; else break ; } return count ; }
int maxPeople ( int p ) { ll sums [ kN ] ; sums [ 0 ] = 0 ; for ( int i = 1 ; i < kN ; i ++ ) sums [ i ] = ( ll ) ( i * i ) + sums [ i - 1 ] ; auto it = std :: lower_bound ( sums , sums + kN , p ) ; if ( * it > p ) { -- it ; } return ( it - sums ) ; }
long squareSeries ( long n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
long maxPeople ( long n ) { long low = 0 ; long high = 1000000L ; long ans = 0L ; while ( low <= high ) { long mid = low + ( ( high - low ) / 2 ) ; long value = squareSeries ( mid ) ; if ( value <= n ) { ans = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return ans ; }
int getAverage ( int x , int y ) { int avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; }
int getfactor ( int n , int p ) { int pw = 0 ; while ( n ) { n /= p ; pw += n ; } return pw ; }
bool isDivisible ( int n , int r , int p ) { int x1 = getfactor ( n , p ) ; int x2 = getfactor ( r , p ) ; int x3 = getfactor ( n - r , p ) ; if ( x1 > x2 + x3 ) return true ; return false ; }
int findIndex ( int a [ ] , int n , int k ) { int index = -1 , max_ceil = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] + k - 1 ) / k ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= max_ceil ) { max_ceil = a [ i ] ; index = i ; } } return index ; }
int Count_Segment ( int p [ ] , int n ) { int count = 0 ; int upto [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) upto [ i ] = 0 ; int j = 0 , curr = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { if ( p [ i ] > p [ i - 1 ] and p [ i ] > p [ i + 1 ] ) { curr = p [ i ] ; j = i - 1 ; while ( j >= 0 and p [ j ] < curr ) { upto [ p [ j ] ] = curr ; j -= 1 ; } j = i + 1 ; while ( j < n and p [ j ] < curr ) { if ( upto [ curr - p [ j ] ] == curr ) count += 1 ; j += 1 ; } } } return count ; }
void dfs ( int node , int parent ) { int a = __builtin_popcount ( weight [ node ] + x ) ; if ( maximum < a ) { maximum = a ; ans = node ; } else if ( maximum == a ) ans = min ( ans , node ) ; for ( int to : graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; } }
bool solve ( int n , int k ) { if ( n >= ( k * ( k + 1 ) ) / 2 ) { return true ; } return false ; }
void solve ( long long int a , long long int b ) { if ( a > 0 && b > 0 ) { cout << "Positive" ; } else if ( a <= 0 && b >= 0 ) { cout << "Zero" << endl ; } else { long long int n = abs ( a - b ) + 1 ; if ( n % 2 == 0 ) { cout << "Positive" << endl ; } else { cout << "Negative" << endl ; } } }
bool isEven ( int arr [ ] , int n , int r ) { if ( r % 2 == 0 ) { if ( arr [ n - 1 ] % 2 == 0 ) return true ; } else { int oddCount = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount % 2 == 0 ) return true ; } return false ; }
int closetAND ( int arr [ ] , int n , int k ) { int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = min ( ans , abs ( k - X ) ) ; } } return ans ; }
int countQuadruplets ( int l , int r , int k ) { int count = 0 ; for ( int u = l ; u <= r ; u ++ ) { for ( int v = l ; v <= r ; v ++ ) { for ( int w = l ; w <= r ; w ++ ) { for ( int x = l ; x <= r ; x ++ ) { if ( __gcd ( __gcd ( u , v ) , __gcd ( w , x ) ) == k ) count ++ ; } } } } return count ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int count_square ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i = i + 2 ) { int k = n - i + 1 ; count += ( k * k ) ; } return count ; }
float Rate ( int N1 , int N2 ) { float rate = ( N2 - N1 ) * 100 / float ( N1 ) ; return rate ; }
void solve ( int a [ ] , int n ) { int ones = 0 , twos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ones ++ ; else twos ++ ; } int ind = 0 ; if ( twos ) a [ ind ++ ] = 2 ; bool evenOnes = ( ones % 2 == 0 ) ? true : false ; if ( evenOnes ) ones -= 1 ; for ( int i = 0 ; i < ones ; i ++ ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < twos - 1 ; i ++ ) a [ ind ++ ] = 2 ; if ( evenOnes ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << " " ; }
int count_pairs ( int a [ ] , int b [ ] , int n , int m ) { int odd1 = 0 , even1 = 0 ; int odd2 = 0 , even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd1 ++ ; else even1 ++ ; } for ( int i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 == 1 ) odd2 ++ ; else even2 ++ ; } int pairs = min ( odd1 , odd2 ) + min ( even1 , even2 ) ; return pairs ; }
int primeCount ( int arr [ ] , int n ) { int max_val = * max_element ( arr , arr + n ) ; vector < bool > prime ( max_val + 1 , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( prime [ arr [ i ] ] ) count ++ ; return count ; }
void getPrefixArray ( int arr [ ] , int n , int pre [ ] ) { pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } }
int getPrime ( int arr [ ] , int n ) { int max_val = * max_element ( arr , arr + n ) ; vector < bool > prime ( max_val + 1 , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int maximum = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) maximum = max ( maximum , arr [ i ] ) ; } return maximum ; }
void CreateArray ( int N , int even , int odd ) { int temp = -1 ; int OddPreSums ; for ( int i = 0 ; i <= N + 1 ; i ++ ) { if ( i * ( ( N + 1 ) - i ) == odd ) { temp = 0 ; OddPreSums = i ; break ; } } if ( temp == -1 ) { cout << temp << endl ; } else { int EvenPreSums = ( N + 1 ) - OddPreSums ; int e = 1 ; int o = 0 ; int CurrSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( CurrSum % 2 == 0 ) { if ( e < EvenPreSums ) { e ++ ; cout << "0 " ; } else { o ++ ; cout << "1 " ; CurrSum ++ ; } } else { if ( e < EvenPreSums ) { e ++ ; cout << "1 " ; CurrSum ++ ; } else { o ++ ; cout << "0 " ; } } } cout << endl ; } }
int changeTheArray ( int arr [ ] , int n ) { int minEle = * ( std :: min_element ( arr , arr + n ) ) ; int maxEle = * ( std :: max_element ( arr , arr + n ) ) ; int minOperations = INT_MAX ; for ( int num = minEle ; num <= maxEle ; num ++ ) { int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != num ) { operations += ( abs ( num - arr [ i ] ) - 1 ) ; } } minOperations = min ( minOperations , operations ) ; } return minOperations ; }
long getMinNum ( int N ) { int lcm = 1 ; for ( int i = 2 ; i <= N ; i ++ ) lcm = ( ( i * lcm ) / ( __gcd ( i , lcm ) ) ) ; return ( lcm + 1 ) ; }
int maxEdges ( int N ) { int edges = 0 ; edges = floor ( ( N * N ) / 4 ) ; return edges ; }
int findX ( int A , int B ) { int j = 0 , x = 0 ; while ( A B ) { if ( ( A & 1 ) && ( B & 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; }  return x ; }
int findX ( int A , int B ) { return A & B ; }
int findSum ( int A , int B ) { return A ^ B ; }
bool isSumEqual ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += ar [ i ] ; if ( sum == ar [ n - 1 ] ) return true ; return false ; }
int findIndex ( int a [ ] , int n ) { int res ; ll min_diff = INT_MAX ; ll prod [ n ] ; prod [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prod [ i ] = prod [ i - 1 ] * a [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ll curr_diff = abs ( ( prod [ n - 1 ] / prod [ i ] ) - prod [ i ] ) ; if ( curr_diff < min_diff ) { min_diff = curr_diff ; res = i ; } } return res ; }
void Permutation ( int n , int k ) { int p [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( int i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( int i = 1 ; i <= n ; i ++ ) cout << p [ i ] << " " ; }
int perfectSquares ( int a , int b ) { return ( floor ( sqrt ( b ) ) - ceil ( sqrt ( a ) ) + 1 ) ; }
int countOnes ( int arr [ ] , int n ) { return perfectSquares ( 1 , n ) ; }
int validPosition ( int arr [ ] , int N , int K ) { int count = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] + K ) > ( sum - arr [ i ] ) ) count ++ ; } return count ; }
void count_unique ( unordered_set < int > & s , int n ) { if ( s . count ( n ) ) return ; s . insert ( n ) ; n += 1 ; while ( n % 10 == 0 ) { n = n / 10 ; } count_unique ( s , n ) ; }
int countPairs ( int arr [ ] , int n ) { int size = ( 2 * N ) + 1 ; int freq [ size ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x + N ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( freq [ i ] > 0 ) { ans += ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 ; for ( int j = i + 2 ; j < 2001 ; j += 2 ) { if ( freq [ j ] > 0 && ( freq [ ( i + j ) / 2 ] > 0 ) ) { ans += ( freq [ i ] * freq [ j ] ) ; } } } } return ans ; }
int smallestSum ( int n ) { if ( n == 1 ) return 0 ; return ( 2 * pow ( 10 , n - 1 ) ) ; }
int largestSum ( int n ) { return ( 2 * ( pow ( 10 , n ) - 1 ) ) ; }
int count_pairs ( int a [ ] , int b [ ] , int n , int m ) { int odd1 = 0 , even1 = 0 ; int odd2 = 0 , even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 ) odd1 ++ ; else even1 ++ ; } for ( int i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 ) odd2 ++ ; else even2 ++ ; } int pairs = min ( odd1 , even2 ) + min ( odd2 , even1 ) ; return pairs ; }
int find_leftmost_unsetbit ( int n ) { int ind = -1 ; int i = 1 ; while ( n ) { if ( ! ( n & 1 ) ) ind = i ; i ++ ; n >>= 1 ; } return ind ; }
int vertices ( int N , int A , int B ) { int position = 0 ; int minisum = INT_MAX ; int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i == A i == B ) continue ; else { int x = abs ( i - A ) ; int y = abs ( i - B ) ; sum = x + y ; if ( sum < minisum ) { minisum = sum ; position = i ; } } } return position ; }
int factorial ( int n ) { int f = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { f *= i ; } return f ; }
int sumFactorial ( int * arr , int n ) { int s = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { s += factorial ( arr [ i ] ) ; } return s ; }
void dfs ( int child , int par , int color [ ] ) { if ( color [ child ] != color [ par ] ) ans ++ ; for ( auto it : gr [ child ] ) { if ( it == par ) continue ; dfs ( it , child , color ) ; } }
int highestPower ( string str , int len ) { int ans = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) ans ++ ; else break ; } return ans ; }
ll modInverse ( ll n , ll p ) { return power ( n , p - 2 , p ) ; }
ll nCrModP ( ll n , ll r , ll p ) { if ( r == 0 ) return 1 ; ll fac [ n + 1 ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p ; }
ll countArrangements ( ll n , ll k , ll p ) { return ( factorial ( n , p ) * nCrModP ( k , n , p ) ) % p ; }
int maxProd ( int N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return max ( maxProd ( N / 10 ) * ( N % 10 ) , maxProd ( N / 10 - 1 ) * 9 ) ; }
void primeFactors ( int n , int freq [ ] ) { int cnt = 0 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } freq [ 2 ] = cnt ; for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { cnt = 0 ; while ( n % i == 0 ) { cnt ++ ; n = n / i ; } freq [ i ] = cnt ; } if ( n > 2 ) freq [ n ] = 1 ; }
int getMaximumPower ( int n , int m ) { int freq1 [ n + 1 ] , freq2 [ m + 1 ] ; memset ( freq1 , 0 , sizeof freq1 ) ; memset ( freq2 , 0 , sizeof freq2 ) ; primeFactors ( n , freq1 ) ; primeFactors ( m , freq2 ) ; int maxi = 0 ; for ( int i = 2 ; i <= m ; i ++ ) { if ( freq1 [ i ] == 0 && freq2 [ i ] == 0 ) continue ; if ( freq2 [ i ] > freq1 [ i ] ) return 0 ; if ( freq2 [ i ] ) { maxi = max ( maxi , freq1 [ i ] / freq2 [ i ] ) ; } } return maxi ; }
bool check ( int mat [ N ] [ M ] ) { int xorr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { xorr ^= mat [ i ] [ 0 ] ; } if ( xorr != 0 ) return true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] != mat [ i ] [ 0 ] ) return true ; } } return false ; }
int sumodd ( int n ) { return ( n * n ) ; }
int sumeven ( int n ) { return ( n * ( n + 1 ) ) ; }
void radiated_Station ( int station [ ] , int n ) { int rStation [ n + 1 ] ; memset ( rStation , 0 , sizeof ( rStation ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { int li = i - 1 , ri = i + 1 ; int lRad = station [ i ] - 1 , rRad = station [ i ] - 1 ; rStation [ i ] += station [ i ] ; while ( li >= 1 && lRad >= 1 ) { rStation [ li -- ] += lRad -- ; } while ( ri <= n && rRad >= 1 ) { rStation [ ri ++ ] += rRad -- ; } } print ( rStation , n ) ; }
int oddTriangularNumber ( int N ) { return ( N * ( ( 2 * N ) - 1 ) ) ; }
void idstrt ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) cout << "The given straight" << " lines are identical" << endl ; else cout << "The given straight" << " lines are not identical" << endl ; }
double area ( double a , double b , double c ) { double d = fabs ( ( c * c ) / ( 2 * a * b ) ) ; return d ; }
float percent ( int n , int x ) { float p = n * x ; p /= 100 ; return p ; }
float getLoss ( int price [ ] , int quantity [ ] , int X [ ] , int n ) { float loss = 0 ; for ( int i = 0 ; i < n ; i ++ ) { float originalPrice = price [ i ] ; float sellingPrice = originalPrice + percent ( originalPrice , X [ i ] ) ; float afterDiscount = sellingPrice - percent ( sellingPrice , X [ i ] ) ; loss += ( ( originalPrice - afterDiscount ) * quantity [ i ] ) ; } return loss ; }
int maxAbsDiff ( int arr [ ] , int n ) { int minEle = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minEle = min ( minEle , arr [ i ] ) ; maxEle = max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; }
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int maximizeSum ( int a [ ] , int n ) { int cnt = 0 ; int mini = INT_MAX ; int minSubarray = INT_MAX ; int sum = maxSubArraySum ( a , n ) ; int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; cnt ++ ; minSubarray = min ( a [ i ] , minSubarray ) ; if ( sum == max_ending_here ) { if ( cnt == 1 ) mini = min ( mini , 0 ) ; else mini = min ( mini , minSubarray ) ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; cnt = 0 ; minSubarray = INT_MAX ; } } return sum - mini ; }
bool isOsiris ( int n ) { int a = n % 10 ; int b = ( n / 10 ) % 10 ; int c = n / 100 ; int digit_sum = a + b + c ; if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; }
int countTriangles ( int a [ ] , int n ) { int cnt = 0 ; int pairs = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { pairs += a [ i ] / 2 ; if ( a [ i ] % 2 == 1 && pairs > 0 ) { cnt += 1 ; pairs -= 1 ; } } cnt += ( 2 * pairs ) / 3 ; return cnt ; }
int smallestMultiple ( int n ) { if ( n == 1 ) return 5 ; return pow ( 10 , n - 1 ) ; }
static int countAnomalies ( int arr [ ] , int n , int k ) { int cnt = 0 ; int i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( abs ( arr [ i ] - ( sum - arr [ i ] ) ) > k ) cnt ++ ; return cnt ; }
void Divisors ( ) { memset ( cnt , 0 , sizeof cnt ) ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j * i < N ; j ++ ) cnt [ i * j ] ++ ; } }
int Sumofdivisors ( int A , int B , int C ) { int sum = 0 ; Divisors ( ) ; for ( int i = 1 ; i <= A ; i ++ ) { for ( int j = 1 ; j <= B ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { int x = i * j * k ; sum += cnt [ x ] ; if ( sum >= mod ) sum -= mod ; } } } return sum ; }
int getHCF ( int x , int y ) { int minimum = min ( x , y ) ; if ( x % minimum == 0 && y % minimum == 0 ) return minimum ; for ( int i = minimum / 2 ; i >= 2 ; i -- ) { if ( x % i == 0 && y % i == 0 ) return i ; } return 1 ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool isDivisible ( int n ) { if ( isPrime ( n + 1 ) ) return false ; return true ; }
void findDivisors ( int n ) { int div [ n + 1 ] ; memset ( div , 0 , sizeof div ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) cout << div [ i ] << " " ; }
int findMaxCock ( int ar [ R ] [ C ] ) { if ( R < 3 C < 3  ) return -1 ; int max_sum = INT_MIN ; for ( int i = 0 ; i < R - 2 ; i ++ ) { for ( int j = 0 ; j < C - 2 ; j ++ ) { int sum = ( ar [ i ] [ j ] + ar [ i ] [ j + 2 ] ) + ( ar [ i + 1 ] [ j + 1 ] ) + ( ar [ i + 2 ] [ j ] + ar [ i + 2 ] [ j + 1 ] + ar [ i + 2 ] [ j + 2 ] ) ; max_sum = max ( max_sum , sum ) ; } } return max_sum ; }
int segments ( int n , int p [ ] , int m ) { map < int , int > c ; c [ 0 ] = 1 ; bool has = false ; int sum = 0 ; long long ans = 0 ; for ( int r = 0 ; r < n ; r ++ ) { if ( p [ r ] < m ) sum -- ; else if ( p [ r ] > m ) sum ++ ; if ( p [ r ] == m ) has = true ; if ( has ) ans += c [ sum ] + c [ sum - 1 ] ; else c [ sum ] ++ ; } return ans ; }
int findMaximumDiff ( int a [ ] , int n ) { int ind1 = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( a [ 0 ] != a [ i ] ) { ind1 = i ; break ; } } int ind2 = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ n - 1 ] != a [ i ] ) { ind2 = ( n - 1 - i ) ; break ; } } return max ( ind1 , ind2 ) ; }
int decideWinner ( int a [ ] , int n ) { int count0 = 0 ; int count1 = 0 ; int count2 = 0 ; int count3 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; }
int minOperations ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; int maxFreq = INT_MIN ; for ( auto x : mp ) maxFreq = max ( maxFreq , x . second ) ; return ( n - maxFreq ) ; }
void Add_edge ( int u , int v ) { tree [ u ] . push_back ( v ) ; tree [ v ] . push_back ( u ) ; }
void intisalise ( ) { startIdx . resize ( n ) ; endIdx . resize ( n ) ; p . resize ( n ) ; }
void Dfs ( int ch , int par ) { p [ currentIdx ] = ch ; startIdx [ ch ] = currentIdx ++ ; for ( auto c : tree [ ch ] ) { if ( c != par ) Dfs ( c , ch ) ; } endIdx [ ch ] = currentIdx - 1 ; }
int findNode ( int v , int k ) { k += startIdx [ v ] - 1 ; if ( k <= endIdx [ v ] ) return p [ k ] ; return -1 ; }
int CntDivbyX ( int arr [ ] , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = number * 2 + arr [ i ] ; if ( ( number % x == 0 ) ) count += 1 ; } return count ; }
int CntDivbyX ( int arr [ ] , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = ( number * 2 + arr [ i ] ) % x ; if ( number == 0 ) count += 1 ; } return count ; }
int smallestIndex ( int a [ ] , int n ) { int right1 = 0 , right0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return min ( right1 , right0 ) ; }
int A_mod_B ( string N , int a ) { int len = N . size ( ) ; int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) ans = ( ans * 10 + ( int ) N [ i ] - '0' ) % a ; return ans % a ; }
int findMod ( string N ) { int mod = A_mod_B ( N , 4 ) ; int ans = ( 1 + pow ( 2 , mod ) + pow ( 3 , mod ) + pow ( 4 , mod ) ) ; return ( ans % 5 ) ; }
int countCon ( int ar [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; }
void printElements ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) cout << arr [ i ] << " " ; } }
void reduceFraction ( int x , int y ) { int d ; d = __gcd ( x , y ) ; x = x / d ; y = y / d ; cout << "x = " << x << ", y = " << y << endl ; }
void generateSubStrings ( string s , unordered_map < string , int > & mpp ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { string temp = "" ; for ( int j = i ; j < l ; j ++ ) { temp += s [ j ] ; mpp [ temp ] += 1 ; } } }
void binomialCoeff ( int C [ maxlen ] [ maxlen ] ) { int i , j ; for ( i = 0 ; i < 100 ; i ++ ) { for ( j = 0 ; j < 100 ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } }
int answerQuery ( unordered_map < string , int > & mpp , int C [ maxlen ] [ maxlen ] , int k ) { int ans = 0 ; for ( auto it : mpp ) { if ( it . second >= k ) ans += C [ it . second ] [ k ] ; } return ans ; }
int numLen ( int K ) { if ( K % 2 == 0 K % 5 == 0 ) return -1 ; int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = number * 10 + 1 ; if ( ( number % K == 0 ) ) return len ; } return -1 ; }
int numLen ( int K ) { if ( K % 2 == 0 K % 5 == 0 ) return -1 ; int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return -1 ; }
void precomputation ( int arr [ ] , int n ) { for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum1 [ j ] += i ; for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum2 [ j ] += ( sum1 [ j ] - i ) * i ; for ( int i = 1 ; i < max_Element ; i ++ ) sum2 [ i ] /= 2 ; for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) ; for ( int i = 1 ; i < max_Element ; i ++ ) sum3 [ i ] /= 3 ; for ( int i = 0 ; i < n ; i ++ ) cout << sum3 [ arr [ i ] ] << " " ; }
int sum ( int k , int n ) { int sum = pow ( k , n + 1 ) - pow ( k - 1 , n + 1 ) ; return sum ; }
int exponent ( int A , int B ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; long y ; if ( B % 2 == 0 ) { y = exponent ( A , B / 2 ) ; y = ( y * y ) ; } else { y = A ; y = ( y * exponent ( A , B - 1 ) ) ; } return y ; }
int sum ( int k , int n ) { int sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) ; return sum ; }
int freqPairs ( int arr [ ] , int n ) { int max = * ( std :: max_element ( arr , arr + n ) ) ; int freq [ max + 1 ] = { 0 } ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 2 * arr [ i ] ; j <= max ; j += arr [ i ] ) { if ( freq [ j ] >= 1 ) count += freq [ j ] ; } if ( freq [ arr [ i ] ] > 1 ) { count += freq [ arr [ i ] ] - 1 ; freq [ arr [ i ] ] -- ; } } return count ; }
bool is_prime ( int num ) { int count = 0 ; for ( int i = 1 ; i * i <= ( num ) ; i ++ ) { if ( ( num ) % i == 0 ) { if ( i * i != ( num ) ) count += 2 ; else count ++ ; } } if ( count == 2 ) return true ; else return false ; }
string is_divisible ( int n ) { if ( n == 1 ) { return "YES" ; } else { if ( is_prime ( n + 1 ) ) return "NO" ; else return "YES" ; } }
ll power ( ll x , ll y , ll p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
ll findCount ( ll N ) { int count = power ( 2 , N , mod ) ; return count ; }
int msb ( int x ) { int ret = 0 ; while ( ( x >> ( ret + 1 ) ) != 0 ) ret ++ ; return ret ; }
int xorRange ( int l , int r ) { int max_bit = msb ( r ) ; int mul = 2 ; int ans = 0 ; for ( int i = 1 ; i <= max_bit ; i ++ ) { if ( ( l / mul ) * mul == ( r / mul ) * mul ) { if ( ( ( l & ( 1 << i ) ) != 0 ) && ( r - l + 1 ) % 2 == 1 ) ans += mul ; mul *= 2 ; continue ; } bool odd_c = 0 ; if ( ( ( l & ( 1 << i ) ) != 0 ) && l % 2 == 1 ) odd_c = ( odd_c ^ 1 ) ; if ( ( ( r & ( 1 << i ) ) != 0 ) && r % 2 == 0 ) odd_c = ( odd_c ^ 1 ) ; if ( odd_c ) ans += mul ; mul *= 2 ; } int zero_bit_cnt = zero_bit_cnt = ( r - l + 1 ) / 2 ; if ( l % 2 == 1 && r % 2 == 1 ) zero_bit_cnt ++ ; if ( zero_bit_cnt % 2 == 1 ) ans ++ ; return ans ; }
long computeXOR ( const int n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } }
int countNumbers ( int x , int n ) { if ( x > n ) return 0 ; return 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ; }
bool checkfact ( int N , int countprime , int prime ) { int countfact = 0 ; if ( prime == 2 prime == 3 ) countfact ++ ; int divide = prime ; while ( N / divide != 0 ) { countfact += N / divide ; divide = divide * divide ; } if ( countfact >= countprime ) return true ; else return false ; }
bool check ( int N ) { int sumsquares = ( N + 1 ) * ( 2 * N + 1 ) ; int countprime = 0 ; for ( int i = 2 ; i <= sqrt ( sumsquares ) ; i ++ ) { int flag = 0 ; while ( sumsquares % i == 0 ) { flag = 1 ; countprime ++ ; sumsquares /= i ; } if ( flag ) { if ( ! checkfact ( N - 1 , countprime , i ) ) return false ; countprime = 0 ; } } if ( sumsquares != 1 ) if ( ! checkfact ( N - 1 , 1 , sumsquares ) ) return false ; return true ; }
int countNonIncreasing ( int arr [ ] , int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] <= arr [ i ] ) len ++ ; else { cnt += ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len + 1 ) * len ) / 2 ) ; return cnt ; }
int recamanArray ( int arr [ ] , int n ) { unordered_set < int > s ; int recaman [ n ] ; recamanGenerator ( recaman , n ) ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( recaman [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { auto it = s . find ( arr [ i ] ) ; if ( it != s . end ( ) ) s . erase ( it ) ; } return s . size ( ) ; }
ll countSubarrays ( int * arr , int n , int k ) { ll prefix_sum [ MAX ] ; prefix_sum [ 0 ] = 0 ; partial_sum ( arr , arr + n , prefix_sum + 1 ) ; ll sum ; if ( k == 1 ) { sum = 0 ; map < ll , int > m ; for ( int i = n ; i >= 0 ; i -- ) { if ( m . find ( prefix_sum [ i ] + 1 ) != m . end ( ) ) sum += m [ prefix_sum [ i ] + 1 ] ; m [ prefix_sum [ i ] ] ++ ; } return sum ; } if ( k == -1 ) { sum = 0 ; map < ll , int > m ; for ( int i = n ; i >= 0 ; i -- ) { if ( m . find ( prefix_sum [ i ] + 1 ) != m . end ( ) ) sum += m [ prefix_sum [ i ] + 1 ] ; if ( m . find ( prefix_sum [ i ] - 1 ) != m . end ( ) ) sum += m [ prefix_sum [ i ] - 1 ] ; m [ prefix_sum [ i ] ] ++ ; } return sum ; } sum = 0 ; ll b ; map < ll , int > m ; for ( int i = n ; i >= 0 ; i -- ) { b = 1 ; while ( true ) { if ( b > 100000000000000 ) break ; if ( m . find ( prefix_sum [ i ] + b ) != m . end ( ) ) sum += m [ prefix_sum [ i ] + b ] ; b *= k ; } m [ prefix_sum [ i ] ] ++ ; } return sum ; }
int kadaneAlgorithm ( const int * ar , int n ) { int sum = 0 , maxSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ar [ i ] ; if ( sum < 0 ) sum = 0 ; maxSum = max ( maxSum , sum ) ; } return maxSum ; }
int maxFunction ( const int * arr , int n ) { int b [ MAX ] , c [ MAX ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i & 1 ) { b [ i ] = abs ( arr [ i + 1 ] - arr [ i ] ) ; c [ i ] = - b [ i ] ; } else { c [ i ] = abs ( arr [ i + 1 ] - arr [ i ] ) ; b [ i ] = - c [ i ] ; } } int ans = kadaneAlgorithm ( b , n - 1 ) ; ans = max ( ans , kadaneAlgorithm ( c , n - 1 ) ) ; return ans ; }
bool isPerfectSquare ( int arr [ ] , int n ) { unordered_map < int , int > umap ; for ( int i = 0 ; i < n ; i ++ ) umap [ arr [ i ] ] ++ ; unordered_map < int , int > :: iterator itr ; for ( itr = umap . begin ( ) ; itr != umap . end ( ) ; itr ++ ) if ( ( itr -> second ) % 2 == 1 ) return false ; return true ; }
int minimumSteps ( int n , int m , int a , int b ) { if ( n > m ) return MAXN ; if ( n == m ) return 0 ; return min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) ; }
bool isPrime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) return 0 ; } return 1 ; }
int minimumCost ( int n ) { if ( isPrime ( n ) ) return 1 ; if ( n % 2 == 1 && isPrime ( n - 2 ) ) return 2 ; if ( n % 2 == 0 ) return 2 ; return 3 ; }
int fib ( int n ) { double phi = ( 1 + sqrt ( 5 ) ) / 2 ; return round ( pow ( phi , n ) / sqrt ( 5 ) ) ; }
ll calculateSum ( int l , int r ) { ll sum = 0 ; for ( int i = l ; i <= r ; i ++ ) sum += fib ( i ) ; return sum ; }
int fib ( int n ) { double phi = ( 1 + sqrt ( 5 ) ) / 2 ; return round ( pow ( phi , n ) / sqrt ( 5 ) ) ; }
int calculateSum ( int l , int r ) { int sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; }
double wastedWater ( double V , double M , double N ) { double wasted_amt , amt_per_min , time_to_fill ; amt_per_min = M - N ; time_to_fill = V / amt_per_min ; wasted_amt = N * time_to_fill ; return wasted_amt ; }
float sphereSide ( float h , float r ) { if ( h < 0 && r < 0 ) return -1 ; float R = ( ( h * r * sqrt ( 2 ) ) / ( h + sqrt ( 2 ) * r ) ) / 2 ; return R ; }
void Loss ( int SP , int P ) { float loss = 0 ; loss = ( 2 * P * P * SP ) / float ( 100 * 100 - P * P ) ; cout << "Loss = " << loss ; }
int possibleways ( int n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; }
int countSubarrays ( const int * arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { ll product = 1 ; for ( int x = i ; x <= j ; x ++ ) product *= arr [ x ] ; if ( product % K == 0 ) count ++ ; } } return count ; }
void build ( int node , int start , int end , const int * arr , int k ) { if ( start == end ) { tree [ node ] = ( 1LL * arr [ start ] ) % k ; return ; } int mid = ( start + end ) >> 1 ; build ( 2 * node , start , mid , arr , k ) ; build ( 2 * node + 1 , mid + 1 , end , arr , k ) ; tree [ node ] = ( tree [ 2 * node ] * tree [ 2 * node + 1 ] ) % k ; }
ll query ( int node , int start , int end , int l , int r , int k ) { if ( start > end start > r end < l ) { return 1 ; } if ( start >= l && end <= r ) { return tree [ node ] % k ; } int mid = ( start + end ) >> 1 ; ll q1 = query ( 2 * node , start , mid , l , r , k ) ; ll q2 = query ( 2 * node + 1 , mid + 1 , end , l , r , k ) ; return ( q1 * q2 ) % k ; }
ll countSubarrays ( const int * arr , int n , int k ) { ll count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { ll product_mod_k = query ( 1 , 0 , n - 1 , i , j , k ) ; if ( product_mod_k == 0 ) { count ++ ; } } } return count ; }
void printMaxValPair ( vector < long long > & v , int n ) { sort ( v . begin ( ) , v . end ( ) ) ; long long N = v [ n - 1 ] ; if ( N % 2 == 1 ) { long long first_maxima = N / 2 ; long long second_maxima = first_maxima + 1 ; long long ans1 = 3e18 , ans2 = 3e18 ; long long from_left = -1 , from_right = -1 ; long long from = -1 ; for ( long long i = 0 ; i < n ; ++ i ) { if ( v [ i ] > first_maxima ) { from = i ; break ; } else { long long diff = first_maxima - v [ i ] ; if ( diff < ans1 ) { ans1 = diff ; from_left = v [ i ] ; } } } from_right = v [ from ] ; long long diff1 = first_maxima - from_left ; long long diff2 = from_right - second_maxima ; if ( diff1 < diff2 ) cout << N << " " << from_left ; else cout << N << " " << from_right ; } else { long long maxima = N / 2 ; long long ans1 = 3e18 ; long long R = -1 ; for ( long long i = 0 ; i < n - 1 ; ++ i ) { long long diff = abs ( v [ i ] - maxima ) ; if ( diff < ans1 ) { ans1 = diff ; R = v [ i ] ; } } cout << N << " " << R ; } }
int Permutations ( int n , int k ) { int ans = 1 ; if ( k >= 2 ) ans += ( n ) * ( n - 1 ) / 2 ; if ( k >= 3 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * 2 / 6 ; if ( k >= 4 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 / 24 ; return ans ; }
int countIntegers ( ll l , ll r ) { ll ans = 0 , i = 1 ; ll v = power ( 2 , i ) ; while ( v <= r ) { while ( v <= r ) { if ( v >= l ) ans ++ ; v = v * 3 ; } i ++ ; v = power ( 2 , i ) ; } if ( l == 1 ) ans ++ ; return ans ; }
int sumTruncatablePrimes ( int n ) { int sum = 0 ; for ( int i = 2 ; i < n ; i ++ ) { int num = i ; bool flag = true ; while ( num ) { if ( ! prime [ num ] ) { flag = false ; break ; } num /= 10 ; } num = i ; int power = 10 ; while ( num / power ) { if ( ! prime [ num % power ] ) { flag = false ; break ; } power *= 10 ; } if ( flag ) sum += i ; } return sum ; }
void nDigitPerfectSquares ( int n ) { cout << pow ( ceil ( sqrt ( pow ( 10 , n - 1 ) ) ) , 2 ) << " " ; cout << pow ( ceil ( sqrt ( pow ( 10 , n ) ) ) - 1 , 2 ) ; }
int MaxTraceSub ( int mat [ ] [ N ] ) { int max_trace = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int r = i , s = j , trace = 0 ; while ( r < N && s < N ) { trace += mat [ r ] [ s ] ; r ++ ; s ++ ; max_trace = max ( trace , max_trace ) ; } } } return max_trace ; }
int printSum ( int a , int b ) { int res = 0 ; int temp1 = 0 , temp2 = 0 ; while ( a ) { temp1 = temp1 * 10 + ( a % 10 ) ; a /= 10 ; } a = temp1 ; while ( b ) { temp2 = temp2 * 10 + ( b % 10 ) ; b /= 10 ; } b = temp2 ; while ( a ) { int sum = ( a % 10 + b % 10 ) ; if ( sum / 10 == 0 ) res = res * 10 + sum ; else { temp1 = 0 ; while ( sum ) { temp1 = temp1 * 10 + ( sum % 10 ) ; sum /= 10 ; } sum = temp1 ; while ( sum ) { res = res * 10 + ( sum % 10 ) ; sum /= 10 ; } } a /= 10 ; b /= 10 ; } return res ; }
int countDigits ( int a , int b ) { return floor ( log10 ( abs ( a ) ) - log10 ( abs ( b ) ) ) + 1 ; }
int smallestOdd ( int n ) { if ( n == 1 ) return 1 ; return pow ( 10 , n - 1 ) + 1 ; }
int longestSubArray ( int arr [ ] , int n ) { bool isZeroPresent = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; }
int smallestEven ( int n ) { if ( n == 1 ) return 0 ; return pow ( 10 , n - 1 ) ; }
void printBalancedExpression ( int a , int b , int c , int d ) { if ( ( a == d && a ) || ( a == 0 && c == 0 && d == 0 ) ) { for ( int i = 1 ; i <= a ; i ++ ) cout << "((" ; for ( int i = 1 ; i <= c ; i ++ ) cout << ")(" ; for ( int i = 1 ; i <= d ; i ++ ) cout << "))" ; for ( int i = 1 ; i <= b ; i ++ ) cout << "()" ; } else cout << -1 ; }
int maxProfit ( int n , int a , int b , int x , int y ) { int res = x * ( n / a ) ; res += y * ( n / b ) ; res -= min ( x , y ) * ( n / ( ( a * b ) / __gcd ( a , b ) ) ) ; return res ; }
ll factorial ( int f ) { ll fact = 1 ; for ( int i = 2 ; i <= f ; i ++ ) fact *= ( ll ) i ; return fact ; }
int kthOdd ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr [ i ] % 2 ) == 1 ) k -- ; if ( k == 0 ) return arr [ i ] ; } return -1 ; }
int lastFiveDigits ( int n ) { n = ( n / 10000 ) * 10000 + ( ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n / 10 ) % 10 ) * 10 + ( n / 1000 ) % 10 ; int ans = 1 ; for ( int i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } printf ( "%05d" , ans ) ; }
ll power ( ll a , ll n ) { if ( n == 0 ) return 1 ; ll p = power ( a , n / 2 ) % mod ; p = ( p * p ) % mod ; if ( n & 1 ) { p = ( p * a ) % mod ; } return p ; }
ll computeSum ( int * arr , int n ) { sort ( arr , arr + n ) ; ll sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ll maxs = ( power ( 2 , i ) - 1 + mod ) % mod ; maxs = ( maxs * arr [ i ] ) % mod ; ll mins = ( power ( 2 , n - 1 - i ) - 1 + mod ) % mod ; mins = ( mins * arr [ i ] ) % mod ; ll V = ( maxs - mins + mod ) % mod ; sum = ( sum + V ) % mod ; } return sum ; }
int maxValue ( int n ) { if ( n == 1 ) return 0 ; return ( ( n * n / 2 ) - 1 ) ; }
int count ( int n ) { int cnt = 0 ; int p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; }
int countNumbers ( int n ) { return n - n / 2 - n / 3 - n / 5 - n / 7 + n / 6 + n / 10 + n / 14 + n / 15 + n / 21 + n / 35 - n / 30 - n / 42 - n / 70 - n / 105 + n / 210 ; }
ll sum ( int n ) { if ( n == 1 ) return 1 ; else return ( ( ll ) pow ( n , n ) + sum ( n - 1 ) ) ; }
ll power ( ll a , ll n ) { if ( n == 0 ) return 1 ; ll p = power ( a , n / 2 ) % mod ; p = ( p * p ) % mod ; if ( n & 1 ) p = ( p * a ) % mod ; return p ; }
int countPermutations ( int n ) { if ( n == 1 ) { return 0 ; } return ( power ( 2 , n - 1 ) - 2 ) % mod ; }
long long numbers ( int n ) { return ( long long ) ( pow ( 2 , n + 1 ) ) - 2 ; }
int countNumbers ( int n ) { return ( n / 2520 ) ; }
int nthTerm ( int N ) { int nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += pow ( i , i ) ; } return nth ; }
int nthTerm ( int N ) { int nth = 0 ; nth = ( N * N * ( N + 1 ) ) / 2 ; return nth ; }
int kthSmallest ( int n , int k ) { return ( 2 * k ) ; }
bool isSumOfPowersOfTwo ( int n ) { if ( n % 2 == 1 ) return false ; else return true ; }
void sieve_modified ( ) { for ( int i = 1 ; i < MAX ; i += 2 ) { for ( int j = i ; j < MAX ; j += i ) prefix [ j ] += i ; } for ( int i = 1 ; i < MAX ; i ++ ) prefix [ i ] += prefix [ i - 1 ] ; }
ll sumOddFactors ( int L , int R ) { return ( prefix [ R ] - prefix [ L - 1 ] ) ; }
void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } }
void getFactorization ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 ) { hash1 [ spf [ x ] ] ++ ; x = x / spf [ x ] ; } while ( x % temp == 0 ) x = x / temp ; } }
bool check ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 && hash1 [ temp ] > 1 ) return false ; while ( x % temp == 0 ) x = x / temp ; } return true ; }
bool hasValidNum ( int arr [ ] , int n ) { sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) getFactorization ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( check ( arr [ i ] ) ) return true ; return false ; }
int findMinRemoval ( int arr [ ] , int n ) { int temp , value = 0 ; int maximum = 0 ; if ( n == 1 ) return 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != 0 && i != n - 1 ) { value = value + abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = abs ( arr [ i ] - arr [ i + 1 ] ) + abs ( arr [ i ] - arr [ i - 1 ] ) - abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; } else if ( i == 0 ) { value = value + abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = abs ( arr [ i ] - arr [ i + 1 ] ) ; } else temp = abs ( arr [ i ] - arr [ i - 1 ] ) ; maximum = max ( maximum , temp ) ; } return ( value - maximum ) ; }
int countQuadruples ( int a [ ] , int n ) { unordered_map < int , int > mpp ; for ( int i = 0 ; i < n ; i ++ ) mpp [ a [ i ] ] ++ ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( j == k ) continue ; mpp [ a [ j ] ] -- ; mpp [ a [ k ] ] -- ; int first = a [ j ] - ( a [ k ] - a [ j ] ) ; int fourth = ( a [ k ] * a [ k ] ) / a [ j ] ; if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) { if ( a [ j ] != a [ k ] ) count += mpp [ first ] * mpp [ fourth ] ; else count += mpp [ first ] * ( mpp [ fourth ] - 1 ) ; } mpp [ a [ j ] ] ++ ; mpp [ a [ k ] ] ++ ; } } return count ; }
double getTime ( int u , int v , int x ) { double speed = u + v ; double time = x / speed ; return time ; }
int number_of_teams ( int M ) { int N1 , N2 , sqr ; sqr = sqrt ( 1 + ( 8 * M ) ) ; N1 = ( 1 + sqr ) / 2 ; N2 = ( 1 - sqr ) / 2 ; if ( N1 > 0 ) return N1 ; return N2 ; }
long long power ( long x , long y ) { long p = mod ; long res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
long long solve ( int n , int k ) { if ( n == 1 ) return 0LL ; return ( power ( ( k - 1 ) , n - 1 ) % mod - solve ( n - 1 , k ) + mod ) % mod ; }
int findMinimum ( int x , int y ) { int low = 0 , high = y ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; }
int LucasSum ( int N ) { int sum = 0 ; int a = 2 , b = 1 , c ; sum += a ; while ( b <= N ) { sum += b ; int c = a + b ; a = b ; b = c ; } return sum ; }
int sumOfDigits ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = x / 10 ; } return sum ; }
int countNumbers ( int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( i % 2 == 0 && sumOfDigits ( i ) % 3 == 0 ) count ++ ; } return count ; }
int countNumbers ( int l , int r ) { return ( ( r / 6 ) - ( l - 1 ) / 6 ) ; }
int countNumbers ( int L , int R , int K ) { if ( K == 9 ) K = 0 ; int totalnumbers = R - L + 1 ; int factor9 = totalnumbers / 9 ; int rem = totalnumbers % 9 ; int ans = factor9 ; for ( int i = R ; i > R - rem ; i -- ) { int rem1 = i % 9 ; if ( rem1 == K ) ans ++ ; } return ans ; }
int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return pow ( 2 , E - 1 ) ; }
void BalanceArray ( vector < int > & A , vector < vector < int > > & Q ) { vector < int > ANS ; int i , sum = 0 ; for ( i = 0 ; i < A . size ( ) ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . size ( ) ; i ++ ) { int index = Q [ i ] [ 0 ] ; int value = Q [ i ] [ 1 ] ; if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ; if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ; ANS . push_back ( sum ) ; } for ( i = 0 ; i < ANS . size ( ) ; i ++ ) cout << ANS [ i ] << " " ; }
int findMinSum ( int arr [ ] , int n ) { int occ = n - 1 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * pow ( 2 , occ ) ; occ -- ; } return sum ; }
int findPowerOfP ( int N , int p ) { int count = 0 ; int r = p ; while ( r <= N ) { count += ( N / r ) ; r = r * p ; } return count ; }
vector < pair < int , int > > primeFactorsofB ( int B ) { vector < pair < int , int > > ans ; for ( int i = 2 ; B != 1 ; i ++ ) { if ( B % i == 0 ) { int count = 0 ; while ( B % i == 0 ) { B = B / i ; count ++ ; } ans . push_back ( make_pair ( i , count ) ) ; } } return ans ; }
int largestPowerOfB ( int N , int B ) { vector < pair < int , int > > vec ; vec = primeFactorsofB ( B ) ; int ans = INT_MAX ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) ans = min ( ans , findPowerOfP ( N , vec [ i ] . first ) / vec [ i ] . second ) ; return ans ; }
int maxLenSubArr ( int a [ ] , int n ) { int count , j ; int cm = 1 , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max ) max = a [ i ] ; } for ( int i = 0 ; i < n - 1 ; ) { count = 1 ; if ( a [ i ] == a [ i + 1 ] && a [ i ] == max ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] == max ) { count ++ ; i ++ ; } else break ; } if ( count > cm ) cm = count ; } else i ++ ; } return cm ; }
ll minSum ( int arr [ ] , int n , int x ) { ll sum = 0 ; int largestDivisible = -1 , minimum = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == -1 ) return sum ; ll sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return min ( sum , sumAfterOperation ) ; }
int parity ( int a ) { return a % 3 ; }
int solve ( int array [ ] , int size ) { int operations = 0 ; for ( int i = 0 ; i < size - 1 ; i ++ ) { if ( parity ( array [ i ] ) == parity ( array [ i + 1 ] ) ) { operations ++ ; if ( i + 2 < size ) { int pari1 = parity ( array [ i ] ) ; int pari2 = parity ( array [ i + 2 ] ) ; if ( pari1 == pari2 ) { if ( pari1 == 0 ) array [ i + 1 ] = 1 ; else if ( pari1 == 1 ) array [ i + 1 ] = 0 ; else array [ i + 1 ] = 1 ; } else { if ( ( pari1 == 0 && pari2 == 1 ) || ( pari1 == 1 && pari2 == 0 ) ) array [ i + 1 ] = 2 ; if ( ( pari1 == 1 && pari2 == 2 ) || ( pari1 == 2 && pari2 == 1 ) ) array [ i + 1 ] = 0 ; if ( ( pari1 == 2 && pari2 == 0 ) || ( pari1 == 0 && pari2 == 2 ) ) array [ i + 1 ] = 1 ; } } } } return operations ; }
int findDigitalRoot ( int num ) { int sum = INT_MAX , tempNum = num ; while ( sum >= 10 ) { sum = 0 ; while ( tempNum > 0 ) { sum += tempNum % 10 ; tempNum /= 10 ; } tempNum = sum ; } return sum ; }
void findAnswer ( int X , int N ) { int counter = 0 ; for ( int i = 1 ; counter < N ; ++ i ) { int digitalRoot = findDigitalRoot ( i ) ; if ( digitalRoot == X ) { ++ counter ; } if ( counter == N ) { cout << i ; break ; } } }
int findAnswer ( int X , int N ) { return ( N - 1 ) * 9 + X ; }
void preComputeXor ( int arr [ ] [ n ] , int prefix_xor [ ] [ n ] ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { if ( j == 0 ) prefix_xor [ i ] [ j ] = arr [ i ] [ j ] ; else prefix_xor [ i ] [ j ] = ( prefix_xor [ i ] [ j - 1 ] ^ arr [ i ] [ j ] ) ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) prefix_xor [ j ] [ i ] = ( prefix_xor [ j - 1 ] [ i ] ^ prefix_xor [ j ] [ i ] ) ; }
int ansQuerie ( int prefix_xor [ ] [ n ] , int x1 , int y1 , int x2 , int y2 ) { int xor_1 = 0 , xor_2 = 0 , xor_3 = 0 ; if ( x1 != 0 ) xor_1 = prefix_xor [ x1 - 1 ] [ y2 ] ; if ( y1 != 0 ) xor_2 = prefix_xor [ x2 ] [ y1 - 1 ] ; if ( x1 != 0 and y1 != 0 ) xor_3 = prefix_xor [ x1 - 1 ] [ y1 - 1 ] ; return ( ( prefix_xor [ x2 ] [ y2 ] ^ xor_1 ) ^ ( xor_2 ^ xor_3 ) ) ; }
int LucasSequence ( int arr [ ] , int n ) { int max = * max_element ( arr , arr + n ) ; unordered_set < int > s ; int a = 2 , b = 1 , c ; s . insert ( a ) ; s . insert ( b ) ; while ( b < max ) { int c = a + b ; a = b ; b = c ; s . insert ( b ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { auto it = s . find ( arr [ i ] ) ; if ( it != s . end ( ) ) count ++ ; } return count ; }
int matrixSum ( int arr [ ] [ n ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i ] [ j ] ) ; } return sum ; }
int maxAND ( int L , int R ) { int maximum = L & R ; for ( int i = L ; i < R ; i ++ ) for ( int j = i + 1 ; j <= R ; j ++ ) maximum = max ( maximum , ( i & j ) ) ; return maximum ; }
int maxAND ( int L , int R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } }
bool checkArray ( int arr [ ] , int n ) { return ( arr [ 0 ] % 2 ) && ( arr [ n - 1 ] % 2 ) && ( n % 2 ) ; }
int findCount ( int arr [ ] , int n ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; }
bool isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; }
int Prime_Numbers ( int n ) { vector < int > primes = SieveOfEratosthenes ( ) ; for ( int i = 0 ; i < ( int ) ( primes . size ( ) ) - 1 ; i ++ ) if ( primes [ i ] + primes [ i + 1 ] + 1 < N ) can [ primes [ i ] + primes [ i + 1 ] + 1 ] = true ; int ans = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( can [ i ] and isprime [ i ] ) { ans ++ ; } } return ans ; }
void printPermutation ( int n , int k ) { for ( int i = 1 ; i <= n ; i ++ ) { int x = 2 * i - 1 ; int y = 2 * i ; if ( i <= k ) cout << y << " " << x << " " ; else cout << x << " " << y << " " ; } }
bool isPossible ( int Sx , int Sy , int Dx , int Dy , int x , int y ) { if ( abs ( Sx - Dx ) % x == 0 and abs ( Sy - Dy ) % y == 0 and ( abs ( Sx - Dx ) / x ) % 2 == ( abs ( Sy - Dy ) / y ) % 2 ) return true ; return false ; }
int getPairs ( int a [ ] ) { int n = sizeof ( a [ 0 ] ) ; int count = ( n * ( n - 1 ) ) / 2 ; return count ; }
bool isDigitSumOne ( int nm ) { if ( nm % 9 == 1 ) return true ; else return false ; }
void printValidNums ( int n ) { int cbrt_n = ( int ) cbrt ( n ) ; for ( int i = 1 ; i <= cbrt_n ; i ++ ) { int cube = pow ( i , 3 ) ; if ( cube >= 1 && cube <= n && isDigitSumOne ( cube ) ) cout << cube << " " ; } }
bool isDigitSumOne ( int nm ) { while ( nm > 9 ) { int sum_digit = 0 ; while ( nm > 0 ) { int digit = nm % 10 ; sum_digit = sum_digit + digit ; nm = nm / 10 ; } nm = sum_digit ; } if ( nm == 1 ) return true ; else return false ; }
void printValidNums ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { if ( isComposite ( i ) && isDigitSumOne ( i ) ) cout << i << " " ; } }
void initialize ( ) { l [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 1001 ; i ++ ) { l [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i + 1 ; j ++ ) { l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) ; } } }
int nCr ( int n , int r ) { return l [ n ] [ r ] ; }
long long countRhombi ( int h , int w ) { long long ct = 0 ; for ( int i = 2 ; i <= h ; i += 2 ) for ( int j = 2 ; j <= w ; j += 2 ) ct += ( h - i + 1 ) * ( w - j + 1 ) ; return ct ; }
ll maxSum ( int N ) { ll ans = 0 ; for ( int u = 1 ; u <= N ; u ++ ) { for ( int v = 1 ; v <= N ; v ++ ) { if ( u == v ) continue ; int degreeU = 2 ; if ( u == 1 u == N ) degreeU = 1 ; int degreeV = 2 ; if ( v == 1 v == N ) degreeV = 1 ; ans += ( degreeU * degreeV ) ; } } return ans ; }
int countSquares ( int row , int column ) { int topLeft = min ( row , column ) - 1 ; int bottomRight = 8 - max ( row , column ) ; int topRight = min ( row , 9 - column ) - 1 ; int bottomLeft = 8 - max ( row , 9 - column ) ; return ( topLeft + topRight + bottomRight + bottomLeft ) ; }
void cal_factorial ( ) { arr [ 0 ] = 1 ; for ( int i = 1 ; i <= 1000000 ; i ++ ) { arr [ i ] = ( arr [ i - 1 ] * i ) % mod ; } }
ll mod_exponent ( ll num , ll p ) { if ( p == 0 ) return 1 ; if ( p & 1 ) { return ( ( num % mod ) * ( mod_exponent ( ( num * num ) % mod , p / 2 ) ) % mod ) % mod ; } else if ( ! ( p & 1 ) ) return ( mod_exponent ( ( num * num ) % mod , p / 2 ) ) % mod ; }
ll getCount ( ll x , ll y ) { ll ans = arr [ x + y - 1 ] ; ans *= mod_exponent ( arr [ x ] , mod - 2 ) ; ans %= mod ; ans *= mod_exponent ( arr [ y ] , mod - 2 ) ; ans %= mod ; ans *= ( x - y ) ; ans %= mod ; return ans ; }
double calculateArea ( int x , int y ) { double pi = 3.1415926536 ; double arx = pi * x * x ; double ary = pi * y * y ; return arx - ary ; }
void findValues ( int a , int b ) { if ( ( a - b ) % 2 == 1 ) { cout << "-1" ; return ; } cout << ( a - b ) / 2 << " " << ( a + b ) / 2 ; }
int minValue ( int n , int x , int y ) { float val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( ceil ( val ) - x ) ; }
int countTriplets ( int n , vector < pair < int , int > > points ) { set < pair < int , int > > pts ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) pts . insert ( points [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { int x = points [ i ] . first + points [ j ] . first ; int y = points [ i ] . second + points [ j ] . second ; if ( x % 2 == 0 && y % 2 == 0 ) if ( pts . find ( make_pair ( x / 2 , y / 2 ) ) != pts . end ( ) ) ct ++ ; } return ct ; }
char getWinner ( int arr [ ] , int n ) { int gcd = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { gcd = __gcd ( gcd , arr [ i ] ) ; maxEle = max ( maxEle , arr [ i ] ) ; } int totalMoves = ( maxEle / gcd ) - n ; if ( totalMoves % 2 == 1 ) return 'A' ; return 'B' ; }
void maximumFactor ( vector < int > arr ) { int n = arr . size ( ) ; vector < int > rank ; vector < int > factors ; int max = * max_element ( arr . begin ( ) , arr . end ( ) ) ; for ( int i = 2 ; i <= max ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] % i == 0 ) count += 1 ; rank . push_back ( count ) ; factors . push_back ( i ) ; } } int m = * max_element ( rank . begin ( ) , rank . end ( ) ) ; for ( int i = 0 ; i < rank . size ( ) ; i ++ ) { if ( rank [ i ] == m ) cout << factors [ i ] << " " ; } }
int digitSum ( int n ) { int ans = 0 ; while ( n ) { ans += n % 10 ; n /= 10 ; } return ans ; }
int findInt ( int n , int m ) { int minDigit = floor ( m / 9 ) ; int start = pow ( 10 , minDigit ) - ( int ) pow ( 10 , minDigit ) % n ; while ( start < INT_MAX ) { if ( digitSum ( start ) == m ) return start ; else start += n ; } return -1 ; }
int smallestDivisor ( int n ) { int mx = sqrt ( n ) ; for ( int i = 2 ; i <= mx ; i ++ ) if ( n % i == 0 ) return i ; return n ; }
int maxSum ( int n ) { long long res = n ; while ( n > 1 ) { int divi = smallestDivisor ( n ) ; n /= divi ; res += n ; } return res ; }
ll power ( ll x , ll y ) { ll ans = 1 ; while ( y ) { if ( y & 1 ) ans = ( ans * x ) % MOD ; y >>= 1 ; x = ( x * x ) % MOD ; } return ans % MOD ; }
int modInverse ( int x ) { return power ( x , MOD - 2 ) ; }
ll countNumbers ( int n , int a , int b ) { ll fact [ MAX ] , inv [ MAX ] ; ll ans = 0 ; fact [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) { fact [ i ] = ( 1LL * fact [ i - 1 ] * i ) ; fact [ i ] %= MOD ; } inv [ MAX - 1 ] = modInverse ( fact [ MAX - 1 ] ) ; for ( int i = MAX - 2 ; i >= 0 ; i -- ) { inv [ i ] = ( inv [ i + 1 ] * ( i + 1 ) ) ; inv [ i ] %= MOD ; } if ( a < b ) swap ( a , b ) ; for ( int s = n ; s <= 9 * n ; s ++ ) { if ( ! check ( s , a , b ) ) continue ; if ( s < n * b || ( s - n * b ) % ( a - b ) != 0 ) continue ; int numDig = ( s - n * b ) / ( a - b ) ; if ( numDig > n ) continue ; ll curr = fact [ n ] ; curr = ( curr * inv [ numDig ] ) % MOD ; curr = ( curr * inv [ n - numDig ] ) % MOD ; ans = ( ans + curr ) % MOD ; } return ans ; }
int countOddSquares ( int n , int m ) { return ( int ) pow ( m , 0.5 ) - ( int ) pow ( n - 1 , 0.5 ) ; }
int Square ( int row , int column , int moves ) { int a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; }
int findNumber ( int n , int m ) { int num = ( m - 1 ) * 9 + n ; return num ; }
int count ( Node * root ) { if ( root == NULL ) return 0 ; return count ( root -> left ) + count ( root -> right ) + 1 ; }
bool checkRec ( Node * root , int n ) { if ( root == NULL ) return false ; if ( count ( root ) == n - count ( root ) ) return true ; return checkRec ( root -> left , n ) || checkRec ( root -> right , n ) ; }
bool check ( Node * root ) { int n = count ( root ) ; return checkRec ( root , n ) ; }
int maxResult ( int n , int a , int b , int c ) { int maxVal = 0 ; for ( int i = 0 ; i <= n ; i += a ) { for ( int j = 0 ; j <= n - i ; j += b ) { float z = ( float ) ( n - ( i + j ) ) / ( float ) ( c ) ; if ( floor ( z ) == ceil ( z ) ) { int x = i / a ; int y = j / b ; maxVal = max ( maxVal , x + y + ( int ) z ) ; } } } return maxVal ; }
long long digitsCount ( long long n ) { int len = 0 ; while ( n > 0 ) { len ++ ; n /= 10 ; } return len ; }
long long absoluteFirstLast ( long long n , int x ) { int i = 0 , mod = 1 ; while ( i < x ) { mod *= 10 ; i ++ ; } int last = n % mod ; long long len = digitsCount ( n ) ; while ( len != x ) { n /= 10 ; len -- ; } int first = n ; return abs ( first - last ) ; }
bool EqualNumbers ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( a [ i ] % 2 == 0 ) a [ i ] /= 2 ; while ( a [ i ] % 3 == 0 ) a [ i ] /= 3 ; if ( a [ i ] != a [ 0 ] ) { return false ; } } return true ; }
void make_sequence ( int N ) { int arr [ N + 1 ] , sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) arr [ i ] = 1 ; else arr [ i ] = 2 ; sum += arr [ i ] ; } if ( sum % 2 == 1 ) arr [ 2 ] = 3 ; for ( int i = 1 ; i <= N ; i ++ ) cout << arr [ i ] << " " ; }
int countOdd ( int L , int R ) { int N = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) N += 1 ; return N ; }
int getMinCost ( int n , int m ) { int cost = ( n - 1 ) * m + ( m - 1 ) * n ; return cost ; }
void minOperation ( int n , int k , int a [ ] ) { for ( int i = k ; i < n ; i ++ ) { if ( a [ i ] != a [ k - 1 ] ) cout << ( -1 ) << endl ; } for ( int i = k - 2 ; i > -1 ; i -- ) { if ( a [ i ] != a [ k - 1 ] ) cout << ( i + 1 ) << endl ; } }
bool digitWell ( int n , int m , int k ) { int cnt = 0 ; while ( n > 0 ) { if ( n % 10 == m ) ++ cnt ; n /= 10 ; } return cnt == k ; }
int findInt ( int n , int m , int k ) { int i = n + 1 ; while ( true ) { if ( digitWell ( i , m , k ) ) return i ; i ++ ; } }
int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 mod == 3 ) return 0 ; return 1 ; }
void generateSequence ( int n , int g ) { for ( int i = 1 ; i <= n ; i ++ ) cout << i * g << " " ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findLCMFibonacci ( int a , int b ) { return ( fib ( a ) * fib ( b ) ) / fib ( gcd ( a , b ) ) ; }
int getMinNum ( int a , int b , int c ) { if ( c < a c > b ) return c ; int x = ( ( b / c ) * c ) + c  ; return x ; }
string isEvenOrOdd ( int L , int R ) { int oddCount = ( R - L ) / 2 ; if ( R % 2 == 1 L % 2 == 1 ) oddCount ++ ; if ( oddCount % 2 == 0 ) return "Even" ; else return "Odd" ; }
int trailing_zeros ( int N ) { int count_of_two = 0 , count_of_five = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int val = i ; while ( val % 2 == 0 && val > 0 ) { val /= 2 ; count_of_two += i ; } while ( val % 5 == 0 && val > 0 ) { val /= 5 ; count_of_five += i ; } } int ans = min ( count_of_two , count_of_five ) ; return ans ; }
void SieveOfEratosthenes ( int n ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { b [ j ++ ] = p ; } } }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void Sieve ( ) { for ( int i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = 2 * i ; j < MAX ; j += i ) { prime [ j ] = 1 ; } } } }
int countPairs ( int n ) { int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int val = ( ( n % i ) % j ) % n ; if ( val == max ) count ++ ; } } return count ; }
int countPairs ( int n ) { if ( n == 2 ) return 4 ; int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = n - max ; return count ; }
int countOdd ( int arr [ ] , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; } return odd ; }
int countValidPairs ( int arr [ ] , int n ) { int odd = countOdd ( arr , n ) ; return ( odd * ( odd - 1 ) ) / 2 ; }
int getMultiple ( string s ) { for ( int i = 0 ; i < 1e3 ; i += 8 ) { if ( checkSub ( to_string ( i ) , s ) ) return i ; } return -1 ; }
void alter ( long long int x , long long int y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } cout << "X=" << x << ", " << "Y=" << y ; }
int digitProduct ( int n ) { int prod = 1 ; while ( n ) { prod = prod * ( n % 10 ) ; n = n / 10 ; } return prod ; }
void printMultiplicativePrimes ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] && prime [ digitProduct ( i ) ] ) cout << i << " " ; } }
ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
bool coPrime ( ll n1 , ll n2 ) { if ( gcd ( n1 , n2 ) == 1 ) return true ; else return false ; }
ll largestCoprime ( ll N ) { ll half = floor ( N / 2 ) ; while ( coPrime ( N , half ) == false ) half -- ; return half ; }
long long largestCoprime ( long long N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; }
void sieve ( int maxEle , int prime [ ] ) { prime [ 0 ] = prime [ 1 ] = 1 ; for ( int i = 2 ; i * i <= maxEle ; i ++ ) { if ( ! prime [ i ] ) { for ( int j = 2 * i ; j <= maxEle ; j += i ) prime [ j ] = 1 ; } } }
int digitSum ( int n ) { int sum = 0 ; while ( n ) { sum += n % 10 ; n = n / 10 ; } return sum ; }
void printAdditivePrime ( int arr [ ] , int n ) { int maxEle = * max_element ( arr , arr + n ) ; int prime [ maxEle + 1 ] ; memset ( prime , 0 , sizeof ( prime ) ) ; sieve ( maxEle , prime ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == 0 ) { int sum = digitSum ( arr [ i ] ) ; if ( prime [ sum ] == 0 ) cout << arr [ i ] << " " ; } } }
void printSafePrimes ( int n ) { int prime [ n + 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) prime [ i ] = 1 ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == 1 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = 0 ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] != 0 ) { int temp = ( 2 * i ) + 1 ; if ( temp <= n && prime [ temp ] != 0 ) prime [ temp ] = 2 ; } } for ( int i = 5 ; i <= n ; i ++ ) if ( prime [ i ] == 2 ) cout << i << " " ; }
double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }
float sum ( float n ) { if ( n < 2 ) return 1 ; else return 1 / n + ( sum ( n - 1 ) ) ; }
double findSum ( int m , int n , int mth , int nth , int p ) { pair < double , double > ad ; ad = findingValues ( m , n , mth , nth ) ; double a = ad . first , d = ad . second ; double sum = ( p * ( 2 * a + ( p - 1 ) * d ) ) / 2 ; return sum ; }
set < int > ABUNDANT ( ) { set < int > v ; for ( int i = 1 ; i < N ; i ++ ) { int sum = 1 ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { sum += j ; if ( i / j != j ) sum += i / j ; } } if ( sum > i ) v . insert ( i ) ; } return v ; }
void SumOfAbundant ( int n ) { set < int > v = ABUNDANT ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( v . count ( i ) and v . count ( n - i ) ) { cout << i << " " << n - i ; return ; } } cout << -1 ; }
int nthTermOfTheSeries ( int n ) { int nthTerm ; if ( n % 2 == 0 ) nthTerm = pow ( n - 1 , 2 ) + n ; else nthTerm = pow ( n + 1 , 2 ) + n ; return nthTerm ; }
vector < int > Divisors ( int x ) { int c = 0 ; vector < int > v ; while ( x % 2 == 0 ) { c ++ ; x /= 2 ; } v . push_back ( c ) ; c = 0 ; while ( x % 3 == 0 ) { c ++ ; x /= 3 ; } v . push_back ( c ) ; c = 0 ; while ( x % 7 == 0 ) { c ++ ; x /= 7 ; } v . push_back ( c ) ; v . push_back ( x ) ; return v ; }
int MinOperations ( int a , int b ) { vector < int > va = Divisors ( a ) ; vector < int > vb = Divisors ( b ) ; if ( va [ 3 ] != vb [ 3 ] ) return -1 ; int minOperations = abs ( va [ 0 ] - vb [ 0 ] ) + abs ( va [ 1 ] - vb [ 1 ] ) + abs ( va [ 2 ] - vb [ 2 ] ) ; return minOperations ; }
ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
ll lcmOfArray ( int arr [ ] , int n ) { if ( n < 1 ) return 0 ; ll lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ; return lcm ; }
void candies ( int n , int k ) { int count = 0 ; int ind = 1 ; int arr [ k ] ; memset ( arr , 0 , sizeof ( arr ) ) ; int low = 0 , high = n ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; int sum = ( mid * ( mid + 1 ) ) >> 1 ; if ( sum <= n ) { count = mid / k ; low = mid + 1 ; } else { high = mid - 1 ; } } int last = ( count * k ) ; n -= ( last * ( last + 1 ) ) / 2 ; int i = 0 ; int term = ( count * k ) + 1 ; while ( n ) { if ( term <= n ) { arr [ i ++ ] = term ; n -= term ; term ++ ; } else { arr [ i ] += n ; n = 0 ; } } for ( int i = 0 ; i < k ; i ++ ) arr [ i ] += ( count * ( i + 1 ) ) + ( k * ( count * ( count - 1 ) ) / 2 ) ; for ( int i = 0 ; i < k ; i ++ ) cout << arr [ i ] << " " ; }
float CPwithLoss ( int sellingPrice , int loss ) { float costPrice ; costPrice = ( sellingPrice * 100.0 ) / ( 100 - loss ) ; return costPrice ; }
void printArr ( float arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
void replaceMax ( float arr [ ] , int n ) { float max = * std :: max_element ( arr , arr + n ) ; float min = * std :: min_element ( arr , arr + n ) ; float range = max - min ; float coeffOfRange = range / ( max + min ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max ) { arr [ i ] = coeffOfRange ; break ; } } printArr ( arr , n ) ; }
int largestOddDigit ( int n ) { int maxOdd = -1 ; while ( n > 0 ) { int digit = n % 10 ; if ( digit % 2 == 1 && digit > maxOdd ) maxOdd = digit ; n = n / 10 ; } return maxOdd ; }
int getProduct ( int n ) { int maxOdd = largestOddDigit ( n ) ; if ( maxOdd == -1 ) return -1 ; return ( n * maxOdd ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void commDiv ( int a , int b ) { int n = gcd ( a , b ) ; a = a / n ; b = b / n ; cout << "A = " << a << ", B = " << b << endl ; }
int minAbsDiff ( int n ) { int left = 1 << ( ( int ) floor ( log2 ( n ) ) ) ; int right = left * 2 ; return min ( ( n - left ) , ( right - n ) ) ; }
void FindAllElements ( int n , int k ) { int sum = k ; int A [ k ] ; fill ( A , A + k , 1 ) ; for ( int i = k - 1 ; i >= 0 ; -- i ) { while ( sum + A [ i ] <= n ) { sum += A [ i ] ; A [ i ] *= 2 ; } } if ( sum != n ) { cout << "Impossible" ; } else { for ( int i = 0 ; i < k ; ++ i ) cout << A [ i ] << ' ' ; } }
bool isEqual ( int a , int b ) { if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) return true ; return false ; }
bool isPerfectSquare ( int x ) { long long left = 1 , right = x ; while ( left <= right ) { long long mid = ( left + right ) / 2 ; if ( mid * mid == x ) { return true ; } if ( mid * mid < x ) { left = mid + 1 ; } else { right = mid - 1 ; } } return false ; }
static bool isStrongPrime ( int n ) { if ( ! isPrime ( n ) n == 2 ) return false ; int previous_prime = n - 1 ; int next_prime = n + 1 ; while ( ! isPrime ( next_prime ) ) next_prime ++ ; while ( ! isPrime ( previous_prime ) ) previous_prime -- ; int mean = ( previous_prime + next_prime ) / 2 ; if ( n > mean ) return true ; else return false ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool isFactorialPrime ( long n ) { if ( ! isPrime ( n ) ) return false ; long fact = 1 ; int i = 1 ; while ( fact <= n + 1 ) { fact = fact * i ; if ( n + 1 == fact n - 1 == fact ) return true ; i ++ ; } return false ; }
void sumArray ( int arr [ ] , int n ) { int leftSum [ n ] , rightSum [ n ] , Sum [ n ] , i , j ; leftSum [ 0 ] = 0 ; rightSum [ n - 1 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ; for ( i = 0 ; i < n ; i ++ ) cout << Sum [ i ] << " " ; }
ll LcmSum ( int m ) { ETF ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j += i ) { ans [ j ] += ( i * phi [ i ] ) ; } } ll answer = ans [ m ] ; answer = ( answer + 1 ) * m ; answer = answer / 2 ; return answer ; }
int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; }
int ncr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; }
int countWays ( string str ) { int freq [ 26 ] = { 0 } ; int nvowels = 0 , nconsonants = 0 ; int vplaces , cways , vways ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) ++ freq [ str [ i ] - 'a' ] ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) nvowels += freq [ i ] ; else nconsonants += freq [ i ] ; } vplaces = nconsonants + 1 ; cways = factorial ( nconsonants ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i != 0 && i != 4 && i != 8 && i != 14 && i != 20 && freq [ i ] > 1 ) { cways = cways / factorial ( freq [ i ] ) ; } } vways = ncr ( vplaces , nvowels ) * factorial ( nvowels ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 && freq [ i ] > 1 ) { vways = vways / factorial ( freq [ i ] ) ; } } return cways * vways ; }
int setBits ( int n ) { int count = 0 ; while ( n ) { n = n & ( n - 1 ) ; count ++ ; } return count ; }
int countPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int setbits_x = setBits ( a [ i ] ) ; for ( int j = i + 1 ; j < n ; j ++ ) { int setbits_y = setBits ( a [ j ] ) ; int setbits_xor_xy = setBits ( a [ i ] ^ a [ j ] ) ; if ( setbits_x + setbits_y == setbits_xor_xy ) count ++ ; } } return count ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findPossibleDerivables ( int arr [ ] , int n , int D , int A , int B ) { int gcdAB = gcd ( A , B ) ; int counter = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( abs ( arr [ i ] - D ) % gcdAB ) == 0 ) { counter ++ ; } } return counter ; }
int calSum ( int n ) { return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; }
int maxOfMin ( int a [ ] , int n , int S ) { int mi = INT_MAX ; int s1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s1 += a [ i ] ; mi = min ( a [ i ] , mi ) ; } if ( s1 < S ) return -1 ; if ( s1 == S ) return 0 ; int low = 0 ; int high = mi ; int ans ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( s1 - ( mid * n ) >= S ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; }
void getElements ( int a , int arr [ ] , int n ) { int elements [ n + 1 ] ; elements [ 0 ] = a ; for ( int i = 0 ; i < n ; i ++ ) { elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; } for ( int i = 0 ; i < n + 1 ; i ++ ) cout << elements [ i ] << " " ; }
int minimumX ( int n , int k ) { int mini = INT_MAX ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int fir = i ; int sec = n / i ; int num1 = fir * k + sec ; int res = ( num1 / k ) * ( num1 % k ) ; if ( res == n ) mini = min ( num1 , mini ) ; int num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ; if ( res == n ) mini = min ( num2 , mini ) ; } } return mini ; }
int minimumX ( int n , int k ) { int ans = INT_MAX ; for ( int rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = min ( ans , rem + ( n / rem ) * k ) ; } return ans ; }
int maxGCD ( int N , int P ) { int ans = 1 ; unordered_map < int , int > prime_factors ; for ( int i = 2 ; i * i <= P ; i ++ ) { while ( P % i == 0 ) { prime_factors [ i ] ++ ; P /= i ; } } if ( P != 1 ) prime_factors [ P ] ++ ; for ( auto v : prime_factors ) ans *= pow ( v . first , v . second / N ) ; return ans ; }
int getSum ( vector < int > arr , int p ) { return arr . size ( ) ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int countPairs ( int a [ ] , int n ) { int count = 0 ; unordered_map < int , int > m ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( isPrime ( a [ i ] ^ a [ j ] ) && m [ a [ i ] ^ a [ j ] ] == 0 ) { m [ ( a [ i ] ^ a [ j ] ) ] ++ ; count ++ ; } } } return count ; }
int count ( Node * root ) { if ( root == NULL ) return 0 ; return count ( root -> left ) + count ( root -> right ) + 1 ; }
bool check ( Node * root ) { int n = count ( root ) ; bool res = false ; checkRec ( root , n , res ) ; return res ; }
int countDivisors ( int n ) { int x = 0 , ans = 1 ; while ( n % 2 == 0 ) { x ++ ; n = n / 2 ; } ans = ans * ( x + 1 ) ; for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { x = 0 ; while ( n % i == 0 ) { x ++ ; n = n / i ; } ans = ans * ( x + 1 ) ; } if ( n > 2 ) ans = ans * 2 ; return ans ; }
int getTotalCount ( int n , int k ) { int k_count = countDivisors ( k ) ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( k_count == countDivisors ( i ) ) count ++ ; if ( k < n ) count = count - 1 ; return count ; }
int getHermiteNumber ( int n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 0 ; else return -2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; }
int doubleFactorial ( int n ) { int fact = 1 ; for ( int i = 1 ; i <= n ; i = i + 2 ) { fact = fact * i ; } return fact ; }
int hermiteNumber ( int n ) { if ( n % 2 == 1 ) return 0 ; else { int number = ( pow ( 2 , n / 2 ) ) * doubleFactorial ( n - 1 ) ; if ( ( n / 2 ) % 2 == 1 ) number = number * -1 ; return number ; } }
void find ( int n ) { int b = n ; int a = b * ( n - 1 ) ; if ( a * b > n && a / b < n ) { cout << "a = " << a << ", b = " << b ; } else cout << -1 << endl ; }
int SquareCube ( long long int N ) { int cnt = 0 , i = 1 ; while ( int ( pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; }
ll getSum ( int n , int d ) { ll sum = 0 ; while ( d <= n ) { sum += d ; d += 10 ; } return sum ; }
bool isPerfect ( int N ) { if ( ( sqrt ( N ) - floor ( sqrt ( N ) ) ) != 0 ) return false ; return true ; }
void printThreeParts ( int N ) { if ( N % 3 == 0 ) cout << " x = 1, y = 1, z = " << N - 2 << endl ; else cout << " x = 1, y = 2, z = " << N - 3 << endl ; }
int sumX ( int N , int M , int K ) { for ( int i = 0 ; i < M ; i ++ ) { N = ( int ) sum ( K + N ) ; } N = N % MOD ; return N ; }
int countDigitsToBeRemoved ( int N , int K ) { string s = to_string ( N ) ; int res = 0 ; int f_zero = 0 ; for ( int i = s . size ( ) - 1 ; i >= 0 ; i -- ) { if ( K == 0 ) return res ; if ( s [ i ] == '0' ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( ! K ) return res ; else if ( f_zero ) return s . size ( ) - 1 ; return -1 ; }
bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; }
int largestPalindrome ( int A [ ] , int n ) { sort ( A , A + n ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( isPalindrome ( A [ i ] ) ) return A [ i ] ; } return -1 ; }
bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; }
int largestPalindrome ( int A [ ] , int n ) { int currentMax = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > currentMax && isPalindrome ( A [ i ] ) ) currentMax = A [ i ] ; } return currentMax ; }
int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
bool isPrime ( int N ) { for ( int i = 2 ; i <= sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; }
int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void printMode ( int a [ ] , int n ) { int b [ n ] ; int max = * max_element ( a , a + n ) ; int t = max + 1 ; int count [ t ] ; for ( int i = 0 ; i < t ; i ++ ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int mode = 0 ; int k = count [ 0 ] ; for ( int i = 1 ; i < t ; i ++ ) { if ( count [ i ] > k ) { k = count [ i ] ; mode = i ; } } cout << "mode = " << mode ; }
void checkTypeOfTriangle ( int a , int b , int c ) { int sqa = pow ( a , 2 ) ; int sqb = pow ( b , 2 ) ; int sqc = pow ( c , 2 ) ; if ( sqa == sqb + sqc sqb == sqc + sqa sqc == sqa + sqb ) { cout << "Right-angled Triangle" ; } else if ( sqa > sqc + sqb sqb > sqa + sqc sqc > sqa + sqb ) { cout << "Obtuse-angled Triangle" ; } else { cout << "Acute-angled Triangle" ; } }
int findLargestDivisor ( int n ) { int m = n ; set < int , greater < int > > s ; s . insert ( 1 ) ; s . insert ( n ) ; for ( int i = 2 ; i < sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) { s . insert ( n / i ) ; s . insert ( i ) ; while ( m % i == 0 ) m /= i ; } } if ( m > 1 ) s . insert ( m ) ; vector < int > vec ; for ( int i = 2 ; i <= MAX ; i ++ ) vec . push_back ( i * i ) ; for ( auto d : s ) { int divi = 0 ; for ( int j = 0 ; j < vec . size ( ) && vec [ j ] <= d ; j ++ ) { if ( d % vec [ j ] == 0 ) { divi = 1 ; break ; } } if ( ! divi ) return d ; } }
int findLargestDivisor ( int n ) { for ( int i = 2 ; i < sqrt ( n ) + 1 ; i ++ ) { while ( n % ( i * i ) == 0 ) { n = n / i ; } } return n ; }
double findMedian ( int a [ ] , int n ) { sort ( a , a + n ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; }
void printAMeans ( int A , int B , int N ) { float d = ( float ) ( B - A ) / ( N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) cout << ( A + i * d ) << " " ; }
long getFinalElement ( long n ) { long finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; }
bool checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; sort ( arr , arr + n ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
bool isTriPerfect ( int n ) { int sum = 1 + n ; int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else sum = sum + i + n / i ; } i += 1 ; } if ( sum == 3 * n and n != 1 ) return true ; else false ; }
void findGreater ( int a , int b ) { long double x = ( long double ) a * ( long double ) ( log ( ( long double ) ( b ) ) ) ; long double y = ( long double ) b * ( long double ) ( log ( ( long double ) ( a ) ) ) ; if ( y > x ) { cout << "a^b is greater" << endl ; } else if ( y < x ) { cout << "b^a is greater" << endl ; } else { cout << "Both are equal" << endl ; } }
int sum ( int N , int X , int Y ) { int S1 , S2 , S3 ; S1 = ( ( N / X ) ) * ( 2 * X + ( N / X - 1 ) * X ) / 2 ; S2 = ( ( N / Y ) ) * ( 2 * Y + ( N / Y - 1 ) * Y ) / 2 ; S3 = ( ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
ll modexp ( ll x , ll n ) { if ( n == 0 ) { return 1 ; } else if ( n % 2 == 0 ) { return modexp ( ( x * x ) % m , n / 2 ) ; } else { return ( x * modexp ( ( x * x ) % m , ( n - 1 ) / 2 ) % m ) ; } }
ll getFractionModulo ( ll a , ll b ) { ll c = gcd ( a , b ) ; a = a / c ; b = b / c ; ll d = modexp ( b , m - 2 ) ; ll ans = ( ( a % m ) * ( d % m ) ) % m ; return ans ; }
int startingPoint ( int Length , int Speed1 , int Speed2 ) { int result1 = 0 , result2 = 0 ; int time1 = Length / Speed1 ; int time2 = Length / Speed2 ; result1 = __gcd ( time1 , time2 ) ; result2 = time1 * time2 / ( result1 ) ; return result2 ; }
float firstTime ( int Length , int Speed1 , int Speed2 ) { float result = 0 ; int relativeSpeed = abs ( Speed1 - Speed2 ) ; result = ( ( float ) Length / relativeSpeed ) ; return result ; }
int findNumber ( int n ) { int i = n - 1 ; while ( i > 0 ) { if ( sumOfDigits ( i ) > sumOfDigits ( n ) ) return i ; i -- ; } return -1 ; }
int findTwoThreePrime ( int l , int r ) { if ( l == 1 ) l ++ ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; while ( num % 2 == 0 ) num /= 2 ; while ( num % 3 == 0 ) num /= 3 ; if ( num == 1 ) count ++ ; } return count ; }
int findNth ( int N ) { int b = 14 ; int i ; for ( i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) b = b * 2 ; else b = b - 8 ; } return b ; }
void icanobifNumbers ( int N ) { int first = 0 , second = 1 ; if ( N == 1 ) cout << first ; else if ( N == 2 ) cout << first << " " << second ; else { cout << first << " " << second << " " ; for ( int i = 3 ; i <= N ; i ++ ) { int x = reversDigits ( first ) ; int y = reversDigits ( second ) ; cout << x + y << " " ; int temp = second ; second = x + y ; first = temp ; } } }
int addNDigits ( int a , int b , int n ) { int num = a ; for ( int i = 0 ; i <= 9 ; i ++ ) { int tmp = a * 10 + i ; if ( tmp % b == 0 ) { a = tmp ; break ; } } if ( num == a ) return -1 ; for ( int j = 0 ; j < n - 1 ; j ++ ) a *= 10 ; return a ; }
void predictMatrix ( int arr [ N ] [ N ] , int range1a , int range1b , int range0a , int range0b , int K , int b [ N ] [ N ] ) { int c = 0 ; while ( K -- ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { c = 0 ; if ( i > 0 && arr [ i - 1 ] [ j ] == 1 ) c ++ ; if ( j > 0 && arr [ i ] [ j - 1 ] == 1 ) c ++ ; if ( i > 0 && j > 0 && arr [ i - 1 ] [ j - 1 ] == 1 ) c ++ ; if ( i < N - 1 && arr [ i + 1 ] [ j ] == 1 ) c ++ ; if ( j < N - 1 && arr [ i ] [ j + 1 ] == 1 ) c ++ ; if ( i < N - 1 && j < N - 1 && arr [ i + 1 ] [ j + 1 ] == 1 ) c ++ ; if ( i < N - 1 && j > 0 && arr [ i + 1 ] [ j - 1 ] == 1 ) c ++ ; if ( i > 0 && j < N - 1 && arr [ i - 1 ] [ j + 1 ] == 1 ) c ++ ; if ( arr [ i ] [ j ] == 1 ) { if ( c >= range1a && c <= range1b ) b [ i ] [ j ] = 1 ; else b [ i ] [ j ] = 0 ; } if ( arr [ i ] [ j ] == 0 ) { if ( c >= range0a && c <= range0b ) b [ i ] [ j ] = 1 ; else b [ i ] [ j ] = 0 ; } } } for ( int k = 0 ; k < N ; k ++ ) for ( int m = 0 ; m < N ; m ++ ) arr [ k ] [ m ] = b [ k ] [ m ] ; } }
int countMoves ( int n ) { int ct = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ct += i * ( n - i ) ; ct += n ; return ct ; }
int Triplets ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = i ; j <= n ; ++ j ) { int x = i * i + j * j ; int y = sqrt ( x ) ; if ( y * y == x && y <= n ) ++ ans ; } } return ans ; }
int countTriplets ( int n ) { vector < int > perfectSquares = getPerfectSquares ( pow ( n , 2 ) ) ; int count = 0 ; for ( int a = 1 ; a <= n ; a ++ ) { int aSquare = pow ( a , 2 ) ; for ( int i = 0 ; i < perfectSquares . size ( ) ; i ++ ) { int cSquare = perfectSquares [ i ] ; int bSquare = abs ( cSquare - aSquare ) ; int b = sqrt ( bSquare ) ; int c = sqrt ( cSquare ) ; if ( c < a || ( find ( perfectSquares . begin ( ) , perfectSquares . end ( ) , bSquare ) == perfectSquares . end ( ) ) ) continue ; if ( ( b >= a ) && ( b <= c ) && ( aSquare + bSquare == cSquare ) ) count ++ ; } } return count ; }
void SumsOfDigits ( int n ) { int sum = 0 ; for ( int base = 2 ; base <= n / 2 ; ++ base ) sum += solve ( n , base ) ; cout << sum ; }
int minimumMoves ( int k , int l , int r ) { int count = r - l + 1 ; if ( count % k == 0 ) return 0 ; return ( k - ( count % k ) ) ; }
bool checkPerfectcube ( int n ) { int d = cbrt ( n ) ; if ( d * d * d == n ) return true ; return false ; }
int largestNonPerfectcubeNumber ( int a [ ] , int n ) { int maxi = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! checkPerfectcube ( a [ i ] ) ) maxi = max ( a [ i ] , maxi ) ; } return maxi ; }
int sumNatural ( int n ) { int sum = ( n * ( n + 1 ) ) ; return sum ; }
void checkIfPossibleRec ( int x , int a , int b , bool isPossible [ ] , int n ) { if ( x > n ) return ; if ( isPossible [ x ] ) return ; isPossible [ x ] = true ; checkIfPossibleRec ( x + a , a , b , isPossible , n ) ; checkIfPossibleRec ( x + b , a , b , isPossible , n ) ; }
bool checkPossible ( int n , int a , int b ) { bool isPossible [ n + 1 ] = { false } ; checkIfPossibleRec ( 0 , a , b , isPossible , n ) ; return isPossible [ n ] ; }
bool isDivisibleRec ( int x , int a , int b , int n ) { if ( x > n ) return false ; if ( n % x == 0 ) return true ; return ( isDivisibleRec ( x * 10 + a , a , b , n ) || isDivisibleRec ( x * 10 + b , a , b , n ) ) ; }
bool isDivisible ( int a , int b , int n ) { return isDivisibleRec ( a , a , b , n ) || isDivisibleRec ( b , a , b , n ) ; }
int sumOdd ( int n ) { int terms = ( n + 1 ) / 2 ; int sum = terms * terms ; return sum ; }
int suminRange ( int l , int r ) { return sumOdd ( r ) - sumOdd ( l - 1 ) ; }
int sumNatural ( int n ) { int sum = ( n * ( n + 1 ) ) / 2 ; return sum ; }
int suminRange ( int l , int r ) { return sumNatural ( r ) - sumNatural ( l - 1 ) ; }
bool CheckArray ( int arr [ ] , int n ) { int prod = 1 ; for ( int i = 0 ; i < n ; ++ i ) prod *= arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] == prod / arr [ i ] ) return true ; return false ; }
bool CheckArray ( int arr [ ] , int n ) { int prod = 1 ; unordered_set < int > freq ; for ( int i = 0 ; i < n ; ++ i ) { freq . insert ( arr [ i ] ) ; prod *= arr [ i ] ; } int root = sqrt ( prod ) ; if ( root * root == prod ) if ( freq . find ( root ) != freq . end ( ) ) return true ; return false ; }
long sumOfAllPalindrome ( int L , int R ) { long sum = 0 ; if ( L <= R ) for ( int i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) && isOddLength ( i ) ) { sum += i ; } } return sum ; }
bool divisibleBy25 ( string number ) { if ( number . length ( ) < 2 ) return false ; int length = number . length ( ) ; int lastTwo = ( number [ length - 2 ] - '0' ) * 10 + ( number [ length - 1 ] - '0' ) ; if ( lastTwo % 25 == 0 ) return true ; return false ; }
bool divisibleBy75 ( string number ) { if ( divisibleBy3 ( number ) && divisibleBy25 ( number ) ) return true ; return false ; }
int breakEvenPoint ( int exp , int S , int M ) { float earn = S - M ; int res = ceil ( exp / earn ) ; return res ; }
int otherNumber ( int A , int Lcm , int Hcf ) { return ( Lcm * Hcf ) / A ; }
int sum ( int a , int b ) { int sum = 0 ; for ( int i = 1 ; i <= min ( a , b ) ; i ++ ) if ( a % i == 0 && b % i == 0 ) sum += i ; return sum ; }
int sumcommDiv ( int a , int b ) { int n = gcd ( a , b ) ; int sum = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum += i ; else sum += ( n / i ) + i ; } } return sum ; }
int minimumNumbers ( int n , int s ) { if ( s % n ) return s / n + 1 ; else return s / n ; }
int search ( int arr [ ] , int strt , int end , int value ) { for ( int i = strt ; i <= end ; i ++ ) { if ( arr [ i ] == value ) return i ; } }
int checkPostorder ( Node * node , int postOrder [ ] , int index ) { if ( node == NULL ) return index ; index = checkPostorder ( node -> left , postOrder , index ) ; index = checkPostorder ( node -> right , postOrder , index ) ; if ( node -> data == postOrder [ index ] ) index ++ ; else return -1 ; return index ; }
ll sumAP ( ll n , ll d ) { n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; }
ll sumMultiples ( ll A , ll B , ll n ) { n -- ; ll common = ( A * B ) / __gcd ( A , B ) ; return sumAP ( n , A ) + sumAP ( n , B ) - sumAP ( n , common ) ; }
bool isPossible ( int N ) { if ( isPrime ( N ) && isPrime ( N - 2 ) ) return true ; else return false ; }
int totalPairs ( int arr1 [ ] , int arr2 [ ] , int K , int n , int m ) { set < pair < int , int > > s ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] > arr2 [ j ] ) { if ( arr1 [ i ] % arr2 [ j ] == K ) s . insert ( make_pair ( arr1 [ i ] , arr2 [ j ] ) ) ; } else { if ( arr2 [ j ] % arr1 [ i ] == K ) s . insert ( make_pair ( arr2 [ j ] , arr1 [ i ] ) ) ; } } } return s . size ( ) ; }
int contiguousPerfectSquare ( int arr [ ] , int n ) { int a ; float b ; int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { b = sqrt ( arr [ i ] ) ; a = b ; if ( a == b ) current_length ++ ; else current_length = 0 ; max_length = max ( max_length , current_length ) ; } return max_length ; }
float getSum ( int a , int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { sum += ( i / pow ( a , i ) ) ; } return sum ; }
int getIndex ( int a [ ] , int n ) { if ( n == 1 ) return 0 ; int ptrL = 0 , ptrR = n - 1 , sumL = a [ 0 ] , sumR = a [ n - 1 ] ; while ( ptrR - ptrL > 1 ) { if ( sumL < sumR ) { ptrL ++ ; sumL += a [ ptrL ] ; } else if ( sumL > sumR ) { ptrR -- ; sumR += a [ ptrR ] ; } else { break ; } } return ptrL ; }
int getPosition ( int a [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] / m + ( a [ i ] % m != 0 ) ) ; } int ans = -1 , max = -1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( max < a [ i ] ) { max = a [ i ] ; ans = i ; } } return ans + 1 ; }
int calcFunction ( int n , int r ) { int finalDenominator = 1 ; int mx = max ( r , n - r ) ; for ( int i = mx + 1 ; i <= n ; i ++ ) { int denominator = ( int ) pow ( i , i ) ; int numerator = ( int ) pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; }
void generateNumbers ( int n , int num , int a , int b ) { if ( num > 0 && num < n ) st . insert ( num ) ; if ( num >= n ) return ; if ( num * 10 + a > num ) generateNumbers ( n , num * 10 + a , a , b ) ; generateNumbers ( n , num * 10 + b , a , b ) ; }
int findSmallest ( int arr [ ] , int n ) { int MAX = * max_element ( arr , arr + n ) ; vector < ll > prime = findPrime ( MAX ) ; unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( arr [ i ] ) ; int ans = -1 ; for ( int i = 0 ; i < prime . size ( ) ; i ++ ) if ( s . find ( prime [ i ] ) == s . end ( ) ) { ans = prime [ i ] ; break ; } return ans ; }
int minOperations ( int A [ ] , int n ) { if ( n & 1 ) return -1 ; int zeros = 0 , consZeros = 0 , ones = 0 ; for ( int i = 0 ; i < n ; ++ i ) { A [ i ] == 0 ? zeros ++ : ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return -1 ; }
int minimumCuts ( int a [ ] , int n ) { sort ( a , a + n ) ; int gcd = a [ 1 ] - a [ 0 ] ; int s = gcd ; for ( int i = 2 ; i < n ; i ++ ) { gcd = __gcd ( gcd , a [ i ] - a [ i - 1 ] ) ; s += a [ i ] - a [ i - 1 ] ; } if ( 360 - s > 0 ) gcd = __gcd ( gcd , 360 - s ) ; return ( 360 / gcd ) - n ; }
int countdig ( int m ) { if ( m == 0 ) return 0 ; else return 1 + countdig ( m / 10 ) ; }
int countSteps ( int x ) { int c = 0 ; int last = x ; while ( last ) { int digits = countdig ( last ) ; digits -= 1 ; int divisor = pow ( 10 , digits ) ; int first = last / divisor ; int lastnumber = first * divisor ; int skipped = ( last - lastnumber ) / first ; skipped += 1 ; c += skipped ; last = last - ( first * skipped ) ; } return c ; }
int findNum ( int div [ ] , int rem [ ] , int N ) { int num = rem [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; }
void profitLoss ( int N , int M ) { if ( N == M ) cout << "No Profit nor Loss" ; else { float result = 0.0 ; result = float ( abs ( N - M ) ) / M ; if ( N - M < 0 ) cout << "Loss = -" << result * 100 << "%" ; else cout << "Profit = " << result * 100 << "%" ; } }
void niceIndices ( int A [ ] , int n ) { int sum = 0 ; map < int , int > m ; for ( int i = 0 ; i < n ; ++ i ) { m [ A [ i ] ] ++ ; sum += A [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { int k = sum - A [ i ] ; if ( k % 2 == 0 ) { k = k >> 1 ; if ( m . find ( k ) != m . end ( ) ) { if ( ( A [ i ] == k && m [ k ] > 1 ) || ( A [ i ] != k ) ) cout << ( i + 1 ) << " " ; } } } }
void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } }
vector < int > getFactorization ( int x ) { vector < int > ret ; while ( x != 1 ) { int temp = spf [ x ] ; ret . push_back ( temp ) ; while ( x % temp == 0 ) x = x / temp ; } return ret ; }
int maxElement ( int A [ ] , int n ) { sieve ( ) ; map < int , int > m ; for ( int i = 0 ; i < n ; ++ i ) { vector < int > p = getFactorization ( A [ i ] ) ; for ( int i = 0 ; i < p . size ( ) ; i ++ ) m [ p [ i ] ] ++ ; } int cnt = 0 , ans = 1e+7 ; for ( auto i : m ) { if ( i . second >= cnt ) { cnt = i . second ; ans > i . first ? ans = i . first : ans = ans ; } } return ans ; }
int countPieces ( int N ) { return 2 * N ; }
float SellingPrice ( float CP , float PP ) { float P_decimal = 1 + ( PP / 100 ) ; float res = P_decimal * CP ; return res ; }
long long sumMultiples ( long long n ) { n -- ; return sumAP ( n , 3 ) + sumAP ( n , 7 ) - sumAP ( n , 21 ) ; }
bool productSumDivisible ( int n , int size ) { int sum = 0 , product = 1 ; while ( n > 0 ) { if ( size % 2 == 0 ) { product *= n % 10 ; } else { sum += n % 10 ; } n = n / 10 ; size -- ; } if ( product % sum == 0 ) return true ; return false ; }
ll gcd ( ll a , ll b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
ll powGCD ( ll a , ll n , ll b ) { for ( int i = 0 ; i < n ; i ++ ) a = a * a ; return gcd ( a , b ) ; }
ll power ( ll x , ll y , ll p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
ll powerGCD ( ll a , ll b , ll n ) { ll e = power ( a , n , b ) ; return gcd ( e , b ) ; }
int lastCoordinate ( int n , int a , int b ) { return ( ( n + 1 ) / 2 ) * a - ( n / 2 ) * b ; }
bool allOddDigits ( int n ) { while ( n ) { if ( ( n % 10 ) % 2 == 0 ) return false ; n /= 10 ; } return true ; }
int largestNumber ( int n ) { if ( n % 2 == 0 ) n -- ; for ( int i = n ; ; i -= 2 ) if ( allOddDigits ( i ) ) return i ; }
int findNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }
void countDigit ( int n ) { int temp = n , sum = 0 , product = 1 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } cout << "Sum = " << sum ; cout << "Product="  }
int findNum ( int N , int K ) { int rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
bool isDivisiblePalindrome ( int n ) { int hash [ 10 ] = { 0 } ; int digitSum = 0 ; while ( n ) { digitSum += n % 10 ; hash [ n % 10 ] ++ ; n /= 10 ; } if ( digitSum % 3 != 0 ) return false ; int oddCount = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( hash [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount > 1 ) return false ; else return true ; }
int countNumbers ( int N ) { return int ( sqrt ( N ) ) - 1 ; }
int countOrderedPairs ( int N ) { int count_pairs = 0 ; for ( int i = 1 ; i <= sqrt ( N - 1 ) ; ++ i ) { for ( int j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= int ( sqrt ( N - 1 ) ) ; return count_pairs ; }
int toK ( int N , int K ) { int w = 1 ; int s = 0 ; while ( N != 0 ) { int r = N % K ; N = N / K ; s = r * w + s ; w *= 10 ; } return s ; }
void hasConsecutiveZeroes ( int N , int K ) { int z = toK ( N , K ) ; if ( check ( z ) ) cout << "Yes" << endl ; else cout << "No" << endl ; }
bool check ( int s ) { int freq [ 10 ] = { 0 } , r ; while ( s != 0 ) { r = s % 10 ; s = int ( s / 10 ) ; freq [ r ] += 1 ; } int xor__ = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { xor__ = xor__ ^ freq [ i ] ; if ( xor__ == 0 ) return true ; else return false ; } }
int lcm ( int a , int b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; }
int dfs ( int src , vector < int > adj [ ] , vector < bool > & visited ) { visited [ src ] = true ; int count = 1 ; for ( int i = 0 ; i < adj [ src ] . size ( ) ; i ++ ) if ( ! visited [ adj [ src ] [ i ] ] ) count += dfs ( adj [ src ] [ i ] , adj , visited ) ; return count ; }
int findMinTime ( int arr [ ] , int P [ ] , int n ) { vector < int > adj [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { adj [ arr [ i ] ] . push_back ( P [ i ] ) ; } vector < bool > visited ( n + 1 ) ; int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! visited [ i ] ) { ans = lcm ( ans , dfs ( i , adj , visited ) ) ; } } return ans ; }
void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) if ( prime [ p ] == true ) for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; }
int superpower ( int n ) { SieveOfEratosthenes ( ) ; int superPower = 0 , factor = 0 ; int i = 2 ; while ( n > 1 && i <= MAX ) { if ( prime [ i ] ) { factor = 0 ; while ( n % i == 0 && n > 1 ) { factor ++ ; n = n / i ; } if ( superPower < factor ) superPower = factor ; } i ++ ; } return superPower ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int countPrime ( Node * * head_ref ) { int count = 0 ; Node * ptr = * head_ref ; while ( ptr != NULL ) { if ( isPrime ( ptr -> data ) ) { count ++ ; } ptr = ptr -> next ; } return count ; }
void pairwiseDifference ( int arr [ ] , int n ) { int diff ; for ( int i = 0 ; i < n - 1 ; i ++ ) { diff = abs ( arr [ i ] - arr [ i + 1 ] ) ; cout << diff << " " ; } }
int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; }
int npr ( int n , int r ) { int pnr = factorial ( n ) / factorial ( n - r ) ; return pnr ; }
int countPermutations ( int n , int r , int k ) { return factorial ( k ) * ( r - k + 1 ) * npr ( n - k , r - k ) ; }
long long sumMultiples ( long long n ) { n -- ; return sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 10 ) ; }
int GIF ( float n ) { return floor ( n ) ; }
int ncr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; }
int smallestDivisor ( int n ) { if ( n % 2 == 0 ) return 2 ; for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return i ; } return n ; }
int countRabbits ( int Heads , int Legs ) { int count = 0 ; count = ( Legs ) -2 * ( Heads ) ; count = count / 2 ; return count ; }
int compositeProduct ( int arr [ ] , int n ) { int max_val = * max_element ( arr , arr + n ) ; vector < bool > prime ( max_val + 1 , true ) ; prime [ 0 ] = true ; prime [ 1 ] = true ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( ! prime [ arr [ i ] ] ) { product *= arr [ i ] ; } return product ; }
int markingScheme ( int N , int answerKey [ ] , int studentAnswer [ ] ) { int positive = 0 , negative = 0 , notattempt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( studentAnswer [ i ] == 0 ) notattempt ++ ; else if ( answerKey [ i ] == studentAnswer [ i ] ) positive ++ ; else if ( answerKey [ i ] != studentAnswer [ i ] ) negative ++ ; } return ( positive * 3 ) + ( negative * -1 ) ; }
bool SumDivisible ( int n , int k ) { int sum = 0 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 1 ) sum += n % 10 ; n = n / 10 ; position ++ ; } if ( sum % k == 0 ) return true ; return false ; }
ll fact ( int n ) { ll f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f = f * i ; return f ; }
ll waysOfConsonants ( int size1 , int freq [ ] ) { ll ans = fact ( size1 ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) continue ; else ans = ans / fact ( freq [ i ] ) ; } return ans ; }
ll waysOfVowels ( int size2 , int freq [ ] ) { return fact ( size2 ) / ( fact ( freq [ 0 ] ) * fact ( freq [ 4 ] ) * fact ( freq [ 8 ] ) * fact ( freq [ 14 ] ) * fact ( freq [ 20 ] ) ) ; }
ll countWays ( string str ) { int freq [ 26 ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) freq [ str [ i ] - 'a' ] ++ ; int vowel = 0 , consonant = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] != 'a' && str [ i ] != 'e' && str [ i ] != 'i' && str [ i ] != 'o' && str [ i ] != 'u' ) consonant ++ ; else vowel ++ ; } return waysOfConsonants ( consonant + 1 , freq ) * waysOfVowels ( vowel , freq ) ; }
int findX ( int n , int k ) { int r = n , v , u ; int m = sqrt ( k ) + 1 ; for ( int i = 2 ; i <= m && k > 1 ; i ++ ) { if ( i == m ) { i = k ; } for ( u = v = 0 ; k % i == 0 ; v ++ ) { k /= i ; } if ( v > 0 ) { int t = n ; while ( t > 0 ) { t /= i ; u += t ; } r = min ( r , u / v ) ; } } return r ; }
int ncr ( int n , int r ) { int ncr = fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; return ncr ; }
void maxSum ( int a [ ] , int n ) { int maxAnd = 0 ; for ( int i = 0 ; i < n ; i ++ ) maxAnd = max ( maxAnd , a [ i ] ) ; int maxOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxOR = maxOR | a [ i ] ; } cout << maxAnd + maxOR ; }
int sum_odd ( int n ) { int sum = 0 , pos = 1 ; while ( n ) { if ( pos % 2 == 1 ) sum += n % 10 ; n = n / 10 ; pos ++ ; } return sum ; }
bool check_prime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
float calculateSum ( float n ) { int a = int ( n ) ; return 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ; }
int solve ( int n ) { int count = 0 , num = 1 ; long long int prod = 1 ; while ( count < n ) { if ( prime [ num ] ) { prod *= num ; count ++ ; } num ++ ; } return prod ; }
void ReplaceElements ( int arr [ ] , int n ) { int prod = 1 ; for ( int i = 0 ; i < n ; ++ i ) { prod *= arr [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { arr [ i ] = prod / arr [ i ] ; } }
int sum ( int n ) { if ( n == 0 ) return 0 ; return square ( ( n + 1 ) / 2 ) + sum ( n / 2 ) ; }
int oddDivSum ( int a , int b ) { return sum ( b ) - sum ( a - 1 ) ; }
int countBits ( int n ) { int count = 0 ; while ( n ) { count ++ ; n >>= 1 ; } return count ; }
bool isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; }
bool isPower ( int a ) { if ( a == 1 ) return true ; for ( int i = 2 ; i * i <= a ; i ++ ) { double val = log ( a ) / log ( i ) ; if ( ( val - ( int ) val ) < 0.00000001 ) return true ; } return false ; }
bool isAchillesNumber ( int n ) { if ( isPowerful ( n ) && ! isPower ( n ) ) return true ; else return false ; }
int OddDivCount ( int a , int b ) { int res = 0 ; for ( int i = a ; i <= b ; ++ i ) { int divCount = 0 ; for ( int j = 1 ; j <= i ; ++ j ) { if ( i % j == 0 ) { ++ divCount ; } } if ( divCount % 2 ) { ++ res ; } } return res ; }
int divisor ( int a ) { int div = 1 , count = 0 ; for ( int i = 2 ; i <= sqrt ( a ) ; i ++ ) { while ( a % i == 0 ) { count ++ ; a = a / i ; } div = div * ( count + 1 ) ; count = 0 ; } if ( a > 1 ) { div = div * ( 2 ) ; } return div ; }
int OddDivCount ( int a , int b ) { int res = 0 ; for ( int i = a ; i <= b ; ++ i ) { int divCount = divisor ( i ) ; if ( divCount % 2 ) { ++ res ; } } return res ; }
int Check_is_possible ( int l , int r , int k ) { int div_count = ( r / k ) - ( l / k ) ; if ( l % k == 0 ) div_count ++ ; return ( div_count > 1 ) ; }
bool isValid ( long long int N , long long int K ) { multiset < int > m1 , m2 ; while ( N > 0 ) { m1 . insert ( N % 10 ) ; N /= 10 ; } while ( K > 0 ) { m2 . insert ( K % 10 ) ; K /= 10 ; } if ( m1 == m2 ) return true ; return false ; }
int largestSquareFactor ( int num ) { int answer = 1 ; for ( int i = 2 ; i < sqrt ( num ) ; ++ i ) { int cnt = 0 ; int j = i ; while ( num % j == 0 ) { cnt ++ ; j *= i ; } if ( cnt & 1 ) { cnt -- ; answer *= pow ( i , cnt ) ; } else { answer *= pow ( i , cnt ) ; } } return answer ; }
int nth_group ( int n ) { return n * ( 2 * pow ( n , 2 ) + 1 ) ; }
bool checkUnusual ( int n ) { int factor = largestPrimeFactor ( n ) ; if ( factor > sqrt ( n ) ) { return true ; } else { return false ; } }
void printPossible ( int a , int b , int c ) { if ( ( a + b + c ) % 2 != 0 a + b < c ) cout << "NO" ; else cout << "YES" ; }
int isChangeable ( int notes [ ] , int n ) { int fiveCount = 0 ; int tenCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( notes [ i ] == 5 ) fiveCount ++ ; else if ( notes [ i ] == 10 ) { if ( fiveCount > 0 ) { fiveCount -- ; tenCount ++ ; } else return 0 ; } else { if ( fiveCount > 0 && tenCount > 0 ) { fiveCount -- ; tenCount -- ; } else if ( fiveCount >= 3 ) { fiveCount -= 3 ; } else return 0 ; } } return 1 ; }
int sumSubarrayMins ( int A [ ] , int n ) { int left [ n ] , right [ n ] ; stack < pair < int , int > > s1 , s2 ; for ( int i = 0 ; i < n ; ++ i ) { int cnt = 1 ; while ( ! s1 . empty ( ) && ( s1 . top ( ) . first ) > A [ i ] ) { cnt += s1 . top ( ) . second ; s1 . pop ( ) ; } s1 . push ( { A [ i ] , cnt } ) ; left [ i ] = cnt ; } for ( int i = n - 1 ; i >= 0 ; -- i ) { int cnt = 1 ; while ( ! s2 . empty ( ) && ( s2 . top ( ) . first ) >= A [ i ] ) { cnt += s2 . top ( ) . second ; s2 . pop ( ) ; } s2 . push ( { A [ i ] , cnt } ) ; right [ i ] = cnt ; } int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) result = ( result + A [ i ] * left [ i ] * right [ i ] ) ; return result ; }
bool isPerfectPower ( int n ) { if ( n == 1 ) return true ; for ( int x = 2 ; x <= sqrt ( n ) ; x ++ ) { int y = 2 ; int p = pow ( x , y ) ; while ( p <= n && p > 0 ) { if ( p == n ) return true ; y ++ ; p = pow ( x , y ) ; } } return false ; }
bool isTrojan ( int n ) { if ( ! isPerfectPower ( n ) && isStrongNumber ( n ) ) return true ; else return false ; }
int Nth_Term ( int n ) { return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) / 6 ; }
int Sum_upto_nth_Term ( int n ) { return ( 1 - pow ( -2 , n ) ) ; }
int Nth_Term ( int n ) { return ( 3 * pow ( n , 2 ) - n + 2 ) / ( 2 ) ; }
void countPermutations ( int N , int B ) { int x = pow ( B , N ) ; int y = pow ( B , N - 1 ) ; cout << x - y << "\n" ; }
int calculateDifference ( int arr [ ] , int n ) { int max_val = * max_element ( arr , arr + n ) ; vector < bool > prime ( max_val + 1 , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int P1 = 1 , P2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { P1 *= arr [ i ] ; } else if ( arr [ i ] != 1 ) { P2 *= arr [ i ] ; } } return abs ( P2 - P1 ) ; }
int CalculateDifference ( int arr [ ] , int n ) { int max_val = * max_element ( arr , arr + n ) ; vector < bool > prime ( max_val + 1 , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int S1 = 0 , S2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { S1 += arr [ i ] ; } else if ( arr [ i ] != 1 ) { S2 += arr [ i ] ; } } return abs ( S2 - S1 ) ; }
int EqualNumbers ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n ) return n - 1 ; return n ; }
int getMin ( int arr [ ] , int n , int k ) { int res = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) res = min ( res , arr [ i ] ) ; } return res ; }
int getMax ( int arr [ ] , int n , int k ) { int res = INT_MIN ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) res = max ( res , arr [ i ] ) ; } return res ; }
void printNumberWithDR ( int k , int d ) { if ( d == 0 && k != 1 ) cout << "-1" ; else { cout << d ; k -- ; while ( k -- ) cout << "0" ; } }
int count_odd_pair ( int n , int a [ ] ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } int ans = odd * even * 2 ; return ans ; }
int count_even_pair ( int odd_sum_pairs , int n ) { int total_pairs = ( n * ( n - 1 ) ) ; int ans = total_pairs - odd_sum_pairs ; return ans ; }
int findSteps ( int n , int m , int a [ ] ) { int cur = 1 ; int steps = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( a [ i ] >= cur ) steps += ( a [ i ] - cur ) ; else steps += ( n - cur + a [ i ] ) ; cur = a [ i ] ; } return steps ; }
int xorEqualsOrCount ( int N ) { int count = 0 ; int bit ; while ( N > 0 ) { bit = N % 2 ; if ( bit == 0 ) count ++ ; N = N / 2 ; } return ( int ) pow ( 2 , count ) ; }
int fact ( int n ) { if ( n == 1 ) return 1 ; return n * fact ( n - 1 ) ; }
double sum ( int x , int n ) { double i , total = 1.0 ; for ( i = 1 ; i <= n ; i ++ ) { total = total + ( pow ( x , i ) / fact ( i + 1 ) ) ; } return total ; }
double sum ( int x , int n ) { double total = 1.0 ; double previous = 1.0 ; for ( int i = 1 ; i <= n ; i ++ ) { previous = ( previous * x ) / ( i + 1 ) ; total = total + previous ; } return total ; }
bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; }
void Count_pairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerOfTwo ( a [ i ] ) ) count ++ ; } int ans = ( count * ( count - 1 ) ) / 2 ; cout << ans << "\n" ; }
int numberOfDivisors ( int num ) { int c = 0 ; for ( int i = 1 ; i <= num ; i ++ ) { if ( num % i == 0 ) { c += 1 ; } } return c ; }
int countNumbers ( int n ) { int c = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( numberOfDivisors ( i ) == 9 ) c += 1 ; } return c ; }
int countNumbers ( int n ) { int c = 0 ; int limit = sqrt ( n ) ; int prime [ limit + 1 ] ; for ( int i = 1 ; i <= limit ; i ++ ) prime [ i ] = i ; for ( int i = 2 ; i * i <= limit ; i ++ ) { if ( prime [ i ] == i ) { for ( int j = i * i ; j <= limit ; j += i ) if ( prime [ j ] == j ) prime [ j ] = i ; } } for ( int i = 2 ; i <= limit ; i ++ ) { int p = prime [ i ] ; int q = prime [ i / prime [ i ] ] ; if ( p * q == i && q != 1 && p != q ) { c += 1 ; } else if ( prime [ i ] == i ) { if ( pow ( i , 8 ) <= n ) { c += 1 ; } } } return c ; }
int sumNth ( int A [ ] , int B [ ] , int m , int n ) { int res = 0 ; if ( n == 1 ) { for ( int i = 0 ; i < m ; i ++ ) res = res + A [ i ] ; } else if ( n == 2 ) { for ( int i = 0 ; i < m ; i ++ ) res = res + B [ i ] * m ; } else { int f [ n ] ; f [ 0 ] = 0 , f [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; for ( int i = 0 ; i < m ; i ++ ) { res = res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ; } } return res ; }
int factorial ( int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = result * i ; return result ; }
int nCr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; }
int calculate_result ( int n ) { int result = 2 * nCr ( ( n - 2 ) , ( n / 2 - 1 ) ) ; return result ; }
void isHalfReducible ( int arr [ ] , int n , int m ) { int frequencyHash [ m + 1 ] ; int i ; memset ( frequencyHash , 0 , sizeof ( frequencyHash ) ) ; for ( i = 0 ; i < n ; i ++ ) { frequencyHash [ arr [ i ] % ( m + 1 ) ] ++ ; } for ( i = 0 ; i <= m ; i ++ ) { if ( frequencyHash [ i ] >= n / 2 ) break ; } if ( i <= m ) cout << "Yes" << endl ; else cout << "No" << endl ; }
void generateDivisors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) arr . push_back ( i ) ; { arr . push_back ( i ) ; arr . push_back ( n / i ) ; } } } }
double harmonicMean ( int n ) { generateDivisors ( n ) ; double sum = 0.0 ; int len = arr . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) sum = sum + double ( n / arr [ i ] ) ; sum = double ( sum / n ) ; return double ( arr . size ( ) / sum ) ; }
bool isOreNumber ( int n ) { double mean = harmonicMean ( n ) ; if ( mean - int ( mean ) == 0 ) return true ; else return false ; }
int sum_of_series ( int n ) { int result = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) result = result - pow ( i , 2 ) ; else result = result + pow ( i , 2 ) ; } return result ; }
int sum_of_series ( int n ) { int result = 0 ; if ( n % 2 == 0 ) { result = - ( n * ( n + 1 ) ) / 2 ; } else { result = ( n * ( n + 1 ) ) / 2 ; } return result ; }
int digitProduct ( int digits [ ] , int start , int end ) { int pro = 1 ; for ( int i = start ; i <= end ; i ++ ) { pro *= digits [ i ] ; } return pro ; }
int numberOfDistinct ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; }
void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; memset ( sum , 0 , sizeof ( sum ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } for ( int i = 1 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) sum [ i ] = 1 ; sum [ i ] += sum [ i - 1 ] ; } }
int calculateAlternateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; int sum = pow ( fibo [ 0 ] , 2 ) + pow ( fibo [ 1 ] , 2 ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum -= fibo [ i ] ; else sum += fibo [ i ] ; } return sum ; }
int getValue ( int n ) { int i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return k / 2 ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
void ulam ( ) { arr . push_back ( 1 ) ; arr . push_back ( 2 ) ; for ( int i = 3 ; i < MAX ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr . size ( ) - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr . size ( ) ; k ++ ) { if ( arr [ j ] + arr [ k ] == i ) { count ++ ; } if ( count > 1 ) break ; } if ( count > 1 ) break ; } if ( count == 1 ) { arr . push_back ( i ) ; } } }
long nthKyneaNumber ( int n ) { n = ( 1 << n ) + 1 ; n = n * n ; n = n - 2 ; return n ; }
long nthKyneaNumber ( int n ) { return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; }
bool isProthNumber ( int n ) { int k = 1 ; while ( k < ( n / k ) ) { if ( n % k == 0 ) { if ( isPowerOfTwo ( n / k ) ) return true ; } k = k + 2 ; } return false ; }
bool isInterprime ( int n ) { if ( n < 4 ) return false ; int prev_prime = n ; int next_prime = n ; while ( ! isPrime ( prev_prime ) ) { prev_prime -- ; } while ( ! isPrime ( next_prime ) ) { next_prime ++ ; } if ( ( prev_prime + next_prime ) == 2 * n ) return true ; else return false ; }
bool isPowerOfTwo ( int n ) { return ( n && ! ( n & ( n - 1 ) ) ) ; }
bool isThabitNumber ( int n ) { n = n + 1 ; if ( n % 3 == 0 ) n = n / 3 ; else return false ; if ( isPowerOfTwo ( n ) ) return true ; else return false ; }
int get_last_two_digit ( long long int N ) { if ( N <= 10 ) { ll ans = 0 , fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ans % 100 ; } return 13 ; }
bool isProductEven ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) == 0 ) return true ; return false ; }
int calculateSquareSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; int sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += ( fibo [ i ] * fibo [ i ] ) ; } return sum ; }
int fib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return ( f [ n ] = 1 ) ; if ( f [ n ] ) return f [ n ] ; int k = ( n & 1 ) ? ( n + 1 ) / 2 : n / 2 ; f [ n ] = ( n & 1 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; }
int calculateSumOfSquares ( int n ) { return fib ( n ) * fib ( n + 1 ) ; }
void sieve ( ) { int arr [ N + 1 ] ; arr [ 0 ] = 1 ; arr [ 1 ] = 1 ; for ( int i = 2 ; i <= sqrt ( N ) ; i ++ ) if ( arr [ i ] == 0 ) for ( int j = i * i ; j <= N ; j += i ) arr [ j ] = 1 ; long runningPrimeSum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] == 0 ) runningPrimeSum += i ; dp [ i ] = runningPrimeSum ; } }
int fnMod ( int n ) { int rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; }
int MinimumMoves ( int a [ ] , int n , int x ) { int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { int p = ( a [ i - 1 ] - a [ i ] ) / x + 1 ; ans += p ; a [ i ] += p * x ; } } return ans ; }
int SumOfDigits ( string str , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( int ) ( str [ i ] - '0' ) ; return sum ; }
bool isPrime ( int k ) { if ( k <= 1 ) return false ; for ( int i = 2 ; i < k ; i ++ ) if ( k % i == 0 ) return false ; return true ; }
int check ( int num , int k ) { int flag = 1 ; for ( int i = 2 ; i < k ; i ++ ) { if ( num % i == 0 ) flag = 0 ; } if ( flag == 1 ) { if ( num % k == 0 ) return 1 ; else return 0 ; } else return 0 ; }
int findCount ( int a , int b , int k ) { int count = 0 ; if ( ! isPrime ( k ) ) return 0 ; else { int ans ; for ( int i = a ; i <= b ; i ++ ) { ans = check ( i , k ) ; if ( ans == 1 ) count ++ ; else continue ; } } return count ; }
int findMinEqualSums ( int a [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; } int sum1 = 0 , sum2 = 0 ; int min = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { sum1 += a [ i ] ; sum2 = sum - sum1 ; if ( abs ( sum1 - sum2 ) < min ) { min = abs ( sum1 - sum2 ) ; } if ( min == 0 ) { break ; } } return min ; }
void SieveOfEratosthenes ( ) { bool prime [ MAX ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( prime [ p ] ) arr . push_back ( p ) ; }
bool isEuclid ( long n ) { long long product = 1 ; int i = 0 ; while ( product < n ) { product = product * arr [ i ] ; if ( product + 1 == n ) return true ; i ++ ; } return false ; }
bool isPowerOfTwo ( int n ) { return ( n && ! ( n & ( n - 1 ) ) ) ; }
int NumberOfSolutions ( int x , int y , int z , int n ) { int ans = 0 ; for ( int i = 0 ; i <= x ; i ++ ) { for ( int j = 0 ; j <= y ; j ++ ) { int temp = n - i - j ; if ( temp >= 0 ) { temp = min ( temp , z ) ; ans += temp + 1 ; } } } return ans ; }
int solve ( int n ) { int count = 0 , num = 1 ; long long int sum = 0 ; while ( count < n ) { if ( prime [ num ] ) { sum += num ; count ++ ; } num ++ ; } return sum ; }
long fact ( const int & p ) { if ( p <= 1 ) return 1 ; return p * fact ( p - 1 ) ; }
int findNum ( int n , int a , int b ) { int result = 0 ; int aCount = 0 ; int bCount = 0 ; return findNumUtil ( result , a , aCount , b , bCount , n ) ; }
void findkth ( int n , int k ) { vector < int > v1 ; vector < int > v2 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { v1 . push_back ( i ) ; if ( i != sqrt ( n ) ) v2 . push_back ( n / i ) ; } } reverse ( v2 . begin ( ) , v2 . end ( ) ) ; if ( k > ( v1 . size ( ) + v2 . size ( ) ) ) cout << "Doesn't Exist" ; else { if ( k <= v1 . size ( ) ) cout << v1 [ k - 1 ] ; else cout << v2 [ k - v1 . size ( ) - 1 ] ; } }
int NumberOfSolutions ( int a , int b , int c , int d ) { int ans = 0 ; for ( int i = a ; i <= b ; i ++ ) if ( d >= max ( c , i + 1 ) ) ans += d - max ( c , i + 1 ) + 1 ; return ans ; }
int CountDigits ( int n ) { if ( n == 1 ) return 1 ; double sum = 0 ; for ( int i = 2 ; i <= n ; ++ i ) { sum += ( double ) log ( i ) / ( double ) log ( 10 ) ; } sum *= ( double ) n ; }
string findNumber ( int n , int d ) { string ans = "" ; if ( d != 10 ) { ans += to_string ( d ) ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } else { if ( n == 1 ) ans += "Impossible" ; else { ans += '1' ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } } return ans ; }
void countDigits ( double val , long arr [ ] ) { while ( ( long ) val > 0 ) { long digit = ( long ) val % 10 ; arr [ ( int ) digit ] ++ ; val = ( long ) val / 10 ; } return ; }
void countFrequency ( int x , int n ) { long freq_count [ 10 ] = { 0 } ; for ( int i = 1 ; i <= n ; i ++ ) { double val = pow ( ( double ) x , ( double ) i ) ; countDigits ( val , freq_count ) ; } for ( int i = 0 ; i <= 9 ; i ++ ) { cout << freq_count [ i ] << " " ; } }
void form_sieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( int j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } }
int nthTerm ( int n ) { return pow ( n , 2 ) + 4 * n ; }
int NthTerm ( long long n ) { long long x = ( 3 * n * n ) % mod ; return ( x - n + mod ) % mod ; }
void PowerOfTwo ( ) { int x = 1 ; for ( int i = 0 ; i < 31 ; i ++ ) { power [ i ] = x ; x *= 2 ; } pre [ 0 ] = 1 ; for ( int i = 1 ; i < 31 ; i ++ ) pre [ i ] = pre [ i - 1 ] + power [ i ] ; }
int Sum ( int n ) { int ans = n * ( n + 1 ) / 2 ; for ( int i = 0 ; i < 31 ; i ++ ) { if ( power [ i ] > n ) { ans -= 2 * pre [ i - 1 ] ; break ; } } return ans ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
bool checkSemiPrime ( int n ) { int i = 0 ; while ( arr [ i ] <= n / 2 ) { if ( sprime [ n - arr [ i ] ] ) { return true ; } i ++ ; } return false ; }
int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 3 ) ) * ( 2 * 3 + ( N / 3 - 1 ) * 3 ) / 2 ; S2 = ( ( N / 4 ) ) * ( 2 * 4 + ( N / 4 - 1 ) * 4 ) / 2 ; S3 = ( ( N / 12 ) ) * ( 2 * 12 + ( N / 12 - 1 ) * 12 ) / 2 ; return S1 + S2 - S3 ; }
long long nextGreater ( long long N ) { long long power_of_2 = 1 , shift_count = 0 ; while ( true ) { if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) break ; shift_count ++ ; power_of_2 = power_of_2 * 2 ; } return ( N + power_of_2 ) ; }
float area ( float r ) { if ( r < 0 ) return -1 ; float area = 3.14 * pow ( r / ( 2 * sqrt ( 2 ) ) , 2 ) ; return area ; }
float area ( float a ) { if ( a < 0 ) return -1 ; float area = pow ( ( a * sqrt ( 3 ) ) / ( sqrt ( 2 ) ) , 2 ) ; return area ; }
void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < N ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < N ; i += p ) prime [ i ] = false ; } } }
int almostPrimes ( int n ) { int ans = 0 ; for ( int i = 6 ; i <= n ; i ++ ) { int c = 0 ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { if ( j * j == i ) { if ( prime [ j ] ) c ++ ; } else { if ( prime [ j ] ) c ++ ; if ( prime [ i / j ] ) c ++ ; } } } if ( c == 2 ) ans ++ ; } return ans ; }
float heightCalculate ( int H , int n , int m ) { float N = n * 1.0 ; float M = m * 1.0 ; float h = H * sqrt ( N / ( N + M ) ) ; return h ; }
int numberOfSolutions ( int n ) { int c = 0 ; for ( int x = 0 ; x <= n ; ++ x ) if ( n == x + n ^ x ) ++ c ; return c ; }
int findNumber ( int n ) { for ( int i = n - 1 ; > = 0 ; i -- ) { int count [ 10 ] = { 0 } ; int x = i ; int count1 = 0 , count2 = 0 ; while ( x ) { count [ x % 10 ] ++ ; x /= 10 ; count1 ++ ; } for ( int j = 0 ; j < 10 ; j ++ ) { if ( count [ j ] == 1 ) count2 ++ ; } if ( count1 == count2 ) return i ; } }
bool isprime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) if ( x % i == 0 ) return false ; return true ; }
bool isNSqMinusnMSqPrime ( int m , int n ) { if ( n - m == 1 and isprime ( m + n ) ) return true ; else return false ; }
int countNumbers ( int N ) { return ( pow ( 10 , N ) - pow ( 8 , N ) ) / 2 ; }
void buildPrefix ( ) { bool prime [ MAX + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } prefix [ 0 ] = prefix [ 1 ] = 0 ; for ( int p = 2 ; p <= MAX ; p ++ ) { prefix [ p ] = prefix [ p - 1 ] ; if ( prime [ p ] ) prefix [ p ] += p ; } }
int sumPrimeRange ( int L , int R ) { buildPrefix ( ) ; return prefix [ R ] - prefix [ L - 1 ] ; }
int findPosition ( int n , int f , int b ) { return n - max ( f + 1 , n - b ) + 1 ; }
int nthOdd ( int n ) { return ( 2 * n - 1 ) ; }
int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; }
int countSolutions ( int a ) { int count = __builtin_popcount ( a ) ; count = pow ( 2 , count ) ; return count ; }
bool isPermutation ( struct Node * first , struct Node * second ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; struct Node * temp1 = first ; while ( temp1 != NULL ) { sum1 += temp1 -> data ; mul1 *= temp1 -> data ; temp1 = temp1 -> next ; } struct Node * temp2 = second ; while ( temp2 != NULL ) { sum2 += temp2 -> data ; mul2 *= temp2 -> data ; temp2 = temp2 -> next ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; }
bool SieveOfEratosthenes ( int n , bool isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } }
void findPrimePair ( int n ) { int flag = 0 ; bool isPrime [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ; for ( int i = 2 ; i < n ; i ++ ) { int x = n / i ; if ( isPrime [ i ] && isPrime [ x ] and x != i and x * i == n ) { cout << i << " " << x ; flag = 1 ; return ; } } if ( ! flag ) cout << "No such pair found" ; }
void solveProportion ( int a , int b1 , int b2 , int c ) { int A = a * b2 ; int B = b1 * b2 ; int C = b1 * c ; int gcd = __gcd ( __gcd ( A , B ) , C ) ; cout << A / gcd << ":" << B / gcd << ":" << C / gcd ; }
int nthTerm ( int n ) { return 2 * pow ( n , 2 ) + n - 3 ; }
int nthTerm ( int n ) { return 5 * pow ( n , 2 ) - 5 * n ; }
int nthTerm ( int n ) { return 3 * pow ( n , 2 ) + 2 * n - 5 ; }
int nthTerm ( int n ) { return 2 * pow ( n , 2 ) + 3 * n - 5 ; }
int nthTerm ( int n ) { return 3 * pow ( n , 2 ) - 4 * n + 2 ; }
int nthTerm ( int n ) { return 4 * pow ( n , 2 ) - 3 * n + 2 ; }
bool isProduct ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i ; ++ cnt ; } } if ( num > 1 ) ++ cnt ; return cnt == 2 ; }
void findNumbers ( int N ) { vector < int > vec ; for ( int i = 1 ; i <= N ; i ++ ) { if ( isProduct ( i ) && ! isPerfectSquare ( i ) ) { vec . push_back ( i ) ; } } for ( int i = 0 ; i < vec . size ( ) ; i ++ ) { cout << vec [ i ] << " " ; } }
int countDivisors ( int n , int k ) { int count = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 && i % k == 0 ) { count ++ ; } } return count ; }
int nthTerm ( int n ) { return 2 * pow ( n , 3 ) + pow ( n , 2 ) ; }
int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + pow ( ( n * ( n + 1 ) / 2 ) , 2 ) ; }
float volume ( float r , float h ) { return ( float ( 1 ) / float ( 3 ) ) * pi * r * r * h ; }
int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }
int maxDistance ( int arr [ ] , int n ) { unordered_map < int , int > mp ; int max_dist = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . find ( arr [ i ] ) == mp . end ( ) ) mp [ arr [ i ] ] = i ; else max_dist = max ( max_dist , i - mp [ arr [ i ] ] ) ; } return max_dist ; }
int calculateSum ( int n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; }
int nthTerm ( int n ) { return 2 * pow ( n , 2 ) - n - 1 ; }
int nthTerm ( int n ) { return 6 * pow ( n , 2 ) - 4 * n - 2 ; }
int nthTerm ( int n ) { return 4 * pow ( n , 2 ) - 7 * n + 3 ; }
int nthTerm ( int n ) { return pow ( n , 2 ) + 2 * n + 2 ; }
void checkSolution ( int a , int b , int c ) { if ( ( ( b * b ) - ( 4 * a * c ) ) > 0 ) cout << "2 solutions" ; else if ( ( ( b * b ) - ( 4 * a * c ) ) == 0 ) cout << "1 solution" ; else cout << "No solutions" ; }
long Bytes ( int kilobytes ) { long Bytes = 0 ; Bytes = kilobytes * 1024 ; return Bytes ; }
int NthTerm ( long long n ) { long long x = ( 2 * n * n ) % mod ; return ( x - n + mod ) % mod ; }
int sum ( int n ) { int ans = ( n * ( n - 1 ) ) / 2 ; return ans ; }
long long int getNthTerm ( long long int N ) { return ( pow ( N , 2 ) + N + 1 ) ; }
int findSum ( int N ) { return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ; }
int getNthTerm ( long long int N ) { return 4 * pow ( N , 2 ) - 3 * N + 2 ; }
double findCosNTheta ( double sinTheta , ll n ) { double cosTheta = sqrt ( 1 - sinTheta * sinTheta ) ; double ans = 0 ; ll toggle = 1 ; for ( int i = 1 ; i <= n ; i += 2 ) { ans = ans + nCr [ n ] [ i ] * pow ( cosTheta , n - i ) * pow ( sinTheta , i ) * toggle ; toggle = toggle * -1 ; } return ans ; }
ll findSum ( int n ) { ll sum2 , sum5 , sum10 ; sum2 = ( ( n / 2 ) * ( 4 + ( n / 2 - 1 ) * 2 ) ) / 2 ; sum5 = ( ( n / 5 ) * ( 10 + ( n / 5 - 1 ) * 5 ) ) / 2 ; sum10 = ( ( n / 10 ) * ( 20 + ( n / 10 - 1 ) * 10 ) ) / 2 ; return sum2 + sum5 - sum10 ; }
int nthTerm ( int N ) { return ( ( 3 * N * N ) - ( 6 * N ) + 2 ) ; }
int nthTerm ( int N ) { return ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ; }
void binomial ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = nCr [ i - 1 ] [ j ] + nCr [ i - 1 ] [ j - 1 ] ; } } }
double findTanNTheta ( double tanTheta , ll n ) { double ans = 0 , numerator = 0 , denominator = 0 ; ll toggle = 1 ; for ( int i = 1 ; i <= n ; i += 2 ) { numerator = numerator + nCr [ n ] [ i ] * pow ( tanTheta , i ) * toggle ; toggle = toggle * -1 ; } denominator = 1 ; toggle = -1 ; for ( int i = 2 ; i <= n ; i += 2 ) { numerator = numerator + nCr [ n ] [ i ] * pow ( tanTheta , i ) * toggle ; toggle = toggle * -1 ; } ans = numerator / denominator ; return ans ; }
int product ( int n ) { vector < int > v [ n + 100 ] ; factors ( n + 100 , v ) ; if ( n % 4 == 0 ) { int x = n / 4 ; x *= x ; return x * x ; } else { if ( isPrime [ n ] ) return -1 ; else { int ans = -1 ; if ( v [ n ] . size ( ) > 2 ) { int fac = v [ n ] [ v [ n ] . size ( ) - 3 ] ; for ( int i = v [ n ] . size ( ) - 1 ; i >= 0 ; i -- ) { for ( int j = v [ n ] . size ( ) - 1 ; j >= 0 ; j -- ) { if ( ( fac * 2 ) + ( v [ n ] [ j ] + v [ n ] [ i ] ) == n ) ans = max ( ans , fac * fac * v [ n ] [ j ] * v [ n ] [ i ] ) ; } } return ans ; } } } }
bool arePermutations ( int a [ ] , int b [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] ; mul1 *= a [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { sum2 += b [ i ] ; mul2 *= b [ i ] ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; }
void binomial ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = nCr [ i - 1 ] [ j ] + nCr [ i - 1 ] [ j - 1 ] ; } } }
double findCosnTheta ( double cosTheta , int n ) { double sinTheta = sqrt ( 1 - cosTheta * cosTheta ) ; double ans = 0 ; int toggle = 1 ; for ( int i = 0 ; i <= n ; i += 2 ) { ans = ans + nCr [ n ] [ i ] * pow ( cosTheta , n - i ) * pow ( sinTheta , i ) * toggle ; toggle = toggle * -1 ; } return ans ; }
float CalculateRatio ( float m , float n ) { return ( 2 * m - 1 ) / ( 2 * n - 1 ) ; }
ll power ( ll x , unsigned long long y , ll p ) { ll res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
ll sumProd ( ll n , ll t ) { ll dino = power ( t + 1 , MOD - 2 , MOD ) ; unsigned long long ans = 1 ; for ( ll i = n + t + 1 ; i > n ; -- i ) ans = ( ans % MOD * i % MOD ) % MOD ; ll tfact = 1 ; for ( int i = 1 ; i <= t ; ++ i ) tfact = ( tfact * i ) % MOD ; ans = ans * dino - tfact + MOD ; return ans % MOD ; }
int sumOfDigitsSingle ( int x ) { int ans = 0 ; while ( x ) { ans += x % 10 ; x /= 10 ; } return ans ; }
int sumOfDigitsTwoParts ( int N ) { int A = closest ( N ) ; return sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) ; }
int nextPerfectCube ( int N ) { int nextN = floor ( cbrt ( N ) ) + 1 ; return nextN * nextN * nextN ; }
double findSum ( ll n ) { return sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; }
int sum ( int x , int y , int n ) { int sum1 = ( pow ( x , 2 ) * ( pow ( x , 2 * n ) - 1 ) ) / ( pow ( x , 2 ) - 1 ) ; int sum2 = ( x * y * ( pow ( x , n ) * pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ; return sum1 + sum2 ; }
int powerDigitSum ( int a , int n ) { int res = 1 ; while ( n ) { if ( n % 2 == 1 ) { res = res * digSum ( a ) ; res = digSum ( res ) ; } a = digSum ( digSum ( a ) * digSum ( a ) ) ; n /= 2 ; } return res ; }
void printPair ( int g , int l ) { cout << g << " " << l ; }
int mostFrequent ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int max_count = 1 , res = arr [ 0 ] , curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ n - 1 ] ; } return res ; }
int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
long long int power ( long long int a , long long int b ) { long long int res = 1 ; while ( b ) { if ( b & 1 ) { res *= a ; res %= mod ; } b /= 2 ; a *= a ; a %= mod ; } return res ; }
long long int minPlayer ( long long int n , long long int k ) { long long int num = ( ( power ( k , n ) - 1 ) + mod ) % mod ; long long int den = ( power ( k - 1 , mod - 2 ) + mod ) % mod ; long long int ans = ( ( ( num * den ) % mod ) * k ) % mod ; return ans ; }
void sieve ( int N ) { prime [ 0 ] = prime [ 1 ] = false ; for ( int i = 2 ; i <= N ; i ++ ) { if ( prime [ i ] ) { for ( int j = 2 ; i * j <= N ; j ++ ) prime [ i * j ] = false ; } } }
int countLogNeeded ( int N ) { int count = 0 ; sieve ( N ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( prime [ i ] ) count ++ ; } return count ; }
float rmsValue ( int arr [ ] , int n ) { int square = 0 ; float mean = 0.0 , root = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) { square += pow ( arr [ i ] , 2 ) ; } mean = ( square / ( float ) ( n ) ) ; root = sqrt ( mean ) ; return root ; }
float Mixture ( int X , int Y , int Z ) { float result = 0.0 , result1 = 0.0 ; result1 = ( ( X - Y ) / ( float ) X ) ; result = pow ( result1 , Z ) ; result = result * X ; return result ; }
int coin ( int totalRupees , int X , int Y , int Z ) { float one = 0 , fifty = 0 , twentyfive = 0 , result = 0 , total = 0 ; one = X * 1 ; fifty = ( ( Y * 1 ) / 2.0 ) ; twentyfive = ( ( Z * 1 ) / 4.0 ) ; total = one + fifty + twentyfive ; result = ( ( totalRupees ) / total ) ; return result ; }
float sumOfSeries ( int x , int k ) { return ( float ( x ) / 81 ) * ( 9 * k - 1 + pow ( 10 , ( -1 ) * k ) ) ; }
int calculateSum ( int n ) { int a1 = 1 , a2 = 2 ; int r = 2 ; int d = 1 ; return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( pow ( r , n ) - 1 ) / ( r - 1 ) ; }
int findProduct ( int n ) { int product = -1 ; int si = factors . size ( ) ; for ( int i = 0 ; i < si ; i ++ ) for ( int j = 0 ; j < si ; j ++ ) for ( int k = 0 ; k < si ; k ++ ) for ( int l = 0 ; l < si ; l ++ ) { int s = factors [ i ] + factors [ j ] + factors [ k ] + factors [ l ] ; if ( s == n ) { int p = factors [ i ] * factors [ j ] * factors [ k ] * factors [ l ] ; if ( p > product ) product = p ; } } return product ; }
int modExp ( int a , int b ) { int result = 1 ; while ( b > 0 ) { if ( b & 1 ) result = result * a ; a = a * a ; b /= 2 ; } return result ; }
int check ( int num ) { if ( num & 1 num < 3 ) return -1 ; else if ( num % 4 == 0 ) return modExp ( num / 4 , 4 ) ; else if ( num % 6 == 0 ) return modExp ( num / 3 , 2 ) * modExp ( num / 6 , 2 ) ; else if ( num % 10 == 0 ) return modExp ( num / 5 , 2 ) * ( num / 10 ) * ( num / 2 ) ; else return -1 ; }
void sieveOfEratosthenes ( int N , int s [ ] ) { vector < bool > prime ( N + 1 , false ) ; for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= N ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } }
int findSum ( int N ) { int s [ N + 1 ] ; int ans = 1 ; sieveOfEratosthenes ( N , s ) ; int currFactor = s [ N ] ; int power = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( currFactor == s [ N ] ) { power ++ ; continue ; } int sum = 0 ; for ( int i = 0 ; i <= power ; i ++ ) sum += pow ( currFactor , i ) ; ans *= sum ; currFactor = s [ N ] ; power = 1 ; } return ans ; }
int countMultiples ( int n ) { int multiple [ ] = { 2 , 3 , 5 } ; int count = 0 , mask = pow ( 2 , 3 ) ; for ( int i = 1 ; i < mask ; i ++ ) { int prod = 1 ; for ( int j = 0 ; j < 3 ; j ++ ) { if ( i & 1 << j ) prod = prod * multiple [ j ] ; } if ( __builtin_popcount ( i ) % 2 == 1 ) count = count + n / prod ; else count = count - n / prod ; } return count ; }
int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; }
bool isDivisible ( long long int n ) { while ( n / 100 ) { int d = n % 10 ; n /= 10 ; n -= d * 5 ; } return ( n % 17 == 0 ) ; }
int calculateSum ( int n ) { return ( pow ( 2 , n + 1 ) + n - 2 ) ; }
unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
int removeElement ( unsigned int n ) { if ( n == 1 n == 2 ) return 0 ; unsigned int a = nextPowerOf2 ( n ) ; if ( n == a n == a - 1 ) return 1 ; else if ( n == a - 2 ) return 0 ; else if ( n % 2 == 0 ) return 1 ; else return 2 ; }
int calculateSum ( int n ) { return ( n * ( 4 * n * n + 6 * n - 1 ) / 3 ) ; }
int bridge_length ( int trainLength , int Speed , int Time ) { return ( ( Time * Speed ) - trainLength ) ; }
int findN ( int k ) { int ans ; if ( k == 0 ) ans = 3 ; if ( k == 1 ) ans = 1 ; else if ( k % 4 == 0 ) ans = k ; else if ( k % 4 == 3 ) ans = k - 1 ; else ans = -1 ; return ans ; }
long repeatedSum ( long n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
long repeatedProduct ( long n ) { long prod = 1 ; while ( n > 0 prod > 9 ) { if ( n == 0 ) { n = prod ; prod = 1 ; } prod *= n % 10 ; n /= 10 ; } return prod ; }
long maxSumProduct ( long N ) { if ( N < 10 ) return N ; return max ( repeatedSum ( N ) , repeatedProduct ( N ) ) ; }
int Circular ( int n ) { int Result = 1 ; while ( n > 0 ) { Result = Result * n ; n -- ; } return Result ; }
float Time ( float arr [ ] , int n , int Emptypipe ) { float fill = 0 ; for ( int i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / ( float ) Emptypipe ) ; return 1 / fill ; }
void smallestSubsegment ( int a [ ] , int n ) { unordered_map < int , int > left ; unordered_map < int , int > count ; int mx = 0 ; int mn , strindex ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( count [ x ] == 0 ) { left [ x ] = i ; count [ x ] = 1 ; } else count [ x ] ++ ; if ( count [ x ] > mx ) { mx = count [ x ] ; mn = i - left [ x ] + 1 ; strindex = left [ x ] ; } else if ( count [ x ] == mx && i - left [ x ] + 1 < mn ) { mn = i - left [ x ] + 1 ; strindex = left [ x ] ; } } for ( int i = strindex ; i < strindex + mn ; i ++ ) cout << a [ i ] << " " ; }
long long modInv ( long long x ) { long long n = MOD - 2 ; long long result = 1 ; while ( n ) { if ( n & 1 ) result = result * x % MOD ; x = x * x % MOD ; n = n / 2 ; } return result ; }
long long getSum ( long long n , long long k ) { long long ans = 1 ; for ( long long i = n + 1 ; i > n - k ; i -- ) ans = ans * i % MOD ; ans = ans * modInv ( k + 1 ) % MOD ; return ans ; }
int calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; int area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; }
void printCombination ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( int j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( int k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { cout << i << " " << j << " " << k ; return ; } } } } } } }
void printCombination ( int n ) { cout << 1 << " " ; if ( ( n - 2 ) % 3 == 0 ) cout << 2 << " " << n - 3 ; else cout << 1 << " " << n - 2 ; }
int Loss ( int costPrice , int sellingPrice ) { int Loss = ( costPrice - sellingPrice ) ; return Loss ; }
bool isPalindrome ( int n ) { if ( n % 11 == 0 ) { return true ; } return false ; }
int percent ( int a , int b ) { float result = 0 ; result = ( ( b - a ) * 100 ) / a ; return result ; }
int nextPerfectSquare ( int N ) { int nextN = floor ( sqrt ( N ) ) + 1 ; return nextN * nextN ; }
void Smallest_prime_factor ( ) { for ( int i = 1 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i <= MAXN ; i += 2 ) if ( spf [ i ] == i ) for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; }
int Digit_Sum ( int copy ) { int d = 0 ; while ( copy ) { d += copy % 10 ; copy /= 10 ; } return d ; }
void Sum_Of_All_Digits ( ) { for ( int n = 2 ; n < MAXN ; n ++ ) { sum_digits [ n ] = sum_digits [ n / spf [ n ] ] + Digit_Sum ( spf [ n ] ) ; if ( Digit_Sum ( n ) == sum_digits [ n ] ) isValid [ n ] = true ; } for ( int n = 2 ; n < MAXN ; n ++ ) { if ( isValid [ n ] ) ans [ n ] = 1 ; ans [ n ] += ans [ n - 1 ] ; } }
unsigned long int binomialCoeff ( unsigned int n , unsigned int k ) { unsigned long int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
unsigned long int catalan ( unsigned int n ) { unsigned long int c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
int isPrime ( int n ) { int i , c = 0 ; for ( i = 1 ; i < n / 2 ; i ++ ) { if ( n % i == 0 ) c ++ ; } if ( c == 1 ) return 1 ; else return 0 ; }
int prevComplement ( int n , int b ) { int maxDigit , maxNum = 0 , digits = 0 , num = n ; while ( n != 0 ) { digits ++ ; n = n / 10 ; } maxDigit = b - 1 ; while ( digits -- ) { maxNum = maxNum * 10 + maxDigit ; } return maxNum - num ; }
int complement ( int n , int b ) { return prevComplement ( n , b ) + 1 ; }
bool isFascinating ( int num ) { int freq [ 10 ] = { 0 } ; string val = "" + to_string ( num ) + to_string ( num * 2 ) + to_string ( num * 3 ) ; for ( int i = 0 ; i < val . length ( ) ; i ++ ) { int digit = val [ i ] - '0' ; if ( freq [ digit ] and digit != 0 > 0 ) return false ; else freq [ digit ] ++ ; } for ( int i = 1 ; i < 10 ; i ++ ) { if ( freq [ i ] == 0 ) return false ; } return true ; }
int binomial_coefficient ( int n , int m ) { int res = 1 ; if ( m > n - m ) m = n - m ; for ( int i = 0 ; i < m ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
void computeTotient ( ) { for ( int i = 1 ; i < N ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p < N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i < N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } }
void CoPrimes ( ) { computeTotient ( ) ; for ( int i = 1 ; i < N ; i ++ ) S [ i ] = S [ i - 1 ] + phi [ i ] ; }
bool isPowerOfTwo ( int n ) { return ( n && ! ( n & ( n - 1 ) ) ) ; }
int previousPowerOfTwo ( int n ) { while ( n & n - 1 ) { n = n & n - 1 ; } return n ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int MaximumDivisors ( int X , int Y ) { int arr [ Y - X + 1 ] ; memset ( arr , 0 , sizeof ( arr ) ) ; int mx = INT_MIN ; int cnt = 0 ; for ( int i = 1 ; i * i <= Y ; i ++ ) { int sq = i * i ; int first_divisible ; if ( ( X / i ) * i >= X ) first_divisible = ( X / i ) * i ; else first_divisible = ( X / i + 1 ) * i ; for ( int j = first_divisible ; j <= Y ; j += i ) { if ( j < sq ) continue ; else if ( j == sq ) arr [ j - X ] ++ ; else arr [ j - X ] += 2 ; } } for ( int i = X ; i <= Y ; i ++ ) { if ( arr [ i - X ] > mx ) { cnt = 1 ; mx = arr [ i - X ] ; } else if ( arr [ i - X ] == mx ) cnt ++ ; } return cnt ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
int NearestElement ( int A , int D , int P ) { if ( A == 0 ) return 0 ; else if ( D == 0 ) return -1 ; else { int X = power ( D , P - 2 , P ) ; return ( X * ( P - A ) ) % P ; } }
int binaryToDecimal ( string n ) { string num = n ; int dec_value = 0 ; int base = 1 ; int len = num . length ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( num [ i ] == '1' ) dec_value += base ; base = base * 2 ; } return dec_value ; }
int numberSequence ( int n ) { if ( n == 1 ) return 1 ; string s = "" ; for ( int i = 1 ; i < n ; i ++ ) s += '1' ; s += '0' ; for ( int i = 1 ; i <= n ; i ++ ) s += '1' ; int num = binaryToDecimal ( s ) ; return num ; }
int numberSequence ( int n ) { int num = pow ( 4 , n ) - pow ( 2 , n ) - 1 ; return num ; }
int complement ( int num ) { int i , len = 0 , temp , comp ; temp = num ; while ( 1 ) { len ++ ; num = num / 10 ; if ( abs ( num ) == 0 ) break ; } num = temp ; comp = pow ( 10 , len ) - num ; return comp ; }
int calculate ( int * array , int size ) { int count = 0 ; for ( int i = 0 ; i < size ; i ++ ) if ( array [ i ] % 2 == 0 && array [ i ] != 0 && array [ i ] != 2 ) count ++ ; return count ; }
int prime ( int num ) { int i , flag = 0 ; for ( i = 2 ; i <= num / 2 ; i ++ ) { if ( num % i == 0 ) { flag = 1 ; break ; } } if ( flag == 0 ) return 1 ; else return 0 ; }
void print_alternate_prime ( int n ) { int counter = 0 ; for ( int num = 2 ; num < n ; num ++ ) { if ( prime ( num ) == 1 ) { if ( counter % 2 == 0 ) cout << num << " " ; counter ++ ; } } }
void SieveOfEratosthenes ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } bool flag = true ; for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { if ( flag ) { cout << p << " " ; flag = false ; } else { flag = true ; } } } }
bool findGreater ( int x , int y ) { if ( x > y ) { return false ; } else { return true ; } }
int max_profit ( int a [ ] , int b [ ] , int n , int fee ) { int i , j , profit ; int l , r , diff_day = 1 , sum = 0 ; b [ 0 ] = 0 ; b [ 1 ] = diff_day ; for ( i = 1 ; i < n ; i ++ ) { l = 0 ; r = diff_day ; sum = 0 ; for ( j = n - 1 ; j >= i ; j -- ) { profit = ( a [ r ] - a [ l ] ) - fee ; if ( profit > 0 ) { sum = sum + profit ; } l ++ ; r ++ ; } if ( b [ 0 ] < sum ) { b [ 0 ] = sum ; b [ 1 ] = diff_day ; } diff_day ++ ; } return 0 ; }
int binomialCoeff ( int x , int n , int k ) { int sum = 0 , term = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { term *= x - i + 1 ; term /= i ; sum += term ; if ( sum > k ) return sum ; } return sum ; }
int minTrials ( int n , int k ) { int low = 1 , high = k ; while ( low < high ) { int mid = ( low + high ) / 2 ; if ( binomialCoeff ( mid , n , k ) < k ) low = mid + 1 ; else high = mid ; } return low ; }
void preprocess ( ) { for ( int i = 1 ; i < N ; i ++ ) { int num = i ; for ( int j = 2 ; j <= sqrt ( num ) ; j ++ ) { if ( num % j == 0 ) { v [ i ] . push_back ( j ) ; while ( num % j == 0 ) { num = num / j ; } } } if ( num > 2 ) v [ i ] . push_back ( num ) ; } }
int query ( int number , int n ) { return v [ number ] [ n - 1 ] ; }
int getsum ( int a ) { int r = 0 , sum = 0 ; while ( a > 0 ) { r = a % 10 ; sum = sum + r ; a = a / 10 ; } return sum ; }
ll boost_hyperfactorial ( ll num ) { ll val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { val = val * pow ( i , i ) ; } return val ; }
int1024_t boost_hyperfactorial ( int num ) { int1024_t val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; }
int power ( int x , int y , int p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
int findOddPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ( A [ i ] % 2 == 1 ) ) count ++ ; return count * ( count - 1 ) / 2 ; }
int summ ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
void printDigitalRoot ( int n ) { int maxi = 1 ; int dig = 1 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { int d1 = summ ( n / i ) ; int d2 = summ ( i ) ; if ( d1 > maxi ) { dig = n / i ; maxi = d1 ; } if ( d2 > maxi ) { dig = i ; maxi = d2 ; } if ( d1 == maxi ) { if ( dig < ( n / i ) ) { dig = n / i ; maxi = d1 ; } } if ( d2 == maxi ) { if ( dig < i ) { dig = i ; maxi = d2 ; } } } } cout << dig << " " << maxi << endl ; }
int gcd ( int a , int b ) { if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
bool isSurd ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int j = i ; while ( j < n ) j = j * i ; if ( j == n ) return false ; } return true ; }
int LastTwoDigit ( long long int num ) { int one = num % 10 ; num /= 10 ; int tens = num % 10 ; tens *= 10 ; num = tens + one ; return num ; }
int power ( long long int x , long long int y , long long int p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
ll modPower ( ll x , ll y , ll p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
ll gcdPow ( ll a , ll n , ll c ) { if ( a % c == 0 ) return c ; ll modexpo = modPower ( a , n , c ) ; return gcd ( modexpo , c ) ; }
int countOddSum ( int ar [ ] , int n ) { int temp [ 2 ] = { 1 , 0 } ; int result = 0 , val = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { val = ( ( val + ar [ i ] ) % 2 + 2 ) % 2 ; temp [ val ] ++ ; } result = ( temp [ 0 ] * temp [ 1 ] ) ; return ( result ) ; }
int countOddSum ( int a [ ] , int n ) { int odd = 0 , c_odd = 0 , result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] & 1 ) { odd = ! odd ; } if ( odd ) { c_odd ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { result += c_odd ; if ( a [ i ] & 1 ) { c_odd = ( n - i - c_odd ) ; } } return result ; }
void findNthRoot ( double x , int n ) { double low , high ; if ( x >= 0 and x <= 1 ) { low = x ; high = 1 ; } else { low = 1 ; high = x ; } double epsilon = 0.00000001 ; double guess = ( low + high ) / 2 ; while ( abs ( ( pow ( guess , n ) ) - x ) >= epsilon ) { if ( pow ( guess , n ) > x ) { high = guess ; } else { low = guess ; } guess = ( low + high ) / 2 ; } cout << fixed << setprecision ( 16 ) << guess ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int SumOfPrimeDivisors ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 ) { if ( isPrime ( i ) ) sum += i ; } } return sum ; }
int Sum ( int N ) { int SumOfPrimeDivisors [ N + 1 ] = { 0 } ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! SumOfPrimeDivisors [ i ] ) { for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int SumOfPrimeDivisors ( int n ) { int sum = 0 ; int root_n = ( int ) sqrt ( n ) ; for ( int i = 1 ; i <= root_n ; i ++ ) { if ( n % i == 0 ) { if ( i == n / i && isPrime ( i ) ) { sum += i ; } else { if ( isPrime ( i ) ) { sum += i ; } if ( isPrime ( n / i ) ) { sum += ( n / i ) ; } } } } return sum ; }
int rangesum ( int n , int l , int r ) { int arr [ n ] ; int c = 1 , i = 0 ; while ( c <= n ) { arr [ i ++ ] = c ; c += 2 ; } c = 2 ; while ( c <= n ) { arr [ i ++ ] = c ; c += 2 ; } int sum = 0 ; for ( i = l - 1 ; i < r ; i ++ ) { sum += arr [ i ] ; } return sum ; }
int sumeven ( int n , int l , int r ) { int sum = 0 ; int mid = n / 2 ; if ( r <= mid ) { int first = ( 2 * l - 1 ) ; int last = ( 2 * r - 1 ) ; int no_of_terms = r - l + 1 ; sum = ( ( no_of_terms ) * ( ( first + last ) ) ) / 2 ; } else if ( l >= mid ) { int first = ( 2 * ( l - n / 2 ) ) ; int last = ( 2 * ( r - n / 2 ) ) ; int no_of_terms = r - l + 1 ; sum = ( ( no_of_terms ) * ( ( first + last ) ) ) / 2 ; } else { int sumleft = 0 , sumright = 0 ; int first_term1 = ( 2 * l - 1 ) ; int last_term1 = ( 2 * ( n / 2 ) - 1 ) ; int no_of_terms1 = n / 2 - l + 1 ; sumleft = ( ( no_of_terms1 ) * ( ( first_term1 + last_term1 ) ) ) / 2 ; int first_term2 = 2 ; int last_term2 = ( 2 * ( r - n / 2 ) ) ; int no_of_terms2 = r - mid ; sumright = ( ( no_of_terms2 ) * ( ( first_term2 + last_term2 ) ) ) / 2 ; sum = ( sumleft + sumright ) ; } return sum ; }
int sumodd ( int n , int l , int r ) { int mid = n / 2 + 1 ; int sum = 0 ; if ( r <= mid ) { int first = ( 2 * l - 1 ) ; int last = ( 2 * r - 1 ) ; int no_of_terms = r - l + 1 ; sum = ( ( no_of_terms ) * ( ( first + last ) ) ) / 2 ; } else if ( l > mid ) { int first = ( 2 * ( l - mid ) ) ; int last = ( 2 * ( r - mid ) ) ; int no_of_terms = r - l + 1 ; sum = ( ( no_of_terms ) * ( ( first + last ) ) ) / 2 ; } else { int sumleft = 0 , sumright = 0 ; int first_term1 = ( 2 * l - 1 ) ; int last_term1 = ( 2 * mid - 1 ) ; int no_of_terms1 = mid - l + 1 ; sumleft = ( ( no_of_terms1 ) * ( ( first_term1 + last_term1 ) ) ) / 2 ; int first_term2 = 2 ; int last_term2 = ( 2 * ( r - mid ) ) ; int no_of_terms2 = r - mid ; sumright = ( ( no_of_terms2 ) * ( ( first_term2 + last_term2 ) ) ) / 2 ; sum = ( sumleft + sumright ) ; } return sum ; }
int rangesum ( int n , int l , int r ) { int sum = 0 ; if ( n % 2 == 0 ) return sumeven ( n , l , r ) ; else return sumodd ( n , l , r ) ; }
void groupElements ( int arr [ ] , int n ) { bool * visited = new bool [ n ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ i ] = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! visited [ i ] ) { cout << arr [ i ] << " " ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { cout << arr [ i ] << " " ; visited [ j ] = true ; } } } } delete [ ] visited ; }
float rainDayProbability ( int a [ ] , int n ) { float count = 0 , m ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; } m = count / n ; return m ; }
void distance ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { float d = sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) + pow ( z2 - z1 , 2 ) * 1.0 ) ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 2 ) ; cout << " Distance is " << d ; return ; }
bool DivisibleBy41 ( int first , int second , int c , int n ) { int digit [ n ] ; digit [ 0 ] = first ; digit [ 1 ] = second ; for ( int i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ; int ans = digit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ; if ( ans % 41 == 0 ) return true ; else return false ; }
int findTetrahedralNumber ( int n ) { return ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) ; }
void printSeries ( int n ) { int prev = 0 ; int curr ; for ( int i = 1 ; i <= n ; i ++ ) { curr = findTetrahedralNumber ( i ) ; curr = curr + prev ; cout << curr << " " ; prev = curr ; } }
void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = ( i * ( i + 1 ) * ( i + 2 ) * ( i + 3 ) / 24 ) ; cout << num << " " ; } }
long findTriangularNumber ( int n ) { return ( n * ( n + 1 ) ) / 2 ; }
void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) / 6 ; cout << num << " " ; } }
long long int calculateSum ( int n ) { long long int sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
long long int calculateSum ( int n ) { long long int sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; }
float findArea ( float a ) { float area ; area = 5 * sqrt ( 3 ) * a * a ; return area ; }
float findVolume ( float a ) { float volume ; volume = ( ( float ) 5 / 12 ) * ( 3 + sqrt ( 5 ) ) * a * a * a ; return volume ; }
int findNthNonSquare ( int n ) { long double x = ( long double ) n ; long double ans = x + floor ( 0.5 + sqrt ( x ) ) ; return ( int ) ans ; }
void count_even_odd ( int min , int max , int steps [ ] [ 2 ] ) { int a , b , even , odd ; bool beven = true , aeven = false ; int n = 2 ; for ( int i = 0 ; i < n ; i ++ ) { a = steps [ i ] [ 0 ] , b = steps [ i ] [ 1 ] ; if ( ! ( aeven a & 1 ) ) aeven = true ; if ( beven ) { if ( b & 1 ) beven = false ; } else if ( ! ( a & 1 ) ) { if ( ! ( b & 1 ) ) beven = true ; } else { if ( b & 1 ) beven = true ; } } if ( beven ) { even = ( int ) max / 2 - ( int ) ( min - 1 ) / 2 ; odd = 0 ; } else { even = ( int ) max / 2 - ( int ) ( min - 1 ) / 2 ; odd = 0 ; } if ( ! ( beven ^ aeven ) ) even += max - min + 1 - ( int ) max / 2 + ( int ) ( min - 1 ) / 2 ; else odd += max - min + 1 - ( int ) max / 2 + ( int ) ( min - 1 ) / 2 ; cout << "even = " << even << ", odd = " << odd << endl ; }
int getMaxOnes ( int n , int x ) { int zeroes = ( n / x ) ; zeroes = zeroes * zeroes ; int total = n * n ; int ans = total - zeroes ; return ans ; }
int ways ( int n ) { int first = 2 ; int second = 3 ; int res = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; }
int minimumOperations ( int a [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ a [ i ] ] += 1 ; int count = 0 ; for ( auto it = mp . begin ( ) ; it != mp . end ( ) ; it ++ ) { if ( ( * it ) . second > 1 ) count += ( * it ) . second - 1 ; } return count ; }
void findVolume ( float a , float h ) { float Volume ; Volume = 3 * sqrt ( 3 ) * a * a * h / 2 ; cout << "Volume: " << Volume ; }
long long int MinimumMail ( int n , int k , int x ) { ll m = ( n - 1 ) + ( ll ) ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + ( ll ) ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; }
int findAllSequence ( int N ) { if ( N % 2 == 0 ) { return pow ( 2 , N / 2 + 1 ) + pow ( 2 , N / 2 ) - 2 ; } else { return pow ( 2 , ( N + 1 ) / 2 ) + pow ( 2 , ( N + 1 ) / 2 ) - 2 ; } }
void computeTotient ( ) { for ( int i = 1 ; i <= N ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p <= N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i <= N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } }
long long power ( long long x , long long y , long long p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
long long calculate ( long long x , long long k , long long mod ) { long long arr [ N ] ; long long count = 0 ; while ( mod > 1 ) { arr [ count ++ ] = mod ; mod = phi [ mod ] ; } long long result = 1 ; long long loop = count + 1 ; arr [ count ] = 1 ; for ( int i = min ( k , loop ) - 1 ; i >= 0 ; i -- ) result = power ( x , result , arr [ i ] ) ; return result ; }
int countOnes ( int n ) { int count = 1 ; int rem = 1 ; while ( rem != 0 ) { rem = ( rem * 10 + 1 ) % n ; count ++ ; } return count ; }
void fibonacci ( int n ) { long long int fib ; for ( long long int i = 0 ; i < n ; i ++ ) { fib = ( pow ( ( 1 + sqrt ( 5 ) ) , i ) - pow ( ( 1 - sqrt ( 5 ) ) , i ) ) / ( pow ( 2 , i ) * sqrt ( 5 ) ) ; cout << fib << " " ; } }
int findLCM ( int a , int b ) { int lar = max ( a , b ) ; int small = min ( a , b ) ; for ( int i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } }
int center_hexadecagonal_num ( long int n ) { return 8 * n * n - 8 * n + 1 ; }
bool findNature ( int a , int b , int n ) { int seq [ MAX ] = { 0 } ; seq [ 0 ] = a ; seq [ 1 ] = b ; for ( int i = 2 ; i <= n ; i ++ ) seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ; return ( seq [ n ] & 1 ) ; }
bool findNature ( int a , int b , int n ) { if ( n == 0 ) return ( a & 1 ) ; if ( n == 1 ) return ( b & 1 ) ; if ( ! ( a & 1 ) ) { if ( ! ( b & 1 ) ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ! ( b & 1 ) ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } }
void check ( unsigned long long m , unsigned long long int n ) { double RHS = m * ( double ) log ( n ) ; double LHS = n * ( double ) log ( m ) ; if ( LHS > RHS ) cout << "m^n > n^m" ; else if ( LHS < RHS ) cout << "m^n < n^m" ; else cout << "m^n = n^m" ; }
int numberOfmeet ( int a , int b ) { int ans ; if ( a > b ) ans = a - b ; else ans = b - a ; if ( a < 0 ) a = a * ( -1 ) ; if ( b < 0 ) b = b * ( -1 ) ; return ans / gcd ( a , b ) ; }
void SieveOfEratosthenes ( vector < int > & primes ) { bool prime [ MAX ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( prime [ p ] ) primes . push_back ( p ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int maxDivisorRange ( int a , int b , int l , int h ) { int g = gcd ( a , b ) ; int res = -1 ; for ( int i = l ; i * i <= g && i <= h ; i ++ ) if ( g % i == 0 ) res = max ( { res , i , g / i } ) ; return res ; }
int findMaxGCD ( int arr [ ] , int n , int k ) { int high = * max_element ( arr , arr + n ) ; int divisors [ high + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++ ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ; } } } for ( int i = high ; i >= 1 ; i -- ) if ( divisors [ i ] >= k ) return i ; }
void primes ( int n ) { int i = 2 ; int j = 0 ; int result [ n ] ; int z = 0 ; while ( j < n ) { bool flag = true ; for ( int item = 2 ; item <= ( int ) ( i * 1 / 2 ) ; item ++ ) if ( i % item == 0 && i != item ) { flag = false ; break ; } if ( flag ) { result [ z ++ ] = i ; j += 1 ; } i += 1 ; } for ( i = 0 ; i < 5 ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) cout << result [ j ] ; cout << " " ; } }
int subtractOne ( int x ) { int m = 1 ; while ( ! ( x & m ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
int subtractOne ( int x ) { return ( ( x << 1 ) + ( ~ x ) ) ; }
unsigned int Log2n ( unsigned int n ) { return ( n > 1 ) ? 1 + Log2n ( n / 2 ) : 0 ; }
bool isPowerOfd ( unsigned int n , unsigned int d ) { int count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % ( Log2n ( d ) ) == 0 ) ; } return false ; }
void meanVector ( int mat [ rows ] [ cols ] ) { cout << "[ " ; for ( int i = 0 ; i < rows ; i ++ ) { double mean = 0.00 ; int sum = 0 ; for ( int j = 0 ; j < cols ; j ++ ) sum += mat [ j ] [ i ] ; mean = sum / rows ; cout << mean << " " ; } cout << "]" ; }
void findMissing ( int a [ ] , int b [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) cout << a [ i ] << " " ; } }
int countDigits ( int n ) { double ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += log10 ( i ) ; ans = ans * n ; return 1 + floor ( ans ) ; }
void checksum ( int n ) { if ( n == 0 ) { cout << "-2 -1 0 1 2" << endl ; return ; } int inc ; if ( n > 0 ) inc = 1 ; else inc = -1 ; for ( int i = 0 ; i <= n - 4 ; i += inc ) { if ( i + i + 1 + i + 2 + i + 3 + i + 4 == n ) { cout << i << " " << i + 1 << " " << i + 2 << " " << i + 3 << " " << i + 4 ; return ; } } cout << "-1" ; }
void checksum ( int n ) { if ( n % 5 == 0 ) cout << n / 5 - 2 << " " << n / 5 - 1 << " " << n / 5 << " " << n / 5 + 1 << " " << n / 5 + 2 ; else cout << "-1" ; }
void printGreater ( double x , double y ) { long double X = y * log ( x ) ; long double Y = x * log ( y ) ; if ( abs ( X - Y ) < 1e-9 ) { cout << "Equal" ; } else if ( X > Y ) { cout << x << "^" << y ; } else { cout << y << "^" << x ; } }
int dfs ( int i ) { if ( visited [ i ] == 1 ) return 0 ; visited [ i ] = 1 ; int x = dfs ( goesTo [ i ] ) ; return ( x + 1 ) ; }
int noOfTranspositions ( int P [ ] , int n ) { for ( int i = 1 ; i <= n ; i ++ ) visited [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) goesTo [ P [ i ] ] = i + 1 ; int transpositions = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( visited [ i ] == 0 ) { int ans = dfs ( i ) ; transpositions += ans - 1 ; } } return transpositions ; }
int sumOfSeries ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; }
void findMissing ( int a [ ] , int b [ ] , int n , int m ) { unordered_set < int > s ; for ( int i = 0 ; i < m ; i ++ ) s . insert ( b [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( s . find ( a [ i ] ) == s . end ( ) ) cout << a [ i ] << " " ; }
int countUnmarked ( int N ) { if ( N % 2 == 0 ) return N / 2 ; else return N / 2 + 1 ; }
int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int calculateSeries ( int n ) { return factorial ( n + 1 ) - 1 ; }
int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int Pentatope_number ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 24 ; }
int minimumLength ( int x , int y , int z ) { return 1 + abs ( x - y ) + abs ( y - z ) ; }
bool areEquivalent ( int num1 , int num2 ) { return divSum ( num1 ) == divSum ( num2 ) ; }
int dodecahedral_num ( int n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; }
int centered_heptagonal_num ( long int n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; }
int centeredIcosahedralNum ( int n ) { return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ; return sum ; }
bool checkHankelMatrix ( int n , int m [ N ] [ N ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i + j < n ) { if ( m [ i ] [ j ] != m [ i + j ] [ 0 ] ) return false ; } else { if ( m [ i ] [ j ] != m [ i + j - n + 1 ] [ n - 1 ] ) return false ; } } } return true ; }
int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
int Centered_Triangular_num ( int n ) { return ( 3 * n * n + 3 * n + 2 ) / 2 ; }
int Dodecagonal_number ( int n ) { return 5 * n * n - 4 * n ; }
bool check ( int d , int x ) { if ( bit ( x / d ) <= bit ( d ) ) return true ; return false ; }
int countDivisor ( int n ) { return n - bs ( n ) + 1 ; }
bool isPower ( unsigned int n ) { for ( int x = 2 ; x <= sqrt ( n ) ; x ++ ) { float f = log ( n ) / log ( x ) ; if ( ( f - ( int ) f ) == 0.0 ) return true ; } return false ; }
void wrapper ( int q , int n [ ] ) { int digitSum [ N ] ; int factorDigitSum [ N ] ; sumOddDigit ( digitSum ) ; sumFactor ( digitSum , factorDigitSum ) ; for ( int i = 0 ; i < q ; i ++ ) cout << factorDigitSum [ n [ i ] ] << " " ; }
bool everMeet ( int x1 , int x2 , int v1 , int v2 ) { if ( x1 < x2 && v1 <= v2 ) return false ; if ( x1 > x2 && v1 >= v2 ) return false ; if ( x1 < x2 ) { swap ( x1 , x2 ) ; swap ( v1 , v2 ) ; } return ( ( x1 - x2 ) % ( v1 - v2 ) == 0 ) ; }
int find_maximum ( int a [ ] , int n , int k ) { unordered_map < int , int > b ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; int d = min ( 1 + i , n - i ) ; if ( b . find ( x ) == b . end ( ) ) b [ x ] = d ; else b [ x ] = min ( d , b [ x ] ) ; } int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( x != k - x && b . find ( k - x ) != b . end ( ) ) ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) ; } return ans ; }
int number_of_digits ( int n ) { int i , res , sum = 0 ; for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; }
int MaximumHeight ( int a [ ] , int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { long long y = ( i * ( i + 1 ) ) / 2 ; if ( y < n ) result = i ; else break ; } return result ; }
int distinctGCDs ( int arr [ ] , int N ) { int M = -1 , ans = 0 ; map < int , int > Mp ; for ( int i = 0 ; i < N ; i ++ ) { M = max ( M , arr [ i ] ) ; Mp [ arr [ i ] ] = 1 ; } for ( int i = 1 ; i <= M ; i ++ ) { int currGcd = 0 ; for ( int j = i ; j <= M ; j += i ) { if ( Mp [ j ] ) { currGcd = __gcd ( currGcd , j ) ; if ( currGcd == i ) { ans ++ ; break ; } } } } return ans ; }
void printCollatz ( int n ) { while ( n != 1 ) { cout << n << " " ; if ( n & 1 ) n = 3 * n + 1 ; else n = n / 2 ; } cout << n ; }
bool isProduct ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; i < n ; i ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; }
void SieveOfEratosthenes ( int n , bool prime [ ] , bool primesquare [ ] , int a [ ] ) { for ( int i = 2 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int i = 0 ; i <= ( n * n + 1 ) ; i ++ ) primesquare [ i ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } int j = 0 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { a [ j ] = p ; primesquare [ p * p ] = true ; j ++ ; } } }
int countDivisors ( int n ) { if ( n == 1 ) return 1 ; bool prime [ n + 1 ] , primesquare [ n * n + 1 ] ; SieveOfEratosthenes ( n , prime , primesquare , a ) ; int ans = 1 ; for ( int i = 0 ; ; i ++ ) { if ( a [ i ] * a [ i ] * a [ i ] > n ) break ; int cnt = 1 ; while ( n % a [ i ] == 0 ) { n = n / a [ i ] ; } ans = ans * cnt ; } if ( prime [ n ] ) ans = ans * 2 ; else if ( primesquare [ n ] ) ans = ans * 3 ; else if ( n != 1 ) ans = ans * 4 ; }
int sumofFactors ( int n ) { int res = 1 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
bool checkArithmetic ( int n ) { int count = countDivisors ( n ) ; int sum = sumofFactors ( n ) ; return ( sum % count == 0 ) ; }
int findGCD ( vector < int > arr , int n ) { int result = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) result = gcd ( arr [ i ] , result ) ; return result ; }
int binomialCoeff ( int n , int k ) { int C [ n + 1 ] [ k + 1 ] = { 0 } ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
ll sumTillX ( ll x , ll n ) { ll odd = ceil ( n / 2.0 ) ; if ( x <= odd ) return x * x ; ll even = x - odd ; return ( ( odd * odd ) + ( even * even ) + even ) ; }
int rangeSum ( int N , int L , int R ) { return sumTillX ( R , N ) - sumTillX ( L - 1 , N ) ; }
int magicOfSequence ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) sum += ( i * i * i + i * 2 ) ; return sum ; }
int magicOfSequence ( int N ) { return ( N * ( N + 1 ) / 2 ) + 2 * N ; }
bool isProduct ( int arr [ ] , int n , int x ) { if ( n < 2 ) return false ; unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { if ( x == 0 ) return true ; else continue ; } if ( x % arr [ i ] == 0 ) { if ( s . find ( x / arr [ i ] ) != s . end ( ) ) return true ; s . insert ( arr [ i ] ) ; } } return false ; }
int repUnitValue ( int n ) { if ( n % 2 == 0 n % 5 == 0 ) return 0 ; int rem = 1 ; int power = 1 ; int k = 1 ; while ( rem % n != 0 ) { k ++ ; power = power * 10 % n ; rem = ( rem + power ) % n ; } return k ; }
bool isSplittable ( int n , int m ) { int total_sum = ( n * ( n + 1 ) ) / 2 ; int sum_s1 = ( total_sum + m ) / 2 ; int sum_s2 = total_sum - sum_s1 ; if ( total_sum < m ) return false ; if ( sum_s1 + sum_s2 == total_sum && sum_s1 - sum_s2 == m ) return ( __gcd ( sum_s1 , sum_s2 ) == 1 ) ; return false ; }
bool isPossibleToZero ( int a [ ] , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i & 1 ) odd += a [ i ] ; else even += a [ i ] ; } return ( odd == even ) ; }
double cosXSertiesSum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * -1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }
bool isBlumInteger ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = i * 2 ; j <= n ; j += i ) prime [ j ] = false ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] ) { if ( ( n % i == 0 ) && ( ( i - 3 ) % 4 ) == 0 ) { int q = n / i ; return ( q != i && prime [ q ] && ( q - 3 ) % 4 == 0 ) ; } } } return false ; }
vector < int > primeFactors ( int n ) { vector < int > res ; if ( n % 2 == 0 ) { while ( n % 2 == 0 ) n = n / 2 ; res . push_back ( 2 ) ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; res . push_back ( i ) ; } } if ( n > 2 ) res . push_back ( n ) ; return res ; }
bool isHoax ( int n ) { vector < int > pf = primeFactors ( n ) ; if ( pf [ 0 ] == n ) return false ; int all_pf_sum = 0 ; for ( int i = 0 ; i < pf . size ( ) ; i ++ ) { int pf_sum ; for ( pf_sum = 0 ; pf [ i ] > 0 ; pf_sum += pf [ i ] % 10 , pf [ i ] /= 10 ) ; all_pf_sum += pf_sum ; } int sum_n ; for ( sum_n = 0 ; n > 0 ; sum_n += n % 10 , n /= 10 ) ; return sum_n == all_pf_sum ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int summingSeries ( long n ) { return pow ( n , 2 ) ; }
int nCr ( int n , int r ) { int Nr = n , Dr = 1 , ans = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { ans = ( ans * Nr ) / ( Dr ) ; Nr -- ; Dr ++ ; } return ans ; }
int solve ( int n ) { int N = 2 * n - 2 ; int R = n - 1 ; return nCr ( N , R ) * fact ( n - 1 ) ; }
void printSumsOfDigits ( int n ) { for ( int base = 2 ; base < n ; ++ base ) cout << solve ( n , base ) << " " ; }
bool check ( int N , int D ) { int temp = ( N * ( N + 1 ) ) / 2 + D ; return ( temp % 2 == 0 ) ; }
bool isValidNesbitt ( double a , double b , double c ) { double A = a / ( b + c ) ; double B = b / ( a + c ) ; double C = c / ( a + b ) ; double inequality = A + B + C ; return ( inequality >= 1.5 ) ; }
int exactPrimeFactorCount ( int n ) { int count = 0 ; if ( n % 2 == 0 ) { count ++ ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { count ++ ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) count ++ ; return count ; }
int no_of_digit ( int a , int b ) { return ( ( int ) ( b * log10 ( a ) ) + 1 ) ; }
vector < long long int > gen ( long long int n , vector < long long int > r ) { long long int a = r [ r . size ( ) - 1 ] ; a ++ ; for ( int i = 1 ; i <= n ; a += 2 , i ++ ) r . push_back ( a ) ; return r ; }
vector < long long int > conell ( long long int n ) { vector < long long int > res ; long long int k = 1 ; res . push_back ( 0 ) ; while ( 1 ) { res = gen ( k , res ) ; k ++ ; int j = res . size ( ) - 1 ; while ( j != n && j + k > n ) k -- ; if ( j >= n ) break ; } res . erase ( res . begin ( ) ) ; return res ; }
unsigned long long int factorial ( unsigned int n ) { unsigned long long int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
void printNComposite ( int n ) { unsigned long long int fact = factorial ( n + 1 ) ; for ( int i = 2 ; i <= n + 1 ; ++ i ) cout << fact + i << " " ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
bool coprime ( int a , int b ) { return ( gcd ( a , b ) == 1 ) ; }
bool isCubeFree ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i * i <= n ; i ++ ) if ( n % ( i * i * i ) == 0 ) return false ; return true ; }
void printCubeFree ( int n ) { bool cubFree [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) cubFree [ i ] = true ; for ( int i = 2 ; i * i * i <= n ; i ++ ) { if ( cubFree [ i ] ) { for ( int multiple = 1 ; i * i * i * multiple <= n ; multiple ++ ) { cubFree [ i * i * i * multiple ] = false ; } } } for ( int i = 2 ; i <= n ; i ++ ) { if ( cubFree [ i ] == true ) cout << i << " " ; } }
int inversegrayCode ( int n ) { int inv = 0 ; for ( ; n ; n = n >> 1 ) inv ^= n ; return inv ; }
int calculateDivisors ( int A , int B ) { int N = ( A - B ) ; int noOfDivisors = 0 ; for ( int i = 1 ; i <= sqrt ( N ) ; i ++ ) { if ( ( N % i ) == 0 ) { if ( i > B ) noOfDivisors ++ ; if ( ( N / i ) != i && ( N / i ) > B ) noOfDivisors ++ ; } } return noOfDivisors ; }
int numberOfPossibleWaysUtil ( int A , int B ) { if ( A == B ) return -1 ; if ( A < B ) return 0 ; int noOfDivisors = 0 ; noOfDivisors = calculateDivisors ( A , B ) ; return noOfDivisors ; }
void printPowerNumber ( int X , int N ) { vector < int > power ; power . push_back ( 1 ) ; vector < int > res ; for ( int i = 1 ; i <= X ; i ++ ) { nextPower ( N , power ) ; res . push_back ( power . back ( ) ) ; res . push_back ( power . front ( ) ) ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] ; }
int firstDigit ( int n ) { long long int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact = fact * i ; while ( fact % 10 == 0 ) fact = fact / 10 ; } while ( fact >= 10 ) fact = fact / 10 ; return fact ; }
bool possibleToReach ( int a , int b ) { int c = cbrt ( a * b ) ; int re1 = a / c ; int re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; }
vector < long long int > primes ( long long int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = i * 2 ; j <= n ; j += i ) prime [ j ] = false ; } } vector < long long int > arr ; for ( int i = 2 ; i < n ; i ++ ) if ( prime [ i ] ) arr . push_back ( i ) ; return arr ; }
int countDigits ( long long int n ) { long long int temp = n ; int c = 0 ; while ( temp != 0 ) { temp = temp / 10 ; c ++ ; } return c ; }
bool frugal ( long long int n ) { vector < long long int > r = primes ( n ) ; long long int t = n ; long long int s = 0 ; for ( int i = 0 ; i < r . size ( ) ; i ++ ) { if ( t % r [ i ] == 0 ) { long long int k = 0 ; while ( t % r [ i ] == 0 ) { t = t / r [ i ] ; k ++ ; } if ( k == 1 ) s = s + countDigits ( r [ i ] ) ; else if ( k != 1 ) s = s + countDigits ( r [ i ] ) + countDigits ( k ) ; } } return ( countDigits ( n ) > s && s != 0 ) ; }
int nthSquareCube ( int n ) { return n * n * n * n * n * n ; }
int findGreatest ( int arr [ ] , int n ) { int result = -1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = max ( result , arr [ i ] ) ; return result ; }
int isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; if ( ( sr - floor ( sr ) ) == 0 ) return floor ( sr ) ; else return -1 ; }
int findS ( int s ) { int sr = isPerfectSquare ( s ) ; if ( sr == -1 ) return -1 ; return isTriangular ( sr ) ; }
int powerNumbers ( int n ) { vector < int > v ; for ( ll i = 2 ; i * i * i <= n ; i ++ ) { ll j = i * i ; while ( j * i <= n ) { j *= i ; ll s = sqrt ( j ) ; if ( s * s != j ) v . push_back ( j ) ; } } sort ( v . begin ( ) , v . end ( ) ) ; v . erase ( unique ( v . begin ( ) , v . end ( ) ) , v . end ( ) ) ; return v . size ( ) + ( ll ) sqrt ( n ) ; }
void NicomachuTheorum_sum ( int n ) { int sum = 0 ; for ( int k = 1 ; k <= n ; k ++ ) sum += k * k * k ; int triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) cout << "Yes" ; else cout << "No" ; }
int checkDigits ( int n ) { while ( n ) { return 0 ; n /= 10 ; } return 1 ; }
int largestNumber ( int n ) { for ( int i = n ; ; i -- ) if ( checkDigits ( i ) ) return i ; }
int largestNumber ( int n ) { string s = "" ; int duplicate = n ; while ( n ) { s = char ( n % 10 + 48 ) + s ; n /= 10 ; } int index = -1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( s [ i ] - '0' ) % 2 & 1 ) { index = i ; break ; } } if ( index == -1 ) return duplicate ; int num = 0 ; for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( s [ i ] - '0' ) ; num = num * 10 + ( s [ index ] - '0' - 1 ) ; for ( int i = index + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 + 8 ; return num ; }
int countDigits ( int n ) { return ( n * log10 ( 2 ) + 1 ) ; }
int check_digits ( int n ) { while ( n ) { return 0 ; n /= 10 ; } return 1 ; }
int smallest_number ( int n ) { for ( int i = n ; ; i ++ ) if ( check_digits ( i ) ) return i ; }
int trickyCase ( string s , int index ) { int index1 = -1 ; for ( int i = index - 1 ; i >= 0 ; i -- ) { int digit = s [ i ] - '0' ; if ( digit != 8 ) { index1 = i ; break ; } } if ( index1 == -1 ) return 2 * pow ( 10 , s . length ( ) ) ; int num = 0 ; for ( int i = 0 ; i < index1 ; i ++ ) num = num * 10 + ( s [ i ] - '0' ) ; if ( s [ index1 ] % 2 == 0 ) num = num * 10 + ( s [ index1 ] - '0' + 2 ) ; else num = num * 10 + ( s [ index1 ] - '0' + 1 ) ; for ( int i = index1 + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 ; return num ; }
int smallestNumber ( int n ) { int num = 0 ; string s = "" ; int duplicate = n ; while ( n ) { s = char ( n % 10 + 48 ) + s ; n /= 10 ; } int index = -1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int digit = s [ i ] - '0' ; if ( digit & 1 ) { index = i ; break ; } } if ( index == -1 ) return duplicate ; if ( s [ index ] == '9' ) { num = trickyCase ( s , index ) ; return num ; } for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( s [ i ] - '0' ) ; num = num * 10 + ( s [ index ] - '0' + 1 ) ; for ( int i = index + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 ; return num ; }
int findBucketNo ( int p ) { return ceil ( ( sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; }
int mean ( int a [ ] [ 3 ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += a [ i ] [ j ] ; return sum / ( n * n ) ; }
int variance ( int a [ ] [ 3 ] , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { a [ i ] [ j ] -= m ; a [ i ] [ j ] *= a [ i ] [ j ] ; } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += a [ i ] [ j ] ; return sum / ( n * n ) ; }
long long int productPrimeFactors ( int n ) { long long int product = 1 ; if ( n % 2 == 0 ) { product *= 2 ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { product = product * i ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) product = product * n ; return product ; }
unsigned int factorial ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
void sieve ( ) { bool isPrime [ MAX ] ; memset ( isPrime , true , sizeof ( isPrime ) ) ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( isPrime [ p ] ) primes . push_back ( p ) ; }
long long int modMult ( long long int a , long long int b , long long int mod ) { long long int res = 0 ; a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; }
long long int countWays ( long long int n , long long int m ) { long long int ans = 1 ; for ( int i = 1 ; i < primes . size ( ) ; i ++ ) { long long int powers = power ( n , primes [ i ] ) ; if ( powers == 0 ) break ; ans = modMult ( ans , powers + 1 , m ) % m ; } if ( ( ( ans - 1 ) % m ) < 0 ) return ( ans - 1 + m ) % m ; else return ( ans - 1 ) % m ; }
int subset ( int ar [ ] , int n ) { int res = 0 ; sort ( ar , ar + n ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = max ( res , count ) ; } return res ; }
int findNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } return -1 ; }
void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { cout << i << ", " << j << ", " << k ; return ; } } } cout << "No Triplet" ; }
int sumofFactors ( int n ) { int res = 1 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
bool checkFriendly ( int n , int m ) { int sumFactors_n = sumofFactors ( n ) ; int sumFactors_m = sumofFactors ( m ) ; int gcd_n = gcd ( n , sumFactors_n ) ; int gcd_m = gcd ( m , sumFactors_m ) ; if ( n / gcd_n == m / gcd_m && sumFactors_n / gcd_n == sumFactors_m / gcd_m ) return true ; else return false ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
long long int primorial ( long long int n ) { long long int p = 2 ; n -- ; for ( int i = 3 ; n != 0 ; i ++ ) { if ( isPrime ( i ) ) { p = p * i ; n -- ; } i ++ ; } return p ; }
long long int findNextPrime ( long long int n ) { long long int nextPrime = n + 2 ; while ( true ) { if ( isPrime ( nextPrime ) ) break ; nextPrime ++ ; } return nextPrime ; }
long long int findSum ( int n ) { long long int multiTerms = n * ( n + 1 ) / 2 ; long long int sum = multiTerms ; for ( int i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; }
double procal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }
void testSomeNumbers ( int limit , int n ) { if ( n < 3 ) return ; for ( int a = 1 ; a <= limit ; a ++ ) for ( int b = a ; b <= limit ; b ++ ) { int pow_sum = pow ( a , n ) + pow ( b , n ) ; double c = pow ( pow_sum , 1.0 / n ) ; int c_pow = pow ( ( int ) c , n ) ; if ( c_pow == pow_sum ) { cout << "Count example found" ; return ; } } cout << "No counter example within given" " range and data" ; }
void series ( int A , int X , int n ) { int nFact = factorial ( n ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { int niFact = factorial ( n - i ) ; int iFact = factorial ( i ) ; int aPow = pow ( A , n - i ) ; int xPow = pow ( X , i ) ; cout << ( nFact * aPow * xPow ) / ( niFact * iFact ) << " " ; } }
void series ( int A , int X , int n ) { int term = pow ( A , n ) ; cout << term << " " ; for ( int i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; cout << term << " " ; } }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void productReduce ( int n , int num [ ] , int den [ ] ) { int new_num = 1 , new_den = 1 ; for ( int i = 0 ; i < n ; i ++ ) { new_num *= num [ i ] ; new_den *= den [ i ] ; } int GCD = gcd ( new_num , new_den ) ; new_num /= GCD ; new_den /= GCD ; cout << new_num << "/" << new_den << endl ; }
int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
int repeatedNumberSum ( int n , int x ) { int sum = x * digSum ( n ) ; return digSum ( sum ) ; }
int totalSumDivisibleByNum ( int n , int number ) { int firstnum = pow ( 10 , n - 1 ) ; int lastnum = pow ( 10 , n ) ; int sum = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; }
int minRemove ( int a [ ] , int b [ ] , int n , int m ) { unordered_map < int , int > countA , countB ; for ( int i = 0 ; i < n ; i ++ ) countA [ a [ i ] ] ++ ; for ( int i = 0 ; i < m ; i ++ ) countB [ b [ i ] ] ++ ; int res = 0 ; for ( auto x : countA ) if ( countB . find ( x . first ) != countB . end ( ) ) res += min ( x . second , countB [ x . first ] ) ; return res ; }
int totalSumDivisibleByNum ( int digit , int number ) { int firstnum = pow ( 10 , digit - 1 ) ; int lastnum = pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; int count = ( ( lastnum - firstnum ) / number + 1 ) ; return ( ( lastnum + firstnum ) * count ) / 2 ; }
int numberofterm ( int n , int number ) { int firstnum = pow ( 10 , n - 1 ) ; int lastnum = pow ( 10 , n ) ; int count = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; }
int sumofseries ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) res += ( i ) * ( i + 1 ) * ( i + 2 ) ; return res ; }
int sumofseries ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) ; }
int seiresSum ( int n , int a [ ] ) { int res = 0 ; for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; }
int seiresSum ( int n , int a [ ] ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; }
void printGMeans ( int A , int B , int N ) { float R = ( float ) pow ( float ( B / A ) , 1.0 / ( float ) ( N + 1 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) cout << A * pow ( R , i ) << " " ; }
int checkdigit ( int n , int k ) { while ( n ) { int rem = n % 10 ; if ( rem == k ) return 1 ; n = n / 10 ; } return 0 ; }
bool isValid ( long long int i , long long int m ) { long long int sq_i = sqrt ( i ) ; long long int sq = min ( m , sq_i ) ; for ( long long int j = 2 ; j <= sq ; j ++ ) if ( i % j == 0 ) return false ; return true ; }
void findLargestNum ( long long int n , long long int m ) { for ( long long int i = n ; i > m ; i -- ) { if ( isValid ( i , m ) ) { cout << i << '' ; return ; } } cout << "Number Doesn't Exists\n" ; }
void georgeCantor ( int n ) { int i = 1 ; int j = 1 ; int k = 1 ; while ( k < n ) { j ++ , k ++ ; if ( k == n ) break ; while ( j > 1 && k < n ) { i ++ , j -- , k ++ ; } if ( k == n ) break ; i ++ , k ++ ; if ( k == n ) break ; while ( i > 1 && k < n ) { i -- , j ++ , k ++ ; } } cout << "N-th term : " << i << " / " << j ; }
bool isDivisible ( long long int n ) { while ( n / 100 ) { int last_digit = n % 10 ; n /= 10 ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; }
int digitSum ( long long int n ) { int digSum = 0 ; while ( n ) { digSum += n % 10 ; n /= 10 ; } return digSum ; }
long long int countInteger ( long long int n , long long int s ) { if ( n < s ) return 0 ; for ( long long int i = s ; i <= min ( n , s + 163 ) ; i ++ ) if ( ( i - digitSum ( i ) ) > s ) return ( n - i + 1 ) ; return 0 ; }
int division ( int num1 , int num2 ) { if ( num1 == 0 ) return 0 ; if ( num2 == 0 ) return INT_MAX ; bool negResult = false ; if ( num1 < 0 ) { num1 = - num1 ; if ( num2 < 0 ) num2 = - num2 ; else negResult = true ; } else if ( num2 < 0 ) { num2 = - num2 ; negResult = true ; } int quotient = 0 ; while ( num1 >= num2 ) { num1 = num1 - num2 ; quotient ++ ; } if ( negResult ) quotient = - quotient ; return quotient ; }
bool pronic_check ( int n ) { int x = ( int ) ( sqrt ( n ) ) ; if ( x * ( x + 1 ) == n ) return true ; else return false ; }
int power ( int n , int r ) { int count = 0 ; for ( int i = r ; ( n / i ) >= 1 ; i = i * r ) count += n / i ; return count ; }
bool isOrthogonal ( int a [ ] [ MAX ] , int m , int n ) { if ( m != n ) return false ; int trans [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) trans [ i ] [ j ] = a [ j ] [ i ] ; int prod [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int k = 0 ; k < n ; k ++ ) { sum = sum + ( a [ i ] [ k ] * a [ j ] [ k ] ) ; } prod [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && prod [ i ] [ j ] != 0 ) return false ; if ( i == j && prod [ i ] [ j ] != 1 ) return false ; } } return true ; }
long long digitNumber ( long long n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 9 ; if ( n % 2 ) { long long temp = digitNumber ( ( n - 1 ) / 2 ) % mod ; return ( 9 * ( temp * temp ) % mod ) % mod ; } else { long long temp = digitNumber ( n / 2 ) % mod ; return ( temp * temp ) % mod ; } }
int countExcluding ( int n , int d ) { if ( d == 0 ) return ( 9 * digitNumber ( n - 1 ) ) % mod ; else return ( 8 * digitNumber ( n - 1 ) ) % mod ; }
bool isPerfectSquare ( long double x ) { if ( x >= 0 ) { long long sr = sqrt ( x ) ; return ( sr * sr == x ) ; } return false ; }
void checkperfectsquare ( int n ) { if ( ceil ( ( double ) sqrt ( n ) ) == floor ( ( double ) sqrt ( n ) ) ) { cout << "perfect square" ; } else { cout << "not a perfect square" ; } }
void printGP ( int a , int r , int n ) { int curr_term ; for ( int i = 0 ; i < n ; i ++ ) { curr_term = a * pow ( r , i ) ; cout << curr_term << " " ; } }
int Nth_of_AP ( int a , int d , int N ) { return ( a + ( N - 1 ) * d ) ; }
bool checkFibinnary ( int n ) { int prev_last = 0 ; while ( n ) { if ( ( n & 1 ) && prev_last ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; }
bool check ( int n , int p ) { int maximum = -1 ; while ( ! ( n % 2 ) ) { maximum = max ( maximum , 2 ) ; n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { maximum = max ( maximum , i ) ; n = n / i ; } } if ( n > 2 ) maximum = max ( maximum , n ) ; return ( maximum <= p ) ; }
int Nonagonal ( int n ) { return n * ( 7 * n - 5 ) / 2 ; }
int Nonagonal ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { cout << i * ( 7 * i - 5 ) / 2 ; cout << " " ; } }
int findLcm ( int * * arr , int size ) { int ans = arr [ 0 ] [ 1 ] ; for ( int i = 1 ; i < size ; i ++ ) ans = ( ( ( arr [ i ] [ 1 ] * ans ) ) / ( gcd ( arr [ i ] [ 1 ] , ans ) ) ) ; return ( ans ) ; }
bool checkplusperfect ( int x ) { int temp = x ; int n = 0 ; while ( x != 0 ) { x /= 10 ; n ++ ; } x = temp ; int sum = 0 ; while ( x != 0 ) { sum += pow ( x % 10 , n ) ; x /= 10 ; } return ( sum == temp ) ; }
int sum_series ( int n ) { int nSquare = n * n ; return nSquare * ( nSquare - 1 ) / 4 ; }
bool isPrime ( int n ) { if ( n == 0 n == 1 ) return false ; int root = sqrt ( n ) ; for ( int i = 2 ; i <= root ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
bool isSandwitched ( int n ) { return ( isPrime ( n - 1 ) && isPrime ( n + 1 ) ) ; }
int Div_by_8 ( int n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; }
float mean ( float mid [ ] , int freq [ ] , int n ) { float sum = 0 , freqSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + mid [ i ] * freq [ i ] ; freqSum = freqSum + freq [ i ] ; } return sum / freqSum ; }
float groupedSD ( float lower_limit [ ] , float upper_limit [ ] , int freq [ ] , int n ) { float mid [ n ] , sum = 0 , freqSum = 0 , sd ; for ( int i = 0 ; i < n ; i ++ ) { mid [ i ] = ( lower_limit [ i ] + upper_limit [ i ] ) / 2 ; sum = sum + freq [ i ] * mid [ i ] * mid [ i ] ; freqSum = freqSum + freq [ i ] ; } sd = sqrt ( ( sum - freqSum * mean ( mid , freq , n ) * mean ( mid , freq , n ) ) / ( freqSum - 1 ) ) ; return sd ; }
bool divisibleBy20 ( string num ) { int lastTwoDigits = stoi ( num . substr ( num . length ( ) - 2 , num . length ( ) - 1 ) ) ; return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) ; }
double findArea ( double d ) { return ( d * d ) / 2.0 ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
int sumOfSeries ( int n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }
int getMSB ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( ( n + 1 ) >> 2 ) ; }
void multiply ( int F [ 2 ] [ 2 ] , int M [ 2 ] [ 2 ] ) { int x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ; int y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ; int z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ; int w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ; F [ 0 ] [ 0 ] = x ; F [ 0 ] [ 1 ] = y ; F [ 1 ] [ 0 ] = z ; F [ 1 ] [ 1 ] = w ; }
void power ( int F [ 2 ] [ 2 ] , int n ) { if ( n == 0 n == 1 ) return ; int M [ 2 ] [ 2 ] = { 1 , 1 , 1 , 0 } ; for ( int m = getMSB ( n ) ; m ; m = m >> 1 ) { multiply ( F , F ) ; if ( n & m ) { multiply ( F , M ) ; } } }
int fib ( int n ) { int F [ 2 ] [ 2 ] = { { 1 , 1 } , { 1 , 0 } } ; if ( n == 0 ) return 0 ; power ( F , n - 1 ) ; return F [ 0 ] [ 0 ] ; }
bool isDvisibleBy12 ( string num ) { if ( num . length ( ) >= 3 ) { int d1 = ( int ) num [ num . length ( ) - 1 ] ; if ( d1 % 2 != 0 ) return ( 0 ) ; int d2 = ( int ) num [ num . length ( ) - 2 ] ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num [ i ] ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = stoi ( num ) ; return ( number % 12 == 0 ) ; } }
int StepstoReachTarget ( int target ) { target = abs ( target ) ; int n = ceil ( ( -1.0 + sqrt ( 1 + 8.0 * target ) ) / 2 ) ; int sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; int d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) ? 2 : 1 ) ; }
float Calculate_GST ( float org_cost , float N_price ) { return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; }
int avg_of_even_num ( int n ) { return n + 1 ; }
int avg_of_odd_num ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; }
int avg_of_odd_num ( int n ) { return n ; }
double seriesSum ( int n ) { int i = 1 ; double res = 0.0 ; bool sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ( double ) ++ i / ++ i ; } else { sign = ! sign ; res = res - ( double ) ++ i / ++ i ; } } return res ; }
bool check ( int n ) { int d = sqrt ( n ) ; if ( d * d == n ) return true ; return false ; }
int largestNonPerfectSquareNumber ( int a [ ] , int n ) { int maxi = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! check ( a [ i ] ) ) maxi = max ( a [ i ] , maxi ) ; } return maxi ; }
int modInverse ( int a , int prime ) { a = a % prime ; for ( int x = 1 ; x < prime ; x ++ ) if ( ( a * x ) % prime == 1 ) return x ; return -1 ; }
void printModIverses ( int n , int prime ) { for ( int i = 1 ; i <= n ; i ++ ) cout << modInverse ( i , prime ) << " " ; }
unsigned int countSymmetric ( unsigned int n ) { if ( n == 0 ) return 1 ; return 1 << ( ( n * ( n + 1 ) ) / 2 ) ; }
void SternSequenceFunc ( vector < int > & BrocotSequence , int n ) { for ( int i = 1 ; BrocotSequence . size ( ) < n ; i ++ ) { int considered_element = BrocotSequence [ i ] ; int precedent = BrocotSequence [ i - 1 ] ; BrocotSequence . push_back ( considered_element + precedent ) ; BrocotSequence . push_back ( considered_element ) ; } for ( int i = 0 ; i < 15 ; ++ i ) cout << BrocotSequence [ i ] << " " ; }
int centeredNonagonal ( int n ) { return ( 3 * n - 2 ) * ( 3 * n - 1 ) / 2 ; }
bool sieve ( int n , bool prime [ ] ) { for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } }
void printSophieGermanNumber ( int n ) { bool prime [ 2 * n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; sieve ( 2 * n + 1 , prime ) ; for ( int i = 2 ; i <= n ; ++ i ) { if ( prime [ i ] && prime [ 2 * i + 1 ] ) cout << i << " " ; } }
void fib ( int f [ ] , int N ) { f [ 1 ] = 1 ; f [ 2 ] = 1 ; for ( int i = 3 ; i <= N ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; }
void printAP ( int a , int d , int n ) { int curr_term ; curr_term = a ; for ( int i = 1 ; i <= n ; i ++ ) { cout << curr_term << " " ; curr_term = curr_term + d ; } }
float Mean ( float arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum / n ; }
bool isRevDiffDivisible ( int x , int k ) { int n = x ; int m = 0 ; int flag ; while ( x > 0 ) { m = m * 10 + x % 10 ; x /= 10 ; } return ( abs ( n - m ) % k == 0 ) ; }
int countNumbers ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) if ( isRevDiffDivisible ( i , k ) ) ++ count ; return count ; }
bool isRatioPossible ( int lowCost , int upCost , int lowQuant , int upQuant , int r ) { for ( int i = lowQuant ; i <= upQuant ; i ++ ) { int ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; }
int centeredHexagonalNumber ( int n ) { return 3 * n * ( n - 1 ) + 1 ; }
long long int oddNumSum ( int n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; }
bool isPerfectSquare ( int n ) { if ( n < 0 ) return false ; int root = round ( sqrt ( n ) ) ) ; return n == root * root ; }
void printnonsquare ( int n ) { int count = 0 ; for ( int i = 1 ; count < n ; ++ i ) { if ( ! isPerfectSquare ( i ) ) { cout << i << " " ; count ++ ; } } }
int nonsquare ( int n ) { return n + ( int ) ( 0.5 + sqrt ( n ) ) ; }
void printNonSquare ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) printf ( "%d " , nonsquare ( i ) ) ; }
int trailingZero ( int x ) { int i = 5 , count = 0 ; while ( x > i ) { count = count + x / i ; i = i * 5 ; } return count ; }
int countProductTrailing ( int M , int N ) { return trailingZero ( N ) + trailingZero ( M ) ; }
bool isTrimorphic ( int N ) { int cube = N * N * N ; while ( N > 0 ) { if ( N % 10 != cube % 10 ) return false ; N /= 10 ; cube /= 10 ; } return true ; }
bool checkTrimorphic ( int num ) { int cube = num * num * num ; while ( num > 0 ) { if ( num % 10 != cube % 10 ) return false ; num /= 10 ; cube /= 10 ; } return true ; }
int averageEven ( int n ) { if ( n % 2 != 0 ) { printf ( "Invalid Input" ) ; return -1 ; } int sum = 0 , count = 0 ; while ( n >= 2 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; }
int averageEven ( int n ) { if ( n % 2 != 0 ) { cout << "Invalid Input" ; return -1 ; } return ( n + 2 ) / 2 ; }
int averageOdd ( int n ) { if ( n % 2 == 0 ) { printf ( "Invalid Input" ) ; return -1 ; } int sum = 0 , count = 0 ; while ( n >= 1 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; }
long long int fifthPowerSum ( int n ) { return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) / 12 ; }
int find_distance ( int n ) { return n * ( ( 3 * n ) + 7 ) ; }
void nearestPerfectSquare ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int sr = sqrt ( arr [ i ] ) ; if ( ( sr & 1 ) == ( arr [ i ] & 1 ) ) cout << sr * sr << " " ; else { sr ++ ; cout << sr * sr << " " ; } } }
int squareSum ( int n ) { return n * ( 4 * n * n - 1 ) / 3 ; }
int squareSum ( int n ) { return 2 * n * ( n + 1 ) * ( 2 * n + 1 ) / 3 ; }
bool isMunchhausen ( unsigned n ) { unsigned sum = 0 ; int temp = n ; while ( temp ) { sum += pwr [ ( temp % 10 ) ] ; temp /= 10 ; } return ( sum == n ) ; }
int kthdigit ( int a , int b , int k ) { int p = pow ( a , b ) ; int count = 0 ; while ( p > 0 && count < k ) { int rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; }
bool isPentagonal ( int N ) { int i = 1 , M ; do { M = ( 3 * i * i - i ) / 2 ; i += 1 ; } while ( M < N ) ; return ( M == N ) ; }
long long int fourthPowerSum ( int n ) { long long int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i * i * i ) ; return sum ; }
int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; }
int unitnumber ( int x , int y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( ( int ) ( pow ( x , y ) ) ) % 10 ) ; }
bool isPrime ( int n ) { if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i * i <= n ; i += 2 ) if ( n % i == 0 ) return false ; return true ; }
int nextPrime ( int start ) { int next = start + 1 ; while ( ! isPrime ( next ) ) next ++ ; return next ; }
bool areAdjacentPrimes ( int a , int b , int c ) { if ( ! isPrime ( a ) || ! isPrime ( b ) || ! isPrime ( c ) ) return false ; int next = nextPrime ( a ) ; if ( next != b ) return false ; if ( nextPrime ( b ) != c ) return false ; return true ; }
int findDivisor ( int x , int y ) { if ( x == y ) return y ; return 2 ; }
long digSum ( long n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
long PowDigSum ( long n , long x ) { long sum = digSum ( n ) ; long rem = x % 6 ; if ( ( sum == 3 sum == 6 ) && x > 1 ) return 9 ; else if ( x == 1 ) return sum ; else if ( x == 0 ) return 1 ; else if ( rem == 0 ) return digSum ( ( long ) pow ( sum , 6 ) ) ; else return digSum ( ( long ) pow ( sum , rem ) ) ; }
float AvgofSquareN ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; }
float AvgofSquareN ( int n ) { return ( float ) ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
int sumofFactors ( int n ) { if ( n % 2 != 0 ) return 0 ; int res = 1 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 , curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
float func ( float x ) { return ( 1 / ( 1 + x * x ) ) ; }
float calculate ( float lower_limit , float upper_limit , int interval_limit ) { float value ; float interval_size = ( upper_limit - lower_limit ) / interval_limit ; float sum = func ( lower_limit ) + func ( upper_limit ) ; for ( int i = 1 ; i < interval_limit ; i ++ ) { if ( i % 3 == 0 ) sum = sum + 2 * func ( lower_limit + i * interval_size ) ; else sum = sum + 3 * func ( lower_limit + i * interval_size ) ; } return ( 3 * interval_size / 8 ) * sum ; }
int LCM ( int a , int b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; }
int lcmOfNumerator ( vector < pair < int , int > > vect ) { int lcm = vect [ 0 ] . first ; for ( int i = 1 ; i < vect . size ( ) ; i ++ ) lcm = LCM ( vect [ i ] . first , lcm ) ; return lcm ; }
int gcdOfDemoninators ( vector < pair < int , int > > vect ) { int gcd = vect [ 0 ] . second ; for ( int i = 1 ; i < vect . size ( ) ; i ++ ) gcd = __gcd ( vect [ i ] . second , gcd ) ; return gcd ; }
void lcmOfRationals ( vector < pair < int , int > > vect ) { cout << lcmOfNumerator ( vect ) << "/" << gcdOfDemoninators ( vect ) ; }
void makePermutation ( int a [ ] , int n ) { unordered_map < int , int > count ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int next_missing = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ a [ i ] ] != 1 a [ i ] > n a [ i ] < 1 ) { count [ a [ i ] ] -- ; while ( count . find ( next_missing ) != count . end ( ) ) next_missing ++ ; a [ i ] = next_missing ; count [ next_missing ] = 1 ; } } }
float focal_length_convex ( float R ) { return - ( R / 2 ) ; }
float focal_length ( float image_distance , float object_distance ) { return 1 / ( ( 1 / image_distance ) + ( 1 / object_distance ) ) ; }
int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
int countSolutions ( int n , int val ) { int total = 0 ; if ( n == 1 && val >= 0 ) return 1 ; for ( int i = 0 ; i <= val ; i ++ ) { total += countSolutions ( n - 1 , val - i ) ; } return total ; }
int lcm ( int a , int b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool twinPrime ( int n1 , int n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && abs ( n1 - n2 ) == 2 ) ; }
int mobius ( int n ) { int p = 0 ; if ( n % 2 == 0 ) { n = n / 2 ; p ++ ; if ( n % 2 == 0 ) return 0 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; p ++ ; if ( n % i == 0 ) return 0 ; } } return ( p % 2 == 0 ) ? -1 : 1 ; }
void fib ( int f [ ] , int n ) { int i ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( i = 2 ; i <= n ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; }
void fibcoef ( int fc [ ] [ N + 1 ] , int f [ ] , int n ) { for ( int i = 0 ; i <= n ; i ++ ) fc [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { int k = j ; while ( k -- ) fc [ i ] [ j ] *= f [ k ] ; k = 1 ; while ( ( j + 1 ) != k ) fc [ i ] [ j ] /= f [ k ++ ] ; } } }
float sumOfSeries ( int n ) { return 0.0246 * ( pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }
int sumofNterm ( int a , int d , int b , int r , int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( a + ( i - 1 ) * d ) * ( b * pow ( r , i - 1 ) ) ) ; return sum ; }
double sumOfTheSeries ( int n ) { double sum = 0.0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 1.0 / ( i * ( i + 1 ) ) ; return sum ; }
long long int sum ( long long int n ) { long long int root = sqrt ( n ) ; long long int ans = 0 ; for ( int i = 1 ; i <= root ; i ++ ) ans += n / i ; ans = 2 * ans - ( root * root ) ; return ans ; }
int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 2 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
int sumOfTheSeries ( int n ) { int sum_n = ( n * ( n + 1 ) / 2 ) ; int sum_sq_n = ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; return ( sum_n + sum_sq_n ) ; }
int sumofsquare ( int n ) { int C [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ; return sum ; }
int factorial ( int start , int end ) { int res = 1 ; for ( int i = start ; i <= end ; i ++ ) res *= i ; return res ; }
int sumofsquare ( int n ) { return factorial ( n + 1 , 2 * n ) / factorial ( 1 , n ) ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum = sum + i ; return sum ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + i * i ; return sum ; }
int sumOfSeries ( int n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
int evenSum ( int n ) { int C [ n + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } int sum = 0 ; for ( int i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; }
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; }
int evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; }
double Series ( int n ) { int i ; double sums = 0.0 , ser ; for ( i = 1 ; i <= n ; ++ i ) { ser = 1 / pow ( i , i ) ; sums += ser ; } return sums ; }
int TrinomialValue ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k < - n k > n ) return 0 ; return TrinomialValue ( n - 1 , k - 1 ) + TrinomialValue ( n - 1 , k ) + TrinomialValue ( n - 1 , k + 1 )  ; }
int Series ( int n ) { int i ; int sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; }
double Series ( double x , int n ) { double sum = 1 , term = 1 , fct = 1 , p = 1 , multi = 1 ; for ( int i = 1 ; i < n ; i ++ ) { fct = fct * multi * ( multi + 1 ) ; p = p * x * x ; term = ( -1 ) * term ; multi += 2 ; sum = sum + ( term * p ) / fct ; } return sum ; }
bool isPresent ( int arr [ ] , int low , int high , int value ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] == value ) return true ; else if ( arr [ mid ] > value ) high = mid - 1 ; else low = mid + 1 ; } return false ; }
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int value = x - arr1 [ i ] ; if ( isPresent ( arr2 , 0 , n - 1 , value ) ) count ++ ; } return count ; }
int two_factor ( int n ) { int twocount = 0 ; while ( n % 2 == 0 ) { twocount ++ ; n = n / 2 ; } return twocount ; }
int five_factor ( int n ) { int fivecount = 0 ; while ( n % 5 == 0 ) { fivecount ++ ; n = n / 5 ; } return fivecount ; }
int find_con_zero ( int arr [ ] , int n ) { int twocount = 0 ; int fivecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { twocount += two_factor ( arr [ i ] ) ; fivecount += five_factor ( arr [ i ] ) ; } if ( twocount < fivecount ) return twocount ; else return fivecount ; }
int fib ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 , fn = 5 ; while ( t < n ) { fn = round ( fn * PHI ) ; t ++ ; } return fn ; }
int first ( int a , int b , int c ) { a %= b ; for ( int i = 1 ; i <= b ; i ++ ) { a = a * 10 ; if ( a / b == c ) return i ; a %= b ; } return -1 ; }
void subsetDifference ( int n ) { int s = n * ( n + 1 ) / 2 ; if ( n % 4 == 0 ) { cout << "First subset sum = " << s / 2 ; cout << "Secondsubsetsum=" << s / 2 ; cout << "Difference="  } else { if ( n % 4 == 1 n % 4 == 2 ) { cout << "First subset sum = " << s / 2 ; cout << "Secondsubsetsum=" << s / 2 + 1 ; cout << "Difference="  } else { cout << "First subset sum = " << s / 2 ; cout << "Secondsubsetsum=" << s / 2 ; cout << "Difference="  } } }
float func ( float x , float y ) { return ( x + y + x * y ) ; }
void euler ( float x0 , float y , float h , float x ) { float temp = -0 ; while ( x0 < x ) { temp = y ; y = y + h * func ( x0 , y ) ; x0 = x0 + h ; } cout << "Approximate solution at x = " << x << " is " << y << endl ; }
void timeToMeet ( double s , double v ) { double V = 3 * v / 2 ; double time = s / V ; cout << time ; }
int maxcoefficientvalue ( int n ) { if ( n % 2 == 0 ) return binomialCoeff ( n , n / 2 ) ; else return binomialCoeff ( n , ( n + 1 ) / 2 ) ; }
int LCM ( int x , int y , int z ) { int ans = ( ( x * y ) / ( __gcd ( x , y ) ) ) ; return ( ( z * ans ) / ( __gcd ( ans , z ) ) ) ; }
int findDivisible ( int n , int x , int y , int z ) { int lcm = LCM ( x , y , z ) ; int ndigitnumber = pow ( 10 , n - 1 ) ; int reminder = ndigitnumber % lcm ; if ( reminder == 0 ) return ndigitnumber ; ndigitnumber += lcm - reminder ; if ( ndigitnumber < pow ( 10 , n ) ) return ndigitnumber ; else return 0 ; }
int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 1 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; }
int sumOfTheSeries ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
void checksum ( int n ) { if ( n == 0 ) { cout << "-1 0 1" << endl ; return ; } int inc ; if ( n > 0 ) inc = 1 ; else inc = -1 ; for ( int i = 0 ; i <= n - 2 ; i += inc ) { if ( i + i + 1 + i + 2 == n ) { cout << i << " " << i + 1 << " " << i + 2 ; return ; } } cout << "-1" ; }
void checksum ( int n ) { if ( n % 3 == 0 ) cout << n / 3 - 1 << " " << n / 3 << " " << n / 3 + 1 ; else cout << "-1" ; }
void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { cout << "x = " << i << ", y = " << ( n - ( i * a ) ) / b ; return ; } } cout << "No solution" ; }
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } } return sum ; }
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; }
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }
long long sum_all_divisors ( long long num ) { long long sum = 0 ; for ( long long i = 1 ; i <= sqrt ( num ) ; i ++ ) { sum += t1 + t2 ; } return sum ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int sumOfLargePrimeFactor ( int n ) { int prime [ n + 1 ] , sum = 0 ; memset ( prime , 0 , sizeof ( prime ) ) ; int max = n / 2 ; for ( int p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = p ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) sum += prime [ p ] ; else sum += p ; } return sum ; }
int gcd ( int a , int b ) { if ( a == 0 b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
int cpFact ( int x , int y ) { while ( gcd ( x , y ) != 1 ) { x = x / gcd ( x , y ) ; } return x ; }
int binomialCoeffSum ( int n ) { return ( 1 << n ) ; }
unsigned int countSetBits ( int n ) { unsigned int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
unsigned int countUnsetBitsInGivenRange ( unsigned int n , unsigned int l , unsigned int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return ( r - l + 1 ) - countSetBits ( n & num ) ; }
long long int evenPowerSum ( int n ) { long long int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int j = 2 * i ; sum = sum + ( j * j * j * j ) ; } return sum ; }
long long int evenPowerSum ( int n ) { return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; }
int balancedprime ( int n ) { bool prime [ MAX + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } vector < int > v ; for ( int p = 3 ; p <= MAX ; p += 2 ) if ( prime [ p ] ) v . push_back ( p ) ; int count = 0 ; for ( int i = 1 ; i < v . size ( ) ; i ++ ) { if ( v [ i ] == ( v [ i + 1 ] + v [ i - 1 ] ) / 2 ) count ++ ; if ( count == n ) return v [ i ] ; } }
int calculateNoOFactors ( int n ) { if ( n == 1 ) return 1 ; int ans = 1 ; int dup = factor [ n ] ; int c = 1 ; int j = n / factor [ n ] ; while ( j != 1 ) { if ( factor [ j ] == dup ) c += 1 ; else { dup = factor [ j ] ; ans = ans * ( c + 1 ) ; c = 1 ; } j = j / factor [ j ] ; } ans = ans * ( c + 1 ) ; return ans ; }
int smallest ( int n ) { for ( int i = 1 ; ; i ++ ) if ( calculateNoOFactors ( i ) >= n ) return i ; }
int squaresum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
int counLastDigitK ( int low , int high , int k ) { int count = 0 ; for ( int i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; }
int minimumSum ( int n ) { if ( isPrime ( n ) ) return 1 ; if ( n % 2 == 0 ) return 2 ; if ( isPrime ( n - 2 ) ) return 2 ; return 3 ; }
int lastDigit ( int n ) { return ( n % 10 ) ; }
int numberOfTriangles ( int n ) { int ans = 2 * ( pow ( 3 , n ) ) - 1 ; return ans ; }
bool isPrime ( int x ) { if ( x == 0 x == 1 ) return false ; for ( int i = 2 ; i * i <= x ; ++ i ) if ( x % i == 0 ) return false ; return true ; }
void findPrimes ( int n ) { cout << n << endl ; cout << 2 << " " << n - 2 << endl ; { cout << 3 << " " ; n = n - 3 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime ( i ) && isPrime ( n - i ) ) { cout << i << " " << ( n - i ) ; break ; } } } }
bool checkDigits ( int n ) { while ( n ) { int dig = n % 10 ; if ( dig != 2 && dig != 3 && dig != 5 && dig != 7 ) return false ; n /= 10 ; } return true ; }
bool prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
int isFullPrime ( int n ) { return ( checkDigits ( n ) && prime ( n ) ) ; }
void coef ( int n ) { c [ 0 ] = 1 ; for ( int i = 0 ; i < n ; c [ 0 ] = - c [ 0 ] , i ++ ) { c [ 1 + i ] = 1 ; for ( int j = i ; j > 0 ; j -- ) c [ j ] = c [ j - 1 ] - c [ j ] ; } }
bool isPrime ( int n ) { coef ( n ) ; c [ 0 ] ++ , c [ n ] -- ; int i = n ; while ( i -- && c [ i ] % n == 0 ) ; return i < 0 ; }
int motzkin ( int n ) { if ( n == 0 n == 1 ) return 1 ; return ( ( 2 * n + 1 ) * motzkin ( n - 1 ) + ( 3 * n - 3 ) * motzkin ( n - 2 ) ) / ( n + 2 ) ; }
float sumOfSeries ( int n ) { return ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ; }
bool check ( int n ) { int l = countDigit ( n ) ; int dup = n ; int sum = 0 ; while ( dup ) { sum += pow ( dup % 10 , l ) ; dup /= 10 ; } return ( n == sum ) ; }
string getResult ( string st ) { int sum = 0 ; int length = st . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { sum = sum + pow ( st [ i ] - '0' , length ) ; } int number = stoi ( st ) ; if ( number == sum ) return "yes" ; else return "no" ; }
int solve ( int low , int high , int T ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return -1 ; }
int nthSHN ( int n , int dp [ ] ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != -1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; }
int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
void leyland ( int n ) { vector < int > ans ; for ( int x = 2 ; x <= n ; x ++ ) { for ( int y = 2 ; y <= x ; y ++ ) { int temp = pow ( x , y ) + pow ( y , x ) ; ans . push_back ( temp ) ; } } sort ( ans . begin ( ) , ans . end ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) cout << ans [ i ] << " " ; }
bool isOverflow ( long long a , long long b ) { if ( a == 0 b == 0 ) return false ; long long result = a * b ; if ( a == result / b ) return false ; else return true ; }
int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; while ( k -- ) { sum += cur ; cur += 2 ; } return sum ; }
int oddSum ( int n ) { return ( n * n ) ; }
double mphTOkmph ( double mph ) { return mph * 1.60934 ; }
int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; }
int trace ( int n , int m ) { int an = 1 + ( n - 1 ) * ( m + 1 ) ; int rowmajorSum = sn ( n , an ) ; an = 1 + ( n - 1 ) * ( n + 1 ) ; int colmajorSum = sn ( n , an ) ; return rowmajorSum + colmajorSum ; }
void precompute ( int prefix [ ] , int suffix [ ] ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( prime [ i ] ) { for ( int j = i * i ; j < MAX ; j += i ) prime [ j ] = false ; } } prefix [ 1 ] = 1 ; suffix [ MAX - 1 ] = 1e9 + 7 ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] ) prefix [ i ] = i ; else prefix [ i ] = prefix [ i - 1 ] ; } for ( int i = MAX - 1 ; i > 1 ; i -- ) { if ( prime [ i ] ) suffix [ i ] = i ; else suffix [ i ] = suffix [ i + 1 ] ; } }
int query ( int prefix [ ] , int suffix [ ] , int L , int R ) { if ( prefix [ R ] < L suffix [ L ] > R ) return 0 ; else return prefix [ R ] - suffix [ L ] ; }
void printXYZ ( int n ) { if ( n == 1 ) cout << -1 ; else cout << "x is " << n << "\ny is " << n + 1 << "\nz is " << n * ( n + 1 ) ; }
int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
int term ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; }
int term ( int n ) { return n * ( n + 1 ) / 2 ; }
float avgOfFirstN ( int n ) { return ( float ) ( 1 + n ) / 2 ; }
int summation ( int n ) { int sum ; sum = ( pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; return sum ; }
double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; for ( i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; }
int term ( int n ) { int x = ( ( ( 1 ) + ( double ) sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; return x ; }
bool isMember ( int a , int d , int x ) { if ( d == 0 ) return ( x == a ) ; return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; }
double compute ( int a , int b ) { double AM , GM , HM ; AM = ( a + b ) / 2 ; GM = sqrt ( a * b ) ; HM = ( GM * GM ) / AM ; return HM ; }
int countDigits ( int n ) { int c = 0 ; do { c ++ ; n = n / 10 ; } while ( n != 0 ) ; return c ; }
bool isDeserium ( int x ) { int temp = x ; int p = countDigits ( x ) ; int sum = 0 ; while ( x != 0 ) { int digit = x % 10 ; sum += pow ( digit , p ) ; p -- ; x = x / 10 ; } return ( sum == temp ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int sameRemainder ( int a , int b , int c ) { int a1 = ( b - a ) , b1 = ( c - b ) , c1 = ( c - a ) ; return gcd ( a1 , gcd ( b1 , c1 ) ) ; }
float mean ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; float mean = ( float ) sum / n ; return mean ; }
float sd ( int arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) ; float sdd = sum / n ; return sdd ; }
bool checkDivisibility ( string num ) { int length = num . size ( ) ; if ( length == 1 && num [ 0 ] == '0' ) return true ; if ( length % 3 == 1 ) { num += "00" ; length += 2 ; } else if ( length % 3 == 2 ) { num += "0" ; length += 1 ; } int sum = 0 , p = 1 ; for ( int i = length - 1 ; i >= 0 ; i -- ) { int group = 0 ; group += num [ i -- ] - '0' ; group += ( num [ i -- ] - '0' ) * 10 ; group += ( num [ i ] - '0' ) * 100 ; sum = sum + group * p ; p *= ( -1 ) ; } sum = abs ( sum ) ; return ( sum % 13 == 0 ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findNumber ( int arr [ ] , int n ) { int ans = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) ans = gcd ( ans , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == ans ) return ans ; return -1 ; }
void modularEquation ( int a , int b ) { if ( a < b ) { cout << "No solution possible " << endl ; return ; } if ( a == b ) { cout << "Infinite Solution possible " << endl ; return ; } int count = 0 ; int n = a - b ; int y = sqrt ( a - b ) ; for ( int i = 1 ; i <= y ; ++ i ) { if ( n % i == 0 ) { if ( n / i > b ) count ++ ; if ( i > b ) count ++ ; } } if ( y * y == n && y > b ) count -- ; cout << count << endl ; }
void SieveofEratosthenes ( int n ) { bool visited [ n ] ; for ( int i = 2 ; i <= n + 1 ; i ++ ) if ( ! visited [ i ] ) { for ( int j = i * i ; j <= n + 1 ; j += i ) visited [ j ] = true ; primes . push_back ( i ) ; } }
bool specialPrimeNumbers ( int n , int k ) { SieveofEratosthenes ( n ) ; int count = 0 ; for ( int i = 0 ; i < primes . size ( ) ; i ++ ) { for ( int j = 0 ; j < i - 1 ; j ++ ) { if ( primes [ j ] + primes [ j + 1 ] + 1 == primes [ i ] ) { count ++ ; break ; } } if ( count == k ) return true ; } return false ; }
int minOp ( long long int num ) { int rem ; int count = 0 ; while ( num ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num /= 10 ; } return count ; }
int findSubarraySum ( int arr [ ] , int n , int sum ) { unordered_map < int , int > prevSum ; int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == sum ) res ++ ; if ( prevSum . find ( currsum - sum ) != prevSum . end ( ) ) res += ( prevSum [ currsum - sum ] ) ; prevSum [ currsum ] ++ ; } return res ; }
int minimumMoves ( int A [ ] , int N ) { int one = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] == 1 ) one ++ ; if ( one != 0 ) return N - one ; int minimum = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { int g = A [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { g = __gcd ( A [ j ] , g ) ; if ( g == 1 ) { minimum = min ( minimum , j - i ) ; break ; } } } if ( minimum == INT_MAX ) return -1 ; else return N + minimum - 1 ; }
bool sumSquare ( int n ) { unordered_map < int , int > s ; for ( int i = 0 ; i * i <= n ; ++ i ) { s [ i * i ] = 1 ; if ( s . find ( n - i * i ) != s . end ( ) ) { cout << sqrt ( n - i * i ) << "^2 + " << i << "^2" << endl ; return true ; } } return false ; }
int countPairs ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; }
bool judgeSquareSum ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int count = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { count ++ ; n /= i ; } if ( i % 4 == 3 && count % 2 != 0 ) return false ; } } return n % 4 != 3 ; }
void preCompute ( int mat [ M ] [ N ] , int prefixCnt [ M ] [ N ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 0 ) { prefixCnt [ i ] [ j ] = 1 ; } else { prefixCnt [ i ] [ j ] = 0 ; } } } for ( int i = 0 ; i < M ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) prefixCnt [ i ] [ j ] += prefixCnt [ i ] [ j - 1 ] ; for ( int i = 1 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) prefixCnt [ i ] [ j ] += prefixCnt [ i - 1 ] [ j ] ; }
int countQuery ( int prefixCnt [ M ] [ N ] , int pi , int pj , int qi , int qj ) { int cnt = prefixCnt [ qi ] [ qj ] ; if ( pi > 0 ) cnt -= prefixCnt [ pi - 1 ] [ qj ] ; if ( pj > 0 ) cnt -= prefixCnt [ qi ] [ pj - 1 ] ; if ( pi > 0 && pj > 0 ) cnt += prefixCnt [ pi - 1 ] [ pj - 1 ] ; return cnt ; }
void series ( int n , int d ) { if ( d == 0 ) { for ( int i = 0 ; i < n ; i ++ ) cout << "0 " ; cout << endl ; return ; } if ( n % 2 == 0 ) { for ( int i = 1 ; i <= n ; i ++ ) { cout << pow ( -1 , i ) * d << " " ; } cout << endl ; } else { float m = n ; float r = ( m / ( m - 1 ) ) ; float g = ( float ) ( d * ( float ) sqrtf ( r ) ) ; cout << "0 " ; for ( int i = 1 ; i < n ; i ++ ) { cout << pow ( -1 , i ) * g << " " ; } cout << endl ; } }
int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { string str = to_string ( i ) ; countr += count ( str . begin ( ) , str . end ( ) , '1' ) ; } return countr ; }
int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) { int divider = i * 10 ; countr += ( n / divider ) * i + min ( max ( n % divider - i + 1 , 0 ) , i ) ; } return countr ; }
int countPairs ( int arr [ ] , int n ) { int result = 0 ; set < int > Hash ; for ( int i = 0 ; i < n ; i ++ ) Hash . insert ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; if ( Hash . find ( product ) != Hash . end ( ) ) result ++ ; } } return result ; }
bool check ( long long a , long long b ) { long long int c = 0 ; while ( a != 0 ) { c = c + a % 10 ; a = a / 10 ; } return ( c == b ) ; }
long long root ( long long n ) { bool found = 0 ; long long mx = 1e18 ; for ( long long i = 0 ; i <= 90 ; i ++ ) { long long s = i * i + 4 * n ; long long sq = sqrt ( s ) ; if ( sq * sq == s && check ( ( sq - i ) / 2 , i ) ) { found = 1 ; mx = min ( mx , ( sq - i ) / 2 ) ; } } if ( found ) return mx ; else return -1 ; }
int factors ( long long n ) { unordered_map < int , int > prime ; for ( int i = 2 ; i <= sqrt ( n ) ; ++ i ) { while ( n % i == 0 ) { ++ prime [ i ] ; n = n / i ; } } if ( n > 2 ) ++ prime [ n ] ; int ans1 = 1 , ans2 = 1 ; for ( auto it : prime ) { ans1 *= 2 * it . second + 1 ; ans2 *= it . second + 1 ; } return ans1 - ans2 ; }
int gcdOfFactorial ( int m , int n ) { return factorial ( min ( m , n ) ) ; }
bool asPowerSum ( int w , int m ) { while ( m ) { if ( ( m - 1 ) % w == 0 ) m = ( m - 1 ) / w ; else if ( ( m + 1 ) % w == 0 ) m = ( m + 1 ) / w ; else if ( m % w == 0 ) m = m / w ; else } return ( m == 0 ) ; }
int dotProduct ( int vect_A [ ] , int vect_B [ ] ) { int product = 0 ; for ( int i = 0 ; i < n ; i ++ ) product = product + vect_A [ i ] * vect_B [ i ] ; return product ; }
void crossProduct ( int vect_A [ ] , int vect_B [ ] , int cross_P [ ] ) { cross_P [ 0 ] = vect_A [ 1 ] * vect_B [ 2 ] - vect_A [ 2 ] * vect_B [ 1 ] ; cross_P [ 1 ] = vect_A [ 2 ] * vect_B [ 0 ] - vect_A [ 0 ] * vect_B [ 2 ] ; cross_P [ 2 ] = vect_A [ 0 ] * vect_B [ 1 ] - vect_A [ 1 ] * vect_B [ 0 ] ; }
int calculate ( int n , int power ) { int sum = 0 ; int bp = ( int ) pow ( n , power ) ; while ( bp != 0 ) { int d = bp % 10 ; sum += d ; bp /= 10 ; } return sum ; }
int power ( int x , unsigned int y , int p ) { while ( y > 0 ) { if ( y & 1 ) res = ( 1LL * res * x ) % p ; x = ( 1LL * x * x ) % p ; } return res ; }
int countEvenWays ( int n ) { return power ( 2 , n / 2 - 1 , MOD ) ; }
void cal_factor ( ) { factor [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( int i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( int i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( int j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } }
int no_of_representations ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = a [ i ] ; int flag = 0 ; while ( factor [ temp ] != 1 ) { flag = -1 ; count ++ ; temp = temp / factor [ temp ] ; } count += flag ; } return count ; }
bool coprime ( int a , int b ) { return ( __gcd ( a , b ) == 1 ) ; }
void pairSum ( int n ) { int mid = n / 2 ; for ( int i = mid ; i >= 1 ; i -- ) { if ( coprime ( i , n - i ) == 1 ) { cout << i << " " << n - i ; break ; } } }
int coutSubSeq ( int A [ ] , int N , int M ) { int sum = 0 ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; }
int countSubSeq ( int A [ ] , int N , int M ) { int ans = 0 ; int h [ M ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = A [ i ] % M ; h [ A [ i ] ] ++ ; } for ( int i = 0 ; i < M ; i ++ ) { for ( int j = i ; j < M ; j ++ ) { int rem = ( M - ( i + j ) % M ) % M ; if ( rem < j ) continue ; if ( i == j && rem == j ) ans += h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 ; else if ( i == j ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ; else if ( i == rem ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ; else if ( rem == j ) ans += h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 ; else ans = ans + h [ i ] * h [ j ] * h [ rem ] ; } } return ans ; }
int findTerm ( int n ) { if ( n == 1 ) return n ; else { int term = 7 ; for ( int i = 2 ; i <= n ; i ++ ) term = term * 2 + ( i - 1 ) ; return term ; } }
int findNumber ( int n ) { n -- ; int i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; }
int findNumber ( int n ) { int x = ( int ) floor ( ( -1 + sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ; int base = ( x * ( x + 1 ) ) / 2 + 1 ; return n - base + 1 ; }
float correlationCoefficient ( int X [ ] , int Y [ ] , int n ) { int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; int squareSum_X = 0 , squareSum_Y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ; return corr ; }
void result ( long long n , long long k , long long t ) { if ( t <= k ) cout << t ; else if ( t <= n ) cout << k ; else { long long temp = t - n ; temp = k - temp ; cout << temp ; } }
float weightedMean ( int X [ ] , int W [ ] , int n ) { int sum = 0 , numWeight = 0 ; for ( int i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( float ) numWeight / sum ; }
int weightedMean ( int n ) { return ( 2 * n + 1 ) / 3 ; }
int sumOfDigits ( int a ) { int sum = 0 ; while ( a ) { sum += a % 10 ; a /= 10 ; } return sum ; }
int findMax ( int x ) { int b = 1 , ans = x ; while ( x ) { int cur = ( x - 1 ) * b + ( b - 1 ) ; if ( sumOfDigits ( cur ) > sumOfDigits ( ans ) || ( sumOfDigits ( cur ) == sumOfDigits ( ans ) && cur > ans ) ) ans = cur ; x /= 10 ; b *= 10 ; } return ans ; }
int series ( int n ) { return ( 8 * n * n ) + 1 ; }
double gcd ( double a , double b ) { if ( a < b ) return gcd ( b , a ) ; if ( fabs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - floor ( a / b ) * b ) ) ; }
float harmonicMean ( float arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) 1 / arr [ i ] ; return ( float ) n / sum ; }
float harmonicMean ( int arr [ ] , int freq [ ] , int n ) { float sum = 0 , frequency_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( float ) freq [ i ] / arr [ i ] ; frequency_sum = frequency_sum + freq [ i ] ; } return frequency_sum / sum ; }
void calculate ( int a [ ] , int b [ ] , int n , int m ) { int mul = 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = floor ( a [ i ] / mul ) ; cout << x << " " ; } }
void modBigNumber ( string num , ll m ) { vector < int > vec ; ll mod = 0 ; for ( int i = 0 ; i < num . size ( ) ; i ++ ) { int digit = num [ i ] - '0' ; mod = mod * 10 + digit ; int quo = mod / m ; vec . push_back ( quo ) ; mod = mod % m ; } cout << "Remainder:"   < <   mod   < <   "" cout << "Quotient : " ; bool zeroflag = 0 ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) { if ( vec [ i ] == 0 && zeroflag == 0 ) continue ; zeroflag = 1 ; cout << vec [ i ] ; } return ; }
int findPowerOfP ( int n , int p ) { int count = 0 ; int r = p ; while ( r <= n ) { count += ( n / r ) ; r = r * p ; } return count ; }
vector < pair < int , int > > primeFactorsofK ( int k ) { vector < pair < int , int > > ans ; for ( int i = 2 ; k != 1 ; i ++ ) { if ( k % i == 0 ) { int count = 0 ; while ( k % i == 0 ) { k = k / i ; count ++ ; } ans . push_back ( make_pair ( i , count ) ) ; } } return ans ; }
int largestPowerOfK ( int n , int k ) { vector < pair < int , int > > vec ; vec = primeFactorsofK ( k ) ; int ans = INT_MAX ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) ans = min ( ans , findPowerOfP ( n , vec [ i ] . first ) / vec [ i ] . second ) ; return ans ; }
int calculate_sum ( int a , int N ) { int m = N / a ; int sum = m * ( m + 1 ) / 2 ; int ans = a * sum ; return ans ; }
void fourDistinctFactors ( ) { bool primeAll [ N + 1 ] ; memset ( primeAll , true , sizeof ( primeAll ) ) ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( primeAll [ p ] == true ) { for ( int i = p * 2 ; i <= N ; i += p ) primeAll [ i ] = false ; } } vector < int > prime ; for ( int p = 2 ; p <= N ; p ++ ) if ( primeAll [ p ] ) prime . push_back ( p ) ; for ( int i = 0 ; i < prime . size ( ) ; ++ i ) { int p = prime [ i ] ; if ( 1LL * p * p * p <= N ) fourDiv [ p * p * p ] = true ; for ( int j = i + 1 ; j < prime . size ( ) ; ++ j ) { int q = prime [ j ] ; if ( 1LL * p * q > N ) break ; fourDiv [ p * q ] = true ; } } }
int horner ( int poly [ ] , int n , int x ) { for ( int i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; }
int findSign ( int poly [ ] , int n , int x ) { int result = horner ( poly , n , x ) ; if ( result > 0 ) return 1 ; else if ( result < 0 ) return -1 ; return 0 ; }
float ucal ( float u , int n ) { if ( n == 0 ) return 1 ; float temp = u ; for ( int i = 1 ; i <= n / 2 ; i ++ ) temp = temp * ( u - i ) ; for ( int i = 1 ; i < n / 2 ; i ++ ) temp = temp * ( u + i ) ; return temp ; }
int digitLCM ( int n ) { int lcm = 1 ; while ( n > 0 ) { lcm = boost :: math :: lcm ( n % 10 , lcm ) ; if ( lcm == 0 ) return 0 ; n = n / 10 ; } return lcm ; }
void gcdMax ( int a [ ] , int b [ ] , int n , int N ) { int cnt [ N ] = { 0 } ; int first [ N ] = { 0 } , second [ N ] = { 0 } ; for ( int i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] ) first [ i ] = max ( first [ i ] , j ) ; memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = true ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] ) second [ i ] = max ( second [ i ] , j ) ; int i ; for ( i = N - 1 ; i >= 0 ; i -- ) if ( first [ i ] && second [ i ] ) break ; cout << "Maximum GCD pair with maximum " "sum is " << first [ i ] << " " << second [ i ] << endl ; }
int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
bool ispowerof2 ( cpp_int num ) { if ( ( num & ( num - 1 ) ) == 0 ) return 1 ; return 0 ; }
int median ( int * a , int l , int r ) { int n = r - l + 1 ; n = ( n + 1 ) / 2 - 1 ; return n + l ; }
int IQR ( int * a , int n ) { sort ( a , a + n ) ; int mid_index = median ( a , 0 , n ) ; int Q1 = a [ median ( a , 0 , mid_index ) ] ; int Q3 = a [ mid_index + median ( a , mid_index + 1 , n ) ] ; return ( Q3 - Q1 ) ; }
bool printPierpont ( int n ) { bool arr [ n + 1 ] ; memset ( arr , false , sizeof arr ) ; int two = 1 , three = 1 ; while ( two + 1 < n ) { arr [ two ] = true ; while ( two * three + 1 < n ) { arr [ three ] = true ; arr [ two * three ] = true ; three *= 3 ; } three = 1 ; two *= 2 ; } vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] ) v . push_back ( i + 1 ) ; memset ( arr , false , sizeof arr ) ; for ( int p = 2 ; p * p < n ; p ++ ) { if ( arr [ p ] == false ) for ( int i = p * 2 ; i < n ; i += p ) arr [ i ] = true ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) if ( ! arr [ v [ i ] ] ) cout << v [ i ] << " " ; }
bool isWoodall ( int x ) { if ( x % 2 == 0 ) return false ; if ( x == 1 ) return true ; int p = 0 ; while ( x % 2 == 0 ) { x = x / 2 ; p ++ ; if ( p == x ) return true ; } return false ; }
void print_result ( int a [ ] , int n , int k , int m ) { vector < int > v [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { int rem = a [ i ] % m ; v [ rem ] . push_back ( a [ i ] ) ; if ( v [ rem ] . size ( ) == k ) { for ( int j = 0 ; j < k ; j ++ ) cout << v [ rem ] [ j ] << " " ; return ; } } cout << "-1" ; }
int smallestX ( int n ) { int temp [ 10 ] = { 0 } ; if ( n == 0 ) return -1 ; int count = 0 , x = 0 ; for ( x = 1 ; count < 10 ; x ++ ) { int y = x * n ; while ( y ) { if ( temp [ y % 10 ] == false ) { count ++ ; temp [ y % 10 ] = true ; } y /= 10 ; } } return x - 1 ; }
int digSum ( int n ) { int sum = 0 , rem = 0 ; while ( n ) { rem = n % 10 ; sum += rem ; n /= 10 ; } return sum ; }
int findX ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( i + digSum ( i ) == n ) return i ; return -1 ; }
bool isDivisible ( int x , int y ) { if ( y == 1 ) return true ; if ( __gcd ( x , y ) == 1 ) return false ; return isDivisible ( x , y / gcd ) ; }
bool isDigitPresent ( int m , bool hash [ ] ) { while ( m ) { if ( hash [ m % 10 ] ) return true ; m = m / 10 ; } return false ; }
int countDivisibles ( int n ) { bool hash [ 10 ] = { 0 } ; int m = n ; while ( m ) { hash [ m % 10 ] = true ; m = m / 10 ; } int ans = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( isDigitPresent ( i , hash ) ) ans ++ ; if ( n / i != i ) { if ( isDigitPresent ( n / i , hash ) ) ans ++ ; } } } return ans ; }
void printTwoDivisibleParts ( string num , int f , int s ) { int N = num . length ( ) ; int prefixReminder [ N + 1 ] ; int suffixReminder [ N + 1 ] ; suffixReminder [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) suffixReminder [ i ] = ( suffixReminder [ i - 1 ] * 10 + ( num [ i - 1 ] - '0' ) ) % f ; prefixReminder [ N ] = 0 ; int base = 1 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { prefixReminder [ i ] = ( prefixReminder [ i + 1 ] + ( num [ i ] - '0' ) * base ) % s ; base = ( base * 10 ) % s ; } for ( int i = 0 ; i < N ; i ++ ) { if ( prefixReminder [ i ] == 0 && suffixReminder [ i ] == 0 && num [ i ] != '0' ) { cout << num . substr ( 0 , i ) << " " << num . substr ( i ) << endl ; return ; } } cout << "Not Possible\n" ; }
int sum ( int n ) { int rem = 0 ; int sum_of_digits = 0 ; while ( n > 0 ) { rem = n % 10 ; sum_of_digits += rem ; n = n / 10 ; } return sum_of_digits ; }
int count ( int n ) { int c = 0 ; for ( int i = n - 97 ; i <= n ; i ++ ) { int a = sum ( i ) ; int b = sum ( a ) ; if ( ( i + a + b ) == n ) { c += 1 ; } } return c ; }
bool isPowerOfK ( unsigned int n , unsigned int k ) { bool oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; }
bool isOctal ( long n ) { while ( n ) { if ( ( n % 10 ) >= 8 ) return false ; else n = n / 10 ; } return true ; }
void printFactorialNums ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { cout << fact << " " ; fact = fact * x ; x ++ ; } }
float Cel_To_Fah ( float n ) { return ( ( n * 9.0 / 5.0 ) + 32.0 ) ; }
bool printPairs ( int arr [ ] , int n , int k ) { bool isPairFound = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { cout << "(" << arr [ i ] << ", " << arr [ j ] << ")" << " " ; isPairFound = true ; } } } return isPairFound ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
void print_sequence ( int n , int k ) { int b = n / ( k * ( k + 1 ) / 2 ) ; if ( b == 0 ) { cout << -1 << endl ; } else { int r = 1 ; for ( int x = 1 ; x * x <= n ; x ++ ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; if ( n / x <= b && n / x > r ) r = n / x ; } for ( int i = 1 ; i < k ; i ++ ) cout << r * i << " " ; int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ; cout << res << endl ; } }
ull countCompositions ( ull n ) { return ( 1L ) << ( n - 1 ) ; }
int computeLastDigit ( long long int A , long long int B ) { int variable = 1 ; return 1 ; else if ( ( B - A ) >= 5 )  return 0 ; else { for ( long long int i = A + 1 ; i <= B ; i ++ ) variable = ( variable * ( i % 10 ) )  ; return variable % 10 ; }
unsigned long long findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
int findMin ( int a [ ] , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) int x = exp ( sum / n ) ; return x + 1 ; }
int countdigits ( int N ) { int count = 0 ; while ( N ) { count ++ ; N = N / 10 ; } return count ; }
float sumOfAP ( float a , float d , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + a ; a = a + d ; } return sum ; }
float sumOfAP ( float a , float d , float n ) { float sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; }
bool printPairs ( int arr [ ] , int n , int k ) { unordered_map < int , bool > occ ; for ( int i = 0 ; i < n ; i ++ ) occ [ arr [ i ] ] = true ; bool isPairFound = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( occ [ k ] && k < arr [ i ] ) { cout << "(" << k << ", " << arr [ i ] << ") " ; isPairFound = true ; } if ( arr [ i ] >= k ) { vector < int > v = findDivisors ( arr [ i ] - k ) ; for ( int j = 0 ; j < v . size ( ) ; j ++ ) { if ( arr [ i ] % v [ j ] == k && arr [ i ] != v [ j ] && occ [ v [ j ] ] ) { cout << "(" << arr [ i ] << ", " << v [ j ] << ") " ; isPairFound = true ; } } v . clear ( ) ; } } return isPairFound ; }
int sumOfSeries ( int n ) { int x ; if ( n % 2 == 0 ) x = ( n / 2 ) * ( n + 1 ) ; else x = ( ( n + 1 ) / 2 ) * n ; return x * x ; }
int findValue ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) ans = max ( ans , abs ( arr [ i ] - arr [ j ] ) + abs ( i - j ) ) ; return ans ; }
int findValue ( int arr [ ] , int n ) { int a [ n ] , b [ n ] , tmp ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( arr [ i ] + i ) ; b [ i ] = ( arr [ i ] - i ) ; } int x = a [ 0 ] , y = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) x = a [ i ] ; if ( a [ i ] < y ) y = a [ i ] ; } int ans1 = ( x - y ) ; x = b [ 0 ] ; y = b [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( b [ i ] > x ) x = b [ i ] ; if ( b [ i ] < y ) y = b [ i ] ; } int ans2 = ( x - y ) ; return max ( ans1 , ans2 ) ; }
int countsubarray ( int array [ ] , int n , int k ) { int count = 0 ; int i , j , mul ; for ( i = 0 ; i < n ; i ++ ) { if ( array [ i ] < k ) count ++ ; mul = array [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { mul = mul * array [ j ] ; if ( mul < k ) count ++ ; else break ; } } return count ; }
long long multiplyFactors ( int n ) { long long prod = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; }
long long power ( long long x , long long y ) { long long res = 1 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % M ; y = ( y >> 1 ) % M ; x = ( x * x ) % M ; } return res ; }
int countFactors ( int n ) { int count = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) count ++ ; else count += 2 ; } } return count ; }
long long multiplyFactors ( int n ) { int numFactor = countFactors ( n ) ; long long product = power ( n , numFactor / 2 ) ; if ( numFactor & 1 ) product = ( product * ( int ) sqrt ( n ) ) % M ; return product ; }
int printTrib ( int n ) { int dp [ n ] ; dp [ 0 ] = dp [ 1 ] = 0 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i < n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; for ( int i = 0 ; i < n ; i ++ ) cout << dp [ i ] << " " ; }
void power ( int T [ 3 ] [ 3 ] , int n ) { if ( n == 0 n == 1 ) return ; int M [ 3 ] [ 3 ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; power ( T , n / 2 ) ; multiply ( T , T ) ; if ( n % 2 ) multiply ( T , M ) ; }
int tribonacci ( int n ) { int T [ 3 ] [ 3 ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; if ( n == 0 n == 1 ) return 0 ; else power ( T , n - 2 ) ; return T [ 0 ] [ 0 ] ; }
char getMaxOccuringChar ( char * str ) { int count [ ASCII_SIZE ] = { 0 } ; int len = strlen ( str ) ; int max = 0 ; char result ; for ( int i = 0 ; i < len ; i ++ ) { count [ str [ i ] ] ++ ; if ( max < count [ str [ i ] ] ) { max = count [ str [ i ] ] ; result = str [ i ] ; } } return result ; }
int counDivisors ( int X ) { int count = 0 ; for ( int i = 1 ; i <= X ; ++ i ) { if ( X % i == 0 ) { count ++ ; } } return count ; }
int countDivisorsMult ( int arr [ ] , int n ) { int mul = 1 ; for ( int i = 0 ; i < n ; ++ i ) mul *= arr [ i ] ; return counDivisors ( mul ) ; }
void SieveOfEratosthenes ( int largest , vector < int > & prime ) { bool isPrime [ largest + 1 ] ; memset ( isPrime , true , sizeof ( isPrime ) ) ; for ( int p = 2 ; p * p <= largest ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= largest ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= largest ; p ++ ) if ( isPrime [ p ] ) prime . push_back ( p ) ; }
int countDivisorsMult ( int arr [ ] , int n ) { int largest = * max_element ( arr , arr + n ) ; vector < int > prime ; SieveOfEratosthenes ( largest , prime ) ; unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < prime . size ( ) ; j ++ ) { while ( arr [ i ] > 1 && arr [ i ] % prime [ j ] == 0 ) { arr [ i ] /= prime [ j ] ; mp [ prime [ j ] ] ++ ; } } if ( arr [ i ] != 1 ) mp [ arr [ i ] ] ++ ; } long long int res = 1 ; for ( auto it : mp ) res *= ( it . second + 1L ) ; return res ; }
void generatePrimeFactors ( ) { factor [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( int i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( int i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( int j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } }
int calculateNoOFactors ( int n ) { if ( n == 1 ) return 1 ; int ans = 1 ; int dup = factor [ n ] ; int c = 1 ; int j = n / factor [ n ] ; while ( j != 1 ) { if ( factor [ j ] == dup ) c += 1 ; else { dup = factor [ j ] ; ans = ans * ( c + 1 ) ; c = 1 ; } j = j / factor [ j ] ; } ans = ans * ( c + 1 ) ; return ans ; }
void digit_product_Sum ( int N ) { int a [ N ] ; int product = 1 ; a [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { product = a [ i - 1 ] / 10 ; if ( product == 0 ) product = 1 ; else product = a [ i - 1 ] % 10 ; int val = a [ i - 1 ] / 10 ; if ( val == 0 ) val = a [ i - 1 ] ; a [ i ] = a [ i - 1 ] + ( val * product ) ; } for ( int i = 0 ; i < N ; i ++ ) cout << a [ i ] << " " ; }
float geometricMean ( int arr [ ] , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product = product * arr [ i ] ; float gm = pow ( product , ( float ) 1 / n ) ; return gm ; }
float geometricMean ( int arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + log ( arr [ i ] ) ; sum = sum / n ; return exp ( sum ) ; }
long long int smallestNumber ( int n ) { if ( n >= 0 && n <= 9 ) return n ; stack < int > digits ; for ( int i = 9 ; i >= 2 && n > 1 ; i -- ) { while ( n % i == 0 ) { digits . push ( i ) ; n = n / i ; } } if ( n != 1 ) return -1 ; long long int k = 0 ; while ( ! digits . empty ( ) ) { k = k * 10 + digits . top ( ) ; digits . pop ( ) ; } return k ; }
bool isMagic ( int n ) { int sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return ( sum == 1 ) ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool checkCircular ( int N ) { int count = 0 , temp = N ; while ( temp ) { count ++ ; temp /= 10 ; } int num = N ; while ( isPrime ( num ) ) { int rem = num % 10 ; int div = num / 10 ; num = ( pow ( 10 , count - 1 ) ) * rem + div ; if ( num == N ) return true ; } return false ; }
bool productOfSingelDgt ( int n ) { if ( n >= 0 && n <= 9 ) return true ; int prime [ ] = { 2 , 3 , 5 , 7 } ; for ( int i = 0 ; i < SIZE && n > 1 ; i ++ ) while ( n % prime [ i ] == 0 ) n = n / prime [ i ] ; return ( n == 1 ) ; }
void printSequence ( int n ) { int a = 1 ; int ans = 2 ; for ( int i = 1 ; i <= n ; i ++ ) { cout << ans << " " ; ans = ( ( a % N ) * ( ans % N ) ) % N ; a = ans ; ans = ( ans + 1 ) % N ; } }
int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
int findSum ( int n ) { return n * ( n + 1 ) / 2 ; }
int findSum ( int n ) { if ( n % 2 == 0 ) return ( n / 2 ) * ( n + 1 ) ; else return ( ( n + 1 ) / 2 ) * n ; }
int count ( int x , int y ) { unordered_map < int , int > m ; while ( x % y != 0 ) { x = x % y ; ans ++ ; if ( m . find ( x ) != m . end ( ) ) return -1 ; m [ x ] = 1 ; x = x * 10 ; } return ans ; }
void solve ( int n ) { float a = ( float ) n / 2 ; if ( n % 2 != 0 ) cout << ceil ( a ) - 1 << " " << floor ( a ) + 1 << endl ; else { if ( ( int ) a % 2 == 0 ) { cout << ceil ( a ) - 1 << " " << floor ( a ) + 1 << endl ; } else { cout << ceil ( a ) - 2 << " " << floor ( a ) + 2 << endl ; } } }
int divCount ( int n ) { bool hash [ n + 1 ] ; memset ( hash , true , sizeof ( hash ) ) ; for ( int p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( int i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; int total = 1 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { int count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = n / p ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }
int maxPrimefactorNum ( int N ) { int arr [ N + 1 ] ; memset ( arr , 0 , sizeof ( arr ) ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( ! arr [ i ] ) for ( int j = 2 * i ; j <= N ; j += i ) arr [ j ] ++ ; arr [ i ] = 1 ; } return * max_element ( arr , arr + N ) ; }
int maxPrimefactorNum ( int N ) { if ( N < 2 ) return 0 ; bool arr [ N + 1 ] ; memset ( arr , true , sizeof ( arr ) ) ; int prod = 1 , res = 0 ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == true ) { for ( int i = p * 2 ; i <= N ; i += p ) arr [ i ] = false ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; }
int arraySum ( int arr [ ] , int n ) { int x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; }
int countDigits ( int a , int b ) { int count = 0 ; int p = abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; }
int countDigits ( int a , int b ) { if ( a == 0 b == 0 ) return 1 ; return floor ( log10 ( abs ( a ) ) + log10 ( abs ( b ) ) ) + 1 ; }
int area_fun ( int side ) { int area = side * side ; return area ; }
bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; }
int lastPosition ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; }
int maxSum ( int n ) { if ( n == 1 ) return 1 ; else return ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ; }
bool check ( int n ) { if ( n <= 0 ) return false ; return 1162261467 % n == 0 ; }
void productPuzzle ( int a [ ] , int n ) { long double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( long double ) log10 ( a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) cout << ( int ) ( EPS + pow ( ( long double ) 10.00 , sum - log10 ( a [ i ] ) ) ) << " " ; }
int changeEvenBits ( int n ) { int to_subtract = 0 ; int m = 0 ; for ( int x = n ; x ; x >>= 2 ) { if ( x & 1 ) to_subtract += ( 1 << m ) ; m += 2 ; } return n - to_subtract ; }
int closestNumber ( int n , int m ) { int q = n / m ; int n1 = m * q ; int n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( abs ( n - n1 ) < abs ( n - n2 ) ) return n1 ; return n2 ; }
bool checkPronic ( int x ) { for ( int i = 0 ; i <= ( int ) ( sqrt ( x ) ) ; i ++ ) if ( x == i * ( i + 1 ) ) return true ; return false ; }
long int countConsecutive ( long int N ) { long int count = 0 ; for ( long int L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { double a = ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ; if ( a - ( int ) a == 0.0 ) count ++ ; } return count ; }
int findMinSum ( int num ) { int sum = 0 ; for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; }
int compute_average ( int a , int b ) { return ( a + b ) / 2 ; }
int minNum ( int arr [ ] , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 ) odd += 1 ; return ( odd % 2 ) ? 1 : 2 ; }
int minNum ( int arr [ ] , int n ) { bool odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 ) odd = ! odd ; if ( odd ) return 1 ; return 2 ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int findPrime ( int n ) { int num = n + 1 ; while ( num ) { if ( isPrime ( num ) ) return num ; num = num + 1 ; } return 0 ; }
void sieveOfEratostheneses ( ) { memset ( isPrime , true , sizeof ( isPrime ) ) ; isPrime [ 1 ] = false ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = 2 * i ; j < MAX ; j += i ) isPrime [ j ] = false ; } } }
int findPrime ( int n ) { int num = n + 1 ; while ( num ) { if ( isPrime [ num ] ) return num ; num = num + 1 ; } return 0 ; }
int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; }
int pell ( int n ) { if ( n <= 2 ) return n ; int a = 1 ; int b = 2 ; int c , i ; for ( i = 3 ; i <= n ; i ++ ) { c = 2 * b + a ; a = b ; b = c ; } return b ; }
int nCr ( int n , int r ) { if ( r > n / 2 ) r = n - r ; int answer = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { answer *= ( n - r + i ) ; answer /= i ; } return answer ; }
int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = max ( high , arr [ i ] ) ; int divisors [ high + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++ ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ; } } } for ( int i = high ; i >= 1 ; i -- ) if ( divisors [ i ] > 1 ) return i ; }
int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = max ( high , arr [ i ] ) ; int count [ high + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; int counter = 0 ; for ( int i = high ; i >= 1 ; i -- ) { int j = i ; counter = 0 ; while ( j <= high ) { if ( count [ j ] >= 2 ) return j ; else if ( count [ j ] == 1 ) counter ++ ; j += i ; if ( counter == 2 ) return i ; } } }
int count_one ( int n ) { int c_one = 0 ; while ( n != 0 ) { int rem = n % 10 ; if ( rem == 1 ) c_one = c_one + 1 ; n = n / 10 ; } return c_one ; }
int checkEvil ( int n ) { int i = 0 , bin = 0 , n_one = 0 ; while ( n != 0 ) { int r = n % 2 ; bin = bin + r * ( int ) ( pow ( 10 , i ) ) ; n = n / 2 ; } n_one = count_one ( bin ) ; if ( n_one % 2 == 0 ) return 1 ; else return 0 ; }
int calculateLeaps ( int n ) { if ( n == 0 n == 1 ) { return 1 ; } else { int leaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } }
int power ( long long int x , long long int y , long long int p ) { long long int res = 1 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
void printLastKDigits ( int a , int b , int k ) { cout << "Last " << k ; cout << " digits of " << a ; cout << "^" << b << " = " ; int temp = 1 ; for ( int i = 1 ; i <= k ; i ++ ) temp *= 10 ; temp = power ( a , b , temp ) ; for ( int i = 0 ; i < k - numberOfDigits ( temp ) ; i ++ ) cout << 0 ; if ( temp ) cout << temp ; }
int msbPos ( int n ) { int pos = 0 ; while ( n != 0 ) { pos ++ ; n = n >> 1 ; } return pos ; }
int josephify ( int n ) { int position = msbPos ( n ) ; int j = 1 << ( position - 1 ) ; n = n ^ j ; n = n << 1 ; n = n | 1 ; return n ; }
int CountPairs ( int n ) { int k = n ; int imin = 1 ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / imin ; } return ans ; }
int reverseDigits ( int num ) { int rev = 0 ; while ( num > 0 ) { rev = rev * 10 + num % 10 ; num /= 10 ; } return rev ; }
int square ( int num ) { return ( num * num ) ; }
bool checkAdamNumber ( int num ) { int a = square ( num ) ; int b = square ( reverseDigits ( num ) ) ; if ( a == reverseDigits ( b ) ) return true ; return false ; }
int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; }
int totalDigits ( int n ) { int number_of_digits = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) number_of_digits += ( n - i + 1 ) ; return number_of_digits ; }
int findSum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) sum = sum + arr [ i ] ; } return sum ; }
void decToBinary ( int n ) { int binaryNum [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) cout << binaryNum [ j ] ; }
int decimalToBinary ( int N ) { ull B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; ull c = pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } return B_Number ; }
long int stirlingFactorial ( int n ) { if ( n == 1 ) return 1 ; long int z ; z = sqrt ( 2 * 3.14 * n ) * pow ( ( n / e ) , n ) ; return z ; }
int countXorPair ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; }
int countXorPair ( int arr [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return odd * even ; }
ll count_of_ways ( ll n ) { ll count ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
bool isPalindrome ( long number ) { return number == reverse ( number ) ; }
long reverse ( long number ) { long reverse = 0 ; while ( number > 0 ) { long remainder = number % 10 ; reverse = ( reverse * 10 ) + remainder ; number = number / 10 ; } return reverse ; }
int sub ( int a , int b ) { return a + flipSign ( b ) ; }
int mul ( int a , int b ) { if ( a < b ) return mul ( b , a ) ; int sum = 0 ; for ( int i = abs ( b ) ; i > 0 ; i -- ) sum += a ; if ( b < 0 ) sum = flipSign ( sum ) ; return sum ; }
int division ( int a , int b ) { if ( b == 0 ) throw ( b ) ; int quotient = 0 , dividend ; int divisor = flipSign ( abs ( b ) ) ; for ( dividend = abs ( a ) ; dividend >= abs ( divisor ) ; dividend += divisor ) quotient ++ ; if ( areDifferentSign ( a , b ) ) quotient = flipSign ( quotient ) ; return quotient ; }
int numOfCombinations ( int arr [ ] , int N ) { int C [ 3 ] = { 0 , 0 , 0 } ; for ( int i = 0 ; i < N ; ++ i ) ++ C [ arr [ i ] % 3 ] ; return C [ 1 ] * C [ 2 ] + C [ 0 ] * ( C [ 0 ] - 1 ) / 2 + C [ 0 ] * ( C [ 0 ] - 1 ) * ( C [ 0 ] - 2 ) / 6 + C [ 1 ] * ( C [ 1 ] - 1 ) * ( C [ 1 ] - 2 ) / 6 + C [ 2 ] * ( C [ 2 ] - 1 ) * ( C [ 2 ] - 2 ) / 6 + C [ 0 ] * C [ 1 ] * C [ 2 ] ; }
int powmod ( int x , int y , int p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) sqrt ( m ) + 1 ; unordered_map < int , int > value ; for ( int i = n ; i >= 1 ; -- i ) value [ powmod ( a , i * n , m ) ] = i ; for ( int j = 0 ; j < n ; ++ j ) { int cur = ( powmod ( a , j , m ) * b ) % m ; if ( value [ cur ] ) { int ans = value [ cur ] * n - j ; if ( ans < m ) return ans ; } } return -1 ; }
int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) sqrt ( m ) + 1 ; int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * a ) % m ; unordered_map < int , int > value ; for ( int i = 1 , cur = an ; i <= n ; ++ i ) { if ( ! value [ cur ] ) value [ cur ] = i ; cur = ( cur * an ) % m ; } for ( int i = 0 , cur = b ; i <= n ; ++ i ) { if ( value [ cur ] ) { int ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return -1 ; }
int findRectNum ( int n ) { return n * ( n + 1 ) ; }
float f ( float x ) { return 1 * pow ( x , 3 ) + 2 * x * x + 10 * x - 20 ; }
void Muller ( float a , float b , float c ) { int i ; float res ; for ( i = 0 ; ; ++ i ) { float f1 = f ( a ) ; float f2 = f ( b ) ; float f3 = f ( c ) ; float d1 = f1 - f3 ; float d2 = f2 - f3 ; float h1 = a - c ; float h2 = b - c ; float a0 = f3 ; float a1 = ( ( ( d2 * pow ( h1 , 2 ) ) - ( d1 * pow ( h2 , 2 ) ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; float a2 = ( ( ( d1 * h2 ) - ( d2 * h1 ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; float x = ( ( -2 * a0 ) / ( a1 + abs ( sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; float y = ( ( -2 * a0 ) / ( a1 - abs ( sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; if ( x >= y ) res = x + c ; else res = y + c ; float m = res * 100 ; float n = c * 100 ; m = floor ( m ) ; n = floor ( n ) ; if ( m == n ) break ; a = b ; b = c ; c = res ; if ( i > MAX_ITERATIONS ) { cout << "Root cannot be found using" << " Muller's method" ; break ; } } if ( i <= MAX_ITERATIONS ) cout << "The value of the root is " << res ; }
int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
int countPairs ( int N ) { int count = 0 ; for ( int i = 1 ; i <= cbrt ( N ) ; i ++ ) { int cb = i * i * i ; int diff = N - cb ; int cbrtDiff = cbrt ( diff ) ; if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; } return count ; }
ll findMinValue ( ll arr [ ] , ll n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) val += ( ld ) ( log ( ( ld ) ( arr [ i ] ) ) ) ; ll left = arr [ 0 ] , right = arr [ n - 1 ] + 1 ; ll ans ; while ( left <= right ) { ll mid = ( left + right ) / 2 ; ld temp = ( ld ) n * ( ld ) ( log ( ( ld ) ( mid ) ) ) ; if ( val < temp ) { ans = mid ; right = mid - 1 ; } else left = mid + 1 ; } return ans ; }
bool isprime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) if ( x % i == 0 ) return false ; return true ; }
bool isSumOfKprimes ( int N , int K ) { if ( N < 2 * K ) return false ; if ( K == 1 ) return isprime ( N ) ; if ( K == 2 ) { if ( N % 2 == 0 ) return true ; return isprime ( N - 2 ) ; } return true ; }
int sumOfTermsInNthRow ( int n ) { int sum = n * ( 2 * pow ( n , 2 ) + 1 ) ; return sum ; }
void printEqualModNumbers ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int d = arr [ n - 1 ] - arr [ 0 ] ; if ( d == 0 ) { cout << "Infinite solution" ; return ; } vector < int > v ; for ( int i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) { v . push_back ( i ) ; if ( i != d / i ) v . push_back ( d / i ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int temp = arr [ 0 ] % v [ i ] ; int j ; for ( j = 1 ; j < n ; j ++ ) if ( arr [ j ] % v [ i ] != temp ) break ; if ( j == n ) cout << v [ i ] << " " ; } }
int firstDigit ( int x ) { while ( x >= 10 ) x = x / 10 ; return x ; }
int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; }
int FindLCM ( int a , int b ) { return ( a * b ) / __gcd ( a , b ) ; }
int rangeDivisor ( int m , int n , int a , int b ) { int lcm = FindLCM ( a , b ) ; int a_divisor = n / a - ( m - 1 ) / a ; int b_divisor = n / b - ( m - 1 ) / b ; int common_divisor = n / lcm - ( m - 1 ) / lcm ; int ans = a_divisor + b_divisor - common_divisor ; return ans ; }
int getOccurence ( int n , int d ) { int itr = d ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && itr / 10 == d ) { result ++ ; itr ++ ; } else if ( itr / 10 == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; }
void printUnique ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { int num = i ; bool visited [ 10 ] = { false } ; while ( num ) { if ( visited [ num % 10 ] ) break ; visited [ num % 10 ] = true ; num = num / 10 ; } if ( num == 0 ) cout << i << " " ; } }
int findSumOfDigits ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) multiply ( v , i ) ; int sum = 0 ; int size = v . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) sum += v [ i ] ; return sum ; }
int findMinZero ( int p ) { int first = 1 , second = 1 , number = 2 , next = 1 ; while ( next ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }
int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; for ( int i = 2 ; i <= n ; i ++ ) if ( ( n % i == 0 ) && ( ( n / i ) % 2 == 1 ) ) return i ; }
int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int resul = 1 ; while ( n % 2 == 0 ) { n /= 2 ; resul *= 2 ; } return resul ; }
int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { if ( N % 2 == 0 ) return 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) res ^= arr [ i ] ; return res ; }
int printKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return -1 ; }
int div ( int x ) { int ans = 0 ; for ( int i = 1 ; i <= x ; i ++ ) if ( x % i == 0 ) ans += i ; return ans ; }
void sieve ( int n ) { vector < bool > prime ( n + 1 , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . push_back ( p ) ; }
int factorialDivisors ( int n ) { int result = 1 ; for ( int i = 0 ; i < allPrimes . size ( ) ; i ++ ) { int p = allPrimes [ i ] ; int exp = 0 ; while ( p <= n ) { exp = exp + ( n / p ) ; p = p * allPrimes [ i ] ; } result = result * ( pow ( allPrimes [ i ] , exp + 1 ) - 1 ) / ( allPrimes [ i ] - 1 ) ; } return result ; }
int countIterations ( int arr [ ] , int n ) { bool oneFound = false ; int res = 0 ; for ( int i = 0 ; i < n ; ) { if ( arr [ i ] == 1 ) oneFound = true ; while ( i < n && arr [ i ] == 1 ) i ++ ; int count_zero = 0 ; while ( i < n && arr [ i ] == 0 ) { count_zero ++ ; i ++ ; } if ( oneFound == false && i == n ) return -1 ; int curr_count ; if ( i < n && oneFound == true ) { if ( count_zero & 1 == 0 ) curr_count = count_zero / 2 ; else curr_count = ( count_zero + 1 ) / 2 ; count_zero = 0 ; } else { curr_count = count_zero ; count_zero = 0 ; } res = max ( res , curr_count ) ; } return res ; }
bool isAutomorphic ( int N ) { int sq = N * N ; while ( N > 0 ) { if ( N % 10 != sq % 10 ) return false ; N /= 10 ; sq /= 10 ; } return true ; }
void printConsecutive ( int last , int first ) { cout << first ++ ; for ( int x = first ; x <= last ; x ++ ) cout << " + " << x ; }
void findConsecutive ( int N ) { for ( int last = 1 ; last < N ; last ++ ) { for ( int first = 0 ; first < last ; first ++ ) { if ( 2 * N == ( last - first ) * ( last + first + 1 ) ) { cout << N << " = " ; printConsecutive ( last , first + 1 ) ; return ; } } } cout << "-1" ; }
void printCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { for ( int j = 1 ; j * j * j <= i ; j ++ ) { if ( j * j * j == i ) { cout << j * j * j << " " ; break ; } } } }
void printCubes ( int a , int b ) { int acrt = cbrt ( a ) ; int bcrt = cbrt ( b ) ; for ( int i = acrt ; i <= bcrt ; i ++ ) if ( i * i * i >= a && i * i * i <= b ) cout << i * i * i << " " ; }
int findCount ( int m , int n ) { int num1 = 0 ; for ( int i = 0 ; i < m ; i ++ ) num1 = ( num1 * 10 ) + 9 ; int num2 = 0 ; for ( int i = 0 ; i < ( m - 1 ) ; i ++ ) num2 = ( num2 * 10 ) + 9 ; return ( ( num1 / n ) - ( num2 / n ) ) ; }
int findNthEvenDigitNumber ( int n ) { int count = 0 ; for ( int i = 0 ; ; i ++ ) { int curr = i ; bool isCurrEvenDigit = true ; while ( curr != 0 ) { if ( curr % 10 == 1 curr % 10 == 3 curr % 10 == 5 curr % 10 == 7 curr % 10 == 9 ) isCurrEvenDigit = false ; curr = curr / 10 ; } if ( isCurrEvenDigit == true ) count ++ ; if ( count == n ) return i ; } }
int findNthEvenDigitNumber ( int n ) { if ( n == 1 ) return 0 ; vector < int > v ; n = n - 1 ; while ( n > 0 ) { v . push_back ( n % 5 ) ; n = n / 5 ; } int result = 0 ; for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) { result = result * 10 ; result = result + v [ i ] ; } return 2 * result ; }
int fibonacci ( int n ) { int a = 0 , b = 1 , c ; if ( n <= 1 ) return n ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; }
bool isMultipleOf10 ( int n ) { int f = fibonacci ( 30 ) ; return ( f % 10 == 0 ) ; }
bool isMultipleOf10 ( int n ) { return ( n % 15 == 0 ) ; }
bool isDivisibleBy25 ( string str ) { int n = str . length ( ) ; if ( n == 1 ) return false ; return ( ( str [ n - 1 ] - '0' == 0 && str [ n - 2 ] - '0' == 0 ) || ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 25 == 0 ) ; }
int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; }
bool isLeap ( int y ) { if ( y % 100 != 0 && y % 4 == 0 y % 400 == 0 ) return true ; return false ; }
int offsetDays ( int d , int m , int y ) { int offset = d ; switch ( m - 1 ) { case 11 : offset += 30 ; case 10 : offset += 31 ; case 9 : offset += 30 ; case 8 : offset += 31 ; case 7 : offset += 31 ; case 6 : offset += 30 ; case 5 : offset += 31 ; case 4 : offset += 30 ; case 3 : offset += 31 ; case 2 : offset += 28 ; case 1 : offset += 31 ; } if ( isLeap ( y ) && m > 2 ) offset += 1 ; return offset ; }
void addDays ( int d1 , int m1 , int y1 , int x ) { int offset1 = offsetDays ( d1 , m1 , y1 ) ; int remDays = isLeap ( y1 ) ? ( 366 - offset1 ) : ( 365 - offset1 ) ; int y2 , offset2 ; if ( x <= remDays ) { y2 = y1 ; offset2 = offset1 + x ; } else { x -= remDays ; y2 = y1 + 1 ; int y2days = isLeap ( y2 ) ? 366 : 365 ; while ( x >= y2days ) { x -= y2days ; y2 ++ ; y2days = isLeap ( y2 ) ? 366 : 365 ; } offset2 = x ; } int m2 , d2 ; revoffsetDays ( offset2 , y2 , & d2 , & m2 ) ; cout << "d2 = " << d2 << ", m2 = " << m2 << ", y2 = " << y2 ; }
int divisorSum ( int N , int K ) { int sum = 0 ; for ( int i = 2 ; i <= ceil ( sqrt ( N ) ) ; i ++ ) if ( N % i == 0 ) sum += ( i + N / i ) ; return sum ; }
bool isPrime ( int n ) { if ( n == 1 n == 0 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool isHyperPerfect ( int N , int K ) { int sum = divisorSum ( N , K ) ; if ( ( 1 + K * ( sum ) ) == N ) return true ; else return false ; }
void printWellOrdered ( int number , int x , int k ) { if ( k == 0 ) { cout << number << " " ; return ; } for ( int i = ( x + 1 ) ; i < 10 ; i ++ ) printWellOrdered ( number * 10 + i , i , k - 1 ) ; }
void generateWellOrdered ( int k ) { printWellOrdered ( 0 , 0 , k ) ; }
long long moduloMultiplication ( long long a , long long b , long long mod ) { a %= mod ; while ( b ) { if ( b & 1 ) res = ( res + a ) % mod ; a = ( 2 * a ) % mod ; } return res ; }
int number0f2s ( int n ) { int count = 0 ; while ( n > 0 ) { if ( n % 10 == 2 ) count ++ ; n = n / 10 ; } return count ; }
int numberOf2sinRange ( int n ) { int count = 0 ; for ( int i = 2 ; i <= n ; i ++ ) count += number0f2s ( i ) ; return count ; }
int numberOf2sinRange ( int n ) { string s = "" ; for ( int i = 0 ; i < n + 1 ; i ++ ) s += to_string ( i ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '2' ) { count ++ ; } } return count ; }
int count2sinRangeAtDigit ( int number , int d ) { int powerOf10 = ( int ) pow ( 10 , d ) ; int nextPowerOf10 = powerOf10 * 10 ; int right = number % powerOf10 ; int roundDown = number - number % nextPowerOf10 ; int roundup = roundDown + nextPowerOf10 ; int digit = ( number / powerOf10 ) % 10 ; if ( digit < 2 ) return roundDown / 10 ; if ( digit == 2 ) return roundDown / 10 + right + 1 ; return roundup / 10 ; }
int numberOf2sinRange ( int number ) { stringstream convert ; convert << number ; string s = convert . str ( ) ; int len = s . length ( ) ; int count = 0 ; for ( int digit = 0 ; digit < len ; digit ++ ) count += count2sinRangeAtDigit ( number , digit ) ; return count ; }
bool isDivisibleBy5 ( string str ) { int n = str . length ( ) ; return ( ( ( str [ n - 1 ] - '0' ) == 0 ) || ( ( str [ n - 1 ] - '0' ) == 5 ) ) ; }
bool isTidy ( int num ) { int prev = 10 ; while ( num ) { int rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; }
int areMirror ( Node * a , Node * b ) { if ( a == NULL && b == NULL ) return true ; if ( a == NULL b == NULL ) return false ; return a -> data == b -> data && areMirror ( a -> left , b -> right ) && areMirror ( a -> right , b -> left ) ; }
void printPairs ( int arr [ ] , int n ) { vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) v . push_back ( abs ( arr [ i ] ) ) ; if ( v . size ( ) == 0 ) return ; sort ( v . begin ( ) , v . end ( ) ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << - v [ i ] << " " << v [ i ] ; }
int minToggle ( int arr [ ] , int n ) { int zero [ n + 1 ] ; zero [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } int ans = n ; for ( int i = 1 ; i <= n ; ++ i ) ans = min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; }
unsigned long long int LCM ( int arr [ ] , int n ) { int max_num = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( max_num < arr [ i ] ) max_num = arr [ i ] ; unsigned long long int res = 1 ; while ( x <= max_num ) { vector < int > indexes ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] % x == 0 ) indexes . push_back ( j ) ; if ( indexes . size ( ) >= 2 ) { for ( int j = 0 ; j < indexes . size ( ) ; j ++ ) arr [ indexes [ j ] ] = arr [ indexes [ j ] ] / x ; res = res * x ; } else x ++ ; } for ( int i = 0 ; i < n ; i ++ ) res = res * arr [ i ] ; return res ; }
void kFactors ( int n , int k ) { vector < int > P ; while ( n % 2 == 0 ) { P . push_back ( 2 ) ; n /= 2 ; } for ( int i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; P . push_back ( i ) ; } } if ( n > 2 ) P . push_back ( n ) ; if ( P . size ( ) < k ) { cout << "-1" << endl ; return ; } for ( int i = 0 ; i < k - 1 ; i ++ ) cout << P [ i ] << ", " ; int product = 1 ; for ( int i = k - 1 ; i < P . size ( ) ; i ++ ) product = product * P [ i ] ; cout << product << endl ; }
long long nondecdigits ( long long n ) { long long int x = 0 ; for ( x = n ; x >= 1 ; x -- ) { int no = x ; int prev_dig = 11 ; bool flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no /= 10 ; } if ( flag == true ) break ; } return x ; }
void nondecdigits ( string s ) { long long m = s . size ( ) ; long long a [ m ] ; for ( long long i = 0 ; i < m ; i ++ ) a [ i ] = s [ i ] - '0' ; long long level = m - 1 ; for ( long long i = m - 1 ; i > 0 ; i -- ) { if ( a [ i ] < a [ i - 1 ] ) { a [ i - 1 ] -- ; level = i - 1 ; } } if ( a [ 0 ] != 0 ) { for ( long long i = 0 ; i <= level ; i ++ ) cout << a [ i ] ; for ( long long i = level + 1 ; i < m ; i ++ ) cout << "9" ; } else { for ( long long i = 1 ; i < level ; i ++ ) cout << a [ i ] ; for ( long long i = level + 1 ; i < m ; i ++ ) cout << "9" ; } }
int countDivisors ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cnt ++ ; cnt = cnt + 2 ; } } return cnt ; }
bool hasEvenNumberOfFactors ( int n ) { int root_n = sqrt ( n ) ; if ( ( root_n * root_n ) == n ) return false ; return true ; }
void printStatusOfDoors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( hasEvenNumberOfFactors ( i ) ) cout << "closed" << " " ; else cout << "open" << " " ; } }
bool validate ( long long int n ) { for ( int i = 0 ; i < 10 ; i ++ ) { long long int temp = n ; int count = 0 ; while ( temp ) { if ( temp % 10 == i ) count ++ ; if ( count > i ) return false ; temp /= 10 ; } } return true ; }
int check ( string str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 9 == 0 ) ; }
int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i ; j < N ; j ++ ) for ( int k = i ; k <= j ; k ++ ) res = res ^ arr [ k ] ; return res ; }
int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; }
bool check ( string str ) { int n = str . length ( ) ; if ( ( str [ n - 1 ] - '0' ) % 2 != 0 ) return false ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 3 == 0 ) ; }
int checkPrime ( int n ) { if ( n <= 1 ) return -1 ; if ( n <= 3 ) return 0 ; if ( n % 2 == 0 n % 3 == 0 ) return -1 ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return -1 ; return 0 ; }
void printPrimePoints ( int n ) { int count = countDigits ( n ) ; if ( count == 1 count == 2 ) { cout << "-1" ; return ; } bool found = false ; for ( int i = 1 ; i < ( count - 1 ) ; i ++ ) { int left = n / ( ( int ) pow ( 10 , count - i ) ) ; int right = n % ( ( int ) pow ( 10 , count - i - 1 ) ) ; if ( checkPrime ( left ) == 0 && checkPrime ( right ) == 0 ) { cout << i << " " ; found = true ; } } if ( found == false ) cout << "-1" ; }
int countOddPrimeFactors ( int n ) { int result = 1 ; while ( n % 2 == 0 ) n /= 2 ; for ( int i = 3 ; i * i <= n ; i += 2 ) { int divCount = 0 ; while ( n % i == 0 ) { n /= i ; ++ divCount ; } result *= divCount + 1 ; } if ( n > 2 ) result *= 2 ; return result ; }
int politness ( int n ) { return countOddPrimeFactors ( n ) - 1 ; }
int politness ( int n ) { int count = 0 ; for ( int i = 2 ; i <= sqrt ( 2 * n ) ; i ++ ) { int a ; if ( ( 2 * n ) % i != 0 ) continue ; a = 2 * n ; a /= i ; a -= ( i - 1 ) ; if ( a % 2 != 0 ) continue ; a /= 2 ; if ( a > 0 ) { count ++ ; } } return count ; }
int power ( int num , unsigned int n ) { if ( n == 0 ) return 1 ; else if ( n % 2 == 0 ) return power ( num , n / 2 ) * power ( num , n / 2 ) ; else return num * power ( num , n / 2 ) * power ( num , n / 2 ) ; }
int checkRecursive ( int num , int x , int k , int n ) { if ( x == 0 ) res ++ ; int r = ( int ) floor ( pow ( num , 1.0 / n ) ) ; for ( int i = k + 1 ; i <= r ; i ++ ) { int a = x - ( int ) pow ( i , n ) ; if ( a >= 0 ) checkRecursive ( num , x - ( int ) pow ( i , n ) , i , n ) ; } return res ; }
int check ( int x , int n ) { return checkRecursive ( x , x , 0 , n ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int check ( string str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 3 == 0 ) ; }
int reverseNum ( int n ) { int rem , rev = 0 ; while ( n ) { rem = n % 10 ; rev = rev * 10 + rem ; n /= 10 ; } return rev ; }
bool isPalindrom ( int num ) { return num == reverseNum ( num ) ; }
int nthPalindrome ( int n , int k ) { int num = ( int ) pow ( 10 , k - 1 ) ; while ( true ) { if ( isPalindrom ( num ) ) -- n ; if ( ! n ) break ; ++ num ; } return num ; }
int findMax ( int n , int a [ ] , int b [ ] , int k [ ] , int m ) { int arr [ n ] ; memset ( arr , 0 , sizeof ( arr ) ) ; for ( int i = 0 ; i < m ; i ++ ) { int lowerbound = a [ i ] ; int upperbound = b [ i ] ; for ( int j = lowerbound ; j <= upperbound ; j ++ ) arr [ j ] += k [ i ] ; } int res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) res = max ( res , arr [ i ] ) ; return res ; }
bool isPerfectSquare ( int n ) { int sq = ( int ) sqrt ( n ) ; return ( n == sq * sq ) ; }
int countPerfectDivisors ( int n ) { int count = 0 ; for ( int i = 1 ; i * i <= n ; ++ i ) { if ( n % i == 0 ) { if ( isPerfectSquare ( i ) ) ++ count ; if ( n / i != i && isPerfectSquare ( n / i ) ) ++ count ; } } return count ; }
void precomputeCounts ( ) { for ( int i = 1 ; i * i < MAX ; ++ i ) { for ( int j = i * i ; j < MAX ; j += i * i ) ++ perfectDiv [ j ] ; } }
int countPerfectDivisors ( int n ) { return perfectDiv [ n ] ; }
void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } }
int getDigitProduct ( int x ) { if ( x < 10 ) return x ; if ( prodDig [ x ] != 0 ) return prodDig [ x ] ; int prod = ( x % 10 ) * getDigitProduct ( x / 10 ) ; return ( prodDig [ x ] = prod ) ; }
void findSeed ( int n ) { vector < int > res ; for ( int i = 1 ; i <= n / 2 ; i ++ ) if ( i * getDigitProduct ( i ) == n ) res . push_back ( i ) ; if ( res . size ( ) == 0 ) { cout << "NO seed exists\n" ; return ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << " " ; }
void sieveOfEratosthenes ( ) { for ( int i = 2 ; i * i < MAX ; ++ i ) { if ( ! primedivisor [ i ] ) for ( int j = i * i ; j < MAX ; j += i ) primedivisor [ j ] = i ; } for ( int i = 1 ; i < MAX ; ++ i ) if ( ! primedivisor [ i ] ) primedivisor [ i ] = i ; }
void findDivisors ( int arr [ ] , int n ) { for ( int i = 0 ; i < MAX ; ++ i ) pos [ i ] = divInd [ i ] = -1 , dist [ i ] = INF ; for ( int i = 0 ; i < n ; ++ i ) { int num = arr [ i ] ; while ( num > 1 ) { int div = primedivisor [ num ] ; divisors [ i ] . push_back ( div ) ; while ( num % div == 0 ) num /= div ; } } }
void nearestGCD ( int arr [ ] , int n ) { findDivisors ( arr , n ) ; for ( int i = 0 ; i < n ; ++ i ) { for ( auto & div : divisors [ i ] ) { if ( divInd [ div ] == -1 ) divInd [ div ] = i ; else { int ind = divInd [ div ] ; divInd [ div ] = i ; if ( dist [ i ] > abs ( ind - i ) ) { dist [ i ] = abs ( ind - i ) ; pos [ i ] = ind + 1 ; } if ( dist [ ind ] > abs ( ind - i ) ) { dist [ ind ] = abs ( ind - i ) ; pos [ ind ] = i + 1 ; } } } } }
int maxPrimefactorNum ( int N ) { int arr [ N + 5 ] ; memset ( arr , 0 , sizeof ( arr ) ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( ! arr [ i ] ) for ( int j = 2 * i ; j <= N ; j += i ) arr [ j ] ++ ; arr [ i ] = 1 ; } int maxval = 0 , maxint = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] > maxval ) { maxval = arr [ i ] ; maxint = i ; } } return maxint ; }
int maxPrimefactorNum ( int N ) { bool arr [ N + 5 ] ; memset ( arr , true , sizeof ( arr ) ) ; for ( int i = 3 ; i * i <= N ; i += 2 ) { if ( arr [ i ] ) for ( int j = i * i ; j <= N ; j += i ) arr [ j ] = false ; } vector < int > prime ; prime . push_back ( 2 ) ; for ( int i = 3 ; i <= N ; i += 2 ) if ( arr [ i ] ) prime . push_back ( i ) ; int i = 0 , ans = 1 ; while ( ans * prime [ i ] <= N && i < prime . size ( ) ) { ans *= prime [ i ] ; i ++ ; } return ans ; }
void sieveSundaram ( ) { bool marked [ MAX / 2 + 100 ] = { 0 } ; for ( int i = 1 ; i <= ( sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ; primes . push_back ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . push_back ( 2 * i + 1 ) ; }
int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; int maxele = * max_element ( arr , arr + n ) ; for ( int i = 2 ; i <= maxele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = max ( ans , count ) ; } return ans ; }
void SieveOfEratosthenes ( ) { for ( int i = 2 ; i * i <= MAX ; ++ i ) { if ( ! prime [ i ] ) for ( int j = i * 2 ; j <= MAX ; j += i ) prime [ j ] = i ; } for ( int i = 1 ; i < MAX ; ++ i ) if ( ! prime [ i ] ) prime [ i ] = i ; }
int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int element = arr [ i ] ; while ( element > 1 ) { int div = prime [ element ] ; ++ countdiv [ div ] ; ans = max ( ans , countdiv [ div ] ) ; while ( element % div == 0 ) element /= div ; } } return ans ; }
int countOfBinaryNumberLessThanN ( int N ) { queue < int > q ; q . push ( 1 ) ; int cnt = 0 ; int t ; while ( ! q . empty ( ) ) { t = q . front ( ) ; q . pop ( ) ; if ( t <= N ) { cnt ++ ; q . push ( t * 10 ) ; q . push ( t * 10 + 1 ) ; } } return cnt ; }
long int SubArraySum ( int arr [ ] , int n ) { long int result = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; }
int nthElement ( int a , int b , int n ) { vector < int > seq ; for ( int i = 1 ; i <= n ; i ++ ) seq . push_back ( a * i ) ; sort ( seq . begin ( ) , seq . end ( ) ) ; for ( int i = 1 , k = n ; i <= n && k ; i ++ ) { if ( ! binary_search ( seq . begin ( ) , seq . end ( ) , b * i ) ) { seq . push_back ( b * i ) ; sort ( seq . begin ( ) , seq . end ( ) ) ; k -- ; } } return seq [ n - 1 ] ; }
bool findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }
int multiplicativeOrder ( int A , int N ) { if ( GCD ( A , N ) != 1 ) return -1 ; unsigned int result = 1 ; int K = 1 ; while ( K < N ) { result = ( result * A ) % N ; if ( result == 1 ) return K ; K ++ ; } return -1 ; }
int sumOfRange ( int a , int b ) { int i = ( a * ( a + 1 ) ) >> 1 ; int j = ( b * ( b + 1 ) ) >> 1 ; return ( i - j ) ; }
int sumofproduct ( int n ) { int sum = 0 ; int root = sqrt ( n ) ; for ( int i = 1 ; i <= root ; i ++ ) { int up = n / i ; int low = max ( n / ( i + 1 ) , root ) ; sum += ( i * sumOfRange ( up , low ) ) ; sum += ( i * ( n / i ) ) ; } return sum ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int power ( int x , unsigned int y , int p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
void findPrimefactors ( unordered_set < int > & s , int n ) { while ( n % 2 == 0 ) { s . insert ( 2 ) ; n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { s . insert ( i ) ; n = n / i ; } } if ( n > 2 ) s . insert ( n ) ; }
int findPrimitive ( int n ) { unordered_set < int > s ; if ( isPrime ( n ) == false ) return -1 ; int phi = n - 1 ; findPrimefactors ( s , phi ) ; for ( int r = 2 ; r <= phi ; r ++ ) { bool flag = false ; for ( auto it = s . begin ( ) ; it != s . end ( ) ; it ++ ) { if ( power ( r , phi / ( * it ) , n ) == 1 ) { flag = true ; break ; } } if ( flag == false ) return r ; } return -1 ; }
int kPrimeFactor ( int n , int k ) { while ( n % 2 == 0 ) { k -- ; n = n / 2 ; if ( k == 0 ) return 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( k == 1 ) return i ; k -- ; n = n / i ; } } if ( n > 2 && k == 1 ) return n ; return -1 ; }
void sieveOfEratosthenes ( int s [ ] ) { vector < bool > prime ( MAX + 1 , false ) ; for ( int i = 2 ; i <= MAX ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= MAX ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= MAX ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } }
int kPrimeFactor ( int n , int k , int s [ ] ) { while ( n > 1 ) { if ( k == 1 ) return s [ n ] ; k -- ; n /= s [ n ] ; } return -1 ; }
int gcd ( int a , int b ) { return b ? gcd ( b , a % b ) : a ; }
int countGCD ( int L , int R , int g ) { L = ( L + g - 1 ) / g ; R = R / g ; int ans = 0 ; for ( int i = L ; i <= R ; i ++ ) for ( int j = L ; j <= R ; j ++ ) if ( gcd ( i , j ) == 1 ) ans ++ ; return ans ; }
int minPower ( int n , int x ) { if ( x == 1 ) return n ; int ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n /= x ; } return ans ; }
int calSum ( int n ) { int a = 3 , b = 0 , c = 2 ; return 3 ; return 3 ; return 5 ; int sum = 5 ; while ( n > 2 ) { sum += d ; a = b ; b = c ; c = d ; n -- ; } return sum ; }
int sumDivisorsOfDivisors ( int n ) { map < int , int > mp ; for ( int j = 2 ; j <= sqrt ( n ) ; j ++ ) { int count = 0 ; while ( n % j == 0 ) { n /= j ; count ++ ; } if ( count ) mp [ j ] = count ; } if ( n != 1 ) mp [ n ] = 1 ; int ans = 1 ; for ( auto it : mp ) { int pw = 1 ; int sum = 0 ; for ( int i = it . second + 1 ; i >= 1 ; i -- ) { sum += ( i * pw ) ; pw *= it . first ; } ans *= sum ; } return ans ; }
int findMinNumber ( int n ) { int count = 0 , ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 2 ) ans *= 2 ; for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 2 ) ans *= i ; } if ( n > 2 ) ans *= n ; return ans ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void findgcd ( int n , int x , int y ) { int g = gcd ( x , y ) ; for ( int i = 0 ; i < g ; i ++ ) cout << n ; }
int gcd ( int a , int b ) { if ( ( a % b ) == 0 ) return b ; return gcd ( b , a % b ) ; }
int firstFactorialDivisibleNumber ( int x ) { int new_x = x ; for ( i = 1 ; i < x ; i ++ ) { new_x /= gcd ( i , new_x ) ; if ( new_x == 1 ) break ; } return i ; }
int countFactorialXNotY ( int x , int y ) { return ( firstFactorialDivisibleNumber ( y ) - firstFactorialDivisibleNumber ( x ) ) ; }
int firstFactorialDivisibleNumber ( int x ) { int fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }
int gcd ( int a , int b ) { if ( ( a % b ) == 0 ) return b ; return gcd ( b , a % b ) ; }
int firstFactorialDivisibleNumber ( int x ) { int new_x = x ; for ( i = 1 ; i < x ; i ++ ) { new_x /= gcd ( i , new_x ) ; if ( new_x == 1 ) break ; } return i ; }
cpp_int fact ( int n ) { cpp_int num = 1 ; for ( int i = 1 ; i <= n ; i ++ ) num = num * i ; return num ; }
bool SieveOfEratosthenes ( int n , bool isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) isPrime [ i ] = false ; } } }
int highestPowerof2 ( int n ) { int res = 0 ; for ( int i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; }
int highestPowerof2 ( int n ) { int p = ( int ) log2 ( n ) ; return ( int ) pow ( 2 , p ) ; }
int getFirstDigit ( int x ) { while ( x >= 10 ) x /= 10 ; return x ; }
int getCountWithSameStartAndEndFrom1 ( int x ) { if ( x < 10 ) return x ; int tens = x / 10 ; int res = tens + 9 ; int firstDigit = getFirstDigit ( x ) ; int lastDigit = x % 10 ; if ( lastDigit < firstDigit ) res -- ; return res ; }
int getCountWithSameStartAndEnd ( int start , int end ) { return getCountWithSameStartAndEndFrom1 ( end ) - getCountWithSameStartAndEndFrom1 ( start - 1 ) ; }
bool sieveOfEratosthenes ( int n , bool isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } }
bool rightTruPrime ( int n ) { bool isPrime [ n + 1 ] ; sieveOfEratosthenes ( n , isPrime ) ; while ( n ) { if ( isPrime [ n ] ) n = n / 10 ; else return false ; } return true ; }
int countMaxChoco ( int money , int price , int wrap ) { if ( money < price ) return 0 ; int choc = money / price ; choc = choc + ( choc - 1 ) / ( wrap - 1 ) ; return choc ; }
void SieveOfEratosthenes ( int n , bool prime [ ] ) { for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } }
void mersennePrimes ( int n ) { bool prime [ n + 1 ] ; SieveOfEratosthenes ( n , prime ) ; for ( int k = 2 ; ( ( 1 << k ) - 1 ) <= n ; k ++ ) { long long num = ( 1 << k ) - 1 ; if ( prime [ num ] ) cout << num << " " ; } }
int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }
int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
void sieve ( bool prime [ ] , int n ) { prime [ 0 ] = prime [ 1 ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } }
int maxDigitInPrimes ( int L , int R ) { bool prime [ R + 1 ] ; memset ( prime , 0 , sizeof ( prime ) ) ; sieve ( prime , R ) ; int freq [ 10 ] = { 0 } ; int val ; for ( int i = L ; i <= R ; i ++ ) { if ( ! prime [ i ] ) { while ( p ) { freq [ p % 10 ] ++ ; p /= 10 ; } } } int max = freq [ 0 ] , ans = 0 ; for ( int j = 1 ; j < 10 ; j ++ ) { if ( max <= freq [ j ] ) { max = freq [ j ] ; ans = j ; } } return ( max != 0 ) ? ans : -1 ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void simpleSieve ( ) { memset ( arr , true , sizeof ( arr ) ) ; for ( int p = 2 ; p * p < 1001 ; p ++ ) { if ( arr [ p ] ) { for ( int i = p * 2 ; i < 1001 ; i = i + p ) arr [ i ] = false ; } } }
int find_sphene ( int N ) { int arr1 [ 8 ] = { 0 } ; int count = 0 ; int j = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( N % i == 0 && count < 9 ) { count ++ ; arr1 [ j ++ ] = i ; } } if ( count == 8 && ( arr [ arr1 [ 1 ] ] && arr [ arr1 [ 2 ] ] && arr [ arr1 [ 3 ] ] ) ) return 1 ; return 0 ; }
int maxHandshake ( int n ) { return ( n * ( n - 1 ) ) / 2 ; }
int gcd ( int i , int j ) { if ( i == j ) return i ; if ( i > j ) return gcd ( i - j , j ) ; return gcd ( i , j - i ) ; }
bool ispossible ( int x , int y , int a , int b ) { x = abs ( x ) , y = abs ( y ) , a = abs ( a ) , b = abs ( b ) ; return ( gcd ( x , y ) == gcd ( a , b ) ) ; }
unsigned int ApowBmodM ( string & a , unsigned int b , unsigned int m ) { unsigned int ans = aModM ( a , m ) ; unsigned int mul = ans ; for ( unsigned int i = 1 ; i < b ; i ++ ) ans = ( ans * mul ) % m ; return ans ; }
bool divisible ( string N , int digit ) { int ans = 0 ; for ( int i = 0 ; i < N . length ( ) ; i ++ ) { ans = ( ans * 10 + ( N [ i ] - '0' ) ) ; ans %= digit ; } return ( ans == 0 ) ; }
int allDigits ( string N ) { bool divide [ 10 ] = { false } ; for ( int digit = 2 ; digit <= 9 ; digit ++ ) { if ( divisible ( N , digit ) ) divide [ digit ] = true ; } int result = 0 ; for ( int i = 0 ; i < N . length ( ) ; i ++ ) { if ( divide [ N [ i ] - '0' ] == true ) result ++ ; } return result ; }
int countNums ( int n , int x , int y ) { vector < bool > arr ( n + 1 , false ) ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; int result = 0 ; for ( int i = min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; }
int reverse ( int x ) { int rev = 0 ; while ( x > 0 ) { rev = ( rev * 10 ) + x % 10 ; x = x / 10 ; } return rev ; }
void printEmirp ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { int rev = reverse ( p ) ; if ( p != rev && rev <= n && prime [ rev ] ) { cout << p << " " << rev << " " ; prime [ rev ] = false ; } } } }
int getSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; { sum = sum + i ; sum = sum + ( n / i ) ; } } } sum = sum - n ; return sum ; }
bool checkAbundant ( int n ) { return ( getSum ( n ) > n ) ; }
int longLenSub ( int arr [ ] , int n ) { unordered_map < int , int > um ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( um . find ( arr [ i ] - 1 ) != um . end ( ) && len < um [ arr [ i ] - 1 ] ) len = um [ arr [ i ] - 1 ] ; if ( um . find ( arr [ i ] + 1 ) != um . end ( ) && len < um [ arr [ i ] + 1 ] ) len = um [ arr [ i ] + 1 ] ; um [ arr [ i ] ] = len + 1 ; if ( longLen < um [ arr [ i ] ] ) longLen = um [ arr [ i ] ] ; } return longLen ; }
bool isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; }
int divisorsSum ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { sum = sum + i ; } { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum ; }
bool isDeficient ( int n ) { return ( divisorsSum ( n ) < ( 2 * n ) ) ; }
bool isKeith ( int x ) { vector < int > terms ; while ( temp > 0 ) { terms . push_back ( temp % 10 ) ; temp = temp / 10 ; n ++ ; } reverse ( terms . begin ( ) , terms . end ( ) ) ; int next_term = 0 , i = n ; while ( next_term < x ) { next_term = 0 ; for ( int j = 1 ; j <= n ; j ++ ) next_term += terms [ i - j ] ; terms . push_back ( next_term ) ; i ++ ; } return ( next_term == x ) ; }
int hcf ( int a , int b ) { if ( b == 0 ) return a ; return hcf ( b , a % b ) ; }
int findlcm ( int a , int b ) { if ( b == 1 ) return a ; a = ( a * b ) / hcf ( a , b ) ; b -= 1 ; return findlcm ( a , b ) ; }
bool canBeSumofConsec ( unsigned int n ) { return ( ( n & ( n - 1 ) ) && n ) ; }
void Sieve ( ) { int n = MAX ; int nNew = sqrt ( n ) ; int marked [ n / 2 + 500 ] = { 0 } ; for ( int i = 1 ; i <= ( nNew - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= n / 2 ; j = j + 2 * i + 1 ) marked [ j ] = 1 ; primes . push_back ( 2 ) ; for ( int i = 1 ; i <= n / 2 ; i ++ ) if ( marked [ i ] == 0 ) primes . push_back ( 2 * i + 1 ) ; }
int binarySearch ( int left , int right , int n ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( mid == 0 || mid == primes . size ( ) - 1 ) return primes [ mid ] ; if ( primes [ mid ] == n ) return primes [ mid - 1 ] ; if ( primes [ mid ] < n && primes [ mid + 1 ] > n ) return primes [ mid ] ; if ( n < primes [ mid ] ) return binarySearch ( left , mid - 1 , n ) ; else return binarySearch ( mid + 1 , right , n ) ; } return 0 ; }
int evenFibSum ( int limit ) { if ( limit < 2 ) return 0 ; long long int ef1 = 0 , ef2 = 2 ; long long int sum = ef1 + ef2 ; while ( ef2 <= limit ) { long long int ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return sum ; }
bool isPerfect ( int n ) { int s = sqrt ( n ) ; return ( s * s == n ) ; }
int divisorsCount ( int n ) { int count = 0 ; for ( int i = 1 ; i <= sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) count += 1 ; else count += 2 ; } } return count ; }
long int evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }
void buildSegtmentTree ( int node , int a , int b ) { if ( a == b ) { segmentTree [ node ] = divisors [ a ] ; return ; } buildSegtmentTree ( 2 * node , a , ( a + b ) / 2 ) ; buildSegtmentTree ( 2 * node + 1 , ( ( a + b ) / 2 ) + 1 , b ) ; segmentTree [ node ] = max ( segmentTree [ 2 * node ] , segmentTree [ 2 * node + 1 ] ) ; }
int query ( int node , int a , int b , int l , int r ) { if ( l > b a > r ) return -1 ; if ( a >= l && b <= r ) return segmentTree [ node ] ; return max ( query ( 2 * node , a , ( a + b ) / 2 , l , r ) , query ( 2 * node + 1 , ( ( a + b ) / 2 ) + 1 , b , l , r ) ) ; }
int countSteps ( int x , int y ) { if ( x % y == 0 ) return x / y ; return x / y + countSteps ( y , x % y ) ; }
void primeFactorize ( int a ) { for ( int i = 2 ; i * i <= a ; i += 2 ) { int cnt = 0 ; while ( a % i == 0 ) { cnt ++ ; a /= i ; } ma [ i ] = cnt ; } if ( a > 1 ) { ma [ a ] = 1 ; } }
int commDiv ( int a , int b ) { primeFactorize ( a ) ; int res = 1 ; for ( auto m = ma . begin ( ) ; m != ma . end ( ) ; m ++ ) { int cnt = 0 ; int key = m -> first ; int value = m -> second ; while ( b % key == 0 ) { b /= key ; cnt ++ ; } res *= ( min ( cnt , value ) + 1 ) ; } return res ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
float y ( float x ) { return 1 / ( 1 + x * x ) ; }
float trapezoidal ( float a , float b , float n ) { float h = ( b - a ) / n ; float s = y ( a ) + y ( b ) ; for ( int i = 1 ; i < n ; i ++ ) s += 2 * y ( a + i * h ) ; return ( h / 2 ) * s ; }
ll spellsCount ( string num ) { int n = num . length ( ) ; ll result = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; while ( i < n - 1 && num [ i + 1 ] == num [ i ] ) { count ++ ; i ++ ; } result = result * pow ( 2 , count - 1 ) ; } return result ; }
int numSquareSum ( int n ) { int squareSum = 0 ; while ( n ) { squareSum += ( n % 10 ) * ( n % 10 ) ; n /= 10 ; } return squareSum ; }
bool isHappynumber ( int n ) { int slow , fast ; slow = fast = n ; do { slow = numSquareSum ( slow ) ; fast = numSquareSum ( numSquareSum ( fast ) ) ; } while ( slow != fast ) ; return ( slow == 1 ) ; }
int kaprekar ( int n ) { int prev = 0 ; return kaprekarRec ( n , prev ) ; }
float sqroot ( float s ) { int pSq = 0 ; int N = 0 ; for ( int i = static_cast < int > ( s ) ; i > 0 ; i -- ) { for ( int j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } float d = s - pSq ; float P = d / ( 2.0 * N ) ; float A = N + P ; float sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; return sqrt_of_s ; }
int power ( int x , int a ) { int res = 1 ; while ( a ) { if ( a & 1 ) res = res * x ; x = x * x ; a >>= 1 ; } return res ; }
int breakInteger ( int N ) { if ( N == 2 ) return 1 ; if ( N == 3 ) return 2 ; int maxProduct ; switch ( N % 3 ) { case 0 : maxProduct = power ( 3 , N / 3 ) ; break ; case 1 : maxProduct = 2 * 2 * power ( 3 , ( N / 3 ) - 1 ) ; break ; case 2 : maxProduct = 2 * power ( 3 , N / 3 ) ; break ; } return maxProduct ; }
int maxProd ( int n ) { if ( n == 2 n == 3 ) return ( n - 1 ) ; int res = 1 ; while ( n > 4 ) { n -= 3 ; res *= 3 ; } return ( n * res ) ; }
int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
int countMultiples ( int n ) { return n / 3 + n / 7 - n / 21 ; }
void sieve ( int n ) { vector < bool > prime ( n + 1 , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . push_back ( p ) ; }
ull factorialDivisors ( ull n ) { ull result = 1 ; for ( int i = 0 ; i < allPrimes . size ( ) ; i ++ ) { ull p = allPrimes [ i ] ; ull exp = 0 ; while ( p <= n ) { exp = exp + ( n / p ) ; p = p * allPrimes [ i ] ; } result = result * ( exp + 1 ) ; } return result ; }
int nonFibonacci ( int n ) { int prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; }
long long reversDigits ( long long num ) { long long rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }
bool isPalindrome ( long long num ) { return ( reversDigits ( num ) == num ) ; }
int countOddSquares ( int n , int m ) { return ( int ) pow ( m , 0.5 ) - ( int ) pow ( n - 1 , 0.5 ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; int k ; for ( k = 0 ; ( ( a b ) & 1 ) == 0 ; ++ k ) { a >>= 1 ; b >>= 1 ; } while ( ( a & 1 ) == 0 ) a >>= 1 ; do { while ( ( b & 1 ) == 0 ) b >>= 1 ; if ( a > b ) swap ( a , b ) ; b = ( b - a ) ; } while ( b != 0 ) ; return a << k ; }
int gcd ( int a , int b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; { return gcd ( a >> 1 , b ) ; return gcd ( a >> 1 , b >> 1 ) << 1 ; } return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; }
int countWindowDistinct ( int win [ ] , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int j ; for ( j = 0 ; j < i ; j ++ ) if ( win [ i ] == win [ j ] ) break ; if ( j == i ) dist_count ++ ; } return dist_count ; }
int toInt ( char x ) { return int ( x ) - '0' ; }
int findNDigitNums ( int n ) { char out [ n + 1 ] ; int index = 0 ; int evenSum = 0 , oddSum = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) { out [ index ] = i + '0' ; findNDigitNumsUtil ( n , out , index + 1 , evenSum + i , oddSum ) ; } }
void findNDigitNumsUtil ( int n , int sum , char * out , int index ) { if ( index > n sum < 0 ) return ; if ( index == n ) { if ( sum == 0 ) { out [ index ] = '\0' ; cout << out << " " ; } return ; } for ( int i = 0 ; i <= 9 ; i ++ ) { out [ index ] = i + '0' ; findNDigitNumsUtil ( n , sum - i , out , index + 1 ) ; } }
void findNDigitNums ( int n , int sum ) { char out [ n + 1 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) { out [ 0 ] = i + '0' ; findNDigitNumsUtil ( n , sum - i , out , 1 ) ; } }
void operation ( int n , int k ) { bool answered = false ; if ( n < k ) { answered = true ; cout << "No" << "\n" ; } bool ok = factors ( n , k ) ; if ( ! ok && ! answered ) { answered = true ; cout << "No" << "\n" ; } if ( ok && ! answered ) cout << "Yes" << "\n" ; }
bool isPalUtil ( int num , int * dupNum ) { if ( oneDigit ( num ) ) return ( num == ( * dupNum ) % 10 ) ; if ( ! isPalUtil ( num / 10 , dupNum ) ) return false ; * dupNum /= 10 ; return ( num % 10 == ( * dupNum ) % 10 ) ; }
int isPal ( int num ) { if ( num < 0 ) num = - num ; return isPalUtil ( num , dupNum ) ; }
void printPalPrimesLessThanN ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] && isPal ( p ) ) cout << p << " " ; }
int countPrimeFactors ( int n ) { int count = 0 ; while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; }
void printKAlmostPrimes ( int k , int n ) { for ( int i = 1 , num = 2 ; i <= n ; num ++ ) { if ( countPrimeFactors ( num ) == k ) { printf ( "%d " , num ) ; i ++ ; } } return ; }
int findPieces ( int n ) { return ( n * ( n + 1 ) ) / 2 + 1 ; }
string numToWords ( int n , string s ) { string str = "" ; if ( n > 19 ) str += ten [ n / 10 ] + one [ n % 10 ] ; else str += one [ n ] ; if ( n ) str += s ; return str ; }
string convertToWords ( long n ) { string out ; out += numToWords ( ( n / 10000000 ) , "crore " ) ; out += numToWords ( ( ( n / 100000 ) % 100 ) , "lakh " ) ; out += numToWords ( ( ( n / 1000 ) % 100 ) , "thousand " ) ; out += numToWords ( ( ( n / 100 ) % 10 ) , "hundred " ) ; if ( n > 100 && n % 100 ) out += "and " ; out += numToWords ( ( n % 100 ) , "" ) ; return out ; }
long long findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ) ; return floor ( x ) + 1 ; }
int findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += log10 ( i ) ; return floor ( digits ) + 1 ; }
void findPairs ( int n ) { int cubeRoot = pow ( n , 1.0 / 3.0 ) ; int cube [ cubeRoot + 1 ] ; for ( int i = 1 ; i <= cubeRoot ; i ++ ) cube [ i ] = i * i * i ; int l = 1 ; int r = cubeRoot ; while ( l < r ) { if ( cube [ l ] + cube [ r ] < n ) l ++ ; else if ( cube [ l ] + cube [ r ] > n ) r -- ; else { cout << "(" << l << ", " << r << ")" << endl ; l ++ ; r -- ; } } }
int countEvenSum ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int sum = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { sum = sum + arr [ j ] ; if ( sum % 2 == 0 ) result ++ ; } } return ( result ) ; }
int countEvenSum ( int arr [ ] , int n ) { int temp [ 2 ] = { 1 , 0 } ; int result = 0 , sum = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { sum = ( ( sum + arr [ i ] ) % 2 + 2 ) % 2 ; temp [ sum ] ++ ; } result = result + ( temp [ 0 ] * ( temp [ 0 ] - 1 ) / 2 ) ; result = result + ( temp [ 1 ] * ( temp [ 1 ] - 1 ) / 2 ) ; return ( result ) ; }
long long countEvenSum ( int a [ ] , int n ) { long long res = 0 ; int s = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] % 2 == 1 ) { s = n - i - 1 - s ; } else { s = s + 1 ; } res = res + s ; } return res ; }
bool isPossible ( int a , int b , int c ) { return ( c % gcd ( a , b ) == 0 ) ; }
int gcd ( int a , int b ) { while ( b != 0 ) { int t = b ; b = a % b ; a = t ; } return a ; }
int findMinDiff ( int a , int b , int x , int y ) { int g = gcd ( a , b ) ; int diff = abs ( x - y ) % g ; return min ( diff , g - diff ) ; }
int calculateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; int sum = fibo [ 0 ] + fibo [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; }
void findCombinations ( int n ) { int arr [ n ] ; findCombinationsUtil ( arr , 0 , n , n ) ; }
bool isPower ( int x , int y ) { int res1 = log ( y ) / log ( x ) ; return ( res1 == res2 ) ; }
bool isPerfectSquare ( int n ) { for ( int sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; }
int findCount ( int d ) { return 9 * ( pow ( 10 , d - 1 ) - pow ( 9 , d - 1 ) ) ; }
int countDyckPaths ( unsigned int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; }
void printDivisors ( int n ) { vector < int > v ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) printf ( "%d " , i ) ; else { printf ( "%d " , i ) ; v . push_back ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) printf ( "%d " , v [ i ] ) ; }
void printDivisors ( int n ) { int i ; for ( i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) cout << i << " " ; } if ( i - ( n / i ) == 1 ) { i -- ; } for ( ; i >= 1 ; i -- ) { if ( n % i == 0 ) cout << n / i << " " ; } }
void printDivisors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) cout << " " << i ; }
bool isTriangular ( int num ) { if ( num < 0 ) return false ; int sum = 0 ; for ( int n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; }
int has0 ( int x ) { while ( x ) { if ( x % 10 == 0 ) return 1 ; x /= 10 ; } return 0 ; }
int getCount ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) count += has0 ( i ) ; return count ; }
char xor_c ( char a , char b ) { return ( a == b ) ? '0' : '1' ; }
int greyConverter ( int n ) { return n ^ ( n >> 1 ) ; }
int seriesSum ( int calculated , int current , int N ) { int i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return ( gcd ( b , a % b ) ) ; }
void findSmallest ( int a , int b ) { int lcm = ( a * b ) / gcd ( a , b ) ; cout << "x = " << lcm / a << "y="  }
int power ( int x , int y , int p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
void squareRoot ( int n , int p ) { if ( p % 4 != 3 ) { cout << "Invalid Input" ; return ; } n = n % p ; int x = power ( n , ( p + 1 ) / 4 , p ) ; if ( ( x * x ) % p == n ) { cout << "Square root is " << x ; return ; } x = p - x ; if ( ( x * x ) % p == n ) { cout << "Square root is " << x ; return ; } cout << "Square root doesn't exist " ; }
int getSum ( int BITree [ ] , int index ) { while ( index > 0 ) { sum += BITree [ index ] ; index -= index & ( - index ) ; } return sum ; }
void convert ( int arr [ ] , int n ) { int temp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) temp [ i ] = arr [ i ] ; sort ( temp , temp + n ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = lower_bound ( temp , temp + n , arr [ i ] ) - temp + 1 ; } }
int getInvCount ( int arr [ ] , int n ) { convert ( arr , n ) ; int BIT [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) BIT [ i ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { invcount += getSum ( BIT , arr [ i ] - 1 ) ; updateBIT ( BIT , n , arr [ i ] , 1 ) ; } return invcount ; }
int modFact ( int n , int p ) { if ( n >= p ) return 0 ; int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = ( result * i ) % p ; return result ; }
int largestPower ( int n , int p ) { int x = 0 ; while ( n ) { n /= p ; x += n ; } return x ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
int modFact ( int n , int p ) { if ( n >= p ) return 0 ; int res = 1 ; bool isPrime [ n + 1 ] ; memset ( isPrime , 1 , sizeof ( isPrime ) ) ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = 2 * i ; j <= n ; j += i ) isPrime [ j ] = 0 ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( isPrime [ i ] ) { int k = largestPower ( n , i ) ; res = ( res * power ( i , k , p ) ) % p ; } } return res ; }
int modInverse ( int a , int p ) { return power ( a , p - 2 , p ) ; }
int power ( int x , unsigned int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
bool miillerTest ( int d , int n ) { int a = 2 + rand ( ) % ( n - 4 ) ; int x = power ( a , d , n ) ; if ( x == 1 x == n - 1 ) return true ; while ( d != n - 1 ) { x = ( x * x ) % n ; d *= 2 ; if ( x == 1 ) return false ; if ( x == n - 1 ) return true ; } return false ; }
bool isPrime ( int n , int k ) { if ( n <= 1 n == 4 ) return false ; if ( n <= 3 ) return true ; int d = n - 1 ; while ( d % 2 == 0 ) d /= 2 ; for ( int i = 0 ; i < k ; i ++ ) if ( ! miillerTest ( d , n ) ) return false ; return true ; }
int inv ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m , a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; }
int findMinX ( int num [ ] , int rem [ ] , int k ) { int prod = 1 ; for ( int i = 0 ; i < k ; i ++ ) prod *= num [ i ] ; int result = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int pp = prod / num [ i ] ; result += rem [ i ] * inv ( pp , num [ i ] ) * pp ; } return result % prod ; }
int findMinX ( int num [ ] , int rem [ ] , int k ) { while ( true ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } return x ; }
int largestFiboLessOrEqual ( int n ) { fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; int i ; for ( i = 2 ; fib [ i - 1 ] <= n ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; return ( i - 2 ) ; }
bool isValid ( int n , int d ) { int digit = n % 10 ; int sum = digit ; if ( digit == d ) return false ; n /= 10 ; while ( n ) { digit = n % 10 ; if ( digit == d digit <= sum ) return false ; else { sum += digit ; n /= 10 ; } } return 1 ; }
int countSquares ( int m , int n ) { if ( n < m ) swap ( m , n ) ; return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; }
int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return n * ( n + 1 ) * ( 3 * m - n + 1 ) / 6 ; }
void printFibRepresntation ( int n ) { while ( n > 0 ) { int f = nearestSmallerEqFib ( n ) ; cout << f << " " ; n = n - f ; } }
int countWaysUtil ( int n , int parts , int nextPart ) { if ( parts == 0 && n == 0 ) return 1 ; if ( n <= 0 parts <= 0 ) return 0 ; if ( dp [ n ] [ nextPart ] [ parts ] != -1 ) return dp [ n ] [ nextPart ] [ parts ] ; for ( int i = nextPart ; i <= n ; i ++ ) ans += countWaysUtil ( n - i , parts - 1 , i ) ; return ( dp [ n ] [ nextPart ] [ parts ] = ans ) ; }
int countWays ( int n ) { memset ( dp , -1 , sizeof ( dp ) ) ; return countWaysUtil ( n , 4 , 1 ) ; }
int pairAndSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; }
ll Euler_totient_function ( ll n ) { ll result = 1 ; for ( ll i = 2 ; i * i <= n ; i ++ ) { ll c = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { c ++ ; n /= i ; } } if ( c > 0 ) { ll power = ( ll ) pow ( i , c - 1 ) ; ll sm = ( ll ) pow ( i , c - 1 ) * ( i - 1 ) ; result *= sm ; } } if ( n > 1 ) { result *= ( n - 1 ) ; } return result ; }
int nextSparse ( int x ) { vector < bool > bin ; while ( x != 0 ) { bin . push_back ( x & 1 ) ; x >>= 1 ; } bin . push_back ( 0 ) ; int last_final = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( bin [ i ] == 1 && bin [ i - 1 ] == 1 && bin [ i + 1 ] != 1 ) { bin [ i + 1 ] = 1 ; for ( int j = i ; j >= last_final ; j -- ) bin [ j ] = 0 ; last_final = i + 1 ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += bin [ i ] * ( 1 << i ) ; return ans ; }
bool isPower ( unsigned n ) { float p ; if ( n <= 1 ) return 1 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { p = log2 ( n ) / log2 ( i ) ; if ( ( ceil ( p ) == floor ( p ) ) && p > 1 ) return true ; } return false ; }
int sumBitDifferences ( int arr [ ] , int n ) { for ( int i = 0 ; i < 32 ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) ) count ++ ; ans += ( count * ( n - count ) * 2 ) ; } return ans ; }
void generateUtil ( int x , int arr [ ] , int curr_sum , int curr_idx ) { if ( curr_sum == x ) { printArr ( arr , curr_idx ) ; return ; } int num = 1 ; while ( num <= x - curr_sum && ( curr_idx == 0 num <= arr [ curr_idx - 1 ] ) ) { arr [ curr_idx ] = num ; generateUtil ( x , arr , curr_sum + num , curr_idx + 1 ) ; num ++ ; } }
void generate ( int x ) { int arr [ x ] ; generateUtil ( x , arr , 0 , 0 ) ; }
bool isPerfect ( long long int n ) { long long int sum = 1 ; for ( long long int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; }
bool check ( int num , int dig ) { for ( int base = 2 ; base <= 32 ; base ++ ) if ( checkUtil ( num , dig , base ) ) return true ; return false ; }
bool isLucky ( int n ) { bool arr [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; }
int countFact ( int low , int high ) { int fact = 1 , x = 1 ; while ( fact < low ) { fact = fact * x ; x ++ ; } int res = 0 ; while ( fact <= high ) { res ++ ; fact = fact * x ; x ++ ; } return res ; }
int nthMagicNo ( int n ) { int pow = 1 , answer = 0 ; while ( n ) { pow = pow * 5 ; if ( n & 1 ) answer += pow ; } return answer ; }
int modInverse ( int a , int m ) { for ( int x = 1 ; x < m ; x ++ ) if ( ( ( a % m ) * ( x % m ) ) % m == 1 ) return x ; }
int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m , a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int phi ( unsigned int n ) { unsigned int result = 1 ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) result ++ ; return result ; }
int phi ( int n ) { float result = n ; for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / ( float ) p ) ) ; } } if ( n > 1 ) result *= ( 1.0 - ( 1.0 / ( float ) n ) ) ; return ( int ) result ; }
int getDifference ( Date dt1 , Date dt2 ) { long int n1 = dt1 . y * 365 + dt1 . d ; for ( int i = 0 ; i < dt1 . m - 1 ; i ++ ) n1 += monthDays [ i ] ; n1 += countLeapYears ( dt1 ) ; long int n2 = dt2 . y * 365 + dt2 . d ; for ( int i = 0 ; i < dt2 . m - 1 ; i ++ ) n2 += monthDays [ i ] ; n2 += countLeapYears ( dt2 ) ; return ( n2 - n1 ) ; }
unsigned countOfMultiples ( unsigned n ) { return ( n / 3 + n / 5 - n / 15 ) ; }
int getPeriod ( int n ) { int rem = 1 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ; int d = rem ; int count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; }
int calculateAddedValue ( int number ) { int result = 0 ; int decimalPlace = 1 ; if ( number == 0 ) { result += ( 5 * decimalPlace ) ; } while ( number > 0 ) { if ( number % 10 == 0 ) { result += ( 5 * decimalPlace ) ; } number /= 10 ; decimalPlace *= 10 ; } return result ; }
int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }
int getRemainder ( int num , int divisor ) { while ( num >= divisor ) num -= divisor ; return num ; }
int minInsertion ( string str ) { int n = str . length ( ) ; int res = 0 ; int count [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ str [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( count [ i ] % 2 == 1 ) res ++ ; return ( res == 0 ) ? 0 : res - 1 ; }
int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
double sum ( int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 1.0 / factorial ( i ) ; return sum ; }
double sum ( int n ) { double sum = 0 ; int fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { fact *= i ; sum += 1.0 / fact ; } return sum ; }
unsigned long int catalan ( unsigned int n ) { unsigned long int c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { cout << square << " " ; square = square + odd ; odd = odd + 2 ; } }
bool isOperand ( char c ) { return ( c >= '0' && c <= '9' ) ; }
int value ( char c ) { return ( c - '0' ) ; }
int evaluate ( char * exp ) { if ( * exp == '\0' ) return -1 ; int res = value ( exp [ 0 ] ) ; for ( int i = 1 ; exp [ i ] ; i += 2 ) { char opr = exp [ i ] , opd = exp [ i + 1 ] ; if ( ! isOperand ( opd ) ) return -1 ; if ( opr == '+' ) res += value ( opd ) ; else if ( opr == '-' ) res -= value ( opd ) ; else if ( opr == '*' ) res *= value ( opd ) ; else if ( opr == '/' ) res /= value ( opd ) ; else return -1 ; } return res ; }
double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }
void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; cout << f1 << " " ; for ( i = 1 ; i < n ; i ++ ) { cout << f2 << " " ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } }
unsigned int factorial ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; }
long long gcd ( long long int a , long long int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
long long lcm ( int a , int b ) { return ( a / gcd ( a , b ) ) * b ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void rearrange ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] += ( arr [ arr [ i ] ] % n ) * n ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] /= n ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; cout << endl ; }
int maxdiff ( int arr [ ] , int n ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] && arr [ i ] > arr [ j ] ) ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) ; else if ( freq [ arr [ i ] ] < freq [ arr [ j ] ] && arr [ i ] < arr [ j ] ) ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) ; } } return ans ; }
void printSequencesRecur ( int arr [ ] , int n , int k , int index ) { int i ; if ( k == 0 ) { printArray ( arr , index ) ; } if ( k > 0 ) { for ( i = 1 ; i <= n ; ++ i ) { arr [ index ] = i ; printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; } } }
void printSequences ( int n , int k ) { int * arr = new int [ k ] ; printSequencesRecur ( arr , n , k , 0 ) ; return ; }
bool isMultipleof5 ( int n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; }
bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; }
bool isPowerofTwo ( long long n ) { if ( n == 0 ) return 0 ; if ( ( n & ( ~ ( n - 1 ) ) ) == n ) return 1 ; return 0 ; }
int reversDigits ( int num ) { static int rev_num = 0 ; static int base_pos = 1 ; if ( num > 0 ) { reversDigits ( num / 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; }
int countSubsequences ( vector < int > arr ) { int odd = 0 ; int even = 0 ; for ( int x : arr ) { if ( x & 1 ) odd ++ ; else even ++ ; } return ( ( 1 << odd ) - 1 ) * ( 1 << even ) ; }
int findDiff ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int count = 0 , max_count = 0 , min_count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = max ( max_count , count ) ; min_count = min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }
int XorSum ( int A [ ] , int B [ ] , int N , int M ) { int ans = -1 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( ans == -1 ) ans = ( A [ i ] & B [ j ] ) ; else ans ^= ( A [ i ] & B [ j ] ) ; } } return ans ; }
int countbitdiff ( int xo ) { int count = 0 ; while ( xo ) { if ( xo % 2 == 1 ) { count ++ ; } xo = xo / 2 ; } return count ; }
void convertXOR ( int arr [ M ] [ N ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int X = arr [ i ] [ j ] ; int temp = findXOR ( X ) ; arr [ i ] [ j ] = temp ; } } printXORmatrix ( arr ) ; }
int countSet ( int N ) { int ans = 0 ; while ( N ) { ans += N & 1 ; N >>= 1 ; } return ans ; }
int countSub ( int * arr , int k ) { int ans = 0 ; int setK = 0 ; for ( int i = 0 ; i < 5 ; i ++ ) { if ( countSet ( arr [ i ] ) == k ) setK += 1 ; else setK = 0 ; ans += setK ; } return ans ; }
void oddXorSubarray ( int a [ ] , int n ) { int odd = 0 ; int c_odd = 0 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] & 1 ) { odd = ! odd ; } if ( odd ) { c_odd ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { result += c_odd ; if ( a [ i ] & 1 ) { c_odd = ( n - i - c_odd ) ; } } cout << result ; }
void countPairs ( int arr [ ] , int N , int K ) { unordered_map < int , int > mp ; int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { cnt += mp [ K - arr [ i ] ] ; mp [ arr [ i ] ] ++ ; } cout << cnt ; }
void uniqueLevels ( TreeNode * root ) { int uniqueLevels = 0 ; queue < TreeNode * > que ; que . push ( root ) ; while ( que . size ( ) > 0 ) { int length = que . size ( ) ; int prefix_XOR = 0 ; int prefix_OR = 0 ; bool flag = true ; for ( int i = 0 ; i < length ; i ++ ) { TreeNode * temp = que . front ( ) ; que . pop ( ) ; prefix_OR |= temp -> val ; prefix_XOR ^= temp -> val ; if ( prefix_XOR != prefix_OR ) flag = false ; if ( temp -> left ) que . push ( temp -> left ) ; if ( temp -> right ) que . push ( temp -> right ) ; } if ( flag ) uniqueLevels += 1 ; } cout << uniqueLevels ; }
int query ( int l , int r , int pre [ ] ) { if ( l == 0 ) return pre [ r ] ; else return pre [ r ] - pre [ l - 1 ] ; }
void countInRange ( int arr [ ] , int N , vector < pair < int , int > > queries , int Q ) { int pre [ N ] = { 0 } ; pre [ 0 ] = check ( arr [ 0 ] ) ; for ( int i = 1 ; i < N ; i ++ ) { pre [ i ] = pre [ i - 1 ] + check ( arr [ i ] ) ; } int c = 0 ; while ( Q -- ) { int l = queries . first ; int r = queries . second ; c ++ ; cout << query ( l , r , pre ) << ' ' ; } }
void Bitwise_AND_sum_i ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { int frequency [ 32 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int bit_position = 0 ; int num = arr1 [ i ] ; while ( num ) { if ( num & 1 ) { frequency [ bit_position ] += 1 ; } bit_position += 1 ; num >>= 1 ; } } for ( int i = 0 ; i < M ; i ++ ) { int num = arr2 [ i ] ; int value_at_that_bit = 1 ; int bitwise_AND_sum = 0 ; for ( int bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( num & 1 ) { bitwise_AND_sum += frequency [ bit_position ] * value_at_that_bit ; } num >>= 1 ; value_at_that_bit <<= 1 ; } cout << bitwise_AND_sum << ' ' ; } return ; }
void Bitwise_OR_sum_i ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { int frequency [ 32 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int bit_position = 0 ; int num = arr1 [ i ] ; while ( num ) { if ( num & 1 ) { frequency [ bit_position ] += 1 ; } bit_position += 1 ; num >>= 1 ; } } for ( int i = 0 ; i < M ; i ++ ) { int num = arr2 [ i ] ; int value_at_that_bit = 1 ; int bitwise_OR_sum = 0 ; for ( int bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( num & 1 ) { bitwise_OR_sum += N * value_at_that_bit ; } else { bitwise_OR_sum += frequency [ bit_position ] * value_at_that_bit ; } num >>= 1 ; value_at_that_bit <<= 1 ; } cout << bitwise_OR_sum << ' ' ; } return ; }
void constructArray ( int A [ ] , int N , int K ) { int B [ N ] ; int totalXOR = A [ 0 ] ^ K ; for ( int i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { cout << B [ i ] << " " ; } }
void countPairs ( int arr [ ] , int k , int size ) { int count = 0 , x ; for ( int i = 0 ; i < size - 1 ; i ++ ) { for ( int j = i + 1 ; j < size ; j ++ ) { x = arr [ i ] | arr [ j ] ; if ( x == k ) count ++ ; } } cout << count ; }
void dfs ( int node , int xorr , int k ) { visited [ node ] = 1 ; if ( node != 1 && xorr == k ) ans ++ ; for ( auto x : adj [ node ] ) { if ( ! visited [ x . first ] ) { int xorr1 = xorr ^ x . second ; dfs ( x . first , xorr1 , k ) ; } } }
int maxDiff ( int arr [ ] , int n ) { int SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { bool isSingleOccurance = true ; for ( int j = i + 1 ; j <= n - 1 ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { isSingleOccurance = false ; arr [ i ] = arr [ j ] = 0 ; break ; } } if ( isSingleOccurance ) { if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ; else SubsetSum_2 += arr [ i ] ; } } return abs ( SubsetSum_1 - SubsetSum_2 ) ; }
int build_num ( int bit [ ] ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) if ( bit [ i ] ) ans += ( 1 << i ) ; return ans ; }
int maximumOR ( int arr [ ] , int n , int k ) { int bit [ 32 ] = { 0 } ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( arr [ i ] & ( 1 << j ) ) bit [ j ] ++ ; } } int max_or = build_num ( bit ) ; for ( int i = k ; i < n ; i ++ ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( arr [ i - k ] & ( 1 << j ) ) bit [ j ] -- ; } for ( int j = 0 ; j < 32 ; j ++ ) { if ( arr [ i ] & ( 1 << j ) ) bit [ j ] ++ ; } max_or = max ( build_num ( bit ) , max_or ) ; } return max_or ; }
int build_num ( int bit [ ] , int k ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) if ( bit [ i ] == k ) ans += ( 1 << i ) ; return ans ; }
int minimumAND ( int arr [ ] , int n , int k ) { int bit [ 32 ] = { 0 } ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( arr [ i ] & ( 1 << j ) ) bit [ j ] ++ ; } } int min_and = build_num ( bit , k ) ; for ( int i = k ; i < n ; i ++ ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( arr [ i - k ] & ( 1 << j ) ) bit [ j ] -- ; } for ( int j = 0 ; j < 32 ; j ++ ) { if ( arr [ i ] & ( 1 << j ) ) bit [ j ] ++ ; } min_and = min ( build_num ( bit , k ) , min_and ) ; } return min_and ; }
void findMinXORSubarray ( int arr [ ] , int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_xor = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_xor ^= arr [ i ] ; int min_xor = curr_xor ; for ( int i = k ; i < n ; i ++ ) { curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; if ( curr_xor < min_xor ) { min_xor = curr_xor ; res_index = ( i - k + 1 ) ; } } cout << min_xor << "\n" ; }
int findmax ( int arr [ ] , int n , int k ) { int trav , i ; int c = 0 , maximum = 0 ; for ( i = 0 ; i < n - k + 1 ; i ++ ) { trav = i - 1 ; c = 0 ; while ( trav >= 0 && arr [ trav ] == 1 ) { trav -- ; c ++ ; } trav = i + k ; while ( trav < n && arr [ trav ] == 1 ) { trav ++ ; c ++ ; } c += k ; if ( c > maximum ) maximum = c ; } return maximum ; }
int powerOfTwo ( int a [ ] , int n ) { map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ a [ i ] ] ++ ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { bool f = false ; for ( int j = 0 ; j < 31 ; j ++ ) { int s = ( 1 << j ) - a [ i ] ; if ( mp . count ( s ) && ( mp [ s ] > 1 || mp [ s ] == 1 && s != a [ i ] ) ) f = true ; } if ( f == false ) count ++ ; } return count ; }
int maxDiff ( int arr [ ] , int n ) { int result = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += abs ( arr [ n - 1 ] ) ; return result ; }
void findArray ( int n , int a , int b , int c ) { int arr [ n + 1 ] = { } ; for ( int bit = 30 ; bit >= 0 ; bit -- ) { int set = a & ( 1 << bit ) ; if ( set ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] |= set ; } else { if ( b & ( 1 << bit ) ) { arr [ 0 ] |= ( 1 << bit ) ; if ( ! ( c & ( 1 << bit ) ) ) { arr [ 1 ] |= ( 1 << bit ) ; } } } } int aa = INT_MAX , bb = 0 , cc = 0 ; for ( int i = 0 ; i < n ; i ++ ) { aa &= arr [ i ] ; bb |= arr [ i ] ; cc ^= arr [ i ] ; } if ( a == aa && b == bb && c == cc ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; } else cout << "-1" ; }
int countSubarray ( int arr [ ] , int K , int N ) { if ( K % 2 != 0 ) return 0 ; if ( N < K ) return 0 ; int start = 0 ; int i = 0 ; int count = 0 ; int currXor = arr [ i ++ ] ; while ( i < K ) { currXor ^= arr [ i ] ; i ++ ; } if ( currXor == 0 ) count ++ ; currXor ^= arr [ start ++ ] ; while ( i < N ) { currXor ^= arr [ i ] ; i ++ ; if ( currXor == 0 ) count ++ ; currXor ^= arr [ start ++ ] ; } return count ; }
int findLargestNumber ( vector < int > & arr ) { int k = * max_element ( arr . begin ( ) , arr . end ( ) ) ; int m [ k ] = { } ; for ( auto n : arr ) ++ m [ n ] ; for ( auto n = arr . size ( ) ; n > 0 ; -- n ) { if ( n == m [ n ] ) return n ; } return -1 ; }
int maxDiff ( int arr [ ] , int n ) { unordered_map < int , int > hashPositive ; unordered_map < int , int > hashNegative ; int SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) if ( arr [ i ] > 0 ) hashPositive [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= n - 1 ; i ++ ) if ( arr [ i ] > 0 && hashPositive [ arr [ i ] ] == 1 ) SubsetSum_1 += arr [ i ] ; for ( int i = 0 ; i <= n - 1 ; i ++ ) if ( arr [ i ] < 0 ) hashNegative [ abs ( arr [ i ] ) ] ++ ; for ( int i = 0 ; i <= n - 1 ; i ++ ) if ( arr [ i ] < 0 && hashNegative [ abs ( arr [ i ] ) ] == 1 ) SubsetSum_2 += arr [ i ] ; return abs ( SubsetSum_1 - SubsetSum_2 ) ; }
int NoCarrySum ( int N , int M ) { return N ^ M ; }
bool CheckBits ( int N , int K ) { int check = 0 ; int count = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( ( 1 << i ) & N ) { if ( check == 0 ) { check = 1 ; } else { if ( count < K ) { return false ; } } count = 0 ; } else { count ++ ; } } return true ; }
int RecursiveFunction ( vector < int > ref , int bit ) { if ( ref . size ( ) == 0 bit < 0 ) return 0 ; vector < int > curr_on , curr_off ; for ( int i = 0 ; i < ref . size ( ) ; i ++ ) { if ( ( ( ref [ i ] >> bit ) & 1 ) == 0 ) curr_off . push_back ( ref [ i ] ) ; else curr_on . push_back ( ref [ i ] ) ; } if ( curr_off . size ( ) == 0 ) return RecursiveFunction ( curr_on , bit - 1 ) ; if ( curr_on . size ( ) == 0 ) return RecursiveFunction ( curr_off , bit - 1 ) ; return min ( RecursiveFunction ( curr_off , bit - 1 ) , RecursiveFunction ( curr_on , bit - 1 ) ) + ( 1 << bit ) ; }
int minimumFlips ( int X , int Y , int Z ) { int res = 0 ; while ( X > 0 Y > 0 Z > 0 ) { if ( ( ( X & 1 ) || ( Y & 1 ) ) && ( Z & 1 ) ) { X = X >> 1 ; Y = Y >> 1 ; Z = Z >> 1 ; continue ; } else if ( ! ( X & 1 ) && ! ( Y & 1 ) && ( Z & 1 ) ) { res ++ ; } else if ( ( X & 1 ) || ( Y & 1 ) == 1 ) { if ( ( X & 1 ) && ( Y & 1 ) && ! ( Z & 1 ) ) { res += 2 ; } else if ( ( ( X & 1 ) || ( Y & 1 ) ) && ! ( Z & 1 ) ) { res ++ ; } } X = X >> 1 ; Y = Y >> 1 ; Z = Z >> 1 ; } return res ; }
int FlipBits ( unsigned int n ) { return n -= ( n & ( - n ) ) ; }
int calculate ( vector < int > & section , int pos ) { if ( pos < 0 ) return 0 ; vector < int > on_section , off_section ; for ( auto el : section ) { if ( ( ( el >> pos ) & 1 ) == 0 ) off_section . push_back ( el ) ; else on_section . push_back ( el ) ; } if ( off_section . size ( ) == 0 ) return calculate ( on_section , pos - 1 ) ; if ( on_section . size ( ) == 0 ) return calculate ( off_section , pos - 1 ) ; return min ( calculate ( off_section , pos - 1 ) , calculate ( on_section , pos - 1 ) ) + ( 1 << pos ) ; }
int minXorValue ( int a [ ] , int n ) { vector < int > section ; for ( int i = 0 ; i < n ; i ++ ) section . push_back ( a [ i ] ) ; return calculate ( section , 30 ) ; }
void SieveOfEratosthenes ( vector < bool > & prime ) { prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } }
void prime_xor ( int arr [ ] , int n , int k ) { vector < bool > prime ( MAX , true ) ; SieveOfEratosthenes ( prime ) ; long long int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { if ( ( i + 1 ) % k == 0 ) { ans ^= arr [ i ] ; } } } cout << ans << endl ; }
int xorOfArray ( int arr [ ] , int n ) { int xor_arr = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xor_arr = xor_arr ^ arr [ i ] ; } return xor_arr ; }
void countEvenBit ( int A [ ] , int B [ ] , int n , int m ) { int i , j , cntOdd = 0 , cntEven = 0 ; for ( i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( A [ i ] ) ; if ( x & 1 ) { cntEven ++ ; } else { cntOdd ++ ; } } int CountB [ m ] ; for ( i = 0 ; i < m ; i ++ ) { int x = __builtin_popcount ( B [ i ] ) ; if ( x & 1 ) { CountB [ i ] = cntEven ; } else { CountB [ i ] = cntOdd ; } } for ( i = 0 ; i < m ; i ++ ) { cout << CountB [ i ] << ' ' ; } }
bool isEven ( int n ) { if ( n ^ 1 == n + 1 ) return true ; else return false ; }
int bitwiseOrTillN ( int n ) { int result = 2 ; for ( int i = 4 ; i <= n ; i = i + 2 ) { result = result | i ; } return result ; }
void minRange ( int arr [ ] , int n , int k ) { int l = 0 , r = n ; int j = -1 ; map < int , int > hm ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n ) { j ++ ; if ( hm . size ( ) < k ) hm [ arr [ j ] ] ++ ; if ( hm . size ( ) == k && ( ( r - l ) >= ( j - i ) ) ) { l = i ; r = j ; break ; } } if ( hm . size ( ) < k ) break ; while ( hm . size ( ) == k ) { if ( hm [ arr [ i ] ] == 1 ) hm . erase ( arr [ i ] ) ; else hm [ arr [ i ] ] -- ; i ++ ; if ( hm . size ( ) == k && ( r - l ) >= ( j - i ) ) { l = i ; r = j ; } } if ( hm [ arr [ i ] ] == 1 ) hm . erase ( arr [ i ] ) ; else hm [ arr [ i ] ] -- ; } if ( l == 0 && r == n ) cout << "Invalid k" << endl ; else cout << l << " " << r << endl ; }
int bitwiseOrTillN ( int n ) { if ( n < 2 ) return 0 ; int bitCount = log2 ( n ) + 1 ; return pow ( 2 , bitCount ) - 2 ; }
int bitwiseAndOdd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; }
int bitwiseAndOdd ( int n ) { return 1 ; }
void construct_Xor_Tree_Util ( vector < int > current , int start , int end , int x ) { if ( start == end ) { xor_tree [ x ] = current [ start ] ; return ; } int left = x * 2 + 1 ; int right = x * 2 + 2 ; int mid = start + ( end - start ) / 2 ; construct_Xor_Tree_Util ( current , start , mid , left ) ; construct_Xor_Tree_Util ( current , mid + 1 , end , right ) ; xor_tree [ x ] = ( xor_tree [ left ] ^ xor_tree [ right ] ) ; }
void genSequence ( int n , int val ) { for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int x = i ^ ( i >> 1 ) ^ val ; cout << x << " " ; } }
bool check ( int arr [ ] , int n , int m , int d ) { int i = 0 ; while ( i < n && m > 0 ) { m -- ; i += d ; } return m == 0 ? true : false ; }
int maximumDistance ( int arr [ ] , int n , int m ) { int low = 1 , high = n - 1 ; int ans = 0 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; bool flag = check ( arr , n , m , mid ) ; if ( flag ) { ans = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return ans ; }
int minTrees ( int n ) { int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
void longest ( int a [ ] , int n , int k ) { unordered_map < int , int > freq ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) end = i , start = l ; } for ( int i = start ; i <= end ; i ++ ) cout << a [ i ] << " " ; }
int extraElement ( int A [ ] , int B [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; }
int maxConsecutiveOnes ( int x ) { int count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; }
int maxOnes ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int currMax = maxConsecutiveOnes ( arr [ i ] ) ; ans = max ( ans , currMax ) ; } return ans ; }
int maxOR ( int L , int R ) { if ( L == R ) { return L ; } int ans = 0 ; for ( int i = MAX - 1 ; i >= 0 ; i -- ) { int p , lbit , rbit ; p = 1 << i ; if ( ( rbit == 1 ) && ( lbit == 0 ) ) { ans += ( p << 1 ) - 1 ; break ; } if ( rbit == 1 ) { ans += p ; } } return ans ; }
int findLen ( int * arr , int n , int m ) { vector < int > filter ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & m ) == m ) filter . push_back ( arr [ i ] ) ; if ( filter . size ( ) == 0 ) return 0 ; int c_and = filter [ 0 ] ; for ( int i = 1 ; i < filter . size ( ) ; i ++ ) c_and &= filter [ i ] ; if ( c_and == m ) return filter . size ( ) ; return 0 ; }
int toggleBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
int clearBit ( int n , int k ) { return ( n & ( ~ ( 1 << ( k - 1 ) ) ) ) ; }
int getMinSteps ( int K ) { return __builtin_popcount ( k ) ; }
int sum ( int a [ ] , int n ) { unordered_map < int , int > cnt ; int ans = 0 , pre_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( i * a [ i ] ) - pre_sum ; pre_sum += a [ i ] ; if ( cnt [ a [ i ] - 1 ] ) ans -= cnt [ a [ i ] - 1 ] ; if ( cnt [ a [ i ] + 1 ] ) ans += cnt [ a [ i ] + 1 ] ; cnt [ a [ i ] ] ++ ; } return ans ; }
int cntElements ( int arr [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; }
int xor_triplet ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j ; k < n ; k ++ ) { int xor1 = 0 , xor2 = 0 ; for ( int x = i ; x < j ; x ++ ) { xor1 ^= arr [ x ] ; } for ( int x = j ; x <= k ; x ++ ) { xor2 ^= arr [ x ] ; } if ( xor1 == xor2 ) { ans ++ ; } } } } return ans ; }
int findSubarray ( int array [ ] , int n ) { unordered_map < int , int > mp ; mp . insert ( { 0 , 1 } ) ; int answer = 0 ; int preXor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int value = 1 ; preXor ^= array [ i ] ; for ( int j = 1 ; j <= MAX ; j ++ ) { int Y = value ^ preXor ; if ( mp . find ( Y ) != mp . end ( ) ) { answer += mp [ Y ] ; } value *= 2 ; } if ( mp . find ( preXor ) != mp . end ( ) ) { mp [ preXor ] ++ ; } else { mp . insert ( { preXor , 1 } ) ; } } return answer ; }
int max_xor ( int arr [ ] , int n ) { int maxXor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { maxXor = max ( maxXor , arr [ i ] ^ arr [ j ] ) ; } } return maxXor ; }
int CountTriplets ( int * arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int first = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { first ^= arr [ j ] ; if ( first == 0 ) ans += ( j - i ) ; } } return ans ; }
void findMajority ( int arr [ ] , int n ) { int len = sizeof ( int ) * 8 ; int number = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & ( 1 << i ) ) count ++ ; } if ( count > ( n / 2 ) ) number += ( 1 << i ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == number ) count ++ ; if ( count > ( n / 2 ) ) cout << number ; else cout << "Majority Element Not Present" ; }
int countBits ( int a , int b ) { int count = 0 ; while ( a b ) { int last_bit_a = a & 1 ; int last_bit_b = b & 1  ; if ( last_bit_a != last_bit_b ) count ++ ; a = a >> 1 ; b = b >> 1 ; }
int CountSetBits ( int n ) { if ( n == 0 ) return 0 ; if ( ( n & 1 ) == 1 ) return 1 + CountSetBits ( n >> 1 ) ; else return CountSetBits ( n >> 1 ) ; }
ull calculate ( int bit_cnt ) { ull res = 1 ; while ( bit_cnt -- ) { res = res * 3 ; } return res ; }
int unset_bit_count ( ull n ) { int count = 0 ; while ( n ) { if ( ( n & 1 ) == 0 ) count ++ ; n = n >> 1 ; } return count ; }
long long bit_q ( int i , int j ) { long long sum = 0ll ; while ( j > 0 ) { sum += bit [ j ] ; j -= ( j & ( j * -1 ) ) ; } i -- ; while ( i > 0 ) { sum -= bit [ i ] ; i -= ( i & ( i * -1 ) ) ; } return sum ; }
void bit_up ( int i , long long diff ) { while ( i <= n ) { bit [ i ] += diff ; i += i & - i ; } }
void initialise ( ) { Ideal_pair = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { root_node [ i ] = true ; bit [ i ] = 0LL ; } }
long long Idealpairs ( ) { int r = -1 ; for ( int i = 1 ; i <= n ; i ++ ) if ( root_node [ i ] ) { r = i ; break ; } dfs ( r ) ; return Ideal_pair ; }
int pairORSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; }
int solve ( int A [ ] , int B [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( __builtin_popcount ( A [ i ] & A [ j ] ) == B [ j ] ) { cnt ++ ; } return cnt ; }
long multiplyByFifteen ( long n ) { long prod = ( n << 3 ) ; prod += ( n << 2 ) ; prod += ( n << 1 ) ; prod += n ; return prod ; }
void balTernary ( int ter ) { int carry = 0 , base = 10 ; int i = 32 ; while ( ter > 0 ) { int rem = ter % base ; rem = rem + carry ; if ( rem == 0 ) { arr [ i -- ] = 0 ; carry = 0 ; } else if ( rem == 1 ) { arr [ i -- ] = 1 ; carry = 0 ; } else if ( rem == 2 ) { arr [ i -- ] = -1 ; carry = 1 ; } else if ( rem == 3 ) { arr [ i -- ] = 0 ; carry = 1 ; } ter = ter / base ; } if ( carry == 1 ) arr [ i ] = 1 ; }
bool isDefeat ( string s1 , string s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( s1 [ i ] == '0' && s2 [ i ] == '1' ) || ( s1 [ i ] == '1' && s2 [ i ] == '0' ) ) continue ; else if ( ( s1 [ i ] == '0' && s2 [ i ] == 'Z' ) || ( s1 [ i ] == 'Z' && s2 [ i ] == '0' ) ) continue ; else { return true ; } } return false ; }
bool check ( int a [ N ] [ M ] , int b [ N ] [ M ] ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( a [ i ] [ j ] != b [ i ] [ j ] ) { a [ i ] [ j ] ^= 1 ; a [ 0 ] [ 0 ] ^= 1 ; a [ 0 ] [ j ] ^= 1 ; a [ i ] [ 0 ] ^= 1 ; } } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( a [ i ] [ j ] != b [ i ] [ j ] ) return false ; } } return true ; }
int FindIndexKthBit ( int n , int k ) { int cnt = 0 ; int ind = 0 ; while ( n ) { if ( n & 1 ) cnt ++ ; if ( cnt == k ) return ind ; ind ++ ; n = n >> 1 ; } return -1 ; }
bool check ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] ) return true ; return false ; }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
void findArray ( int q [ ] , int n ) { int arr [ n ] , ans ; for ( int k = 0 , j = 0 ; j < n / 4 ; j ++ ) { ans = q [ k ] ^ q [ k + 3 ] ; arr [ k + 1 ] = q [ k + 1 ] ^ ans ; arr [ k + 2 ] = q [ k + 2 ] ^ ans ; arr [ k ] = q [ k ] ^ ( ( arr [ k + 1 ] ) ^ ( arr [ k + 2 ] ) ) ; arr [ k + 3 ] = q [ k + 3 ] ^ ( arr [ k + 1 ] ^ arr [ k + 2 ] ) ; k += 4 ; } printArray ( arr , n ) ; }
int countX ( int n ) { string binary = bitset < 8 > ( n ) . to_string ( ) ; int count = 0 ; for ( int i = 0 ; i < binary . length ( ) ; i ++ ) { if ( binary . at ( i ) == '1' ) count ++ ; } int answer = ( int ) pow ( 2 , count ) ; return answer ; }
void binToDecimal3 ( int n ) { int a [ 64 ] = { 0 } ; int x = 0 , i ; for ( i = 0 ; n > 0 ; i ++ ) { a [ i ] = n % 2 ; n /= 2 ; } x = ( i < 3 ) ? 3 : i ; int d = 0 , p = 0 ; for ( int i = x - 3 ; i < x ; i ++ ) d += a [ i ] * pow ( 2 , p ++ ) ; cout << d << " " ; d = 0 ; p = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) d += a [ i ] * pow ( 2 , p ++ ) ; cout << d ; }
void binToDecimal3 ( int n ) { int last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; n = n >> 3 ; while ( n > 7 ) n = n >> 1 ; int first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; cout << first_3 << " " << last_3 ; }
int nextPowerOf2 ( int n ) { int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
int memoryUsed ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int nearest = nextPowerOf2 ( sum ) ; return nearest ; }
bool isPowerOfTwo ( int x ) { if ( x == 0 ) return false ; if ( ! ( x & ( x - 1 ) ) ) return true ; else return false ; }
int countNum ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerOfTwo ( a [ i ] ) || isPowerOfTwo ( a [ i ] + 1 ) ) count ++ ; } return count ; }
bool checkEvenParity ( int x ) { int parity = 0 ; while ( x != 0 ) { x = x & ( x - 1 ) ; parity ++ ; } if ( parity % 2 == 0 ) return true ; else return false ; }
long sumlist ( int a [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkEvenParity ( a [ i ] ) ) sum += a [ i ] ; } return sum ; }
int minDistance ( int n1 , int n2 ) { int bitCount1 = floor ( log2 ( n1 ) ) + 1 ; int bitCount2 = floor ( log2 ( n2 ) ) + 1 ; int bitDiff = abs ( bitCount1 - bitCount2 ) ; int maxBitCount = max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * pow ( 2 , bitDiff ) ; } else { n1 = n1 * pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue ; if ( xorValue == 0 ) bitCountXorValue = 1 ; else { bitCountXorValue = floor ( log2 ( xorValue ) ) + 1 ; } int disSimilarBitPosition = maxBitCount - bitCountXorValue ; int result = bitCount1 + bitCount2 - 2 * disSimilarBitPosition ; return result ; }
int findOddPair ( int A [ ] , int N ) { int oddPair = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; }
int countOddPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ! ( A [ i ] & 1 ) ) count ++ ; int evenPairCount = count * ( count - 1 ) / 2 ; int totPairs = N * ( N - 1 ) / 2 ; return totPairs - evenPairCount ; }
int findevenPair ( int A [ ] , int N ) { int i , j ; int evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] ^ A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; }
int findEvenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 != 0 ) count ++ ; } int totalPairs = ( N * ( N - 1 ) / 2 ) ; int oddEvenPairs = count * ( N - count ) ; return totalPairs - oddEvenPairs ; }
int findevenPair ( int A [ ] , int N ) { int i , j ; int evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; }
int calculate ( int X ) { int number_of_bits = 8 ; return ( ( 1 << number_of_bits ) - 1 ) ^ X ; }
void alternate ( int & a , int & b , int & x ) { x = a ^ b ^ x ; }
int countZeros ( unsigned int x ) { int total_bits = sizeof ( x ) * 8 ; int res = 0 ; while ( ! ( x & ( 1 << ( total_bits - 1 ) ) ) ) { x = ( x << 1 ) ; res ++ ; } return res ; }
int countZeros ( int x ) { unsigned y ; int n = 32 ; y = x >> 16 ; if ( y != 0 ) { n = n - 16 ; x = y ; } y = x >> 8 ; if ( y != 0 ) { n = n - 8 ; x = y ; } y = x >> 4 ; if ( y != 0 ) { n = n - 4 ; x = y ; } y = x >> 2 ; if ( y != 0 ) { n = n - 2 ; x = y ; } y = x >> 1 ; if ( y != 0 ) return n - 2 ; return n - x ; }
void LeadingZeros ( int x , int y ) { if ( ( x ^ y ) <= ( x & y ) ) cout << "Equal"  else if ( ( x & ( ~ y ) ) > y )  cout << y ; else cout < < x ; }
void subset ( int nthBit , int num , int numOfBits ) { if ( nthBit >= 0 ) { if ( num & ( 1 << nthBit ) ) { cout << numOfBits - nthBit << " " ; } subset ( nthBit - 1 , num , numOfBits ) ; } else return ; }
void solve ( int A , int B ) { int count = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } cout << "Number of different bits : " << count << endl ; }
int countSubarrWithEqualZeroAndOne ( int arr [ ] , int n ) { unordered_map < int , int > um ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += ( arr [ i ] == 0 ) ? -1 : arr [ i ] ; um [ curr_sum ] ++ ; } int count = 0 ; for ( auto itr = um . begin ( ) ; itr != um . end ( ) ; itr ++ ) { if ( itr -> second > 1 ) count += ( ( itr -> second * ( itr -> second - 1 ) ) / 2 ) ; } if ( um . find ( 0 ) != um . end ( ) ) count += um [ 0 ] ; return count ; }
int setRightmostUnsetBit ( int n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; return n | ( n + 1 ) ; }
int OR ( int a [ ] , int n ) { int ans = a [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) ans |= a [ i ] ; return ans ; }
int hammingDistance ( int n1 , int n2 ) { int x = n1 ^ n2 ; int setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; }
bool isKthBitSet ( unsigned int n , unsigned int k ) { if ( ( n >> ( k - 1 ) ) & 1 ) return true ; return false ; }
unsigned int setKthBit ( unsigned int n , unsigned int k ) { return ( ( 1 << ( k - 1 ) ) n ) ; }
bool allBitsAreSet ( unsigned int n ) { if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; }
bool bitsAreInAltOrder ( unsigned int n ) { unsigned int num = n ^ ( n >> 1 ) ; return allBitsAreSet ( num ) ; }
bool bitsAreInAltPatrnInGivenRange ( unsigned int n , unsigned int l , unsigned int r ) { unsigned int num , left_shift ; if ( isKthBitSet ( n , r ) ) { num = n ; left_shift = r ; } else { num = setKthBit ( n , ( r + 1 ) ) ; left_shift = r + 1 ; } num = num & ( ( 1 << left_shift ) - 1 ) ; num = num >> ( l - 1 ) ; return bitsAreInAltOrder ( num ) ; }
bool findParity ( int x ) { int y = x ^ ( x >> 1 ) ; y = y ^ ( y >> 2 ) ; y = y ^ ( y >> 4 ) ; y = y ^ ( y >> 8 ) ; y = y ^ ( y >> 16 ) ; if ( y & 1 ) return 1 ; return 0 ; }
int bit ( int n ) { int count = 0 ; while ( n ) { count ++ ; n = n & ( n - 1 ) ; } return count ; }
int maxSumOfBits ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = bit ( arr [ i ] ) ; } int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; }
int increment ( unsigned int i ) { i = - ( ~ i ) ; return i ; }
char increment ( unsigned char i ) { i = - ( ~ i ) ; return i ; }
void MakePreSum ( int arr [ ] , int presum [ ] , int n ) { presum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) presum [ i ] = presum [ i - 1 ] + arr [ i ] ; }
int lenOfLongSubarr ( int arr [ ] , int n ) { unordered_map < int , int > um ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? -1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( um . find ( sum ) == um . end ( ) ) um [ sum ] = i ; if ( um . find ( sum - 1 ) != um . end ( ) ) { if ( maxLen < ( i - um [ sum - 1 ] ) ) maxLen = i - um [ sum - 1 ] ; } } return maxLen ; }
int bit_count ( int n ) { int count = 0 ; while ( n ) { count ++ ; n = n & ( n - 1 ) ; } return count ; }
int maxsum ( int arr [ ] , int n ) { int bits [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { bits [ i ] = bit_count ( arr [ i ] ) ; } int sum [ 32 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { sum [ bits [ i ] ] += arr [ i ] ; } int maximum = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { maximum = max ( sum [ i ] , maximum ) ; } return maximum ; }
int findOddPair ( int A [ ] , int N ) { int i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; }
bool allBitsSetInTheGivenRange ( unsigned int n , unsigned int l , unsigned int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( num == new_num ) return true ; return false ; }
bool bitsAreComplement ( unsigned int a , unsigned int b , unsigned int l , unsigned int r ) { unsigned int xor_value = a ^ b ; return allBitsSetInTheGivenRange ( xor_value , l , r ) ; }
bool allBitsSetInTheGivenRange ( unsigned int n , unsigned int l , unsigned int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return true ; return false ; }
bool checkSame ( int n ) { int set = 0 , unset = 0 ; while ( n ) { if ( n & 1 ) set ++ ; else unset ++ ; n = n >> 1 ; } if ( set == unset ) return true ; else return false ; }
bool isBalanced ( string s ) { stack < char > st ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '(' ) st . push ( s [ i ] ) ; else { if ( st . empty ( ) ) { return false ; } else st . pop ( ) ; } } if ( ! st . empty ( ) ) return false ; return true ; }
bool isBalancedSeq ( string s1 , string s2 ) { if ( isBalanced ( s1 + s2 ) ) return true ; return isBalanced ( s2 + s1 ) ; }
void KthCharacter ( int m , int n , int k ) { int distance = pow ( 2 , n ) ; int Block_number = k / distance ; int remaining = k % distance ; int s [ 32 ] , x = 0 ; for ( ; m > 0 ; x ++ ) { s [ x ] = m % 2 ; m = m / 2 ; } int root = s [ x - 1 - Block_number ] ; if ( remaining == 0 ) { cout << root << endl ; return ; } bool flip = true ; while ( remaining > 1 ) { if ( remaining & 1 ) { flip = ! flip ; } remaining = remaining >> 1 ; } if ( flip ) { cout << ! root << endl ; } else { cout << root << endl ; } }
int MSBPosition ( long long int N ) { int msb_p = -1 ; while ( N ) { N = N >> 1 ; msb_p ++ ; } return msb_p ; }
long long int findBitwiseOR ( long long int L , long long int R ) { long long int res = 0 ; int msb_p1 = MSBPosition ( L ) ; int msb_p2 = MSBPosition ( R ) ; while ( msb_p1 == msb_p2 ) { long long int res_val = ( 1 << msb_p1 ) ; res += res_val ; L -= res_val ; R -= res_val ; msb_p1 = MSBPosition ( L ) ; msb_p2 = MSBPosition ( R ) ; } msb_p1 = max ( msb_p1 , msb_p2 ) ; for ( int i = msb_p1 ; i >= 0 ; i -- ) { long long int res_val = ( 1 << i ) ; res += res_val ; } return res ; }
int getInteger ( int L , int R ) { int number = 0 ; for ( int i = L ; i <= R ; i ++ ) number += pow ( 2 , i ) ; return number ; }
int maxOR ( long long arr [ ] , int n , int k , int x ) { long long preSum [ n + 1 ] , suffSum [ n + 1 ] ; long long res , pow = 1 ; for ( int i = 0 ; i < k ; i ++ ) pow *= x ; preSum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) preSum [ i + 1 ] = preSum [ i ] | arr [ i ] ; suffSum [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] ; res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) ; return res ; }
int findXor ( int arr [ ] , int n ) { int xoR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xoR = xoR ^ arr [ i ] ; } return xoR * 2 ; }
int turnOnK ( int n , int k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; }
void setBitwiseORk ( int n ) { vector < int > v ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( i n ) == n ) v . push_back ( i ) ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << ' ' ; }
int smallerNumsWithSameSetBits ( int n ) { int temp = __builtin_popcount ( n ) ; int count = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( temp == __builtin_popcount ( i ) ) count ++ ; } return count ; }
int findEletobeInserted ( int A [ ] , int n , int k ) { int ans = k ; for ( int i = 0 ; i < n ; i ++ ) return ans ; }
int andSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < BITS ; i ++ ) { int countSetBits = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & ( 1 << i ) ) countSetBits ++ ; } int subset = ( 1 << countSetBits ) - 1 ; subset = ( subset * ( 1 << i ) ) ; ans += subset ; } return ans ; }
int Root ( int idx ) { int i = idx ; while ( i != id [ i ] ) id [ i ] = id [ id [ i ] ] , i = id [ i ] ; return i ; }
void Union ( int a , int b ) { int i = Root ( a ) , j = Root ( b ) ; if ( i != j ) { if ( sz [ i ] >= sz [ j ] ) { id [ j ] = i , sz [ i ] += sz [ j ] ; sz [ j ] = 0 ; } else { id [ i ] = j , sz [ j ] += sz [ i ] ; sz [ i ] = 0 ; } } }
void UnionUtil ( struct Edge e [ ] , int W [ ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) { int u , v ; u = e [ i ] . u , v = e [ i ] . v ; u -- , v -- ; if ( W [ u ] % 2 == 0 && W [ v ] % 2 == 0 ) Union ( u , v ) ; } }
int findMax ( int n , int W [ ] ) { int maxi = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( W [ i ] % 2 == 0 ) maxi = max ( maxi , sz [ i ] ) ; return maxi ; }
unsigned int countSetBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }
int multiplyWith4 ( int n ) { return ( n << 2 ) ; }
bool isEven ( int n ) { bool isEven = true ; for ( int i = 1 ; i <= n ; i ++ ) isEven = ! isEven ; return isEven ; }
bool isEven ( int n ) { return ( ( n / 2 ) * 2 == n ) ; }
bool checkValidPair ( int num1 , int num2 ) { string s1 = to_string ( num1 ) ; string s2 = to_string ( num2 ) ; for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) for ( int j = 0 ; j < s2 . size ( ) ; j ++ ) if ( s1 [ i ] == s2 [ j ] ) return true ; return false ; }
int countPairs ( int arr [ ] , int n ) { int numberOfPairs = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( checkValidPair ( arr [ i ] , arr [ j ] ) ) numberOfPairs ++ ; return numberOfPairs ; }
int countSetBits ( int n ) { unsigned int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }
bool isPowerOf2 ( int num ) { return ( num && ! ( num & ( num - 1 ) ) ) ; }
bool checkSubsequence ( int arr [ ] , int n ) { if ( n == 1 ) return isPowerOf2 ( arr [ 0 ] ) ; int total = 0 ; for ( int i = 0 ; i < NUM_BITS ; i ++ ) total = total | ( 1 << i ) ; for ( int i = 0 ; i < NUM_BITS ; i ++ ) { int ans = total ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & ( 1 << i ) ) ans = ans & arr [ j ] ; } if ( isPowerOf2 ( ans ) ) return true ; } return false ; }
int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; }
void constructSTUtil ( int arr [ ] , int ss , int se , int * st , int si , int operation ) { if ( ss == se ) { st [ si ] = arr [ ss ] ; return ; } int mid = getMid ( ss , se ) ; constructSTUtil ( arr , ss , mid , st , si * 2 + 1 , ! operation ) ; constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 , ! operation ) ; if ( operation == 1 ) { st [ si ] = ( st [ 2 * si + 1 ] st [ 2 * si + 2 ] ) ; } else { st [ si ] = ( st [ 2 * si + 1 ] ^ st [ 2 * si + 2 ] ) ; } }
void constructTree ( int low , int high , int pos , int a [ ] ) { if ( low == high ) { level [ pos ] = 0 ; tree [ pos ] = a [ high ] ; return ; } int mid = ( low + high ) / 2 ; constructTree ( low , mid , 2 * pos + 1 , a ) ; constructTree ( mid + 1 , high , 2 * pos + 2 , a ) ; level [ pos ] = level [ 2 * pos + 1 ] + 1 ; if ( level [ pos ] & 1 ) tree [ pos ] = tree [ 2 * pos + 1 ] | tree [ 2 * pos + 2 ] ; else tree [ pos ] = tree [ 2 * pos + 1 ] ^ tree [ 2 * pos + 2 ] ; }
void update ( int low , int high , int pos , int index , int a [ ] ) { if ( low == high and low == index ) { tree [ pos ] = a [ low ] ; return ; } if ( index < low index > high ) return ; if ( low != high )  { int mid = ( low + high ) / 2 ; update ( low , mid , 2 * pos + 1 , index , a ) ; update ( mid + 1 , high , 2 * pos + 2 , index , a ) ; if ( level [ pos ] & 1 ) tree [ pos ] = tree [ 2 * pos + 1 ] | tree [ 2 * pos + 2 ] ; else tree [ pos ] = tree [ 2 * pos + 1 ] ^ tree [ 2 * pos + 2 ] ; } }
void updateValue ( int index , int value , int a [ ] , int n ) { a [ index ] = value ; update ( 0 , n - 1 , 0 , index , a ) ; }
int maxXOR ( int n , int k ) { int c = log2 ( n ) + 1 ; return ( ( 1 << c ) - 1 ) ; }
int divide ( long long dividend , long long divisor ) { int sign = ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? -1 : 1 ; dividend = abs ( dividend ) ; divisor = abs ( divisor ) ; long long quotient = 0 , temp = 0 ; for ( int i = 31 ; i >= 0 ; -- i ) { if ( temp + ( divisor << i ) <= dividend ) { temp += divisor << i ; quotient |= 1LL << i ; } } if ( sign == -1 ) quotient = - quotient ; return quotient ; }
int count ( int n ) { int c = 0 ; while ( n ) { c ++ ; n = n >> 1 ; } return c ; }
unsigned int swapBitsInPair ( unsigned int x ) { return ( ( x & 0b10101010 ) >> 1 ) | ( ( x & 0b01010101 ) << 1 ) ; }
int evenbitsetnumber ( int n ) { int count = 0 , res = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
int getmsb ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( n + 1 ) >> 1 ; }
int getevenbits ( int n ) { n = getmsb ( n ) ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; if ( n & 1 ) n = n >> 1 ; return n ; }
int setallevenbits ( int n ) { return n | getevenbits ( n ) ; }
int getmsb ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( n + 1 ) >> 1 ; }
int getevenbits ( int n ) { n = getmsb ( n ) ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; if ( ( n & 1 ) == 0 ) n = n >> 1 ; return n ; }
int setalloddbits ( int n ) { return n | getevenbits ( n ) ; }
int setevenbits ( int n ) { int temp = n ; int count = 0 ; int res = 0 ; for ( temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n & res ) ; }
int setoddbits ( int m ) { int count = 0 ; int res = 0 ; for ( int temp = m ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( m & res ) ; }
int getAlternateBits ( int n , int m ) { int tempn = setevenbits ( n ) ; int tempm = setoddbits ( m ) ; return ( tempn tempm ) ; }
int takeLandFsetbits ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( ( n + 1 ) >> 1 ) + 1 ; }
int toggleFandLbits ( int n ) { if ( n == 1 ) return 0 ; return n ^ takeLandFsetbits ( n ) ; }
int countSetBits ( int n ) { unsigned int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
int checkOdious ( int n ) { return ( countSetBits ( n ) % 2 == 1 ) ; }
int setleftmostunsetbit ( int n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; int pos = 0 ; for ( int temp = n , count = 0 ; temp > 0 ; temp >>= 1 , count ++ ) if ( ( temp & 1 ) == 0 ) pos = count ; return ( n | ( 1 << ( pos ) ) ) ; }
int getPosOfRightmostSetBit ( int n ) { return log2 ( n & - n ) ; }
unsigned int toggleLastKBits ( unsigned int n , unsigned int k ) { unsigned int num = ( 1 << k ) - 1 ; return ( n ^ num ) ; }
unsigned int incrementByOne ( unsigned int n ) { int k = getPosOfRightmostSetBit ( ~ n ) ; n = ( ( 1 << k ) n ) ; if ( k != 0 ) n = toggleLastKBits ( n , k ) ; return n ; }
void printNumHavingAltBitPatrn ( int n ) { int curr_num = 1 ; cout << curr_num << " " ; while ( 1 ) { curr_num <<= 1 ; if ( n < curr_num ) break ; cout << curr_num << " " ; curr_num = ( ( curr_num ) << 1 ) ^ 1 ; if ( n < curr_num ) break ; cout << curr_num << " " ; } }
int xnor ( int a , int b ) { if ( a < b ) swap ( a , b ) ; if ( a == 0 && b == 0 ) return 1 ; int a_rem = 0 ; int b_rem = 0 ; int count = 0 ; int xnornum = 0 ; while ( a ) { a_rem = a & 1 ; b_rem = b & 1 ; if ( a_rem == b_rem ) xnornum |= ( 1 << count ) ; count ++ ; a = a >> 1 ; b = b >> 1 ; } return xnornum ; }
int togglebit ( int n ) { if ( n == 0 ) return 1 ; int i = n ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return i ^ n ; }
void MaximumSum ( int a [ ] , int b [ ] , int n ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 |= a [ i ] ; sum2 |= b [ i ] ; } cout << sum1 + sum2 << endl ; }
unsigned int posOfCarryBit ( ull a , ull b ) { return posOfRightmostSetBit ( a & b ) ; }
bool isPowerOfTwo ( unsigned int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; }
bool differAtOneBitPos ( unsigned int a , unsigned int b ) { return isPowerOfTwo ( a ^ b ) ; }
ll power2 ( ll n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 2 ; return power2 ( n / 2 ) * power2 ( n / 2 ) ; }
ll multiply ( ll x , ll n ) { return x * power2 ( n ) ; }
ll multiply ( ll x , ll n ) { return x << n ; }
bool isDivBy2PowerM ( unsigned int n , unsigned int m ) { if ( ( n & ( ( 1 << m ) - 1 ) ) == 0 ) return true ; return false ; }
bool findWinner ( int N ) { return N & 1 ; }
void wrapper ( int arr [ ] , int n , int l [ ] , int r [ ] , int q ) { int prefodd [ N ] = { 0 } , prefeven [ N ] = { 0 } ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ( i ) % 2 == 0 ) { prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ; } else { prefeven [ i ] = prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] ; } } int i = 0 ; while ( i != q ) { query ( prefeven , prefodd , l [ i ] , r [ i ] ) ; i ++ ; } }
int countgroup ( int a [ ] , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; return 0 ; }
unsigned int perfectPowerOf2 ( unsigned int n ) { unsigned int per_pow = 1 ; while ( n > 0 ) { per_pow = per_pow << 1 ; n = n >> 1 ; } return per_pow ; }
int solve ( int p [ ] , int n ) { int G = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] & 1 ) G ^= ( p [ i ] + 1 ) ; G ^= ( p [ i ] - 1 ) ; } return G ; }
bool isDivisibleby17 ( int n ) { if ( n == 0 n == 17 ) return true ; if ( n < 17 ) return false ; return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) ; }
long long answer ( long long n ) { long m = 2 ; long long ans = 1 ; long long r = 1 ; while ( r < n ) { r = ( int ) ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; }
int maxAND ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) res = max ( res , arr [ i ] & arr [ j ] ) ; return res ; }
int checkBit ( int pattern , int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( ( pattern & arr [ i ] ) == pattern ) count ++ ; return count ; }
int index ( int i ) { return 1 + ( i >> 31 ) - ( - i >> 31 ) ; }
int countPairs ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; int ans = 0 ; for ( auto it = mp . begin ( ) ; it != mp . end ( ) ; it ++ ) { int count = it -> second ; ans += ( count * ( count - 1 ) ) / 2 ; } return ans ; }
int countones ( long n ) { int c = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; c ++ ; } return c ; }
bool checking ( string s ) { int c = 0 ; int n = s . length ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '0' ) c ++ ; if ( c >= 6 and s [ i ] == '1' ) return true ; } return false ; }
unsigned int countSetBitsInGivenRange ( unsigned int n , unsigned int l , unsigned int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return countSetBits ( n & num ) ; }
bool areAllBitsSet ( unsigned int n ) { if ( n == 0 ) return false ; if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; }
int findUnique ( unsigned int a [ ] , int n , int k ) { int INT_SIZE = 8 * sizeof ( unsigned int ) ; int count [ INT_SIZE ] ; memset ( count , 0 , sizeof ( count ) ) ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; unsigned res = 0 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; }
bool powerOfTwo ( unsigned int n ) { return ( ! ( n & n - 1 ) ) ; }
bool onlyFirstAndLastAreSet ( unsigned int n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return powerOfTwo ( n - 1 ) ; }
bool allBitsAreSet ( unsigned int n ) { if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; }
bool bitsAreInAltOrder ( unsigned int n ) { unsigned int num = n ^ ( n >> 1 ) ; return allBitsAreSet ( num ) ; }
int setBit ( int xorValue ) { int count = 0 ; while ( xorValue ) { if ( xorValue % 2 ) count ++ ; xorValue /= 2 ; } return count ; }
int minFlip ( int n , int k ) { int size = log2 ( n ) + 1 ; int max = pow ( 2 , k ) - 1 ; max = max << ( size - k ) ; int xorValue = ( n ^ max ) ; return ( setBit ( xorValue ) ) ; }
int setallbitgivenrange ( int n , int l , int r ) { int range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) ; return ( n range ) ; }
unsigned countBits ( unsigned int number ) { return ( int ) log2 ( number ) + 1 ; }
int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = n / 2 ; msb ++ ; } return ( 1 << msb ) ; }
int setAllBitsAfterMSB ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return n ; }
void toggle ( int & n ) { n = n ^ setAllBitsAfterMSB ( n ) ; }
bool checkPowerof8 ( int n ) { double i = log ( n ) / log ( 8 ) ; return ( i - trunc ( i ) < 0.000001 ) ; }
bool adjacentSet ( int n ) { return ( n & ( n >> 1 ) ) ; }
int getRightMostSetBit ( unsigned int n ) { return log2 ( n & - n ) + 1 ; }
int posOfRightMostSameBit ( unsigned int m , unsigned int n ) { return getRightMostSetBit ( ~ ( m ^ n ) ) ; }
void printNonConsecutive ( int n ) { int p = ( 1 << n ) ; for ( int i = 1 ; i < p ; i ++ ) if ( ( i & ( i << 1 ) ) == 0 ) cout << i << " " ; }
int isKthBitSet ( int x , int k ) { return ( x & ( 1 << ( k - 1 ) ) ) ? 1 : 0 ; }
int leftmostSetBit ( int x ) { int count = 0 ; while ( x ) { count ++ ; x = x >> 1 ; } return count ; }
int isBinPalindrome ( int x ) { int l = leftmostSetBit ( x ) ; int r = 1 ; while ( l > r ) { if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) return 0 ; l -- ; r ++ ; } return 1 ; }
int findNthPalindrome ( int n ) { int pal_count = 0 ; int i = 0 ; for ( i = 1 ; i <= INT_MAX ; i ++ ) { if ( isBinPalindrome ( i ) ) { pal_count ++ ; } if ( pal_count == n ) break ; } return i ; }
int convertStringToInt ( string s ) { int num = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { num = num * 2 + ( s [ i ] - '0' ) ; } return num ; }
int getNthNumber ( int n ) { queue < string > q ; if ( n == 1 ) return 1 ; n -- ; q . push ( "11" ) ; while ( ! q . empty ( ) ) { string curr = q . front ( ) ; q . pop ( ) ; n -- ; if ( ! n ) { return convertStringToInt ( curr ) ; } int mid = curr . size ( ) / 2 ; if ( curr . size ( ) % 2 == 0 ) { string s0 = curr , s1 = curr ; s0 . insert ( mid , "0" ) ; s1 . insert ( mid , "1" ) ; q . push ( s0 ) ; q . push ( s1 ) ; } else { string ch ( 1 , curr [ mid ] ) ; string temp = curr ; temp . insert ( mid , ch ) ; q . push ( temp ) ; } } return 0 ; }
int constructNthNumber ( int group_no , int aux_num , int op ) { int INT_SIZE = 32 ; int a [ INT_SIZE ] = { 0 } ; int num = 0 , len_f ; int i = 0 ; if ( op == 2 ) { len_f = 2 * group_no ; a [ len_f - 1 ] = a [ 0 ] = 1 ; while ( aux_num ) { a [ group_no + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } else if ( op == 0 ) { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 0 ; while ( aux_num ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } else { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 1 ; while ( aux_num ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } for ( i = 0 ; i < len_f ; i ++ ) num += ( 1 << i ) * a [ i ] ; return num ; }
int getNthNumber ( int n ) { int group_no = 0 , group_offset ; int count_upto_group = 0 , count_temp = 1 ; int op , aux_num ; while ( count_temp < n ) { group_no ++ ; count_upto_group = count_temp ; count_temp += 3 * ( 1 << ( group_no - 1 ) ) ; } group_offset = n - count_upto_group - 1 ; if ( ( group_offset + 1 ) <= ( 1 << ( group_no - 1 ) ) ) { op = 2 ; aux_num = group_offset ; } else { if ( ( ( group_offset + 1 ) - ( 1 << ( group_no - 1 ) ) ) % 2 ) op = 0 ; else op = 1 ; aux_num = ( ( group_offset ) - ( 1 << ( group_no - 1 ) ) ) / 2 ; } return constructNthNumber ( group_no , aux_num , op ) ; }
void shuffle ( int N , int key ) { unsigned int NO_OF_BITS = N ; unsigned int reverse_num = 0 , temp ; for ( int i = 0 ; i < NO_OF_BITS ; i ++ ) { temp = ( key & ( 1 << i ) ) ; if ( temp ) reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) ; } cout << reverse_num ; }
int bitExtracted ( int number , int k , int p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; }
void areSame ( int a , int b ) { if ( ! ( a - b ) ) cout << "Same" ; else cout << "Not Same" ; }
int countSetBits ( int n ) { int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( countSetBits ( i ) == 2 ) sum += i ; return sum ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; ( 1 << i ) < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { int num = ( 1 << i ) + ( 1 << j ) ; if ( num <= n ) sum += num ; } } return sum ; }
ull findMax ( ull num ) { ull num_copy = num ; int j = sizeof ( unsigned long long int ) * 8 - 1 ; int i = 0 ; while ( i < j ) { int m = ( num_copy >> i ) & 1 ; int n = ( num_copy >> j ) & 1 ; if ( m > n ) { int x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; }
unsigned int toggleLastMBits ( unsigned int n , unsigned int m ) { unsigned int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; }
int getPosOfRightmostSetBit ( int n ) { return log2 ( n & - n ) + 1 ; }
int setRightmostUnsetBit ( int n ) { if ( n == 0 ) return 1 ; if ( ( n & ( n + 1 ) ) == 0 ) return n ; int pos = getPosOfRightmostSetBit ( ~ n ) ; return ( ( 1 << ( pos - 1 ) ) n ) ; }
int previousSmallerInteger ( int n ) { int pos = getFirstSetBitPos ( n ) ; return ( n & ~ ( 1 << ( pos - 1 ) ) ) ; }
int getRightMostSetBit ( int n ) { if ( n == 0 ) return 0 ; return log2 ( n & - n ) + 1 ; }
int posOfRightMostDiffBit ( int m , int n ) { return getRightMostSetBit ( m ^ n ) ; }
int posOfRightMostDiffBit ( int m , int n ) { return ffs ( m ^ n ) ; }
int getFirstSetBitPos ( int n ) { return ( log2 ( n & - n ) + 1 ) - 1 ; }
int nextGreaterWithOneMoreSetBit ( int n ) { int pos = getFirstSetBitPos ( ~ n ) ; if ( pos > -1 ) return ( 1 << pos ) | n ; return ( ( n << 1 ) + 1 ) ; }
int setKthBit ( int n , int k ) { return ( ( 1 << k ) n ) ; }
int getNext ( int n ) { int c = n ; int c0 = 0 ; int c1 = 0 ; while ( ( ( c & 1 ) == 0 ) && ( c != 0 ) ) { c0 ++ ; c >>= 1 ; } while ( ( c & 1 ) == 1 ) { c1 ++ ; c >>= 1 ; } if ( c0 + c1 == 31 c0 + c1 == 0 ) return -1 ; return n + ( 1 << c0 ) + ( 1 << ( c1 - 1 ) ) - 1 ; }
void reverseArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n / 2 ; i ++ ) swap ( arr [ i ] , arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] ) ; }
int countNum ( int arr [ ] , int n ) { unordered_set < int > s ; int count = 0 , maxm = INT_MIN , minm = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { s . insert ( arr [ i ] ) ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; } for ( int i = minm ; i <= maxm ; i ++ ) if ( s . find ( arr [ i ] ) == s . end ( ) ) count ++ ; return count ; }
long CountXORandSumEqual ( long x ) { long count = CountZeroBit ( x ) ; return ( 1LL << count ) ; }
int maxXORInRange ( int L , int R ) { int LXR = L ^ R ; int msbPos = 0 ; while ( LXR ) { msbPos ++ ; LXR >>= 1 ; } int maxXOR = 0 ; int two = 1 ; while ( msbPos -- ) { maxXOR += two ; two <<= 1 ; } return maxXOR ; }
int missingNumber ( int arr1 [ ] , int arr2 [ ] , int n ) { int mnum = 0 ; for ( int i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; }
int CountORandSumEqual ( int N ) { int count = CountZeroBit ( N ) ; return ( 1 << count ) ; }
int toggleKthBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; }
int countValues ( int x ) { int count = 0 , n = 1 ; while ( x != 0 ) { if ( x % 2 == 0 ) count += n ; n *= 2 ; x /= 2 ; } return count ; }
void constructXOR ( int A [ ] , int n ) { int XOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) XOR ^= A [ i ] ; for ( int i = 0 ; i < n ; i ++ ) A [ i ] = XOR ^ A [ i ] ; }
long long kBitDifferencePairs ( int arr [ ] , int n , int k ) { int MAX = * max_element ( arr , arr + n ) ; long long count [ MAX + 1 ] ; memset ( count , 0 , sizeof ( count ) ) ; for ( int i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] ] ; long long ans = 0 ; if ( k == 0 ) { for ( int i = 0 ; i <= MAX ; ++ i ) ans += ( count [ i ] * ( count [ i ] - 1 ) ) / 2 ; return ans ; } for ( int i = 0 ; i <= MAX ; ++ i ) { if ( ! count [ i ] ) continue ; for ( int j = i + 1 ; j <= MAX ; ++ j ) { if ( __builtin_popcount ( i ^ j ) == k ) ans += count [ i ] * count [ j ] ; } } return ans ; }
void multiply ( int F [ 2 ] [ 2 ] , int M [ 2 ] [ 2 ] ) { int x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ; int y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ; int z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ; int w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ; F [ 0 ] [ 0 ] = x ; F [ 0 ] [ 1 ] = y ; F [ 1 ] [ 0 ] = z ; F [ 1 ] [ 1 ] = w ; }
void power ( int F [ 2 ] [ 2 ] , int n ) { if ( n == 0 n == 1 ) return ; int M [ 2 ] [ 2 ] = { { 1 , 1 } , { 1 , 0 } } ; power ( F , n / 2 ) ; multiply ( F , F ) ; if ( n % 2 != 0 ) multiply ( F , M ) ; }
int countWays ( int n ) { int F [ 2 ] [ 2 ] = { { 1 , 1 } , { 1 , 0 } } ; if ( n == 0 ) return 0 ; power ( F , n ) ; return F [ 0 ] [ 0 ] ; }
int countTrailingZero ( int x ) { int count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; }
int totalFlips ( char * A , char * B , char * C , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; ++ i ) { if ( A [ i ] == B [ i ] && C [ i ] == '1' ) ++ count ; else if ( A [ i ] != B [ i ] && C [ i ] == '0' ) ++ count ; } return count ; }
int countNumbers ( int n ) { int k = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += pow ( 2 , k ) ; k += 1 ; n >>= 1 ; } return count ; }
int multiply ( int n , int m ) { int ans = 0 , count = 0 ; while ( m ) { if ( m % 2 == 1 ) ans += n << count ; count ++ ; m /= 2 ; } return ans ; }
bool EqualNumber ( int A , int B ) { return ( A ^ B ) ; }
int countXOR ( int n ) { int count0 = 0 , count1 = 0 ; while ( n ) { ( n % 2 == 0 ) ? count0 ++ : count1 ++ ; n /= 2 ; } return ( count0 ^ count1 ) ; }
int xorPairCount ( int arr [ ] , int n , int x ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( x ^ arr [ i ] ) != s . end ( ) ) result ++ ; s . insert ( arr [ i ] ) ; } return result ; }
int xorPairCount ( int arr [ ] , int n , int x ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = x ^ arr [ i ] ; if ( m . find ( curr_xor ) != m . end ( ) ) result += m [ curr_xor ] ; m [ arr [ i ] ] ++ ; } return result ; }
int msbPos ( ll n ) { int msb_p = -1 ; while ( n ) { n = n >> 1 ; msb_p ++ ; } return msb_p ; }
ll andOperator ( ll x , ll y ) { while ( x && y ) { int msb_p1 = msbPos ( x ) ; int msb_p2 = msbPos ( y ) ; if ( msb_p1 != msb_p2 ) break ; ll msb_val = ( 1 << msb_p1 ) ; res = res + msb_val ; x = x - msb_val ; y = y - msb_val ; } return res ; }
int multiplyTen ( int n ) { return ( n << 1 ) + ( n << 3 ) ; }
int countValues ( int n ) { int countV = 0 ; for ( int i = 0 ; i <= n ; i ++ ) if ( ( n + i ) == ( n ^ i ) ) countV ++ ; return countV ; }
int countValues ( int n ) { int unset_bits = 0 ; while ( n ) { if ( ( n & 1 ) == 0 ) unset_bits ++ ; n = n >> 1 ; } return 1 << unset_bits ; }
int countSubarrays ( int arr [ ] , int n ) { int difference = 0 ; int ans = 0 ; int hash_positive [ n + 1 ] , hash_negative [ n + 1 ] ; fill_n ( hash_positive , n + 1 , 0 ) ; fill_n ( hash_negative , n + 1 , 0 ) ; hash_positive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 == 1 ) difference ++ ; else difference -- ; if ( difference < 0 ) { ans += hash_negative [ - difference ] ; hash_negative [ - difference ] ++ ; } else { ans += hash_positive [ difference ] ; hash_positive [ difference ] ++ ; } } return ans ; }
void printTwoSetBitNums ( int n ) { int x = 1 ; while ( n > 0 ) { int y = 0 ; while ( y < x ) { cout << ( 1 << x ) + ( 1 << y ) << " " ; n -- ; if ( n == 0 ) return ; y ++ ; } x ++ ; } }
void printRepeatingEven ( int arr [ ] , int n ) { long long _xor = 0L ; long long pos ; for ( int i = 0 ; i < n ; ++ i ) { pos = 1 << arr [ i ] ; _xor ^= pos ; } for ( int i = 0 ; i < n ; ++ i ) { pos = 1 << arr [ i ] ; if ( ! ( pos & _xor ) ) { cout << arr [ i ] << " " ; _xor ^= pos ; } } }
int countSetBits ( int x ) { unsigned int count = 0 ; while ( x ) { x &= ( x - 1 ) ; count ++ ; } return count ; }
bool isBleak ( int n ) { for ( int x = 1 ; x < n ; x ++ ) if ( x + countSetBits ( x ) == n ) return false ; return true ; }
void diameter ( Node * root ) { if ( root == NULL ) return ; int ans = INT_MIN , lh = 0 , rh = 0 ; int f = 0 ; Node * k ; int height_of_tree = height ( root , ans , k , lh , rh , f ) ; int lPath [ 100 ] , pathlen = 0 ; printPathsRecur ( k -> left , lPath , pathlen , lh , f ) ; printf ( "%d " , k -> data ) ; int rPath [ 100 ] ; f = 1 ; printPathsRecur ( k -> right , rPath , pathlen , rh , f ) ; }
int countSetBits ( int x ) { unsigned int count = 0 ; while ( x ) { x &= ( x - 1 ) ; count ++ ; } return count ; }
int ceilLog2 ( int x ) { int count = 0 ; x -- ; while ( x > 0 ) { x = x >> 1 ; count ++ ; } return count ; }
bool isBleak ( int n ) { for ( int x = n - ceilLog2 ( n ) ; x < n ; x ++ ) if ( x + countSetBits ( x ) == n ) return false ; return true ; }
int countStrings ( int n ) { int a [ n ] , b [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }
int myXOR ( int x , int y ) { for ( int i = 31 ; i >= 0 ; i -- ) { bool b1 = x & ( 1 << i ) ; bool b2 = y & ( 1 << i ) ; bool xoredBit = ( b1 & b2 ) ? 0 : ( b1 b2 ) ; res <<= 1 ; res |= xoredBit ; } return res ; }
int myXOR ( int x , int y ) { return ( x y ) & ( ~ x ~ y ) ; }
int myXOR ( int x , int y ) { return ( x & ( ~ y ) ) | ( ( ~ x ) & y ) ; }
int swapBits ( int n , int p1 , int p2 ) { n ^= 1 << p1 ; n ^= 1 << p2 ; return n ; }
int multiplyBySevenByEight ( int n ) { return ( n - ( n >> 3 ) ) ; }
int subtract ( int x , int y ) { while ( y != 0 ) { int borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; }
int subtract ( int x , int y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; }
int square ( int n ) { if ( n < 0 ) n = - n ; int res = n ; for ( int i = 1 ; i < n ; i ++ ) res += n ; return res ; }
double temp_convert ( int F1 , int B1 , int F2 , int B2 , int T ) { float t2 ; t2 = F2 + ( float ) ( B2 - F2 ) / ( B1 - F1 ) * ( T - F1 ) ; return t2 ; }
int Divisible ( int arr [ ] , int n ) { int count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) count_even ++ ; return count_even + ( n - count_even ) / 2 ; }
unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
int maxLength ( int arr [ ] , int n ) { int maxLen = 0 ; int i = 0 ; int j = i + 1 ; while ( j < n ) { if ( arr [ i ] != arr [ j ] ) { maxLen = max ( maxLen , 2 ) ; int l = i - 1 ; int r = j + 1 ; while ( l >= 0 && r < n && arr [ l ] == arr [ i ] && arr [ r ] == arr [ j ] ) { l -- ; r ++ ; } maxLen = max ( maxLen , 2 * ( r - j ) ) ; } i ++ ; j = i + 1 ; } return maxLen ; }
int maxLength ( int a [ ] , int n ) { int maxLen = 0 ; int prev_cnt = 0 , curr_cnt = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) curr_cnt ++ ; else { prev_cnt = curr_cnt ; curr_cnt = 1 ; } maxLen = max ( maxLen , min ( prev_cnt , curr_cnt ) ) ; } return ( 2 * maxLen ) ; }
int freivald ( int a [ ] [ N ] , int b [ ] [ N ] , int c [ ] [ N ] ) { bool r [ N ] ; for ( int i = 0 ; i < N ; i ++ ) r [ i ] = random ( ) % 2 ; int br [ N ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) br [ i ] = br [ i ] + b [ i ] [ j ] * r [ j ] ; int cr [ N ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) cr [ i ] = cr [ i ] + c [ i ] [ j ] * r [ j ] ; int axbr [ N ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) axbr [ i ] = axbr [ i ] + a [ i ] [ j ] * br [ j ] ; for ( int i = 0 ; i < N ; i ++ ) if ( axbr [ i ] - cr [ i ] != 0 ) false ; return true ; }
bool isProduct ( int a [ ] [ N ] , int b [ ] [ N ] , int c [ ] [ N ] , int k ) { for ( int i = 0 ; i < k ; i ++ ) if ( freivald ( a , b , c ) == false ) return false ; return true ; }
int children ( Node * root ) { if ( ! root ) return 0 ; return root -> children + 1 ; }
int randomNodeUtil ( Node * root , int count ) { if ( ! root ) return 0 ; if ( count == children ( root -> left ) ) return root -> data ; if ( count < children ( root -> left ) ) return randomNodeUtil ( root -> left , count ) ; return randomNodeUtil ( root -> right , count - children ( root -> left ) - 1 ) ; }
int randomNode ( Node * root ) { srand ( time ( 0 ) ) ; int count = rand ( ) % ( root -> children + 1 ) ; return randomNodeUtil ( root , count ) ; }
float calc_Expectation ( float a [ ] , float n ) { float prb = ( 1 / n ) ; float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] * prb ; return sum ; }
int findLargestd ( int S [ ] , int n ) { bool found = false ; sort ( S , S + n ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return INT_MIN ; }
int recaman ( int n ) { int arr [ n ] ; arr [ 0 ] = 0 ; printf ( "%d, " , arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int curr = arr [ i - 1 ] - i ; int j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; printf ( "%d, " , arr [ i ] ) ; } }
int countPairs ( int arr [ ] , int n ) { unordered_set < int > s ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( sumOfDiv ( arr [ i ] ) ) != s . end ( ) ) { int sum = sumOfDiv ( arr [ i ] ) ; if ( isAmicable ( arr [ i ] , sum ) ) count ++ ; } } return count / 2 ; }
int findArea ( int arr [ ] , int n ) { sort ( arr , arr + n , greater < int > ( ) ) ; int dimension [ 2 ] = { 0 , 0 } ; for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; }
int findArea ( int arr [ ] , int n ) { unordered_set < int > s ; int first = 0 , second = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( arr [ i ] ) == s . end ( ) ) { s . insert ( arr [ i ] ) ; continue ; } if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } return ( first * second ) ; }
void printAllPaths ( Node * root ) { if ( root == NULL ) return ; vector < PATH > Allpaths ( MAX_PATH_SIZE ) ; printAllPathsUtil ( root , Allpaths , 0 , 0 ) ; }
int longLenStrictBitonicSub ( int arr [ ] , int n ) { unordered_map < int , int > inc , dcr ; int len_inc [ n ] , len_dcr [ n ] ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( inc . find ( arr [ i ] - 1 ) != inc . end ( ) ) len = inc [ arr [ i ] - 1 ] ; inc [ arr [ i ] ] = len_inc [ i ] = len + 1 ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { int len = 0 ; if ( dcr . find ( arr [ i ] - 1 ) != dcr . end ( ) ) len = dcr [ arr [ i ] - 1 ] ; dcr [ arr [ i ] ] = len_dcr [ i ] = len + 1 ; } for ( int i = 0 ; i < n ; i ++ ) if ( longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) ) longLen = len_inc [ i ] + len_dcr [ i ] - 1 ; return longLen ; }
void leftRotatebyOne ( int arr [ ] , int n ) { int temp = arr [ 0 ] , i ; for ( i = 0 ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = temp ; }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return -1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
bool pairInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; }
int pairsInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; }
int maxSum ( int arr [ ] , int n ) { int res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = max ( res , curr_sum ) ; } return res ; }
int maxSum ( int arr [ ] , int n ) { int cum_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; int curr_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ; int res = curr_val ; for ( int i = 1 ; i < n ; i ++ ) { int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ; curr_val = next_val ; res = max ( res , next_val ) ; } return res ; }
int countRotations ( int arr [ ] , int n ) { int min = arr [ 0 ] , min_index ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; }
int countRotations ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }
void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) cout << arr [ i % n ] << " " ; }
int findMin ( int arr [ ] , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; }
void reverseArray ( int arr [ ] , int start , int end ) { while ( start < end ) { std :: swap ( arr [ start ] , arr [ end ] ) ; start ++ ; end -- ; } }
void rightRotate ( int arr [ ] , int d , int n ) { reverseArray ( arr , 0 , n - 1 ) ; reverseArray ( arr , 0 , d - 1 ) ; reverseArray ( arr , d , n - 1 ) ; }
int maxHamming ( int arr [ ] , int n ) { int brr [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; int maxHam = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int currHam = 0 ; for ( int j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = max ( maxHam , currHam ) ; } return maxHam ; }
void rearrangeArr ( int arr [ ] , int n ) { int evenPos = n / 2 ; int oddPos = n - evenPos ; int tempArr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) tempArr [ i ] = arr [ i ] ; sort ( tempArr , tempArr + n ) ; int j = oddPos - 1 ; for ( int i = 0 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j -- ; } j = oddPos ; for ( int i = 1 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j ++ ; } for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
void moveZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) swap ( arr [ count ++ ] , arr [ i ] ) ; }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; }
void modifyAndRearrangeArr ( int arr [ ] , int n ) { if ( n == 1 ) return ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( arr [ i ] != 0 ) && ( arr [ i ] == arr [ i + 1 ] ) ) { arr [ i ] = 2 * arr [ i ] ; arr [ i + 1 ] = 0 ; i ++ ; } } pushZerosToEnd ( arr , n ) ; }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
void RearrangePosNeg ( int arr [ ] , int n ) { int key , j ; for ( int i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; if ( key > 0 ) continue ; j = i - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } }
bool isLeaf ( Node * node ) { if ( node == NULL ) return false ; if ( node -> left == NULL && node -> right == NULL ) return true ; return false ; }
int leftLeavesSum ( Node * root ) { int res = 0 ; if ( root != NULL ) { if ( isLeaf ( root -> left ) ) res += root -> left -> key ; else res += leftLeavesSum ( root -> left ) ; res += leftLeavesSum ( root -> right ) ; } return res ; }
void reverse ( int arr [ ] , int l , int r ) { if ( l < r ) { swap ( arr [ l ] , arr [ r ] ) ; reverse ( arr , ++ l , -- r ) ; } }
void RearrangePosNeg ( int arr [ ] , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; RearrangePosNeg ( arr , l , m ) ; RearrangePosNeg ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } }
void rearrangeNaive ( int arr [ ] , int n ) { int temp [ n ] , i ; for ( i = 0 ; i < n ; i ++ ) temp [ arr [ i ] ] = i ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) cout << ( "%d " , arr [ i ] ) ; cout << ( "\n" ) ; }
void rearrange ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ arr [ i ] % n ] += i * n ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] /= n ; } }
void rearrange ( int arr [ ] , int n ) { int max_idx = n - 1 , min_idx = 0 ; int max_elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] / max_elem ; }
void rearrange ( int arr [ ] , int n ) { int max_ele = arr [ n - 1 ] ; int min_ele = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_ele ; max_ele -= 1 ; } else { arr [ i ] = min_ele ; min_ele += 1 ; } } }
void leftLeavesSumRec ( Node * root , bool isleft , int * sum ) { if ( ! root ) return ; if ( ! root -> left && ! root -> right && isleft ) * sum += root -> key ; leftLeavesSumRec ( root -> left , 1 , sum ) ; leftLeavesSumRec ( root -> right , 0 , sum ) ; }
int leftLeavesSum ( Node * root ) { int sum = 0 ; leftLeavesSumRec ( root , 0 , & sum ) ; return sum ; }
void rearrange ( int arr [ ] , int n ) { int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) { if ( i != j ) swap ( arr [ i ] , arr [ j ] ) ; j ++ ; } } }
void segregateElements ( int arr [ ] , int n ) { int temp [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; memcpy ( arr , temp , sizeof ( temp ) ) ; }
void rearrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) swap ( a [ positive ] , a [ negative ] ) ; else break ; } }
void printPostorder ( struct Node * node ) { if ( node == NULL ) return ; printPostorder ( node -> left ) ; printPostorder ( node -> right ) ; cout << node -> data << " " ; }
void printInorder ( struct Node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; cout << node -> data << " " ; printInorder ( node -> right ) ; }
void printPreorder ( struct Node * node ) { if ( node == NULL ) return ; cout << node -> data << " " ; printPreorder ( node -> left ) ; printPreorder ( node -> right ) ; }
int largest ( int arr [ ] , int n ) { return * max_element ( arr , arr + n ) ; }
void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) cout << arr [ i ] << " " ; } }
void findElements ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) cout << arr [ i ] << " " ; }
void findElements ( int arr [ ] , int n ) { int first = INT_MIN , second = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) cout << arr [ i ] << " " ; }
double findMean ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return ( double ) sum / ( double ) n ; }
double findMedian ( int a [ ] , int n ) { sort ( a , a + n ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; }
int findSmallestMissinginSortedArray ( vector < int > arr ) { if ( arr [ 0 ] != 0 ) return 0 ; if ( arr [ arr . size ( ) - 1 ] == arr . size ( ) - 1 ) return arr . size ( ) ; int first = arr [ 0 ] ; return findFirstMissing ( arr , 0 , arr . size ( ) - 1 , first ) ; }
int findFirstMissing ( vector < int > arr , int start , int end , int first ) { if ( start < end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] != mid + first ) return findFirstMissing ( arr , start , mid , first ) ; else return findFirstMissing ( arr , mid + 1 , end , first ) ; } return start + first ; }
int sumNodes ( int l ) { int leafNodeCount = pow ( 2 , l - 1 ) ; int sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; int sum = sumLastLevel * l ; return sum ; }
void buildSparseTable ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) lookup [ i ] [ 0 ] = arr [ i ] ; for ( int j = 1 ; ( 1 << j ) <= n ; j ++ ) { for ( int i = 0 ; ( i + ( 1 << j ) - 1 ) < n ; i ++ ) { if ( lookup [ i ] [ j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] ; else lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ; } } }
int query ( int L , int R ) { int j = ( int ) log2 ( R - L + 1 ) ; if ( lookup [ L ] [ j ] <= lookup [ R - ( 1 << j ) + 1 ] [ j ] ) return lookup [ L ] [ j ] ; else return lookup [ R - ( 1 << j ) + 1 ] [ j ] ; }
void add ( int arr [ ] , int N , int lo , int hi , int val ) { arr [ lo ] += val ; if ( hi != N - 1 ) arr [ hi + 1 ] -= val ; }
void updateArray ( int arr [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) arr [ i ] += arr [ i - 1 ] ; }
void FillPrefixSuffix ( int prefix [ ] , int arr [ ] , int suffix [ ] , int n ) { prefix [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix [ i ] = __gcd ( prefix [ i - 1 ] , arr [ i ] ) ; suffix [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffix [ i ] = __gcd ( suffix [ i + 1 ] , arr [ i ] ) ; }
int GCDoutsideRange ( int l , int r , int prefix [ ] , int suffix [ ] , int n ) { if ( l == 0 ) return suffix [ r + 1 ] ; if ( r == n - 1 ) return prefix [ l - 1 ] ; return __gcd ( prefix [ l - 1 ] , suffix [ r + 1 ] ) ; }
int lowerIndex ( int arr [ ] , int n , int x ) { int l = 0 , h = n - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] >= x ) h = mid - 1 ; else l = mid + 1 ; } return l ; }
int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; count = upperIndex ( arr , n , y ) - lowerIndex ( arr , n , x ) + 1 ; return count ; }
void precompute ( int arr [ ] , int n , int pre [ ] ) { memset ( pre , 0 , n * sizeof ( int ) ) ; pre [ n - 1 ] = arr [ n - 1 ] * pow ( 2 , 0 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) pre [ i ] = pre [ i + 1 ] + arr [ i ] * ( 1 << ( n - 1 - i ) ) ; }
int decimalOfSubarr ( int arr [ ] , int l , int r , int n , int pre [ ] ) { if ( r != n - 1 ) return ( pre [ l ] - pre [ r + 1 ] ) / ( 1 << ( n - 1 - r ) ) ; return pre [ l ] / ( 1 << ( n - 1 - r ) ) ; }
int answerQuery ( int a [ ] , int n , int l , int r ) { int count = 0 ; l = l - 1 ; for ( int i = l ; i < r ; i ++ ) { int element = a [ i ] ; int divisors = 0 ; for ( int j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; }
void addConsideringGrid ( Node * root , int level , int index ) { if ( root == NULL ) return ; grid [ level - index ] += ( root -> data ) ; addConsideringGrid ( root -> left , level + 1 , index - 1 ) ; addConsideringGrid ( root -> right , level + 1 , index + 1 ) ; }
vector < int > diagonalSum ( Node * root ) { grid . clear ( ) ; addConsideringGrid ( root , 0 , 0 ) ; vector < int > ans ; for ( auto x : grid ) { ans . push_back ( x . second ) ; } return ans ; }
void make_prefix ( int A [ ] , int n ) { for ( int j = 0 ; j < 32 ; j ++ ) one [ 0 ] [ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int a = A [ i - 1 ] ; for ( int j = 0 ; j < 32 ; j ++ ) { int x = pow ( 2 , j ) ; if ( a & x ) one [ i ] [ j ] = 1 + one [ i - 1 ] [ j ] ; else one [ i ] [ j ] = one [ i - 1 ] [ j ] ; } } }
void type1 ( int arr [ ] , int start , int limit ) { for ( int i = start ; i <= limit ; i ++ ) arr [ i ] ++ ; }
void type2 ( int arr [ ] , int query [ ] [ 3 ] , int start , int limit ) { for ( int i = start ; i <= limit ; i ++ ) { if ( query [ i ] [ 0 ] == 1 ) type1 ( arr , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; else if ( query [ i ] [ 0 ] == 2 ) type2 ( arr , query , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; } }
void record_sum ( int record [ ] , int l , int r , int n , int adder ) { for ( int i = l ; i <= r ; i ++ ) record [ i ] += adder ; }
int solveQuery ( int start , int end , int arr [ ] ) { unordered_map < int , int > frequency ; for ( int i = start ; i <= end ; i ++ ) frequency [ arr [ i ] ] ++ ; int count = 0 ; for ( auto x : frequency ) if ( x . first == x . second ) count ++ ; return count ; }
int answer_query ( int a [ ] , int n , int l , int r ) { int count = 0 ; for ( int i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; }
int countIndex ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == a [ i + 1 ] ) prefixans [ i ] = 1 ; if ( i != 0 ) prefixans [ i ] += prefixans [ i - 1 ] ; } }
int answer_query ( int l , int r ) { if ( l == 0 ) return prefixans [ r - 1 ] ; else return prefixans [ r - 1 ] - prefixans [ l - 1 ] ; }
void update ( vector < int > & D , int l , int r , int x ) { D [ l ] += x ; D [ r + 1 ] -= x ; }
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = max ( max_so_far , curr_max ) ; } return max_so_far ; }
int minJumps ( int arr [ ] , int n ) { int * jumps = new int [ n ] ; int min ; jumps [ n - 1 ] = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == 0 ) jumps [ i ] = INT_MAX ; else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ; else { min = INT_MAX ; for ( int j = i + 1 ; j < n && j <= arr [ i ] + i ; j ++ ) { if ( min > jumps [ j ] ) min = jumps [ j ] ; } if ( min != INT_MAX ) jumps [ i ] = min + 1 ; else jumps [ i ] = min ; } } return jumps [ 0 ] ; }
int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 , min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; }
int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return -1 ; int * csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } delete [ ] csum ; return max_end - k + 1 ; }
int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return -1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; }
int findMinOps ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 , j = n - 1 ; i <= j ; ) { if ( arr [ i ] == arr [ j ] ) { i ++ ; j -- ; } else if ( arr [ i ] > arr [ j ] ) { j -- ; arr [ j ] += arr [ j + 1 ] ; ans ++ ; } else { i ++ ; arr [ i ] += arr [ i - 1 ] ; ans ++ ; } } return ans ; }
int findSmallest ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 0 ; i < n && arr [ i ] <= res ; i ++ ) res = res + arr [ i ] ; return res ; }
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; start = s ; end = i ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; s = i + 1 ; } } return ( end - start + 1 ) ; }
int findMinDiff ( int arr [ ] , int n ) { int diff = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) < diff ) diff = abs ( arr [ i ] - arr [ j ] ) ; return diff ; }
int findMinDiff ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int diff = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; }
bool checkbit ( int array [ ] , int index ) { return array [ index >> 5 ] & ( 1 << ( index & 31 ) ) ; }
void setbit ( int array [ ] , int index ) { array [ index >> 5 ] |= ( 1 << ( index & 31 ) ) ; }
void sortInWave ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i += 2 ) swap ( & arr [ i ] , & arr [ i + 1 ] ) ; }
void sortInWave ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i += 2 ) { if ( i > 0 && arr [ i - 1 ] > arr [ i ] ) swap ( & arr [ i ] , & arr [ i - 1 ] ) ; if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) swap ( & arr [ i ] , & arr [ i + 1 ] ) ; } }
void moveToEnd ( int mPlusN [ ] , int size ) { int j = size - 1 ; for ( int i = size - 1 ; i >= 0 ; i -- ) if ( mPlusN [ i ] != NA ) { mPlusN [ j ] = mPlusN [ i ] ; j -- ; } }
int merge ( int mPlusN [ ] , int N [ ] , int m , int n ) { int i = n ; int j = 0 ; int k = 0 ; while ( k < ( m + n ) ) { if ( ( j == n ) || ( i < ( m + n ) && mPlusN [ i ] <= N [ j ] ) ) { mPlusN [ k ] = mPlusN [ i ] ; k ++ ; i ++ ; } else { mPlusN [ k ] = N [ j ] ; k ++ ; j ++ ; } } }
bool sortedAfterSwap ( int A [ ] , bool B [ ] , int n ) { int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { j = i ; while ( B [ j ] ) j ++ ; sort ( A + i , A + 1 + j ) ; i = j ; } } for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return false ; } return true ; }
bool sortedAfterSwap ( int A [ ] , bool B [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { if ( A [ i ] != i + 1 ) swap ( A [ i ] , A [ i + 1 ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return false ; } return true ; }
void segregate0and1 ( int arr [ ] , int n ) { int type0 = 0 ; int type1 = n - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { swap ( arr [ type0 ] , arr [ type1 ] ) ; type1 -- ; } else { type0 ++ ; } } }
bool increasing ( int a [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) if ( a [ i ] >= a [ i + 1 ] ) return false ; return true ; }
bool decreasing ( int a [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) if ( a [ i ] < a [ i + 1 ] ) return false ; return true ; }
int shortestUnsorted ( int a [ ] , int n ) { if ( increasing ( a , n ) == true || decreasing ( a , n ) == true ) return 0 ; else return 3 ; }
int indexOf ( vector < int > & arr , int ele ) { for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( arr [ i ] == ele ) { return i ; } } return -1 ; }
int minSwaps ( vector < int > arr , int N ) { int ans = 0 ; vector < int > temp ( arr . begin ( ) , arr . end ( ) ) ; sort ( temp . begin ( ) , temp . end ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != temp [ i ] ) { ans ++ ; swap ( arr , i , indexOf ( arr , temp [ i ] ) ) ; } } return ans ; }
void printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { if ( m > n ) { int * tempp = arr1 ; arr1 = arr2 ; arr2 = tempp ; int temp = m ; m = n ; n = temp ; } sort ( arr1 , arr1 + m ) ; for ( int i = 0 ; i < m ; i ++ ) cout << arr1 [ i ] << " " ; for ( int i = 0 ; i < n ; i ++ ) if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) == -1 ) cout << arr2 [ i ] << " " ; }
void printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { if ( m > n ) { int * tempp = arr1 ; arr1 = arr2 ; arr2 = tempp ; int temp = m ; m = n ; n = temp ; } sort ( arr1 , arr1 + m ) ; for ( int i = 0 ; i < n ; i ++ ) if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) != -1 ) cout << arr2 [ i ] << " " ; }
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return -1 ; }
void intersection ( int a [ ] , int b [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( a [ i ] > b [ j ] ) { j ++ ; } else if ( b [ j ] > a [ i ] ) { i ++ ; } else { cout << a [ i ] << " " ; i ++ ; j ++ ; } } }
void sort012 ( int a [ ] , int arr_size ) { int lo = 0 ; int hi = arr_size - 1 ; int mid = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : swap ( a [ lo ++ ] , a [ mid ++ ] ) ; break ; case 1 : mid ++ ; break ; case 2 : swap ( a [ mid ] , a [ hi -- ] ) ; break ; } } }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
void sortArr ( int arr [ ] , int n ) { int i , cnt0 = 0 , cnt1 = 0 , cnt2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { switch ( arr [ i ] ) { case 0 : cnt0 ++ ; break ; case 1 : cnt1 ++ ; break ; case 2 : cnt2 ++ ; break ; } } i = 0 ; while ( cnt0 > 0 ) { arr [ i ++ ] = 0 ; cnt0 -- ; } while ( cnt1 > 0 ) { arr [ i ++ ] = 1 ; cnt1 -- ; } while ( cnt2 > 0 ) { arr [ i ++ ] = 2 ; cnt2 -- ; } printArr ( arr , n ) ; }
int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }
int binarySearch ( int arr [ ] , int low , int high , int x ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( x == arr [ mid ] ) return mid ; if ( x > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return -1 ; }
int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 , i ; sort ( arr , arr + n ) ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( binarySearch ( arr , i + 1 , n - 1 , arr [ i ] + k ) != -1 ) count ++ ; return count ; }
void constructArr ( int arr [ ] , int pair [ ] , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }
int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { int max = arr1 [ 0 ] ; int min = arr2 [ 0 ] ; int i ; for ( i = 1 ; i < n1 && i < n2 ; ++ i ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; if ( arr2 [ i ] < min ) min = arr2 [ i ] ; } while ( i < n1 ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; i ++ ; } while ( i < n2 ) { if ( arr2 [ i ] < min ) min = arr2 [ i ] ; i ++ ; } return max * min ; }
int findElement ( int arr [ ] , int n , int key ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return -1 ; }
int findPos ( int arr [ ] , int key ) { int l = 0 , h = 1 ; int val = arr [ 0 ] ; while ( val < key ) { l = h ; h = 2 * h ; val = arr [ h ] ; } return binarySearch ( arr , l , h , key ) ; }
int findSingle ( int ar [ ] , int ar_size ) { int res = ar [ 0 ] ; for ( int i = 1 ; i < ar_size ; i ++ ) res = res ^ ar [ i ] ; return res ; }
bool isPresent ( int B [ ] , int m , int x ) { for ( int i = 0 ; i < m ; i ++ ) if ( B [ i ] == x ) return true ; return false ; }
int findMaxSubarraySumUtil ( int A [ ] , int B [ ] , int n , int m ) { int max_so_far = INT_MIN , curr_max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPresent ( B , m , A [ i ] ) ) { curr_max = 0 ; continue ; } curr_max = max ( A [ i ] , curr_max + A [ i ] ) ; max_so_far = max ( max_so_far , curr_max ) ; } return max_so_far ; }
int findMaxSum ( int arr [ ] , int n ) { int res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { int prefix_sum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; int suffix_sum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = max ( res , prefix_sum ) ; } return res ; }
int getTotalHeight ( struct Node * root ) { if ( root == NULL ) return 0 ; return getTotalHeight ( root -> left ) + getHeight ( root ) + getTotalHeight ( root -> right ) ; }
int findMaxSum ( int arr [ ] , int n ) { int preSum [ n ] ; int suffSum [ n ] ; int ans = INT_MIN ; preSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = max ( ans , preSum [ n - 1 ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = max ( ans , preSum [ i ] ) ; } return ans ; }
int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return -1 ; }
int ceilSearch ( int arr [ ] , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return -1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } }
void findMajority ( int arr [ ] , int n ) { int maxCount = 0 ; int index = -1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) cout << arr [ index ] << endl ; else cout << "No Majority Element" << endl ; }
int getTotalHeight ( Node * root ) { int sum = 0 ; getTotalHeightUtil ( root , sum ) ; return sum ; }
int majorityElement ( int * arr , int n ) { sort ( arr , arr + n ) ; int count = 1 , max_ele = -1 , temp = arr [ 0 ] , ele , f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( temp == arr [ i ] ) { count ++ ; } else { count = 1 ; temp = arr [ i ] ; } if ( max_ele < count ) { max_ele = count ; ele = arr [ i ] ; if ( max_ele > ( n / 2 ) ) { f = 1 ; break ; } } } return ( f == 1 ? ele : -1 ) ; }
bool isMajority ( int arr [ ] , int n , int x ) { int i ; int last_index = n % 2 ? ( n / 2 + 1 ) : ( n / 2 ) ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return 1 ; } return 0 ; }
int _binarySearch ( int arr [ ] , int low , int high , int x ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( ( mid == 0 x > arr [ mid - 1 ] ) && ( arr [ mid ] == x ) ) return mid ; else if ( x > arr [ mid ] ) return _binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return _binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return -1 ; }
bool isMajority ( int arr [ ] , int n , int x ) { int i = _binarySearch ( arr , 0 , n - 1 , x ) ; if ( i == -1 ) return false ; if ( ( ( i + n / 2 ) <= ( n - 1 ) ) && arr [ i + n / 2 ] == x ) return true ; else return false ; }
bool isMajorityElement ( int arr [ ] , int n , int key ) { if ( arr [ n / 2 ] == key ) return true ; else return false ; }
int findPeak ( int arr [ ] , int n ) { if ( n == 1 ) return 0 ; if ( arr [ 0 ] >= arr [ 1 ] ) return 0 ; if ( arr [ n - 1 ] >= arr [ n - 2 ] ) return n - 1 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] >= arr [ i - 1 ] && arr [ i ] >= arr [ i + 1 ] ) return i ; } }
int findPeak ( int arr [ ] , int n ) { return findPeakUtil ( arr , 0 , n - 1 , n ) ; }
void printRepeating ( int arr [ ] , int size ) { int i , j ; printf ( " Repeating elements are " ) ; for ( i = 0 ; i < size ; i ++ ) for ( j = i + 1 ; j < size ; j ++ ) if ( arr [ i ] == arr [ j ] ) cout << arr [ i ] << " " ; }
void printRepeating ( int arr [ ] , int size ) { int * count = new int [ sizeof ( int ) * ( size - 2 ) ] ; int i ; cout << " Repeating elements are " ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) cout << arr [ i ] << " " ; else count [ arr [ i ] ] ++ ; } }
void printRepeating ( int arr [ ] , int size ) { int S = 0 ; int P = 1 ; int x , y ; int D ; int n = size - 2 , i ; for ( i = 0 ; i < size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; } S = S - n * ( n + 1 ) / 2 ; P = P / fact ( n ) ; D = sqrt ( S * S - 4 * P ) ; x = ( D + S ) / 2 ; y = ( S - D ) / 2 ; cout << "The two Repeating elements are " << x << " & " << y ; }
int fact ( int n ) { return ( n == 0 ) ? 1 : n * fact ( n - 1 ) ; }
void printRepeating ( int arr [ ] , int size ) { int Xor = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) Xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) Xor ^= i ; set_bit_no = Xor & ~ ( Xor - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i & set_bit_no ) x = x ^ i ; else y = y ^ i ; } cout << "The two repeating elements are " << y << " " << x ; }
int linearSearch ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return -1 ; }
int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum , i , j ; for ( i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { cout << "Sum found between indexes " << i << " and " << j - 1 ; return 1 ; } if ( curr_sum > sum j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } cout << "No subarray found" ; return 0 ; }
int maxTripletSum ( int arr [ ] , int n ) { int sum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; }
int maxTripletSum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; }
int maxTripletSum ( int arr [ ] , int n ) { int maxA = INT_MIN , maxB = INT_MIN , maxC = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; } return ( maxA + maxB + maxC ) ; }
int minimum ( int a , int b , int c ) { return min ( min ( a , b ) , c ) ; }
void smallestDifferenceTriplet ( int arr1 [ ] , int arr2 [ ] , int arr3 [ ] , int n ) { sort ( arr1 , arr1 + n ) ; sort ( arr2 , arr2 + n ) ; sort ( arr3 , arr3 + n ) ; int res_min , res_max , res_mid ; int i = 0 , j = 0 , k = 0 ; int diff = INT_MAX ; while ( i < n && j < n && k < n ) { int sum = arr1 [ i ] + arr2 [ j ] + arr3 [ k ] ; int max = maximum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) ; int min = minimum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) ; if ( min == arr1 [ i ] ) i ++ ; else if ( min == arr2 [ j ] ) j ++ ; else k ++ ; if ( diff > ( max - min ) ) { diff = max - min ; res_max = max ; res_mid = sum - ( max + min ) ; res_min = min ; } } cout << res_max << ", " << res_mid << ", " << res_min ; }
bool find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { cout << "Triplet is " << A [ i ] << ", " << A [ j ] << ", " << A [ k ] ; return true ; } } } } return false ; }
bool find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; sort ( A , A + arr_size ) ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { l = i + 1 ; r = arr_size - 1 ; while ( l < r ) { if ( A [ i ] + A [ l ] + A [ r ] == sum ) { printf ( "Triplet is %d, %d, %d" , A [ i ] , A [ l ] , A [ r ] ) ; return true ; } else if ( A [ i ] + A [ l ] + A [ r ] < sum ) l ++ ; else r -- ; } } return false ; }
bool areConsecutive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { bool * visited = ( bool * ) calloc ( n , sizeof ( bool ) ) ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - min ] != false ) return false ; visited [ arr [ i ] - min ] = true ; } return true ; } return false ; }
bool areConsecutive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { int j ; if ( arr [ i ] < 0 ) j = - arr [ i ] - min ; else j = arr [ i ] - min ; if ( arr [ j ] > 0 ) arr [ j ] = - arr [ j ] ; else return false ; } return true ; } return false ; }
int getMax ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ; return max ; }
void relativeComplement ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( arr1 [ i ] < arr2 [ j ] ) { cout << arr1 [ i ] << " " ; i ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) { j ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; j ++ ; } } while ( i < n ) cout << arr1 [ i ] << " " ; }
int minOps ( int arr [ ] , int n , int k ) { int max = * max_element ( arr , arr + n ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return -1 ; else res += ( max - arr [ i ] ) / k ; } return res ; }
void search ( vector < int > arr , int search_Element ) { int left = 0 ; int length = arr . size ( ) ; int position = -1 ; int right = length - 1 ; for ( left = 0 ; left <= right ; ) { if ( arr [ left ] == search_Element ) { position = left ; cout << "Element found in Array at " << position + 1 << " Position with " << left + 1 << " Attempt" ; break ; } if ( arr [ right ] == search_Element ) { position = right ; cout << "Element found in Array at " << position + 1 << " Position with " << length - right << " Attempt" ; break ; } left ++ ; right -- ; } if ( position == -1 ) cout << "Not found in Array with " << left << " Attempt" ; }
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return -1 ; }
int exponentialSearch ( int arr [ ] , int n , int x ) { if ( arr [ 0 ] == x ) return 0 ; int i = 1 ; while ( i < n && arr [ i ] <= x ) i = i * 2 ; return binarySearch ( arr , i / 2 , min ( i , n - 1 ) , x ) ; }
int findCrossOver ( int arr [ ] , int low , int high , int x ) { if ( arr [ high ] <= x ) return high ; if ( arr [ low ] > x ) return low ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] <= x && arr [ mid + 1 ] > x ) return mid ; if ( arr [ mid ] < x ) return findCrossOver ( arr , mid + 1 , high , x ) ; return findCrossOver ( arr , low , mid - 1 , x ) ; }
int countSort ( int arr [ ] , int n , int exp ) { int output [ n ] ; int i , count [ n ] ; for ( int i = 0 ; i < n ; i ++ ) count [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) count [ ( arr [ i ] / exp ) % n ] ++ ; for ( i = 1 ; i < n ; i ++ ) count [ i ] += count [ i - 1 ] ; for ( i = n - 1 ; i >= 0 ; i -- ) { output [ count [ ( arr [ i ] / exp ) % n ] - 1 ] = arr [ i ] ; count [ ( arr [ i ] / exp ) % n ] -- ; } for ( i = 0 ; i < n ; i ++ ) arr [ i ] = output [ i ] ; }
void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n , int x ) { int diff = INT_MAX ; int res_l , res_r ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } cout << "The closest pair is [" << ar1 [ res_l ] << ", " << ar2 [ res_r ] << "] \n" ; }
int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; }
int minCost ( int cost [ R ] [ C ] , int m , int n ) { if ( n < 0 m < 0  ) return INT_MAX ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ; }
int minCost ( int cost [ R ] [ C ] , int m , int n ) { int i , j ; int tc [ R ] [ C ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return tc [ m ] [ n ] ; }
int matrixChainMemoised ( int * p , int i , int j ) { if ( i == j ) { return 0 ; } if ( dp [ i ] [ j ] != -1 ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] = INT_MAX ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i ] [ j ] ; }
int MatrixChainOrder ( int * p , int n ) { int i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; }
int MatrixChainOrder ( int p [ ] , int n ) { int m [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; m [ i ] [ j ] = INT_MAX ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; }
int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; }
int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }
int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }
int max ( int x , int y ) { return ( x > y ) ? x : y ; }
int lps ( char * seq , int i , int j ) { if ( i == j ) return 1 ; if ( seq [ i ] == seq [ j ] && i + 1 == j ) return 2 ; if ( seq [ i ] == seq [ j ] ) return lps ( seq , i + 1 , j - 1 ) + 2 ; return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; }
int cutRod ( int price [ ] , int n ) { if ( n <= 0 ) return 0 ; int max_val = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) max_val = max ( max_val , price [ i ] + cutRod ( price , n - i - 1 ) ) ; return max_val ; }
int cutRod ( int price [ ] , int n ) { int val [ n + 1 ] ; val [ 0 ] = 0 ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { int max_val = INT_MIN ; for ( j = 0 ; j < i ; j ++ ) max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; }
int minPalPartion ( string String , int i , int j ) { if ( i >= j || isPalindrome ( String , i , j ) ) return 0 ; int ans = INT_MAX , count ; for ( int k = i ; k < j ; k ++ ) { count = minPalPartion ( String , i , k ) + minPalPartion ( String , k + 1 , j ) + 1 ; ans = min ( ans , count ) ; } return ans ; }
int maxDivide ( int a , int b ) { while ( a % b == 0 ) a = a / b ; return a ; }
int getNthUglyNo ( int n ) { int i = 1 ; int count = 1 ; while ( n > count ) { i ++ ; if ( isUgly ( i ) ) count ++ ; } return i ; }
int optimalSearchTree ( int keys [ ] , int freq [ ] , int n ) { return optCost ( freq , 0 , n - 1 ) ; }
int sum ( int freq [ ] , int i , int j ) { int s = 0 ; for ( int k = i ; k <= j ; k ++ ) s += freq [ k ] ; return s ; }
int optimalSearchTree ( int keys [ ] , int freq [ ] , int n ) { int cost [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) cost [ i ] [ i ] = freq [ i ] ; for ( int L = 2 ; L <= n ; L ++ ) { for ( int i = 0 ; i <= n - L + 1 ; i ++ ) { int j = i + L - 1 ; cost [ i ] [ j ] = INT_MAX ; for ( int r = i ; r <= j ; r ++ ) { int c = ( ( r > i ) ? cost [ i ] [ r - 1 ] : 0 ) + ( ( r < j ) ? cost [ r + 1 ] [ j ] : 0 ) + sum ( freq , i , j ) ; if ( c < cost [ i ] [ j ] ) cost [ i ] [ j ] = c ; } } } return cost [ 0 ] [ n - 1 ] ; }
bool isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
int countParenth ( char symb [ ] , char oper [ ] , int n ) { int F [ n ] [ n ] , T [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { F [ i ] [ i ] = ( symb [ i ] == 'F' ) ? 1 : 0 ; T [ i ] [ i ] = ( symb [ i ] == 'T' ) ? 1 : 0 ; } for ( int gap = 1 ; gap < n ; ++ gap ) { for ( int i = 0 , j = gap ; j < n ; ++ i , ++ j ) { T [ i ] [ j ] = F [ i ] [ j ] = 0 ; for ( int g = 0 ; g < gap ; g ++ ) { int k = i + g ; int tik = T [ i ] [ k ] + F [ i ] [ k ] ; int tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ; if ( oper [ k ] == '&' ) { T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ; F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == ' ' ) { F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] ; T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == '^' ) { T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ; F [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ; } } } } return T [ 0 ] [ n - 1 ] ; }
int getCount ( char keypad [ ] [ 3 ] , int n ) { if ( keypad == NULL n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; int row [ ] = { 0 , 0 , -1 , 0 , 1 } ; int col [ ] = { 0 , -1 , 0 , 1 , 0 } ; int count [ 10 ] [ n + 1 ] ; int i = 0 , j = 0 , k = 0 , move = 0 , ro = 0 , co = 0 , num = 0 ; int nextNum = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) { count [ i ] [ 0 ] = 0 ; count [ i ] [ 1 ] = 1 ; } for ( k = 2 ; k <= n ; k ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { if ( keypad [ i ] [ j ] != '*' && keypad [ i ] [ j ] != '#' ) { num = keypad [ i ] [ j ] - '0' ; count [ num ] [ k ] = 0 ; for ( move = 0 ; move < 5 ; move ++ ) { ro = i + row [ move ] ; co = j + col [ move ] ; if ( ro >= 0 && ro <= 3 && co >= 0 && co <= 2 && keypad [ ro ] [ co ] != '*' && keypad [ ro ] [ co ] != '#' ) { nextNum = keypad [ ro ] [ co ] - '0' ; count [ num ] [ k ] += count [ nextNum ] [ k - 1 ] ; } } } } } } totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) totalCount += count [ i ] [ n ] ; return totalCount ; }
int getCount ( char keypad [ ] [ 3 ] , int n ) { if ( keypad == NULL n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; int odd [ 10 ] , even [ 10 ] ; int i = 0 , j = 0 , useOdd = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) odd [ i ] = 1 ; for ( j = 2 ; j <= n ; j ++ ) { useOdd = 1 - useOdd ; if ( useOdd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 8 ] ; even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] ; even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] ; even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] ; even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] ; even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] ; even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] ; even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ; even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ; even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] ; } else { odd [ 0 ] = even [ 0 ] + even [ 8 ] ; odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] ; odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] ; odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] ; odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] ; odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] ; odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] ; odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] ; odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] ; odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] ; } } totalCount = 0 ; if ( useOdd == 1 ) { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += even [ i ] ; } else { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += odd [ i ] ; } return totalCount ; }
unsigned long long int finalCount ( int n , int sum ) { unsigned long long int ans = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; }
unsigned long long int finalCount ( int n , int sum ) { memset ( lookup , -1 , sizeof lookup ) ; unsigned long long int ans = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; }
void findCount ( int n , int sum ) { int start = pow ( 10 , n - 1 ) ; int end = pow ( 10 , n ) - 1 ; int count = 0 ; int i = start ; while ( i <= end ) { int cur = 0 ; int temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = temp / 10 ; } if ( cur == sum ) { count ++ ; i += 9 ; } else i ++ ; } cout << count ; }
long long int countNonDecreasing ( int n ) { long long int dp [ 10 ] [ n + 1 ] ; memset ( dp , 0 , sizeof dp ) ; for ( int i = 0 ; i < 10 ; i ++ ) dp [ i ] [ 1 ] = 1 ; for ( int digit = 0 ; digit <= 9 ; digit ++ ) { for ( int len = 2 ; len <= n ; len ++ ) { for ( int x = 0 ; x <= digit ; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } long long int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ i ] [ n ] ; return count ; }
long long int countNonDecreasing ( int n ) { int N = 10 ; long long count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count /= i ; } return count ; }
int getMinSquares ( unsigned int n ) { if ( sqrt ( n ) - floor ( sqrt ( n ) ) == 0 ) return 1 ; if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int * dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( int x = 1 ; x <= ceil ( sqrt ( i ) ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } int res = dp [ n ] ; delete [ ] dp ; return res ; }
int minCoins ( int coins [ ] , int m , int V ) { int table [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = INT_MAX ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( coins [ j ] <= i ) { int sub_res = table [ i - coins [ j ] ] ; if ( sub_res != INT_MAX && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } if ( table [ V ] == INT_MAX ) return -1 ; return table [ V ] ; }
int superSeq ( char * X , char * Y , int m , int n ) { if ( ! m ) return n ; if ( ! n ) return m ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }
int superSeq ( char * X , char * Y , int m , int n ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( ! i ) dp [ i ] [ j ] = j ; else if ( ! j ) dp [ i ] [ j ] = i ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }
int sumOfDigitsFrom1ToN ( int n ) { int result = 0 ; for ( int x = 1 ; x <= n ; x ++ ) result += sumOfDigits ( x ) ; return result ; }
int sumOfDigits ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = x / 10 ; } return sum ; }
int sumOfDigitsFrom1ToN ( int n ) { if ( n < 10 ) return n * ( n + 1 ) / 2 ; int d = log10 ( n ) ; int * a = new int [ d + 1 ] ; a [ 0 ] = 0 , a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ceil ( pow ( 10 , i - 1 ) ) ; int p = ceil ( pow ( 10 , d ) ) ; int msd = n / p ; return msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ; }
int sumOfDigitsFrom1ToN ( int n ) { int d = ( int ) ( log10 ( n ) ) ; int a [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( ceil ( pow ( 10 , i - 1 ) ) ) ; return sumOfDigitsFrom1ToNUtil ( n , a ) ; }
int countWays ( int N ) { if ( N == 1 ) return 4 ; int countB = 1 , countS = 1 , prev_countB , prev_countS ; for ( int i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; } int result = countS + countB ; return ( result * result ) ; }
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int max = 0 ; int b ; for ( b = N - 3 ; b >= 1 ; b -- ) { int curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; }
int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = 0 ; for ( b = n - 3 ; b >= 1 ; b -- ) { int curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; }
int count ( int n ) { int table [ n + 1 ] , i ; for ( int j = 0 ; j < n + 1 ; j ++ ) table [ j ] = 0 ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }
float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } }
int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = -1 , m2 = -1 ; for ( count = 0 ; count <= n ; count ++ ) { if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; } if ( ar1 [ i ] <= ar2 [ j ] ) { m1 = m2 ; m2 = ar1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; }
float area ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; }
bool isInside ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x , int y ) { float A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) ; float A1 = area ( x , y , x2 , y2 , x3 , y3 ) ; float A2 = area ( x1 , y1 , x , y , x3 , y3 ) ; float A3 = area ( x1 , y1 , x2 , y2 , x , y ) ; return ( A == A1 + A2 + A3 ) ; }
bool isLucky ( int n ) { static int counter = 2 ; int next_position = n ; if ( counter > n ) return 1 ; if ( n % counter == 0 ) return 0 ; next_position -= next_position / counter ; counter ++ ; return isLucky ( next_position ) ; }
float squareRoot ( float n ) { float x = n ; float y = 1 ; float e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }
int maxDiffUtil ( Node * t , int * res ) { if ( t == NULL ) return INT_MAX ; if ( t -> left == NULL && t -> right == NULL ) return t -> key ; int val = min ( maxDiffUtil ( t -> left , res ) , maxDiffUtil ( t -> right , res ) ) ; * res = max ( * res , t -> key - val ) ; return min ( val , t -> key ) ; }
int maxDiff ( Node * root ) { int res = INT_MIN ; maxDiffUtil ( root , & res ) ; return res ; }
void inorder ( Node * root ) { if ( root ) { inorder ( root -> left ) ; printf ( "%d " , root -> key ) ; inorder ( root -> right ) ; } }
int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
int multiply ( int x , int y ) { if ( y ) return ( x + multiply ( x , y - 1 ) ) ; else return 0 ; }
int pow ( int a , int b ) { if ( b ) return multiply ( a , pow ( a , b - 1 ) ) ; else return 1 ; }
float getAvg ( float prev_avg , int x , int n ) { return ( prev_avg * n + x ) / ( n + 1 ) ; }
int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; }
int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; }
int findSmallerInRight ( char * str , int low , int high ) { int countRight = 0 , i ; for ( i = low + 1 ; i <= high ; ++ i ) if ( str [ i ] < str [ low ] ) ++ countRight ; return countRight ; }
int findRank ( char * str ) { int len = strlen ( str ) ; int mul = fact ( len ) ; int rank = 1 ; int countRight ; int i ; for ( i = 0 ; i < len ; ++ i ) { mul /= len - i ; countRight = findSmallerInRight ( str , i , len - 1 ) ; rank += countRight * mul ; } return rank ; }
void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { cout << C << " " ; C = C * ( line - i ) / i ; } cout << "\n" ; } }
float exponential ( int n , float x ) { float sum = 1.0f ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }
void printCombination ( int arr [ ] , int n , int r ) { int data [ r ] ; combinationUtil ( arr , n , r , 0 , data , 0 ) ; }
int myRand ( int arr [ ] , int freq [ ] , int n ) { int prefix [ n ] , i ; prefix [ 0 ] = freq [ 0 ] ; for ( i = 1 ; i < n ; ++ i ) prefix [ i ] = prefix [ i - 1 ] + freq [ i ] ; int r = ( rand ( ) % prefix [ n - 1 ] ) + 1 ; int indexc = findCeil ( prefix , r , 0 , n - 1 ) ; return arr [ indexc ] ; }
bool isPerfectSquare ( int x ) { int s = sqrt ( x ) ; return ( s * s == x ) ; }
bool isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
int findgroups ( int arr [ ] , int n ) { int c [ 3 ] = { 0 } , i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; }
int findTrailingZeros ( int n ) { int count = 0 ; for ( int i = 5 ; n / i >= 1 ; i *= 5 ) count += n / i ; return count ; }
unsigned long int catalan ( unsigned int n ) { if ( n <= 1 ) return 1 ; unsigned long int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res += catalan ( i ) * catalan ( n - i - 1 ) ; return res ; }
unsigned long int catalan ( unsigned int n ) { unsigned long int c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
void catalan ( int n ) { cpp_int cat_ = 1 ; cout << cat_ << " " ; for ( cpp_int i = 1 ; i < n ; i ++ ) { cat_ *= ( 4 * i - 2 ) ; cat_ /= ( i + 1 ) ; cout << cat_ << " " ; } }
int calcAngle ( double h , double m ) { if ( h < 0 m < 0 h > 12 m > 60 ) printf ( "Wrong input" ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) { m = 0 ; h += 1 ; if ( h > 12 ) h = h - 12 ; } float hour_angle = 0.5 * ( h * 60 + m ) ; float minute_angle = 6 * m ; float angle = abs ( hour_angle - minute_angle ) ; angle = min ( 360 - angle , angle ) ; return angle ; }
int getInvCount ( int arr [ ] ) { int inv_count = 0 ; for ( int i = 0 ; i < 9 - 1 ; i ++ ) for ( int j = i + 1 ; j < 9 ; j ++ ) if ( arr [ j ] && arr [ i ] && arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; }
bool isSolvable ( int puzzle [ 3 ] [ 3 ] ) { int invCount = getInvCount ( ( int * ) puzzle ) ; return ( invCount % 2 == 0 ) ; }
int find ( double p ) { return ceil ( sqrt ( 2 * 365 * log ( 1 / ( 1 - p ) ) ) ) ; }
int countSolutions ( int n ) { int res = 0 ; for ( int x = 0 ; x * x < n ; x ++ ) for ( int y = 0 ; x * x + y * y < n ; y ++ ) res ++ ; return res ; }
int countSolutions ( int n ) { int x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; }
double func ( double x ) { return x * x * x - x * x + 2 ; }
void regulaFalsi ( double a , double b ) { if ( func ( a ) * func ( b ) >= 0 ) { cout << "You have not assumed right a and b\n" ; return ; } double c = a ; for ( int i = 0 ; i < MAX_ITER ; i ++ ) { c = ( a * func ( b ) - b * func ( a ) ) / ( func ( b ) - func ( a ) ) ; if ( func ( c ) == 0 ) break ; else if ( func ( c ) * func ( a ) < 0 ) b = c ; else a = c ; } cout << "The value of root is : " << c ; }
double func ( double x ) { return x * x * x - x * x + 2 ; }
double derivFunc ( double x ) { return 3 * x * x - 2 * x ; }
void newtonRaphson ( double x ) { double h = func ( x ) / derivFunc ( x ) ; while ( abs ( h ) >= EPSILON ) { h = func ( x ) / derivFunc ( x ) ; x = x - h ; } cout << "The value of the root is : " << x ; }
int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; }
bool oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; }
unsigned int countSetBits ( unsigned int n ) { int bitCount = 0 ; for ( int i = 1 ; i <= n ; i ++ ) bitCount += countSetBitsUtil ( i ) ; return bitCount ; }
unsigned int countSetBitsUtil ( unsigned int x ) { if ( x <= 0 ) return 0 ; return ( x % 2 == 0 ? 0 : 1 ) + countSetBitsUtil ( x / 2 ) ; }
int swapBits ( unsigned int num , unsigned int p1 , unsigned int p2 , unsigned int n ) { int shift1 , shift2 , value1 , value2 ; while ( n -- ) { shift1 = 1 << p1 ; shift2 = 1 << p2 ; value1 = ( ( num & shift1 ) ) ; value2 = ( ( num & shift2 ) ) ; if ( ( ! value1 && value2 ) || ( ! value2 && value1 ) ) { if ( value1 ) { num = num & ( ~ shift1 ) ; num = num | shift2 ; } else { num = num & ( ~ shift2 ) ; num = num | shift1 ; } } p1 ++ ; p2 ++ ; } return num ; }
int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; }
int smallest ( int x , int y , int z ) { int c = 0 ; while ( x && y && z ) { x -- ; y -- ; z -- ; c ++ ; } return c ; }
int min ( int x , int y ) { return y + ( ( x - y ) & ( ( x - y ) >> ( sizeof ( int ) * CHAR_BIT - 1 ) ) ) ; }
int smallest ( int x , int y , int z ) { return min ( x , min ( y , z ) ) ; }
uint_t snoob ( uint_t x ) { uint_t rightOne ; uint_t nextHigherOneBit ; uint_t rightOnesPattern ; uint_t next = 0 ; if ( x ) { rightOne = x & - ( signed ) x ; nextHigherOneBit = x + rightOne ; rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( rightOnesPattern ) / rightOne ; rightOnesPattern >>= 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; }
int addOne ( int x ) { int m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; }
int addOne ( int x ) { return ( - ( ~ x ) ) ; }
int fun ( unsigned int n ) { return n & ( n - 1 ) ; }
bool isPowerOfFour ( unsigned int n ) { int count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; }
bool isPowerOfFour ( unsigned int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0xAAAAAAAA ) ; }
float logn ( int n , int r ) { return log ( n ) / log ( r ) ; }
void findPostOrderUtil ( int pre [ ] , int n , int minval , int maxval , int & preIndex ) { if ( preIndex == n ) return ; if ( pre [ preIndex ] < minval pre [ preIndex ] > maxval ) { return ; } int val = pre [ preIndex ] ; preIndex ++ ; findPostOrderUtil ( pre , n , minval , val , preIndex ) ; findPostOrderUtil ( pre , n , val , maxval , preIndex ) ; cout << val << " " ; }
void findPostOrder ( int pre [ ] , int n ) { int preIndex = 0 ; findPostOrderUtil ( pre , n , INT_MIN , INT_MAX , preIndex ) ; }
unsigned int getModulo ( unsigned int n , unsigned int d ) { return ( n & ( d - 1 ) ) ; }
int min ( int x , int y ) { return y ^ ( ( x ^ y ) & - ( x < y ) ) ; }
int max ( int x , int y ) { return x ^ ( ( x ^ y ) & - ( x < y ) ) ; }
int absbit32 ( int x , int y ) { int sub = x - y ; int mask = ( sub >> 31 ) ; return ( sub ^ mask ) - mask ; }
int max ( int x , int y ) { int abs = absbit32 ( x , y ) ; return ( x + y + abs ) / 2 ; }
int min ( int x , int y ) { int abs = absbit32 ( x , y ) ; return ( x + y - abs ) / 2 ; }
int getOddOccurrence ( int arr [ ] , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return -1 ; }
int getOddOccurrence ( int arr [ ] , int size ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < size ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( auto i : hash ) { if ( i . second % 2 != 0 ) { return i . first ; } } return -1 ; }
int countWays ( int N , int K ) { return K * fastPow ( K - 1 , N - 1 ) ; }
unsigned int countSetBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }
int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; }
void initialize ( ) { BitsSetTable256 [ 0 ] = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ i / 2 ] ; } }
int countSetBits ( int N ) { int count = 0 ; for ( int i = 0 ; i < sizeof ( int ) * 8 ; i ++ ) { if ( N & ( 1 << i ) ) count ++ ; } return count ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n &= ( n - 1 ) ; } return count ; }
int FlippedCount ( int a , int b ) { return countSetBits ( a ^ b ) ; }
unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
unsigned int nextPowerOf2 ( unsigned int n ) { unsigned int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; }
unsigned int nextPowerOf2 ( unsigned int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; }
bool getParity ( unsigned int n ) { bool parity = 0 ; while ( n ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; }
bool isPowerOfTwo ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n / 2 ; } return 1 ; }
bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; }
unsigned int getFirstSetBitPos ( int n ) { return log2 ( n & - n ) + 1 ; }
int Right_most_setbit ( int num ) { if ( num == 0 ) { return 0 ; } else { int pos = 1 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { if ( ! ( num & ( 1 << i ) ) ) pos ++ ; else break ; } return pos ; } }
void bin ( long n ) { long i ; cout << "0" ; for ( i = 1 << 30 ; i > 0 ; i = i / 2 ) { if ( ( n & i ) != 0 ) { cout << "1" ; } else { cout << "0" ; } } }
int findPosition ( unsigned n ) { if ( ! isPowerOfTwo ( n ) ) return -1 ; unsigned i = 1 , pos = 1 ; while ( ! ( i & n ) ) { i = i << 1 ; ++ pos ; } return pos ; }
int isPowerOfTwo ( unsigned n ) { return n && ( ! ( n & ( n - 1 ) ) ) ; }
int findPosition ( unsigned n ) { if ( ! isPowerOfTwo ( n ) ) return -1 ; unsigned count = 0 ; while ( n ) { n = n >> 1 ; ++ count ; } return count ; }
void swap ( int * xp , int * yp ) { * xp = * xp ^ * yp ; * yp = * xp ^ * yp ; * xp = * xp ^ * yp ; }
void swap ( int & a , int & b ) { a = ( a & b ) + ( a b ) ; b = a + ( ~ b ) + 1 ; a = a + ( ~ b ) + 1 ; cout << "After swapping: a = " << a << ", b = " << b ; }
bool checkSentence ( char str [ ] ) { int len = strlen ( str ) ; if ( str [ 0 ] < 'A' str [ 0 ] > 'Z' ) return false ; if ( str [ len - 1 ] != '.' ) return false ; int prev_state = 0 , curr_state = 0 ; int index = 1 ; while ( str [ index ] ) { if ( str [ index ] >= 'A' && str [ index ] <= 'Z' ) curr_state = 0 ; else if ( str [ index ] == ' ' ) curr_state = 1 ; else if ( str [ index ] >= 'a' && str [ index ] <= 'z' ) curr_state = 2 ; else if ( str [ index ] == '.' ) curr_state = 3 ; if ( prev_state == curr_state && curr_state != 2 ) return false ; if ( prev_state == 2 && curr_state == 0 ) return false ; if ( curr_state == 3 && prev_state != 1 ) return ( str [ index + 1 ] == '\0' ) ; index ++ ; prev_state = curr_state ; } return false ; }
int maxOnesIndex ( bool arr [ ] , int n ) { int max_count = 0 ; int max_index ; int prev_zero = -1 ; int prev_prev_zero = -1 ; for ( int curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; }
int findLength ( int arr [ ] , int n ) { int max_len = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int mn = arr [ i ] , mx = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { mn = min ( mn , arr [ j ] ) ; mx = max ( mx , arr [ j ] ) ; if ( ( mx - mn ) == j - i ) max_len = max ( max_len , mx - mn + 1 ) ; } } return max_len ; }
bool isSubSequence ( char str1 [ ] , char str2 [ ] , int m , int n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; }
void segregate0and1 ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) count ++ ; } for ( int i = 0 ; i < count ; i ++ ) arr [ i ] = 0 ; for ( int i = count ; i < n ; i ++ ) arr [ i ] = 1 ; }
void find3Numbers ( vector < int > & nums ) { if ( nums . size ( ) < 3 ) { cout << "No such triplet found" ; return ; } int seq = 1 ; int min_num = nums [ 0 ] ; int max_seq = INT_MIN ; int store_min = min_num ; for ( int i = 1 ; i < nums . size ( ) ; i ++ ) { if ( nums [ i ] == min_num ) continue ; else if ( nums [ i ] < min_num ) { min_num = nums [ i ] ; continue ; } else if ( nums [ i ] < max_seq ) { max_seq = nums [ i ] ; store_min = min_num ; } else if ( nums [ i ] > max_seq ) { seq ++ ; if ( seq == 3 ) { cout << "Triplet: " << store_min << ", " << max_seq << ", " << nums [ i ] << endl ; return ; } max_seq = nums [ i ] ; } } cout << "No such triplet found" ; }
int maxCircularSum ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } int curr_max = a [ 0 ] , max_so_far = a [ 0 ] , curr_min = a [ 0 ] , min_so_far = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { curr_max = max ( curr_max + a [ i ] , a [ i ] ) ; max_so_far = max ( max_so_far , curr_max ) ; curr_min = min ( curr_min + a [ i ] , a [ i ] ) ; min_so_far = min ( min_so_far , curr_min ) ; } if ( min_so_far == sum ) return max_so_far ; return max ( max_so_far , sum - min_so_far ) ; }
int GetCeilIndex ( int arr [ ] , vector < int > & T , int l , int r , int key ) { while ( r - l > 1 ) { int m = l + ( r - l ) / 2 ; if ( arr [ T [ m ] ] >= key ) r = m ; else l = m ; } return r ; }
void generateUtil ( int A [ ] , int B [ ] , int C [ ] , int i , int j , int m , int n , int len , bool flag ) { if ( flag ) { if ( len ) printArr ( C , len + 1 ) ; for ( int k = i ; k < m ; k ++ ) { if ( ! len ) { C [ len ] = A [ k ] ; generateUtil ( A , B , C , k + 1 , j , m , n , len , ! flag ) ; } else { if ( A [ k ] > C [ len ] ) { C [ len + 1 ] = A [ k ] ; generateUtil ( A , B , C , k + 1 , j , m , n , len + 1 , ! flag ) ; } } } } else { for ( int l = j ; l < n ; l ++ ) { if ( B [ l ] > C [ len ] ) { C [ len + 1 ] = B [ l ] ; generateUtil ( A , B , C , i , l + 1 , m , n , len + 1 , ! flag ) ; } } } }
void generate ( int A [ ] , int B [ ] , int m , int n ) { int C [ m + n ] ; generateUtil ( A , B , C , 0 , 0 , m , n , 0 , true ) ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; cout << endl ; }
void replace_elements ( int arr [ ] , int n ) { int pos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ pos ++ ] = arr [ i ] ; while ( pos > 1 && arr [ pos - 2 ] == arr [ pos - 1 ] ) { pos -- ; arr [ pos - 1 ] ++ ; } } for ( int i = 0 ; i < pos ; i ++ ) cout << arr [ i ] << " " ; }
void arrangeString ( string str , int x , int y ) { int count_0 = 0 ; int count_1 = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) count_0 ++ ; else count_1 ++ ; } while ( count_0 > 0 count_1 > 0 ) { for ( int j = 0 ; j < x && count_0 > 0 ; j ++ ) { if ( count_0 > 0 ) { cout << "0" ; count_0 -- ; } } for ( int j = 0 ; j < y && count_1 > 0 ; j ++ ) { if ( count_1 > 0 ) { cout << "1" ; count_1 -- ; } } } }
int maxDiff ( int arr [ ] , int arr_size ) { int max_diff = arr [ 1 ] - arr [ 0 ] ; for ( int i = 0 ; i < arr_size ; i ++ ) { for ( int j = i + 1 ; j < arr_size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_diff ) max_diff = arr [ j ] - arr [ i ] ; } } return max_diff ; }
int maxDiff ( int arr [ ] , int n ) { int maxDiff = -1 ; int maxRight = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > maxRight ) maxRight = arr [ i ] ; else { int diff = maxRight - arr [ i ] ; if ( diff > maxDiff ) { maxDiff = diff ; } } } return maxDiff ; }
int maxDiff ( int arr [ ] , int n ) { int diff = arr [ 1 ] - arr [ 0 ] ; int curr_sum = diff ; int max_sum = curr_sum ; for ( int i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; }
int maxIndexDiff ( int arr [ ] , int n ) { int maxDiff = -1 ; int i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; }
int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low + 1 ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else break ; } return max ; }
int findMaximum ( int arr [ ] , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; else return findMaximum ( arr , mid + 1 , high ) ; }
void constructLowerArray ( int arr [ ] , int * countSmaller , int n ) { int i , j ; for ( i = 0 ; i < n ; i ++ ) countSmaller [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] < arr [ i ] ) countSmaller [ i ] ++ ; } } }
void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " " ; cout << "\n" ; }
int findMissingPositive ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) { if ( abs ( arr [ i ] ) - 1 < size && arr [ abs ( arr [ i ] ) - 1 ] > 0 ) arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; } for ( i = 0 ; i < size ; i ++ ) if ( arr [ i ] > 0 ) return i + 1 ; return size + 1 ; }
int findMissing ( int arr [ ] , int size ) { int shift = segregate ( arr , size ) ; return findMissingPositive ( arr + shift , size - shift ) ; }
void fillDepth ( int parent [ ] , int i , int depth [ ] ) { if ( depth [ i ] ) return ; if ( parent [ i ] == -1 ) { depth [ i ] = 1 ; return ; } if ( depth [ parent [ i ] ] == 0 ) fillDepth ( parent , parent [ i ] , depth ) ; depth [ i ] = depth [ parent [ i ] ] + 1 ; }
int maxRepeating ( int * arr , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % k ] += k ; int max = arr [ 0 ] , result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; }
int maxPathSum ( int ar1 [ ] , int ar2 [ ] , int m , int n ) { int i = 0 , j = 0 ; int result = 0 , sum1 = 0 , sum2 = 0 ; while ( i < m && j < n ) { if ( ar1 [ i ] < ar2 [ j ] ) sum1 += ar1 [ i ++ ] ; else if ( ar1 [ i ] > ar2 [ j ] ) sum2 += ar2 [ j ++ ] ; else { result += max ( sum1 , sum2 ) + ar1 [ i ] ; sum1 = 0 ; sum2 = 0 ; i ++ ; j ++ ; } } while ( i < m ) sum1 += ar1 [ i ++ ] ; while ( j < n ) sum2 += ar2 [ j ++ ] ; result += max ( sum1 , sum2 ) ; return result ; }
void smallestGreater ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int diff = INT_MAX , closest = -1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] && arr [ j ] - arr [ i ] < diff ) { diff = arr [ j ] - arr [ i ] ; closest = j ; } } ( closest == -1 ) ? cout << "_ " : cout << arr [ closest ] << " " ; } }
void smallestGreater ( int arr [ ] , int n ) { set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { auto it = s . find ( arr [ i ] ) ; it ++ ; if ( it != s . end ( ) ) cout << * it << " " ; else cout << "_ " ; } }
long long int arraySum ( int arr [ ] , int n ) { long long int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum ; }
long long int maxDiff ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; long long int arraysum = arraySum ( arr , n ) ; long long int diff1 = abs ( arraysum - 2 * arraySum ( arr , k ) ) ; reverse ( arr , arr + n ) ; long long int diff2 = abs ( arraysum - 2 * arraySum ( arr , k ) ) ; return ( max ( diff1 , diff2 ) ) ; }
int minNumber ( int a [ ] , int n , int x ) { sort ( a , a + n ) ; int k ; for ( k = 0 ; a [ ( n - 1 ) / 2 ] != x ; k ++ ) { a [ n ++ ] = x ; sort ( a , a + n ) ; } return k ; }
int minNumber ( int a [ ] , int n , int x ) { int l = 0 , h = 0 , e = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == x ) e ++ ; else if ( a [ i ] > x ) h ++ ; else if ( a [ i ] < x ) l ++ ; } int ans = 0 ; if ( l > h ) ans = l - h ; else if ( l < h ) ans = h - l - 1 ; return ans + 1 - e ; }
int fun ( int x ) { int y = ( x / 4 ) * 4 ; int ans = 0 ; for ( int i = y ; i <= x ; i ++ ) ans ^= i ; return ans ; }
int query ( int x ) { if ( x == 0 ) return 0 ; int k = ( x + 1 ) / 2 ; return ( x %= 2 ) ? 2 * fun ( k ) : ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) ; }
int preprocess ( int arr [ ] , int N , int left [ ] , int right [ ] ) { left [ 0 ] = 0 ; int lastIncr = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) lastIncr = i ; left [ i ] = lastIncr ; } right [ N - 1 ] = N - 1 ; int firstDecr = N - 1 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > arr [ i + 1 ] ) firstDecr = i ; right [ i ] = firstDecr ; } }
bool isSubarrayMountainForm ( int arr [ ] , int left [ ] , int right [ ] , int L , int R ) { return ( right [ L ] >= left [ R ] ) ; }
void sieveOfEratosthenes ( bool isPrime [ ] ) { isPrime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) isPrime [ i ] = false ; } } }
int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; }
int queryPrimesUtil ( int * st , int ss , int se , int qs , int qe , int index ) { if ( qs <= ss && qe >= se ) return st [ index ] ; if ( se < qs ss > qe ) return 0 ; int mid = getMid ( ss , se )  ; return queryPrimesUtil ( st , ss , mid , qs , qe , 2 * index + 1 ) + queryPrimesUtil ( st , mid + 1 , se , qs , qe , 2 * index + 2 ) ; }
void updateValueUtil ( int * st , int ss , int se , int i , int diff , int si ) { if ( i < ss i > se ) return ; st [ si ] = st [ si ] + diff  ; if ( se != ss ) { int mid = getMid ( ss , se ) ; updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) ; updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) ; } }
void updateValue ( int arr [ ] , int * st , int n , int i , int new_val , bool isPrime [ ] ) { if ( i < 0 i > n  - 1 ) { printf ( "Invalid Input" ) ; return ; } int diff , oldValue ; oldValue = arr [ i ] ; arr [ i ] = new_val ; if ( isPrime [ oldValue ] && isPrime [ new_val ] ) return ; if ( ( ! isPrime [ oldValue ] ) && ( ! isPrime [ new_val ] ) ) return ; if ( isPrime [ oldValue ] && ! isPrime [ new_val ] ) { diff = -1 ; } if ( ! isPrime [ oldValue ] && isPrime [ new_val ] ) { diff = 1 ; } updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) ; }
int constructSTUtil ( int arr [ ] , int ss , int se , int * st , int si , bool isPrime [ ] ) { if ( ss == se ) { if ( isPrime [ arr [ ss ] ] ) st [ si ] = 1 ; else st [ si ] = 0 ; return st [ si ] ; } int mid = getMid ( ss , se ) ; st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 , isPrime ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 , isPrime ) ; return st [ si ] ; }
void checkEVENodd ( int arr [ ] , int n , int l , int r ) { if ( arr [ r ] == 1 ) cout << "odd" << endl ; else cout << "even" << endl ; }
int findMean ( int arr [ ] , int l , int r ) { int sum = 0 , count = 0 ; for ( int i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; } int mean = floor ( sum / count ) ; return mean ; }
void calculatePrefixSum ( int arr [ ] , int n ) { prefixSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] ; }
int findMean ( int l , int r ) { if ( l == 0 ) return floor ( prefixSum [ r ] / ( r + 1 ) ) ; return floor ( ( prefixSum [ r ] - prefixSum [ l - 1 ] ) / ( r - l + 1 ) ) ; }
void updateQuery ( int arr [ ] , int n , int q , int l , int r , int k ) { if ( q == 0 ) { arr [ l - 1 ] += k ; arr [ r ] += - k ; } else { arr [ l - 1 ] += - k ; arr [ r ] += k ; } return ; }
void generateArray ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; ++ i ) arr [ i ] += arr [ i - 1 ] ; return ; }
int calculateProduct ( int A [ ] , int L , int R , int P ) { L = L - 1 ; R = R - 1 ; int ans = 1 ; for ( int i = L ; i <= R ; i ++ ) { ans = ans * A [ i ] ; ans = ans % P ; } return ans ; }
int modInverse ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m , a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; }
void calculate_Pre_Product ( int A [ ] , int N , int P ) { pre_product [ 0 ] = A [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { pre_product [ i ] = pre_product [ i - 1 ] * A [ i ] ; pre_product [ i ] = pre_product [ i ] % P ; } }
void calculate_inverse_product ( int A [ ] , int N , int P ) { inverse_product [ 0 ] = modInverse ( pre_product [ 0 ] , P ) ; for ( int i = 1 ; i < N ; i ++ ) inverse_product [ i ] = modInverse ( pre_product [ i ] , P ) ; }
int calculateProduct ( int A [ ] , int L , int R , int P ) { L = L - 1 ; R = R - 1 ; int ans ; if ( L == 0 ) ans = pre_product [ R ] ; else ans = pre_product [ R ] * inverse_product [ L - 1 ] ; return ans ; }
void buildPrefix ( ) { bool prime [ MAX + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } prefix [ 0 ] = prefix [ 1 ] = 0 ; for ( int p = 2 ; p <= MAX ; p ++ ) { prefix [ p ] = prefix [ p - 1 ] ; if ( prime [ p ] ) prefix [ p ] ++ ; } }
int query ( int L , int R ) { return prefix [ R ] - prefix [ L - 1 ] ; }
void command ( bool arr [ ] , int a , int b ) { arr [ a ] ^= 1 ; arr [ b + 1 ] ^= 1 ; }
void incrementByD ( int arr [ ] , struct query q_arr [ ] , int n , int m , int d ) { int sum [ n ] ; memset ( sum , 0 , sizeof ( sum ) ) ; for ( int i = 0 ; i < m ; i ++ ) { sum [ q_arr [ i ] . start ] += d ; if ( ( q_arr [ i ] . end + 1 ) < n ) sum [ q_arr [ i ] . end + 1 ] -= d ; } arr [ 0 ] += sum [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum [ i ] += sum [ i - 1 ] ; arr [ i ] += sum [ i ] ; } }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
double probability ( int a [ ] , int b [ ] , int size1 , int size2 ) { int max1 = INT_MIN , count1 = 0 ; for ( int i = 0 ; i < size1 ; i ++ ) { if ( a [ i ] > max1 ) { max1 = a [ i ] ; count1 = 1 ; } else if ( a [ i ] == max1 ) { count1 ++ ; } } int max2 = INT_MIN , count2 = 0 ; for ( int i = 0 ; i < size2 ; i ++ ) { if ( b [ i ] > max2 ) { max2 = b [ i ] ; count2 = 1 ; } else if ( b [ i ] == max2 ) { count2 ++ ; } } return ( double ) ( count1 * count2 ) / ( size1 * size2 ) ; }
int countDe ( int arr [ ] , int n ) { vector < int > v ( arr , arr + n ) ; sort ( arr , arr + n ) ; int count1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count1 ++ ; reverse ( arr , arr + n ) ; int count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count2 ++ ; return ( min ( count1 , count2 ) ) ; }
int printMinimumProduct ( int arr [ ] , int n ) { int first_min = min ( arr [ 0 ] , arr [ 1 ] ) ; int second_min = max ( arr [ 0 ] , arr [ 1 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] < first_min ) { second_min = first_min ; first_min = arr [ i ] ; } else if ( arr [ i ] < second_min ) second_min = arr [ i ] ; } return first_min * second_min ; }
long long noOfTriples ( long long arr [ ] , int n ) { sort ( arr , arr + n ) ; long long count = 0 ; for ( long long i = 0 ; i < n ; i ++ ) if ( arr [ i ] == arr [ 2 ] ) count ++ ; if ( arr [ 0 ] == arr [ 2 ] ) return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 ; else if ( arr [ 1 ] == arr [ 2 ] ) return ( count - 1 ) * ( count ) / 2 ; return count ; }
bool checkReverse ( int arr [ ] , int n ) { int temp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) temp [ i ] = arr [ i ] ; sort ( temp , temp + n ) ; int front ; for ( front = 0 ; front < n ; front ++ ) if ( temp [ front ] != arr [ front ] ) break ; int back ; for ( back = n - 1 ; back >= 0 ; back -- ) if ( temp [ back ] != arr [ back ] ) break ; if ( front >= back ) return true ; do { front ++ ; if ( arr [ front - 1 ] < arr [ front ] ) return false ; } while ( front != back ) ; return true ; }
bool checkReverse ( int arr [ ] , int n ) { if ( n == 1 ) return true ; int i ; for ( i = 1 ; i < n && arr [ i - 1 ] < arr [ i ] ; i ++ ) ; if ( i == n ) return true ; int j = i ; while ( j < n && arr [ j ] < arr [ j - 1 ] ) { if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) return false ; j ++ ; } if ( j == n ) return true ; int k = j ; if ( arr [ k ] < arr [ i - 1 ] ) return false ; while ( k > 1 && k < n ) { if ( arr [ k ] < arr [ k - 1 ] ) return false ; k ++ ; } return true ; }
void sortExceptUandL ( int a [ ] , int l , int u , int n ) { int b [ n - ( u - l + 1 ) ] ; for ( int i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; sort ( b , b + n - ( u - l + 1 ) ) ; for ( int i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; }
int findMinSwaps ( int arr [ ] , int n ) { int noOfZeroes [ n ] ; memset ( noOfZeroes , 0 , sizeof ( noOfZeroes ) ) ; int i , count = 0 ; noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { noOfZeroes [ i ] = noOfZeroes [ i + 1 ] ; if ( arr [ i ] == 0 ) noOfZeroes [ i ] ++ ; } for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) count += noOfZeroes [ i ] ; } return count ; }
void printList ( struct Node * head ) { while ( head != NULL ) { cout << head -> data << " -> " ; head = head -> next ; } }
void sortlist ( int arr [ ] , int N , struct Node * head ) { unordered_map < int , int > hash ; struct Node * temp = head ; while ( temp ) { hash [ temp -> data ] ++ ; temp = temp -> next ; } temp = head ; for ( int i = 0 ; i < N ; i ++ ) { int frequency = hash [ arr [ i ] ] ; while ( frequency -- ) { temp -> data = arr [ i ] ; temp = temp -> next ; } } }
void printRepeating ( int arr [ ] , int size ) { set < int > s ( arr , arr + size ) ; for ( auto x : s ) cout << x << " " ; }
int min_noOf_operation ( int arr [ ] , int n , int k ) { int noOfSubtraction ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; }
int maxSum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; }
int countPairs ( int a [ ] , int n , int k ) { sort ( a , a + n ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n && a [ j ] - a [ i ] < k ) { res ++ ; j ++ ; } } return res ; }
void sortedMerge ( int a [ ] , int b [ ] , int res [ ] , int n , int m ) { sort ( a , a + n ) ; sort ( b , b + m ) ; int i = 0 , j = 0 , k = 0 ; while ( i < n && j < m ) { if ( a [ i ] <= b [ j ] ) { res [ k ] = a [ i ] ; i += 1 ; k += 1 ; } else { res [ k ] = b [ j ] ; j += 1 ; k += 1 ; } } while ( i < n ) { res [ k ] = a [ i ] ; i += 1 ; k += 1 ; } while ( j < m ) { res [ k ] = b [ j ] ; j += 1 ; k += 1 ; } }
ll findMaxPairs ( ll a [ ] , ll b [ ] , ll n , ll k ) { sort ( a , a + n ) ; sort ( b , b + n ) ; bool flag [ n ] ; memset ( flag , false , sizeof ( flag ) ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( abs ( a [ i ] - b [ j ] ) <= k && flag [ j ] == false ) { result ++ ; flag [ j ] = true ; break ; } } } return result ; }
ll findMaxPairs ( ll a [ ] , ll b [ ] , ll n , ll k ) { sort ( a , a + n ) ; sort ( b , b + n ) ; int result = 0 ; for ( int i = 0 , j = 0 ; i < n && j < n ; ) { if ( abs ( a [ i ] - b [ j ] ) <= k ) { result ++ ; i ++ ; j ++ ; } else if ( a [ i ] > b [ j ] ) j ++ ; else i ++ ; } return result ; }
int sumOfMinAbsDifferences ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int sum = 0 ; sum += abs ( arr [ 0 ] - arr [ 1 ] ) ; sum += abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) sum += min ( abs ( arr [ i ] - arr [ i - 1 ] ) , abs ( arr [ i ] - arr [ i + 1 ] ) ) ; return sum ; }
int findSmallestDifference ( int A [ ] , int B [ ] , int m , int n ) { sort ( A , A + m ) ; sort ( B , B + n ) ; int a = 0 , b = 0 ; int result = INT_MAX ; while ( a < m && b < n ) { if ( abs ( A [ a ] - B [ b ] ) < result ) result = abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; }
bool arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }
void findLarger ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = n - 1 ; i >= n / 2 ; i -- ) cout << arr [ i ] << " " ; }
int minSwapsToSort ( int arr [ ] , int n ) { pair < int , int > arrPos [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arrPos [ i ] . first = arr [ i ] ; arrPos [ i ] . second = i ; } sort ( arrPos , arrPos + n ) ; vector < bool > vis ( n , false ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] arrPos [ i ] . second == i ) continue ; int cycle_size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = 1 ; j = arrPos [ j ] . second ; cycle_size ++ ; } ans += ( cycle_size - 1 ) ; } return ans ; }
int minSwapToMakeArraySame ( int a [ ] , int b [ ] , int n ) { map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ b [ i ] ] = i ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = mp [ a [ i ] ] ; return minSwapsToSort ( b , n ) ; }
int singleelement ( int arr [ ] , int n ) { int low = 0 , high = n - 2 ; int mid ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( arr [ mid ] == arr [ mid ^ 1 ] ) { low = mid + 1 ; } else { high = mid - 1 ; } } return arr [ low ] ; }
int getMissingNo ( int a [ ] , int n ) { int n_elements_sum = n * ( n + 1 ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += a [ i ] ; return n_elements_sum - sum ; }
int countOccurrences ( int arr [ ] , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; }
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r < l ) return -1 ; int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; }
int countOccurrences ( int arr [ ] , int n , int x ) { int ind = binarySearch ( arr , 0 , n - 1 , x ) ; if ( ind == -1 ) return 0 ; int count = 1 ; int left = ind - 1 ; while ( left >= 0 && arr [ left ] == x ) count ++ , left -- ; int right = ind + 1 ; while ( right < n && arr [ right ] == x ) count ++ , right ++ ; return count ; }
void printClosest ( int arr [ ] , int n , int x ) { int res_l , res_r ; int l = 0 , r = n - 1 , diff = INT_MAX ; while ( r > l ) { if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } cout << " The closest pair is " << arr [ res_l ] << " and " << arr [ res_r ] ; }
int countOnes ( bool arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
int findMissingUtil ( int arr1 [ ] , int arr2 [ ] , int N ) { if ( N == 1 ) return arr1 [ 0 ] ; if ( arr1 [ 0 ] != arr2 [ 0 ] ) return arr1 [ 0 ] ; int lo = 0 , hi = N - 1 ; while ( lo < hi ) { int mid = ( lo + hi ) / 2 ; if ( arr1 [ mid ] == arr2 [ mid ] ) lo = mid ; else hi = mid ; if ( lo == hi - 1 ) break ; } return arr1 [ hi ] ; }
void printTwoElements ( int arr [ ] , int size ) { int i ; cout << " The repeating element is " ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) - 1 ] > 0 ) arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; else cout << abs ( arr [ i ] ) << "\n" ; } cout << "and the missing element is " ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) cout << ( i + 1 ) ; } }
void findFourElements ( int A [ ] , int n , int X ) { for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k + 1 ; l < n ; l ++ ) if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) cout << A [ i ] << ", " << A [ j ] << ", " << A [ k ] << ", " << A [ l ] ; } } } }
void findFourElements ( int arr [ ] , int n , int X ) { unordered_map < int , pair < int , int > > mp ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) mp [ arr [ i ] + arr [ j ] ] =  { i , j } ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( mp . find ( X - sum ) != mp . end ( ) ) { pair < int , int > p = mp [ X - sum ] ; if ( p . first != i && p . first != j && p . second != i && p . second != j ) { cout << arr [ i ] << ", " << arr [ j ] << ", " << arr [ p . first ] << ", " << arr [ p . second ] ; return ; } } } } }
int findMajority ( int arr [ ] , int n ) { return arr [ n / 2 ] ; }
void minAdjDifference ( int arr [ ] , int n ) { if ( n < 2 ) return ; int res = abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < n ; i ++ ) res = min ( res , abs ( arr [ i ] - arr [ i - 1 ] ) ) ; res = min ( res , abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; cout << "Min Difference = " << res ; }
int getMin ( int arr [ ] , int n ) { return * min_element ( arr , arr + n ) ; }
int getMax ( int arr [ ] , int n ) { return * max_element ( arr , arr + n ) ; }
int deleteElement ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) break ; if ( i < n ) { n = n - 1 ; for ( int j = i ; j < n ; j ++ ) arr [ j ] = arr [ j + 1 ] ; } return n ; }
int deleteElement ( int arr [ ] , int n , int x ) { if ( arr [ n - 1 ] == x ) return ( n - 1 ) ; int prev = arr [ n - 1 ] , i ; for ( i = n - 2 ; i >= 0 && arr [ i ] != x ; i -- ) { int curr = arr [ i ] ; arr [ i ] = prev ; prev = curr ; } if ( i < 0 ) return 0 ; arr [ i ] = prev ; return ( n - 1 ) ; }
int maxWater ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int left = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) left = max ( left , arr [ j ] ) ; int right = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) right = max ( right , arr [ j ] ) ; res = res + ( min ( left , right ) - arr [ i ] ) ; } return res ; }
int findWater ( int arr [ ] , int n ) { int result = 0 ; int left_max = 0 , right_max = 0 ; int lo = 0 , hi = n - 1 ; while ( lo <= hi ) { if ( arr [ lo ] < arr [ hi ] ) { if ( arr [ lo ] > left_max ) left_max = arr [ lo ] ; else result += left_max - arr [ lo ] ; lo ++ ; } else { if ( arr [ hi ] > right_max ) right_max = arr [ hi ] ; else result += right_max - arr [ hi ] ; hi -- ; } } return result ; }
int maxWater ( int arr [ ] , int n ) { int size = n - 1 ; int prev = arr [ 0 ] ; int prev_index = 0 ; int water = 0 ; int temp = 0 ; for ( int i = 1 ; i <= size ; i ++ ) { if ( arr [ i ] >= prev ) { prev = arr [ i ] ; prev_index = i ; temp = 0 ; } else { water += prev - arr [ i ] ; temp += prev - arr [ i ] ; } } if ( prev_index < size ) { water -= temp ; prev = arr [ size ] ; for ( int i = size ; i >= prev_index ; i -- ) { if ( arr [ i ] >= prev ) { prev = arr [ i ] ; } else { water += prev - arr [ i ] ; } } } return water ; }
int maxWater ( int arr [ ] , int n ) { int left = 0 ; int right = n - 1 ; int l_max = 0 ; int r_max = 0 ; int result = 0 ; while ( left <= right ) { if ( r_max <= l_max ) { result += max ( 0 , r_max - arr [ right ] ) ; r_max = max ( r_max , arr [ right ] ) ; right -= 1 ; } else { result += max ( 0 , l_max - arr [ left ] ) ; l_max = max ( l_max , arr [ left ] ) ; left += 1 ; } } return result ; }
int missingK ( int a [ ] , int k , int n ) { int difference = 0 , ans = 0 , count = k ; bool flag = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ; if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { difference += ( a [ i + 1 ] - a [ i ] ) - 1 ; if ( difference >= count ) { ans = a [ i ] + count ; flag = 1 ; break ; } else count -= difference ; } } if ( flag ) return ans ; else return -1 ; }
int leastFrequent ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int min_count = n + 1 , res = -1 , curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count < min_count ) { min_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count < min_count ) { min_count = curr_count ; res = arr [ n - 1 ] ; } return res ; }
int leastFrequent ( int arr [ ] , int n ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < n ; i ++ ) hash [ arr [ i ] ] ++ ; int min_count = n + 1 , res = -1 ; for ( auto i : hash ) { if ( min_count >= i . second ) { res = i . first ; min_count = i . second ; } } return res ; }
int maximumSum ( int a [ ] [ M ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) sort ( a [ i ] , a [ i ] + M ) ; int sum = a [ n - 1 ] [ M - 1 ] ; int prev = a [ n - 1 ] [ M - 1 ] ; int i , j ; for ( i = n - 2 ; i >= 0 ; i -- ) { for ( j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i ] [ j ] < prev ) { prev = a [ i ] [ j ] ; sum += prev ; break ; } } if ( j == -1 ) return 0 ; } return sum ; }
int maximumSum ( int a [ ] [ M ] , int n ) { int prev = * max_element ( & a [ n - 1 ] [ 0 ] , & a [ n - 1 ] [ M - 1 ] + 1 ) ; int sum = prev ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int max_smaller = INT_MIN ; for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i ] [ j ] < prev && a [ i ] [ j ] > max_smaller ) max_smaller = a [ i ] [ j ] ; } if ( max_smaller == INT_MIN ) return 0 ; prev = max_smaller ; sum += max_smaller ; } return sum ; }
int findValue ( int a [ ] , int n , int k ) { sort ( a , a + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == k ) k *= 2 ; } return k ; }
int findSmallest ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] ) break ; if ( j == n ) return a [ i ] ; } return -1 ; }
int findSmallest ( int a [ ] , int n ) { int smallest = * min_element ( a , a + n ) ; for ( int i = 1 ; i < n ; i ++ ) if ( a [ i ] % smallest ) return -1 ; return smallest ; }
ll CalculateMax ( ll arr [ ] , int n ) { sort ( arr , arr + n ) ; int min_sum = arr [ 0 ] + arr [ 1 ] ; int max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return abs ( max_sum - min_sum ) ; }
void printMinDiffPairs ( int arr [ ] , int n ) { if ( n <= 1 ) return ; sort ( arr , arr + n ) ; int minDiff = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) minDiff = min ( minDiff , arr [ i ] - arr [ i - 1 ] ) ; for ( int i = 1 ; i < n ; i ++ ) if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) cout << "(" << arr [ i - 1 ] << ", " << arr [ i ] << "), " ; }
int calculateDiff ( int i , int j , int arr [ ] ) { return abs ( arr [ i ] - arr [ j ] ) + abs ( i - j ) ; }
int extrema ( int a [ ] , int n ) { int count = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { count += ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) ; count += ( a [ i ] < a [ i - 1 ] && a [ i ] < a [ i + 1 ] ) ; } return count ; }
int getClosest ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; }
int sum ( int a [ ] , int n ) { int maxVal = a [ 0 ] , maxCount = 1 ; int secondMax = INT_MIN , secondMaxCount ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == maxVal ) maxCount ++ ; else if ( a [ i ] > maxVal ) { secondMax = maxVal ; secondMaxCount = maxCount ; maxVal = a [ i ] ; maxCount = 1 ; } else if ( a [ i ] == secondMax ) { secondMax = a [ i ] ; secondMaxCount ++ ; } else if ( a [ i ] > secondMax ) { secondMax = a [ i ] ; secondMaxCount = 1 ; } } if ( maxCount > 1 ) return maxCount * ( maxCount - 1 ) / 2 ; return secondMaxCount ; }
void printSmall ( int arr [ ] , int asize , int n ) { vector < int > copy_arr ( arr , arr + asize ) ; sort ( copy_arr . begin ( ) , copy_arr . begin ( ) + asize ) ; for ( int i = 0 ; i < asize ; ++ i ) if ( binary_search ( copy_arr . begin ( ) , copy_arr . begin ( ) + n , arr [ i ] ) ) cout << arr [ i ] << " " ; }
void printKMissing ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int i = 0 ; while ( i < n && arr [ i ] <= 0 ) i ++ ; int count = 0 , curr = 1 ; while ( count < k && i < n ) { if ( arr [ i ] != curr ) { cout << curr << " " ; count ++ ; } else i ++ ; curr ++ ; } while ( count < k ) { cout << curr << " " ; curr ++ ; count ++ ; } }
void printmissingk ( int arr [ ] , int n , int k ) { map < int , int > d ; for ( int i = 0 ; i < n ; i ++ ) d [ arr [ i ] ] = arr [ i ] ; int cnt = 1 ; int fl = 0 ; for ( int i = 0 ; i < ( n + k ) ; i ++ ) { if ( d . find ( cnt ) == d . end ( ) ) { fl += 1 ; cout << cnt << " " ; if ( fl == k ) break ; } cnt += 1 ; } }
bool checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; sort ( arr , arr + n ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
int minProductSubset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int max_neg = INT_MIN ; int min_pos = INT_MAX ; int count_neg = 0 , count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = max ( max_neg , a [ i ] ) ; } if ( a [ i ] > 0 ) min_pos = min ( min_pos , a [ i ] ) ; prod = prod * a [ i ] ; } if ( count_zero == n || ( count_neg == 0 && count_zero > 0 ) ) return 0 ; if ( count_neg == 0 ) return min_pos ; if ( ! ( count_neg & 1 ) && count_neg != 0 ) { prod = prod / max_neg ; } return prod ; }
int countPairs ( int a [ ] , int n ) { int mn = INT_MAX ; int mx = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { mn = min ( mn , a [ i ] ) ; mx = max ( mx , a [ i ] ) ; } int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == mn ) c1 ++ ; if ( a [ i ] == mx ) c2 ++ ; } if ( mn == mx ) return n * ( n - 1 ) / 2 ; else return c1 * c2 ; }
int findElement ( int a [ ] , int n , int b ) { sort ( a , a + n ) ; int max = a [ n - 1 ] ; while ( b < max ) { if ( binary_search ( a , a + n , b ) ) b *= 2 ; else return b ; } return b ; }
void printList ( struct Node * node ) { while ( node != NULL ) { cout << node -> data << " " ; node = node -> next ; } cout << endl ; }
void rearrangeOddEven ( Node * head ) { stack < Node * > odd ; stack < Node * > even ; int i = 1 ; while ( head != nullptr ) { if ( head -> data % 2 != 0 && i % 2 == 0 ) { odd . push ( head ) ; } else if ( head -> data % 2 == 0 && i % 2 != 0 ) { even . push ( head ) ; } head = head -> next ; i ++ ; } while ( ! odd . empty ( ) && ! even . empty ( ) ) { swap ( odd . top ( ) -> data , even . top ( ) -> data ) ; odd . pop ( ) ; even . pop ( ) ; } }
void printList ( Node * node ) { while ( node != NULL ) { cout << node -> data << " " ; node = node -> next ; } }
void display ( Node * head ) { Node * curr = head ; while ( curr != NULL ) { printf ( "%d " , curr -> data ) ; curr = curr -> next ; } }
int addWithCarry ( Node * head ) { if ( head == NULL ) return 1 ; int res = head -> data + addWithCarry ( head -> next ) ; head -> data = ( res ) % 10 ; return ( res ) / 10 ; }
void populateArbit ( Node * head ) { static Node * maxNode ; if ( head == NULL ) return ; if ( head -> next == NULL ) { maxNode = head ; return ; } populateArbit ( head -> next ) ; head -> arbit = maxNode ; if ( head -> data > maxNode -> data ) maxNode = head ; return ; }
void deleteLast ( struct Node * head , int x ) { struct Node * temp = head , * ptr = NULL ; while ( temp ) { if ( temp -> data == x ) ptr = temp ; temp = temp -> next ; } if ( ptr != NULL && ptr -> next == NULL ) { temp = head ; while ( temp -> next != ptr ) temp = temp -> next ; temp -> next = NULL ; } if ( ptr != NULL && ptr -> next != NULL ) { ptr -> data = ptr -> next -> data ; temp = ptr -> next ; ptr -> next = ptr -> next -> next ; free ( temp ) ; } }
int getLength ( Node * Node ) { int size = 0 ; while ( Node != NULL ) { Node = Node -> next ; size ++ ; } return size ; }
bool isPalindromeUtil ( Node * head , Node * loop_start ) { Node * ptr = head ; stack < int > s ; int count = 0 ; while ( ptr != loop_start count != 1 ) { s . push ( ptr -> data ) ; if ( ptr == loop_start ) count = 1 ; ptr = ptr -> next ; } ptr = head ; count = 0 ; while ( ptr != loop_start count != 1 ) { if ( ptr -> data == s . top ( ) ) s . pop ( ) ; else return false ; if ( ptr == loop_start ) count = 1 ; ptr = ptr -> next ; } return true ; }
bool isPalindrome ( Node * head ) { Node * loop_start = detectAndgetLoopstarting ( head ) ; return isPalindromeUtil ( head , loop_start ) ; }
int countCommon ( Node * a , Node * b ) { int count = 0 ; for ( ; a && b ; a = a -> next , b = b -> next ) if ( a -> data == b -> data ) ++ count ; else break ; return count ; }
int maxPalindrome ( Node * head ) { int result = 0 ; Node * prev = NULL , * curr = head ; while ( curr ) { Node * next = curr -> next ; curr -> next = prev ; result = max ( result , 2 * countCommon ( prev , next ) + 1 ) ; result = max ( result , 2 * countCommon ( curr , next ) ) ; prev = curr ; curr = next ; } return result ; }
void displayList ( struct Node * head ) { struct Node * temp = head ; while ( temp != NULL ) { cout << temp -> data << " " ; temp = temp -> next ; } }
int LinkedListLength ( Node * head ) { while ( head && head -> next ) { head = head -> next -> next ; } if ( ! head ) return 0 ; return 1 ; }
void push ( Node * * head , int info ) { Node * node = new Node ( ) ; node -> data = info ; node -> next = ( * head ) ; ( * head ) = node ; }
int sumOfLastN_NodesUtil ( struct Node * head , int n ) { if ( n <= 0 ) return 0 ; stack < int > st ; int sum = 0 ; while ( head != NULL ) { st . push ( head -> data ) ; head = head -> next ; } while ( n -- ) { sum += st . top ( ) ; st . pop ( ) ; } return sum ; }
void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; }
int sumOfLastN_NodesUtil ( struct Node * head , int n ) { if ( n <= 0 ) return 0 ; int sum = 0 , len = 0 ; struct Node * temp = head ; while ( temp != NULL ) { len ++ ; temp = temp -> next ; } int c = len - n ; temp = head ; while ( temp != NULL && c -- ) temp = temp -> next ; while ( temp != NULL ) { sum += temp -> data ; temp = temp -> next ; } return sum ; }
void printList ( Node * node ) { while ( node != NULL ) { printf ( "%d " , node -> data ) ; node = node -> next ; } }
void printList ( struct Node * node ) { while ( node != NULL ) { printf ( "%d " , node -> data ) ; node = node -> next ; } }
void printList ( struct Node * head ) { while ( head != NULL ) { cout << head -> data << " " ; head = head -> next ; } }
void printList ( Node * head ) { while ( head != NULL ) { cout << head -> data << " " ; head = head -> next ; } }
void insertAfterNthNode ( Node * head , int n , int x ) { if ( head == NULL ) return ; Node * newNode = getNode ( x ) ; Node * slow_ptr = head ; Node * fast_ptr = head ; for ( int i = 1 ; i <= n - 1 ; i ++ ) fast_ptr = fast_ptr -> next ; while ( fast_ptr -> next != NULL ) { slow_ptr = slow_ptr -> next ; fast_ptr = fast_ptr -> next ; } newNode -> next = slow_ptr -> next ; slow_ptr -> next = newNode ; }
void printList ( Node * head ) { while ( head != NULL ) { cout << head -> data << " " ; head = head -> next ; } }
void printList ( Node * head ) { Node * temp = head ; while ( temp -> next != head ) { cout << temp -> data << " " ; temp = temp -> next ; } cout << temp -> data << " " ; }
void printList ( Node * head ) { while ( head -> next != nullptr ) { cout << head -> data << " <--> " ; head = head -> next ; } cout << head -> data << endl ; }
void printList ( struct Node * head ) { while ( head != NULL ) { cout << head -> data << " " ; head = head -> next ; } }
bool isPalindrome ( struct Node * left ) { if ( left == NULL ) return true ; struct Node * right = left ; while ( right -> next != NULL ) right = right -> next ; while ( left != right ) { if ( left -> data != right -> data ) return false ; left = left -> next ; right = right -> prev ; } return true ; }
void printKDistant ( node * root , int k ) { if ( root == NULL k < 0 ) return ; if ( k == 0 ) { cout << root -> data << " " ; return ; } printKDistant ( root -> left , k - 1 ) ; printKDistant ( root -> right , k - 1 ) ; }
void kDistantFromLeafUtil ( Node * node , int path [ ] , bool visited [ ] , int pathLen , int k ) { if ( node == NULL ) return ; path [ pathLen ] = node -> key ; visited [ pathLen ] = false ; pathLen ++ ; if ( node -> left == NULL && node -> right == NULL && pathLen - k - 1 >= 0 && visited [ pathLen - k - 1 ] == false ) { cout << path [ pathLen - k - 1 ] << " " ; visited [ pathLen - k - 1 ] = true ; return ; } kDistantFromLeafUtil ( node -> left , path , visited , pathLen , k ) ; kDistantFromLeafUtil ( node -> right , path , visited , pathLen , k ) ; }
void printKDistantfromLeaf ( Node * node , int k ) { int path [ MAX_HEIGHT ] ; bool visited [ MAX_HEIGHT ] = { false } ; kDistantFromLeafUtil ( node , path , visited , 0 , k ) ; }
int rotate ( int arr [ ] , int N , int X ) { long long int nextPower = 1 ; while ( nextPower <= N ) nextPower *= 2 ; if ( X == 1 ) return nextPower - N ; long long int prevPower = nextPower / 2 ; return 2 * ( N - prevPower ) + 1 ; }
void performSwap ( vector < vector < int > > & mat , int i , int j ) { int N = mat . size ( ) ; int ei = N - 1 - i ; int ej = N - 1 - j ; int temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ ej ] [ i ] ; mat [ ej ] [ i ] = mat [ ei ] [ ej ] ; mat [ ei ] [ ej ] = mat [ j ] [ ei ] ; mat [ j ] [ ei ] = temp ; }
void rotate ( vector < vector < int > > & mat , int N , int K ) { K = K % 4 ; while ( K -- ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { for ( int j = i ; j < N - i - 1 ; j ++ ) { if ( i != j && ( i + j ) != N - 1 ) { performSwap ( mat , i , j ) ; } } } } print ( mat ) ; }
void findMaximumZeros ( string str , int n ) { int c0 = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( str [ i ] == '0' ) c0 ++ ; } if ( c0 == n ) { cout << n ; return ; } string s = str + str ; int mx = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int cs = 0 ; int ce = 0 ; for ( int j = i ; j < i + n ; ++ j ) { if ( s [ j ] == '0' ) cs ++ ; else break ; } for ( int j = i + n - 1 ; j >= i ; -- j ) { if ( s [ j ] == '0' ) ce ++ ; else break ; } int val = cs + ce ; mx = max ( val , mx ) ; } cout << mx ; }
void findMaximumZeros ( string str , int n ) { int c0 = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( str [ i ] == '0' ) c0 ++ ; } if ( c0 == n ) { cout << n ; return ; } int mx = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) cnt ++ ; else { mx = max ( mx , cnt ) ; cnt = 0 ; } } mx = max ( mx , cnt ) ; int start = 0 , end = n - 1 ; cnt = 0 ; while ( str [ start ] != '1' && start < n ) { cnt ++ ; start ++ ; } while ( str [ end ] != '1' && end >= 0 ) { cnt ++ ; end -- ; } mx = max ( mx , cnt ) ; cout << mx ; }
unsigned int getLeafCount ( struct Node * node ) { if ( ! node ) return 0 ; queue < Node * > q ; int count = 0 ; q . push ( node ) ; while ( ! q . empty ( ) ) { struct Node * temp = q . front ( ) ; q . pop ( ) ; if ( temp -> left != NULL ) q . push ( temp -> left ) ; if ( temp -> right != NULL ) q . push ( temp -> right ) ; if ( temp -> left == NULL && temp -> right == NULL ) count ++ ; } return count ; }
void rotateArray ( vector < int > & arr , int N ) { vector < int > v = arr ; sort ( v . begin ( ) , v . end ( ) ) ; for ( int i = 1 ; i <= N ; ++ i ) { rotate ( arr . begin ( ) , arr . begin ( ) + 1 , arr . end ( ) ) ; if ( arr == v ) { cout << "YES" << endl ; return ; } } cout << "NO" << endl ; }
int numberOfDigit ( int N ) { int digit = 0 ; while ( N > 0 ) { digit ++ ; N /= 10 ; } return digit ; }
void rotateNumberByK ( int N , int K ) { int X = numberOfDigit ( N ) ; K = ( ( K % X ) + X ) % X ; int left_no = N / ( int ) ( pow ( 10 , X - K ) ) ; N = N % ( int ) ( pow ( 10 , X - K ) ) ; int left_digit = numberOfDigit ( left_no ) ; N = ( N * ( int ) ( pow ( 10 , left_digit ) ) ) + left_no ; cout << N ; }
void minMovesToSort ( int arr [ ] , int N ) { int count = 0 ; int index ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] < arr [ i + 1 ] ) { count ++ ; index = i ; } } if ( count == 0 ) { cout << "0" ; } else if ( count == N - 1 ) { cout << N - 1 ; } else if ( count == 1 && arr [ 0 ] <= arr [ N - 1 ] ) { cout << index + 1 ; } else { cout << "-1" ; } }
int findMaximumDiagonalSumOMatrixf ( int A [ ] [ N ] ) { int maxDiagonalSum = INT_MIN ; for ( int i = 0 ; i < N ; i ++ ) { int curr = 0 ; for ( int j = 0 ; j < N ; j ++ ) { curr += A [ j ] [ ( i + j ) % N ] ; } maxDiagonalSum = max ( maxDiagonalSum , curr ) ; } for ( int i = 0 ; i < N ; i ++ ) { int curr = 0 ; for ( int j = 0 ; j < N ; j ++ ) { curr += A [ ( i + j ) % N ] [ j ] ; } maxDiagonalSum = max ( maxDiagonalSum , curr ) ; } return maxDiagonalSum ; }
int countLeaves ( struct node * node ) { if ( node == NULL ) { return 0 ; } if ( node -> left == NULL && node -> right == NULL ) { return 1 ; } return countLeaves ( node -> left ) + countLeaves ( node -> right ) ; }
int MaxSum ( vector < int > arr , int n , int k ) { int i , max_sum = 0 , sum = 0 ; for ( i = 0 ; i < k ; i ++ ) { sum += arr [ i ] ; } max_sum = sum ; while ( i < n ) { sum = sum - arr [ i - k ] + arr [ i ] ; if ( max_sum < sum ) { max_sum = sum ; } i ++ ; } return max_sum ; }
int gcd ( int n1 , int n2 ) { if ( n2 == 0 ) { return n1 ; } else { return gcd ( n2 , n1 % n2 ) ; } }
vector < int > RotateArr ( vector < int > arr , int n , int d ) { int i = 0 , j = 0 ; d = d % n ; int no_of_sets = gcd ( d , n ) ; for ( i = 0 ; i < no_of_sets ; i ++ ) { int temp = arr [ i ] ; j = i ; while ( true ) { int k = j + d ; if ( k >= n ) k = k - n ; if ( k == i ) break ; arr [ j ] = arr [ k ] ; j = k ; } arr [ j ] = temp ; } return arr ; }
int getMinimumRemoval ( string str ) { int n = str . length ( ) ; int ans = n ; if ( n % 2 == 0 ) { vector < int > freqEven ( 128 ) ; vector < int > freqOdd ( 128 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { freqEven [ str [ i ] ] ++ ; } else { freqOdd [ str [ i ] ] ++ ; } } int evenMax = 0 , oddMax = 0 ; for ( char chr = 'a' ; chr <= 'z' ; chr ++ ) { evenMax = max ( evenMax , freqEven [ chr ] ) ; oddMax = max ( oddMax , freqOdd [ chr ] ) ; } ans = ans - evenMax - oddMax ; } else { vector < int > freq ( 128 ) ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str [ i ] ] ++ ; } int strMax = 0 ; for ( char chr = 'a' ; chr <= 'z' ; chr ++ ) { strMax = max ( strMax , freq [ chr ] ) ; } ans = ans - strMax ; } return ans ; }
int findAltSubSeq ( string s ) { int n = s . size ( ) , ans = INT_MIN ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { int cur = 0 , f = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( f == 0 and s [ k ] - '0' == i ) { f = 1 ; cur ++ ; } else if ( f == 1 and s [ k ] - '0' == j ) { f = 0 ; cur ++ ; } } if ( i != j and cur % 2 == 1 ) cur -- ; ans = max ( cur , ans ) ; } } return ans ; }
int getFirstElement ( int a [ ] , int N , int K , int M ) { K %= N ; int index ; if ( K >= M ) index = ( N - K ) + ( M - 1 ) ; else index = ( M - K - 1 ) ; int result = a [ index ] ; return result ; }
int getFirstElement ( int a [ ] , int N , int K , int M ) { K %= N ; int index = ( K + M - 1 ) % N ; int result = a [ index ] ; return result ; }
void left_rotate ( int arr [ ] ) { int last = arr [ 1 ] ; for ( int i = 3 ; i < 6 ; i = i + 2 ) { arr [ i - 2 ] = arr [ i ] ; } arr [ 6 - 1 ] = last ; }
void right_rotate ( int arr [ ] ) { int start = arr [ 6 - 2 ] ; for ( int i = 6 - 4 ; i >= 0 ; i = i - 2 ) { arr [ i + 2 ] = arr [ i ] ; } arr [ 0 ] = start ; }
void rotate ( int arr [ ] ) { left_rotate ( arr ) ; right_rotate ( arr ) ; for ( int i = 0 ; i < 6 ; i ++ ) { cout << ( arr [ i ] ) << " " ; } }
int maximumMatchingPairs ( int perm1 [ ] , int perm2 [ ] , int n ) { int left [ n ] , right [ n ] ; map < int , int > mp1 , mp2 ; for ( int i = 0 ; i < n ; i ++ ) { mp1 [ perm1 [ i ] ] = i ; } for ( int j = 0 ; j < n ; j ++ ) { mp2 [ perm2 [ j ] ] = j ; } for ( int i = 0 ; i < n ; i ++ ) { int idx2 = mp2 [ perm1 [ i ] ] ; int idx1 = i ; if ( idx1 == idx2 ) { left [ i ] = 0 ; right [ i ] = 0 ; } else if ( idx1 < idx2 ) { left [ i ] = ( n - ( idx2 - idx1 ) ) ; right [ i ] = ( idx2 - idx1 ) ; } else { left [ i ] = ( idx1 - idx2 ) ; right [ i ] = ( n - ( idx1 - idx2 ) ) ; } } map < int , int > freq1 , freq2 ; for ( int i = 0 ; i < n ; i ++ ) { freq1 [ left [ i ] ] ++ ; freq2 [ right [ i ] ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = max ( ans , max ( freq1 [ left [ i ] ] , freq2 [ right [ i ] ] ) ) ; } return ans ; }
int countRotation ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { return i ; } } return 0 ; }
int query ( int node , int l , int r , int start , int end , int a [ ] ) { if ( l > end or r < start ) return 0 ; if ( start <= l and r <= end ) return seg [ node ] ; int mid = ( l + r ) / 2 ; return ( ( query ( 2 * node , l , mid , start , end , a ) ) | ( query ( 2 * node + 1 , mid + 1 , r , start , end , a ) ) ) ; }
void isConversionPossible ( string s1 , string s2 , int x ) { int diff , n ; n = s1 . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) continue ; diff = ( int ( s2 [ i ] - s1 [ i ] ) + 26 ) % 26 ; if ( diff > x ) { cout << "NO" << endl ; return ; } } cout << "YES" << endl ; }
int countRotation ( int n ) { int count = 0 ; do { int digit = n % 10 ; if ( digit == 0 ) count ++ ; n = n / 10 ; } while ( n != 0 ) ; return count ; }
void printList ( Node * node ) { while ( node != NULL ) { cout << node -> data << " -> " ; node = node -> next ; } cout << "NULL" ; }
bool isPossible ( int a [ ] , int n ) { if ( n <= 2 ) return true ; int flag = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( ! ( a [ i ] > a [ i + 1 ] and a [ i + 1 ] > a [ i + 2 ] ) ) { flag = 1 ; break ; } } if ( flag == 0 ) return true ; flag = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( ! ( a [ i ] < a [ i + 1 ] and a [ i + 1 ] < a [ i + 2 ] ) ) { flag = 1 ; break ; } } if ( flag == 0 ) return true ; int val1 = INT_MAX , mini = -1 , val2 = INT_MIN , maxi ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < val1 ) { mini = i ; val1 = a [ i ] ; } if ( a [ i ] > val2 ) { maxi = i ; val2 = a [ i ] ; } } flag = 1 ; for ( int i = 0 ; i < maxi ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 and maxi + 1 == mini ) { flag = 1 ; for ( int i = mini ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) return true ; } flag = 1 ; for ( int i = 0 ; i < mini ; i ++ ) { if ( a [ i ] < a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 and maxi - 1 == mini ) { flag = 1 ; for ( int i = maxi ; i < n - 1 ; i ++ ) { if ( a [ i ] < a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) return true ; } return false ; }
int cntRotations ( string s , int n ) { string str = s + s ; int pre [ 2 * n ] = { 0 } ; for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( i != 0 ) pre [ i ] += pre [ i - 1 ] ; if ( str [ i ] == 'a' str [ i ] == 'e' str [ i ] == 'i' str [ i ] == 'o' str [ i ] == 'u' ) { pre [ i ] ++ ; } } int ans = 0 ; for ( int i = n - 1 ; i < 2 * n - 1 ; i ++ ) { int r = i , l = i - n ; int x1 = pre [ r ] ; if ( l >= 0 ) x1 -= pre [ l ] ; r = i - n / 2 ; int left = pre [ r ] ; if ( l >= 0 ) left -= pre [ l ] ; int right = x1 - left ; if ( left > right ) { ans ++ ; } } return ans ; }
int cntRotations ( char s [ ] , int n ) { int lh = 0 , rh = 0 , i , ans = 0 ; for ( i = 0 ; i < n / 2 ; ++ i ) if ( s [ i ] == 'a' s [ i ] == 'e' s [ i ] == 'i' s [ i ] == 'o' s [ i ] == 'u' ) { lh ++ ; } for ( i = n / 2 ; i < n ; ++ i ) if ( s [ i ] == 'a' s [ i ] == 'e' s [ i ] == 'i' s [ i ] == 'o' s [ i ] == 'u' ) { rh ++ ; } if ( lh > rh ) ans ++ ; for ( i = 1 ; i < n ; ++ i ) { if ( s [ i - 1 ] == 'a' s [ i - 1 ] == 'e' s [ i - 1 ] == 'i' s [ i - 1 ] == 'o' s [ i - 1 ] == 'u' ) { rh ++ ; lh -- ; } if ( s [ ( i - 1 + n / 2 ) % n ] == 'a' || s [ ( i - 1 + n / 2 ) % n ] == 'e' || s [ ( i - 1 + n / 2 ) % n ] == 'i' || s [ ( i - 1 + n / 2 ) % n ] == 'o' || s [ ( i - 1 + n / 2 ) % n ] == 'u' ) { rh -- ; lh ++ ; } if ( lh > rh ) ans ++ ; } return ans ; }
void cal ( int num ) { int digits = numberOfDigits ( num ) ; int powTen = pow ( 10 , digits - 1 ) ; for ( int i = 0 ; i < digits - 1 ; i ++ ) { int firstDigit = num / powTen ; int left = ( ( num * 10 ) + firstDigit ) - ( firstDigit * powTen * 10 ) ; cout << left << " " ; num = left ; } }
void CheckKCycles ( int n , string s ) { bool ff = true ; int x = 0 ; for ( int i = 1 ; i < n ; i ++ ) { x = ( s . substr ( i ) + s . substr ( 0 , i ) ) . length ( ) ; if ( x >= s . length ( ) ) { continue ; } ff = false ; break ; } if ( ff ) { cout << ( "Yes" ) ; } else { cout << ( "No" ) ; } }
void populateNext ( node * p ) { static node * next = NULL ; if ( p ) { populateNext ( p -> right ) ; p -> next = next ; next = p ; populateNext ( p -> left ) ; } }
void occurredOnce ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; if ( arr [ 0 ] != arr [ 1 ] ) cout << arr [ 0 ] << " " ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i - 1 ] ) cout << arr [ i ] << " " ; if ( arr [ n - 2 ] != arr [ n - 1 ] ) cout << arr [ n - 1 ] << " " ; }
void occurredOnce ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; for ( auto it = mp . begin ( ) ; it != mp . end ( ) ; it ++ ) if ( it -> second == 1 ) cout << it -> first << " " ; }
void occurredOnce ( int arr [ ] , int n ) { int i = 1 , len = n ; if ( arr [ 0 ] == arr [ len - 1 ] ) { i = 2 ; len -- ; } for ( ; i < n ; i ++ ) if ( arr [ i ] == arr [ i - 1 ] ) i ++ ; else cout << arr [ i - 1 ] << " " ; if ( arr [ n - 1 ] != arr [ 0 ] && arr [ n - 1 ] != arr [ n - 2 ] ) cout << arr [ n - 1 ] ; }
void rvereseArray ( int arr [ ] , int start , int end ) { while ( start < end ) { int temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; start ++ ; end -- ; } }
void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " " ; }
void splitArr ( int arr [ ] , int k , int n ) { rvereseArray ( arr , 0 , n - 1 ) ; rvereseArray ( arr , 0 , n - k - 1 ) ; rvereseArray ( arr , n - k , n - 1 ) ; }
int countRotationsDivBy8 ( string n ) { int len = n . length ( ) ; int count = 0 ; if ( len == 1 ) { int oneDigit = n [ 0 ] - '0' ; if ( oneDigit % 8 == 0 ) return 1 ; return 0 ; } if ( len == 2 ) { int first = ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) ; int second = ( n [ 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) ; if ( first % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; return count ; } int threeDigit ; for ( int i = 0 ; i < ( len - 2 ) ; i ++ ) { threeDigit = ( n [ i ] - '0' ) * 100 + ( n [ i + 1 ] - '0' ) * 10 + ( n [ i + 2 ] - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; } threeDigit = ( n [ len - 1 ] - '0' ) * 100 + ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; threeDigit = ( n [ len - 2 ] - '0' ) * 100 + ( n [ len - 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; return count ; }
void restoreSortedArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { reverse ( arr , arr + i + 1 ) ; reverse ( arr + i + 1 , arr + n ) ; reverse ( arr , arr + n ) ; } } }
int findStartIndexOfArray ( int arr [ ] , int low , int high ) { if ( low > high ) { return -1 ; } if ( low == high ) { return low ; } int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] ) return mid + 1 ; if ( arr [ mid - 1 ] > arr [ mid ] ) return mid ; if ( arr [ low ] > arr [ mid ] ) return findStartIndexOfArray ( arr , low , mid - 1 ) ; else return findStartIndexOfArray ( arr , mid + 1 , high ) ; }
void restoreSortedArray ( int arr [ ] , int n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) return ; int start = findStartIndexOfArray ( arr , 0 , n - 1 ) ; reverse ( arr , arr + start ) ; reverse ( arr + start , arr + n ) ; reverse ( arr , arr + n ) ; }
void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " " ; }
void printList ( Node * node ) { while ( node != NULL ) { cout << node -> data << " " ; node = node -> next ; } }
bool isRotation ( unsigned int x , unsigned int y ) { unsigned long long int x64 = x | ( ( unsigned long long int ) x << 32 ) ; while ( x64 >= y ) { if ( unsigned ( x64 ) = = y ) return true ; x64 >>= 1 ; } return false ; }
int countRotations ( string n ) { int len = n . length ( ) ; if ( len == 1 ) { int oneDigit = n . at ( 0 ) - '0' ; if ( oneDigit % 4 == 0 ) return 1 ; return 0 ; } int twoDigit , count = 0 ; for ( int i = 0 ; i < ( len - 1 ) ; i ++ ) { twoDigit = ( n . at ( i ) - '0' ) * 10 + ( n . at ( i + 1 ) - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; } twoDigit = ( n . at ( len - 1 ) - '0' ) * 10 + ( n . at ( 0 ) - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; return count ; }
bool isRotated ( string str1 , string str2 ) { if ( str1 . length ( ) != str2 . length ( ) ) return false ; if ( str1 . length ( ) < 2 ) { return str1 . compare ( str2 ) == 0 ; } string clock_rot = "" ; string anticlock_rot = "" ; int len = str2 . length ( ) ; anticlock_rot = anticlock_rot + str2 . substr ( len - 2 , 2 ) + str2 . substr ( 0 , len - 2 ) ; clock_rot = clock_rot + str2 . substr ( 2 ) + str2 . substr ( 0 , 2 ) ; return ( str1 . compare ( clock_rot ) == 0 || str1 . compare ( anticlock_rot ) == 0 ) ; }
void printList ( struct Node * head ) { struct Node * temp = head ; if ( head != NULL ) { do { printf ( "%d " , temp -> data ) ; temp = temp -> next ; } while ( temp != head ) ; } }
void deleteNode ( Node * head_ref , Node * del ) { struct Node * temp = head_ref ; if ( head_ref == del ) head_ref = del -> next ; while ( temp -> next != del ) { temp = temp -> next ; } temp -> next = del -> next ; free ( del ) ; return ; }
int largestElement ( struct Node * head_ref ) { struct Node * current ; current = head_ref ; int maxEle = INT_MIN ; do { if ( current -> data > maxEle ) { maxEle = current -> data ; } current = current -> next ; } while ( current != head_ref ) ; return maxEle ; }
void deleteFibonacciNodes ( Node * head ) { int maxEle = largestElement ( head ) ; set < int > hash ; createHash ( hash , maxEle ) ; struct Node * ptr = head ; struct Node * next ; do { if ( hash . find ( ptr -> data ) != hash . end ( ) ) deleteNode ( head , ptr ) ; next = ptr -> next ; ptr = next ; } while ( ptr != head ) ; }
void printList ( struct Node * head ) { struct Node * temp = head ; if ( head != NULL ) { do { printf ( "%d " , temp -> data ) ; temp = temp -> next ; } while ( temp != head ) ; } }
int sumOfList ( struct Node * head ) { struct Node * temp = head ; int sum = 0 ; if ( head != NULL ) { do { temp = temp -> next ; sum += temp -> data ; } while ( temp != head ) ; } return sum ; }
int searchList ( struct Node * start , int search ) { struct Node * temp = start ; int count = 0 , flag = 0 , value ; if ( temp == NULL ) return -1 ; else { while ( temp -> next != start ) { count ++ ; if ( temp -> data == search ) { flag = 1 ; count -- ; break ; } temp = temp -> next ; } if ( temp -> data == search ) { count ++ ; flag = 1 ; } if ( flag == 1 ) cout << "\n" << search << " found at location " << count << endl ; else cout << "\n" << search << " not found" << endl ; } }
int countList ( struct node * start ) { struct node * temp = start ; int count = 0 ; while ( temp -> next != start ) { temp = temp -> next ; count ++ ; } count ++ ; return count ; }
void display ( Node * head ) { if ( ! head ) return ; Node * temp = head ; cout << "Forward direction: " ; while ( temp -> next != head ) { cout << temp -> data << " " ; temp = temp -> next ; } cout << temp -> data ; Node * last = head -> prev ; temp = last ; cout << "Backwarddirection:"  while ( temp -> prev != last ) { cout << temp -> data << " " ; temp = temp -> prev ; } cout << temp -> data ; }
int displayList ( struct node * temp ) { struct node * t = temp ; if ( temp == NULL ) return 0 ; else { cout << "The list is: " ; while ( temp -> next != t ) { cout << temp -> data << " " ; temp = temp -> next ; } cout << temp -> data ; return 1 ; } }
int filter ( int x , int y , int z ) { if ( x != -1 && y != -1 ) { return z ; } return x == -1 ? y : x ; }
int samePathUtil ( int mtrx [ ] [ 7 ] , int vrtx , int v1 , int v2 , int i ) { int ans = -1 ; if ( i == v1 i == v2 ) return i ; for ( int j = 0 ; j < vrtx ; j ++ ) { if ( mtrx [ i ] [ j ] == 1 ) { ans = filter ( ans , samePathUtil ( mtrx , vrtx , v1 , v2 , j ) , i ) ; } } return ans ; }
bool isVertexAtSamePath ( int mtrx [ ] [ 7 ] , int vrtx , int v1 , int v2 , int i ) { int lca = samePathUtil ( mtrx , vrtx , v1 - 1 , v2 - 1 , i ) ; if ( lca == v1 - 1 lca == v2 - 1 ) return true ; return false ; }
void dfs ( int node , int parent , int h , int cost ) { lca [ node ] [ 0 ] = parent ; level [ node ] = h ; if ( parent != -1 ) { dist [ node ] [ 0 ] = cost ; } for ( int i = 1 ; i < log ; i ++ ) { if ( lca [ node ] [ i - 1 ] != -1 ) { lca [ node ] [ i ] = lca [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ; dist [ node ] [ i ] = dist [ node ] [ i - 1 ] + dist [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ; } } for ( auto i : graph [ node ] ) { if ( i . first == parent ) continue ; dfs ( i . first , node , h + 1 , i . second ) ; } }
void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
void dfs ( int node , int parent , int h ) { par [ node ] = parent ; level [ node ] = h ; for ( int child : graph [ node ] ) { if ( child == parent ) continue ; dfs ( child , node , h + 1 ) ; } }
int findPrimeOnPath ( int u , int v ) { int count = 0 ; if ( level [ u ] > level [ v ] ) swap ( u , v ) ; int d = level [ v ] - level [ u ] ; while ( d -- ) { if ( prime [ weight [ v ] ] ) count ++ ; v = par [ v ] ; } if ( v == u ) { if ( prime [ weight [ v ] ] ) count ++ ; return count ; } while ( v != u ) { if ( prime [ weight [ v ] ] ) count ++ ; if ( prime [ weight [ u ] ] ) count ++ ; u = par [ u ] ; v = par [ v ] ; } if ( prime [ weight [ v ] ] ) count ++ ; return count ; }
void addEdge ( int u , int v ) { graph [ u ] . push_back ( v ) ; graph [ v ] . push_back ( u ) ; }
int sumOddNodes ( Node * root , int n1 , int n2 ) { vector < int > path1 ; vector < int > path2 ; getPath ( root , path1 , n1 ) ; getPath ( root , path2 , n2 ) ; int intersection = -1 ; int i = 0 , j = 0 ; while ( i != path1 . size ( ) || j != path2 . size ( ) ) { if ( i == j && path1 [ i ] == path2 [ j ] ) { i ++ ; j ++ ; } else { intersection = j - 1 ; break ; } } int sum = 0 ; for ( int i = path1 . size ( ) - 1 ; i > intersection ; i -- ) if ( path1 [ i ] % 2 ) sum += path1 [ i ] ; for ( int i = intersection ; i < path2 . size ( ) ; i ++ ) if ( path2 [ i ] % 2 ) sum += path2 [ i ] ; return sum ; }
int findLCA ( int n1 , int n2 , int parent [ ] ) { vector < bool > visited ( MAX , false ) ; visited [ n1 ] = true ; while ( parent [ n1 ] != -1 ) { visited [ n1 ] = true ; n1 = parent [ n1 ] ; } visited [ n1 ] = true ; while ( ! visited [ n2 ] ) n2 = parent [ n2 ] ; return n2 ; }
void insertAdj ( int parent [ ] , int i , int j ) { parent [ i ] = j ; }
void addEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; }
void dfs ( int cur , int prev ) { parent [ cur ] = prev ; depth [ cur ] = depth [ prev ] + 1 ; for ( int i = 0 ; i < adj [ cur ] . size ( ) ; i ++ ) if ( adj [ cur ] [ i ] != prev ) dfs ( adj [ cur ] [ i ] , cur ) ; }
void preprocess ( ) { depth [ 0 ] = -1 ; dfs ( 1 , 0 ) ; }
void makeSet ( struct subset subsets [ ] , int i ) { if ( i < 1 i > V ) return ; subsets [ i ] . color = WHITE  ; subsets [ i ] . parent = i ; subsets [ i ] . rank = 0 ; return ; }
int findSet ( struct subset subsets [ ] , int i ) { if ( subsets [ i ] . parent != i ) subsets [ i ] . parent = findSet ( subsets , subsets [ i ] . parent ) ; return subsets [ i ] . parent ; }
void unionSet ( struct subset subsets [ ] , int x , int y ) { int xroot = findSet ( subsets , x ) ; int yroot = findSet ( subsets , y ) ; if ( subsets [ xroot ] . rank < subsets [ yroot ] . rank ) subsets [ xroot ] . parent = yroot ; else if ( subsets [ xroot ] . rank > subsets [ yroot ] . rank ) subsets [ yroot ] . parent = xroot ; else { subsets [ yroot ] . parent = xroot ; ( subsets [ xroot ] . rank ) ++ ; } }
bool findPair ( int a [ ] , int n , int z ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( i != j && a [ i ] + a [ j ] == z ) return true ; return false ; }
bool linearSearch ( int a [ ] , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == key ) return true ; } return false ; }
int maximumSum ( int arr [ ] , int N ) { int Sum = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) Sum += ( arr [ i ] - arr [ i - 1 ] ) ; } return Sum ; }
void stoogesort ( int arr [ ] , int l , int h ) { if ( l >= h ) return ; if ( arr [ l ] > arr [ h ] ) swap ( arr [ l ] , arr [ h ] ) ; if ( h - l + 1 > 2 ) { int t = ( h - l + 1 ) / 3 ; stoogesort ( arr , l , h - t ) ; stoogesort ( arr , l + t , h ) ; stoogesort ( arr , l , h - t ) ; } }
void findWinner ( int n , int m ) { int X = 0 ; int Y = 0 ; if ( n >= m ) { X = n - 1 ; Y = m ; } else { X = m - 1 ; Y = n ; } if ( X > Y ) cout << "X" ; else if ( Y > X ) cout << "Y" ; else cout << "-1" ; }
void checkPascaltriangle ( int N ) { double x = ( sqrt ( 8 * N + 1 ) - 1 ) / 2 ; if ( ceil ( x ) - x == 0 ) cout << "Yes" ; else cout << "No" ; }
void countSubarrays ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( ( j - i ) % 2 == 0 ) sum += arr [ j ] ; else sum -= arr [ j ] ; if ( sum == 0 ) count ++ ; } } cout << " " << count ; }
void findCountRooks ( int row [ ] , int col [ ] , int n , int k ) { int res = n - k ; cout << res << "\n" ; int ri = 0 , ci = 0 ; while ( res -- > 0 ) { while ( ri < k && row [ ri ] == 1 ) { ri ++ ; } while ( ci < k && col [ ci ] == 1 ) { ci ++ ; } cout << ( ri + 1 ) << " " << ( ci + 1 ) << "\n" ; ri ++ ; ci ++ ; } }
bool checkIfDivisible ( string str , long long int num ) { long long int powerOf2 = log2 ( num ) ; if ( str . length ( ) < powerOf2 ) return false ; if ( powerOf2 == 0 ) return true ; long long int i , number = 0 ; int len = str . length ( ) ; for ( i = len - powerOf2 ; i < len ; i ++ ) { number += ( str [ i ] - '0' ) * pow ( 10 , powerOf2 - 1 ) ; powerOf2 -- ; } if ( number % num ) return false ; else return true ; }
void countNo ( int A , int N , int L , int R ) { int ans = L - 1 + N + floor ( ( N - 1 ) / ( A - 1 ) ) ; if ( ans % A == 0 ) { ans = ans + 1 ; } cout << ans << endl ; }
bool check_order ( vector < int > arr ) { int cnt = 0 ; for ( int i = 0 ; i < arr . size ( ) - 1 ; i ++ ) { if ( abs ( arr [ i + 1 ] - arr [ i ] ) > 1 ) cnt ++ ; } if ( abs ( arr [ 0 ] - arr [ arr . size ( ) - 1 ] ) > 1 ) cnt ++ ; if ( cnt > 1 ) return false ; return true ; }
int getM ( int n ) { if ( n == 1 ) return -1 ; else return n - 2 ; }
int maxProfit ( int prices [ ] , int n ) { if ( n <= 1 ) return 0 ; int rest [ n ] = { 0 } ; int hold [ n ] = { 0 } ; int sold [ n ] = { 0 } ; rest [ 0 ] = 0 ; hold [ 0 ] = - prices [ 0 ] ; sold [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { rest [ i ] = max ( rest [ i - 1 ] , sold [ i - 1 ] ) ; hold [ i ] = max ( hold [ i - 1 ] , rest [ i - 1 ] - prices [ i ] ) ; sold [ i ] = hold [ i - 1 ] + prices [ i ] ; } return max ( rest [ n - 1 ] , sold [ n - 1 ] ) ; }
int findSubarrays ( int arr [ ] , int N , int K ) { return N - K + 1 ; }
ll findCount ( string s ) { ll freq [ 26 ] ; ll dp [ 26 ] [ 26 ] ; memset ( freq , 0 , sizeof freq ) ; memset ( dp , 0 , sizeof dp ) ; for ( int i = 0 ; i < s . size ( ) ; ++ i ) { for ( int j = 0 ; j < 26 ; j ++ ) { dp [ j ] [ s [ i ] - 'a' ] += freq [ j ] ; } freq [ s [ i ] - 'a' ] ++ ; } ll ans = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) ans = max ( freq [ i ] , ans ) ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { ans = max ( dp [ i ] [ j ] , ans ) ; } } return ans ; }
int findCycles ( int N ) { int res = 0 ; int finalResult = 0 ; int val = 2 * N - 1 ; int s = val ; res = ( N - 1 ) * ( N - 2 ) ; finalResult = res + s ; return finalResult ; }
int longest_subarray ( int arr [ ] , int d ) { int i = 0 , j = 1 , e = 0 ; for ( i = 0 ; i < d - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { j = j + 1 ; } else { j = 1 ; } if ( e < j ) { e = j ; } } return e ; }
int find ( int a [ ] , int n , int k ) { vector < int > v ; for ( int i = 1 ; i < n ; ++ i ) { v . push_back ( a [ i - 1 ] - a [ i ] ) ; } sort ( v . begin ( ) , v . end ( ) ) ; int res = a [ n - 1 ] - a [ 0 ] ; for ( int i = 0 ; i < k - 1 ; ++ i ) { res += v [ i ] ; } return res ; }
bool isStrong ( int N ) { string num = to_string ( N ) ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { sum += factorial [ num [ i ] - '0' ] ; } return sum == N ; }
void printStrongNumbers ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( isStrong ( i ) ) { cout << i << " " ; } } }
int countPairs ( int A , int B ) { int countY = 0 , countX = ( B - A ) + 1 , next_val = 9 ; while ( next_val <= B ) { if ( next_val >= A ) { countY += 1 ; } next_val = next_val * 10 + 9 ; } return ( countX * countY ) ; }
long power ( long a , long b , long c ) { long result = 1 ; while ( b > 0 ) { if ( ( b & 1 ) == 1 ) { result = ( result * a ) % c ; } b /= 2 ; a = ( a * a ) % c ; } return result ; }
long calculate ( long X , long N ) { int a [ 10 ] ; int cyclicity [ 11 ] ; cyclicity [ 1 ] = 1 ; cyclicity [ 2 ] = 4 ; cyclicity [ 3 ] = 4 ; cyclicity [ 4 ] = 2 ; cyclicity [ 5 ] = 1 ; cyclicity [ 6 ] = 1 ; cyclicity [ 7 ] = 4 ; cyclicity [ 8 ] = 4 ; cyclicity [ 9 ] = 2 ; cyclicity [ 10 ] = 1 ; if ( N == 0 N == 1 ) { return ( X % 10 ) ; } else if ( N == 2 N == 3 N == 4 ) { long temp = ( long ) 1e18 ; a [ 2 ] = 2 ; a [ 3 ] = 6 ; a [ 4 ] = 4 ; long v = X % 10 ; if ( v != 0 ) { int u = cyclicity [ ( int ) v ] ; int r = a [ ( int ) N ] % u ; if ( r == 0 ) { if ( v == 2 v == 4 v == 6 v == 8 ) { return 6 ; } else if ( v == 5 ) { return 5 ; } else if ( v == 1 v == 3 v == 7 v == 9 ) { return 1 ; } } else { return ( power ( v , r , temp ) % 10 ) ; } } else { return 0 ; } } return 1 ; }
void precompute ( string s , string K ) { int n = s . size ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { cnt [ i + 1 ] = cnt [ i ] + ( s . substr ( i , K . size ( ) ) == K ) ; } }
int getXOR ( int BITree [ ] , int index ) { int ans = 0 ; index += 1 ; while ( index > 0 ) { ans ^= BITree [ index ] ; index -= index & ( - index ) ; } return ans ; }
void updateBIT ( int BITree [ ] , int n , int index , int val ) { index = index + 1 ; while ( index <= n ) { BITree [ index ] ^= val ; index += index & ( - index ) ; } }
bool isPowerOfTwo ( int x ) { if ( x && ( ! ( x & ( x - 1 ) ) ) ) return true ; return false ; }
void computePrefix ( int n , int a [ ] ) { if ( isPowerOfTwo ( a [ 0 ] ) ) prefix [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] ; if ( isPowerOfTwo ( a [ i ] ) ) prefix [ i ] ++ ; } }
int formQuadruplets ( int arr [ ] , int n ) { int ans = 0 , pairs = 0 ; pairs = n / 4 ; sort ( arr , arr + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n - pairs ; i += 3 ) { ans += arr [ i + 2 ] ; } return ans ; }
void count ( ) { int maxN = 1000000 , i , j ; for ( i = 0 ; i < maxN ; i ++ ) arr [ i ] = 1 ; arr [ 0 ] = 0 ; arr [ 1 ] = 0 ; for ( i = 2 ; i * i <= maxN ; i ++ ) { if ( arr [ i ] == 1 ) { for ( j = 2 * i ; j <= maxN ; j += i ) { arr [ j ] = 0 ; } } } int cnt = 0 ; for ( i = 0 ; i <= maxN ; i ++ ) { if ( arr [ i ] == 1 ) cnt ++ ; if ( arr [ cnt ] == 1 ) dp [ i ] = 1 ; else dp [ i ] = 0 ; } for ( i = 1 ; i <= maxN ; i ++ ) dp [ i ] += dp [ i - 1 ] ; }
void findUngroupedElement ( string s , int k ) { int n = s . length ( ) ; int b [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) b [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { char p = s . at ( i ) ; b [ p - 'a' ] += 1 ; } int sum = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( b [ i ] > k ) sum += b [ i ] - k ; } cout << sum << endl ; }
void AddEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; }
void findFirstEnd ( int u , int p ) { lvl [ u ] = 1 + lvl [ p ] ; if ( lvl [ u ] > maxi ) { maxi = lvl [ u ] ; end1 = u ; } for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) { if ( adj [ u ] [ i ] != p ) { findFirstEnd ( adj [ u ] [ i ] , u ) ; } } }
void findSecondEnd ( int u , int p ) { lvl [ u ] = 1 + lvl [ p ] ; if ( lvl [ u ] > maxi ) { maxi = lvl [ u ] ; end2 = u ; } for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) { if ( adj [ u ] [ i ] != p ) { findSecondEnd ( adj [ u ] [ i ] , u ) ; } } }
void findDistancefromFirst ( int u , int p ) { dist1 [ u ] = 1 + dist1 [ p ] ; for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) { if ( adj [ u ] [ i ] != p ) { findDistancefromFirst ( adj [ u ] [ i ] , u ) ; } } }
void findDistancefromSecond ( int u , int p ) { dist2 [ u ] = 1 + dist2 [ p ] ; for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) { if ( adj [ u ] [ i ] != p ) { findDistancefromSecond ( adj [ u ] [ i ] , u ) ; } } }
void findNodes ( ) { int n = 5 ; AddEdge ( 1 , 2 ) ; AddEdge ( 1 , 3 ) ; AddEdge ( 3 , 4 ) ; AddEdge ( 3 , 5 ) ; findFirstEnd ( 1 , 0 ) ; clear ( n ) ; findSecondEnd ( end1 , 0 ) ; findDistancefromFirst ( end1 , 0 ) ; findDistancefromSecond ( end2 , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) { int x = dist1 [ i ] ; int y = dist2 [ i ] ; if ( x >= y ) { cout << end1 << ' ' ; } else { cout << end2 << ' ' ; } } }
int findMaxSum ( int * arr , int n ) { vector < int > a ; vector < int > b ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { a . push_back ( arr [ i ] ) ; } else if ( arr [ i ] < 0 ) { b . push_back ( arr [ i ] ) ; } } sort ( a . begin ( ) , a . end ( ) ) ; sort ( b . begin ( ) , b . end ( ) ) ; int p = a . size ( ) - 1 ; int q = b . size ( ) - 1 ; int s = 0 ; while ( p >= 0 && q >= 0 ) { if ( a [ p ] + b [ q ] > 0 ) { s = s + a [ p ] + b [ q ] ; } else { break ; } p = p - 1 ; q = q - 1 ; } return s ; }
void countIntgralPoints ( int x1 , int y1 , int x2 , int y2 ) { cout << ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ; }
void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
void PrimeDegreeNodes ( int prufer [ ] , int n ) { int nodes = n + 2 ; bool prime [ nodes + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , nodes + 1 ) ; int degree [ n + 2 + 1 ] ; for ( int i = 1 ; i <= nodes ; i ++ ) degree [ i ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) degree [ prufer [ i ] ] ++ ; for ( int i = 1 ; i <= nodes ; i ++ ) { if ( prime [ degree [ i ] ] ) { cout << i << " " ; } } }
int countSingle ( Node * root ) { int count = 0 ; countSingleRec ( root , count ) ; return count ; }
void SieveOfEratosthenes ( ) { int i , j ; Prime [ 0 ] = Prime [ 1 ] = false ; for ( i = 2 ; i * i <= 10005 ; i ++ ) { if ( Prime [ i ] ) { for ( j = 2 * i ; j < 10005 ; j += i ) { Prime [ j ] = false ; } } } }
void primeDegreeNodes ( int N , int M , int edges [ ] [ 2 ] ) { vector < int > Adj [ N + 1 ] ; for ( int i = 0 ; i < M ; i ++ ) { int x = edges [ i ] [ 0 ] ; int y = edges [ i ] [ 1 ] ; Adj [ x ] . push_back ( y ) ; Adj [ y ] . push_back ( x ) ; } SieveOfEratosthenes ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { int x = Adj [ i ] . size ( ) ; if ( Prime [ x ] ) cout << i << ' ' ; } }
int digitSum ( int num ) { int sum = 0 ; while ( num ) { sum += ( num % 10 ) ; num /= 10 ; } return sum ; }
int countWays ( int colored [ ] , int count , int n ) { if ( count == n ) { return 1 ; } int answer = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { if ( colored [ i ] == 0 ) { if ( colored [ i - 1 ] == 1 colored [ i + 1 ] == 1 ) { colored [ i ] = 1 ; answer = ( answer + countWays ( colored , count + 1 , n ) ) % mod ; colored [ i ] = 0 ; } } } return answer ; }
int waysToColor ( int arr [ ] , int n , int k ) { int colored [ n + 2 ] = { 0 } ; for ( int i = 0 ; i < k ; i ++ ) { colored [ arr [ i ] ] = 1 ; } return countWays ( colored , k , n ) ; }
int waysToColor ( int arr [ ] , int n , int k ) { int powOf2 [ 500 ] = { 0 } ; int c [ 500 ] [ 500 ] ; for ( int i = 0 ; i <= n ; i ++ ) { c [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j <= i ; j ++ ) { c [ i ] [ j ] = ( c [ i - 1 ] [ j ] + c [ i - 1 ] [ j - 1 ] ) % mod ; } } powOf2 [ 0 ] = powOf2 [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { powOf2 [ i ] = powOf2 [ i - 1 ] * 2 % mod ; } int rem = n - k ; arr [ k ++ ] = n + 1 ; sort ( arr , arr + k ) ; int answer = 1 ; for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ i ] - ( i - 1 >= 0 ? arr [ i - 1 ] : 0 ) - 1 ; answer *= c [ rem ] [ x ] % mod * ( i != 0 && i != k - 1 ? powOf2 [ x ] : 1 ) % mod ; rem -= x ; } return answer ; }
char ShortestPalindrome ( string s ) { int n = s . length ( ) ; char ans = s [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { ans = min ( ans , s [ i ] ) ; } return ans ; }
int SumGPUtil ( long long int r , long long int n , long long int m ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return ( 1 + r ) % m ; long long int ans ; if ( n % 2 == 1 ) { ans = ( 1 + r ) * SumGPUtil ( ( r * r ) % m , ( n - 1 ) / 2 , m ) ; } else { ans = 1 + ( r * ( 1 + r ) * SumGPUtil ( ( r * r ) % m , ( n / 2 ) - 1 , m ) ) ; } return ( ans % m ) ; }
void SumGP ( long long int a , long long int r , long long int N , long long int M ) { long long int answer ; answer = a * SumGPUtil ( r , N , M ) ; answer = answer % M ; cout << answer << endl ; }
void findLeafDown ( Node * root , int lev , int * minDist ) { if ( root == NULL ) return ; if ( root -> left == NULL && root -> right == NULL ) { if ( lev < ( * minDist ) ) * minDist = lev ; return ; } findLeafDown ( root -> left , lev + 1 , minDist ) ; findLeafDown ( root -> right , lev + 1 , minDist ) ; }
int findThroughParent ( Node * root , Node * x , int * minDist ) { if ( root == NULL ) return -1 ; if ( root == x ) return 0 ; int l = findThroughParent ( root -> left , x , minDist ) ; if ( l != -1 ) { findLeafDown ( root -> right , l + 2 , minDist ) ; return l + 1 ; } int r = findThroughParent ( root -> right , x , minDist ) ; if ( r != -1 ) { findLeafDown ( root -> left , r + 2 , minDist ) ; return r + 1 ; } return -1 ; }
int minimumDistance ( Node * root , Node * x ) { int minDist = INT_MAX ; findLeafDown ( x , 0 , & minDist ) ; findThroughParent ( root , x , & minDist ) ; return minDist ; }
int SmallestDiv ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return i ; } } return n ; }
ll int countOfNum ( ll int n , ll int a , ll int b ) { ll int cnt_of_a , cnt_of_b , cnt_of_ab , sum ; cnt_of_a = n / a ; cnt_of_b = n / b ; sum = cnt_of_b + cnt_of_a ; cnt_of_ab = n / ( a * b ) ; sum = sum - cnt_of_ab ; return sum ; }
ll int sumOfNum ( ll int n , ll int a , ll int b ) { ll int i ; ll int sum = 0 ; set < ll int > ans ; for ( i = a ; i <= n ; i = i + a ) { ans . insert ( i ) ; } for ( i = b ; i <= n ; i = i + b ) { ans . insert ( i ) ; } for ( auto it = ans . begin ( ) ; it != ans . end ( ) ; it ++ ) { sum = sum + * it ; } return sum ; }
bool isPalindrome ( string r ) { string p = r ; reverse ( p . begin ( ) , p . end ( ) ) ; return ( r == p ) ; }
int minimumAdjacentDifference ( vector < int > a , int n , int k ) { int minDiff = INT_MAX ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int cnt = __builtin_popcount ( i ) ; if ( cnt == n - k ) { vector < int > temp ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) temp . push_back ( a [ j ] ) ; } int maxDiff = INT_MIN ; for ( int j = 0 ; j < temp . size ( ) - 1 ; j ++ ) { maxDiff = max ( maxDiff , temp [ j + 1 ] - temp [ j ] ) ; } minDiff = min ( minDiff , maxDiff ) ; } } return minDiff ; }
int gcdFunc ( int a , int b ) { if ( b == 0 ) return a ; return gcdFunc ( b , a % b ) ; }
int findMinimumElements ( int * a , int n ) { int b [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { b [ i - 1 ] = a [ i ] - a [ i - 1 ] ; } int gcd = b [ 0 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { gcd = gcdFunc ( gcd , b [ i ] ) ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans += ( b [ i ] / gcd ) - 1 ; } return ans ; }
bool checkPermutation ( int arr [ ] , int n ) { long long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; long long prefix [ n + 1 ] = { 0 } ; prefix [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix [ i ] = prefix [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long long lsum = prefix [ i ] ; long long rsum = sum - prefix [ i ] ; long long l_len = i + 1 , r_len = n - i - 1 ; if ( ( ( 2 * lsum ) == ( l_len * ( l_len + 1 ) ) ) && ( ( 2 * rsum ) == ( r_len * ( r_len + 1 ) ) ) ) return true ; } return false ; }
void maximumArea ( int l , int b , int x , int y ) { int left , right , above , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; below = ( b - y - 1 ) * l ; cout << max ( max ( left , right ) , max ( above , below ) ) ; }
void precompute ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd [ i ] = 1 ; if ( arr [ i ] % 2 == 0 ) even [ i ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { even [ i ] = even [ i ] + even [ i - 1 ] ; odd [ i ] = odd [ i ] + odd [ i - 1 ] ; } }
bool isOdd ( int L , int R ) { int cnt = odd [ R ] ; if ( L > 0 ) cnt -= odd [ L - 1 ] ; if ( cnt == R - L + 1 ) return true ; return false ; }
void findTriplets ( int x ) { vector < int > fact ; unordered_set < int > factors ; for ( int i = 2 ; i <= sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { fact . push_back ( i ) ; if ( x / i != i ) fact . push_back ( x / i ) ; factors . insert ( i ) ; factors . insert ( x / i ) ; } } bool found = false ; int k = fact . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { int a = fact [ i ] ; for ( int j = 0 ; j < k ; j ++ ) { int b = fact [ j ] ; if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) { cout << a << " " << b << " " << ( x / ( a * b ) ) ; found = true ; break ; } } if ( found ) break ; } if ( ! found ) cout << "-1" ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
void findArray ( int n , int k , int s ) { int vis [ n ] = { 0 } ; int cnt = 0 ; int arr [ n ] ; for ( int i = 0 ; i < n && cnt < k ; i += 2 ) { arr [ i ] = s ; vis [ i ] = 1 ; cnt ++ ; } int val = s ; if ( s % 2 == 0 ) val ++ ; else val = val + 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] == 0 ) { arr [ i ] = val ; } } printArr ( arr , n ) ; }
int countPair ( int a , int b ) { string s = to_string ( b ) ; int i ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != '9' ) break ; } int result ; if ( i == s . length ( ) ) result = a * s . length ( ) ; else result = a * ( s . length ( ) - 1 ) ; return result ; }
float getArea ( int a ) { float area = ( M_PI * a * a ) / 4.0 ; return area ; }
bool flipsPossible ( int a [ ] , int n ) { int count_odd = 0 , count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] & 1 ) count_odd ++ ; else count_even ++ ; } if ( count_odd % 2 && count_even % 2 ) return false ; else return true ; }
int sumEqualProduct ( int a [ ] , int n ) { int zero = 0 , two = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { zero ++ ; } if ( a [ i ] == 2 ) { two ++ ; } } int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 ; return cnt ; }
int minSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } if ( sum == 1 ) return 10 ; return sum ; }
void initialize ( int mul [ ] , int div [ ] , int size ) { for ( int i = 1 ; i < size ; i ++ ) { mul [ i ] = ( mul [ i ] * mul [ i - 1 ] ) / div [ i ] ; } }
void update ( int l , int r , int x , int mul [ ] , int div [ ] ) { mul [ l ] *= x ; div [ r + 1 ] *= x ; }
void printArray ( int ar [ ] , int mul [ ] , int div [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { ar [ i ] = ar [ i ] * mul [ i ] ; cout << ar [ i ] << " " ; } }
void findTriangle ( long S ) { long X1 = 0 , Y1 = 0 ; long X2 = MAX , Y2 = 1 ; long X3 = ( MAX - S % MAX ) % MAX ; long Y3 = ( S + X3 ) / MAX ; cout << "(" << X1 << ", " << Y1 << ")\n" ; cout << "(" << X2 << ", " << Y2 << ")\n" ; cout << "(" << X3 << ", " << Y3 << ")" ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
void findArrangement ( int arr [ ] , int n ) { if ( n < 2 ) { cout << "-1" ; return ; } int minVal = * min_element ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == minVal ) { swap ( arr [ i ] , arr [ n - 1 ] ) ; break ; } } int andVal = arr [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { andVal &= arr [ i ] ; } if ( andVal == arr [ n - 1 ] ) printArr ( arr , n ) ; else cout << "-1" ; }
int maxOperations ( int X , int Y ) { if ( X > Y ) return -1 ; int diff = Y - X ; if ( diff == 1 ) return -1 ; if ( diff % 2 == 0 ) return ( diff / 2 ) ; return ( 1 + ( ( diff - 3 ) / 2 ) ) ; }
void precompute ( ) { for ( int i = 0 ; i < DIGITS ; i ++ ) dp [ 1 ] [ i ] = i , cnt [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < DIGITS ; j ++ ) { for ( int k = 0 ; k < DIGITS ; k ++ ) { if ( j != k ) { dp [ i ] [ j ] = dp [ i ] [ j ] + ( dp [ i - 1 ] [ k ] + ( cnt [ i - 1 ] [ k ] * j ) % MOD ) % MOD ; dp [ i ] [ j ] %= MOD ; cnt [ i ] [ j ] += cnt [ i - 1 ] [ k ] ; cnt [ i ] [ j ] %= MOD ; } } } } }
void precompute ( ) { F [ 1 ] = 2 ; F [ 2 ] = 3 ; F [ 3 ] = 4 ; for ( int i = 4 ; i < N ; i ++ ) F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; }
double minimizedSum ( int a [ ] , int n , int K ) { int sum = maxSubArraySum ( a , n ) ; double totalSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) totalSum += a [ i ] ; if ( sum < 0 ) return totalSum ; totalSum = totalSum - sum + ( double ) sum / ( double ) K ; return totalSum ; }
double get ( double L , double R ) { double x = 1.0 / L ; double y = 1.0 / ( R + 1.0 ) ; return ( x - y ) ; }
void DivisorCount ( ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = i ; j < N ; j += i ) { divi [ j ] ++ ; } } }
void pre ( ) { for ( int i = 1 ; i < N ; i ++ ) { if ( prime [ divi [ i ] ] == 1 ) { sum [ i ] = i ; } } for ( int i = 1 ; i < N ; i ++ ) sum [ i ] += sum [ i - 1 ] ; }
int consecutiveOnes ( int x ) { int p = 0 ; while ( x > 0 ) { if ( x % 2 == 1 and p == 1 ) return true ; p = x % 2 ; x /= 2 ; } return false ; }
void preCompute ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) { if ( ! consecutiveOnes ( i ) ) v . push_back ( i ) ; } }
int nextValid ( int n ) { int it = upper_bound ( v . begin ( ) , v . end ( ) , n ) - v . begin ( ) ; int val = v [ it ] ; return val ; }
void randomList ( int m , int n ) { int arr [ m ] = { 0 } ; srand ( time ( 0 ) ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ rand ( ) % m ] ++ ; } printArr ( arr , m ) ; }
ll power ( ll x , ll y , ll p ) { ll res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
ll nCrModPFermat ( ll n , ll r , ll p ) { if ( r == 0 ) return 1 ; ll fac [ n + 1 ] ; fac [ 0 ] = 1 ; for ( ll i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p ; }
ll countOdd ( ll n ) { ll x = n / 2 ; if ( n % 2 == 1 ) x ++ ; return x ; }
ll counteEven ( ll n ) { ll x = n / 2 ; return x ; }
int sumPrime ( int k ) { SieveOfEratosthenes ( ) ; vector < int > v ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] ) v . push_back ( i ) ; } int sum = 0 ; int skip = ( k * ( k - 1 ) ) / 2 ; while ( k > 0 ) { sum += v [ skip ] ; skip ++ ; k -- ; } return sum ; }
int lcm ( int x , int y ) { int temp = ( x * y ) / __gcd ( x , y ) ; return temp ; }
void findNumbers ( int a [ ] , int n , int b [ ] , int m ) { int lcmA = 1 , gcdB = 0 ; for ( int i = 0 ; i < n ; i ++ ) lcmA = lcm ( lcmA , a [ i ] ) ; for ( int i = 0 ; i < m ; i ++ ) gcdB = __gcd ( gcdB , b [ i ] ) ; if ( gcdB % lcmA != 0 ) { cout << "-1" ; return ; } int num = lcmA ; while ( num <= gcdB ) { if ( gcdB % num == 0 ) cout << num << " " ; num += lcmA ; } }
int countSubStr ( string str , int n , char ch ) { int cnt = 0 ; int j = nextOccurrence ( str , n , 0 , ch ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( j != -1 && j < i ) { j = nextOccurrence ( str , n , j + 1 , ch ) ; } if ( j == -1 ) break ; cnt += ( n - j ) ; } return cnt ; }
void checkEvenOdd ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { cout << "Even" ; return ; } } cout << "Odd" ; }
int power ( int x , unsigned int y ) { int res = 1 ; while ( y > 0 ) { if ( y & 1 ) res = res * x ; y = y >> 1 ; x = x * x ; } return res ; }
int maxPartition ( string s ) { int n = s . length ( ) , P = 0 ; string current = "" , previous = "" ; for ( int i = 0 ; i < n ; i ++ ) { current += s [ i ] ; if ( current != previous ) { previous = current ; current . clear ( ) ; P ++ ; } } return P ; }
int LongestSubarray ( int a [ ] , int n , int k ) { int pre [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > k ) pre [ i ] = 1 ; else pre [ i ] = -1 ; } for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = pre [ i - 1 ] + pre [ i ] ; int len = 0 ; int lo = 1 , hi = n ; while ( lo <= hi ) { int mid = ( lo + hi ) / 2 ; bool ok = false ; for ( int i = mid - 1 ; i < n ; i ++ ) { int x = pre [ i ] ; if ( i - mid >= 0 ) x -= pre [ i - mid ] ; if ( x > 0 ) { ok = true ; break ; } } if ( ok == true ) { len = mid ; lo = mid + 1 ; } else hi = mid - 1 ; } return len ; }
bool prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; ++ i ) if ( n % i == 0 ) return false ; return true ; }
int Min_Sum ( int n ) { if ( prime ( n ) ) return 1 ; if ( n % 2 == 0 ) return 2 ; else { if ( prime ( n - 2 ) ) return 2 ; else return 3 ; } }
int MinDeletion ( int a [ ] , int n ) { unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) map [ a [ i ] ] ++ ; int ans = 0 ; for ( auto i : map ) { int x = i . first ; int frequency = i . second ; if ( x <= frequency ) { ans += ( frequency - x ) ; } else ans += frequency ; } return ans ; }
int find_maximum_value ( int a [ ] , int n ) { int sum = 0 ; int minimum = INT_MAX ; int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { minimum = min ( minimum , abs ( a [ i ] ) ) ; sum += abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) pos += 1 ; else neg += 1 ; } if ( pos > 0 && neg > 0 ) return sum ; return ( sum - 2 * minimum ) ; }
int maxCountAB ( string s [ ] , int n ) { int A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string S = s [ i ] ; int L = S . size ( ) ; for ( int j = 0 ; j < L - 1 ; j ++ ) { if ( S . at ( j ) == 'A' && S . at ( j + 1 ) == 'B' ) { ans ++ ; } } if ( S . at ( 0 ) == 'B' && S . at ( L - 1 ) == 'A' ) BA ++ ; else if ( S . at ( 0 ) == 'B' ) B ++ ; else if ( S . at ( L - 1 ) == 'A' ) A ++ ; } if ( BA == 0 ) ans += min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + min ( B , A ) ; return ans ; }
int MinOperations ( int n , int x , int * arr ) { int total = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] > x ) { int difference = arr [ i ] - x ; total = total + difference ; arr [ i ] = x ; } } for ( int i = 1 ; i < n ; ++ i ) { int LeftNeigbouringSum = arr [ i ] + arr [ i - 1 ] ; if ( LeftNeigbouringSum > x ) { int current_diff = LeftNeigbouringSum - x ; arr [ i ] = max ( 0 , arr [ i ] - current_diff ) ; total = total + current_diff ; } } return total ; }
int countPairs ( string s ) { set < char > st ; st . insert ( 'a' ) ; st . insert ( 'e' ) ; st . insert ( 'i' ) ; st . insert ( 'o' ) ; st . insert ( 'u' ) ; int count = 0 ; int n = s . size ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( st . find ( s [ i ] ) == st . end ( ) && st . find ( s [ i + 1 ] ) != st . end ( ) ) count ++ ; } return count ; }
int maxSize ( vector < int > & v , int n ) { v . push_back ( 0 ) ; v . push_back ( 100001 ) ; n += 2 ; sort ( v . begin ( ) , v . end ( ) ) ; int mx = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int L = v [ i - 1 ] + 1 ; int R = v [ i + 1 ] - 1 ; int cnt = R - L + 1 ; mx = max ( mx , cnt ) ; } return mx ; }
int power ( int x , unsigned int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
int maxLength ( int a [ ] , int n ) { int sum = 0 , len = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return n ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) len = max ( len , max ( n - i - 1 , i ) ) ; } return len ; }
int countMaxLength ( int N ) { int res ; int pre [ MAXN ] , p = 1 ; pre [ 0 ] = 0 ; for ( int i = 1 ; i < MAXN ; i ++ ) { p *= 2 ; pre [ i ] = pre [ i - 1 ] + i * p ; } int ind ; for ( int i = 1 ; i < MAXN ; i ++ ) { if ( pre [ i ] >= N ) { ind = i ; break ; } } int x = N - pre [ ind - 1 ] ; int y = 2 * ind - 1 ; if ( x >= y ) res = min ( x , y ) ; else res = max ( x , 2 * ( ind - 2 ) + 1 ) ; return res ; }
int getMinVal ( int p , int q ) { if ( q % p == 0 ) return p ; return -1 ; }
void findPoints ( int l1 , int r1 , int l2 , int r2 ) { int x = ( l1 != l2 ) ? min ( l1 , l2 ) : -1 ; int y = ( r1 != r2 ) ? max ( r1 , r2 ) : -1 ; cout << x << " " << y ; }
int countPrimePalindrome ( string str , int len ) { bool prime [ len + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= len ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * p ; i <= len ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int j = 2 ; j <= len ; j ++ ) { if ( prime [ j ] ) { for ( int i = 0 ; i + j - 1 < len ; i ++ ) { if ( isPalindrome ( str , i , i + j - 1 ) ) count ++ ; } } } return count ; }
int minOperations ( int N ) { double x = log2 ( N ) ; int ans = ceil ( x ) ; return ans ; }
int find_greatest_divisor ( int l , int r ) { if ( l == r ) return l ; return 1 ; }
void findNumbers ( int arr [ ] , int n ) { int sumN = ( n * ( n + 1 ) ) / 2 ; int sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sum = 0 , sumSq = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq = sumSq + ( pow ( arr [ i ] , 2 ) ) ; } int B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; int A = sum - sumN + B ; cout << "A = " ; cout << A << endl ; cout << "B = " ; cout << B << endl ; }
int factorialUsingRecursion ( int n ) { if ( n == 0 ) return 1 ; return n * factorialUsingRecursion ( n - 1 ) ; }
int factorialUsingIteration ( int n ) { int res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
bool checkPerfectSquare ( double n ) { double d = sqrt ( n ) ; if ( d * d == n ) return true ; return false ; }
int largestPerfectSquareNumber ( int a [ ] , double n ) { int maxi = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkPerfectSquare ( a [ i ] ) ) maxi = max ( a [ i ] , maxi ) ; } return maxi ; }
void convert ( int n , int a [ ] ) { int z = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] > z ) z = a [ i ] ; } z = z + 1 ; int ff [ z ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { ff [ a [ i ] ] += 1 ; } int cc = 0 ; for ( int i = 0 ; i < z ; i ++ ) { cc += int ( ff [ i ] / 4 ) ; ff [ i ] = ff [ i ] % 4 ; } int vv = 0 ; for ( int i = 0 ; i < z ; i ++ ) { if ( ff [ i ] >= 2 ) vv += 1 ; } cc += int ( vv / 2 ) ; cout << ( cc ) ; }
double getProbability ( double p , double q ) { p /= 100 ; q /= 100 ; double probability = ( p * p + q * q ) / ( p + q ) ; return probability ; }
bool check ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) return true ; } return false ; }
int find_LCM ( int x , int y ) { return ( x * y ) / __gcd ( x , y ) ; }
int CountPairs ( int n , int m , int A , int B ) { int cnt = 0 ; int lcm = find_LCM ( A , B ) ; for ( int i = 1 ; i <= n ; i ++ ) cnt += ( m + ( i % lcm ) ) / lcm ; return cnt ; }
int sortArr ( int arr [ ] , int n , int min , int max ) { int m = max - min + 1 ; vector < int > c ( m , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) c [ arr [ i ] - min ] ++ ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < c [ i ] ; j ++ ) cout << ( i + min ) << " " ; }
void revereseArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n / 2 ; i ++ ) swap ( arr [ i ] , arr [ n - i - 1 ] ) ; }
double recursiveLogStar ( double n , double b ) { if ( n > 1.0 ) return 1.0 + recursiveLogStar ( _log ( n , b ) , b ) ; else return 0 ; }
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
unsigned int fact ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
double maxKth ( int arr [ ] , int N , int C , int K ) { if ( N + C < K ) { return -1 ; } int iter = 300 ; double l = 0 , r = 1000000000.0 ; while ( iter -- ) { double mid = ( l + r ) * 0.5 ; double a = 0 ; double b = 0 ; for ( int i = 0 ; i < N ; i ++ ) { a += int ( ( double ) arr [ i ] / mid ) ; if ( ( double ) arr [ i ] >= mid ) { b ++ ; } } if ( a >= K && b + C >= K ) { l = mid ; } else { r = mid ; } } return l ; }
bool isPossibleToSelect ( int arr [ ] , int N , int dif , int K ) { int count = 1 ; int prev = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] >= ( prev + dif ) ) { count ++ ; if ( count == K ) return true ; prev = arr [ i ] ; } } return false ; }
int binarySearch ( int arr [ ] , int left , int right , int K , int N ) { int ans = 1 ; while ( left <= right ) { int dif = left + ( right - left ) / 2 ; if ( isPossibleToSelect ( arr , N , dif , K ) ) { ans = max ( ans , dif ) ; left = dif + 1 ; } else right = dif - 1 ; } return ans ; }
int cal ( vector < int > arr , int mid ) { int chocolate = 0 ; for ( auto i : arr ) { if ( i >= mid ) chocolate += i - mid ; } return chocolate ; }
bool check ( vector < int > & bananas , int mid_val , int H ) { int time = 0 ; for ( int i = 0 ; i < bananas . size ( ) ; i ++ ) { if ( bananas [ i ] % mid_val != 0 ) { time += ( ( bananas [ i ] / mid_val ) + 1 ) ; } else { time += ( bananas [ i ] / mid_val ) ; } } if ( time <= H ) { return true ; } else { return false ; } }
int minEatingSpeed ( vector < int > & piles , int H ) { int start = 1 ; int end = * max_element ( piles . begin ( ) , piles . end ( ) ) ; while ( start < end ) { int mid = start + ( end - start ) / 2 ; if ( ( check ( piles , mid , H ) ) == true ) { end = mid ; } else { start = mid + 1 ; } } return end ; }
bool is_prefix ( string temp , string str ) { if ( temp . length ( ) < str . length ( ) ) return 0 ; else { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] != temp [ i ] ) return 0 ; } return 1 ; } }
string lexicographicallyString ( string input [ ] , int n , string str ) { sort ( input , input + n ) ; for ( int i = 0 ; i < n ; i ++ ) { string temp = input [ i ] ; if ( is_prefix ( temp , str ) ) { return temp ; } } return "-1" ; }
int minSumPair ( int arr [ ] , int N ) { if ( N < 5 ) { return -1 ; } int prefixMin [ N ] ; prefixMin [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N - 1 ; i ++ ) { prefixMin [ i ] = min ( arr [ i ] , prefixMin [ i - 1 ] ) ; } int ans = INT_MAX ; for ( int i = 3 ; i < N - 1 ; i ++ ) { ans = min ( ans , arr [ i ] + prefixMin [ i - 2 ] ) ; } return ans ; }
long check ( long H [ ] , long A [ ] , long mid , long N , long M , long L ) { long sum = 0 ; for ( long i = 0 ; i < N ; i ++ ) { long speed = mid * A [ i ] + H [ i ] ; if ( speed >= L ) { sum += speed ; } } return sum ; }
long buzzTime ( long N , long M , long L , long H [ ] , long A [ ] ) { long low = 0 , high = 1e10 ; long ans = 0 ; while ( high >= low ) { long mid = low + ( high - low ) / 2 ; if ( check ( H , A , mid , N , M , L ) >= M ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; }
void findCount ( string number ) { int sum = 0 ; for ( int i = 0 ; i < number . length ( ) ; ++ i ) { sum += number [ i ] - 48 ; } int count = 0 ; for ( int i = 0 ; i < number . length ( ) ; ++ i ) { int remaining_sum = sum - ( number [ i ] - 48 ) ; for ( int j = 0 ; j <= 9 ; ++ j ) { if ( ( remaining_sum + j ) % 3 == 0 && j != number [ i ] - 48 ) { ++ count ; } } } cout << count ; }
bool is_possible ( vector < int > & teams , int T , int k ) { int sum = 0 ; for ( int i = 0 ; i < teams . size ( ) ; i ++ ) { sum += min ( T , teams [ i ] ) ; } return ( sum >= ( T * k ) ) ; }
int countOfTeams ( vector < int > & teams_list , int N , int K ) { int lb = 0 , ub = 1e9 ; while ( lb <= ub ) { int mid = lb + ( ub - lb ) / 2 ; if ( is_possible ( teams_list , mid , K ) ) { if ( ! is_possible ( teams_list , mid + 1 , K ) ) { return mid ; } else { lb = mid + 1 ; } } else { ub = mid - 1 ; } } return 0 ; }
void balBracketSequence ( string str ) { int n = str . size ( ) ; if ( str [ 0 ] == str [ n - 1 ] ) { cout << "No" << endl ; } else { int cntForOpen = 0 , cntForClose = 0 ; int check = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) cntForOpen ++ ; else if ( str [ i ] == str [ n - 1 ] ) cntForOpen -- ; else cntForOpen ++ ; if ( cntForOpen < 0 ) { check = 0 ; break ; } } if ( check && cntForOpen == 0 ) { cout << "Yes, " ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ n - 1 ] ) cout << ')' ; else cout << '(' ; } return ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) cntForClose ++ ; else cntForClose -- ; if ( cntForClose < 0 ) { check = 0 ; break ; } } if ( check && cntForClose == 0 ) { cout << "Yes, " ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) cout << '(' ; else cout << ')' ; } return ; } } cout << "No" ; } }
void minimumOperations ( int arr [ ] , int N ) { int mx = 0 , pos = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= mx ) { mx = arr [ i ] ; pos = i ; } } cout << ( mx - 1 ) * N + pos + 1 ; }
ll check ( ll v , vector < ll > & a ) { ll tec = 0 , ans = 0 ; vector < ll > b ( n + k + 1 ) ; for ( i = 0 ; i < n ; i ++ ) { tec -= b [ i ] ; if ( a [ i ] + tec < v ) { ll mov = v - a [ i ] - tec ; ans = ans + mov ; tec += mov ; b [ i + k ] = mov ; } } return ( ans <= m ) ; }
ll FindLargest ( vector < ll > a ) { l = 1 ; r = pow ( 10 , 10 ) ; while ( r - l > 0 ) { ll tm = ( l + r + 1 ) / 2 ; if ( check ( tm , a ) ) l = tm ; else r = tm - 1 ; } return l ; }
int largestAltitude ( int L , int B ) { if ( L > B ) { swap ( B , L ) ; } int low = 0 , high = L ; int res = 0 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( mid <= ( B / 2 ) ) { res = mid ; low = mid + 1 ; } else high = mid - 1 ; } return res ; }
void findLargestIndex ( int arr [ ] , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] == i ) { cout << i << endl ; return ; } } cout << -1 << endl ; }
bool isMaximumMedian ( vector < vector < int > > & arr , int N , int K , int mid ) { vector < vector < int > > Pre ( N + 5 , vector < int > ( N + 5 , 0 ) ) ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) { Pre [ i + 1 ] [ j + 1 ] = Pre [ i + 1 ] [ j ] + Pre [ i ] [ j + 1 ] - Pre [ i ] [ j ] ; if ( arr [ i ] [ j ] <= mid ) Pre [ i + 1 ] [ j + 1 ] ++ ; } } int required = ( K * K + 1 ) / 2 ; bool flag = 0 ; for ( int i = K ; i <= N ; ++ i ) { for ( int j = K ; j <= N ; ++ j ) { int X = Pre [ i ] [ j ] - Pre [ i - K ] [ j ] - Pre [ i ] [ j - K ] + Pre [ i - K ] [ j - K ] ; if ( X < required ) flag = 1 ; } } return flag ; }
int getPairsCount ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( a [ i ] * a [ j ] ) == abs ( i - j ) ) count ++ ; } } return count ; }
int getPairsCount ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && ( arr [ i ] * arr [ j ] ) == abs ( i - j ) ) { count ++ ; } } } return count ; }
int numberofSubsequences ( int a [ ] , int L , int R , int X , int n ) { int ans = 0 ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int cnt = 0 , sum = 0 ; int minVal = INT_MAX , maxVal = INT_MIN ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) ) { cnt += 1 ; sum += a [ j ] ; maxVal = max ( maxVal , a [ j ] ) ; minVal = min ( minVal , a [ j ] ) ; } } if ( cnt >= 2 && sum >= L && sum <= R && ( maxVal - minVal >= X ) ) { ans += 1 ; } } return ans ; }
void numberofBoxes ( int W , int B , int O ) { int low = 0 , high = min ( W , B ) ; int ans = 0 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( ( ( W >= mid ) and ( B >= mid ) ) and ( ( W - mid ) + ( B - mid ) + O ) >= mid ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } cout << ans ; }
int minSwaps ( int N , int M , vector < vector < int > > & A , vector < vector < int > > & B ) { int count01 = 0 ; int count10 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { if ( A [ i ] [ j ] == 1 ) count10 ++ ; else count01 ++ ; } } } if ( count01 == count10 ) return count01 ; else return -1 ; }
int Count ( int N , int K ) { if ( K == 0 ) return 0 ; int res = 0 ; int low = 1 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = ( mid * mid + mid ) / 2 ; if ( sum <= K ) { res = max ( res , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } return res ; }
void createLoops ( Node * root ) { vector < Node * > even_ptrs , odd_ptrs ; preorderTraversal ( root , & even_ptrs , & odd_ptrs ) ; int i ; for ( i = 1 ; i < even_ptrs . size ( ) ; i ++ ) even_ptrs [ i - 1 ] -> abtr = even_ptrs [ i ] ; even_ptrs [ i - 1 ] -> abtr = even_ptrs [ 0 ] ; for ( i = 1 ; i < odd_ptrs . size ( ) ; i ++ ) odd_ptrs [ i - 1 ] -> abtr = odd_ptrs [ i ] ; odd_ptrs [ i - 1 ] -> abtr = odd_ptrs [ 0 ] ; }
void traverseLoop ( Node * start ) { Node * curr = start ; do { cout << curr -> data << " " ; curr = curr -> abtr ; } while ( curr != start ) ; }
int repeatingElement ( int arr [ ] , int N ) { int M = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; M = max ( M , arr [ i ] ) ; } int sum1 = M * ( M + 1 ) / 2 ; int ans = ( sum - sum1 ) / ( N - M ) ; return ans ; }
string lexicographicallyMaximum ( string S , int N ) { unordered_map < char , int > M ; for ( int i = 0 ; i < N ; ++ i ) { M [ S [ i ] ] ++ ; } vector < char > V ; for ( char i = 'a' ; i < ( char ) ( 'a' + min ( N , 25 ) ) ; ++ i ) { if ( M [ i ] == 0 ) { V . push_back ( i ) ; } } int j = V . size ( ) - 1 ; for ( int i = 0 ; i < N ; ++ i ) { if ( S [ i ] >= ( 'a' + min ( N , 25 ) ) M [ S [ i ] ] > 1 ) { if ( V [ j ] < S [ i ] ) continue ; M [ S [ i ] ] -- ; S [ i ] = V [ j ] ; j -- ; } if ( j < 0 ) break ; } int l = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( l > j ) break ; if ( S [ i ] >= ( 'a' + min ( N , 25 ) ) M [ S [ i ] ] > 1 ) { M [ S [ i ] ] -- ; S [ i ] = V [ l ] ; l ++ ; } } return S ; }
void minimumK ( vector < int > & arr , int M , int N ) { int good = ceil ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) { int K = i ; int candies = N ; int taken = 0 ; while ( candies > 0 ) { taken += min ( K , candies ) ; candies -= min ( K , candies ) ; for ( int j = 0 ; j < M ; j ++ ) { int consume = ( arr [ j ] * candies ) / 100 ; candies -= consume ; } } if ( taken >= good ) { cout << i ; return ; } } }
void minTimeToColor ( int node , int parent , int arrival_time ) { int current_time = 0 ; for ( auto x : edges [ node ] ) { if ( x != parent ) { ++ current_time ; if ( current_time == arrival_time ) ++ current_time ; ans = max ( ans , current_time ) ; minTimeToColor ( x , node , current_time ) ; } } }
int countElement ( int arr [ ] , int N ) { int count = 0 ; unordered_map < int , int > m ; for ( int i = 0 ; i < N ; i ++ ) { m [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { int lg = log2 ( arr [ i ] ) ; int p = pow ( 2 , lg ) ; if ( m [ p ] ) { count ++ ; } } return count ; }
void findLarger ( int arr [ ] , int n ) { int mid = ( n + 1 ) / 2 ; int mx = * max_element ( arr , arr + n ) ; int count [ mx + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { count [ arr [ i ] ] ++ ; } for ( int i = mx ; i >= 0 ; i -- ) { while ( count [ i ] > 0 ) { count [ i ] -- ; mid -- ; cout << i << ' ' ; if ( mid == 0 ) break ; } if ( mid == 0 ) break ; } }
int maximizeMangoes ( int n , int m , int x , int y ) { int l = 0 , r = n ; int ans = 0 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( check ( n , m , x , y , mid ) ) { ans = mid ; l = mid + 1 ; } else r = mid - 1 ; } return ans ; }
double probability ( vector < int > arr1 , vector < int > arr2 ) { int N = arr1 . size ( ) ; int M = arr2 . size ( ) ; double res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int y = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( arr2 [ j ] > arr1 [ i ] ) y ++ ; } res += y ; } res = ( double ) res / ( double ) ( N * M ) ; return res ; }
float probability ( int * arr1 , int * arr2 ) { int N = 4 ; int M = 4 ; float res = 0 ; sort ( arr2 , arr2 + M ) ; for ( int i = 0 ; i < N ; i ++ ) { int y = countGreater ( arr2 , arr1 [ i ] ) ; res += y ; } res = res / ( N * M ) ; return res ; }
int countGreater ( int * arr , int k ) { int n = 4 ; int l = 0 ; int r = n - 1 ; int leftGreater = n ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; }
int findkthElement ( vector < int > arr , int n , int K ) { int l = 0 ; int h = n - 1 , r ; while ( l + 1 < h ) { int mid = ( l + h ) / 2 ; if ( arr [ l ] >= arr [ mid ] ) l = mid ; else h = mid ; } if ( arr [ l ] < arr [ h ] ) r = l ; else r = h ; if ( K <= r + 1 ) return arr [ r + 1 - K ] ; else return arr [ n - ( K - ( r + 1 ) ) ] ; }
int find ( vector < int > arr , int N , int key ) { int l = 0 ; int h = N - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] >= arr [ mid ] ) { if ( arr [ l ] >= key && key >= arr [ mid ] ) h = mid - 1 ; else l = mid + 1 ; } else { if ( arr [ mid ] >= key && key >= arr [ h ] ) l = mid + 1 ; else h = mid - 1 ; } } return -1 ; }
int countInversions ( int arr [ ] , int n ) { vector < int > v ; for ( int i = 1 ; i <= n ; i ++ ) { v . push_back ( i ) ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { auto itr = lower_bound ( v . begin ( ) , v . end ( ) , arr [ i ] ) ; ans += itr - v . begin ( ) ; v . erase ( itr ) ; } cout << ans ; return 0 ; }
void countDistinct ( vector < int > arr , int L , int R ) { int count = 0 ; int pref [ arr . size ( ) + 1 ] ; for ( int i = 1 ; i <= arr . size ( ) ; ++ i ) { count += arr [ i - 1 ] ; pref [ i ] = count ; } int left = binarysearch ( pref , arr . size ( ) + 1 , L ) ; int right = binarysearch ( pref , arr . size ( ) + 1 , R ) ; cout << right - left + 1 ; }
bool ischar ( char x ) { if ( ( x >= 'A' && x <= 'Z' ) || ( x >= 'a' && x <= 'z' ) ) { return 1 ; } return 0 ; }
bool isnum ( char x ) { if ( x >= '0' && x <= '9' ) return 1 ; return 0 ; }
void maxItems ( int n , int m , int a [ ] , int b [ ] , int K ) { int count = 0 ; int A [ n + 1 ] ; int B [ m + 1 ] ; A [ 0 ] = 0 ; B [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { A [ i ] = a [ i - 1 ] + A [ i - 1 ] ; } for ( int i = 1 ; i <= m ; i ++ ) { B [ i ] = b [ i - 1 ] + B [ i - 1 ] ; } for ( int i = 0 ; i <= n ; i ++ ) { if ( A [ i ] > K ) break ; int rem = K - A [ i ] ; int j = 0 ; int lo = 0 , hi = m ; while ( lo <= hi ) { int mid = ( lo + hi ) / 2 ; if ( B [ mid ] <= rem ) { j = mid ; lo = mid + 1 ; } else { hi = mid - 1 ; } } count = max ( j + i , count ) ; } cout << count ; }
bool isValid ( int weight [ ] , int n , int D , int mx ) { int st = 1 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += weight [ i ] ; if ( sum > mx ) { st ++ ; sum = weight [ i ] ; } if ( st > D ) return false ; } return true ; }
void shipWithinDays ( int weight [ ] , int D , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += weight [ i ] ; int s = weight [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s = max ( s , weight [ i ] ) ; } int e = sum ; int res = -1 ; while ( s <= e ) { int mid = s + ( e - s ) / 2 ; if ( isValid ( weight , n , D , mid ) ) { res = mid ; e = mid - 1 ; } else s = mid + 1 ; } cout << res ; }
int countWays ( int index , int target ) { if ( target == 0 ) return 1 ; if ( index < 0 target < 0  ) return 0 ; int inc = countWays ( index , target - psquare [ index ] ) ; int exc = countWays ( index - 1 , target ) ; return inc + exc ; }
int findSum ( int * arr , int N , int pt ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += abs ( arr [ i ] - pt ) ; } return sum ; }
void findArray ( int arr [ ] , int n ) { vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { int ans = -1 , old_c = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { int curr_c = count ( & arr [ j ] , & arr [ n ] , arr [ j ] ) ; if ( curr_c == old_c ) { if ( arr [ j ] < ans ) ans = arr [ j ] ; } if ( curr_c > old_c ) { ans = arr [ j ] ; old_c = curr_c ; } } } v . push_back ( ans ) ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << " " ; }
void minDays ( vector < int > P , vector < int > arr ) { for ( int i = 1 ; i < P . size ( ) ; i ++ ) { P [ i ] += P [ i ] + P [ i - 1 ] ; } for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { int index = binarySeach ( P , arr [ i ] ) ; if ( index != -1 ) { cout << index + 1 << " " ; } else { cout << -1 << " " ; } } }
int countTriplets ( int D , vector < int > & arr ) { unordered_map < int , int > freq ; int ans = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( freq . find ( arr [ i ] - D ) != freq . end ( ) && freq . find ( arr [ i ] - 2 * D ) != freq . end ( ) ) { ans += freq [ arr [ i ] - D ] * freq [ arr [ i ] - 2 * D ] ; } freq [ arr [ i ] ] ++ ; } return ans ; }
int find_index ( int arr [ ] , int N ) { int max_value = INT_MIN ; for ( int i = 0 ; i < N ; i ++ ) { max_value = max ( max_value , arr [ i ] ) ; } map < int , int > store ; for ( int i = 1 ; i <= max_value ; i ++ ) { store [ i ] ++ ; } if ( store . find ( 1 ) != store . end ( ) ) { store . erase ( 1 ) ; } for ( int i = 2 ; i <= sqrt ( max_value ) ; i ++ ) { int multiple = 2 ; while ( ( i * multiple ) <= max_value ) { if ( store . find ( i * multiple ) != store . end ( ) ) { store . erase ( i * multiple ) ; } multiple ++ ; } } int prime_sum_from_left = 0 ; int first_array [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { first_array [ i ] = prime_sum_from_left ; if ( store . find ( arr [ i ] ) != store . end ( ) ) { prime_sum_from_left += arr [ i ] ; } } int prime_sum_from_right = 0 ; int second_array [ N ] ; for ( int i = N - 1 ; i >= 0 ; i -- ) { second_array [ i ] = prime_sum_from_right ; if ( store . find ( arr [ i ] ) != store . end ( ) ) { prime_sum_from_right += arr [ i ] ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( first_array [ i ] == second_array [ i ] ) { return i ; } } return -1 ; }
void convert ( int arr [ ] , int n ) { int brr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; sort ( brr , brr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { int l = 0 , r = n - 1 , mid ; while ( l <= r ) { mid = ( l + r ) / 2 ; if ( brr [ mid ] == arr [ i ] ) { cout << mid << ' ' ; break ; } else if ( brr [ mid ] < arr [ i ] ) { l = mid + 1 ; } else { r = mid - 1 ; } } } }
int findIndex ( int arr [ ] , int N ) { int maxValue = INT_MIN ; for ( int i = 0 ; i < N ; i ++ ) { maxValue = max ( maxValue , arr [ i ] ) ; } map < int , int > St ; for ( int i = 1 ; i <= maxValue ; i ++ ) { St [ i ] ++ ; } if ( St . find ( 1 ) != St . end ( ) ) { St . erase ( 1 ) ; } for ( int i = 2 ; i <= sqrt ( maxValue ) ; i ++ ) { int j = 2 ; while ( ( i * j ) <= maxValue ) { if ( St . find ( i * j ) != St . end ( ) ) { St . erase ( i * j ) ; } j ++ ; } } int LeftCount = 0 ; int Prefix [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { Prefix [ i ] = LeftCount ; if ( St . find ( arr [ i ] ) != St . end ( ) ) { LeftCount ++ ; } } int RightCount = 0 ; int Suffix [ N ] ; for ( int i = N - 1 ; i >= 0 ; i -- ) { Suffix [ i ] = RightCount ; if ( St . find ( arr [ i ] ) != St . end ( ) ) { RightCount ++ ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( Prefix [ i ] == Suffix [ i ] ) { return i ; } } return -1 ; }
int getCountPairs ( vector < int > arr , int N , int S ) { int count = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < arr . size ( ) ; j ++ ) { if ( ( arr [ i ] + arr [ j ] ) == S ) count ++ ; } } return count ; }
bool isPrime ( int N ) { if ( N == 1 ) return false ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; }
int findCoPrime ( int L , int R ) { int coPrime ; for ( int i = R + 1 ; ; i ++ ) { if ( isPrime ( i ) ) { coPrime = i ; break ; } } return coPrime ; }
void replaceCharacters ( string s , vector < vector < char > > p ) { int n = s . size ( ) , k = p . size ( ) ; char arr [ 26 ] ; char brr [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ s [ i ] - 'a' ] = s [ i ] ; brr [ s [ i ] - 'a' ] = s [ i ] ; } for ( int j = 0 ; j < k ; j ++ ) { char a = p [ j ] [ 0 ] , b = p [ j ] [ 1 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( arr [ i ] == a ) { brr [ i ] = b ; } } } for ( int i = 0 ; i < n ; i ++ ) { cout << brr [ s [ i ] - 'a' ] ; } }
void maximumValue ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { ans = max ( ans , arr [ i ] + arr [ j ] + i - j ) ; } } cout << ans ; }
void maximumValue ( int arr [ ] , int n ) { int maxvalue = arr [ 0 ] ; int result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { result = max ( result , maxvalue + arr [ i ] - i ) ; maxvalue = max ( maxvalue , arr [ i ] + i ) ; } cout << result ; }
void smallestSemiPrime ( int n ) { bool prime [ MAX ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime ) ; int num1 = n + 1 ; while ( prime [ num1 ] != true ) { num1 ++ ; } int num2 = num1 + n ; while ( prime [ num2 ] != true ) { num2 ++ ; } cout << num1 * 1LL * num2 ; }
void productOfTwoPerfectCubes ( int N ) { map < int , int > cubes ; for ( int i = 1 ; i * i * i <= N ; i ++ ) cubes [ i * i * i ] = i ; for ( auto itr = cubes . begin ( ) ; itr != cubes . end ( ) ; itr ++ ) { int firstNumber = itr -> first ; if ( N % itr -> first == 0 ) { int secondNumber = N / itr -> first ; if ( cubes . find ( secondNumber ) != cubes . end ( ) ) { cout << "Yes" ; return ; } } } cout << "No" ; }
void productOfTwoPerfectCubes ( int N ) { int cube_root ; cube_root = round ( cbrt ( N ) ) ; if ( cube_root * cube_root * cube_root == N ) { cout << "Yes" ; return ; } else { cout << "No" ; return ; } }
bool bound ( int w , int h , int N , int x ) { int val = ( x / w ) * ( x / h ) ; if ( val >= N ) return true ; else return false ; }
int FindSquare ( int N , int W , int H ) { int i = 1 ; int j = W * H * N ; while ( i < j ) { int mid = i + ( j - i ) / 2 ; if ( bound ( W , H , N , mid ) ) j = mid ; else i = mid + 1 ; } return j ; }
void printNumberOfPairs ( int N ) { unordered_set < int > st ; for ( int i = 2 ; i * i <= N ; i ++ ) { int x = i ; while ( x <= N ) { x *= i ; if ( x <= N ) { st . insert ( x ) ; } } } cout << st . size ( ) ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }
void maximumProduct ( vector < string > words ) { vector < int > bits ( words . size ( ) , 0 ) ; for ( int i = 0 ; i < words . size ( ) ; i ++ ) { for ( int j = 0 ; j < words [ i ] . length ( ) ; j ++ ) { bits [ i ] = bits [ i ] | 1 << ( words [ i ] [ j ] - 'a' ) ; } } int result = 0 ; for ( int i = 0 ; i < bits . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < bits . size ( ) ; j ++ ) { if ( ( bits [ i ] & bits [ j ] ) == 0 ) { int L = countSetBits ( bits [ i ] ) ; int R = countSetBits ( bits [ j ] ) ; result = max ( L * R , result ) ; } } } cout << result ; }
int closestValue ( vector < int > A , int k ) { int close = A . back ( ) ; auto it = lower_bound ( A . begin ( ) , A . end ( ) , k ) ; if ( it != A . end ( ) ) { close = * it ; if ( it != A . begin ( ) ) { if ( ( k - * ( it - 1 ) ) < ( close - k ) ) { close = * ( it - 1 ) ; } } } return close ; }
void minPossible ( vector < int > arr , vector < int > brr , vector < int > crr ) { sort ( arr . begin ( ) , arr . end ( ) ) ; sort ( crr . begin ( ) , crr . end ( ) ) ; int minimum = INT_MAX ; for ( int val : brr ) { int arr_close = closestValue ( arr , val ) ; int crr_close = closestValue ( crr , val ) ; if ( abs ( val - arr_close ) + abs ( val - crr_close ) < minimum ) minimum = abs ( val - arr_close ) + abs ( val - crr_close ) ; } cout << minimum ; }
int findCost ( int A [ ] , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; }
function palindrome ( str ) { var st = 0 ; var ed = str . length - 1 ; while ( st < ed ) { if ( str [ st ] == str [ ed ] ) { st ++ ; ed -- ; } else return false ; } return true ; }
int possible ( int A [ ] , int N , int mid , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { count += ( A [ i ] - 1 ) / mid ; } return count <= K ; }
int minimumMaximum ( int A [ ] , int N , int K ) { int lo = 1 ; int hi = * max_element ( A , A + N ) ; int mid ; while ( lo < hi ) { mid = ( lo + hi ) / 2 ; if ( possible ( A , N , mid , K ) ) { hi = mid ; } else { lo = mid + 1 ; } } return hi ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
void sumOfPrimeSquare ( int n ) { int i = 0 ; vector < int > squares ; while ( i * i < n ) { squares . push_back ( i * i ) ; i ++ ; } bool flag = false ; for ( i = 0 ; i < squares . size ( ) ; i ++ ) { int difference = n - squares [ i ] ; if ( isPrime ( difference ) ) { flag = true ; break ; } } if ( flag ) { cout << "Yes" ; } else cout << "No" ; }
void SieveOfEratosthenes ( bool prime [ ] , int n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } }
void sumOfPrimeSquare ( int n ) { bool flag = false ; bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , n ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ! prime [ i ] ) continue ; int dif = n - i ; if ( ceil ( ( double ) sqrt ( dif ) ) == floor ( ( double ) sqrt ( dif ) ) ) { flag = true ; break ; } } if ( flag ) { cout << "Yes" ; } else cout << "No" ; }
int minimum_swaps ( int arr [ ] , int n ) { int count = 0 ; int max_el = * max_element ( arr , arr + n ) ; int min_el = * min_element ( arr , arr + n ) ; if ( min_el == max_el ) return 0 ; int index_max = -1 ; int index_min = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max_el && index_max == -1 ) { index_max = i ; } if ( arr [ i ] == min_el ) { index_min = i ; } } count += index_max ; count += ( n - 1 - index_min ) ; if ( index_min < index_max ) count -= 1 ; return count ; }
bool check ( int arr [ ] , int M , int K , int ind ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 1 ; j < K ; j ++ ) { if ( arr [ ind + i ] != arr [ ind + i + j * M ] ) { return false ; } } } return true ; }
bool SubarrayRepeatsKorMore ( int arr [ ] , int N , int M , int K ) { for ( int ind = 0 ; ind <= N - M * K ; ind ++ ) { if ( check ( arr , M , K , ind ) ) { return true ; } } return false ; }
bool checkExists ( int arr [ ] , int N , int M , int K ) { int count = 0 ; for ( int i = 0 ; i < N - M ; i ++ ) { if ( arr [ i ] == arr [ i + M ] ) count ++ ; else count = 0 ; if ( count == M * ( K - 1 ) ) return true ; } return false ; }
int CommonDigits ( int N , int M ) { int count = 0 ; int freq1 [ 10 ] = { 0 } ; int freq2 [ 10 ] = { 0 } ; while ( N > 0 ) { freq1 [ N % 10 ] ++ ; N = N / 10 ; } while ( M > 0 ) { freq2 [ M % 10 ] ++ ; M = M / 10 ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( freq1 [ i ] > 0 & freq2 [ i ] > 0 ) { count ++ ; } } return count ; }
void minimumNumber ( int K , int X ) { if ( K > X ) { cout << "-1" ; return ; } int ans = 0 ; int sum = 0 ; for ( int i = K ; i <= X ; i ++ ) { sum += i ; if ( sum >= X ) { ans = i ; break ; } } cout << ans ; }
bool isGreaterEqual ( int N , int K , int X ) { return ( ( N * 1LL * ( N + 1 ) / 2 ) - ( ( K - 1 ) * 1LL * K / 2 ) ) >= X ; }
int left_search ( vector < int > A , int num ) { int low = 0 , high = A . size ( ) - 1 ; int ans = 0 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( A [ mid ] >= num ) { ans = mid ; high = mid - 1 ; } else { low = mid + 1 ; } } return ans ; }
void totalCount ( vector < vector < int > > A , int N , int M , vector < vector < int > > queries , int Q ) { vector < int > row_sum ( N ) ; vector < int > col_sum ( N ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { row_sum [ i ] += A [ i ] [ j ] ; col_sum [ j ] += A [ i ] [ j ] ; } } vector < int > sum_list ; for ( int i = 0 ; i < N ; i ++ ) sum_list . push_back ( row_sum [ i ] ) ; for ( int i = 0 ; i < M ; i ++ ) sum_list . push_back ( col_sum [ i ] ) ; sort ( sum_list . begin ( ) , sum_list . end ( ) ) ; for ( int i = 0 ; i < Q ; i ++ ) { int L = queries [ i ] [ 0 ] ; int R = queries [ i ] [ 1 ] ; int l = left_search ( sum_list , L ) ; int r = right_search ( sum_list , R ) ; cout << r - l + 1 << " " ; } }
static int search ( vector < int > list , int num ) { int low = 0 , high = list . size ( ) - 1 ; int ans = -1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( list [ mid ] <= num ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; }
bool isPalindrome ( int n ) { int rev = 0 ; int temp = n ; while ( n > 0 ) { rev = rev * 10 + n % 10 ; n /= 10 ; } return rev == temp ; }
int countNumbers ( int L , int R , int K ) { vector < int > list ; for ( int i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) ) { list . push_back ( i ) ; } } int count = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { int right_index = search ( list , list [ i ] + K - 1 ) ; if ( right_index != -1 ) count = max ( count , right_index - i + 1 ) ; } return count ; }
int maximumLength ( vector < vector < int > > & mat , int V ) { int distance = 0 ; int N = ( int ) mat . size ( ) ; vector < int > Adj [ N ] ; vector < bool > visited ( N , false ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { Adj [ i ] . push_back ( j ) ; } } } dfs ( V , Adj , visited , 0 , distance ) ; return distance ; }
void getMaximumDifference ( int Edges [ ] [ 2 ] , int arr [ ] , int N , int M ) { vector < int > Adj [ N + 1 ] ; for ( int i = 0 ; i < M ; i ++ ) { int u = Edges [ i ] [ 0 ] ; int v = Edges [ i ] [ 1 ] ; Adj [ u ] . push_back ( v ) ; } int ans = 0 ; DFS ( 1 , Adj , ans , arr , arr [ 0 ] , arr [ 0 ] ) ; cout << ans ; }
int minimumDeletions ( string S ) { int len = 0 ; int n = S . length ( ) ; for ( char i = 'a' ; i <= 'z' ; i ++ ) { for ( char j = i + 1 ; j <= 'z' ; j ++ ) { int newLen = findLength ( S , i , j ) ; len = max ( len , newLen ) ; } } return n - len ; }
int findMinX ( int A [ ] , int B [ ] , int N ) { int prod = 1 ; for ( int i = 0 ; i < N ; i ++ ) prod *= A [ i ] ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int pp = prod / A [ i ] ; result += B [ i ] * inv ( pp , A [ i ] ) * pp ; } return result % prod ; }
void findPairs ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = abs ( arr [ i ] ) ; sort ( arr , arr + N ) ; int left = 0 ; int ans = 0 ; for ( int right = 0 ; right < N ; right ++ ) { while ( 2 * arr [ left ] < arr [ right ] ) left ++ ; ans += ( right - left ) ; } cout << ans ; }
int GetDiff ( int A [ ] , int N ) { int SuffMaxArr [ N ] ; SuffMaxArr [ N - 1 ] = A [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; -- i ) { SuffMaxArr [ i ] = max ( SuffMaxArr [ i + 1 ] , A [ i + 1 ] ) ; } int MaximumSum = INT_MIN ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] < SuffMaxArr [ i ] ) MaximumSum = max ( MaximumSum , A [ i ] + SuffMaxArr [ i ] ) ; } int MinimumSum = INT_MAX ; int SuffMinArr [ N ] ; SuffMinArr [ N - 1 ] = INT_MAX ; for ( int i = N - 2 ; i >= 0 ; -- i ) { SuffMinArr [ i ] = min ( SuffMinArr [ i + 1 ] , A [ i + 1 ] ) ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] < SuffMinArr [ i ] ) { MinimumSum = min ( MinimumSum , A [ i ] + SuffMinArr [ i ] ) ; } } return abs ( MaximumSum - MinimumSum ) ; }
void minimumSwaps ( int arr [ ] , int N ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != i % 2 ) { if ( i % 2 == 0 ) { even ++ ; } else { odd ++ ; } } } if ( even != odd ) { cout << -1 ; } else { cout << even ; } }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
void primeFactorSum ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( k % arr [ i ] == 0 && isPrime ( arr [ i ] ) ) { sum = sum + arr [ i ] ; } } cout << sum ; }
void CalculateValues ( int N ) { int A = 0 , B = 0 , C = 0 ; for ( C = 0 ; C < N / 7 ; C ++ ) { for ( B = 0 ; B < N / 5 ; B ++ ) { int A = N - 7 * C - 5 * B ; if ( A >= 0 && A % 3 == 0 ) { cout << "A = " << A / 3 << ", B = " << B << ", C = " << C << endl ; return ; } } } cout << -1 << endl ; }
int mininsert ( int arr [ ] , int K , int N ) { int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int a = min ( arr [ i ] , arr [ i + 1 ] ) ; int b = max ( arr [ i ] , arr [ i + 1 ] ) ; while ( K * a < b ) { a *= K ; ans ++ ; } } return ans ; }
void makeLexicographically ( int arr [ ] , int N ) { int index = 0 ; int temp = 0 ; int check = 0 ; int condition = 0 ; int element = 0 ; for ( int i = 0 ; i < N ; ++ i ) { if ( element == arr [ i ] ) { check = i ; break ; } else if ( arr [ i ] != i + 1 && check == 0 ) { index = i ; check = 1 ; condition = -1 ; element = i + 1 ; } } if ( condition == -1 ) { temp = arr [ index ] ; arr [ index ] = arr [ check ] ; arr [ check ] = temp ; } print ( arr , N ) ; }
void print_triplet ( int arr [ ] , int n ) { for ( int i = 1 ; i <= n - 2 ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] && arr [ i ] > arr [ i + 1 ] ) { cout << i - 1 << " " << i << " " << i + 1 ; return ; } } cout << -1 ; }
void findConcatenatedNumbers ( vector < int > a , vector < int > b ) { bool ans = true ; int n1 = a . size ( ) ; int n2 = b . size ( ) ; unordered_map < int , int > cnt ; for ( int i = 0 ; i < n1 ; i ++ ) { cnt [ a [ i ] ] = 1 ; } for ( int i = 0 ; i < n2 ; i ++ ) { int left = b [ i ] ; int right = 0 ; int mul = 1 ; while ( left > 9 ) { right += ( left % 10 ) * mul ; left /= 10 ; mul *= 10 ; if ( cnt [ left ] == 1 && cnt [ right ] == 1 ) { ans = false ; cout << b [ i ] << " " ; } } } if ( ans ) cout << "-1" ; }
void evenproduct ( int arr [ ] , int length ) { int count = 0 ; for ( int i = 0 ; i < length + 1 ; i ++ ) { int product = 1 ; for ( int j = i ; j < length + 1 ; j ++ ) { product *= arr [ j ] ; if ( product % 2 == 0 ) ++ count ; } } cout << count ; }
void evenproduct ( int arr [ ] , int length ) { int total_subarray = length * ( length + 1 ) / 2 ; int total_odd = 0 ; int count_odd = 0 ; for ( int i = 0 ; i < length ; ++ i ) { if ( arr [ i ] % 2 == 0 ) { count_odd = 0 ; } else { ++ count_odd ; total_odd += count_odd ; } } cout << ( total_subarray - total_odd ) << endl ; }
void dfsUtil ( int u , int par , int depth ) { for ( auto it : adj [ u ] ) { if ( it != par ) { dfsUtil ( it , u , depth + 1 ) ; } } ans += depth ; }
bool isInGroupUtil ( vector < vector < int > > mat ) { for ( auto i : mat ) { if ( ! checkGroup ( i ) ) return false ; } return true ; }
void isInGroup ( vector < vector < int > > mat ) { bool ans = isInGroupUtil ( mat ) ; if ( ans ) printf ( "Yes" ) ; else printf ( "No" ) ; }
int convertBinaryToDecimal ( vector < int > arr ) { int ans = 0 ; for ( int i : arr ) ans = ( ans << 1 ) | i ; return ans ; }
void decimalEquilvalentAtEachLevel ( TreeNode * root ) { int ans = 0 ; queue < TreeNode * > que ; que . push ( root ) ; while ( true ) { int length = que . size ( ) ; if ( length == 0 ) break ; vector < int > eachLvl ; while ( length > 0 ) { TreeNode * temp = que . front ( ) ; que . pop ( ) ; eachLvl . push_back ( temp -> val ) ; if ( temp -> left != NULL ) que . push ( temp -> left ) ; if ( temp -> right != NULL ) que . push ( temp -> right ) ; length -= 1 ; } ans += convertBinaryToDecimal ( eachLvl ) ; } cout << ans << endl ; }
void countSubstrings ( string s ) { int ans = 0 ; int subs = 1 ; char pre = '0' ; for ( auto & i : s ) { if ( pre == i ) { subs += 1 ; } else { subs = 1 ; } ans += subs ; pre = i ; } cout << ans << endl ; }
void longestSequence ( int arr [ ] , int N ) { if ( N == 0 ) { cout << 0 ; return ; } sort ( arr , arr + N ) ; int maxLen = 1 ; int len = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] arr [ i ] == arr [ i - 1 ] + 1 ) { len ++ ; maxLen = max ( maxLen , len ) ; } else { len = 1 ; } } cout << maxLen ; }
void minimumOperations ( int arr [ ] , int N ) { int oddCnt = 0 , evenCnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { evenCnt ++ ; } else { oddCnt ++ ; } } cout << min ( oddCnt , evenCnt ) ; }
int productOfDigits ( int N ) { int product = 1 ; while ( N != 0 ) { product = product * ( N % 10 ) ; N = N / 10 ; } return product ; }
void hasArrayTwoPairs ( int nums [ ] , int n , int target ) { sort ( nums , nums + n ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = target - nums [ i ] ; int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = low + ( ( high - low ) / 2 ) ; if ( nums [ mid ] > x ) { high = mid - 1 ; } else if ( nums [ mid ] < x ) { low = mid + 1 ; } else { if ( mid == i ) { if ( ( mid - 1 >= 0 ) && nums [ mid - 1 ] == x ) { cout << nums [ i ] << ", " ; cout << nums [ mid - 1 ] ; return ; } if ( ( mid + 1 < n ) && nums [ mid + 1 ] == x ) { cout << nums [ i ] << ", " ; cout << nums [ mid + 1 ] ; return ; } break ; } else { cout << nums [ i ] << ", " ; cout << nums [ mid ] ; return ; } } } } cout << -1 ; }
void minSum ( int arr [ ] , int N , int Q [ ] , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int val = Q [ i ] ; int front = 0 , rear = 0 ; for ( int j = 0 ; j < N ; j ++ ) { front += arr [ j ] ; if ( arr [ j ] == val ) { break ; } } for ( int j = N - 1 ; j >= 0 ; j -- ) { rear += arr [ j ] ; if ( arr [ j ] == val ) { break ; } } cout << min ( front , rear ) << " " ; } }
void minOperations ( int arr [ ] , int N , int Q [ ] , int M ) { map < int , int > m1 , m2 ; int front = 0 , rear = 0 ; for ( int i = 0 ; i < N ; i ++ ) { front += arr [ i ] ; m1 . insert ( { arr [ i ] , front } ) ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { rear += arr [ i ] ; m2 . insert ( { arr [ i ] , rear } ) ; } for ( int i = 0 ; i < M ; i ++ ) { cout << min ( m1 [ Q [ i ] ] , m2 [ Q [ i ] ] ) << " " ; } }
bool checkAnagram ( string s1 , string s2 ) { vector < int > s2hash ( 26 , 0 ) ; vector < int > s1hash ( 26 , 0 ) ; int s1len = s1 . size ( ) ; int s2len = s2 . size ( ) ; if ( s1len > s2len ) return false ; int left = 0 , right = 0 ; while ( right < s1len ) { s1hash [ s1 [ right ] - 'a' ] += 1 ; s2hash [ s2 [ right ] - 'a' ] += 1 ; right ++ ; } right -= 1 ; while ( right < s2len ) { if ( s1hash == s2hash ) return true ; right ++ ; if ( right != s2len ) s2hash [ s2 [ right ] - 'a' ] += 1 ; s2hash [ s2 [ left ] - 'a' ] -= 1 ; left ++ ; } return false ; }
void findSubstring ( string S ) { string T = "" ; string ans = "" ; int l = 0 ; T += S [ 0 ] ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { if ( abs ( S [ i ] - S [ i - 1 ] ) == 1 ) { l = T . length ( ) ; if ( l > ans . length ( ) ) { ans = T ; } T = "" ; T += S [ i ] ; } else { T += S [ i ] ; } } l = ( int ) T . length ( ) ; if ( l > ( int ) ans . length ( ) ) { ans = T ; } cout << ans << endl ; }
void DFS ( int row , int col , vector < vector < int > > grid , int M , int N ) { vector < vector < bool > > vis ( M + 1 , vector < bool > ( N + 1 , false ) ) ; DFSUtil ( 0 , 0 , grid , vis , M , N ) ; }
void DFS_iterative ( vector < vector < int > > grid , int M , int N ) { vector < vector < bool > > vis ( M + 5 , vector < bool > ( N + 5 , false ) ) ; stack < pair < int , int > > st ; st . push ( { 0 , 0 } ) ; vis [ 0 ] [ 0 ] = true ; while ( ! st . empty ( ) ) { pair < int , int > p = st . top ( ) ; st . pop ( ) ; int row = p . first ; int col = p . second ; cout << grid [ row ] [ col ] << " " ; for ( int i = 0 ; i < 4 ; i ++ ) { int x = row + dRow [ i ] ; int y = col + dCol [ i ] ; if ( isValid ( vis , x , y , M , N ) ) { st . push ( { x , y } ) ; vis [ x ] [ y ] = true ; } } } }
void suffixArr ( int arr [ ] , int suffix [ ] [ 2 ] , int N ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 ) { suffix [ i ] [ 0 ] = arr [ i ] ; suffix [ i ] [ 1 ] = arr [ i ] ; } else { suffix [ i ] [ 0 ] = max ( suffix [ i + 1 ] [ 0 ] , arr [ i ] ) ; suffix [ i ] [ 1 ] = min ( suffix [ i + 1 ] [ 1 ] , arr [ i ] ) ; } } }
void MinMaxQueries ( int a [ ] , int Q [ ] [ ] ) { int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; int prefix [ N ] [ 2 ] ; int suffix [ N ] [ 2 ] ; prefixArr ( arr , prefix , N ) ; suffixArr ( arr , suffix , N ) ; for ( int i = 0 ; i < q ; i ++ ) { int L = queries [ i ] [ 0 ] ; int R = queries [ i ] [ 1 ] ; maxAndmin ( prefix , suffix , N , L , R ) ; } }
bool check ( int a [ ] , int n ) { bool flag = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i + 1 ] > a [ i ] && a [ i ] < a [ i - 1 ] ) flag = 1 ; } if ( flag ) return false ; else return true ; }
void smallestNumber ( int arr [ ] , int len ) { int maxi = 0 ; for ( int i = 0 ; i < len ; i ++ ) { maxi = std :: max ( maxi , arr [ i ] ) ; } int ans = -1 ; for ( int i = 2 ; i < maxi + 2 ; i ++ ) { bool flag = true ; for ( int j = 0 ; j < len ; j ++ ) { if ( arr [ j ] % i == 0 ) { flag = false ; break ; } } if ( flag ) { ans = i ; break ; } } cout << ans ; }
void findDuplicate ( string str , int N ) { int first = 0 ; int second = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( first & ( 1 << ( str [ i ] - 'a' ) ) ) { second = second | ( 1 << ( str [ i ] - 'a' ) ) ; } else { first = first | ( 1 << ( str [ i ] - 'a' ) ) ; } } for ( int i = 0 ; i < 26 ; i ++ ) { if ( ( first & ( 1 << i ) ) && ( second & ( 1 << i ) ) ) { cout << char ( i + 'a' ) << " " ; } } }
int minOperations ( string & S ) { int count = 0 ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { if ( S [ i ] != S [ i - 1 ] ) { count += 1 ; } } cout << count ; }
bool check ( int N ) { if ( N == 0 ) return 0 ; return ! ( N & ( N - 1 ) ) ; }
void build_seg_tree ( int ss , int se , int si , int tree [ ] , int arr [ ] ) { if ( ss == se ) { tree [ si ] = check ( arr [ ss ] ) ; return ; } int mid = ( ss + se ) / 2 ; build_seg_tree ( ss , mid , 2 * si + 1 , tree , arr ) ; build_seg_tree ( mid + 1 , se , 2 * si + 2 , tree , arr ) ; tree [ si ] = tree [ 2 * si + 1 ] + tree [ 2 * si + 2 ] ; }
int query ( int l , int r , int ss , int se , int si , int tree [ ] ) { if ( r < ss l > se ) return 0 ; if ( l <= ss && r >= se )  return tree [ si ] ; int mid = ( ss + se ) / 2 ; return query ( l , r , ss , mid , 2 * si + 1 , tree ) + query ( l , r , mid + 1 , se , 2 * si + 2 , tree ) ; }
void numberOfPairs ( int arr [ ] , int N ) { int set_bits [ 31 ] = { 0 } ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int x = arr [ i ] ; int bitpos = -1 ; while ( x > 0 ) { bitpos ++ ; x /= 2 ; } for ( int j = 0 ; j <= bitpos ; j ++ ) { count += set_bits [ j ] ; } set_bits [ bitpos ] ++ ; } cout << count ; }
void calculateQuery ( int arr [ ] , int N , int query [ ] , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int X = query [ i ] ; int sum_start = 0 , sum_end = 0 ; for ( int j = 0 ; j < N ; j ++ ) { sum_start += arr [ j ] ; if ( arr [ j ] == X ) break ; } for ( int j = N - 1 ; j >= 0 ; j -- ) { sum_end += arr [ j ] ; if ( arr [ j ] == X ) break ; } cout << min ( sum_end , sum_start ) << " " ; } }
void calculateQuery ( int arr [ ] , int N , int query [ ] , int M ) { int prefix = 0 , suffix = 0 ; unordered_map < int , pair < int , int > > mp ; for ( int i = 0 ; i < N ; i ++ ) { prefix += arr [ i ] ; mp [ arr [ i ] ] . first = prefix ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { suffix += arr [ i ] ; mp [ arr [ i ] ] . second = suffix ; } for ( int i = 0 ; i < M ; i ++ ) { int X = query [ i ] ; cout << min ( mp [ X ] . first , mp [ X ] . second ) << " " ; } }
void minOps ( string s , int N ) { int ans = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( s [ i ] != s [ i - 1 ] ) { ans ++ ; } } if ( ans % 2 == 1 ) { cout << ( ans - 1 ) / 2 << endl ; return ; } cout << ( ans / 2 ) ; }
int oddOneOut ( int arr [ ] , int N ) { int odd = 0 , even = 0 ; int lastOdd = 0 , lastEven = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { even ++ ; lastEven = i ; } else { odd ++ ; lastOdd = i ; } } if ( odd == 1 ) { cout << lastOdd << endl ; } else { cout << lastEven << endl ; } }
void mulsum ( int arr [ ] , int n , int N ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % N == 0 ) { sum = sum + arr [ i ] ; } } cout << sum ; }
bool isGreaterEqual ( int N , int X ) { return ( N * 1LL * ( N + 1 ) / 2 ) >= X ; }
int minimumPossible ( int X ) { for ( int i = 1 ; i <= X ; i ++ ) { if ( isGreaterEqual ( i , X ) ) return i ; } }
bool isGreaterEqual ( int N , int X ) { return ( N * 1LL * ( N + 1 ) / 2 ) >= X ; }
int minimumPossible ( int X ) { int low = 1 , high = X , res = -1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( isGreaterEqual ( mid , X ) ) { res = mid ; high = mid - 1 ; } else low = mid + 1 ; } return res ; }
bool CheckDivByAllDigits ( int number ) { int n = number ; while ( n > 0 ) { if ( n % 10 ) if ( number % ( n % 10 ) ) { return false ; } n /= 10 ; } return true ; }
void cntNumInRang ( int arr [ ] [ 2 ] , int N ) { int prefCntDiv [ Max ] = { 0 } ; for ( int i = 1 ; i <= Max ; i ++ ) { prefCntDiv [ i ] = prefCntDiv [ i - 1 ] + ( CheckDivByAllDigits ( i ) ) ; } for ( int i = 0 ; i < N ; i ++ ) cout << ( prefCntDiv [ arr [ i ] [ 1 ] ] - prefCntDiv [ arr [ i ] [ 0 ] - 1 ] ) << " " ; }
int arrayNesting ( vector < int > arr ) { int res = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( arr [ i ] == i ) { res = max ( res , 1 ) ; } else { int count = 0 ; int curr_index = i ; while ( arr [ curr_index ] != curr_index ) { int next_index = arr [ curr_index ] ; arr [ curr_index ] = curr_index ; curr_index = next_index ; count ++ ; } res = max ( res , count ) ; } } return res ; }
void count ( int a [ ] , int n ) { if ( n == 1 ) { cout << 0 ; return ; } int pre [ n - 1 ] , suf [ n - 1 ] ; int max = a [ 0 ] ; int ans = 0 , i ; pre [ 0 ] = a [ 0 ] ; for ( i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i ] > max ) max = a [ i ] ; pre [ i ] = max ; } max = a [ n - 1 ] ; suf [ n - 2 ] = a [ n - 1 ] ; for ( i = n - 2 ; i >= 1 ; i -- ) { if ( a [ i ] > max ) max = a [ i ] ; suf [ i - 1 ] = max ; } for ( i = 0 ; i < n - 1 ; i ++ ) { if ( pre [ i ] < suf [ i ] ) ans ++ ; } cout << ans ; }
void countNumbers ( long long int L , long long int R ) { int Count = 0 ; for ( int p : prime ) { if ( p >= L && p <= R ) { Count ++ ; } } cout << Count << endl ; }
int xorSubsequence ( int a [ ] , int n , int k ) { int ans = 0 ; map < int , int > map ; int dp [ n ] = { 0 } ; map [ a [ 0 ] ] = 1 ; dp [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { int dpj ; if ( map . find ( a [ i ] ^ k ) != map . end ( ) ) { dpj = map [ a [ i ] ^ k ] ; } else { dpj = -1 ; } if ( dpj != 0 ) dp [ i ] = max ( dp [ i ] , dpj + 1 ) ; ans = max ( ans , dp [ i ] ) ; if ( map . find ( a [ i ] ) != map . end ( ) ) { map [ a [ i ] ] = max ( map [ a [ i ] ] + 1 , dp [ i ] ) ; } else { map [ a [ i ] ] = max ( 1 , dp [ i ] ) ; } } return ans >= 2 ? ans : 0 ; }
void distance ( TreeNode * root , int target , int distancesum , int n ) { if ( root -> data == target ) { sum = distancesum ; } if ( root -> left ) { int tempsum = distancesum - root -> left -> size + ( n - root -> left -> size ) ; distance ( root -> left , target , tempsum , n ) ; } if ( root -> right ) { int tempsum = distancesum - root -> right -> size + ( n - root -> right -> size ) ; distance ( root -> right , target , tempsum , n ) ; } }
void countRemainingElements ( int L1 [ ] , int L2 [ ] , int n ) { int one = 0 ; int zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( L1 [ i ] == 1 ) one ++ ; else zero ++ ; } int ans = n ; for ( int i = 0 ; i < n ; i ++ ) { if ( L2 [ i ] == 1 ) { one -- ; if ( one < 0 ) { ans = i ; break ; } } else { zero -- ; if ( zero < 0 ) { ans = i ; break ; } } } cout << n - ans ; }
void minTime ( vector < int > arr , int N , int K ) { queue < int > q ; vector < bool > vis ( N + 1 , false ) ; int time = 0 ; for ( int i = 0 ; i < K ; i ++ ) { q . push ( arr [ i ] ) ; vis [ arr [ i ] ] = true ; } while ( q . size ( ) > 0 ) { for ( int i = 0 ; i < q . size ( ) ; i ++ ) { int curr = q . front ( ) ; q . pop ( ) ; if ( curr - 1 >= 1 && ! vis [ curr - 1 ] ) { vis [ curr - 1 ] = true ; q . push ( curr - 1 ) ; } if ( curr + 1 <= N && ! vis [ curr + 1 ] ) { vis [ curr + 1 ] = true ; q . push ( curr + 1 ) ; } } time ++ ; } cout << ( time - 1 ) ; }
int getCount ( int rows , int columns , int A [ ] [ 2 ] ) { int res = 0 ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = i + 1 ; j < rows ; j ++ ) { if ( A [ i ] [ 0 ] * 1LL * A [ j ] [ 1 ] == A [ i ] [ 1 ] * 1LL * A [ j ] [ 0 ] ) { res ++ ; } } } return res ; }
void Min_Score_Index ( int N , vector < int > A ) { vector < int > Score ( N , 0 ) ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( A [ i ] + i < N ) Score [ i ] = A [ i ] * Score [ A [ i ] + i ] ; else Score [ i ] = A [ i ] ; } int min_value = INT_MAX ; for ( int i : Score ) min_value = min ( i , min_value ) ; int ind = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( Score [ i ] == min_value ) ind = i ; } cout << ( ind ) ; }
void minLength ( string & S , string & T , int N , int M ) { string temp ; int subtract = 0 ; for ( int i = 0 ; i < N ; ++ i ) { temp . push_back ( S [ i ] ) ; if ( temp . size ( ) >= M ) { if ( temp . substr ( temp . size ( ) - M , M ) == T ) { subtract += M ; int cnt = 0 ; while ( cnt != M ) { temp . pop_back ( ) ; ++ cnt ; } } } } cout << ( N - subtract ) << "\n" ; }
int maximumCount ( int arr1 [ ] , int arr2 [ ] , int s1 , int s2 ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < s1 ; i ++ ) { sum1 += arr1 [ i ] ; } for ( int j = 0 ; j < s2 ; j ++ ) { sum2 += arr2 [ j ] ; } int len = 0 ; if ( s1 >= s2 ) { len = s2 ; } else { len = s1 ; } sort ( arr1 , arr1 + s1 ) ; sort ( arr2 , arr2 + s2 ) ; int j = 0 , k = s2 - 1 , count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( sum1 <= sum2 ) { if ( arr2 [ k ] >= arr1 [ i ] ) { int dif1 = arr1 [ j ] , dif2 = arr2 [ k ] ; sum1 -= dif1 ; sum1 += dif2 ; sum2 -= dif2 ; sum2 += dif1 ; j ++ ; k -- ; count ++ ; } else { break ; } } else { break ; } } return count ; }
static int noOfValidKbers ( int K , vector < int > arr ) { map < int , int > set ; while ( K != 0 ) { set [ K % 10 ] = 1 ; K = K / 10 ; } int count = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { int no = arr [ i ] ; bool flag = true ; while ( no != 0 ) { int digit = no % 10 ; if ( set . find ( digit ) == set . end ( ) ) { flag = false ; break ; } no = no / 10 ; } if ( flag == true ) { count ++ ; } } return count ; }
void build ( int arr [ ] , int index , int s , int e ) { if ( s == e ) Tree [ index ] = arr [ s ] ; else { int m = ( s + e ) / 2 ; build ( arr , 2 * index , s , m ) ; build ( arr , 2 * index + 1 , m + 1 , e ) ; Tree [ index ] = max ( Tree [ 2 * index ] , Tree [ 2 * index + 1 ] ) ; } }
bool isSubarrayExistUtil ( int arr [ ] , int K , int N ) { int totalXOR = 0 ; int SubarrayXOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) totalXOR ^= arr [ i ] ; for ( int i = 0 ; i < K ; i ++ ) SubarrayXOR ^= arr [ i ] ; if ( SubarrayXOR == ( totalXOR ^ SubarrayXOR ) ) return true ; for ( int i = K ; i < N ; i ++ ) { SubarrayXOR ^= arr [ i ] ; SubarrayXOR ^= arr [ i - 1 ] ; if ( SubarrayXOR == ( totalXOR ^ SubarrayXOR ) ) return true ; } return false ; }
int countPairs ( int L , int R ) { int count_even ; if ( L % 2 == 0 ) { count_even = ( R / 2 ) - ( L / 2 ) + 1 ; } else { count_even = ( R / 2 ) - ( L / 2 ) ; } int count_odd ; if ( L % 2 == 0 ) { count_odd = ( ( R + 1 ) / 2 ) - ( ( L + 1 ) / 2 ) ; } else { count_odd = ( ( R + 1 ) / 2 ) - ( ( L + 1 ) / 2 ) + 1 ; } count_even *= count_even ; count_odd *= count_odd ; cout << count_even + count_odd ; }
int delCost ( string s , int cost [ ] ) { int ans = 0 ; map < char , int > forMax ; map < char , int > forTot ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! forMax [ s [ i ] ] ) { forMax [ s [ i ] ] = cost [ i ] ; } else { forMax [ s [ i ] ] = max ( cost [ i ] , forMax [ s [ i ] ] ) ; } if ( ! forTot [ s [ i ] ] ) { forTot [ s [ i ] ] = cost [ i ] ; } else { forTot [ s [ i ] ] = forTot [ s [ i ] ] + cost [ i ] ; } } for ( auto i : forMax ) { ans += forTot [ i . first ] - i . second ; } return ans ; }
int findPeak ( vector < int > arr ) { int left = 0 ; int right = arr . size ( ) - 1 ; while ( left < right ) { int mid = left + ( right - left ) / 2 ; if ( arr [ mid ] < arr [ mid + 1 ] ) { left = mid + 1 ; } else { right = mid ; } } return left ; }
int BS ( int X , int left , int right , vector < int > arr ) { while ( left <= right ) { int mid = left + ( right - left ) / 2 ; if ( arr [ mid ] == X ) { return mid ; } else if ( X > arr [ mid ] ) { left = mid + 1 ; } else { right = mid - 1 ; } } return -1 ; }
int reverseBS ( int X , int left , int right , vector < int > arr ) { while ( left <= right ) { int mid = left + ( right - left ) / 2 ; if ( arr [ mid ] == X ) { return mid ; } else if ( X > arr [ mid ] ) { right = mid - 1 ; } else { left = mid + 1 ; } } return -1 ; }
int getDefiniteFinds ( vector < int > & arr ) { int n = arr . size ( ) ; vector < int > smallestRight ( n + 1 ) ; smallestRight [ n ] = INT_MAX ; for ( int i = n - 1 ; i >= 0 ; i -- ) { smallestRight [ i ] = min ( smallestRight [ i + 1 ] , arr [ i ] ) ; } int mn = INT_MIN ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mn < arr [ i ] and arr [ i ] < smallestRight [ i + 1 ] ) { ans ++ ; } mn = max ( arr [ i ] , mn ) ; } return ans ; }
void Count_numbers ( int L , int R ) { int count = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) count += 1 ; cout << count << endl ; }
int findIndex ( int arr [ ] , int N ) { int rightSum = 0 ; int leftSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { rightSum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { rightSum -= arr [ i ] ; if ( checkReverse ( leftSum , rightSum ) ) { return i ; } leftSum += arr [ i ] ; } return -1 ; }
void minimumTime ( int * arr , int n ) { int sum = 0 ; int T = * max_element ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } cout << max ( 2 * T , sum ) ; }
int findClosest ( int N , int target ) { int closest = -1 ; int diff = INT_MAX ; for ( int i = 1 ; i <= sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( N / i == i ) { if ( abs ( target - i ) < diff ) { diff = abs ( target - i ) ; closest = i ; } } else { if ( abs ( target - i ) < diff ) { diff = abs ( target - i ) ; closest = i ; } if ( abs ( target - N / i ) < diff ) { diff = abs ( target - N / i ) ; closest = N / i ; } } } } cout << closest ; }
void computeDivisors ( ) { for ( int i = 1 ; i <= MAX ; i ++ ) { for ( int j = i ; j <= MAX ; j += i ) { divisors [ j ] . push_back ( i ) ; } } }
int getClosest ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; }
int findClosest ( vector < int > & arr , int n , int target ) { if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ; int i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) / 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ; if ( target < arr [ mid ] ) { if ( mid > 0 && target > arr [ mid - 1 ] ) return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) ; j = mid ; } else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) ; i = mid + 1 ; } } return arr [ mid ] ; }
void printClosest ( int N , int X ) { computeDivisors ( ) ; int ans = findClosest ( divisors [ N ] , divisors [ N ] . size ( ) , X ) ; cout << ans ; }
int LCS ( vector < int > & firstArr , vector < int > & secondArr ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < firstArr . size ( ) ; i ++ ) { mp [ firstArr [ i ] ] = i + 1 ; } vector < int > tempArr ; for ( int i = 0 ; i < secondArr . size ( ) ; i ++ ) { if ( mp . find ( secondArr [ i ] ) != mp . end ( ) ) { tempArr . push_back ( mp [ secondArr [ i ] ] ) ; } } vector < int > tail ; tail . push_back ( tempArr [ 0 ] ) ; for ( int i = 1 ; i < tempArr . size ( ) ; i ++ ) { if ( tempArr [ i ] > tail . back ( ) ) tail . push_back ( tempArr [ i ] ) ; else if ( tempArr [ i ] < tail [ 0 ] ) tail [ 0 ] = tempArr [ i ] ; else { auto it = lower_bound ( tail . begin ( ) , tail . end ( ) , tempArr [ i ] ) ; * it = tempArr [ i ] ; } } return ( int ) tail . size ( ) ; }
int maxSubarrayProduct ( vector < int > arr , int n ) { int max_ending_here = 1 ; int min_ending_here = 1 ; int max_so_far = 0 ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { max_ending_here = max_ending_here * arr [ i ] ; min_ending_here = min ( min_ending_here * arr [ i ] , 1 ) ; flag = 1 ; } else if ( arr [ i ] == 0 ) { max_ending_here = 1 ; min_ending_here = 1 ; } else { int temp = max_ending_here ; max_ending_here = max ( min_ending_here * arr [ i ] , 1 ) ; min_ending_here = temp * arr [ i ] ; } if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } if ( flag == 0 && max_so_far == 0 ) return 0 ; return max_so_far ; }
int findMaxProduct ( int * a , int n ) { int i = 0 ; int maxProd = -1e9 ; while ( i < n ) { vector < int > v ; v . push_back ( a [ i ] ) ; if ( i < n - 1 && a [ i ] < a [ i + 1 ] ) { while ( i < n - 1 && a [ i ] < a [ i + 1 ] ) { v . push_back ( a [ i + 1 ] ) ; i += 1 ; } } else if ( i < n - 1 && a [ i ] > a [ i + 1 ] ) { while ( i < n - 1 && a [ i ] > a [ i + 1 ] ) { v . push_back ( a [ i + 1 ] ) ; i += 1 ; } } int prod = maxSubarrayProduct ( v , v . size ( ) ) ; maxProd = max ( maxProd , prod ) ; i ++ ; } return maxProd ; }
void PrimeFactors ( int N ) { stack < int > st ; int i = 2 ; while ( N != 1 ) { if ( N % i == 0 ) { st . push ( i ) ; while ( N % i == 0 ) { N = N / i ; } } i ++ ; } while ( ! st . empty ( ) ) { printf ( "%d " , st . top ( ) ) ; st . pop ( ) ; } }
int power ( long long int A , long long int N ) { int count = 0 ; if ( A == 1 ) return 0 ; while ( N ) { count ++ ; N /= A ; } return count ; }
int LCM ( int A , int B ) { return ( A * B / __gcd ( A , B ) ) ; }
int findSmallestNumber ( int X ) { int lcm = 1 ; int temp = X ; while ( temp ) { int last = temp % 10 ; temp /= 10 ; if ( ! last ) continue ; lcm = LCM ( lcm , last ) ; } int answer = ( ( X + lcm - 1 ) / lcm ) * lcm ; cout << answer ; }
int findNonMultiples ( int arr [ ] , int n , int k ) { set < int > multiples ; for ( int i = 0 ; i < n ; ++ i ) { if ( multiples . find ( arr [ i ] ) == multiples . end ( ) ) { for ( int j = 1 ; j <= k / arr [ i ] ; j ++ ) { multiples . insert ( arr [ i ] * j ) ; } } } return k - multiples . size ( ) ; }
int countValues ( int arr [ ] , int N , int L , int R ) { return findNonMultiples ( arr , N , R ) - findNonMultiples ( arr , N , L - 1 ) ; }
void minSum ( int N ) { ll low = 0 , high = 1e9 ; while ( low + 1 < high ) { ll mid = low + ( high - low ) / 2 ; if ( mid * mid >= N ) { high = mid ; } else { low = mid ; } } ll first = high ; low = 0 ; high = 1e9 ; while ( low + 1 < high ) { ll mid = low + ( high - low ) / 2 ; if ( first * mid > N ) { high = mid ; } else { low = mid ; } } ll second = high ; cout << first + second ; }
void minSum ( int N ) { int ans = ceil ( 2 * sqrt ( N + 1 ) ) ; cout << ans ; }
int root ( int a ) { if ( a == parent [ a ] ) { return a ; } return parent [ a ] = root ( parent [ a ] ) ; }
void connect ( int a , int b ) { a = root ( a ) ; b = root ( b ) ; if ( a != b ) { parent [ b ] = a ; } }
int find_ht ( TreeNode * root ) { if ( ! root ) return 0 ; if ( root -> left == NULL && root -> right == NULL ) return 1 ; return max ( find_ht ( root -> left ) , find_ht ( root -> right ) ) + 1 ; }
int countFreq ( int N , int K ) { int count = 0 ; while ( N > 0 ) { if ( N % 10 == K ) { count ++ ; } N = N / 10 ; } return count ; }
int findElementUtil ( int arr [ ] , int N , int K ) { int c ; int max ; int ele ; max = 0 ; for ( int i = 0 ; i < N ; i ++ ) { c = countFreq ( arr [ i ] , K ) ; if ( c > max ) { max = c ; ele = arr [ i ] ; } } if ( max == 0 ) return -1 ; else return ele ; }
void findOverlapSegement ( int N , int a [ ] , int b [ ] ) { vector < pair < pair < int , int > , int > > tup ; for ( int i = 0 ; i < N ; i ++ ) { int x , y ; x = a [ i ] ; y = b [ i ] ; tup . push_back ( pair < pair < int , int > , int > ( pair < int , int > ( x , y ) , i ) ) ; } sort ( tup . begin ( ) , tup . end ( ) ) ; int curr = tup [ 0 ] . first . second ; int currPos = tup [ 0 ] . second ; for ( int i = 1 ; i < N ; i ++ ) { int Q = tup [ i - 1 ] . first . first ; int R = tup [ i ] . first . first ; if ( Q == R ) { if ( tup [ i - 1 ] . first . second < tup [ i ] . first . second ) cout << tup [ i - 1 ] . second << ' ' << tup [ i ] . second ; else cout << tup [ i ] . second << ' ' << tup [ i - 1 ] . second ; return ; } int T = tup [ i ] . first . second ; if ( T <= curr ) { cout << tup [ i ] . second << ' ' << currPos ; return ; } else { curr = T ; currPos = tup [ i ] . second ; } } cout << "-1 -1" ; }
bool isSpiralSorted ( int arr [ ] , int n ) { int start = 0 ; int end = n - 1 ; while ( start < end ) { if ( arr [ start ] > arr [ end ] ) { return false ; } start ++ ; if ( arr [ end ] > arr [ start ] ) { return false ; } end -- ; } return true ; }
int findMinDeletions ( vector < pair < int , int > > & v , int n ) { int minDel = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int L = v [ i ] . first ; int R = v [ i ] . second ; int Count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( v [ j ] . first >= L && v [ j ] . second <= R ) { Count += 1 ; } } minDel = min ( minDel , n - Count ) ; } return minDel ; }
int maxEvenIntegers ( int arr [ ] , int N , int M ) { int ans = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i + j ] % 2 == 0 ) cnt ++ ; } ans = max ( ans , cnt ) ; } return ans ; }
int MaxNonEmpSubSeq ( int a [ ] , int n ) { int sum = 0 ; int max = * max_element ( a , a + n ) ; if ( max <= 0 ) { return max ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) { sum += a [ i ] ; } } return sum ; }
void findMaxLengthSequence ( int N , int arr [ 4 ] ) { int rightmost_element = -1 ; int i = 0 ; int j = N - 1 ; vector < int > sequence ; while ( i <= j ) { if ( arr [ i ] > arr [ j ] ) { if ( arr [ j ] > rightmost_element ) { sequence . push_back ( arr [ j ] ) ; rightmost_element = arr [ j ] ; j -- ; } else if ( arr [ i ] > rightmost_element ) { sequence . push_back ( arr [ i ] ) ; rightmost_element = arr [ i ] ; i ++ ; } else break ; } else if ( arr [ i ] < arr [ j ] ) { if ( arr [ i ] > rightmost_element ) { sequence . push_back ( arr [ i ] ) ; rightmost_element = arr [ i ] ; i ++ ; } else if ( arr [ j ] > rightmost_element ) { sequence . push_back ( arr [ j ] ) ; rightmost_element = arr [ j ] ; j -- ; } else break ; } else if ( arr [ i ] == arr [ j ] ) { if ( i == j ) { if ( arr [ i ] > rightmost_element ) { sequence . push_back ( arr [ i ] ) ; rightmost_element = arr [ i ] ; i ++ ; } break ; } else { sequence . push_back ( arr [ i ] ) ; int k = i + 1 ; vector < int > max_left ; while ( k < j && arr [ k ] > arr [ k - 1 ] ) { max_left . push_back ( arr [ k ] ) ; k ++ ; } int l = j - 1 ; vector < int > max_right ; while ( l > i && arr [ l ] > arr [ l + 1 ] ) { max_right . push_back ( arr [ l ] ) ; l -- ; } if ( max_left . size ( ) > max_right . size ( ) ) for ( int element : max_left ) sequence . push_back ( element ) ; else for ( int element : max_right ) sequence . push_back ( element ) ; break ; } } } for ( int element : sequence ) printf ( "%d " , element ) ; }
long long getcount ( long long n , int k ) { long long res = ( n >> ( k + 1 ) ) << k ; if ( ( n >> k ) & 1 ) res += n & ( ( 1ll << k ) - 1 ) ; return res ; }
void countDivisors ( long long int n ) { int count = 0 ; vector < long long int > divisor ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) divisor . push_back ( i ) ; else { divisor . push_back ( i ) ; divisor . push_back ( n / i ) ; } } } divisor . push_back ( n ) ; for ( auto x : divisor ) { x -= 1 ; if ( ( n / x ) == ( n % x ) ) count ++ ; } cout << count ; }
int smallestIndexArrayElementsFlip ( int arr [ ] , int N ) { int pos = -1 ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] *= -1 ; int sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) { sum += arr [ j ] ; } if ( sum == 0 ) { pos = i ; break ; } else { arr [ i ] *= -1 ; } } return pos ; }
int smallestIndexArrayElementsFlip ( int arr [ ] , int N ) { int pos = -1 ; int ArrSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { ArrSum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( 2 * arr [ i ] == ArrSum ) { pos = i ; break ; } } return pos ; }
vector < int > MaxAverage ( TreeNode * root ) { if ( root != NULL && root -> children . size ( ) == 0 ) { ans = max ( ans , ( root -> val ) * ( 1.0 ) ) ; return { root -> val , 1 } ; } vector < int > childResult ( 2 ) ; for ( TreeNode * child : root -> children ) { vector < int > childTotal = MaxAverage ( child ) ; childResult [ 0 ] = childResult [ 0 ] + childTotal [ 0 ] ; childResult [ 1 ] = childResult [ 1 ] + childTotal [ 1 ] ; } int sum = childResult [ 0 ] + root -> val ; int count = childResult [ 1 ] + 1 ; ans = max ( ans , sum / count * 1.0 ) ; return { sum , count } ; }
int make_array_element_even ( int arr [ ] , int N ) { int res = 0 ; int odd_cont_seg = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd_cont_seg ++ ; } else { if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += ( odd_cont_seg / 2 ) + 2 ; } odd_cont_seg = 0 ; } } } if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += odd_cont_seg / 2 + 2 ; } } return res ; }
void findSum ( vector < int > a ) { int ans = 0 ; for ( int low = 0 ; low < a . size ( ) ; low ++ ) { for ( int high = low ; high < a . size ( ) ; high ++ ) { int count = 0 ; int maxNumber = 0 ; for ( int i = low ; i <= high ; i ++ ) { if ( a [ i ] == maxNumber ) count ++ ; else if ( a [ i ] > maxNumber ) { maxNumber = a [ i ] ; count = 1 ; } } ans += maxNumber * ( ( count % 2 == 0 ) ? 2 : 1 ) ; } } cout << ( ans ) ; }
void countPairs ( int * arr , int n ) { unordered_map < int , int > mp1 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; mp1 [ sum ] += 1 ; } sum = 0 ; int ans = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { sum += arr [ i ] ; if ( mp1 . find ( sum ) != mp1 . end ( ) ) { ans += mp1 [ sum ] ; } } cout << ans ; }
int minCollectingSpeed ( vector < int > & piles , int H ) { int ans = -1 ; int low = 1 , high ; high = * max_element ( piles . begin ( ) , piles . end ( ) ) ; while ( low <= high ) { int K = low + ( high - low ) / 2 ; int time = 0 ; for ( int ai : piles ) { time += ( ai + K - 1 ) / K ; } if ( time <= H ) { ans = K ; high = K - 1 ; } else { low = K + 1 ; } } cout << ans ; }
bool isMagic ( int num ) { return ( num % 9 == 1 ) ; }
int findSmallestInteger ( int arr [ ] , int N , int K ) { int left = 1 ; int right = * max_element ( arr , arr + N ) ; while ( left < right ) { int mid = ( left + right ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += ( arr [ i ] + mid - 1 ) / mid ; } if ( sum > K ) { left = mid + 1 ; } else { right = mid ; } } return left ; }
int minimum_deci_binary_number ( string s ) { int m = INT_MIN ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { int temp = s [ i ] - '0' ; if ( temp > m ) { m = temp ; } } return m ; }
int minimumReverse ( string s , int n ) { int k = 0 , l = 0 ; int sum1 = 0 , sum0 = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) sum1 ++ ; else sum0 ++ ; if ( s [ i ] == s [ i - 1 ] && s [ i ] == '0' ) k ++ ; else if ( s [ i ] == s [ i - 1 ] && s [ i ] == '1' ) l ++ ; } if ( s [ 0 ] == '1' ) sum1 ++ ; sum0 ++ ; if ( abs ( sum1 - sum0 ) > 1 ) return -1 ; return max ( k , l ) ; }
void canTransformStrings ( string A , string B ) { int n1 = A . size ( ) ; int n2 = B . size ( ) ; int count1A = 0 , count1B = 0 ; int odd1A = 0 , odd1B = 0 ; int even1A = 0 , even1B = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( A [ i ] == '1' ) count1A ++ ; else { if ( count1A & 1 ) odd1A ++ ; else even1A ++ ; } } for ( int i = 0 ; i < n2 ; i ++ ) { if ( B [ i ] == '1' ) count1B ++ ; else { if ( count1B & 1 ) odd1B ++ ; else even1B ++ ; } } if ( count1A == count1B && odd1A == odd1B && even1A == even1B ) { cout << "Yes" ; } else cout << "No" ; }
void maxPairs ( vector < int > nums , int k ) { map < int , int > m ; int result = 0 ; for ( auto i : nums ) { if ( m . find ( i ) != m . end ( ) && m [ i ] > 0 ) { m [ i ] = m [ i ] - 1 ; result ++ ; } else { m [ k - i ] = m [ k - i ] + 1 ; } } cout << result ; }
void uniqueElements ( int arr [ ] , int start , int K , map < int , int > & mp ) { set < int > st ; for ( int i = 0 ; i < K ; i ++ ) st . insert ( arr [ start + i ] ) ; set < int > :: iterator itr = st . begin ( ) ; for ( ; itr != st . end ( ) ; itr ++ ) mp [ * itr ] ++ ; }
void smallestPresentNumber ( int arr [ ] , int N , int K ) { map < int , int > mp ; for ( int i = 0 ; i <= N - K ; i ++ ) { uniqueElements ( arr , i , K , mp ) ; } checkAnswer ( mp , N , K ) ; }
void generateK ( int arr [ ] , int N ) { for ( int k = 1 ; k <= N ; k ++ ) smallestPresentNumber ( arr , N , k ) ; }
void printAnswer ( int answer [ ] , int N ) { for ( int i = 1 ; i <= N ; i ++ ) { cout << answer [ i ] << " " ; } }
void lengthOfSubarray ( vector < int > indices [ ] , set < int > st , int N ) { int answer [ N + 1 ] ; memset ( answer , -1 , sizeof ( answer ) ) ; for ( auto itr : st ) { int start = -1 ; int gap = -1 ; indices [ itr ] . push_back ( N ) ; for ( int i = 0 ; i < indices [ itr ] . size ( ) ; i ++ ) { gap = max ( gap , indices [ itr ] [ i ] - start ) ; start = indices [ itr ] [ i ] ; } if ( answer [ gap ] == -1 ) answer [ gap ] = itr ; } updateAnswerArray ( answer , N ) ; printAnswer ( answer , N ) ; }
void smallestPresentNumber ( int arr [ ] , int N ) { vector < int > indices [ N + 1 ] ; set < int > elements ; for ( int i = 0 ; i < N ; i ++ ) { indices [ arr [ i ] ] . push_back ( i ) ; elements . insert ( arr [ i ] ) ; } lengthOfSubarray ( indices , elements , N ) ; }
void removeIndicesToMakeSumEqual ( vector < int > & arr ) { int N = arr . size ( ) ; vector < int > odd ( N , 0 ) ; vector < int > even ( N , 0 ) ; even [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { odd [ i ] = odd [ i - 1 ] ; even [ i ] = even [ i - 1 ] ; if ( i % 2 == 0 ) { even [ i ] += arr [ i ] ; } else { odd [ i ] += arr [ i ] ; } } bool find = 0 ; int p = odd [ N - 1 ] ; int q = even [ N - 1 ] - arr [ 0 ] ; if ( p == q ) { cout << "0 " ; find = 1 ; } for ( int i = 1 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { p = even [ N - 1 ] - even [ i - 1 ] - arr [ i ] + odd [ i - 1 ] ; q = odd [ N - 1 ] - odd [ i - 1 ] + even [ i - 1 ] ; } else { q = odd [ N - 1 ] - odd [ i - 1 ] - arr [ i ] + even [ i - 1 ] ; p = even [ N - 1 ] - even [ i - 1 ] + odd [ i - 1 ] ; } if ( p == q ) { find = 1 ; cout << i << " " ; } } if ( ! find ) { cout << -1 ; } }
int cntDisPairs ( int arr [ ] , int N , int K ) { int cntPairs = 0 ; sort ( arr , arr + N ) ; int i = 0 ; int j = N - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] == K ) { while ( i < j && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } while ( i < j && arr [ j ] == arr [ j - 1 ] ) { j -- ; } cntPairs += 1 ; i ++ ; j -- ; } else if ( arr [ i ] + arr [ j ] < K ) { i ++ ; } else { j -- ; } } return cntPairs ; }
int maxLength ( int a [ ] , int b [ ] , int n , int c ) { if ( n == 0 ) return 0 ; int max_length = 0 ; int low = 0 , high = n ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( possible ( a , b , n , c , mid ) != false ) { max_length = mid ; low = mid + 1 ; } else high = mid - 1 ; } return max_length ; }
bool possible ( int a [ ] , int b [ ] , int n , int c , int k ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { sum += a [ i ] ; } int total_cost = sum * k + getMax ( b , 0 , n - 1 , 0 , k - 1 , 0 ) ; if ( total_cost <= c ) return true ; for ( int i = k ; i < n ; i ++ ) { sum += a [ i ] ; sum -= a [ i - k ] ; total_cost = sum * k + getMax ( b , 0 , n - 1 , i - k + 1 , i , 0 ) ; if ( total_cost <= c ) return true ; } return false ; }
void build ( int b [ ] , int index , int s , int e ) { if ( s == e ) { seg [ index ] = b [ s ] ; return ; } int mid = s + ( e - s ) / 2 ; build ( b , 2 * index + 1 , s , mid ) ; build ( b , 2 * index + 2 , mid + 1 , e ) ; seg [ index ] = max ( seg [ 2 * index + 1 ] , seg [ 2 * index + 2 ] ) ; }
int getMax ( int b [ ] , int ss , int se , int qs , int qe , int index ) { if ( se < qs ss > qe ) return INT_MIN / 2 ; if ( ss >= qs && se <= qe )  return seg [ index ] ; int mid = ss + ( se - ss ) / 2 ; return max ( getMax ( b , ss , mid , qs , qe , 2 * index + 1 ) , getMax ( b , mid + 1 , se , qs , qe , 2 * index + 2 ) ) ; }
int maxLength ( int a [ ] , int b [ ] , int n , int c ) { if ( n == 0 ) return 0 ; int max_length = 0 ; int low = 0 , high = n ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( possible ( a , b , n , c , mid ) ) { max_length = mid ; low = mid + 1 ; } else high = mid - 1 ; } return max_length ; }
bool possible ( int a [ ] , int b [ ] , int n , int c , int k ) { deque < int > dq ; int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { sum += a [ i ] ; while ( dq . size ( ) > 0 && b [ i ] > b [ dq . back ( ) ] ) dq . pop_back ( ) ; dq . push_back ( i ) ; } int total_cost = sum * k + b [ dq . front ( ) ] ; if ( total_cost <= c ) return true ; for ( int i = k ; i < n ; i ++ ) { sum += a [ i ] ; sum -= a [ i - k ] ; while ( dq . size ( ) > 0 && dq . front ( ) <= i - k ) dq . pop_front ( ) ; while ( dq . size ( ) > 0 && b [ i ] > b [ dq . back ( ) ] ) dq . pop_back ( ) ; dq . push_back ( i ) ; total_cost = sum * k + b [ dq . front ( ) ] ; if ( total_cost <= c ) return true ; } return false ; }
int findMaxLength ( int N , vector < int > arr ) { vector < int > dp ( N + 1 , 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 2 * i ; j <= N ; j += i ) { if ( arr [ i - 1 ] < arr [ j - 1 ] ) { dp [ j ] = max ( dp [ j ] , dp [ i ] + 1 ) ; } } } return * max_element ( dp . begin ( ) , dp . end ( ) ) ; }
int UtilSmallestElement ( int arr [ ] , int N ) { int total = 0 ; for ( int i = 0 ; i < N ; i ++ ) { total += arr [ i ] ; } vector < vector < int > > dp ( N + 1 , vector < int > ( total , -1 ) ) ; cout << smallestLeft ( arr , total , 0 , N , dp ) ; }
int SmallestElementLeft ( int arr [ ] , int N ) { int totalSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalSum += arr [ i ] ; } int req = totalSum / 2 ; bool dp [ req + 1 ] ; memset ( dp , false , sizeof ( dp ) ) ; dp [ 0 ] = true ; int reach = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = req ; j - arr [ i ] >= 0 ; j -- ) { dp [ j ] = dp [ j ] || dp [ j - arr [ i ] ] ; if ( dp [ j ] ) { reach = max ( reach , j ) ; } } } return totalSum - ( 2 * reach ) ; }
int countSubArraySignChange ( int arr [ ] , int N ) { unordered_map < int , int > prefixCount ; unordered_map < int , int > suffixCount ; int total = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { total += arr [ i ] ; suffixCount [ arr [ i ] ] ++ ; } int prefixSum = 0 ; int suffixSum = 0 ; int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { prefixSum += arr [ i ] ; prefixCount [ arr [ i ] ] ++ ; suffixSum = total - prefixSum ; suffixCount [ arr [ i ] ] -- ; int diff = prefixSum - suffixSum ; if ( diff % 2 == 0 ) { int x = prefixCount + suffixCount [ - diff / 2 ] ; count = count + x ; } } return count ; }
int countCommonChar ( int ind , string & S ) { int cnt = 0 ; set < char > ls ; set < char > rs ; for ( int i = 0 ; i < ind ; ++ i ) { ls . insert ( S [ i ] ) ; } for ( int i = ind ; i < S . length ( ) ; ++ i ) { rs . insert ( S [ i ] ) ; } for ( auto v : ls ) { if ( rs . count ( v ) ) { ++ cnt ; } } return cnt ; }
int longestSubarray ( string s ) { s += '0' ; int i ; int res = 0 ; int prev_one = 0 ; int curr_one = 0 ; int numberOfZeros = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '1' ) { curr_one += 1 ; } else { numberOfZeros += 1 ; prev_one += curr_one ; res = max ( res , prev_one ) ; prev_one = curr_one ; curr_one = 0 ; } } if ( numberOfZeros == 1 ) { res -= 1 ; } return res ; }
void LarUnEl ( int arr [ ] , int N ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } int LNRElem = INT_MIN ; int ind = -1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp [ arr [ i ] ] == 1 && arr [ i ] > LNRElem ) { ind = i ; LNRElem = arr [ i ] ; } } if ( ind == -1 ) { cout << ind ; return ; } cout << arr [ ind ] ; }
bool isConsistingSubarrayUtil ( int arr [ ] , int n ) { map < int , int > mp ; for ( int i = 0 ; i < n ; ++ i ) { mp [ arr [ i ] ] ++ ; } map < int , int > :: iterator it ; for ( it = mp . begin ( ) ; it != mp . end ( ) ; ++ it ) { if ( it -> second > 1 ) { return true ; } } return false ; }
void isConsistingSubarray ( int arr [ ] , int N ) { if ( isConsistingSubarrayUtil ( arr , N ) ) { cout << "Yes" << endl ; } else { cout << "No" << endl ; } }
void countShifts ( string str ) { int firstOne = -1 ; int lastOne = -1 ; int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == '1' ) { if ( firstOne == -1 ) firstOne = i ; lastOne = i ; } } if ( ( firstOne == -1 ) || ( firstOne == lastOne ) ) { cout << 0 ; return ; } for ( int i = firstOne ; i <= lastOne ; i ++ ) { if ( str [ i ] == '0' ) { count ++ ; } } cout << count << endl ; }
bool checkSubsequenceUtil ( int arr [ ] , int L , int R , int N ) { for ( int i = 0 ; i < L ; i ++ ) if ( arr [ i ] == arr [ L ] ) return true ; for ( int i = R + 1 ; i < N ; i ++ ) if ( arr [ i ] == arr [ R ] ) return true ; return false ; }
int largestSubarray ( int arr [ ] , int N , int K ) { int count = 0 ; int len = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < K ) { count += 1 ; } else { len = max ( len , count ) ; count = 0 ; } } if ( count ) { len = max ( len , count ) ; } cout << len ; }
void findNthNum ( long long int N ) { long long int a , b , left ; long long int right , mid ; long long int t , last_num = 0 ; left = 1 , right = N ; while ( left <= right ) { mid = left + ( right - left ) / 2 ; t = ( mid * ( mid + 1 ) ) / 2 ; if ( t < N ) { left = mid + 1 ; } else if ( t == N ) { a = mid ; break ; } else { a = mid ; right = mid - 1 ; } } t = a - 1 ; b = N - ( t * ( t + 1 ) ) / 2 - 1 ; cout << ( 1 << a ) + ( 1 << b ) ; }
void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ 2 ] ) { for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ; arr [ x - 1 ] = y ; int count = 1 ; for ( int j = 1 ; j < N ; j ++ ) { if ( arr [ j ] != arr [ j - 1 ] ) { count += 1 ; } } cout << count << ' ' ; } }
void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ 2 ] ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count += 1 ; } } for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ; if ( x > 1 ) { if ( arr [ x - 1 ] != arr [ x - 2 ] ) { count -= 1 ; } if ( arr [ x - 2 ] != y ) { count += 1 ; } } if ( x < N ) { if ( arr [ x ] != arr [ x - 1 ] ) { count -= 1 ; } if ( y != arr [ x ] ) { count += 1 ; } } cout << count << ' ' ; arr [ x - 1 ] = y ; } }
void longestSubWithMaxSum ( int arr [ ] , int N ) { int Max = * max_element ( arr , arr + N ) ; if ( Max < 0 ) { cout << Max ; return ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= 0 ) { cout << arr [ i ] << " " ; } } }
void printNGE ( int * arr , int n ) { stack < int > s ; int nge [ n ] , i = 0 ; for ( i = 0 ; i < n ; i ++ ) { nge [ i ] = -1 ; } i = 0 ; while ( i < 2 * n ) { while ( ! s . empty ( ) && arr [ i % n ] > arr [ s . top ( ) ] ) { nge [ s . top ( ) ] = arr [ i % n ] ; s . pop ( ) ; } s . push ( i % n ) ; i ++ ; } for ( i = 0 ; i < n ; i ++ ) { cout << nge [ i ] << " " ; } }
bool isPerfectSquare ( int x ) { int s = sqrt ( x ) ; return ( s * s == x ) ; }
bool isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
void ifgcdFibonacci ( int a [ ] , int n , int k ) { vector < int > compositeset ; for ( int i = 0 ; i < n ; i ++ ) { if ( isComposite ( a [ i ] ) && a [ i ] % k == 0 ) { compositeset . push_back ( a [ i ] ) ; } } int gcd = compositeset [ 0 ] ; for ( int i = 1 ; i < compositeset . size ( ) ; i ++ ) { gcd = __gcd ( gcd , compositeset [ i ] ) ; if ( gcd == 1 ) { break ; } } if ( isFibonacci ( gcd ) ) { cout << "Yes" ; return ; } cout << "No" ; return ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void findPair ( int A [ ] , int N ) { int right_prod [ N ] ; int flag = 0 ; right_prod [ N - 1 ] = A [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) right_prod [ i ] = right_prod [ i + 1 ] * A [ i ] ; int total_prod = right_prod [ 0 ] ; int product ; for ( int i = 1 ; i < N - 1 ; i ++ ) { product = 1 ; for ( int j = i ; j < N - 1 ; j ++ ) { product *= A [ j ] ; if ( gcd ( product , right_prod [ j + 1 ] ) == 1 || gcd ( product , total_prod / right_prod [ i ] ) == 1 ) { flag = 1 ; cout << "(" << i - 1 << ", " << j + 1 << ")" ; break ; } } if ( flag == 1 ) break ; } if ( flag == 0 ) cout << -1 ; }
void countString ( string S ) { long long count = 0 ; for ( auto it : S ) { if ( it == '0' and count > 0 ) { count -- ; } else { count ++ ; } } cout << ( ( 1 << count ) - 1 ) << "\n" ; }
void replaceDuplicates ( vector < string > & names ) { unordered_map < string , int > hash ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { if ( hash . count ( names [ i ] ) == 0 ) hash [ names [ i ] ] ++ ; else { int count = hash [ names [ i ] ] ++ ; names [ i ] += to_string ( count ) ; } } for ( int i = 0 ; i < names . size ( ) ; i ++ ) { cout << names [ i ] << " " ; } }
long long int digitProduct ( int number ) { long long int res = 1 ; while ( number > 0 ) { res *= ( number % 10 ) ; number /= 10 ; } return res ; }
void DistinctCompositeDigitProduct ( int arr [ ] , int n ) { set < int > output ; bool prime [ N + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , N ) ; for ( int i = 0 ; i < n ; i ++ ) { long long int ans = digitProduct ( arr [ i ] ) ; if ( ans <= 1 ) { continue ; } if ( ! prime [ ans ] ) { output . insert ( ans ) ; } } cout << output . size ( ) << endl ; }
vector < bool > SegmentedSieveFn ( int low , int high ) { int lmt = floor ( sqrt ( high ) ) + 1 ; vector < int > prime ; simpleSieve ( lmt , prime ) ; int n = high - low + 1 ; vector < bool > segmentedSieve ( n + 1 , true ) ; for ( int i = 0 ; i < prime . size ( ) ; i ++ ) { int lowLim = floor ( low / prime [ i ] ) * prime [ i ] ; if ( lowLim < low ) { lowLim += prime [ i ] ; } for ( int j = lowLim ; j <= high ; j += prime [ i ] ) { if ( j != prime [ i ] ) { segmentedSieve [ j - low ] = false ; } } } return segmentedSieve ; }
int countPairsWhoseSumPrimeL_R ( int L , int R ) { vector < bool > segmentedSieve = SegmentedSieveFn ( L , R ) ; int cntPairs = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( segmentedSieve [ i - L ] ) { cntPairs += i / 2 ; } } return cntPairs ; }
int count_zeroes ( int n , string str ) { int cnt = 0 ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { if ( str [ i ] == '0' ) cnt ++ ; } return cnt ; }
string kReducingString ( int n , int k , string str ) { int no_of_zeroes = count_zeroes ( n , str ) ; int no_of_ones = n - no_of_zeroes ; if ( no_of_zeroes == 0 no_of_zeroes == n ) { return str ; } if ( k == 1 ) { if ( no_of_zeroes == 0 no_of_zeroes == n ) { return str ; } else { return "Not Possible" ; } } bool check = 0 ; for ( int i = ( n / k ) ; i < n ; i += ( n / k ) ) { if ( no_of_zeroes == i no_of_ones == i ) { check = 1 ; break ; } } if ( check == 0 ) { return "Not Possible" ; } return kReducingStringUtil ( n , k , str , no_of_zeroes ) ; }
void convert_to_allzeroes ( string str , int a , int b ) { int len = str . length ( ) ; int left_1 , i = 0 ; while ( i < len && str [ i ] == '0' ) i ++ ; left_1 = i ; int right_1 ; i = len - 1 ; while ( i >= 0 && str [ i ] == '0' ) i -- ; right_1 = i ; if ( left_1 == len && right_1 == -1 ) { cout << 0 ; return ; } int cost = a , zeroes ; for ( i = left_1 ; i <= right_1 ; i ++ ) { zeroes = 0 ; while ( i < len && str [ i ] == '0' ) { zeroes ++ ; i ++ ; } if ( zeroes ) cost += min ( zeroes * b , a ) ; } cout << cost ; }
int MinDistK ( int arr [ ] , int N , int K ) { int res = INT_MAX ; int dist = 0 ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { if ( arr [ i ] >= 0 && arr [ i + K - 1 ] >= 0 ) { dist = max ( arr [ i ] , arr [ i + K - 1 ] ) ; } else { dist = abs ( arr [ i ] ) + abs ( arr [ i + K - 1 ] ) + min ( abs ( arr [ i ] ) , abs ( arr [ i + K - 1 ] ) ) ; } res = min ( res , dist ) ; } return res ; }
int maximizeMin ( int A [ ] , int N , int S , int M ) { int minIndex , left , right , i , j ; for ( i = 0 ; i < M ; i ++ ) { minIndex = min ( A , N ) ; A [ minIndex ] ++ ; left = minIndex - 1 ; right = minIndex + 1 ; for ( j = 0 ; j < S - 1 ; j ++ ) { if ( left == -1 ) A [ right ++ ] ++ ; else if ( right == N ) A [ left -- ] ++ ; else { if ( A [ left ] < A [ right ] ) A [ left -- ] ++ ; else A [ right ++ ] ++ ; } } } minIndex = min ( A , N ) ; return A [ minIndex ] ; }
ll sumOfPathNodes ( ll N ) { if ( N == 1 ) { return 1 ; } else if ( N == 2 N == 3 ) { return N + 1 ; } vector < ll > arr ; arr . push_back ( 1 ) ; ll k = 1 ; bool flag = true ; while ( k < N ) { if ( flag == true ) { k *= 2 ; flag = false ; } else { k *= 4 ; flag = true ; } if ( k > N ) { break ; } arr . push_back ( k ) ; } ll len = arr . size ( ) ; vector < ll > prefix ( len ) ; prefix [ 0 ] = 1 ; for ( ll i = 1 ; i < len ; ++ i ) { prefix [ i ] = arr [ i ] + prefix [ i - 1 ] ; } vector < ll > :: iterator it = lower_bound ( prefix . begin ( ) , prefix . end ( ) , N ) ; ll ind = it - prefix . begin ( ) ; ll final_ans = 0 ; ll temp = N ; while ( ind > 1 ) { ll val = temp - prefix [ ind - 1 ] ; if ( ind % 2 != 0 ) { temp = prefix [ ind - 2 ] + ( val + 1 ) / 2 ; } else { temp = prefix [ ind - 2 ] + ( val + 3 ) / 4 ; } -- ind ; final_ans += temp ; } final_ans += ( N + 1 ) ; return final_ans ; }
void fill_counts ( int a [ ] , int n ) { int i , j ; int maxA = a [ 0 ] ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > maxA ) { maxA = a [ i ] ; } } memset ( lcount , 0 , sizeof ( lcount ) ) ; memset ( rcount , 0 , sizeof ( rcount ) ) ; for ( i = 0 ; i < n ; i ++ ) { lcount [ a [ i ] ] [ i ] = 1 ; rcount [ a [ i ] ] [ i ] = 1 ; } for ( i = 0 ; i <= maxA ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { lcount [ i ] [ j ] = lcount [ i ] [ j - 1 ] + lcount [ i ] [ j ] ; } for ( j = n - 2 ; j >= 0 ; j -- ) { rcount [ i ] [ j ] = rcount [ i ] [ j + 1 ] + rcount [ i ] [ j ] ; } } }
bool checkPointRange ( int arr [ ] [ 3 ] , int X , int Y , int N ) { for ( int i = 0 ; i < N ; i ++ ) { double dist = sqrt ( ( arr [ i ] [ 0 ] - X ) * ( arr [ i ] [ 0 ] - X ) + ( arr [ i ] [ 1 ] - Y ) * ( arr [ i ] [ 1 ] - Y ) ) ; if ( dist <= arr [ i ] [ 2 ] ) { return true ; } } return false ; }
void findWinner ( int arr [ ] , int N ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd ++ ; } else { even ++ ; } } if ( even == 0 ) { if ( odd % 2 == 0 ) { cout << "Player 2" << endl ; } else if ( odd % 2 == 1 ) { cout << "Player 1" << endl ; } } else if ( even == 1 && odd % 2 == 1 ) { cout << "Player 1" << endl ; } else { cout << -1 << endl ; } }
set < int > createhashmap ( int Max ) { set < int > hashmap ; int curr = 1 ; int prev = 0 ; hashmap . insert ( prev ) ; while ( curr <= Max ) { hashmap . insert ( curr ) ; int temp = curr ; curr = curr + prev ; prev = temp ; } return hashmap ; }
vector < bool > SieveOfEratosthenes ( int Max ) { vector < bool > isPrime ( Max , true ) ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; for ( int p = 2 ; p * p <= Max ; p ++ ) { if ( isPrime [ p ] ) { for ( int i = p * p ; i <= Max ; i += p ) { isPrime [ i ] = false ; } } } return isPrime ; }
int cntFibonacciPrime ( int arr [ ] , int N ) { int Max = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { Max = max ( Max , arr [ i ] ) ; } vector < bool > isPrime = SieveOfEratosthenes ( Max ) ; set < int > hashmap = createhashmap ( Max ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) continue ; if ( ( hashmap . count ( arr [ i ] ) ) && ! isPrime [ arr [ i ] ] ) { cout << arr [ i ] << " " ; } } }
int minJumps ( string seats ) { vector < int > position ; int count = 0 ; int len = seats . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( seats [ i ] == 'x' ) { position . push_back ( i - count ) ; count ++ ; } } if ( count == len count == 0 ) return 0 ; int med_index = ( count - 1 ) / 2 ; int med_val = position [ med_index ] ; int ans = 0 ; for ( int i = 0 ; i < position . size ( ) ; i ++ ) { ans = ( ans % MOD + abs ( position [ i ] - med_val ) % MOD ) % MOD ; } return ans % MOD ; }
int singlePrimeFactor ( int N ) { unordered_set < int > disPrimeFact ; for ( int i = 2 ; i * i <= N ; ++ i ) { while ( N % i == 0 ) { disPrimeFact . insert ( i ) ; N /= i ; } } if ( N != 1 ) { disPrimeFact . insert ( N ) ; } if ( disPrimeFact . size ( ) == 1 ) { return * disPrimeFact . begin ( ) ; } return -1 ; }
int cntsingleFactorPair ( int arr [ ] , int N ) { int countOf1 = 0 ; unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) { countOf1 ++ ; continue ; } int factorValue = singlePrimeFactor ( arr [ i ] ) ; if ( factorValue == -1 ) { continue ; } else { mp [ factorValue ] ++ ; } } int res = 0 ; for ( auto it : mp ) { int X = it . second ; res += countOf1 * X + ( X * ( X - 1 ) ) / 2 ; } return res ; }
int countPairs ( int v1 [ ] , int v2 [ ] , int n , int m , int k ) { int count = 0 ; if ( n <= m ) { sort ( v1 , v1 + n ) ; for ( int j = 0 ; j < m ; j ++ ) { int index = lower_bound ( v1 , v1 + n , v2 [ j ] - k ) - v1 ; count += index ; } } else { sort ( v2 , v2 + m ) ; for ( int i = 0 ; i < n ; i ++ ) { int index = upper_bound ( v2 , v2 + m , v1 [ i ] + k ) - v2 ; count += m - index ; } } return count ; }
void maxSumSubarr ( int A [ ] , int N , int K , int X ) { int sum_K = 0 ; for ( int i = 0 ; i < K ; i ++ ) { sum_K += A [ i ] ; } int Max_Sum = 0 ; if ( sum_K < X ) { Max_Sum = sum_K ; } for ( int i = K ; i < N ; i ++ ) { sum_K -= ( A [ i - K ] - A [ i ] ) ; if ( sum_K < X ) { Max_Sum = max ( Max_Sum , sum_K ) ; } } cout << Max_Sum << endl ; }
void removeSmallestSubarray ( int arr [ ] , int n , int k ) { int mod_arr [ n ] ; int total_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mod_arr [ i ] = ( arr [ i ] + k ) % k ; total_sum += arr [ i ] ; } int target_remainder = total_sum % k ; if ( target_remainder == 0 ) { cout << "0" ; return ; } unordered_map < int , int > map1 ; map1 [ 0 ] = -1 ; int curr_remainder = 0 ; int res = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { curr_remainder = ( curr_remainder + arr [ i ] + k ) % k ; map1 [ curr_remainder ] = i ; int mod = ( curr_remainder - target_remainder + k ) % k ; if ( map1 . find ( mod ) != map1 . end ( ) ) res = min ( res , i - map1 [ mod ] ) ; } if ( res == INT_MAX res == n ) { res = -1 ; } cout << res ; }
int findMaxLen ( int wood [ ] , int N , int K ) { int left = 1 ; int right = * max_element ( wood , wood + N ) ; while ( left <= right ) { int mid = left + ( right - left ) / 2 ; if ( isValid ( wood , N , mid , K ) ) { left = mid + 1 ; } else { right = mid - 1 ; } } return right ; }
int countFactors ( vector < int > & spf , int num ) { int count = 0 ; while ( num > 1 ) { count ++ ; num = num / spf [ num ] ; } return count ; }
vector < int > precalculateSum ( vector < int > & spf ) { vector < int > sum ( MAX ) ; sum [ 0 ] = 0 ; for ( int i = 1 ; i < MAX ; i ++ ) { int prime_factor = countFactors ( spf , i ) ; if ( spf [ prime_factor ] == prime_factor ) { sum [ i ] = sum [ i - 1 ] + 1 ; } else { sum [ i ] = sum [ i - 1 ] ; } } return sum ; }
int countSum ( int a [ ] , int n , int sum ) { int i , j , k , l ; int count = 0 ; for ( i = 0 ; i < n - 3 ; i ++ ) { for ( j = i + 1 ; j < n - 2 ; j ++ ) { for ( k = j + 1 ; k < n - 1 ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ i ] + a [ j ] + a [ k ] + a [ l ] == sum ) count ++ ; } } } } return count ; }
int countSum ( int a [ ] , int n , int sum ) { int i , j , k , l ; int count = 0 ; for ( i = 0 ; i < n - 3 ; i ++ ) { for ( j = i + 1 ; j < n - 2 ; j ++ ) { int req = sum - a [ i ] - a [ j ] ; unordered_map < int , int > m ; for ( k = j + 1 ; k < n ; k ++ ) m [ a [ k ] ] ++ ; int twice_count = 0 ; for ( k = j + 1 ; k < n ; k ++ ) { twice_count += m [ req - a [ k ] ] ; if ( req - a [ k ] == a [ k ] ) twice_count -- ; } count += twice_count / 2 ; } } return count ; }
int countSum ( int a [ ] , int n , int sum ) { int i , j , k ; int count = 0 ; unordered_map < int , int > m ; for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { int temp = a [ i ] + a [ j ] ; if ( temp < sum ) count += m [ sum - temp ] ; } for ( j = 0 ; j < i ; j ++ ) { int temp = a [ i ] + a [ j ] ; if ( temp < sum ) m [ temp ] ++ ; } } return count ; }
int minSwaps ( string S , int n ) { int swaps = 0 ; vector < vector < int > > arr ( 26 ) ; for ( int i = 0 ; i < n ; i ++ ) { int pos = S [ i ] - 'a' ; arr [ pos ] . push_back ( i ) ; } for ( char ch = 'a' ; ch <= 'z' ; ++ ch ) { int pos = ch - 'a' ; for ( int i = 1 ; i < arr [ pos ] . size ( ) ; ++ i ) { swaps += abs ( arr [ pos ] [ i ] - arr [ pos ] [ i - 1 ] - 1 ) ; } } return swaps ; }
bool isValid ( int arr [ ] , int n , int m , int d ) { for ( int i = 0 ; i < m ; i ++ ) { if ( abs ( arr [ n - m + i ] - arr [ i ] ) < d ) { return 0 ; } } return 1 ; }
void max_distance ( int a [ ] , int temp [ ] , int n ) { map < int , int > mp ; for ( int i = 1 ; i <= n ; i ++ ) { temp [ i ] = -1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mp . find ( a [ i ] ) == mp . end ( ) ) temp [ a [ i ] ] = i + 1 ; else temp [ a [ i ] ] = max ( temp [ a [ i ] ] , i - mp [ a [ i ] ] ) ; mp [ a [ i ] ] = i ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( temp [ i ] != -1 ) temp [ i ] = max ( temp [ i ] , n - mp [ i ] ) ; } }
void min_comm_ele ( int a [ ] , int ans [ ] , int temp [ ] , int n ) { max_distance ( a , temp , n ) ; for ( int i = 1 ; i <= n ; i ++ ) { ans [ i ] = -1 ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( ans [ temp [ i ] ] == -1 ) ans [ temp [ i ] ] = i ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( i > 1 && ans [ i - 1 ] != -1 ) { if ( ans [ i ] == -1 ) ans [ i ] = ans [ i - 1 ] ; else ans [ i ] = min ( ans [ i ] , ans [ i - 1 ] ) ; } cout << ans [ i ] << " " ; } }
int maxiConsecutiveSubarray ( int arr [ ] , int N ) { int maxi = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int cnt = 1 , j ; for ( j = i ; j < N ; j ++ ) { if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; } else { break ; } } maxi = max ( maxi , cnt ) ; i = j ; } return maxi ; }
void FindTrip ( int arr [ ] , int N ) { for ( int i = 1 ; i < N - 1 ; i ++ ) { int p = arr [ i - 1 ] ; int q = arr [ i ] ; int r = arr [ i + 1 ] ; if ( p < q && q > r ) { cout << i - 1 << " " << i << " " << i + 1 ; return ; } } cout << -1 ; }
int cntSubarrays ( int arr [ ] , int N ) { int cntSub = 0 ; int cntUnique = 0 ; unordered_map < int , int > cntFreq ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i ; j < N ; j ++ ) { cntFreq [ arr [ j ] ] ++ ; if ( cntFreq [ arr [ j ] ] == 1 ) { cntUnique ++ ; } else if ( cntFreq [ arr [ j ] ] == 2 ) { cntUnique -- ; } if ( cntUnique == 0 ) { cntSub ++ ; } } cntFreq . clear ( ) ; cntUnique = 0 ; } return cntSub ; }
bool checkPalinK ( string str , int K ) { int N = str . length ( ) ; int cntFreq [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { cntFreq [ str [ i ] ] ++ ; } int cntOddFreq = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( cntFreq [ i ] % 2 == 1 ) { cntOddFreq ++ ; } } if ( cntOddFreq <= ( K + 1 ) ) { return true ; } return false ; }
void printIndexes ( string str ) { int N = str . length ( ) ; int cntFreq [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { cntFreq [ str [ i ] ] ++ ; } int cntLeftFreq [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int cntLeft = 0 ; int cntRight = 0 ; for ( int j = str [ i ] - 1 ; j >= 0 ; j -- ) { cntLeft += cntLeftFreq [ j ] ; cntRight += cntFreq [ j ] - cntLeftFreq [ j ] ; } cntLeftFreq [ str [ i ] ] ++ ; if ( cntLeft == cntRight && cntLeft != 0 ) { cout << i << " " ; } } }
int digiSum ( int a ) { int sum = 0 ; while ( a ) { sum += a % 10 ; a = a / 10 ; } return sum ; }
bool isPrime ( int r ) { bool s = true ; for ( int i = 2 ; i * i <= r ; i ++ ) { if ( r % i == 0 ) { s = false ; break ; } } return s ; }
int Count_Number ( int x ) { int ans = 0 ; if ( x % 99 != 0 ) { ans = -1 ; } else { int diff = x / 99 ; for ( int i = 1 ; i < 10 ; i ++ ) { for ( int j = 1 ; j < 10 ; j ++ ) { if ( ( i - j ) == diff ) { ans += 10 ; } } } } return ans ; }
int find_index ( int arr [ ] , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == K ) return i ; else if ( arr [ i ] > K ) return i ; return n ; }
int find_index ( int arr [ ] , int n , int K ) { int start = 0 ; int end = n - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] == K ) return mid ; else if ( arr [ mid ] < K ) start = mid + 1 ; else end = mid - 1 ; } return end + 1 ; }
bool isinRange ( int board [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( board [ i ] [ j ] <= 0 board [ i ] [ j ] > 9 ) { return false ; } } } return true ; }
bool isValidSudoku ( int board [ ] [ N ] ) { if ( isinRange ( board ) == false ) { return false ; } bool unique [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { memset ( unique , false , sizeof ( unique ) ) ; for ( int j = 0 ; j < N ; j ++ ) { int Z = board [ i ] [ j ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } for ( int i = 0 ; i < N ; i ++ ) { memset ( unique , false , sizeof ( unique ) ) ; for ( int j = 0 ; j < N ; j ++ ) { int Z = board [ j ] [ i ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } for ( int i = 0 ; i < N - 2 ; i += 3 ) { for ( int j = 0 ; j < N - 2 ; j += 3 ) { memset ( unique , false , sizeof ( unique ) ) ; for ( int k = 0 ; k < 3 ; k ++ ) { for ( int l = 0 ; l < 3 ; l ++ ) { int X = i + k ; int Y = j + l ; int Z = board [ X ] [ Y ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } } } return true ; }
void minSubarray ( int * arr , int N ) { unordered_map < int , int > m ; for ( int i = 0 ; i < N ; i ++ ) { int mini = INT_MAX ; for ( int j = i ; j < N ; j ++ ) { mini = min ( mini , arr [ j ] ) ; m [ mini ] ++ ; } } for ( int i = 0 ; i < N ; i ++ ) { cout << m [ arr [ i ] ] << " " ; } }
void minSubarray ( int * arr , int N ) { int result [ N ] ; stack < pair < int , int > > l , r ; for ( int i = 0 ; i < N ; i ++ ) { int count = 1 ; while ( ! l . empty ( ) && l . top ( ) . first > arr [ i ] ) { count += l . top ( ) . second ; l . pop ( ) ; } l . push ( { arr [ i ] , count } ) ; result [ i ] = count ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { int count = 1 ; while ( ! r . empty ( ) && r . top ( ) . first >= arr [ i ] ) { count += r . top ( ) . second ; r . pop ( ) ; } r . push ( { arr [ i ] , count } ) ; result [ i ] *= count ; } for ( int i = 0 ; i < N ; i ++ ) { cout << result [ i ] << " " ; } }
bool isPrime ( int num ) { if ( num <= 1 ) return false ; for ( int i = 2 ; i * i <= num ; i ++ ) if ( num % i == 0 ) return false ; return true ; }
bool isFulPrime ( int n ) { if ( ! isPrime ( n ) ) return false ; else { while ( n > 0 ) { int rem = n % 10 ; if ( ! ( rem == 2 rem == 3 rem == 5 rem == 7 ) ) return false ; n = n / 10 ; } } return true ; }
int countFulPrime ( int L , int R ) { int cnt = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( ( i % 2 ) != 0 && isFulPrime ( i ) ) { cnt ++ ; } } return cnt ; }
int computePos ( int arr [ ] , int n , int value ) { if ( value < arr [ 0 ] ) return 0 ; if ( value > arr [ n - 1 ] ) return n - 1 ; int start = 0 ; int end = n - 1 ; while ( start < end ) { int mid = ( start + end + 1 ) / 2 ; if ( arr [ mid ] >= value ) end = mid - 1 ; else start = mid ; } return start ; }
void countShift ( int arr [ ] , int n , vector < vector < int > > & queries ) { for ( auto q : queries ) { int index = q [ 0 ] ; int update = q [ 1 ] ; int newElement = arr [ index ] + update ; int newIndex = computePos ( arr , n , newElement ) ; cout << abs ( newIndex - index ) << " " ; } }
void printAlter ( int arr [ ] , int N ) { for ( int currIndex = 0 ; currIndex < N ; currIndex ++ ) { if ( currIndex % 2 == 0 ) { cout << arr [ currIndex ] << " " ; } } }
void printAlter ( int arr [ ] , int N ) { for ( int currIndex = 0 ; currIndex < N ; currIndex += 2 ) { cout << arr [ currIndex ] << " " ; } }
int findmin ( string s ) { int n = s . length ( ) ; int i , j , maximum = 0 ; int incr [ n + 1 ] = { 0 } ; for ( i = 0 ; i < n ; i ++ ) { incr [ i + 1 ] = incr [ i ] ; if ( s [ i ] == '0' ) { incr [ i + 1 ] ++ ; } } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { maximum = max ( maximum , incr [ i ] + j - i + 1 - ( incr [ j + 1 ] - incr [ i ] ) + incr [ n ] - incr [ j + 1 ] ) ; } } return n - maximum ; }
void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
int digitSum ( int number ) { int sum = 0 ; while ( number > 0 ) { sum += ( number % 10 ) ; number /= 10 ; } return sum ; }
void longestCompositeDigitSumSubsequence ( int arr [ ] , int n ) { int count = 0 ; bool prime [ N + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , N ) ; for ( int i = 0 ; i < n ; i ++ ) { int res = digitSum ( arr [ i ] ) ; if ( res == 1 ) { continue ; } if ( ! prime [ res ] ) { count ++ ; } } cout << count << endl ; }
bool isPower ( int x ) { return ( x && ( ! ( x & ( x - 1 ) ) ) ) ; }
int maximumlength ( int arr [ ] , int N ) { int max_length = 0 ; int max_len_subarray = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( isPower ( arr [ i ] ) == 1 ) { max_length ++ ; max_len_subarray = max ( max_length , max_len_subarray ) ; } else { max_length = 0 ; } } cout << max_len_subarray ; }
void minSub ( int N ) { int count = 0 ; while ( N >= 0 ) { int num = N ; int rev = 0 ; while ( num != 0 ) { int digit = num % 10 ; rev = ( rev * 10 ) + digit ; num = num / 10 ; } if ( N == rev ) { break ; } count ++ ; N -- ; } cout << count ; }
bool isPalindrome ( string str ) { int i = 0 , j = str . size ( ) - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; }
int isPerfect ( int N ) { int sum = 1 ; for ( int i = 2 ; i < sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { sum += i ; } else { sum += i + N / i ; } } } if ( sum == N && N != 1 ) return 1 ; return 0 ; }
int maxSum ( int arr [ ] , int N , int K ) { if ( N < K ) { cout << "Invalid" ; return -1 ; } int res = 0 ; for ( int i = 0 ; i < K ; i ++ ) { res += arr [ i ] ; } int curr_sum = res ; for ( int i = K ; i < N ; i ++ ) { curr_sum += arr [ i ] - arr [ i - K ] ; res = max ( res , curr_sum ) ; } return res ; }
int max_PerfectNumbers ( int arr [ ] , int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = isPerfect ( arr [ i ] ) ? 1 : 0 ; } return maxSum ( arr , N , K ) ; }
int minElements ( int A [ ] , int B [ ] , int N , int M ) { map < int , int > map ; for ( int i = 0 ; i < N ; i ++ ) { map [ A [ i ] ] = i ; } vector < int > subseq ; int l = 0 , r = -1 ; for ( int i = 0 ; i < M ; i ++ ) { if ( map . find ( B [ i ] ) != map . end ( ) ) { int e = map [ B [ i ] ] ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( subseq [ m ] < e ) l = m + 1 ; else r = m - 1 ; } if ( r + 1 < subseq . size ( ) ) { subseq [ r + 1 ] = e ; } else { subseq . push_back ( e ) ; } l = 0 ; r = subseq . size ( ) - 1 ; } } return N - subseq . size ( ) ; }
int cntSubarr ( int arr [ ] , int N ) { int res = 0 ; int prefixXor = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { prefixXor = arr [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { prefixXor ^= arr [ j ] ; if ( prefixXor == 0 && ( j - i + 1 ) % 2 == 0 ) { res ++ ; } } } return res ; }
int cntSubXor ( int arr [ ] , int N ) { int prefixXor = 0 ; int Even [ M ] ; int Odd [ M ] ; int cntSub = 0 ; Odd [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { prefixXor ^= arr [ i ] ; if ( i % 2 == 1 ) { cntSub += Odd [ prefixXor ] ; Odd [ prefixXor ] ++ ; } else { cntSub += Even [ prefixXor ] ; Even [ prefixXor ] ++ ; } } return cntSub ; }
int zvalue ( vector < int > & nums ) { int m = * max_element ( nums . begin ( ) , nums . end ( ) ) ; int cnt = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { cnt = 0 ; for ( int j = 0 ; j < nums . size ( ) ; j ++ ) { if ( nums [ j ] >= i ) cnt ++ ; } if ( cnt == i ) return i ; } return -1 ; }
bool isEvenOddBinaryTree ( Node * root ) { if ( root == NULL ) return true ; queue < Node * > q ; q . push ( root ) ; int level = 0 ; while ( ! q . empty ( ) ) { int size = q . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Node * node = q . front ( ) ; if ( level % 2 == 0 ) { if ( node -> val % 2 == 1 ) return false ; } else if ( level % 2 == 1 ) { if ( node -> val % 2 == 0 ) return true ; } if ( node -> left != NULL ) { q . push ( node -> left ) ; } if ( node -> right != NULL ) { q . push ( node -> right ) ; } } level ++ ; } return true ; }
bool is_prime ( int n ) { if ( n <= 1 ) return 0 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return 0 ; } return 1 ; }
void countSmallerPrimes ( int ar [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = i + 1 ; j < N ; j ++ ) { if ( ar [ j ] <= ar [ i ] && is_prime ( ar [ j ] ) ) { count ++ ; } } cout << count << " " ; } }
bool is_prime ( int n ) { if ( n <= 1 ) return 0 ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return 0 ; return 1 ; }
bool checkConcat ( string str1 , string str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; if ( N % M != 0 ) { return false ; } for ( int i = 0 ; i < N ; i ++ ) { if ( str1 [ i ] != str2 [ i % M ] ) { return false ; } } return true ; }
int MinLen ( string str , int K ) { int N = str . length ( ) ; int i = 0 ; while ( i < N - 1 ) { if ( str [ i ] != str [ i + 1 ] ) { break ; } i ++ ; } if ( i == N - 1 ) { return N ; } return max ( 1 , N - K ) ; }
int findSubArray ( vector < int > arr , int k ) { int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( palindrome ( arr , i , i + k - 1 ) ) return i ; } return -1 ; }
bool helper ( int mid ) { int cnt = 0 ; for ( auto i : mp ) { int temp = i . second ; while ( temp >= mid ) { temp -= mid ; cnt ++ ; } } return cnt >= N ; }
int findMaximumDays ( int arr [ ] ) { for ( int i = 0 ; i < P ; i ++ ) { mp [ arr [ i ] ] ++ ; } int start = 0 , end = P , ans = 0 ; while ( start <= end ) { int mid = start + ( ( end - start ) / 2 ) ; if ( mid != 0 and helper ( mid ) ) { ans = mid ; start = mid + 1 ; } else if ( mid == 0 ) { start = mid + 1 ; } else { end = mid - 1 ; } } return ans ; }
double temp ( int n , int x ) { return pow ( x * 1.0 / n , n ) ; }
bool check ( int n , int y , int x ) { double v = temp ( n , x ) ; return ( v >= y ) ; }
void speciallyBalancedNodes ( int R , int N , string str [ ] , int values [ ] ) { Node * root = build_tree ( R , N , str , values ) ; int sum = 0 ; SBTUtil ( root , sum ) ; cout << sum << " " ; }
void display ( int countLeftGreater [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { cout << countLeftGreater [ i ] << " " ; } }
int minLength ( int arr [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return 1 ; } } return N ; }
void PrintIndexes ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int currSubSum = 0 ; for ( int j = i ; j < N ; j ++ ) { currSubSum += arr [ j ] ; int sq = sqrt ( currSubSum ) ; if ( sq * sq == currSubSum ) { cout << "(" << i << ", " << j << ") " ; } } } }
bool check ( vector < int > pSum , int len , int k , vector < int > a ) { int i = 0 ; int j = len ; while ( j <= a . size ( ) ) { int maxSize = a [ j - 1 ] ; int totalNumbers = maxSize * len ; int currNumbers = pSum [ j ] - pSum [ i ] ; if ( currNumbers + k >= totalNumbers ) { return true ; } else { i ++ ; j ++ ; } } return false ; }
int countPosition ( vector < vector < int > > mat ) { int n = mat . size ( ) ; int m = mat [ 0 ] . size ( ) ; vector < int > row ( n ) ; vector < int > col ( m ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { col [ j ] ++ ; row [ i ] ++ ; } } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( row [ i ] == col [ j ] ) { count ++ ; } } } return count ; }
void position ( int arr [ ] [ 2 ] , int N ) { int pos = -1 ; int count ; for ( int i = 0 ; i < N ; i ++ ) { count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ 0 ] <= arr [ j ] [ 0 ] && arr [ i ] [ 1 ] >= arr [ j ] [ 1 ] ) { count ++ ; } } if ( count == N ) { pos = i ; } } if ( pos == -1 ) { cout << pos ; } else { cout << pos + 1 ; } }
int maxAtLevel ( int N , int M , vector < int > Value , int Edges [ ] [ 2 ] ) { vector < int > adj [ N ] ; for ( int i = 0 ; i < M ; i ++ ) { int u = Edges [ i ] [ 0 ] ; int v = Edges [ i ] [ 1 ] ; adj [ u ] . push_back ( v ) ; } queue < int > q ; q . push ( 0 ) ; while ( ! q . empty ( ) ) { int count = q . size ( ) ; int maxVal = 0 ; while ( count -- ) { int temp = q . front ( ) ; q . pop ( ) ; maxVal = max ( maxVal , Value [ temp ] ) ; for ( int i = 0 ; i < adj [ temp ] . size ( ) ; i ++ ) { q . push ( adj [ temp ] [ i ] ) ; } } cout << maxVal << " " ; } }
int floyd_warshall ( int * graph , int V ) { int dist [ V ] [ V ] , i , j , k ; for ( i = 0 ; i < V ; i ++ ) { for ( j = 0 ; j < V ; j ++ ) { dist [ i ] [ j ] = * ( ( graph + i * V ) + j ) ; } } for ( k = 0 ; k < V ; k ++ ) { for ( i = 0 ; i < V ; i ++ ) { for ( j = 0 ; j < V ; j ++ ) { if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) { dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; } } } } int sum = 0 ; for ( i = 0 ; i < V ; i ++ ) { for ( j = i + 1 ; j < V ; j ++ ) { sum += dist [ i ] [ j ] ; } } return sum ; }
int sumOfshortestPath ( int N , int E , int edges [ ] [ 3 ] ) { int g [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { g [ i ] [ j ] = INF ; } } for ( int i = 0 ; i < E ; i ++ ) { int u = edges [ i ] [ 0 ] ; int v = edges [ i ] [ 1 ] ; int w = edges [ i ] [ 2 ] ; g [ u ] [ v ] = w ; g [ v ] [ u ] = w ; } return floyd_warshall ( ( int * ) g , N ) ; }
int minCost ( string A , string B ) { int n = A . size ( ) ; int i = 0 ; int maxlen = 0 ; while ( i < n ) { int length = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( A [ i ] == B [ j ] ) { ++ i ; ++ length ; if ( i == n ) break ; } } maxlen = max ( maxlen , length ) ; } return n - maxlen ; }
int binarySearch ( int arr [ ] , int N , int X ) { int start = 0 ; int end = N ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( X == arr [ mid ] ) { return mid ; } else if ( X < arr [ mid ] ) { start = mid + 1 ; } else { end = mid - 1 ; } } return -1 ; }
bool check ( int a [ ] , int n ) { int b [ n ] ; int minElement = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = a [ i ] ; minElement = min ( minElement , a [ i ] ) ; } sort ( b , b + n ) ; int k = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] && a [ i ] % minElement != 0 ) { k = 0 ; break ; } } return k == 1 ? true : false ; }
bool check_both_present ( int arr [ ] , int N , int a , int b ) { bool f1 = false , f2 = false ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == a ) { f1 = true ; } if ( arr [ i ] == b ) { f2 = true ; } } if ( f1 && f2 ) { return true ; } else { return false ; } }
void print_array ( int ans [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { cout << ans [ i ] << " " ; } }
void build_AP ( int N , int a , int b ) { int arr [ N ] , ans [ N ] ; for ( int i = 0 ; i < N ; i ++ ) ans [ i ] = INT_MAX ; int flag = 0 ; if ( a > b ) { swap ( a , b ) ; } int diff = b - a ; for ( int start = 1 ; start <= a ; start ++ ) { for ( int d = 1 ; d <= diff ; d ++ ) { arr [ 0 ] = start ; for ( int i = 1 ; i < N ; i ++ ) { arr [ i ] = arr [ i - 1 ] + d ; } if ( check_both_present ( arr , N , a , b ) && arr [ N - 1 ] < ans [ N - 1 ] ) { for ( int i = 0 ; i < N ; i ++ ) { ans [ i ] = arr [ i ] ; } } } } print_array ( ans , N ) ; }
int numSpecial ( vector < vector < int > > & mat ) { int m = mat . size ( ) , n = mat [ 0 ] . size ( ) ; int rows [ m ] ; int cols [ n ] ; int i , j ; for ( i = 0 ; i < m ; i ++ ) { rows [ i ] = 0 ; for ( j = 0 ; j < n ; j ++ ) rows [ i ] += mat [ i ] [ j ] ; } for ( i = 0 ; i < n ; i ++ ) { cols [ i ] = 0 ; for ( j = 0 ; j < m ; j ++ ) cols [ i ] += mat [ j ] [ i ] ; } int cnt = 0 ; for ( i = 0 ; i < m ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 && rows [ i ] == 1 && cols [ j ] == 1 ) cnt ++ ; } } return cnt ; }
int ctMinEdits ( string str1 , string str2 ) { int N1 = str1 . length ( ) ; int N2 = str2 . length ( ) ; int freq1 [ 256 ] = { 0 } ; for ( int i = 0 ; i < N1 ; i ++ ) { freq1 [ str1 [ i ] ] ++ ; } int freq2 [ 256 ] = { 0 } ; for ( int i = 0 ; i < N2 ; i ++ ) { freq2 [ str2 [ i ] ] ++ ; } for ( int i = 0 ; i < 256 ; i ++ ) { if ( freq1 [ i ] > freq2 [ i ] ) { freq1 [ i ] = freq1 [ i ] - freq2 [ i ] ; freq2 [ i ] = 0 ; } else { freq2 [ i ] = freq2 [ i ] - freq1 [ i ] ; freq1 [ i ] = 0 ; } } int sum1 = 0 ; int sum2 = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { sum1 += freq1 [ i ] ; sum2 += freq2 [ i ] ; } return max ( sum1 , sum2 ) ; }
void create_graph ( ) { g [ 1 ] . push_back ( 2 ) ; g [ 2 ] . push_back ( 1 ) ; g [ 1 ] . push_back ( 3 ) ; g [ 3 ] . push_back ( 1 ) ; g [ 1 ] . push_back ( 4 ) ; g [ 4 ] . push_back ( 1 ) ; g [ 2 ] . push_back ( 5 ) ; g [ 5 ] . push_back ( 2 ) ; g [ 2 ] . push_back ( 6 ) ; g [ 6 ] . push_back ( 2 ) ; }
void dfs ( int node , int parent ) { size [ node ] = 1 ; int mx = 0 ; for ( int y : g [ node ] ) { if ( y == parent ) continue ; dfs ( y , node ) ; size [ node ] += size [ y ] ; mx = max ( mx , size [ y ] ) ; } mx = max ( mx , n - size [ node ] ) ; if ( mx < mini ) { mini = mx ; ans = node ; } }
int countPrecedingK ( int a [ ] , int n , int K ) { int prefix [ n ] ; prefix [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + a [ i ] ; } int ctr = 0 ; if ( prefix [ K - 1 ] < a [ K ] ) ctr ++ ; for ( int i = K + 1 ; i < n ; i ++ ) { if ( prefix [ i - 1 ] - prefix [ i - K - 1 ] < a [ i ] ) ctr ++ ; } return ctr ; }
int minDigits ( int N , int K ) { int digits_num = floor ( log10 ( N ) + 1 ) ; int temp_sum = 0 ; int temp = digits_num ; int result ; int X , var ; int sum = 0 ; int num2 = N ; while ( num2 != 0 ) { sum += num2 % 10 ; num2 /= 10 ; } if ( sum <= K ) { X = 0 ; } else { while ( temp > 0 ) { var = ( N / ( pow ( 10 , temp - 1 ) ) ) ; temp_sum += var % 10 ; if ( temp_sum >= K ) { var /= 10 ; var ++ ; result = var * pow ( 10 , temp ) ; break ; } temp -- ; } X = result - N ; return X ; } }
int CountPairs ( int * a , int * b , int n ) { int C [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { C [ i ] = a [ i ] + b [ i ] ; } map < int , int > freqCount ; for ( int i = 0 ; i < n ; i ++ ) { freqCount [ C [ i ] ] ++ ; } int NoOfPairs = 0 ; for ( auto x : freqCount ) { int y = x . second ; NoOfPairs = NoOfPairs + y * ( y - 1 ) / 2 ; } cout << NoOfPairs ; }
void convertBfromA ( int a , int b ) { int moves = 0 ; int x = abs ( a - b ) ; for ( int i = 10 ; i > 0 ; i -- ) { moves += x / i ; x = x % i ; } cout << moves << " " ; }
int smallestNth ( int A , int B , int N ) { int res = INT_MAX ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = N ; j > i ; j -- ) { if ( ( B - A ) % ( j - i ) == 0 ) { int D = ( B - A ) / ( j - i ) ; int FirstTerm = A - ( i - 1 ) * D ; int NthTerm = FirstTerm + ( N - 1 ) * D ; if ( FirstTerm > 0 ) res = min ( res , NthTerm ) ; } } } return res ; }
void sieve ( bool prime [ ] ) { for ( int i = 0 ; i < 1000000 ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = prime [ 1 ] = false ; for ( int i = 2 ; i * i <= 1000000 ; i ++ ) { if ( prime [ i ] ) { for ( int j = i * i ; j <= 1000000 ; j += i ) { prime [ j ] = false ; } } } }
void subPrimeSum ( int N , int K , int arr [ ] , bool prime [ ] ) { int currSum = 0 ; for ( int i = 0 ; i < K ; i ++ ) { currSum += arr [ i ] ; } if ( prime [ currSum ] ) { for ( int i = 0 ; i < K ; i ++ ) { cout << arr [ i ] << " " ; } return ; } int st = 1 , en = K ; while ( en < N ) { currSum += arr [ en ] - arr [ st - 1 ] ; if ( prime [ currSum ] ) { for ( int i = st ; i <= en ; i ++ ) { cout << arr [ i ] << " " ; } return ; } en ++ ; st ++ ; } }
int minDeletion ( string str ) { int n = str . length ( ) ; int firstIdx1 = -1 ; int lastIdx0 = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { firstIdx1 = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) { lastIdx0 = i ; break ; } } if ( firstIdx1 == -1 lastIdx0 == -1 ) return 0 ; int count1 = 0 , count0 = 0 ; for ( int i = 0 ; i < lastIdx0 ; i ++ ) { if ( str [ i ] == '1' ) { count1 ++ ; } } for ( int i = firstIdx1 + 1 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { count0 ++ ; } } return min ( count0 , count1 ) ; }
int maximumSum ( int a [ ] , int b [ ] , int n , int index , int lastpicked ) { if ( index == n ) return 0 ; int option1 = 0 , option2 = 0 ; if ( lastpicked == -1 a [ lastpicked ] != a [ index ] ) option1 = b [ index ] + maximumSum ( a , b , n , index + 1 , index ) ; option2 = maximumSum ( a , b , n , index + 1 , lastpicked ) ; return max ( option1 , option2 ) ; }
int maximumSum ( int a [ ] , int b [ ] , int n , int index , int lastpicked , vector < vector < int > > dp ) { if ( index == n ) return 0 ; if ( dp [ index ] [ lastpicked + 1 ] != -1 ) return dp [ index ] [ lastpicked + 1 ] ; int option1 = 0 , option2 = 0 ; if ( lastpicked == -1 a [ lastpicked ] != a [ index ] ) { option1 = b [ index ] + maximumSum ( a , b , n , index + 1 , index , dp ) ; } option2 = maximumSum ( a , b , n , index + 1 , lastpicked , dp ) ; return dp [ index ] [ lastpicked + 1 ] = max ( option1 , option2 ) ; }
void sumOfKElements ( int arr [ ] , int n , int k ) { bool rev = false ; if ( k < 0 ) { rev = true ; k *= -1 ; int l = 0 , r = n - 1 ; while ( l < r ) { int tmp = arr [ l ] ; arr [ l ] = arr [ r ] ; arr [ r ] = tmp ; l ++ ; r -- ; } } int dp [ n ] = { 0 } ; dp [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] += dp [ i - 1 ] + arr [ i ] ; } int ans [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( i + k < n ) ans [ i ] = dp [ i + k ] - dp [ i ] ; else { int x = k - ( n - 1 - i ) ; int y = x / n ; int rem = x % n ; ans [ i ] = dp [ n - 1 ] - dp [ i ] + y * dp [ n - 1 ] + ( rem - 1 >= 0 ? dp [ rem - 1 ] : 0 ) ; } } if ( rev ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { cout << ans [ i ] << " " ; } } else { for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << " " ; } } }
vector < int > countingSubarray ( vector < int > arr , int n ) { vector < int > a ( n ) ; vector < int > nsml ( n , -1 ) ; vector < int > nsmr ( n , n ) ; stack < int > st ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( ! st . empty ( ) && arr [ st . top ( ) ] >= arr [ i ] ) st . pop ( ) ; nsmr [ i ] = ( ! st . empty ( ) ) ? st . top ( ) : n ; st . push ( i ) ; } while ( ! st . empty ( ) ) st . pop ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! st . empty ( ) && arr [ st . top ( ) ] >= arr [ i ] ) st . pop ( ) ; nsml [ i ] = ( ! st . empty ( ) ) ? st . top ( ) : -1 ; st . push ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { nsml [ i ] ++ ; nsmr [ i ] -- ; int r = nsmr [ i ] - i + 1 ; int l = i - nsml [ i ] + 1 ; a [ i ] = r * l ; } return a ; }
int countTuples ( int arr [ ] , int N ) { int ans = 0 , val = 0 ; unordered_map < int , int > freq ; for ( int j = 0 ; j < N - 2 ; j ++ ) { val = 0 ; for ( int l = j + 1 ; l < N ; l ++ ) { if ( arr [ j ] == arr [ l ] ) { ans += val ; } val += freq [ arr [ l ] ] ; } freq [ arr [ j ] ] ++ ; } return ans ; }
bool isCrossed ( string path ) { if ( path . size ( ) == 0 ) return false ; bool ans = false ; set < pair < int , int > > set ; int x = 0 , y = 0 ; set . insert ( { x , y } ) ; for ( int i = 0 ; i < path . size ( ) ; i ++ ) { if ( path [ i ] == 'N' ) set . insert ( { x , y ++ } ) ; if ( path [ i ] == 'S' ) set . insert ( { x , y -- } ) ; if ( path [ i ] == 'E' ) set . insert ( { x ++ , y } ) ; if ( path [ i ] == 'W' ) set . insert ( { x -- , y } ) ; if ( set . find ( { x , y } ) != set . end ( ) ) { ans = true ; break ; } } if ( ans ) cout << "Crossed" ; else cout << "Not Crossed" ; }
int GCD ( int a , int b ) { if ( b == 0 ) { return a ; } return GCD ( b , a % b ) ; }
void GcdPair ( vector < pair < int , int > > arr , int k ) { int lo = 0 , hi = arr . size ( ) - 1 , mid ; pair < int , int > ans ; ans = make_pair ( -1 , 0 ) ; while ( lo <= hi ) { mid = lo + ( hi - lo ) / 2 ; if ( GCD ( arr [ mid ] . first , arr [ mid ] . second ) > k ) { ans = arr [ mid ] ; hi = mid - 1 ; } else lo = mid + 1 ; } if ( ans . first == -1 ) cout << "-1" ; else cout << "( " << ans . first << ", " << ans . second << " )" ; return ; }
void isPossible ( int arr [ ] , int N ) { int mn = INT_MAX ; int B [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { mn = min ( mn , arr [ i ] ) ; B [ i ] = arr [ i ] ; } sort ( arr , arr + N ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != B [ i ] ) { if ( B [ i ] % mn != 0 ) { cout << "No" ; return ; } } } cout << "Yes" ; return ; }
int func ( int n ) { int count = 0 ; if ( n == 2 or n == 1 ) return 1 ; if ( n % 2 == 0 ) count = 1 + func ( n / 2 ) ; if ( n % 2 != 0 ) count = 1 + func ( n * 3 + 1 ) ; return count ; }
void findKthElement ( int l , int r , int k ) { vector < int > arr ; for ( int i = l ; i <= r ; i ++ ) arr . push_back ( i ) ; vector < vector < int > > result ; for ( int i : arr ) result . push_back ( { i , func ( i ) } ) ; sort ( result . begin ( ) , result . end ( ) ) ; cout << ( result [ k - 1 ] [ 0 ] ) ; }
void checkHex ( string s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { char ch = s [ i ] ; if ( ( ch < '0' ch > '9' ) && ( ch < 'A' ch > ' F ' ) ) { cout << "No" << endl  ; return  ; } }
int maxWidth ( int N , int M , vector < int > cost , vector < vector < int > > s ) { vector < int > adj [ N ] ; for ( int i = 0 ; i < M ; i ++ ) { adj [ s [ i ] [ 0 ] ] . push_back ( s [ i ] [ 1 ] ) ; } int result = 0 ; queue < int > q ; q . push ( 0 ) ; while ( ! q . empty ( ) ) { int count = q . size ( ) ; result = max ( count , result ) ; while ( count -- ) { int temp = q . front ( ) ; q . pop ( ) ; for ( int i = 0 ; i < adj [ temp ] . size ( ) ; i ++ ) { q . push ( adj [ temp ] [ i ] ) ; } } } return result ; }
void addEdge ( vector < int > adj [ ] , int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; }
void DFSUtil ( int u , vector < int > adj [ ] , vector < bool > & visited , int & componentMin , int & componentMax ) { visited [ u ] = true ; componentMax = max ( componentMax , u ) ; componentMin = min ( componentMin , u ) ; for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) if ( visited [ adj [ u ] [ i ] ] == false ) DFSUtil ( adj [ u ] [ i ] , adj , visited , componentMin , componentMax ) ; }
bool isValid ( vector < pair < int , int > > & v ) { int MAX = -1 ; bool ans = 0 ; for ( auto i : v ) { if ( i . first <= MAX ) { ans = 1 ; } MAX = max ( MAX , i . second ) ; } return ( ans == 0 ? 1 : 0 ) ; }
void DFS ( vector < int > adj [ ] , int V ) { std :: vector < pair < int , int > > v ; vector < bool > visited ( V , false ) ; for ( int u = 1 ; u <= V ; u ++ ) { if ( visited [ u ] == false ) { int componentMax = u ; int componentMin = u ; DFSUtil ( u , adj , visited , componentMin , componentMax ) ; v . push_back ( { componentMin , componentMax } ) ; } } bool check = isValid ( v ) ; if ( check ) cout << "Yes" ; else cout << "No" ; return ; }
bool checkEqual ( string arr [ ] , int N ) { int hash [ 256 ] = { 0 } ; int M = arr [ 0 ] . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { hash [ arr [ i ] [ j ] ] ++ ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( hash [ i ] % N != 0 ) { return false ; } } return true ; }
void print_substring ( string s ) { int n = s . size ( ) ; string str = "" ; vector < int > ans ; if ( n == 0 ) { cout << "-1" ; return ; } vector < int > last_pos ( 26 , -1 ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( last_pos [ s [ i ] - 'a' ] == -1 ) { last_pos [ s [ i ] - 'a' ] = i ; } } int minp = -1 ; for ( int i = 0 ; i < n ; ++ i ) { int lp = last_pos [ s [ i ] - 'a' ] ; minp = max ( minp , lp ) ; if ( i == minp ) { str += s [ i ] ; cout << str << ' ' ; minp = -1 ; str = "" ; } else { str += s [ i ] ; } } }
void partitionString ( string s ) { int n = s . size ( ) ; vector < int > ans ; if ( n == 0 ) { cout << "-1" ; return ; } vector < int > last_pos ( 26 , -1 ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( last_pos [ s [ i ] - 'a' ] == -1 ) { last_pos [ s [ i ] - 'a' ] = i ; } } int minp = -1 , plen = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int lp = last_pos [ s [ i ] - 'a' ] ; minp = max ( minp , lp ) ; ++ plen ; if ( i == minp ) { ans . push_back ( plen ) ; minp = -1 ; plen = 0 ; } } for ( int i = 0 ; i < ( int ) ans . size ( ) ; i ++ ) { cout << ans [ i ] << " " ; } }
int lenghtOfLongestAP ( int A [ ] , int n ) { unordered_map < int , unordered_map < int , int > > dp ; int res = 2 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int d = A [ j ] - A [ i ] ; dp [ d ] [ j ] = dp [ d ] . count ( i ) ? dp [ d ] [ i ] + 1 : 2 ; res = max ( res , dp [ d ] [ j ] ) ; } } return res ; }
void numDifferenceUtil ( int N , int K ) { vector < int > res ; res = numDifference ( N , K ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) { cout << res [ i ] << " " ; } }
int minFirstTerm ( int X , int diff , int N ) { int first_term ; int low = 0 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( X - mid * diff > 0 ) { first_term = X - mid * diff ; low = mid + 1 ; } else high = mid - 1 ; } return first_term ; }
bool isCubeSum ( int n ) { for ( int i = 1 ; i * i * i <= n ; i ++ ) { if ( i * i * i + ( i + 1 ) * ( i + 1 ) * ( i + 1 ) == n ) return true ; } return false ; }
bool isSumCube ( int N ) { int a = cbrt ( N ) ; int b = a - 1 ; return ( ( a * a * a + b * b * b ) == N ) ; }
int maxweight ( int s , int e , unordered_map < int , int > & pre ) { if ( s == e ) return 0 ; int ans = 0 ; for ( int i = s ; i < e ; i ++ ) { int left = pre [ i ] - pre [ s - 1 ] ; int right = pre [ e ] - pre [ i ] ; if ( left < right ) ans = max ( ans , left + maxweight ( s , i , pre ) ) ; if ( left == right ) { ans = max ( { ans , left + maxweight ( s , i , pre ) , right + maxweight ( i + 1 , e , pre ) } ) ; } if ( left > right ) ans = max ( ans , right + maxweight ( i + 1 , e , pre ) ) ; } return ans ; }
void maxSum ( vector < int > arr ) { unordered_map < int , int > pre ; pre [ -1 ] = 0 ; pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < arr . size ( ) ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } cout << maxweight ( 0 , arr . size ( ) - 1 , pre ) ; }
void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
int LISPrime ( int arr [ ] , int n ) { int lisp [ n ] ; bool prime [ N + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , N ) ; lisp [ 0 ] = prime [ arr [ 0 ] ] ? 1 : 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ! prime [ arr [ i ] ] ) { lisp [ i ] = 0 ; continue ; } lisp [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( prime [ arr [ j ] ] && arr [ i ] > arr [ j ] && lisp [ i ] < lisp [ j ] + 1 ) { lisp [ i ] = lisp [ j ] + 1 ; } } } return * max_element ( lisp , lisp + n ) ; }
void checkSumOfNatural ( int n ) { int i = 1 ; bool flag = false ; while ( i * ( i + 1 ) < n * 2 ) { int X = i * ( i + 1 ) ; int t = n * 2 - X ; int k = sqrt ( t ) ; if ( k * ( k + 1 ) == t ) { flag = true ; break ; } i += 1 ; } if ( flag ) cout << "YES" ; else cout << "NO" ; }
void countNumEnds ( int A , int L , int R ) { int temp , count = 0 , digits ; int cycle ; digits = log10 ( A ) + 1 ; temp = pow ( 10 , digits ) ; cycle = temp ; while ( temp <= R ) { if ( temp >= L ) count ++ ; temp += cycle ; } cout << count ; }
int minOperations ( string s ) { int len = s . length ( ) ; int result = 0 ; for ( int i = 0 ; i < len / 2 ; i ++ ) { int D1 = max ( s [ i ] , s [ len - 1 - i ] ) - min ( s [ i ] , s [ len - 1 - i ] ) ; int D2 = 26 - D1 ; result += min ( D1 , D2 ) ; } return result ; }
void countMaximum ( int * a , int n ) { sort ( a , a + n , cmp ) ; int count = 0 ; int mark = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ( a [ i ] + n >= mark ) ) { count += 1 ; } mark = max ( mark , a [ i ] + i + 1 ) ; } cout << count ; }
bool allCoprime ( int A [ ] , int n ) { bool all_coprime = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( __gcd ( A [ i ] , A [ j ] ) != 1 ) { all_coprime = false ; break ; } } } return all_coprime ; }
unsigned long int binomialCoeff ( unsigned int n , unsigned int k ) { unsigned long int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
unsigned long int catalan ( unsigned int n ) { unsigned long int c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
unsigned long int findWays ( unsigned n ) { if ( n & 1 ) return 0 ; return catalan ( n / 2 ) ; }
void countNonNPeriodic ( int N ) { cout << findWays ( 2 * N ) - findWays ( N ) ; }
int isValid ( int n , int m , int k ) { int step2 = n - m ; int cnt = ( step2 * ( step2 + 1 ) ) / 2 ; if ( cnt - m == k ) return 0 ; if ( cnt - m > k ) return 1 ; return -1 ; }
void countOfOperations ( int n , int k ) { int start = 0 , end = n ; bool ok = 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int temp = isValid ( n , mid , k ) ; if ( temp == 0 ) { ok = 0 ; cout << mid ; break ; } else if ( temp == 1 ) { start = mid + 1 ; } else { end = mid - 1 ; } } if ( ok ) cout << "-1" ; }
bool nonLower ( string s ) { for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( ! islower ( s [ i ] ) ) { return true ; } } return false ; }
char getChar ( int n ) { return ( char ) ( n + 96 ) ; }
vector < string > getCode ( string str ) { if ( str . size ( ) == 0 ) { vector < string > ans ; ans . push_back ( "" ) ; return ans ; } vector < string > output1 = getCode ( str . substr ( 1 ) ) ; vector < string > output2 ( 0 ) ; int firstDigit = ( str [ 0 ] - '0' ) ; int firstTwoDigit = 0 ; if ( str . size ( ) >= 2 ) { firstTwoDigit = ( str [ 0 ] - '0' ) * 10 + ( str [ 1 ] - '0' ) ; if ( firstTwoDigit >= 10 && firstTwoDigit <= 26 ) { output2 = getCode ( str . substr ( 2 ) ) ; } } vector < string > output ( output1 . size ( ) + output2 . size ( ) ) ; int k = 0 ; for ( int i = 0 ; i < output1 . size ( ) ; i ++ ) { char ch = getChar ( firstDigit ) ; output [ i ] = ch + output1 [ i ] ; k ++ ; } for ( int i = 0 ; i < output2 . size ( ) ; i ++ ) { char ch = getChar ( firstTwoDigit ) ; output [ k ] = ch + output2 [ i ] ; k ++ ; } return output ; }
int smallestNum ( int n ) { float power = log2 ( 10 ) ; cout << power ; return ceil ( ( n - 1 ) * power ) ; }
double countSubSequence ( int arr [ ] , int n ) { int maximum = * max_element ( arr , arr + n ) ; int minimum = * min_element ( arr , arr + n ) ; if ( maximum == minimum ) return pow ( 2 , n ) - 1 ; int i = count ( arr , n , maximum ) ; int j = count ( arr , n , minimum ) ; double res = ( pow ( 2 , i ) - 1 ) * ( pow ( 2 , j ) - 1 ) * pow ( 2 , n - i - j ) ; return res ; }
int transformSubsequence ( int n , int m , vector < int > A , vector < int > B ) { if ( B . size ( ) == 0 ) return n ; vector < vector < int > > dp ( n + 1 , vector < int > ( m + 1 , 0 ) ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < m + 1 ; j ++ ) { if ( i == 0 or j == 0 ) dp [ i ] [ j ] = 0 ; else if ( A [ i - 1 ] == B [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return n - dp [ n ] [ m ] ; }
void SieveOfEratosthenes ( ) { memset ( isPrime , true , sizeof ( isPrime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= MAX ; p ++ ) if ( isPrime [ p ] ) primes . push_back ( p ) ; }
int prime_search ( vector < int > primes , int diff ) { int low = 0 ; int high = primes . size ( ) - 1 ; int res ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( primes [ mid ] == diff ) { return primes [ mid ] ; } else if ( primes [ mid ] < diff ) { low = mid + 1 ; } else { res = primes [ mid ] ; high = mid - 1 ; } } return res ; }
int minCost ( int arr [ ] , int n ) { SieveOfEratosthenes ( ) ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { int diff = arr [ i - 1 ] - arr [ i ] ; int closest_prime = prime_search ( primes , diff ) ; res += closest_prime ; arr [ i ] += closest_prime ; } } return res ; }
int isprm ( int n ) { if ( n <= 1 ) return 0 ; if ( n <= 3 ) return 1 ; if ( n % 2 == 0 n % 3 == 0 ) return 0 ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) return 0 ; } return 1 ; }
int countprime ( int n ) { int count = 0 ; vector < int > primevector ; for ( int i = 2 ; i <= n ; i ++ ) { if ( isprm ( i ) == 1 ) { primevector . push_back ( i ) ; } } int sum = primevector [ 0 ] ; for ( int i = 1 ; i < primevector . size ( ) ; i ++ ) { sum += primevector [ i ] ; if ( sum > n ) break ; if ( isprm ( sum ) == 1 ) { count ++ ; } } return count ; }
void addEdge ( vector < int > v [ ] , int x , int y ) { v [ x ] . push_back ( y ) ; v [ y ] . push_back ( x ) ; }
void dfs ( vector < int > tree [ ] , vector < int > & temp , int ancestor [ ] , int u , int parent , int k ) { temp . push_back ( u ) ; for ( auto i : tree [ u ] ) { if ( i == parent ) continue ; dfs ( tree , temp , ancestor , i , u , k ) ; } temp . pop_back ( ) ; if ( temp . size ( ) < k ) { ancestor [ u ] = -1 ; } else { ancestor [ u ] = temp [ temp . size ( ) - k ] ; } }
void KthAncestor ( int N , int K , int E , int edges [ ] [ 2 ] ) { vector < int > tree [ N + 1 ] ; for ( int i = 0 ; i < E ; i ++ ) { addEdge ( tree , edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) ; } vector < int > temp ; int ancestor [ N + 1 ] ; dfs ( tree , temp , ancestor , 1 , 0 , K ) ; for ( int i = 1 ; i <= N ; i ++ ) { cout << ancestor [ i ] << " " ; } }
vector < int > dfs ( Node * root , int distance ) { if ( root == NULL ) { vector < int > res ( distance + 1 , 0 ) ; return res ; } if ( root -> left == NULL && root -> right == NULL ) { vector < int > res ( distance + 1 , 0 ) ; res [ 1 ] ++ ; return res ; } vector < int > left = dfs ( root -> left , distance ) ; vector < int > right = dfs ( root -> right , distance ) ; vector < int > res ( distance + 1 , 0 ) ; for ( int i = res . size ( ) - 2 ; i >= 1 ; i -- ) res [ i + 1 ] = left [ i ] + right [ i ] ; for ( int l = 1 ; l < left . size ( ) ; l ++ ) { for ( int r = 0 ; r < right . size ( ) ; r ++ ) { if ( l + r <= distance ) { result += left [ l ] * right [ r ] ; } } } return res ; }
void build ( vector < int > & sum , vector < int > & a , int l , int r , int rt ) { if ( l == r ) { sum [ rt ] = a [ l - 1 ] ; return ; } int m = ( l + r ) >> 1 ; build ( sum , a , l , m , rt << 1 ) ; build ( sum , a , m + 1 , r , rt << 1 1 ) ; }
void pushDown ( vector < int > & sum , vector < int > & add , int rt , int ln , int rn ) { if ( add [ rt ] ) { add [ rt << 1 ] += add [ rt ] ; add [ rt << 1 1 ] += add [ rt ] ; sum [ rt << 1 ] += add [ rt ] * ln ; sum [ rt << 1 1 ] += add [ rt ] * rn ; add [ rt ] = 0 ; } }
void update ( vector < int > & sum , vector < int > & add , int L , int R , int C , int l , int r , int rt ) { if ( L <= l && r <= R ) { sum [ rt ] += C * ( r - l + 1 ) ; add [ rt ] += C ; return ; } int m = ( l + r ) >> 1 ; pushDown ( sum , add , rt , m - l + 1 , r - m ) ; if ( L <= m ) update ( sum , add , L , R , C , l , m , rt << 1 ) ; if ( R > m ) update ( sum , add , L , R , C , m + 1 , r , rt << 1 1 ) ; }
void sequenceMaintenance ( int n , int q , vector < int > & a , vector < int > & b , int m ) { sort ( a . begin ( ) , a . end ( ) ) ; vector < int > sum , add , ans ; sum . assign ( n << 2 , 0 ) ; add . assign ( n << 2 , 0 ) ; build ( sum , a , 1 , n , 1 ) ; for ( int i = 0 ; i < q ; i ++ ) { int l = 1 , r = n , pos = -1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( query ( sum , add , m , m , 1 , n , 1 ) >= b [ i ] ) { r = m - 1 ; pos = m ; } else { l = m + 1 ; } } if ( pos == -1 ) ans . push_back ( 0 ) ; else { ans . push_back ( n - pos + 1 ) ; update ( sum , add , pos , n , - m , 1 , n , 1 ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { cout << ans [ i ] << " " ; } }
int MaximumPath ( vector < vector < int > > & grid ) { int N = grid . size ( ) ; int M = grid [ 0 ] . size ( ) ; vector < vector < int > > sum ; sum . resize ( N + 1 , vector < int > ( M + 1 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { sum [ i ] [ j ] = max ( sum [ i - 1 ] [ j ] , sum [ i ] [ j - 1 ] ) + grid [ i - 1 ] [ j - 1 ] ; } } return sum [ N ] [ M ] ; }
void SubarrayHavingPerfectSquare ( vector < int > arr , int k ) { pair < int , int > ans ; int sum = 0 , i ; for ( i = 0 ; i < k ; i ++ ) { sum += arr [ i ] ; } bool found = false ; if ( isPerfectSquare ( sum ) ) { ans . first = 0 ; ans . second = i - 1 ; } else { for ( int j = i ; j < arr . size ( ) ; j ++ ) { sum = sum + arr [ j ] - arr [ j - k ] ; if ( isPerfectSquare ( sum ) ) { found = true ; ans . first = j - k + 1 ; ans . second = j ; } } for ( int k = ans . first ; k <= ans . second ; k ++ ) { cout << arr [ k ] << " " ; } } if ( found == false ) { cout << "-1" ; } }
int calcSubarray ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { bool flag = true ; int comm_diff = A [ i + 1 ] - A [ i ] ; for ( int k = i ; k < j ; k ++ ) { if ( A [ k + 1 ] - A [ k ] == comm_diff ) { continue ; } else { flag = false ; break ; } } if ( flag ) { count ++ ; } } } return count ; }
char findKthChar ( int n , int k ) { string prev = "A" ; string cur = "" ; if ( n == 1 ) { return 'A' ; } for ( int i = 2 ; i <= n ; i ++ ) { cur = prev + "B" ; for ( int i = 0 ; i < prev . length ( ) ; i ++ ) { if ( prev [ i ] == 'A' ) { prev [ i ] = 'B' ; } else { prev [ i ] = 'A' ; } } reverse ( prev . begin ( ) , prev . end ( ) ) ; cur += prev ; prev = cur ; } return cur [ k - 1 ] ; }
bool areAnagrams ( int a , int b ) { int freqA [ TEN ] = { 0 } ; int freqB [ TEN ] = { 0 } ; updateFreq ( a , freqA ) ; updateFreq ( b , freqB ) ; for ( int i = 0 ; i < TEN ; i ++ ) { if ( freqA [ i ] != freqB [ i ] ) return false ; } return true ; }
bool isPowerOf2 ( int N ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( areAnagrams ( 1 << i , N ) ) { cout << ( 1 << i ) ; return true ; } } return false ; }
int right_angled ( int n ) { int count = 0 ; for ( int z = 1 ; z <= n ; z ++ ) { for ( int y = 1 ; y <= z ; y ++ ) { for ( int x = 1 ; x <= y ; x ++ ) { if ( ( x * x ) + ( y * y ) == ( z * z ) ) { count ++ ; } } } } return count ; }
void mirrorMatrix ( int mat1 [ ] [ 4 ] , int mat2 [ ] [ 4 ] , int N ) { int row = 0 ; int col = 0 ; bool isMirrorImage = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( mat2 [ row ] [ col ] != mat1 [ i ] [ j ] ) { isMirrorImage = false ; } col ++ ; } col = 0 ; row ++ ; } if ( isMirrorImage ) cout << "Yes" ; else cout << "No" ; }
void maxAbsDiffLevelSum ( int N , int M , vector < int > cost , int Edges [ ] [ 2 ] ) { vector < int > adj [ N ] ; for ( int i = 0 ; i < M ; i ++ ) { int u = Edges [ i ] [ 0 ] ; int v = Edges [ i ] [ 1 ] ; adj [ u ] . push_back ( v ) ; } int maxSum = cost [ 0 ] , minSum = cost [ 0 ] ; queue < int > q ; q . push ( 0 ) ; while ( ! q . empty ( ) ) { int count = q . size ( ) ; int sum = 0 ; while ( count -- ) { int temp = q . front ( ) ; q . pop ( ) ; sum = sum + cost [ temp ] ; for ( int i = 0 ; i < adj [ temp ] . size ( ) ; i ++ ) { q . push ( adj [ temp ] [ i ] ) ; } } maxSum = max ( sum , maxSum ) ; minSum = min ( sum , minSum ) ; } cout << abs ( maxSum - minSum ) ; }
int dfs ( int src , int dest , int * vis , vector < int > * adj ) { vis [ src ] = 1 ; if ( src == dest ) { return 1 ; } for ( int u : adj [ src ] ) { if ( ! vis [ u ] ) { int temp = dfs ( u , dest , vis , adj ) ; if ( temp != 0 ) { return temp + 1 ; } } } return 0 ; }
int countMagicNumbers ( int idx , int sum , int a [ ] , int n , int m , int l , int r ) { if ( idx == n ) { int temp = sum % m ; if ( temp == l || temp == r || ( temp > l && temp < r ) ) return dp [ { idx , sum } ] = 1 ; else return dp [ { idx , sum } ] = 0 ; } pair < int , int > curr = make_pair ( idx , sum ) ; if ( dp . find ( curr ) != dp . end ( ) ) return dp [ curr ] ; int ls = countMagicNumbers ( idx + 1 , sum + a [ idx ] , a , n , m , l , r ) ; int rs = countMagicNumbers ( idx + 1 , sum + ( a [ idx ] - 1 ) , a , n , m , l , r ) ; int temp1 = max ( ls , rs ) ; int temp = sum % m ; if ( ( temp == l || temp == r || ( temp > l && temp < r ) ) && idx != 0 ) { temp1 += 1 ; } return dp [ { idx , sum } ] = temp1 ; }
int count_numbers ( int L , int R ) { int ans = 0 ; for ( int n = L ; n <= R ; n ++ ) { int no_of_bits = log2 ( n ) + 1 ; int no_of_set_bits = __builtin_popcount ( n ) ; if ( no_of_bits - no_of_set_bits == 1 ) { ans ++ ; } } return ans ; }
int check ( string & s , int k ) { int n = s . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i ; j < n ; j += k ) { if ( s [ i ] != s [ j ] ) return false ; } } int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( s [ i ] == '0' ) c ++ ; else c -- ; } if ( c == 0 ) return true ; else return false ; }
int findSum ( string s ) { int sum = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . size ( ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { sum += ( j - i ) ; } } } return sum ; }
int countElements ( int a [ ] , int n ) { int cnt [ n + 1 ] = { 0 } ; memset ( cnt , 0 , sizeof ( cnt ) ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ++ cnt [ a [ i ] ] ; } for ( int l = 0 ; l < n ; ++ l ) { int sum = 0 ; for ( int r = l ; r < n ; ++ r ) { sum += a [ r ] ; if ( l == r ) continue ; if ( sum <= n ) { ans += cnt [ sum ] ; cnt [ sum ] = 0 ; } } } return ans ; }
int maxGCD ( int n ) { int maxHcf = INT_MIN ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { maxHcf = max ( maxHcf , __gcd ( i , j ) ) ; } } return maxHcf ; }
void addEdge ( int a , int b ) { tree [ a ] . push_back ( b ) ; tree [ b ] . push_back ( a ) ; }
void dfs ( int x ) { vis [ x ] = true ; subtreeSize [ x ] = 1 ; for ( auto i : tree [ x ] ) { if ( ! vis [ i ] ) { dfs ( i ) ; subtreeSize [ x ] += subtreeSize [ i ] ; } } }
vector < vector < int > > matrixMinimum ( vector < vector < int > > nums , int K ) { int N = nums . size ( ) ; int M = nums [ 0 ] . size ( ) ; vector < vector < int > > res ( N - K + 1 , vector < int > ( M - K + 1 ) ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M - K + 1 ; j ++ ) { int mini = INT_MAX ; for ( int k = j ; k < j + K ; k ++ ) { mini = min ( mini , nums [ i ] [ k ] ) ; } nums [ i ] [ j ] = mini ; } } for ( int j = 0 ; j < M ; j ++ ) { for ( int i = 0 ; i < N - K + 1 ; i ++ ) { int mini = INT_MAX ; for ( int k = i ; k < i + K ; k ++ ) { mini = min ( mini , nums [ k ] [ j ] ) ; } nums [ i ] [ j ] = mini ; } } for ( int i = 0 ; i < N - K + 1 ; i ++ ) for ( int j = 0 ; j < M - K + 1 ; j ++ ) res [ i ] [ j ] = nums [ i ] [ j ] ; return res ; }
int uncrossedLines ( int * a , int * b , int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 0 ; else if ( a [ i - 1 ] == b [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ n ] [ m ] ; }
char find_kth_largest ( string str , int k ) { sort ( str . begin ( ) , str . end ( ) , greater < char > ( ) ) ; return str [ k - 1 ] ; }
void updateString ( string str , int pos , char s ) { int index = pos - 1 ; char c = s ; str [ index ] = c ; }
void update_BITree ( int index , char C , int val ) { while ( index <= N ) { BITree [ C - 'a' ] [ index ] += val ; index += ( index & - index ) ; } }
int sum_BITree ( int index , char C ) { int s = 0 ; while ( index ) { s += BITree [ C - 'a' ] [ index ] ; index -= ( index & - index ) ; } return s ; }
int revNum ( int N ) { int x = 0 ; while ( N ) { x = x * 10 + N % 10 ; N = N / 10 ; } return x ; }
int ctNonPalin ( int arr [ ] , int N ) { int Res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int x = revNum ( arr [ i ] ) ; if ( x == arr [ i ] ) { continue ; } else { Res += ( arr [ i ] % 10 == N % 10 ) ; } } return Res ; }
int smallSumSubset ( vector < int > data , int target , int maxVal ) { int sum = 0 ; for ( int i : data ) sum += i ; if ( target <= 0 ) return 0 ; else if ( sum < target ) return maxVal ; else if ( sum == target ) return data . size ( ) ; else if ( data [ 0 ] >= target ) return 1 ; else if ( data [ 0 ] < target ) { vector < int > temp ; for ( int i = 1 ; i < data . size ( ) ; i ++ ) temp . push_back ( data [ i ] ) ; return min ( smallSumSubset ( temp , target , maxVal ) , 1 + smallSumSubset ( temp , target - data [ 0 ] , maxVal ) ) ; } }
int minlt ( vector < int > arr , int target , int n ) { vector < vector < int > > dp ( arr . size ( ) + 1 , vector < int > ( target + 1 , -1 ) ) ; for ( int i = 0 ; i < arr . size ( ) + 1 ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j < target + 1 ; j ++ ) dp [ 0 ] [ j ] = INT_MAX ; for ( int i = 1 ; i <= arr . size ( ) ; i ++ ) { for ( int j = 1 ; j <= target ; j ++ ) { if ( arr [ i - 1 ] > j ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else { dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , ( dp [ i ] [ j - arr [ i - 1 ] ] ) != INT_MAX ? ( dp [ i ] [ j - arr [ i - 1 ] ] + 1 ) : INT_MAX ) ; } } } if ( dp [ arr . size ( ) ] [ target ] == INT_MAX ) { return -1 ; } else { return dp [ arr . size ( ) ] [ target ] ; } }
ll GCD ( ll a , ll b ) { if ( a == 0 ) return b ; return GCD ( b % a , a ) ; }
ll LCM ( ll a , ll b ) { return ( a * b ) / GCD ( a , b ) ; }
void checkPairwiseCoPrime ( int A [ ] , int n ) { ll prod = 1 ; ll lcm = 1 ; for ( int i = 0 ; i < n ; i ++ ) { prod *= A [ i ] ; lcm = LCM ( A [ i ] , lcm ) ; } if ( prod == lcm ) cout << "Yes" << endl ; else cout << "No" << endl ; }
int minDiffSubArray ( int arr [ ] , int n ) { int prefix_sum [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; int suffix_sum [ n ] ; suffix_sum [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffix_sum [ i ] = suffix_sum [ i + 1 ] + arr [ i ] ; int minDiff = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int diff = abs ( prefix_sum [ i ] - suffix_sum [ i + 1 ] ) ; if ( diff < minDiff ) minDiff = diff ; } return minDiff ; }
int minDiffSubArray ( int arr [ ] , int n ) { int total_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) total_sum += arr [ i ] ; int prefix_sum = 0 ; int minDiff = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) { prefix_sum += arr [ i ] ; int diff = abs ( ( total_sum - prefix_sum ) - prefix_sum ) ; if ( diff < minDiff ) minDiff = diff ; } return minDiff ; }
int maxLenSub ( int arr [ ] , int N ) { int Pos = 0 ; int Neg = 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { Pos = Neg = 0 ; } else if ( arr [ i ] > 0 ) { Pos += 1 ; if ( Neg != 0 ) { Neg += 1 ; } res = max ( res , Pos ) ; } else { swap ( Pos , Neg ) ; Neg += 1 ; if ( Pos != 0 ) { Pos += 1 ; } res = max ( res , Pos ) ; } } return res ; }
void maxStrings ( vector < string > arr , int len ) { int N = arr . size ( ) ; vector < string > ans ; for ( int i = 0 ; i < N ; i ++ ) { if ( len == arr [ i ] . size ( ) ) { ans . push_back ( arr [ i ] ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { cout << ans [ i ] << " " ; } }
void printStrings ( vector < string > & arr ) { int max = maxLength ( arr ) ; maxStrings ( arr , max ) ; }
void addEdge ( int u , int v ) { vec [ u ] . push_back ( v ) ; vec [ v ] . push_back ( u ) ; }
bool swapXandY ( string & str , int X , int Y ) { int N = str . length ( ) ; swap ( X , Y ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == 'p' ) { str [ i ] = 'r' ; } else if ( str [ i ] == 'r' ) { str [ i ] = 'p' ; } } }
bool canTransform ( string str1 , string str2 ) { string s1 = "" ; string s2 = "" ; for ( char c : str1 ) { if ( c != 'C' ) { s1 += c ; } } for ( char c : str2 ) { if ( c != 'C' ) { s2 += c ; } } if ( s1 != s2 ) return false ; int i = 0 ; int j = 0 ; int n = str1 . length ( ) ; while ( i < n and j < n ) { if ( str1 [ i ] == 'C' ) { i ++ ; } else if ( str2 [ j ] == 'C' ) { j ++ ; } else { if ( ( str1 [ i ] == 'A' and i < j ) or ( str1 [ i ] == 'B' and i > j ) ) { return false ; } i ++ ; j ++ ; } } return true ; }
void dailyTemperatures ( vector < int > & T ) { int n = T . size ( ) ; vector < int > daysOfWait ( n , -1 ) ; stack < int > s ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! s . empty ( ) && T [ s . top ( ) ] < T [ i ] ) { daysOfWait [ s . top ( ) ] = i - s . top ( ) ; s . pop ( ) ; } s . push ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { cout << daysOfWait [ i ] << " " ; } }
int CtSubarr ( int arr [ ] , int N , int K ) { unordered_set < int > st ; int prefixSum = 0 ; st . insert ( prefixSum ) ; int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { prefixSum += arr [ i ] ; if ( st . count ( prefixSum - K ) ) { res += 1 ; prefixSum = 0 ; st . clear ( ) ; st . insert ( 0 ) ; } st . insert ( prefixSum ) ; } return res ; }
int getMaxLength ( int arr [ ] , int N ) { int res = 2 ; int dist = 2 ; int curradj = ( arr [ 1 ] - arr [ 0 ] ) ; int prevadj = ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < N ; i ++ ) { curradj = arr [ i ] - arr [ i - 1 ] ; if ( curradj == prevadj ) { dist ++ ; } else { prevadj = curradj ; res = max ( res , dist ) ; dist = 2 ; } } res = max ( res , dist ) ; return res ; }
double func ( double a , double b , double c , double x ) { return a * x * x + b * x + c ; }
double findRoot ( double a , double b , double c , double low , double high ) { double x ; while ( fabs ( high - low ) > eps ) { x = ( low + high ) / 2 ; if ( func ( a , b , c , low ) * func ( a , b , c , x ) <= 0 ) { high = x ; } else { low = x ; } } return x ; }
int minSteps ( string str , int N ) { int smaller , cost = 0 ; int f [ 26 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int curr_ele = str [ i ] - 'a' ; smaller = 0 ; for ( int j = 0 ; j <= curr_ele ; j ++ ) { if ( f [ j ] ) smaller += f [ j ] ; } if ( smaller == 0 ) cost += ( i + 1 ) ; else cost += ( i - smaller + 1 ) ; f [ str [ i ] - 'a' ] ++ ; } return cost ; }
void dfs ( int u , int p , int dis , vector < int > & vis , vector < int > & distance , vector < int > & parent , vector < int > & preTime , vector < int > & postTime , vector < int > Adj [ ] ) { distance [ u ] = dis ; parent [ u ] = p ; vis [ u ] = 1 ; timeT ++ ; preTime [ u ] = timeT ; for ( int i = 0 ; i < Adj [ u ] . size ( ) ; i ++ ) { if ( vis [ Adj [ u ] [ i ] ] == 0 ) { dfs ( Adj [ u ] [ i ] , u , dis + 1 , vis , distance , parent , preTime , postTime , Adj ) ; } } timeT ++ ; postTime [ u ] = timeT ; }
void addEdge ( vector < int > Adj [ ] , int u , int v ) { Adj [ u ] . push_back ( v ) ; Adj [ v ] . push_back ( u ) ; }
void findNodeU ( int N , int V , int Vertices [ ] , int Edges [ ] [ 2 ] ) { vector < int > vis ( N + 1 , 0 ) ; vector < int > distance ( N + 1 , 0 ) ; vector < int > parent ( N + 1 , 0 ) ; vector < int > preTime ( N + 1 , 0 ) ; vector < int > postTime ( N + 1 , 0 ) ; vector < int > Adj [ N + 1 ] ; int u , v ; for ( int i = 0 ; i < N - 1 ; i ++ ) { addEdge ( Adj , Edges [ i ] [ 0 ] , Edges [ i ] [ 1 ] ) ; } dfs ( 1 , 0 , 0 , vis , distance , parent , preTime , postTime , Adj ) ; int maximumDistance = 0 ; maximumDistance = 0 ; for ( int k = 0 ; k < V ; k ++ ) { if ( maximumDistance < distance [ Vertices [ k ] ] ) { maximumDistance = distance [ Vertices [ k ] ] ; u = Vertices [ k ] ; } if ( parent [ Vertices [ k ] ] != 0 ) { Vertices [ k ] = parent [ Vertices [ k ] ] ; } } bool ans = true ; bool flag ; for ( int k = 0 ; k < V ; k ++ ) { if ( preTime [ Vertices [ k ] ] <= preTime [ u ] && postTime [ Vertices [ k ] ] >= postTime [ u ] ) flag = true ; else flag = false ; ans = ans & flag ; } if ( ans ) cout << u ; else cout << "NO" ; }
void countRectangles ( vector < int > & a , vector < int > & b , int K ) { int n = a . size ( ) ; int m = b . size ( ) ; vector < int > subA = findSubarrays ( a ) ; vector < int > subB = findSubarrays ( b ) ; int total = 0 ; for ( int i = 1 ; i < subA . size ( ) ; i ++ ) { if ( K % i == 0 and ( K / i ) <= m ) { total = total + subA [ i ] * subB [ K / i ] ; } } cout << total ; }
void addedge ( int a , int b ) { edges [ a ] . push_back ( b ) ; edges [ b ] . push_back ( a ) ; }
void findCost ( int r , int p , int arr [ ] ) { int i , cur ; for ( i = 0 ; i < edges [ r ] . size ( ) ; i ++ ) { cur = edges [ r ] . at ( i ) ; if ( cur == p ) continue ; findCost ( cur , r , arr ) ; arr [ r ] += arr [ cur ] ; } int t1 = arr [ r ] ; int t2 = allsum - t1 ; if ( t1 * t2 > ans ) { ans = t1 * t2 ; } }
void maximumCost ( int r , int p , int N , int M , int arr [ ] , int Edges [ ] [ 2 ] ) { for ( int i = 0 ; i < N ; i ++ ) { allsum += arr [ i ] ; } for ( int i = 0 ; i < M ; i ++ ) { addedge ( Edges [ i ] [ 0 ] , Edges [ i ] [ 1 ] ) ; } findCost ( r , p , arr ) ; }
void printRes ( vector < int > & res ) { int n = res . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { cout << res [ i ] << " " ; } }
void printLBS ( int arr [ ] , int N ) { int lis [ N ] ; int lds [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { lis [ i ] = lds [ i ] = 1 ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { if ( lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } } for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = N - 1 ; j > i ; j -- ) { if ( arr [ j ] < arr [ i ] ) { if ( lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; } } } int MaxVal = arr [ 0 ] , inx = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( MaxVal < lis [ i ] + lds [ i ] - 1 ) { MaxVal = lis [ i ] + lds [ i ] - 1 ; inx = i ; } } int ct1 = lis [ inx ] ; vector < int > res ; for ( int i = inx ; i >= 0 && ct1 > 0 ; i -- ) { if ( lis [ i ] == ct1 ) { res . push_back ( arr [ i ] ) ; ct1 -- ; } } reverse ( res . begin ( ) , res . end ( ) ) ; int ct2 = lds [ inx ] - 1 ; for ( int i = inx ; i < N && ct2 > 0 ; i ++ ) { if ( lds [ i ] == ct2 ) { res . push_back ( arr [ i ] ) ; ct2 -- ; } } printRes ( res ) ; }
void dfs ( int current_node , int prev_node , int len , bool add_to_map , vector < vector < int > > & adj ) { if ( len > diameter ) { diameter = len ; X = current_node ; } if ( add_to_map && len == diameter ) { mp [ current_node ] = 1 ; } for ( auto & it : adj [ current_node ] ) { if ( it != prev_node ) dfs ( it , current_node , len + 1 , add_to_map , adj ) ; } }
void dfsUtility ( vector < vector < int > > & adj ) { dfs ( 1 , -1 , 0 , 0 , adj ) ; int farthest_node = X ; dfs ( farthest_node , -1 , 0 , 0 , adj ) ; dfs ( farthest_node , -1 , 0 , 1 , adj ) ; dfs ( X , -1 , 0 , 1 , adj ) ; }
void printDiameters ( vector < vector < int > > & adj ) { dfsUtility ( adj ) ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( mp [ i ] == 1 ) cout << diameter + 1 << ", " ; else cout << diameter << ", " ; } }
bool is_prime ( int n ) { if ( n <= 1 ) return 0 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return 0 ; } return 1 ; }
int count_prime_subarrays ( int ar [ ] , int n ) { int ans = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( is_prime ( ar [ i ] ) ) count ++ ; else { if ( count ) { ans += count * ( count + 1 ) / 2 ; count = 0 ; } } } if ( count ) ans += count * ( count + 1 ) / 2 ; return ans ; }
bool hasCoprimePair ( vector < int > & arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( __gcd ( arr [ i ] , arr [ j ] ) == 1 ) { return true ; } } } return false ; }
bool check ( string ans , vector < string > & s , int n , int m ) { for ( int i = 1 ; i < n ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < m ; ++ j ) { if ( ans [ j ] != s [ i ] [ j ] ) count ++ ; } if ( count > 1 ) return false ; } return true ; }
bool possible ( int T , int arr [ ] , int n , int d ) { int partition = 1 ; int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total = total + arr [ i ] ; if ( total > T ) { partition = partition + 1 ; total = arr [ i ] ; if ( partition > d ) { return false ; } } } return true ; }
void calcT ( int n , int d , int arr [ ] ) { int mx = -1 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mx = max ( mx , arr [ i ] ) ; sum = sum + arr [ i ] ; } int lb = mx ; int ub = sum ; while ( lb < ub ) { int T_mid = lb + ( ub - lb ) / 2 ; if ( possible ( T_mid , arr , n , d ) == true ) { ub = T_mid ; } else { lb = T_mid + 1 ; } } cout << lb << endl ; }
int minReqSubstring ( string s , int n ) { char ongoing = 'N' ; int count = 0 , l = s . size ( ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( ongoing == 'N' ) { if ( s [ i ] < s [ i - 1 ] ) { ongoing = 'D' ; } else if ( s [ i ] == s [ i - 1 ] ) { ongoing = 'N' ; } else { ongoing = 'I' ; } } else if ( ongoing == 'I' ) { if ( s [ i ] > s [ i - 1 ] ) { ongoing = 'I' ; } else if ( s [ i ] == s [ i - 1 ] ) { ongoing = 'I' ; } else { ongoing = 'N' ; count += 1 ; } } else { if ( s [ i ] < s [ i - 1 ] ) { ongoing = 'D' ; } else if ( s [ i ] == s [ i - 1 ] ) { ongoing = 'D' ; } else { ongoing = 'N' ; count += 1 ; } } } return count + 1 ; }
int findPermutation ( unordered_set < int > & arr , int N ) { int pos = arr . size ( ) + 1 ; if ( pos > N ) return 1 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr . find ( i ) == arr . end ( ) ) { if ( i % pos == 0 or pos % i == 0 ) { arr . insert ( i ) ; res += findPermutation ( arr , N ) ; arr . erase ( arr . find ( i ) ) ; } } } return res ; }
int minimum_required_operations ( int arr [ ] , int n , int k ) { int answer = 0 ; long long mod = 1000000007 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + arr [ i + 1 ] > k ) { if ( arr [ i ] > k ) { answer += ( arr [ i ] - k ) ; arr [ i ] = k ; } answer += ( arr [ i ] + arr [ i + 1 ] ) - k ; arr [ i + 1 ] = ( k - arr [ i ] ) ; answer %= mod ; } } return answer ; }
int minSteps ( int arr [ ] , int n , int k ) { int i , cnt = 0 ; int flag ; if ( k == 1 ) flag = 0 ; else flag = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == flag ) { cnt ++ ; flag = ( flag + 1 ) % 2 ; } } return cnt ; }
void solve ( int arr [ ] , int n , int X , int Y ) { int diff = Y - X ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) cout << "Yes" ; else cout << "No" ; }
int minSum ( int a [ ] , int n , int k ) { priority_queue < int > q ; for ( int i = 0 ; i < n ; i ++ ) { q . push ( a [ i ] ) ; } while ( ! q . empty ( ) && k > 0 ) { int top = q . top ( ) / 2 ; q . pop ( ) ; q . push ( top ) ; k -= 1 ; } int sum = 0 ; while ( ! q . empty ( ) ) { sum += q . top ( ) ; q . pop ( ) ; } return sum ; }
void determineWinner ( string str ) { vector < int > A ( 10 ) ; int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { A [ int ( str [ i ] ) - 48 ] ++ ; } for ( int i = 0 ; i <= 9 ; i ++ ) { if ( i % 2 != 0 ) { sum1 = sum1 + A [ i ] ; } else { sum2 = sum2 + A [ i ] ; } } if ( sum1 == sum2 ) { cout << "-1" ; } else if ( sum1 > sum2 ) { cout << "Player 1" ; } else { cout << "Player 2" ; } }
void manipulateStrings ( string P , string Q ) { int freq [ 26 ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < P . size ( ) ; i ++ ) { freq [ P [ i ] - 'a' ] ++ ; } for ( int i = 0 ; i < Q . size ( ) ; i ++ ) { freq [ Q [ i ] - 'a' ] -- ; } string sb = "" ; int pos = Q [ 0 ] - 'a' ; for ( int i = 0 ; i <= pos ; i ++ ) { while ( freq [ i ] > 0 ) { char c = ( char ) ( 'a' + i ) ; sb += c ; freq [ i ] -- ; } } sb += Q ; for ( int i = pos + 1 ; i < 26 ; i ++ ) { while ( freq [ i ] > 0 ) { char c = ( char ) ( 'a' + i ) ; sb += c ; freq [ i ] -- ; } } cout << sb << endl ; }
int deleted ( int seg [ ] , int l , int r , int start , int end , int current ) { if ( end < l or start > r ) return 0 ; if ( start >= l and end <= r ) return seg [ current ] ; int mid = ( start + end ) / 2 ; return deleted ( seg , l , r , start , mid , 2 * current + 1 ) + deleted ( seg , l , r , mid + 1 , end , 2 * current + 2 ) ; }
bool deleteNode ( int nodeVal ) { return mp . find ( nodeVal ) != mp . end ( ) ; }
void printInorderTree ( Node * root ) { if ( root == NULL ) return ; printInorderTree ( root -> left ) ; cout << root -> key << " " ; printInorderTree ( root -> right ) ; }
void sieve ( ) { prime [ 0 ] = prime [ 1 ] = false ; for ( int i = 2 ; i < 100005 ; i ++ ) prime [ i ] = true ; for ( int i = 2 ; i * i < 100005 ; i ++ ) { if ( prime [ i ] ) { for ( int j = i * i ; j < 100005 ; j += i ) { prime [ j ] = false ; } } } }
void smallestPrimeFactors ( ) { for ( int i = 0 ; i < 100005 ; i ++ ) spf [ i ] = -1 ; for ( int i = 2 ; i * i < 100005 ; i ++ ) { for ( int j = i ; j < 100005 ; j += i ) { if ( spf [ j ] == -1 ) { spf [ j ] = i ; } } } }
int sumOfPrimeFactors ( int n ) { int ans = 0 ; while ( n > 1 ) { ans += spf [ n ] ; n /= spf [ n ] ; } return ans ; }
int findLength ( int n ) { if ( prime [ n ] ) { return 1 ; } if ( dp [ n ] ) { return dp [ n ] ; } int sum = sumOfPrimeFactors ( n ) ; return dp [ n ] = 1 + findLength ( sum ) ; }
void solve ( int n , int arr [ ] ) { int i , ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { int left = max ( i - 1 , 0 ) ; int right = min ( n - 1 , i + 1 ) ; while ( left >= 0 ) { if ( arr [ left ] > arr [ i ] ) { left ++ ; break ; } left -- ; } if ( left < 0 ) left ++ ; while ( right < n ) { if ( arr [ right ] > arr [ i ] ) { right -- ; break ; } right ++ ; } if ( right >= n ) right -- ; ans = 1 + right - left ; cout << ans << " " ; } }
int countofPairs ( vector < int > & a ) { int n = a . size ( ) ; int mini = * min_element ( a . begin ( ) , a . end ( ) ) , maxi = * max_element ( a . begin ( ) , a . end ( ) ) ; vector < int > freq ( n + 1 , 0 ) ; for ( int i = 0 ; i < n ; ++ i ) freq [ a [ i ] ] ++ ; return maxCount ( freq , mini , maxi ) ; }
int largest_subarray ( int a [ ] , int n ) { unordered_map < int , int > index ; int ans = 0 ; for ( int i = 0 , j = 0 ; i < n ; i ++ ) { j = max ( index [ a [ i ] ] , j ) ; ans = max ( ans , i - j + 1 ) ; index [ a [ i ] ] = i + 1 ; } return ans ; }
int getMaxSum ( int a [ ] , int n ) { int dp [ n ] [ 2 ] ; dp [ 0 ] [ 0 ] = a [ 0 ] ; dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 0 ] ; int max_sum = max ( dp [ 0 ] [ 0 ] , dp [ 0 ] [ 1 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = max ( a [ i ] , dp [ i - 1 ] [ 0 ] + a [ i ] ) ; dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 1 ] + a [ i ] , a [ i ] * a [ i ] ) ; dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 0 ] + a [ i ] * a [ i ] ) ; max_sum = max ( max_sum , dp [ i ] [ 1 ] ) ; max_sum = max ( max_sum , dp [ i ] [ 0 ] ) ; } return max_sum ; }
int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; }
int MaxUtil ( int * st , int ss , int se , int l , int r , int node ) { if ( l <= ss && r >= se ) return st [ node ] ; if ( se < l ss > r ) return -1 ; int mid = getMid ( ss , se )  ; return max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) ; }
int constructSTUtil ( int arr [ ] , int ss , int se , int * st , int si ) { if ( ss == se ) { st [ si ] = arr [ ss ] ; return arr [ ss ] ; } int mid = getMid ( ss , se ) ; st [ si ] = max ( constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ) ; return st [ si ] ; }
vector < int > findPrevious ( vector < int > a , int n ) { vector < int > ps ( n ) ; ps [ 0 ] = -1 ; stack < int > Stack ; Stack . push ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( Stack . size ( ) > 0 && a [ Stack . top ( ) ] >= a [ i ] ) Stack . pop ( ) ; ps [ i ] = Stack . size ( ) > 0 ? Stack . top ( ) : -1 ; Stack . push ( i ) ; } return ps ; }
vector < int > findNext ( vector < int > a , int n ) { vector < int > ns ( n ) ; ns [ n - 1 ] = n ; stack < int > Stack ; Stack . push ( n - 1 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { while ( Stack . size ( ) > 0 && a [ Stack . top ( ) ] >= a [ i ] ) Stack . pop ( ) ; ns [ i ] = Stack . size ( ) > 0 ? Stack . top ( ) : n ; Stack . push ( i ) ; } return ns ; }
int findMaximumSum ( vector < int > a , int n ) { vector < int > prev_smaller = findPrevious ( a , n ) ; vector < int > next_smaller = findNext ( a , n ) ; int max_value = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_value = max ( max_value , a [ i ] * ( next_smaller [ i ] - prev_smaller [ i ] - 1 ) ) ; } return max_value ; }
int findCount ( int arr [ ] , int n ) { int prefix_sum [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; int suffix_sum [ n ] ; suffix_sum [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffix_sum [ i ] = suffix_sum [ i + 1 ] + arr [ i ] ; int s = 1 , e = 1 ; int curr_subarray_sum = 0 , count = 0 ; while ( s < n - 1 && e < n - 1 ) { while ( e < n - 1 && curr_subarray_sum < prefix_sum [ s - 1 ] ) { curr_subarray_sum += arr [ e ++ ] ; } if ( curr_subarray_sum <= suffix_sum [ e ] ) { count ++ ; } curr_subarray_sum -= arr [ s ++ ] ; } return count ; }
int minOperation ( string s , int n ) { int ans = 0 ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( s [ i ] == '0' && s [ j ] == '1' ) { ans ++ ; i ++ ; j -- ; continue ; } if ( s [ i ] == '1' ) { i ++ ; } if ( s [ j ] == '0' ) { j -- ; } } return ans ; }
void solve ( int n ) { int ans = 0 ; for ( int y = n + 1 ; y <= n * n + n ; y ++ ) { if ( ( n * n ) % ( y - n ) == 0 ) { ans += 1 ; } } cout << ans ; }
int power ( int x , int y , int mod ) { int res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
void count ( int N ) { if ( N == 1 ) { cout << 10 << endl ; return ; } cout << ( power ( 9 , N , 1000000007 ) ) << endl ; }
bool possible ( ll mid , vector < ll > & a ) { ll n = a . size ( ) ; ll total = ( n * ( n - 1 ) ) / 2 ; ll need = ( total + 1 ) / 2 ; ll count = 0 ; ll start = 0 , end = 1 ; while ( end < n ) { if ( a [ end ] - a [ start ] <= mid ) { end ++ ; } else { count += ( end - start - 1 ) ; start ++ ; } } if ( end == n && start < end && a [ end - 1 ] - a [ start ] <= mid ) { ll t = end - start - 1 ; count += ( t * ( t + 1 ) / 2 ) ; } if ( count >= need ) return true ; else return false ; }
ll findMedian ( vector < ll > & a ) { ll n = a . size ( ) ; ll low = 0 , high = a [ n - 1 ] - a [ 0 ] ; while ( low <= high ) { ll mid = ( low + high ) / 2 ; if ( possible ( mid , a ) ) high = mid - 1 ; else low = mid + 1 ; } return high + 1 ; }
int computeDistance ( Node * root , int value ) { if ( root == NULL ) { return -1 ; } int left = computeDistance ( root -> left , value ) ; int right = computeDistance ( root -> right , value ) ; if ( left == -1 && right == -1 ) { if ( root -> key == value ) { return 1 ; } else return -1 ; } if ( left == -1 ) { return right + 1 ; } if ( right == -1 ) { return left + 1 ; } else { return 1 + max ( left , right ) ; } return -1 ; }
void dfs ( int node , int count , int m , int arr [ ] , int k ) { visited [ node ] = 1 ; if ( arr [ node - 1 ] == k ) { count ++ ; } else { count = 0 ; } if ( count > m ) { return ; } if ( adj [ node ] . size ( ) == 1 && node != 1 ) { ans ++ ; } for ( auto x : adj [ node ] ) { if ( ! visited [ x ] ) { dfs ( x , count , m , arr , k ) ; } } }
int find ( vector < int > & parent , int x ) { if ( parent [ x ] == x ) return x ; parent [ x ] = find ( parent , parent [ x ] ) ; return parent [ x ] ; }
void setUnion ( vector < int > & parent , vector < int > & rank , int x , int y ) { int parentx = find ( parent , x ) ; int parenty = find ( parent , y ) ; if ( parenty == parentx ) return ; ctr -- ; if ( rank [ parentx ] < rank [ parenty ] ) { parent [ parentx ] = parenty ; } else if ( rank [ parentx ] > rank [ parenty ] ) { parent [ parenty ] = parentx ; } else { parent [ parentx ] = parenty ; rank [ parenty ] ++ ; } }
vector < int > solve ( int n , int m , vector < pair < int , int > > & query ) { vector < int > result ( query . size ( ) ) ; vector < int > parent ( n * m ) ; for ( int i = 0 ; i < n * m ; i ++ ) parent [ i ] = i ; vector < int > rank ( n * m , 1 ) ; vector < bool > grid ( n * m , 0 ) ; for ( int i = 0 ; i < query . size ( ) ; i ++ ) { int x = query [ i ] . first ; int y = query [ i ] . second ; if ( grid [ m * x + y ] == 1 ) { result [ i ] = ctr ; continue ; } grid [ m * x + y ] = 1 ; ctr ++ ; if ( x > 0 and grid [ m * ( x - 1 ) + y ] == 1 ) setUnion ( parent , rank , m * x + y , m * ( x - 1 ) + y ) ; if ( y > 0 and grid [ m * ( x ) + y - 1 ] == 1 ) setUnion ( parent , rank , m * x + y , m * ( x ) + y - 1 ) ; if ( x < n - 1 and grid [ m * ( x + 1 ) + y ] == 1 ) setUnion ( parent , rank , m * x + y , m * ( x + 1 ) + y ) ; if ( y < m - 1 and grid [ m * ( x ) + y + 1 ] == 1 ) setUnion ( parent , rank , m * x + y , m * ( x ) + y + 1 ) ; result [ i ] = ctr ; } return result ; }
void FindMinimumDistance ( ) { queue < pair < int , int > > q ; q . push ( { x , y } ) ; mat [ x ] [ y ] = 0 ; while ( ! q . empty ( ) ) { x = q . front ( ) . first ; y = q . front ( ) . second ; q . pop ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) { int a = x + dx [ i ] ; int b = y + dy [ i ] ; if ( a < 0 a > = r b > = c b < 0 ) continue ; if ( mat [ a ] [ b ] == 0 ) { mat [ a ] [ b ] = mat [ x ] [ y ] + 1 ; q . push ( { a , b } ) ; } } } }
void make_set ( int v ) { parent [ v ] = v ; size_set [ v ] = 1 ; }
int find_set ( int v ) { if ( v == parent [ v ] ) return v ; return parent [ v ] = find_set ( parent [ v ] ) ; }
void union_set ( int a , int b ) { a = find_set ( a ) ; b = find_set ( b ) ; if ( a != b ) { if ( size_set [ a ] < size_set [ b ] ) swap ( a , b ) ; parent [ b ] = a ; size_set [ a ] += size_set [ b ] ; } }
void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < 100001 ; i ++ ) prime [ i ] = 1 ; int p = 2 ; while ( p * p <= 100000 ) { if ( prime [ p ] == 1 ) { for ( int i = p * p ; i < 100001 ; i += p ) prime [ i ] = 0 ; } p += 1 ; } }
void fibonacciOfPrime ( int n1 , int n2 ) { SieveOfEratosthenes ( ) ; vector < int > initial ; for ( int i = n1 ; i <= n2 ; i ++ ) if ( prime [ i ] ) initial . push_back ( i ) ; vector < int > now ; for ( auto a : initial ) for ( auto b : initial ) if ( a != b ) { int c = join ( a , b ) ; now . push_back ( c ) ; } vector < int > current ; for ( auto x : now ) if ( prime [ x ] ) current . push_back ( x ) ; set < int > current_set ; for ( auto i : current ) current_set . insert ( i ) ; int first = * min_element ( current_set . begin ( ) , current_set . end ( ) ) ; int second = * max_element ( current_set . begin ( ) , current_set . end ( ) ) ; int count = current_set . size ( ) - 1 ; int curr = 1 ; int c ; while ( curr < count ) { c = first + second ; first = second ; second = c ; curr += 1 ; } cout << ( c ) << endl ; }
long reverse ( long num ) { long rev = 0 ; while ( num > 0 ) { int r = ( int ) ( num % 10 ) ; rev = rev * 10 + r ; num /= 10 ; } return rev ; }
long count ( int N , int A , int B ) { long l = ( long ) pow ( 10 , N - 1 ) , r = ( long ) pow ( 10 , N ) - 1 ; if ( l == 1 ) l = 0 ; long ans = 0 ; for ( long i = l ; i <= r ; i ++ ) { int even_sum = 0 , odd_sum = 0 ; long itr = 0 , num = reverse ( i ) ; while ( num > 0 ) { if ( itr % 2 == 0 ) odd_sum += num % 10 ; else even_sum += num % 10 ; num /= 10 ; itr ++ ; } if ( even_sum % A == 0 && odd_sum % B == 0 ) ans ++ ; } return ans ; }
long count ( int N , int A , int B ) { if ( N == 1 ) { return 9 / B + 1 ; } int max_sum = 9 * N ; int odd_count = N / 2 + N % 2 ; int even_count = N - odd_count ; long dp [ even_count ] [ max_sum + 1 ] = { 0 } ; for ( int i = 0 ; i <= 9 ; i ++ ) dp [ 0 ] [ i % A ] ++ ; for ( int i = 1 ; i < even_count ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { for ( int k = 0 ; k <= max_sum ; k ++ ) { if ( dp [ i - 1 ] [ k ] > 0 ) dp [ i ] [ ( j + k ) % A ] += dp [ i - 1 ] [ k ] ; } } } long dp1 [ odd_count ] [ max_sum + 1 ] = { 0 } ; for ( int i = 1 ; i <= 9 ; i ++ ) dp1 [ 0 ] [ i % B ] ++ ; for ( int i = 1 ; i < odd_count ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { for ( int k = 0 ; k <= max_sum ; k ++ ) { if ( dp1 [ i - 1 ] [ k ] > 0 ) dp1 [ i ] [ ( j + k ) % B ] += dp1 [ i - 1 ] [ k ] ; } } } return dp [ even_count - 1 ] [ 0 ] * dp1 [ odd_count - 1 ] [ 0 ] ; }
int calc_distance ( int A [ ] , int B [ ] , int n ) { int distance_traveled_A = 0 ; int distance_traveled_B = 0 ; int answer = 0 ; for ( int i = 0 ; i < 5 ; i ++ ) { distance_traveled_A += A [ i ] ; distance_traveled_B += B [ i ] ; if ( ( distance_traveled_A == distance_traveled_B ) && ( A [ i ] == B [ i ] ) ) { answer += A [ i ] ; } } return answer ; }
int dfs ( int node , int A , int * subtree_size , int * visited , int * check_subtree ) { visited [ node ] = true ; subtree_size [ node ] = 1 ; if ( node == A ) { check_subtree [ node ] = true ; } else check_subtree [ node ] = false ; for ( int v : G [ node ] ) { if ( ! visited [ v ] ) { subtree_size [ node ] += dfs ( v , A , subtree_size , visited , check_subtree ) ; check_subtree [ node ] = check_subtree [ node ] | check_subtree [ v ] ; } } return subtree_size [ node ] ; }
int numberOfPairs ( int N , int B , int A ) { int subtree_size [ N + 1 ] ; int visited [ N + 1 ] ; memset ( visited , 0 , sizeof ( visited ) ) ; int check_subtree [ N + 1 ] ; dfs ( B , A , subtree_size , visited , check_subtree ) ; int difference ; for ( int v : G [ B ] ) { if ( check_subtree [ v ] ) { difference = N - subtree_size [ v ] ; break ; } } return ( N * ( N - 1 ) ) - difference * ( subtree_size [ A ] ) ; }
int equalXORandOR ( int n ) { int m = 0 ; int MSB = ( int ) log2 ( n ) ; for ( int i = 0 ; i <= MSB ; i ++ ) { if ( ! ( n & ( 1 << i ) ) ) { m += ( 1 << i ) ; } } return m ; }
int findMinSoln ( int n , int k ) { int minSoln = INT_MAX ; for ( int i = 1 ; i < k ; i ++ ) { if ( n % i == 0 ) minSoln = min ( minSoln , ( n / i ) * k + i ) ; } return minSoln ; }
int getSum ( int BITree [ ] , int index ) { int ans = 0 ; index += 1 ; while ( index > 0 ) { ans += BITree [ index ] ; index -= index & ( - index ) ; } return ans ; }
static void updateBIT ( int BITree [ ] , int n , int index , int val ) { index = index + 1 ; while ( index <= n ) { BITree [ index ] += val ; index += index & ( - index ) ; } }
int getLowerBound ( int BITree [ ] , int arr [ ] , int n , int k ) { int lb = -1 ; int l = 0 , r = n - 1 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( getSum ( BITree , mid ) >= k ) { r = mid - 1 ; lb = mid ; } else l = mid + 1 ; } return lb ; }
void dfs ( int * val , int * cost , vector < vector < int > > & tr , int u , int s ) { s = s + cost [ u ] ; if ( s < 0 ) s = 0 ; if ( s > val [ u ] ) return ; cnt ++ ; for ( int i = 0 ; i < tr [ u ] . size ( ) ; i ++ ) { dfs ( val , cost , tr , tr [ u ] [ i ] , s ) ; } }
void dfs1 ( int cur , int par ) { for ( auto u : adj [ cur ] ) { if ( u != par ) { dfs1 ( u , cur ) ; height [ cur ] = max ( height [ cur ] , height [ u ] ) ; } } height [ cur ] += 1 ; }
void dfs2 ( int cur , int par ) { int max1 = 0 ; int max2 = 0 ; for ( auto u : adj [ cur ] ) { if ( u != par ) { if ( height [ u ] >= max1 ) { max2 = max1 ; max1 = height [ u ] ; } else if ( height [ u ] > max2 ) { max2 = height [ u ] ; } } } int sum = 0 ; for ( auto u : adj [ cur ] ) { if ( u != par ) { sum = ( ( max1 == height [ u ] ) ? max2 : max1 ) ; if ( max1 == height [ u ] ) dist [ u ] = 1 + max ( 1 + max2 , dist [ cur ] ) ; else dist [ u ] = 1 + max ( 1 + max1 , dist [ cur ] ) ; dfs2 ( u , cur ) ; } } }
void displaySteppingNumbers ( int n , int m ) { for ( int i = n ; i <= m ; i ++ ) if ( isStepNum ( i ) ) cout << i << " " ; }
int BFS ( vector < vector < int > > & mat , int row , int col ) { int area = 0 ; queue < pair < int , int > > Q ; Q . push ( { row , col } ) ; while ( ! Q . empty ( ) ) { auto it = Q . front ( ) ; Q . pop ( ) ; int r = it . first , c = it . second ; if ( r < 0 c < 0 r > 4 c > 4 ) continue ; if ( mat [ r ] == 0 ) continue ; if ( mat [ r ] == 1 ) { mat [ r ] = 0 ; area ++ ; } Q . push ( { r + 1 , c } ) ; Q . push ( { r - 1 , c } ) ; Q . push ( { r , c + 1 } ) ; Q . push ( { r , c - 1 } ) ; } return area ; }
void sizeOfConnections ( vector < vector < int > > mat ) { vector < int > result ; for ( int row = 0 ; row < 5 ; ++ row ) { for ( int col = 0 ; col < 5 ; ++ col ) { if ( mat [ row ] [ col ] == 1 ) { int area = BFS ( mat , row , col ) ; result . push_back ( area ) ; } } } for ( int val : result ) cout << val << " " ; }
void DFS ( vector < vector < int > > adjl , vector < int > & parent , int u , int p ) { parent [ u ] = p ; for ( int v : adjl [ u ] ) { if ( v != p ) { DFS ( adjl , parent , v , u ) ; } } }
vector < int > valuesFromChildren ( vector < int > parent , vector < int > values ) { vector < int > valuesChildren ( parent . size ( ) ) ; for ( int i = 0 ; i < parent . size ( ) ; i ++ ) { if ( parent [ i ] == -1 ) continue ; else { int p = parent [ i ] ; valuesChildren [ p ] += values [ i ] ; } } return valuesChildren ; }
void maxProduct ( int arr [ ] , int N ) { if ( N < 3 ) { return ; } int a = arr [ 0 ] , b = arr [ 1 ] ; int c = 0 , d = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] * arr [ j ] > a * b ) { c = a , d = b ; a = arr [ i ] , b = arr [ j ] ; } if ( arr [ i ] * arr [ j ] < a * b && arr [ i ] * arr [ j ] > c * d ) c = arr [ i ] , d = arr [ j ] ; } cout << c << " " << d ; }
void maxProduct ( int arr [ ] , int N ) { if ( N < 3 ) { return ; } sort ( arr , arr + N ) ; int smallest1 = arr [ 0 ] ; int smallest3 = arr [ 2 ] ; int largest1 = arr [ N - 1 ] ; int largest3 = arr [ N - 3 ] ; if ( smallest1 * smallest3 >= largest1 * largest3 ) { cout << smallest1 << " " << smallest3 ; } else { cout << largest1 << " " << largest3 ; } }
int maxLen ( int A [ ] , int N ) { vector < vector < int > > v ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 1 ) { int s = i , len ; while ( A [ i ] == 1 && i < N ) { i ++ ; } len = i - s ; v . push_back ( { len , s , i - 1 } ) ; } } if ( v . size ( ) == 0 ) { return -1 ; } int ans = 0 ; for ( int i = 0 ; i < v . size ( ) - 1 ; i ++ ) { ans = max ( ans , v [ i ] [ 0 ] ) ; if ( v [ i + 1 ] [ 1 ] - v [ i ] [ 2 ] - 1 == 2 ) { ans = max ( ans , v [ i ] [ 0 ] + v [ i + 1 ] [ 0 ] ) ; } if ( v [ i + 1 ] [ 1 ] - v [ i ] [ 2 ] - 1 == 1 ) { ans = max ( ans , v [ i ] [ 0 ] + v [ i + 1 ] [ 0 ] - 1 ) ; } } ans = max ( v [ v . size ( ) - 1 ] [ 0 ] , ans ) ; return ans ; }
void maxLengthOf1s ( vector < int > arr , int n ) { vector < int > prefix ( n , 0 ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i - 2 ] == 1 ) prefix [ i ] = prefix [ i - 1 ] + 1 ; else prefix [ i ] = 0 ; } vector < int > suffix ( n , 0 ) ; for ( int i = n - 3 ; i >= 0 ; i -- ) { if ( arr [ i + 2 ] == 1 ) suffix [ i ] = suffix [ i + 1 ] + 1 ; else suffix [ i ] = 0 ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans = max ( ans , prefix [ i + 1 ] + suffix [ i ] ) ; } cout << ans << "\n" ; }
void dfs ( int u ) { visited [ u ] = 1 ; for ( auto it : adj [ u ] ) { if ( visited [ it ] == 0 ) dfs ( it ) ; } s . push ( u ) ; }
bool check_cycle ( ) { unordered_map < int , int > pos ; int ind = 0 ; while ( ! s . empty ( ) ) { pos [ s . top ( ) ] = ind ; tsort . push_back ( s . top ( ) ) ; ind += 1 ; s . pop ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( auto it : adj [ i ] ) { if ( pos [ i ] > pos [ it ] ) { return true ; } } } return false ; }
void addEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; }
void printNewArray ( vector < int > a , int n ) { vector < pair < int , int > > v ; for ( int i = 0 ; i < n ; i ++ ) { v . push_back ( { a [ i ] , i } ) ; } sort ( v . begin ( ) , v . end ( ) ) ; int ans [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ans [ v [ ( i + 1 ) % n ] . second ] = v [ i ] . first ; } for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << " " ; } }
void bfs ( int n , int m , int num ) { queue < int > q ; q . push ( num ) ; while ( ! q . empty ( ) ) { int stepNum = q . front ( ) ; q . pop ( ) ; if ( stepNum <= m && stepNum >= n ) cout << stepNum << " " ; if ( num == 0 stepNum > m ) continue ; int lastDigit = stepNum % 10 ; int stepNumA = stepNum * 10 + ( lastDigit - 1 ) ; int stepNumB = stepNum * 10 + ( lastDigit + 1 ) ; if ( lastDigit == 0 ) q . push ( stepNumB ) ; else if ( lastDigit == 9 ) q . push ( stepNumA ) ; else { q . push ( stepNumA ) ; q . push ( stepNumB ) ; } } }
void displaySteppingNumbers ( int n , int m ) { for ( int i = 0 ; i <= 9 ; i ++ ) bfs ( n , m , i ) ; }
void solve ( int arr [ ] , int n ) { int countzeroes = 0 ; int countones = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) countzeroes ++ ; else countones ++ ; } if ( abs ( countzeroes - countones ) == 1 ) cout << "Yes" ; else cout << "No" ; }
char bs ( char ar [ ] , int n , int ele ) { int start = 0 ; int end = n - 1 ; char ch = '@' ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( ar [ mid ] == ele ) end = mid - 1 ; else if ( ar [ mid ] < ele ) { ch = ar [ mid ] ; start = mid + 1 ; } else end = mid - 1 ; } return ch ; }
void countPairs ( int N , int arr [ ] ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) { count ++ ; } } cout << ( count / 2 ) << endl ; }
int findMaxLen ( vector < ll > & a , ll k ) { int n = a . size ( ) ; sort ( a . begin ( ) , a . end ( ) ) ; vector < bool > vis ( n , 0 ) ; map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ a [ i ] ] = i ; } int c = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( vis [ i ] == false ) { int check = a [ i ] * k ; if ( mp . find ( check ) != mp . end ( ) ) { c ++ ; vis [ mp [ check ] ] = true ; } } } return n - c ; }
bool isVowel ( char c ) { if ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) return true ; return false ; }
void countSubstrings ( string s , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( isVowel ( s [ j ] ) ) { count ++ ; } if ( count % 2 == 0 ) result ++ ; } } cout << result ; }
void addEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; }
int minimumCost ( int V , int cost [ ] ) { bool vis [ V + 1 ] ; memset ( vis , false , sizeof ( vis ) ) ; int min_cost = 0 ; for ( int i = 1 ; i <= V ; i ++ ) { if ( ! vis [ i ] ) { int min_cost_node = INT_MAX ; dfs ( i , cost , vis , min_cost_node ) ; min_cost += min_cost_node ; } } return min_cost ; }
bool check ( string & str , int mid , char a ) { int n = str . size ( ) ; int previous = -1 , i ; for ( i = 0 ; i < n ; ++ i ) { if ( str [ i ] == a ) { if ( i - previous > mid ) { return false ; } previous = i ; } } if ( i - previous > mid ) return false ; else return true ; }
bool possible ( string & str , int mid ) { for ( int i = 0 ; i < 26 ; ++ i ) { if ( check ( str , mid , i + 'a' ) ) return true ; } return false ; }
int findMinLength ( string & str ) { int low = 1 , high = str . length ( ) ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( possible ( str , mid ) ) high = mid - 1 ; else low = mid + 1 ; } return high + 1 ; }
int solve ( int A [ ] , int N ) { int i = 0 ; int k = 0 ; for ( int j = 1 ; j < N ; j ++ ) { int tempK = min ( A [ i ] , A [ j ] ) / ( j - i ) ; if ( tempK > k ) { k = tempK ; } if ( A [ j ] >= A [ i ] / ( j - i ) ) i = j ; } return k ; }
bool possible ( int arr [ ] , int N , int mid , int K ) { int add = 0 ; for ( int i = N / 2 - ( N + 1 ) % 2 ; i < N ; ++ i ) { if ( mid - arr [ i ] > 0 ) { add += ( mid - arr [ i ] ) ; if ( add > K ) return false ; } } if ( add <= K ) return true ; else return false ; }
int findMaxMedian ( int arr [ ] , int N , int K ) { int low = 1 ; int mx = 0 ; for ( int i = 0 ; i < N ; ++ i ) { mx = max ( mx , arr [ i ] ) ; } long long int high = K + mx ; while ( low <= high ) { int mid = ( high + low ) / 2 ; if ( possible ( arr , N , mid , K ) ) { low = mid + 1 ; } else { high = mid - 1 ; } } if ( N % 2 == 0 ) { if ( low - 1 < arr [ N / 2 ] ) { return ( arr [ N / 2 ] + low - 1 ) / 2 ; } } return low - 1 ; }
void split ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] == 1 ) { count = 2 ; break ; } } cout << count << endl ; }
bool check ( string str1 , string str2 ) { vector < bool > mark ( 26 , false ) ; int n = str1 . size ( ) , m = str2 . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mark [ str1 [ i ] - 'a' ] = true ; } for ( int i = 0 ; i < m ; i ++ ) { if ( mark [ str2 [ i ] - 'a' ] ) return true ; } return false ; }
bool countLessThanMid ( LL mid , LL N , LL M , LL K ) { LL count = 0 ; for ( int i = 1 ; i <= min ( ( LL ) N , mid ) ; ++ i ) { count = count + min ( mid / i , M ) ; } if ( count >= K ) return false ; else return true ; }
LL findKthElement ( LL N , LL M , LL K ) { LL low = 1 , high = N * M ; while ( low <= high ) { LL mid = low + ( high - low ) / 2 ; if ( countLessThanMid ( mid , N , M , K ) ) low = mid + 1 ; else high = mid - 1 ; } return high + 1 ; }
int PermuteTheArray ( int A [ ] , int n ) { int arr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ A [ i ] - 1 ] = i ; } int mini = n , maxi = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mini = min ( mini , arr [ i ] ) ; maxi = max ( maxi , arr [ i ] ) ; if ( maxi - mini == i ) count ++ ; } return count ; }
vector < int > findLargest ( int beg , int end , vector < int > arr , int n ) { if ( beg == end ) { vector < int > compared ( n , 0 ) ; compared [ 0 ] = 1 ; compared [ 1 ] = arr [ beg ] ; return compared ; } vector < int > compared1 = findLargest ( beg , ( beg + end ) / 2 , arr , n ) ; vector < int > compared2 = findLargest ( ( beg + end ) / 2 + 1 , end , arr , n ) ; if ( compared1 [ 1 ] > compared2 [ 1 ] ) { int k = compared1 [ 0 ] + 1 ; compared1 [ 0 ] = k ; compared1 [ k ] = compared2 [ 1 ] ; return compared1 ; } else { int k = compared2 [ 0 ] + 1 ; compared2 [ 0 ] = k ; compared2 [ k ] = compared1 [ 1 ] ; return compared2 ; } }
void findSecondLargest ( int end , vector < int > arr ) { vector < int > compared1 = findLargest ( 0 , end - 1 , arr , end ) ; vector < int > compared2 = findLargest ( 2 , compared1 [ 0 ] + 2 , compared1 , compared1 [ 0 ] ) ; cout << compared2 [ 1 ] ; }
int CountsubString ( char str [ ] , int n ) { int c = 0 ; for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; char temp = str [ i ] , f = 0 ; if ( j == i ) { c ++ ; continue ; } int k = i + 1 ; while ( temp > str [ k ] && k <= j ) { temp = str [ k ] ; k ++ ; } if ( k > j ) { c ++ ; f = 2 ; } while ( temp < str [ k ] && k <= j && f != 2 ) { temp = str [ k ] ; k ++ ; } if ( k > j && f != 2 ) { c ++ ; f = 0 ; } } } return c ; }
void countSubString ( string S , char C ) { int count = 0 ; int conCount = 0 ; for ( char ch : S ) { if ( ch == C ) conCount ++ ; else { count += ( conCount * ( conCount + 1 ) ) / 2 ; conCount = 0 ; } } count += ( conCount * ( conCount + 1 ) ) / 2 ; cout << count ; }
void checkPalindrome ( string S ) { int N = S . size ( ) ; bool first_half = true ; bool second_half = true ; int cnt = ( N / 2 ) - 1 ; for ( int i = 0 ; i < ( ( N / 2 ) / 2 ) ; i ++ ) { if ( S [ i ] != S [ cnt ] ) { first_half = false ; break ; } if ( S [ N / 2 + i ] != S [ N / 2 + cnt ] ) { second_half - false ; break ; } cnt -- ; } if ( first_half && second_half ) { cout << "Yes" << endl ; } else { cout << "No" << endl ; } }
bool isSubsetSum ( int arr [ ] , int n , int sum ) { bool subset [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < arr [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= arr [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } return subset [ n ] [ sum ] ; }
int findSum ( int * arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int val = sqrt ( sum ) ; for ( int i = val ; i >= 0 ; i -- ) { if ( isSubsetSum ( arr , n , i * i ) ) { return i * i ; } } return 0 ; }
int findsubArray ( int arr [ ] , int N , int K ) { int res = N + 1 ; for ( int i = 0 ; i < N ; i ++ ) { int curr_prod = 1 ; for ( int j = i ; j < N ; j ++ ) { curr_prod = curr_prod * arr [ j ] ; if ( curr_prod % N == K && res > ( j - i + 1 ) ) { res = min ( res , j - i + 1 ) ; break ; } } } return ( res == N + 1 ) ? 0 : res ; }
void check ( int arr [ N ] [ M ] ) { int f = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! checkBitonic ( arr [ i ] , M ) ) { cout << "NO" << endl ; return ; } } for ( int i = 0 ; i < N ; i ++ ) { int temp [ N ] ; for ( int j = 0 ; j < N ; j ++ ) { temp [ j ] = arr [ j ] [ i ] ; } if ( ! checkBitonic ( temp , N ) ) { cout << "NO" << endl ; return ; } } cout << "YES" ; }
int getMaxGcd ( int N ) { int maxGcd = INT_MIN , A , B ; for ( int i = 1 ; i <= sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { A = i , B = N / i ; maxGcd = max ( maxGcd , __gcd ( A , B ) ) ; } } return maxGcd ; }
bool can_place ( int A [ ] , int n , int B , int mid ) { int count = 1 ; int last_position = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] - last_position >= mid ) { last_position = A [ i ] ; count ++ ; if ( count == B ) { return true ; } } } return false ; }
int find_min_difference ( int A [ ] , int n , int B ) { sort ( A , A + n ) ; int s = 0 ; int e = A [ n - 1 ] - A [ 0 ] ; int ans = 0 ; while ( s <= e ) { long long int mid = ( s + e ) / 2 ; if ( can_place ( A , n , B , mid ) ) { ans = mid ; s = mid + 1 ; } else { e = mid - 1 ; } } return ans ; }
void UniversalSubset ( vector < string > A , vector < string > B ) { int n1 = A . size ( ) ; int n2 = B . size ( ) ; vector < string > res ; int A_fre [ n1 ] [ 26 ] ; for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) A_fre [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < A [ i ] . size ( ) ; j ++ ) { A_fre [ i ] [ A [ i ] [ j ] - 'a' ] ++ ; } } int B_fre [ 26 ] = { 0 } ; for ( int i = 0 ; i < n2 ; i ++ ) { int arr [ 26 ] = { 0 } ; for ( int j = 0 ; j < B [ i ] . size ( ) ; j ++ ) { arr [ B [ i ] [ j ] - 'a' ] ++ ; B_fre [ B [ i ] [ j ] - 'a' ] = max ( B_fre [ B [ i ] [ j ] - 'a' ] , arr [ B [ i ] [ j ] - 'a' ] ) ; } } for ( int i = 0 ; i < n1 ; i ++ ) { int flag = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( A_fre [ i ] [ j ] < B_fre [ j ] ) { flag = 1 ; break ; } } if ( flag == 0 ) res . push_back ( A [ i ] ) ; } if ( res . size ( ) ) { for ( int i = 0 ; i < res . size ( ) ; i ++ ) { for ( int j = 0 ; j < res [ i ] . size ( ) ; j ++ ) cout << res [ i ] [ j ] ; } cout << " " ; } else cout << "-1" ; }
int countTriplets ( int A [ ] , int N ) { int ans = 0 ; map < int , int > map ; for ( int j = N - 2 ; j >= 1 ; j -- ) { map [ A [ j + 1 ] ] ++ ; for ( int i = 0 ; i < j ; i ++ ) { int target = A [ i ] * A [ j ] ; if ( map . find ( target ) != map . end ( ) ) ans += map [ target ] ; } } return ans ; }
int minDistance ( int a [ ] , int n ) { int maximum = -1 , minimum = INT_MAX ; int min_index = -1 , max_index = -1 ; int min_dist = n + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > maximum ) maximum = a [ i ] ; if ( a [ i ] < minimum ) minimum = a [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == minimum ) min_index = i ; if ( a [ i ] == maximum ) max_index = i ; if ( min_index != -1 && max_index != -1 ) min_dist = min ( min_dist , abs ( min_index - max_index ) ) ; } return min_dist ; }
int sign ( int x ) { if ( x > 0 ) return 1 ; else return -1 ; }
int findMaxSum ( int arr [ ] , int size ) { int max_sum = 0 , pres , i , j ; for ( i = 0 ; i < size ; i ++ ) { pres = arr [ i ] ; j = i ; while ( j < size && sign ( arr [ i ] ) == sign ( arr [ j ] ) ) { pres = max ( pres , arr [ j ] ) ; j ++ ; } max_sum = max_sum + pres ; i = j - 1 ; } return max_sum ; }
bool groupInKConsecutive ( vector < int > & arr , int K ) { map < int , int > count ; for ( int h : arr ) { ++ count [ h ] ; } for ( auto c : count ) { int cur = c . first ; int n = c . second ; if ( n > 0 ) { for ( int i = 1 ; i < K ; ++ i ) { if ( ! count . count ( cur + i ) ) { return false ; } count [ cur + i ] -= n ; if ( count [ cur + i ] < 0 ) return false ; } } } return true ; }
bool checkrules ( string s ) { if ( s . length ( ) == 0 ) return true ; if ( s [ 0 ] != '1' ) return false ; if ( s . length ( ) > 2 ) { if ( s [ 1 ] == '0' && s [ 2 ] == '0' ) return checkrules ( s . substr ( 3 ) ) ; } return checkrules ( s . substr ( 1 ) ) ; }
int countSubAllOnes ( string s ) { int l = 0 , r = 0 , ans = 0 ; while ( l <= r ) { if ( r == s . length ( ) ) { ans += ( ( r - l ) * ( r - l + 1 ) ) / 2 ; break ; } if ( s [ r ] == '1' ) r ++ ; else { ans += ( ( r - l ) * ( r - l + 1 ) ) / 2 ; l = r + 1 ; r ++ ; } } return ans ; }
int countOfPrimes ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( isPrime ( i ) ) { if ( sumSquare ( i ) ) count ++ ; } } return count ; }
int Maxlen ( int arr [ ] , int n ) { int ans = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count = 0 ; else count ++ ; ans = max ( ans , count ) ; } return ans ; }
void findPair ( int a [ ] , int n ) { int min_dist = INT_MAX ; int index_a = -1 , index_b = -1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( j - i < min_dist ) { if ( a [ i ] % a [ j ] == 0 a [ j ] % a [ i ] == 0 ) { min_dist = j - i ; index_a = i ; index_b = j ; } } } } if ( index_a == -1 ) { cout << ( "-1" ) ; } else { cout << "(" << a [ index_a ] << ", " << a [ index_b ] << ")" ; } }
int findNumberDivByPowerofTwo ( int ar [ ] , int k , int n ) { int found = -1 , m = k ; while ( m > 0 ) { int l = 0 ; int r = n - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( ar [ mid ] == m ) { found = m ; break ; } else if ( ar [ mid ] > m ) { r = mid - 1 ; } else if ( ar [ mid ] < m ) { l = mid + 1 ; } } if ( found != -1 ) { break ; } m = m / 2 ; } return found ; }
int longestNudeSubseq ( int arr [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isNudeNum ( arr [ i ] ) ) answer ++ ; } return answer ; }
int findSubset ( int * a , int n ) { int sum = 0 ; int cnt = 0 ; vector < int > v ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i - 1 ] - i <= 0 ) { sum += a [ i - 1 ] - i ; cnt += 1 ; } else { v . push_back ( a [ i - 1 ] - i ) ; } } sort ( v . begin ( ) , v . end ( ) ) ; int ptr = 0 ; while ( ptr < v . size ( ) && sum + v [ ptr ] <= 0 ) { cnt += 1 ; ptr += 1 ; sum += v [ ptr ] ; } return cnt ; }
vector < int > get_submaxarr ( int * arr , int n , int y ) { int j = 0 ; stack < int > stk ; vector < int > maxarr ( n ) ; stk . push ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( stk . empty ( ) == false and arr [ i ] > arr [ stk . top ( ) ] ) { maxarr [ stk . top ( ) ] = i - 1 ; stk . pop ( ) ; } stk . push ( i ) ; } while ( ! stk . empty ( ) ) { maxarr [ stk . top ( ) ] = n - 1 ; stk . pop ( ) ; } vector < int > submax ; for ( int i = 0 ; i <= n - y ; i ++ ) { while ( maxarr [ j ] < i + y - 1 or j < i ) { j ++ ; } submax . push_back ( arr [ j ] ) ; } return submax ; }
int findMinx ( int A , int B , int C , int K ) { int start = 1 ; int end = ceil ( sqrt ( K ) ) ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; int x = func ( A , B , C , mid ) ; int Y = func ( A , B , C , mid - 1 ) ; if ( x >= K && Y < K ) { return mid ; } else if ( x < K ) { start = mid + 1 ; } else { end = mid - 1 ; } } return -1 ; }
int longestSubarray ( int arr [ ] , int n , int k ) { int i , j , Max = 1 ; set < int > s ; for ( i = 0 ; i < n - 1 ; i ++ ) { s . insert ( arr [ i ] ) ; for ( j = i + 1 ; j < n ; j ++ ) { if ( abs ( arr [ i ] - arr [ j ] ) == 0 || abs ( arr [ i ] - arr [ j ] ) == k ) { if ( ! s . count ( arr [ j ] ) ) { if ( s . size ( ) == 2 ) break ; else s . insert ( arr [ j ] ) ; } } else break ; } if ( s . size ( ) == 2 ) { Max = max ( Max , j - i ) ; s . clear ( ) ; } else s . clear ( ) ; } return Max ; }
void printDiagonal ( int K , int N , vector < vector < int > > & M ) { int startrow , startcol ; if ( K - 1 < N ) { startrow = K - 1 ; startcol = 0 ; } else { startrow = N - 1 ; startcol = K - N ; } for ( ; startrow >= 0 && startcol < N ; startrow -- , startcol ++ ) { cout << M [ startrow ] [ startcol ] << " " ; } }
vector < int > generateSequence ( int * freq , int n ) { map < int , int > m ; int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { m [ i ] = freq [ i ] ; total += freq [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( m [ i ] ) { vector < int > sequence ; auto mcopy = m ; mcopy [ i ] -- ; sequence . push_back ( i ) ; int last = i ; for ( int i = 0 ; i < total - 1 ; i ++ ) { if ( mcopy [ last - 1 ] ) { mcopy [ last - 1 ] -- ; sequence . push_back ( last - 1 ) ; last -- ; } else if ( mcopy [ last + 1 ] ) { mcopy [ last + 1 ] -- ; sequence . push_back ( last + 1 ) ; last ++ ; } else break ; } if ( sequence . size ( ) == total ) { return sequence ; } } } vector < int > empty ; return empty ; }
void getMinimumDistance ( int a [ ] , int n ) { set < int > min_set ; set < int > max_set ; int max = 0 , min = INT_MAX ; map < int , int > frequency ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ a [ i ] ] += 1 ; } for ( int i = 0 ; i < n ; i ++ ) { int count = frequency [ a [ i ] ] ; if ( count == max ) { max_set . insert ( a [ i ] ) ; } else if ( count > max ) { max_set . clear ( ) ; max = count ; max_set . insert ( a [ i ] ) ; } if ( count == min ) { min_set . insert ( a [ i ] ) ; } else if ( count < min ) { min_set . clear ( ) ; min = count ; min_set . insert ( a [ i ] ) ; } } int min_dist = INT_MAX ; int last_min_found = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_set . find ( a [ i ] ) != min_set . end ( ) ) last_min_found = i ; if ( max_set . find ( a [ i ] ) != max_set . end ( ) && last_min_found != -1 ) { if ( ( i - last_min_found ) < min_dist ) min_dist = i - last_min_found ; } } last_min_found = -1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( min_set . find ( a [ i ] ) != min_set . end ( ) ) last_min_found = i ; if ( max_set . find ( a [ i ] ) != max_set . end ( ) && last_min_found != -1 ) { if ( ( last_min_found - i ) > min_dist ) min_dist = last_min_found - i ; } } cout << ( min_dist ) ; }
void printNum ( int L , int R ) { for ( int i = L ; i <= R ; i ++ ) { int temp = i ; int c = 10 ; int flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) cout << i << " " ; } }
void findPair ( int arr [ ] , int n ) { int i , j ; if ( n < 2 ) { cout << "-1" << endl ; } set < int > hashMap ; for ( int k = 0 ; k < n ; k ++ ) { hashMap . insert ( arr [ k ] ) ; } for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( hashMap . find ( sum ) == hashMap . end ( ) ) { cout << "(" << arr [ i ] << ", " << arr [ j ] << ")" << endl ; } } } }
ll findLengthOfMaxSubset ( int arr [ ] , int n , int m ) { set < int > s ; int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int tmp = arr [ i ] ; if ( tmp != m ) { s . insert ( tmp ) ; answer ++ ; } } int min = 1 ; while ( s . count ( min ) ) { min ++ ; } if ( min != m ) { answer = -1 ; } return answer ; }
bool getDiameterPath ( int vertex , int targetVertex , int parent , vector < int > & path ) { if ( vertex == targetVertex ) { path . push_back ( vertex ) ; return true ; } for ( auto i : tree [ vertex ] ) { if ( i == parent ) continue ; if ( getDiameterPath ( i , targetVertex , vertex , path ) ) { path . push_back ( vertex ) ; return true ; } } return false ; }
void addedge ( int a , int b ) { tree [ a ] . push_back ( b ) ; tree [ b ] . push_back ( a ) ; }
void FindCenter ( int n ) { int maxHeight = -1 ; int maxHeightNode = -1 ; farthestNode ( 0 , -1 , 0 , maxHeight , maxHeightNode ) ; int leaf1 = maxHeightNode ; maxHeight = -1 ; farthestNode ( maxHeightNode , -1 , 0 , maxHeight , maxHeightNode ) ; int leaf2 = maxHeightNode ; vector < int > path ; getDiameterPath ( leaf1 , leaf2 , -1 , path ) ; int pathSize = path . size ( ) ; if ( pathSize % 2 ) { cout << path [ pathSize / 2 ] << endl ; } else { cout << path [ pathSize / 2 ] << ", " << path [ ( pathSize - 1 ) / 2 ] << endl ; } }
int countSubsquare ( int arr [ ] [ m ] , int n , int X ) { int dp [ n + 1 ] [ m + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { dp [ i + 1 ] [ j + 1 ] = arr [ i ] [ j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; } } int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { int lo = 1 ; int hi = min ( n - i , m - j ) + 1 ; bool found = false ; while ( lo <= hi ) { int mid = ( lo + hi ) / 2 ; int ni = i + mid - 1 ; int nj = j + mid - 1 ; int sum = dp [ ni ] [ nj ] - dp [ ni ] [ j - 1 ] - dp [ i - 1 ] [ nj ] + dp [ i - 1 ] [ j - 1 ] ; if ( sum >= X ) { if ( sum == X ) { found = true ; } hi = mid - 1 ; } else { lo = mid + 1 ; } } if ( found == true ) { cnt ++ ; } } } return cnt ; }
long long int countSub ( string str ) { int n = ( int ) str . size ( ) ; long long int ans = 0 ; int cnt [ 26 ] ; memset ( cnt , 0 , sizeof ( cnt ) ) ; int i = 0 , j = 0 ; while ( i < n ) { if ( j < n && ( cnt [ str [ j ] - 'a' ] == 0 ) ) { cnt [ str [ j ] - 'a' ] ++ ; ans += ( j - i + 1 ) ; j ++ ; } else { cnt [ str [ i ] - 'a' ] -- ; i ++ ; } } return ans ; }
void findMaxValue ( int N , int K ) { int packages ; int maxi = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( N % i == 0 ) maxi = max ( maxi , i ) ; } packages = N / maxi ; cout << packages << endl ; }
void max_sum_subarray ( vector < int > arr , int L , int R ) { int n = arr . size ( ) ; int pre [ n ] = { 0 } ; pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } multiset < int > s1 ; s1 . insert ( 0 ) ; int ans = INT_MIN ; ans = max ( ans , pre [ L - 1 ] ) ; int flag = 0 ; for ( int i = L ; i < n ; i ++ ) { if ( i - R >= 0 ) { if ( flag == 0 ) { auto it = s1 . find ( 0 ) ; s1 . erase ( it ) ; flag = 1 ; } } if ( i - L >= 0 ) s1 . insert ( pre [ i - L ] ) ; ans = max ( ans , pre [ i ] - * s1 . begin ( ) ) ; if ( i - R >= 0 ) { auto it = s1 . find ( pre [ i - R ] ) ; s1 . erase ( it ) ; } } cout << ans << endl ; }
int rowWise ( char * v , int n , int m , int k ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int countcons = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( * ( v + i * m + j ) == '1' ) { countcons = 0 ; } else { countcons ++ ; } if ( countcons >= k ) { ans ++ ; } } } return ans ; }
int colWise ( char * v , int n , int m , int k ) { int ans = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int countcons = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( * ( v + j * n + i ) == '1' ) { countcons = 0 ; } else { countcons ++ ; } if ( countcons >= k ) { ans ++ ; } } } return ans ; }
bool solve ( int a [ ] , int n ) { int mx = INT_MIN ; for ( int j = 1 ; j < n ; j ++ ) { if ( mx > a [ j ] ) return false ; mx = max ( mx , a [ j - 1 ] ) ; } return true ; }
int count ( vector < int > v , int n ) { int i , odd = 0 , even = 0 ; int j , d , count ; int t = ( int ) 1 << v . size ( ) ; int size = v . size ( ) ; for ( i = 1 ; i < t ; i ++ ) { d = 1 , count = 0 ; for ( j = 0 ; j < size ; j ++ ) { if ( i & ( 1 << j ) ) { d *= v [ j ] ; count ++ ; } } if ( count & 1 ) odd += n / d ; else even += n / d ; } return ( odd - even ) ; }
int BinarySearch ( int l , int r , vector < int > v , int key ) { int mid ; while ( r - l > 1 ) { mid = ( l + r ) / 2 ; if ( key <= count ( v , mid ) ) { r = mid ; } else { l = mid ; } } if ( key == count ( v , l ) ) return l ; else return r ; }
void sieve ( ) { memset ( spf , -1 , 100005 ) ; for ( int i = 2 ; i * i <= 100005 ; i ++ ) { for ( int j = i ; j <= 100005 ; j += i ) { if ( spf [ j ] == -1 ) { spf [ j ] = i ; } } } }
set < int > findPrimeFactors ( set < int > s , int n ) { while ( n > 1 ) { s . insert ( spf [ n ] ) ; n /= spf [ n ] ; } return s ; }
int MinimumSteps ( int n , int m ) { queue < pair < int , int > > q ; set < int > s ; q . push ( { n , 0 } ) ; while ( ! q . empty ( ) ) { int newNum = q . front ( ) . first ; int distance = q . front ( ) . second ; q . pop ( ) ; set < int > k = findPrimeFactors ( s , newNum ) ; for ( auto i : k ) { if ( newNum == m ) { return distance ; } else if ( newNum > m ) { break ; } else { q . push ( { newNum + i , distance + 1 } ) ; } } } return -1 ; }
void maxSide ( int a [ ] , int n ) { int sideLength = 0 ; sort ( a , a + n ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] > sideLength ) { sideLength ++ ; } else { break ; } } cout << sideLength << endl ; }
void medianChange ( vector < int > & arr1 , vector < int > & arr2 ) { int N = arr1 . size ( ) ; vector < float > median ; if ( N & 1 ) { median . push_back ( arr1 [ N / 2 ] * 1.0 ) ; } else { median . push_back ( ( arr1 [ N / 2 ] + arr1 [ ( N - 1 ) / 2 ] ) / 2.0 ) ; } for ( auto & x : arr2 ) { auto it = find ( arr1 . begin ( ) , arr1 . end ( ) , x ) ; arr1 . erase ( it ) ; N -- ; if ( N & 1 ) { median . push_back ( arr1 [ N / 2 ] * 1.0 ) ; } else { median . push_back ( ( arr1 [ N / 2 ] + arr1 [ ( N - 1 ) / 2 ] ) / 2.0 ) ; } } for ( int i = 0 ; i < median . size ( ) - 1 ; i ++ ) { cout << median [ i + 1 ] - median [ i ] << ' ' ; } }
int countPairs ( int X [ ] , int Y [ ] , int m , int n ) { vector < int > suffix ( 1005 ) ; long long total_pairs = 0 ; for ( int i = 0 ; i < n ; i ++ ) suffix [ Y [ i ] ] ++ ; for ( int i = 1e3 ; i >= 3 ; i -- ) suffix [ i ] += suffix [ i + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { if ( X [ i ] == 0 ) continue ; else if ( X [ i ] == 1 ) { total_pairs += suffix [ 0 ] ; continue ; } else if ( X [ i ] == 2 ) total_pairs += suffix [ 5 ] ; else if ( X [ i ] == 3 ) total_pairs += suffix [ 2 ] + suffix [ 4 ] ; else total_pairs += suffix [ X [ i ] + 1 ] ; total_pairs += suffix [ 0 ] + suffix [ 1 ] ; } return total_pairs ; }
int solve ( int A [ ] [ 10 ] , int N , int M ) { int B [ N ] [ M ] ; int c = 1 ; set < int > s ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = c ++ ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( i != 0 ) { if ( A [ i - 1 ] [ j ] == A [ i ] [ j ] ) B [ i - 1 ] [ j ] = B [ i ] [ j ] ; } if ( i != N - 1 ) { if ( A [ i + 1 ] [ j ] == A [ i ] [ j ] ) B [ i + 1 ] [ j ] = B [ i ] [ j ] ; } if ( j != 0 ) { if ( A [ i ] [ j - 1 ] == A [ i ] [ j ] ) B [ i ] [ j - 1 ] = B [ i ] [ j ] ; } if ( j != M - 1 ) { if ( A [ i ] [ j + 1 ] == A [ i ] [ j ] ) B [ i ] [ j + 1 ] = B [ i ] [ j ] ; } } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) s . insert ( B [ i ] [ j ] ) ; } return s . size ( ) ; }
int splitArray ( int start , int end , int * arr , int * prefix_sum ) { if ( start >= end ) return 0 ; for ( int k = start ; k < end ; ++ k ) { if ( ( prefix_sum [ k ] - prefix_sum [ start - 1 ] ) == ( prefix_sum [ end ] - prefix_sum [ k ] ) ) { return 1 + splitArray ( start , k , arr , prefix_sum ) + splitArray ( k + 1 , end , arr , prefix_sum ) ; } } return 0 ; }
void solve ( int arr [ ] , int n ) { int prefix_sum [ n + 1 ] ; prefix_sum [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i - 1 ] ; } cout << splitArray ( 1 , n , arr , prefix_sum ) ; }
void minDiff ( vector < ll > a , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) a . push_back ( a [ i ] * 2 ) ; } sort ( a . begin ( ) , a . end ( ) ) ; ll mindifference = a [ 1 ] - a [ 0 ] ; for ( int i = 1 ; i < a . size ( ) ; i ++ ) { mindifference = min ( mindifference , a [ i ] - a [ i - 1 ] ) ; } cout << mindifference << endl ; }
int countFac ( int n ) { int m = n ; int count = 0 ; for ( int i = 2 ; ( i * i ) <= m ; ++ i ) { int total = 0 ; while ( n % i == 0 ) { n /= i ; ++ total ; } int temp = 0 ; for ( int j = 1 ; ( temp + j ) <= total ; ++ j ) { temp += j ; ++ count ; } } if ( n != 1 ) ++ count ; return count ; }
int findMissing ( int arr [ ] , int left , int right , int diff ) { if ( right <= left ) return INT_MAX ; int mid = left + ( right - left ) / 2 ; if ( arr [ mid + 1 ] - arr [ mid ] != diff ) return ( arr [ mid ] + diff ) ; if ( mid > 0 && arr [ mid ] - arr [ mid - 1 ] != diff ) return ( arr [ mid - 1 ] + diff ) ; if ( arr [ mid ] == arr [ 0 ] + mid * diff ) return findMissing ( arr , mid + 1 , right , diff ) ; return findMissing ( arr , left , mid - 1 , diff ) ; }
int missingElement ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int diff = ( arr [ n - 1 ] - arr [ 0 ] ) / n ; return findMissing ( arr , 0 , n - 1 , diff ) ; }
long long int check ( int A , int B , int C , int D , long long int x ) { long long int ans ; ans = ( A * x * x * x + B * x * x + C * x + D ) ; return ans ; }
void findSolution ( int A , int B , int C , int D , int E ) { int start = 0 , end = 100000 ; long long int mid , ans ; while ( start <= end ) { mid = start + ( end - start ) / 2 ; ans = check ( A , B , C , D , mid ) ; if ( ans == E ) { cout << mid << endl ; return ; } if ( ans < E ) start = mid + 1 ; else end = mid - 1 ; } cout << "NA" ; }
int findParent ( int height , int node ) { int start = 1 ; int end = pow ( 2 , height ) - 1 ; if ( end == node ) return -1 ; while ( node >= 1 ) { end = end - 1 ; int mid = start + ( end - start ) / 2 ; if ( mid == node end == node ) { return ( end + 1 ) ; } else if ( node < mid ) { end = mid ; } else { start = mid ; } } }
int findValue ( int R , int C ) { int k = ( R * ( R - 1 ) ) / 2 + 1 ; int diff = R + 1 ; for ( int i = 1 ; i < C ; i ++ ) { k = ( k + diff ) ; diff ++ ; } return k ; }
int power ( int x , unsigned int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }
int nthRootSearch ( int low , int high , int N , int K ) { if ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( power ( mid , K ) <= N ) && ( power ( mid + 1 , K ) > N ) ) { return mid ; } else if ( power ( mid , K ) < N ) { return nthRootSearch ( mid + 1 , high , N , K ) ; } else { return nthRootSearch ( low , mid - 1 , N , K ) ; } } return low ; }
int get_subset_count ( int arr [ ] , int K , int N ) { sort ( arr , arr + N ) ; int left , right ; left = 0 ; right = N - 1 ; int ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; }
int naive_find_x ( int N ) { int c = 0 , i ; for ( i = 1 ; i < N ; i ++ ) { c += i * i * i ; if ( c >= N ) break ; } return i ; }
int binary_searched_find_x ( int k ) { int l = 0 ; int r = k ; int ans = 0 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( pow ( ( ( mid * ( mid + 1 ) ) / 2 ) , 2 ) >= k ) { ans = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return ans ; }
int checkPerfectSquare ( long int N , long int start , long int last ) { long int mid = ( start + last ) / 2 ; if ( start > last ) { return -1 ; } if ( mid * mid == N ) { return mid ; } else if ( mid * mid > N ) { return checkPerfectSquare ( N , start , mid - 1 ) ; } else { return checkPerfectSquare ( N , mid + 1 , last ) ; } }
void minDistancePoints ( int A [ ] , int K , int n ) { map < int , int > m ; queue < int > q ; for ( int i = 0 ; i < n ; ++ i ) { m [ A [ i ] ] = 1 ; q . push ( A [ i ] ) ; } vector < int > ans ; while ( K > 0 ) { int x = q . front ( ) ; q . pop ( ) ; if ( ! m [ x - 1 ] && K > 0 ) { m [ x - 1 ] = 1 ; q . push ( x - 1 ) ; ans . push_back ( x - 1 ) ; K -- ; } if ( ! m [ x + 1 ] && K > 0 ) { m [ x + 1 ] = 1 ; q . push ( x + 1 ) ; ans . push_back ( x + 1 ) ; K -- ; } } for ( auto i : ans ) cout << i << " " ; }
int search ( int mat [ ] [ 3 ] , int n , int m ) { int i , a = INT_MAX ; for ( i = 0 ; i < n ; i ++ ) { int low = 0 ; int high = m - 1 ; int mid ; int ans = INT_MAX ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( mat [ i ] [ mid ] == 1 ) { if ( mid == 0 ) { ans = 0 ; break ; } else if ( mat [ i ] [ mid - 1 ] == 0 ) { ans = mid ; break ; } } if ( mat [ i ] [ mid ] == 1 ) high = mid - 1 ; else low = mid + 1 ; } if ( ans < a ) a = ans ; } if ( a == INT_MAX ) return -1 ; return a + 1 ; }
void findNumbers ( int N , int M ) { int m = M ; map < int , int > remLen ; int len , remainder ; for ( len = 1 ; len <= N + 1 ; ++ len ) { remainder = M % N ; if ( remLen . find ( remainder ) == remLen . end ( ) ) remLen [ remainder ] = len ; else break ; M = M * 10 + m ; M = M % N ; } int LenA = len ; int LenB = remLen [ remainder ] ; for ( int i = 0 ; i < LenB ; ++ i ) cout << m ; cout << " " ; for ( int i = 0 ; i < LenA ; ++ i ) cout << m ; return ; }
int subMatrixSum ( int i , int j , int len ) { return prefix_2D [ i ] [ j ] - prefix_2D [ i ] [ j - len ] - prefix_2D [ i - len ] [ j ] + prefix_2D [ i - len ] [ j - len ] ; }
int numberOfWays ( int a [ ] , int b [ ] , int n , int m , int k ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) prefix_2D [ i ] [ j ] = 1 ; else prefix_2D [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { prefix_2D [ i ] [ j ] += prefix_2D [ i ] [ j - 1 ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { prefix_2D [ i ] [ j ] += prefix_2D [ i - 1 ] [ j ] ; } } int answer = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { int low = 1 ; int high = min ( i , j ) ; while ( low < high ) { int mid = ( low + high ) >> 1 ; if ( subMatrixSum ( i , j , mid ) >= k ) { high = mid ; } else { low = mid + 1 ; } } if ( subMatrixSum ( i , j , low ) >= k ) { answer += ( min ( i , j ) - low + 1 ) ; } } } return answer ; }
void minpoint ( int arr [ ] , int n , int k ) { int min_point = 0 ; for ( int i = 1 ; i < k - 1 ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) min_point += 1 ; } int final_point = min_point ; for ( int i = k ; i < n ; i ++ ) { if ( arr [ i - ( k - 1 ) ] < arr [ i - ( k - 1 ) + 1 ] && arr [ i - ( k - 1 ) ] < arr [ i - ( k - 1 ) - 1 ] ) min_point -= 1 ; if ( arr [ i - 1 ] < arr [ i ] && arr [ i - 1 ] < arr [ i - 2 ] ) min_point += 1 ; if ( min_point > final_point ) final_point = min_point ; } cout << ( final_point ) ; }
void checkMin ( int arr [ ] , int len ) { int smallest = INT_MAX , secondSmallest = INT_MAX ; for ( int i = 0 ; i < len ; i ++ ) { if ( arr [ i ] < smallest ) { secondSmallest = smallest ; smallest = arr [ i ] ; } else if ( arr [ i ] < secondSmallest ) { secondSmallest = arr [ i ] ; } } if ( 2 * smallest <= secondSmallest ) cout << "Yes" ; else cout << "No" ; }
pair < int , int > find ( int dividend , int divisor , int start , int end ) { if ( start > end ) return { 0 , dividend } ; int mid = start + ( end - start ) / 2 ; int n = dividend - divisor * mid ; if ( n > divisor ) start = mid + 1 ; else if ( n < 0 ) end = mid - 1 ; else { if ( n == divisor ) { ++ mid ; n = 0 ; } return { mid , n } ; } return find ( dividend , divisor , start , end ) ; }
pair < int , int > divide ( int dividend , int divisor ) { return find ( dividend , divisor , 1 , dividend ) ; }
int get ( int a , int b , int n ) { int lo = 0 , hi = 1e6 ; int ans = 0 ; while ( lo <= hi ) { int mid = ( lo + hi ) / 2 ; int dig = ceil ( ( mid * log ( mid , b ) + log ( a , b ) ) ) ; if ( dig > n ) { hi = mid - 1 ; } else { ans = mid ; lo = mid + 1 ; } } return ans ; }
void FindRank ( int arr [ ] , int length ) { cout << "1" << " " ; for ( int i = 1 ; i < length ; i ++ ) { int rank = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) rank ++ ; } cout << rank << " " ; } }
void findFibonacci ( int N ) { for ( int i = N / 2 ; i > 1 ; i -- ) { if ( fib . find ( i ) != fib . end ( ) && fib . find ( N - i ) != fib . end ( ) ) { cout << i << " " << ( N - i ) << endl ; return ; } } cout << "-1" << endl ; }
void createHash ( ) { int prev = 0 , curr = 1 ; fibonacci . insert ( prev ) ; fibonacci . insert ( curr ) ; while ( curr <= MAX ) { int temp = curr + prev ; fibonacci . insert ( temp ) ; prev = curr ; curr = temp ; } }
bool checkArray ( int arr [ ] , int n ) { ll sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( fibonacci . find ( arr [ i ] ) != fibonacci . end ( ) ) sum += arr [ i ] ; if ( fibonacci . find ( sum ) != fibonacci . end ( ) ) return true ; return false ; }
void compute ( int sz ) { bool isFib [ sz + 1 ] ; memset ( isFib , false , sizeof ( isFib ) ) ; int prev = 0 , curr = 1 ; isFib [ prev ] = isFib [ curr ] = true ; while ( curr <= sz ) { int temp = curr + prev ; isFib [ temp ] = true ; prev = curr ; curr = temp ; } fibUpto [ 0 ] = 1 ; for ( int i = 1 ; i <= sz ; i ++ ) { fibUpto [ i ] = fibUpto [ i - 1 ] ; if ( isFib [ i ] ) fibUpto [ i ] ++ ; } }
int countOfNumbers ( int N , int K ) { compute ( N ) ; int low = 1 , high = N , ans = 0 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( mid - fibUpto [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ( ans ? N - ans + 1 : 0 ) ; }
void precompute ( string s , int n ) { for ( int i = 0 ; i < n ; i ++ ) { f [ s [ i ] - 'a' ] [ i ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { f [ i ] [ j ] += f [ i ] [ j - 1 ] ; } } }
int palindromicSubsequencesUtil ( int L , int R ) { int c , ok = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { int cnt = f [ i ] [ R ] ; if ( L > 0 ) cnt -= f [ i ] [ L - 1 ] ; if ( cnt > 1 ) { ok = 1 ; c = i ; break ; } } if ( ok == 0 ) { return -1 ; } return c ; }
void createHash ( set < int > & hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . insert ( prev ) ; hash . insert ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . insert ( temp ) ; prev = curr ; curr = temp ; } }
int longestFibSubarray ( int arr [ ] , int n ) { int max_val = * max_element ( arr , arr + n ) ; set < int > hash ; createHash ( hash , max_val ) ; int left [ n ] , right [ n ] ; int fibcount = 0 , res = -1 ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = fibcount ; if ( hash . find ( arr [ i ] ) != hash . end ( ) ) { fibcount ++ ; } else fibcount = 0 ; } fibcount = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { right [ i ] = fibcount ; if ( hash . find ( arr [ i ] ) != hash . end ( ) ) { fibcount ++ ; } else fibcount = 0 ; } for ( int i = 0 ; i < n ; i ++ ) res = max ( res , left [ i ] + right [ i ] ) ; return res ; }
bool isPrime ( int N ) { if ( N < 2 ) return false ; if ( N < 4 ) return true ; if ( ( N & 1 ) == 0 ) return false ; if ( N % 3 == 0 ) return false ; int curr = 5 , s = sqrt ( N ) ; while ( curr <= s ) { if ( N % curr == 0 ) return false ; curr += 2 ; if ( N % curr == 0 ) return false ; curr += 4 ; } return true ; }
bool check ( int s , int p , int prefix_sum [ ] , int n ) { bool satisfies = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( i + s - 1 >= n ) break ; if ( prefix_sum [ i + s - 1 ] - ( i - 1 >= 0 ? prefix_sum [ i - 1 ] : 0 ) < p ) satisfies = false ; } return satisfies ; }
int minimumWindowSize ( int x , int y , int p ) { int prefix_sum [ y - x + 1 ] = { 0 } ; for ( int i = x ; i <= y ; i ++ ) { if ( isPrime ( i ) ) prefix_sum [ i - x ] = 1 ; } for ( int i = 1 ; i < y - x + 1 ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] ; int low = 1 , high = y - x + 1 ; int mid ; while ( high - low > 1 ) { mid = ( low + high ) / 2 ; if ( check ( mid , p , prefix_sum , y - x + 1 ) ) { high = mid ; } else low = mid ; } if ( check ( low , p , prefix_sum , y - x + 1 ) ) return low ; return high ; }
void preProcess ( int mat [ N ] [ M ] , int aux [ N ] [ M ] ) { for ( int i = 0 ; i < M ; i ++ ) aux [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) aux [ i ] [ j ] = mat [ i ] [ j ] + aux [ i - 1 ] [ j ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 1 ; j < M ; j ++ ) aux [ i ] [ j ] += aux [ i ] [ j - 1 ] ; }
int sumQuery ( int aux [ N ] [ M ] , int tli , int tlj , int rbi , int rbj ) { int res = aux [ rbi ] [ rbj ] ; if ( tli > 0 ) res = res - aux [ tli - 1 ] [ rbj ] ; if ( tlj > 0 ) res = res - aux [ rbi ] [ tlj - 1 ] ; if ( tli > 0 && tlj > 0 ) res = res + aux [ tli - 1 ] [ tlj - 1 ] ; return res ; }
int maximumSquareSize ( int mat [ N ] [ M ] , int K ) { int aux [ N ] [ M ] ; preProcess ( mat , aux ) ; for ( int i = min ( N , M ) ; i >= 1 ; i -- ) { bool satisfies = true ; for ( int x = 0 ; x < N ; x ++ ) { for ( int y = 0 ; y < M ; y ++ ) { if ( x + i - 1 <= N - 1 && y + i - 1 <= M - 1 ) { if ( sumQuery ( aux , x , y , x + i - 1 , y + i - 1 ) > K ) satisfies = false ; } } } if ( satisfies == true ) return ( i ) ; } return 0 ; }
void preProcess ( int mat [ N ] [ M ] , int aux [ N ] [ M ] ) { for ( int i = 0 ; i < M ; i ++ ) aux [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) aux [ i ] [ j ] = mat [ i ] [ j ] + aux [ i - 1 ] [ j ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 1 ; j < M ; j ++ ) aux [ i ] [ j ] += aux [ i ] [ j - 1 ] ; }
int sumQuery ( int aux [ N ] [ M ] , int tli , int tlj , int rbi , int rbj ) { int res = aux [ rbi ] [ rbj ] ; if ( tli > 0 ) res = res - aux [ tli - 1 ] [ rbj ] ; if ( tlj > 0 ) res = res - aux [ rbi ] [ tlj - 1 ] ; if ( tli > 0 && tlj > 0 ) res = res + aux [ tli - 1 ] [ tlj - 1 ] ; return res ; }
bool check ( int mid , int aux [ N ] [ M ] , int K ) { bool satisfies = true ; for ( int x = 0 ; x < N ; x ++ ) { for ( int y = 0 ; y < M ; y ++ ) { if ( x + mid - 1 <= N - 1 && y + mid - 1 <= M - 1 ) { if ( sumQuery ( aux , x , y , x + mid - 1 , y + mid - 1 ) > K ) satisfies = false ; } } } return ( satisfies == true ) ; }
int maximumSquareSize ( int mat [ N ] [ M ] , int K ) { int aux [ N ] [ M ] ; preProcess ( mat , aux ) ; int low = 1 , high = min ( N , M ) ; int mid ; while ( high - low > 1 ) { mid = ( low + high ) / 2 ; if ( check ( mid , aux , K ) ) { low = mid ; } else high = mid ; } if ( check ( high , aux , K ) ) return high ; return low ; }
void createHash ( set < int > & hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . insert ( prev ) ; hash . insert ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . insert ( temp ) ; prev = curr ; curr = temp ; } }
void add_factors ( int n , unordered_map < int , int > & mp ) { for ( int i = 1 ; i <= int ( sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) mp [ i ] ++ ; else { mp [ i ] ++ ; mp [ n / i ] ++ ; } } } }
void removeDuplicates ( int arr [ ] , int n ) { int st = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 2 && arr [ i ] == arr [ i + 1 ] && arr [ i ] == arr [ i + 2 ] ) continue ; else { arr [ st ] = arr [ i ] ; st ++ ; } } cout << "{" ; for ( int i = 0 ; i < st ; i ++ ) { cout << arr [ i ] ; if ( i != st - 1 ) cout << ", " ; } cout << "}" ; }
bool permutation ( int arr [ ] , int n ) { set < int > hash ; int maxEle = 0 ; for ( int i = 0 ; i < n ; i ++ ) { hash . insert ( arr [ i ] ) ; maxEle = max ( maxEle , arr [ i ] ) ; } if ( maxEle != n ) return false ; if ( hash . size ( ) == n ) return true ; return false ; }
int findPivot ( int arr [ ] , int low , int high ) { if ( high < low ) return -1 ; if ( high == low ) return low ; int mid = ( low + high ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) { return mid ; } if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) { return mid - 1 ; } if ( arr [ low ] > arr [ mid ] ) { return findPivot ( arr , low , mid - 1 ) ; } else { return findPivot ( arr , mid + 1 , high ) ; } }
bool isRotated ( int arr [ ] , int n ) { int l = 0 ; int r = n - 1 ; int pivot = -1 ; if ( arr [ l ] > arr [ r ] ) { pivot = findPivot ( arr , l , r ) ; int temp = pivot ; if ( l < pivot ) { while ( pivot > l ) { if ( arr [ pivot ] < arr [ pivot - 1 ] ) { return false ; } pivot -- ; } } pivot = temp ; if ( pivot < r ) { pivot ++ ; while ( pivot < r ) { if ( arr [ pivot ] > arr [ pivot + 1 ] ) { return false ; } pivot ++ ; } } return true ; } else { return false ; } }
void state1 ( char c ) { if ( c == 'a' ) nfa = 2 ; else if ( c == 'b' c == 'c' ) nfa = 1 ; else flag = 1 ; }
void state2 ( char c ) { if ( c == 'a' ) nfa = 3 ; else if ( c == 'b' c == 'c' ) nfa = 2 ; else flag = 1 ; }
void state3 ( char c ) { if ( c == 'a' ) nfa = 1 ; else if ( c == 'b' c == 'c' ) nfa = 3 ; else flag = 1 ; }
void state4 ( char c ) { if ( c == 'b' ) nfa = 5 ; else if ( c == 'a' c == 'c' ) nfa = 4 ; else flag = 1 ; }
void state5 ( char c ) { if ( c == 'b' ) nfa = 6 ; else if ( c == 'a' c == 'c' ) nfa = 5 ; else flag = 1 ; }
void state6 ( char c ) { if ( c == 'b' ) nfa = 4 ; else if ( c == 'a' c == 'c' ) nfa = 6 ; else flag = 1 ; }
void state7 ( char c ) { if ( c == 'c' ) nfa = 8 ; else if ( c == 'b' c == 'a' ) nfa = 7 ; else flag = 1 ; }
void state9 ( char c ) { if ( c == 'c' ) nfa = 7 ; else if ( c == 'b' c == 'a' ) nfa = 9 ; else flag = 1 ; }
bool checkA ( string s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 1 ) state1 ( s [ i ] ) ; else if ( nfa == 2 ) state2 ( s [ i ] ) ; else if ( nfa == 3 ) state3 ( s [ i ] ) ; } if ( nfa == 1 ) { return true ; } else { nfa = 4 ; } }
bool checkB ( string s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 4 ) state4 ( s [ i ] ) ; else if ( nfa == 5 ) state5 ( s [ i ] ) ; else if ( nfa == 6 ) state6 ( s [ i ] ) ; } if ( nfa == 4 ) { return true ; } else { nfa = 7 ; } }
bool checkC ( string s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 7 ) state7 ( s [ i ] ) ; else if ( nfa == 8 ) state8 ( s [ i ] ) ; else if ( nfa == 9 ) state9 ( s [ i ] ) ; } if ( nfa == 7 ) { return true ; } }
int getPositionCount ( int a [ ] , int n ) { int count = 1 ; int min = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; }
int CountSubSet ( int arr [ ] , int n , int X ) { int N = pow ( 2 , n ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i & ( 1 << j ) ) if ( arr [ j ] == X ) count += 1 ; } } return count ; }
int calculatePower ( int b , int e ) { int ans = 1 ; while ( e > 0 ) { if ( e % 2 == 1 ) ans = ans * b ; e = e / 2 ; b = b * b ; } return ans ; }
int CountSubSet ( int arr [ ] , int n , int X ) { int count = 0 , checkX = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == X ) { checkX = 1 ; break ; } } if ( checkX == 1 ) count = calculatePower ( 2 , n - 1 ) ; else count = 0 ; return count ; }
int build ( int * A , int start , int end , int node ) { if ( start == end ) segment_tree [ node ] = A [ start ] ; else { int mid = ( start + end ) / 2 ; segment_tree [ node ] = max ( build ( A , start , mid , 2 * node + 1 ) , build ( A , mid + 1 , end , 2 * node + 2 ) ) ; } return segment_tree [ node ] ; }
int query ( int start , int end , int l , int r , int node ) { if ( start > r end < l ) return -1 ; if ( start >= l && end <= r ) return segment_tree [ node ] ; int mid = ( start + end ) / 2 ; return max ( query ( start , mid , l , r , 2 * node + 1 ) , query ( mid + 1 , end , l , r , 2 * node + 2 ) ) ; }
int longestSubArray ( int * A , int N , int K ) { int res = 1 ; int preSum [ N + 1 ] ; preSum [ 0 ] = A [ 0 ] ; for ( int i = 0 ; i < N ; i ++ ) preSum [ i + 1 ] = preSum [ i ] + A [ i ] ; build ( A , 0 , N - 1 , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { int start = i , end = N - 1 , mid , max_index = i ; while ( start <= end ) { mid = ( start + end ) / 2 ; int max_element = query ( 0 , N - 1 , i , mid , 0 ) ; int expected_sum = ( mid - i + 1 ) * max_element ; int actual_sum = preSum [ mid + 1 ] - preSum [ i ] ; if ( expected_sum - actual_sum <= K ) { start = mid + 1 ; max_index = max ( max_index , mid ) ; } else { end = mid - 1 ; } } res = max ( res , max_index - i + 1 ) ; } return res ; }
int solve ( int arr [ ] , int n , int k ) { int max_len = 0 , l = 0 , r = n , m ; while ( l <= r ) { m = ( l + r ) / 2 ; if ( maxSum ( arr , n , m ) > k ) r = m - 1 ; else { l = m + 1 ; max_len = m ; } } return max_len ; }
int countNums ( int l , int r ) { int cnt = 0 ; for ( int i = l ; i <= r ; i ++ ) { int lastDigit = ( i % 10 ) ; if ( ( lastDigit % 10 ) == 2 || ( lastDigit % 10 ) == 3 || ( lastDigit % 10 ) == 9 ) { cnt ++ ; } } return cnt ; }
int findMinimumK ( int a [ ] , int n , int s ) { int maximum = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { maximum = max ( maximum , a [ i ] ) ; } int low = 1 , high = maximum + 1 ; int ans = high ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ( int ) ( a [ i ] / mid ) ; } if ( sum > s ) low = mid + 1 ; else { ans = min ( ans , mid ) ; high = mid - 1 ; } } return ans ; }
bool allDigits ( string str , int len ) { bool present [ MAX ] = { false } ; for ( int i = 0 ; i < len ; i ++ ) { if ( isDigit ( str [ i ] ) ) { int digit = str [ i ] - '0' ; present [ digit ] = true ; } } for ( int i = 0 ; i < MAX ; i ++ ) { if ( ! present [ i ] ) return false ; } return true ; }
bool isPlusPossible ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; bool foundModOne = false ; for ( auto x : mp ) { int element = x . first ; int frequency = x . second ; if ( frequency % 4 == 0 ) continue ; if ( frequency % 4 == 1 ) { if ( foundModOne ) return false ; foundModOne = true ; } else return false ; } }
vector < int > merge ( vector < int > & v1 , vector < int > & v2 ) { int i = 0 , j = 0 ; vector < int > v ; while ( i < v1 . size ( ) && j < v2 . size ( ) ) { if ( v1 [ i ] <= v2 [ j ] ) { v . push_back ( v1 [ i ] ) ; i ++ ; } else { v . push_back ( v2 [ j ] ) ; j ++ ; } } for ( int k = i ; k < v1 . size ( ) ; k ++ ) v . push_back ( v1 [ k ] ) ; for ( int k = j ; k < v2 . size ( ) ; k ++ ) v . push_back ( v2 [ k ] ) ; return v ; }
void buildTree ( vector < int > * tree , int * arr , int index , int s , int e ) { if ( s == e ) { tree [ index ] . push_back ( arr [ s ] ) ; return ; } int mid = ( s + e ) / 2 ; buildTree ( tree , arr , 2 * index , s , mid ) ; buildTree ( tree , arr , 2 * index + 1 , mid + 1 , e ) ; tree [ index ] = merge ( tree [ 2 * index ] , tree [ 2 * index + 1 ] ) ; }
int query ( vector < int > * tree , int index , int s , int e , int l , int r , int k ) { if ( r < s l > e ) return 0 ; if ( s >= l && e <= r )  { return ( tree [ index ] . size ( ) - ( lower_bound ( tree [ index ] . begin ( ) , tree [ index ] . end ( ) , k ) - tree [ index ] . begin ( ) ) ) ; } int mid = ( s + e ) / 2 ; return ( query ( tree , 2 * index , s , mid , l , r , k ) + query ( tree , 2 * index + 1 , mid + 1 , e , l , r , k ) ) ; }
int findGCDSum ( int n , int a [ ] ) { int GCDSum = 0 ; int tempGCD = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { tempGCD = 0 ; for ( int k = i ; k <= j ; k ++ ) { tempGCD = __gcd ( tempGCD , a [ k ] ) ; } GCDSum += tempGCD ; } } return GCDSum ; }
void buildSparseTable ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { SparseTable [ i ] [ 0 ] = a [ i ] ; } for ( int j = 1 ; j <= 19 ; j ++ ) { for ( int i = 0 ; i <= n - ( 1 << j ) ; i ++ ) { SparseTable [ i ] [ j ] = __gcd ( SparseTable [ i ] [ j - 1 ] , SparseTable [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) ; } } }
int queryForGCD ( int L , int R ) { int returnValue ; int j = int ( log2 ( R - L + 1 ) ) ; returnValue = __gcd ( SparseTable [ L ] [ j ] , SparseTable [ R - ( 1 << j ) + 1 ] [ j ] ) ; return returnValue ; }
int calculateSum ( int a [ ] , int n ) { buildSparseTable ( a , n ) ; int endPointer , startPointer , prevEndPointer , tempGCD ; int tempAns = 0 ; for ( int i = 0 ; i < n ; i ++ ) { endPointer = i ; startPointer = i ; prevEndPointer = i ; tempGCD = a [ i ] ; while ( endPointer < n ) { endPointer = nextPosition ( tempGCD , startPointer , prevEndPointer , n ) ; tempAns += ( ( endPointer - prevEndPointer ) * tempGCD ) ; prevEndPointer = endPointer ; if ( endPointer < n ) { tempGCD = __gcd ( tempGCD , a [ endPointer ] ) ; } } } return tempAns ; }
bool isSquarePossible ( int arr [ ] , int n , int l ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= l ) cnt ++ ; if ( cnt >= l ) return true ; } return false ; }
int maxArea ( int arr [ ] , int n ) { int l = 0 , r = n ; int len = 0 ; while ( l <= r ) { int m = l + ( ( r - l ) / 2 ) ; if ( isSquarePossible ( arr , n , m ) ) { len = m ; l = m + 1 ; } else r = m - 1 ; } return ( len * len ) ; }
int find_triplet ( int array [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { indices [ array [ i ] ] . push_back ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { int y = array [ i ] ; for ( int j = 0 ; j < ROW ; j ++ ) { int s = test [ j ] [ 1 ] * y ; if ( s % test [ j ] [ 0 ] != 0 ) continue ; if ( s % test [ j ] [ 2 ] != 0 ) continue ; int x = s / test [ j ] [ 0 ] ; ll z = s / test [ j ] [ 2 ] ; if ( x > MAX z > MAX ) continue ; int l = 0 ; int r = indices [ x ] . size ( ) - 1 ; int first = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( indices [ x ] [ m ] < i ) { first = m ; l = m + 1 ; } else { r = m - 1 ; } } l = 0 ; r = indices [ z ] . size ( ) - 1 ; int third = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( indices [ z ] [ m ] > i ) { third = m ; r = m - 1 ; } else { l = m + 1 ; } } if ( first != -1 && third != -1 ) { answer += ( first + 1 ) * ( indices [ z ] . size ( ) - third ) ; } } } return answer ; }
int lcm ( int A , int B ) { return ( A * B ) / gcd ( A , B ) ; }
int checkA ( int A , int B , int C , int K ) { int start = 1 ; int end = K ; int ans = -1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = A * mid ; int divA = mid - 1 ; int divB = ( value % B == 0 ) ? value / B - 1 : value / B ; int divC = ( value % C == 0 ) ? value / C - 1 : value / C ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ; int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; } else if ( elem > ( K - 1 ) ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; }
int checkB ( int A , int B , int C , int K ) { int start = 1 ; int end = K ; int ans = -1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = B * mid ; int divB = mid - 1 ; int divA = ( value % A == 0 ) ? value / A - 1 : value / A ; int divC = ( value % C == 0 ) ? value / C - 1 : value / C ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ; int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; } else if ( elem > ( K - 1 ) ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; }
int checkC ( int A , int B , int C , int K ) { int start = 1 ; int end = K ; int ans = -1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int value = C * mid ; int divC = mid - 1 ; int divB = ( value % B == 0 ) ? value / B - 1 : value / B ; int divA = ( value % A == 0 ) ? value / A - 1 : value / A ; int divAB = ( value % lcm ( A , B ) == 0 ) ? value / lcm ( A , B ) - 1 : value / lcm ( A , B ) ; int divBC = ( value % lcm ( C , B ) == 0 ) ? value / lcm ( C , B ) - 1 : value / lcm ( C , B ) ; int divAC = ( value % lcm ( A , C ) == 0 ) ? value / lcm ( A , C ) - 1 : value / lcm ( A , C ) ; int divABC = ( value % lcm ( A , lcm ( B , C ) ) == 0 ) ? value / lcm ( A , lcm ( B , C ) ) - 1 : value / lcm ( A , lcm ( B , C ) ) ; int elem = divA + divB + divC - divAC - divBC - divAB + divABC ; if ( elem == ( K - 1 ) ) { ans = value ; break ; } else if ( elem > ( K - 1 ) ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; }
int findKthMultiple ( int A , int B , int C , int K ) { int res = checkA ( A , B , C , K ) ; if ( res == -1 ) res = checkB ( A , B , C , K ) ; if ( res == -1 ) res = checkC ( A , B , C , K ) ; return res ; }
int kthSmallest ( int a [ ] , int left , int right , int k ) { while ( left <= right ) { int pivotIndex = partition ( a , left , right ) ; if ( pivotIndex == k - 1 ) return a [ pivotIndex ] ; else if ( pivotIndex > k - 1 ) right = pivotIndex - 1 ; else left = pivotIndex + 1 ; } return -1 ; }
int calculateDifference ( int arr [ ] , int n ) { int max_val = * max_element ( arr , arr + n ) ; vector < bool > prime ( max_val + 1 , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int X1 = 1 , X2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { X1 ^= arr [ i ] ; } else if ( arr [ i ] != 1 ) { X2 ^= arr [ i ] ; } } return abs ( X1 - X2 ) ; }
bool containsElement ( int arr [ ] , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; ++ i ) xorArr ^= arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { int x = xorArr ^ arr [ i ] ; if ( arr [ i ] == x ) return true ; } return false ; }
double Square ( double n , double i , double j ) { double mid = ( i + j ) / 2 ; double mul = mid * mid ; if ( ( mul == n ) || ( abs ( mul - n ) < 0.00001 ) ) return mid ; else if ( mul < n ) return Square ( n , mid , j ) ; else return Square ( n , i , mid ) ; }
int length_substring ( string S , char K ) { int curr_cnt = 0 , prev_cnt = 0 , max_len ; for ( int i = 0 ; i < S . size ( ) ; i ++ ) { if ( S [ i ] == K ) { curr_cnt += 1 ; } else { prev_cnt = max ( prev_cnt , curr_cnt ) ; curr_cnt = 0 ; } } prev_cnt = max ( prev_cnt , curr_cnt ) ; max_len = prev_cnt ; return max_len ; }
int Xor_Sum ( int arr [ ] , int n ) { int sum = 0 , index , left_xor = 0 , right_xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { left_xor = left_xor ^ arr [ i ] ; right_xor = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { right_xor = right_xor ^ arr [ j ] ; } if ( left_xor + right_xor > sum ) { sum = left_xor + right_xor ; index = i ; } } return index + 1 ; }
void ComputePrefixXor ( int arr [ ] , int PrefixXor [ ] , int n ) { PrefixXor [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) PrefixXor [ i ] = PrefixXor [ i - 1 ] ^ arr [ i ] ; }
int Xor_Sum ( int arr [ ] , int n ) { int PrefixXor [ n ] ; ComputePrefixXor ( arr , PrefixXor , n ) ; int sum = 0 , index ; for ( int i = 0 ; i < n ; i ++ ) { if ( PrefixXor [ i ] + ( PrefixXor [ n - 1 ] ^ PrefixXor [ i ] ) > sum ) { sum = PrefixXor [ i ] + ( PrefixXor [ n - 1 ] ^ PrefixXor [ i ] ) ; index = i ; } } return index + 1 ; }
map < int , int > buildMapWithColor ( int arr [ ] , int n ) { map < int , int > mapWithColor ; for ( int i = 0 ; i < n ; i ++ ) { mapWithColor [ arr [ i ] ] = i + 1 ; } return mapWithColor ; }
bool isPalindrome ( string str , int i , int j ) { while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; }
int maxLenPalindrome ( string str , int n , char ch ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ch ) { for ( int j = n - 1 ; j >= i ; j -- ) { if ( str [ j ] == ch ) { if ( isPalindrome ( str , i , j ) ) { maxLen = max ( maxLen , j - i + 1 ) ; break ; } } } } } return maxLen ; }
vector < int > findCount ( string a [ ] , string b [ ] , int n , int m ) { int freq [ MAX ] = { 0 } ; vector < int > smallestFreq ; for ( int i = 0 ; i < n ; i ++ ) { string s = a [ i ] ; memset ( freq , 0 , sizeof freq ) ; for ( int j = 0 ; j < s . size ( ) ; j ++ ) { freq [ s [ j ] - 'a' ] ++ ; } for ( int j = 0 ; j < MAX ; j ++ ) { if ( freq [ j ] ) { smallestFreq . push_back ( freq [ j ] ) ; break ; } } } sort ( smallestFreq . begin ( ) , smallestFreq . end ( ) ) ; vector < int > ans ; for ( int i = 0 ; i < m ; i ++ ) { string s = b [ i ] ; memset ( freq , 0 , sizeof freq ) ; for ( int j = 0 ; j < s . size ( ) ; j ++ ) { freq [ s [ j ] - 'a' ] ++ ; } int frequency = 0 ; for ( int j = 0 ; j < MAX ; j ++ ) { if ( freq [ j ] ) { frequency = freq [ j ] ; break ; } } int ind = lower_bound ( smallestFreq . begin ( ) , smallestFreq . end ( ) , frequency ) - smallestFreq . begin ( ) ; ans . push_back ( ind ) ; } return ans ; }
void printAnswer ( string a [ ] , string b [ ] , int n , int m ) { vector < int > ans = findCount ( a , b , n , m ) ; for ( auto it : ans ) { cout << it << " " ; } }
int linearCheck ( int ar [ ] [ n ] , int arr [ ] ) { for ( int i = 0 ; i < m ; i ++ ) { bool matched = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( ar [ i ] [ j ] != arr [ j ] ) { matched = false ; break ; } } if ( matched ) return i + 1 ; } return -1 ; }
int compareRow ( int a1 [ ] , int a2 [ ] ) { for ( int i = 0 ; i < n ; i ++ ) { if ( a1 [ i ] < a2 [ i ] ) return 1 ; else if ( a1 [ i ] > a2 [ i ] ) return -1 ; } return 0 ; }
int binaryCheck ( int ar [ ] [ n ] , int arr [ ] ) { int l = 0 , r = m - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; int temp = compareRow ( ar [ mid ] , arr ) ; if ( temp == 0 ) return mid + 1 ; else if ( temp == 1 ) l = mid + 1 ; else r = mid - 1 ; } return -1 ; }
int findCnt ( int arr [ ] , int n , int k ) { int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { arr [ i ] += arr [ i - 1 ] ; if ( arr [ i ] > k or arr [ i ] < -1 * k ) ans ++ ; } if ( arr [ 0 ] > k arr [ 0 ] < -1 * k ) ans ++ ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) ans += n - ( upper_bound ( arr , arr + n , arr [ i ] + k ) - arr ) ; return ans ; }
int FindIntersection ( pair < int , int > type1 [ ] , int n , pair < int , int > type2 [ ] , int m ) { int ans = n * m ; vector < int > start , end ; for ( int i = 0 ; i < n ; i ++ ) { start . push_back ( type1 [ i ] . first ) ; end . push_back ( type1 [ i ] . second ) ; } sort ( start . begin ( ) , start . end ( ) ) ; sort ( end . begin ( ) , end . end ( ) ) ; for ( int i = 0 ; i < m ; i ++ ) { int L = type2 [ i ] . first ; int R = type2 [ i ] . second ; ans -= ( start . end ( ) - upper_bound ( start . begin ( ) , start . end ( ) , R ) ) ; ans -= ( upper_bound ( end . begin ( ) , end . end ( ) , L - 1 ) - end . begin ( ) ) ; } return ans ; }
int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; }
int divTermCount ( int a , int b , int c , int num ) { return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / lcm ( a , b ) ) - ( num / lcm ( b , c ) ) - ( num / lcm ( a , c ) ) + ( num / lcm ( a , lcm ( b , c ) ) ) ) ; }
int findNthTerm ( int a , int b , int c , int n ) { int low = 1 , high = INT_MAX , mid ; while ( low < high ) { mid = low + ( high - low ) / 2 ; if ( divTermCount ( a , b , c , mid ) < n ) low = mid + 1 ; else high = mid ; } return low ; }
void setZero ( int freq [ ] ) { for ( int i = 0 ; i < MAX ; i ++ ) freq [ i ] = 0 ; }
void preCalculate ( string str , int n ) { freq [ ( int ) str [ 0 ] ] [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { char ch = str [ i ] ; for ( int j = 0 ; j < MAX ; j ++ ) { char charToUpdate = j ; if ( charToUpdate == ch ) freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 ; else freq [ j ] [ i ] = freq [ j ] [ i - 1 ] ; } } }
int getFrequency ( char ch , int l , int r ) { if ( l == 0 ) return freq [ ( int ) ch ] [ r ] ; else return ( freq [ ( int ) ch ] [ r ] - freq [ ( int ) ch ] [ l - 1 ] ) ; }
string firstNonRepeating ( string str , int n , int l , int r ) { char t [ 2 ] = "" ; for ( int i = l ; i < r ; i ++ ) { char ch = str [ i ] ; if ( getFrequency ( ch , l , r ) == 1 ) { t [ 0 ] = ch ; return t ; } } return "-1" ; }
int maxLength ( string s , int n ) { int ans = INT_MIN ; vector < int > A , L , R ; int freq [ n + 5 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { int count = 0 ; memset ( freq , 0 , sizeof freq ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( s [ j ] - 'a' == i ) count ++ ; freq [ j ] = count ; } for ( int j = 0 ; j < n ; j ++ ) { L . push_back ( ( 2 * freq [ j - 1 ] ) - j ) ; R . push_back ( ( 2 * freq [ j ] ) - j ) ; } int max_len = INT_MIN ; int min_val = INT_MAX ; for ( int j = 0 ; j < n ; j ++ ) { min_val = min ( min_val , L [ j ] ) ; A . push_back ( min_val ) ; int l = 0 , r = j ; while ( l <= r ) { int mid = ( l + r ) >> 1 ; if ( A [ mid ] <= R [ j ] ) { max_len = max ( max_len , j - mid + 1 ) ; r = mid - 1 ; } else { l = mid + 1 ; } } } ans = max ( ans , max_len ) ; A . clear ( ) ; R . clear ( ) ; L . clear ( ) ; } return ans ; }
int minOperations ( int arr [ ] , int n ) { int start = ( int ) arr [ n - 1 ] ; int end = * ( max_element ( arr , arr + n ) ) + n ; int max_arr = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( check ( mid , n , arr ) ) { max_arr = mid ; end = mid - 1 ; } else { start = mid + 1 ; } } int desired [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { desired [ i ] = max_arr ; max_arr -- ; } int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { operations += ( desired [ i ] - arr [ i ] ) ; } return operations ; }
int countNode ( Node * head ) { int count = 0 ; while ( head -> next != NULL ) { Node * ptr = head -> next ; while ( ptr != NULL ) { if ( head -> data == ptr -> data ) { count ++ ; break ; } ptr = ptr -> next ; } head = head -> next ; } return count ; }
void insert ( Node * * head , int item ) { Node * temp = new Node ( ) ; temp -> data = item ; temp -> next = * head ; * head = temp ; }
int countNode ( Node * head ) { if ( head == NULL ) return 0 ; ; unordered_set < int > s ; s . insert ( head -> data ) ; int count = 0 ; for ( Node * curr = head -> next ; curr != NULL ; curr = curr -> next ) { if ( s . find ( curr -> data ) != s . end ( ) ) count ++ ; s . insert ( curr -> data ) ; } return count ; }
int countLessThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] < key ) { l = m + 1 ; index = m ; } else { r = m - 1 ; } } return ( index + 1 ) ; }
int countGreaterThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] <= key ) { l = m + 1 ; } else { r = m - 1 ; index = m ; } } if ( index == -1 ) return 0 ; return ( n - index ) ; }
int countTriplets ( int n , int * a , int * b , int * c ) { sort ( a , a + n ) ; sort ( b , b + n ) ; sort ( c , c + n ) ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int current = b [ i ] ; int a_index = -1 , c_index = -1 ; int low = countLessThan ( a , n , current ) ; int high = countGreaterThan ( c , n , current ) ; count += ( low * high ) ; } return count ; }
int maximum_middle_value ( int n , int k , int arr [ ] ) { int ans = -1 ; int low = ( n + 1 - k ) / 2 ; int high = ( n + 1 - k ) / 2 + k ; for ( int i = low ; i <= high ; i ++ ) { ans = max ( ans , arr [ i - 1 ] ) ; } return ans ; }
int firstRepeating ( string & str ) { bool visited [ NO_OF_CHARS ] ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) visited [ i ] = false ; int res = -1 ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { if ( visited [ str [ i ] ] == false ) visited [ str [ i ] ] = true ; else res = i ; } return res ; }
int minSteps ( int arr [ ] [ n ] ) { bool v [ n ] [ n ] = { 0 } ; queue < pair < int , int > > q ; q . push ( { 0 , 0 } ) ; int depth = 0 ; while ( q . size ( ) != 0 ) { int x = q . size ( ) ; while ( x -- ) { pair < int , int > y = q . front ( ) ; int i = y . first , j = y . second ; q . pop ( ) ; if ( v [ i ] [ j ] ) continue ; if ( i == n - 1 && j == n - 1 ) return depth ; v [ i ] [ j ] = 1 ; if ( i + arr [ i ] [ j ] < n ) q . push ( { i + arr [ i ] [ j ] , j } ) ; if ( j + arr [ i ] [ j ] < n ) q . push ( { i , j + arr [ i ] [ j ] } ) ; } depth ++ ; } return -1 ; }
int minSteps ( int arr [ ] , int n ) { bool v [ n ] = { 0 } ; queue < int > q ; q . push ( 0 ) ; int depth = 0 ; while ( q . size ( ) != 0 ) { int x = q . size ( ) ; while ( x -- ) { int i = q . front ( ) ; q . pop ( ) ; if ( v [ i ] ) continue ; if ( i == n - 1 ) return depth ; v [ i ] = 1 ; if ( i + arr [ i ] < n ) q . push ( i + arr [ i ] ) ; if ( i - arr [ i ] >= 0 ) q . push ( i - arr [ i ] ) ; } depth ++ ; } return -1 ; }
int divisorcount ( int elem ) { int ans = 0 ; for ( int i = 1 ; i <= sqrt ( elem ) ; i ++ ) { if ( elem % i == 0 ) { if ( i * i == elem ) ans ++ ; else ans += 2 ; } } return ans ; }
string findwinner ( int A [ ] , int B [ ] , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = divisorcount ( A [ i ] ) ; } for ( int i = 0 ; i < M ; i ++ ) { B [ i ] = divisorcount ( B [ i ] ) ; } sort ( A , A + N ) ; sort ( B , B + M ) ; int winA = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int val = A [ i ] ; int start = 0 ; int end = M - 1 ; int index = -1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( B [ mid ] <= val ) { index = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } winA += ( index + 1 ) ; } int winB = N * M - winA ; if ( winA > winB ) { return "A" ; } else if ( winB > winA ) { return "B" ; } return "Draw" ; }
int minTime ( int box [ ] , int truck [ ] , int n , int m ) { sort ( box , box + n ) ; sort ( truck , truck + m ) ; int l = 0 ; int h = 2 * n ; int min_time = 0 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( isPossible ( box , truck , n , m , mid ) ) { min_time = mid ; h = mid - 1 ; } else l = mid + 1 ; } return min_time ; }
bool isPossible ( int arr [ ] , int n , int dist , int k ) { int req = 0 ; int curr = 0 ; int prev = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( curr != n && arr [ curr ] - arr [ prev ] <= dist ) curr ++ ; req ++ ; if ( curr == n ) break ; prev = curr - 1 ; } if ( curr != n ) return false ; if ( req <= k ) return true ; return false ; }
int minDistance ( int arr [ ] , int n , int k ) { int l = 0 ; int h = arr [ n - 1 ] ; int ans = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( isPossible ( arr , n , m , k ) ) { ans = m ; h = m - 1 ; } else l = m + 1 ; } return ans ; }
int getKthElement ( int n , int k , int L [ ] , int R [ ] ) { int l = 1 ; int h = n ; int total [ n + 1 ] ; total [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total [ i + 1 ] = total [ i ] + ( R [ i ] - L [ i ] ) + 1 ; } int index = -1 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( total [ m ] > k ) { index = m ; h = m - 1 ; } else if ( total [ m ] < k ) l = m + 1 ; else { index = m ; break ; } } l = L [ index - 1 ] ; h = R [ index - 1 ] ; int x = k - total [ index - 1 ] ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( m - L [ index - 1 ] ) + 1 == x ) { return m ; } else if ( ( m - L [ index - 1 ] ) + 1 > x ) h = m - 1 ; else l = m + 1 ; } }
int MinimumX ( int a , int b , int c , int k ) { int x = INT_MAX ; if ( k <= c ) return 0 ; int h = k - c ; int l = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; }
void preCalculate ( int binary [ ] , int n , pair < int , int > left [ ] ) { int count1 = 0 , count0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] . first = count1 ; left [ i ] . second = count0 ; if ( binary [ i ] ) count1 ++ ; else count0 ++ ; } }
int findMissing ( int arr [ ] , int n ) { int l = 0 , h = n - 1 ; int mid ; while ( h > l ) { mid = l + ( h - l ) / 2 ; if ( arr [ mid ] - mid == arr [ 0 ] ) { if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) return arr [ mid ] + 1 ; else { l = mid + 1 ; } } else { if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) return arr [ mid ] - 1 ; else { h = mid - 1 ; } } } return -1 ; }
int maxSum ( int arr [ ] , int n , int K ) { int maximum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { int sumk = 0 ; for ( int j = i ; j < n ; j += K ) sumk = sumk + arr [ j ] ; maximum = max ( maximum , sumk ) ; } return maximum ; }
int operations ( int op [ ] , int n , int k ) { int i , count = 0 ; int nVal = 0 ; int minimum = INT_MAX ; for ( i = 0 ; i < n ; i ++ ) { nVal += op [ i ] ; minimum = min ( minimum , nVal ) ; if ( ( k + nVal ) <= 0 ) return ( i + 1 ) ; } if ( nVal >= 0 ) return -1 ; int times = ( k - abs ( minimum ) ) / abs ( nVal ) ; k = ( k - ( times * abs ( nVal ) ) ) ; count = ( times * n ) ; while ( k > 0 ) { for ( i = 0 ; i < n ; i ++ ) { k = k + op [ i ] ; count ++ ; if ( k <= 0 ) break ; } } return count ; }
int findMax ( int arr [ ] , int low , int high ) { if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid == 0 && arr [ mid ] > arr [ mid + 1 ] ) { return arr [ mid ] ; } if ( mid < high && arr [ mid + 1 ] < arr [ mid ] && mid > 0 && arr [ mid ] > arr [ mid - 1 ] ) { return arr [ mid ] ; } if ( arr [ low ] > arr [ mid ] ) { return findMax ( arr , low , mid - 1 ) ; } else { return findMax ( arr , mid + 1 , high ) ; } }
void cal_prefix ( int n , int arr [ ] ) { int i , j ; for ( i = 0 ; i < n ; i ++ ) ar [ i + 1 ] = arr [ i ] ; for ( i = 1 ; i <= 1000 ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) prefix [ i ] [ j ] = 0 ; for ( j = 1 ; j <= n ; j ++ ) { prefix [ i ] [ j ] = prefix [ i ] [ j - 1 ] + ( int ) ( ar [ j ] <= i ? 1 : 0 ) ; } } }
int ksub ( int l , int r , int n , int k ) { int lo , hi , mid ; lo = 1 ; hi = 1000 ; while ( lo + 1 < hi ) { mid = ( lo + hi ) / 2 ; if ( prefix [ mid ] [ r ] - prefix [ mid ] [ l - 1 ] >= k ) hi = mid ; else lo = mid + 1 ; } if ( prefix [ lo ] [ r ] - prefix [ lo ] [ l - 1 ] >= k ) hi = lo ; return hi ; }
int binary ( int arr [ ] , int v ) { int index = lookup_table [ 0 ] - 1 ; int co = 0 ; while ( lookup_table [ co ] != 0 ) { if ( v == arr [ index ] ) return index ; else if ( v < arr [ index ] ) index -= lookup_table [ ++ co ] ; else index += lookup_table [ ++ co ] ; } }
int countPairs ( string s1 , int n1 , string s2 , int n2 ) { int freq1 [ 26 ] = { 0 } ; int freq2 [ 26 ] = { 0 } ; int i , count = 0 ; for ( i = 0 ; i < n1 ; i ++ ) freq1 [ s1 [ i ] - 'a' ] ++ ; for ( i = 0 ; i < n2 ; i ++ ) freq2 [ s2 [ i ] - 'a' ] ++ ; for ( i = 0 ; i < 26 ; i ++ ) count += ( min ( freq1 [ i ] , freq2 [ i ] ) ) ; return count ; }
int findSmallestX ( int Y ) { int low = 0 , high = 5 * Y ; int N = 0 ; while ( low <= high ) { int mid = ( high + low ) / 2 ; if ( countFactor ( 5 , mid ) < Y ) { low = mid + 1 ; } else { N = mid ; high = mid - 1 ; } } return N ; }
void findpair ( int l , int r ) { int ans1 = l ; int ans2 = 2 * l ; cout << ans1 << ", " << ans2 << endl ; }
bool check ( int arr [ ] , int N , int K ) { set < int > unique ; for ( int i = 0 ; i < N ; i ++ ) unique . insert ( arr [ i ] ) ; if ( unique . size ( ) == K ) return true ; return false ; }
int squareSum ( int N ) { int sum = ( int ) ( N * ( N + 1 ) * ( 2 * N + 1 ) ) / 6 ; return sum ; }
int findMaxN ( int X ) { int N = sqrt ( X ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( squareSum ( i ) > X ) return i - 1 ; } return -1L ; }
int findMaxN ( int X ) { int low = 1 , high = 100000 ; int N = 0 ; while ( low <= high ) { int mid = ( high + low ) / 2 ; if ( squareSum ( mid ) <= X ) { N = mid ; low = mid + 1 ; } else high = mid - 1 ; } return N ; }
int findNumber ( pair < int , int > a [ ] , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) { if ( K >= a [ i ] . first && K <= a [ i ] . second ) return i ; } return -1 ; }
int findNumber ( pair < int , int > a [ ] , int n , int K ) { int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( K >= a [ mid ] . first && K <= a [ mid ] . second ) return mid ; else if ( K < a [ mid ] . first ) high = mid - 1 ; else low = mid + 1 ; } return -1 ; }
void prefixSum ( int * p_arr , int * arr , int n ) { p_arr [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) p_arr [ i ] = arr [ i ] + p_arr [ i - 1 ] ; }
void canDivide ( int * p_arr , int n , unordered_set < int > & q , int l , int r ) { int sum ; if ( l == 0 ) sum = p_arr [ r ] ; else sum = p_arr [ r ] - p_arr [ l - 1 ] ; if ( sum % 2 == 1 ) { cout << "No" << endl ; return ; } int beg = 0 ; if ( l != 0 ) beg = p_arr [ l - 1 ] ; if ( q . find ( beg + sum / 2 ) != q . end ( ) ) cout << "Yes" << endl ; else cout << "No" << endl ; }
int findRing ( int arr [ ] [ n ] , int x ) { if ( arr [ 0 ] [ 0 ] > x ) return -1 ; int l = 0 , r = ( n + 1 ) / 2 - 1 ; if ( n % 2 == 1 && arr [ r ] [ r ] < x ) return -1 ; if ( n % 2 == 0 && arr [ r + 1 ] [ r ] < x ) return -1 ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( arr [ mid ] [ mid ] <= x ) if ( mid == ( n + 1 ) / 2 - 1 arr [ mid + 1 ] [ mid + 1 ] > x ) return mid ; else l = mid + 1 ; else r = mid - 1 ; } return r ; }
int binarySearchRowInc ( int arr [ ] [ n ] , int row , int l , int r , int x ) { while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( arr [ row ] [ mid ] == x ) return mid ; if ( arr [ row ] [ mid ] < x ) l = mid + 1 ; else r = mid - 1 ; } return -1 ; }
int binarySearchColumnInc ( int arr [ ] [ n ] , int col , int t , int b , int x ) { while ( t <= b ) { int mid = ( t + b ) / 2 ; if ( arr [ mid ] [ col ] == x ) return mid ; if ( arr [ mid ] [ col ] < x ) t = mid + 1 ; else b = mid - 1 ; } return -1 ; }
int binarySearchRowDec ( int arr [ ] [ n ] , int row , int l , int r , int x ) { while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( arr [ row ] [ mid ] == x ) return mid ; if ( arr [ row ] [ mid ] < x ) r = mid - 1 ; else l = mid + 1 ; } return -1 ; }
int binarySearchColumnDec ( int arr [ ] [ n ] , int col , int t , int b , int x ) { while ( t <= b ) { int mid = ( t + b ) / 2 ; if ( arr [ mid ] [ col ] == x ) return mid ; if ( arr [ mid ] [ col ] < x ) b = mid - 1 ; else t = mid + 1 ; } return -1 ; }
int minIndex ( int arr [ ] , int n , int pos ) { int num = arr [ pos ] ; int i = pos - 1 ; while ( i >= 0 ) { if ( arr [ i ] != num ) break ; i -- ; } return i + 1 ; }
int minIndex ( int arr [ ] , int pos ) { int low = 0 ; int high = pos ; int i = pos ; while ( low < high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] != arr [ pos ] ) { low = mid + 1 ; } else { high = mid - 1 ; i = mid ; if ( mid > 0 && arr [ mid - 1 ] != arr [ pos ] ) { break ; } } } return arr [ low ] == arr [ pos ] ? low : i ; }
int findAnswer ( string str1 , string str2 , int n ) { int l , r ; int ans = 2 ; for ( int i = 0 ; i < n ; ++ i ) { if ( str1 [ i ] != str2 [ i ] ) { l = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str1 [ i ] != str2 [ i ] ) { r = i ; break ; } } if ( r < l ) return 26 * ( n + 1 ) ; else if ( l == r ) return ans ; else { for ( int i = l + 1 ; i <= r ; i ++ ) { if ( str1 [ i ] != str2 [ i - 1 ] ) { ans -- ; break ; } } for ( int i = l + 1 ; i <= r ; i ++ ) { if ( str1 [ i - 1 ] != str2 [ i ] ) { ans -- ; break ; } } return ans ; } }
int ternarySearch ( int l , int r , int key , int ar [ ] ) { if ( r >= l ) { int mid1 = l + ( r - l ) / 3 ; int mid2 = r - ( r - l ) / 3 ; if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; } if ( key < ar [ mid1 ] ) { return ternarySearch ( l , mid1 - 1 , key , ar ) ; } else if ( key > ar [ mid2 ] ) { return ternarySearch ( mid2 + 1 , r , key , ar ) ; } else { return ternarySearch ( mid1 + 1 , mid2 - 1 , key , ar ) ; } } return -1 ; }
int ternarySearch ( int l , int r , int key , int ar [ ] ) { while ( r >= l ) { int mid1 = l + ( r - l ) / 3 ; int mid2 = r - ( r - l ) / 3 ; if ( ar [ mid1 ] == key ) { return mid1 ; } if ( ar [ mid2 ] == key ) { return mid2 ; } if ( key < ar [ mid1 ] ) { r = mid1 - 1 ; } else if ( key > ar [ mid2 ] ) { l = mid2 + 1 ; } else { l = mid1 + 1 ; r = mid2 - 1 ; } } return -1 ; }
int countSubArrays ( const int * arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = 0 ; for ( int k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; }
void build ( int * arr , int node , int start , int end ) { if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } int mid = ( start + end ) >> 1 ; build ( arr , 2 * node , start , mid ) ; build ( arr , 2 * node + 1 , mid + 1 , end ) ; tree [ node ] = tree [ 2 * node ] | tree [ 2 * node + 1 ] ; }
int query ( int node , int start , int end , int l , int r ) { if ( start > end start > r end < l ) { return 0 ; } if ( start >= l && end <= r ) { return tree [ node ] ; } int mid = ( start + end ) >> 1 ; int q1 = query ( 2 * node , start , mid , l , r ) ; int q2 = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return q1 | q2 ; }
int countSubArrays ( int arr [ ] , int n , int K ) { build ( arr , 1 , 0 , n - 1 ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = query ( 1 , 0 , n - 1 , i , j ) ; if ( bitwise_or >= K ) count ++ ; } } return count ; }
void build ( int * arr , int node , int start , int end ) { if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } int mid = ( start + end ) >> 1 ; build ( arr , 2 * node , start , mid ) ; build ( arr , 2 * node + 1 , mid + 1 , end ) ; tree [ node ] = tree [ 2 * node ] | tree [ 2 * node + 1 ] ; }
int query ( int node , int start , int end , int l , int r ) { if ( start > end start > r end < l ) { return 0 ; } if ( start >= l && end <= r ) { return tree [ node ] ; } int mid = ( start + end ) >> 1 ; int q1 = query ( 2 * node , start , mid , l , r ) ; int q2 = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return q1 | q2 ; }
int countSubArrays ( const int * arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int low = i , high = n - 1 , index = INT_MAX ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( query ( 1 , 0 , n - 1 , i , mid ) >= K ) { index = min ( index , mid ) ; high = mid - 1 ; } else { low = mid + 1 ; } } if ( index != INT_MAX ) { count += n - index ; } } return count ; }
int max_min ( int a [ ] , int n ) { sort ( a , a + n ) ; return min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; }
int max_min ( int a [ ] , int n ) { if ( n <= 1 ) return INT_MAX ; int f_min = a [ 0 ] , s_min = INT_MAX ; int f_max = a [ 0 ] , s_max = INT_MIN ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= f_min ) { s_min = f_min ; f_min = a [ i ] ; } else if ( a [ i ] < s_min ) { s_min = a [ i ] ; } if ( a [ i ] >= f_max ) { s_max = f_max ; f_max = a [ i ] ; } else if ( a [ i ] > s_max ) { s_max = a [ i ] ; } } return min ( ( f_max - s_min ) , ( s_max - f_min ) ) ; }
int findMinDifference ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int diff1 = arr [ n - 1 ] - arr [ 1 ] ; int diff2 = arr [ n - 2 ] - arr [ 0 ] ; return min ( diff1 , diff2 ) ; }
int findMinDifference ( int arr [ ] , int n ) { int min__ , secondMin , max__ , secondMax ; min__ = secondMax = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 0 ] : arr [ 1 ] ; max__ = secondMin = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 1 ] : arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > max__ ) { secondMax = max__ ; max__ = arr [ i ] ; } else if ( arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } else if ( arr [ i ] < min__ ) { secondMin = min__ ; min__ = arr [ i ] ; } else if ( arr [ i ] < secondMin ) { secondMin = arr [ i ] ; } } int diff = min ( max__ - secondMin , secondMax - min__ ) ; return diff ; }
int minimal ( int a [ ] , int n ) { int lo = 0 , hi = n - 1 ; while ( lo < hi ) { int mid = ( lo + hi ) >> 1 ; if ( a [ mid ] < a [ mid + 1 ] ) { hi = mid ; } else { lo = mid + 1 ; } } return lo ; }
int findCount ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( checkDistinct ( i ) ) count += 1 ; } return count ; }
int countDigits ( int n ) { int count = 0 ; while ( n > 0 ) { count += 1 ; n /= 10 ; } return count ; }
int findCount ( int L , int R ) { int count = 0 ; int countDigitsL = countDigits ( L ) ; int countDigitsR = countDigits ( R ) ; int firstDigitL = ( L / pow ( 10 , countDigitsL - 1 ) ) ; int firstDigitR = ( R / pow ( 10 , countDigitsR - 1 ) ) ; if ( countDigitsL < countDigitsR ) { count += ( 9 * ( countDigitsR - countDigitsL - 1 ) ) ; if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) count += ( 9 - firstDigitL + 1 ) ; else count += ( 9 - firstDigitL ) ; if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) count += firstDigitR ; else count += ( firstDigitR - 1 ) ; } else { if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) count += ( 9 - firstDigitL + 1 ) ; else count += ( 9 - firstDigitL ) ; if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) count -= ( 9 - firstDigitR ) ; else count -= ( 9 - firstDigitR + 1 ) ; } return count ; }
int LowerInsertionPoint ( int arr [ ] , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; }
int getRightMin ( int arr [ ] , int n ) { int min = arr [ 0 ] ; int rightMin = 0 ; int i = 1 ; while ( i < n ) { if ( arr [ i ] == min ) rightMin = i ; i *= 2 ; } i = rightMin + 1 ; while ( i < n && arr [ i ] == min ) { rightMin = i ; i ++ ; } return rightMin ; }
int getLeftMax ( int arr [ ] , int n ) { int max = arr [ n - 1 ] ; int leftMax = n - 1 ; int i = n - 2 ; while ( i > 0 ) { if ( arr [ i ] == max ) leftMax = i ; i /= 2 ; } i = leftMax - 1 ; while ( i >= 0 && arr [ i ] == max ) { leftMax = i ; i -- ; } return leftMax ; }
void SieveOfEratosthenes ( ) { bool isPrime [ MAX ] ; memset ( isPrime , 1 , sizeof ( isPrime ) ) ; isPrime [ 0 ] = isPrime [ 1 ] = 0 ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * 2 ; j < MAX ; j += i ) isPrime [ j ] = 0 ; } } for ( int i = 1 ; i < MAX ; i ++ ) { primeUpto [ i ] = primeUpto [ i - 1 ] ; if ( isPrime [ i ] ) primeUpto [ i ] ++ ; } }
int countOfNumbers ( int N , int K ) { SieveOfEratosthenes ( ) ; int low = 1 , high = N , ans = 0 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( mid - primeUpto [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ( ans ? N - ans + 1 : 0 ) ; }
int minIndex ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( 2 * arr [ i ] == sum ) return ( i + 1 ) ; } return -1 ; }
int smallest_pair ( int a [ ] , int n ) { int min = INT_MAX , secondMin = INT_MAX ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] < min ) { secondMin = min ; min = a [ j ] ; } else if ( ( a [ j ] < secondMin ) && a [ j ] != min ) secondMin = a [ j ] ; } return ( secondMin + min ) ; }
int checkSorted ( int n , int arr [ ] ) { int first = 0 , second = 0 ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { count ++ ; if ( first == 0 ) first = i ; else second = i ; } } if ( count > 2 ) return false ; if ( count == 0 ) return true ; if ( count == 2 ) swap ( arr [ first - 1 ] , arr [ second ] ) ; else if ( count == 1 ) swap ( arr [ first - 1 ] , arr [ first ] ) ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] < arr [ i - 1 ] ) return false ; return true ; }
int countWays ( int arr [ ] , int n ) { int max_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) max_val = max ( max_val , arr [ i ] ) ; int freq [ max_val + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; ans += freq [ 0 ] * ( freq [ 0 ] - 1 ) * ( freq [ 0 ] - 2 ) / 6 ; for ( int i = 1 ; i <= max_val ; i ++ ) ans += freq [ 0 ] * freq [ i ] * ( freq [ i ] - 1 ) / 2 ; for ( int i = 1 ; 2 * i <= max_val ; i ++ ) ans += freq [ i ] * ( freq [ i ] - 1 ) / 2 * freq [ 2 * i ] ; for ( int i = 1 ; i <= max_val ; i ++ ) { for ( int j = i + 1 ; i + j <= max_val ; j ++ ) ans += freq [ i ] * freq [ j ] * freq [ i + j ] ; } return ans ; }
bool checkIndices ( int Arr [ ] , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] != Arr [ j ] ) { if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) return true ; } } } return false ; }
int LongestSubarray ( int arr [ ] , int n , int k ) { int count = 1 ; int max_length = 1 ; int prev_mod = arr [ 0 ] % k ; for ( int i = 1 ; i < n ; i ++ ) { int curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return max ( max_length , count ) ; }
ll int getCount ( vector < ll int > v , int n ) { sort ( ( v ) . begin ( ) , ( v ) . end ( ) ) ; ll int cnt = 0 ; for ( ll int i = 0 ; i < n ; i ++ ) { ll int tmp = v . end ( ) - 1 - upper_bound ( ( v ) . begin ( ) , ( v ) . end ( ) , v [ i ] - 1 ) ; if ( tmp == v [ i ] ) cnt ++ ; } return cnt ; }
bool binarySearch1D ( int arr [ ] , int K ) { int low = 0 ; int high = N - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == K ) return true ; if ( arr [ mid ] < K ) low = mid + 1 ; else high = mid - 1 ; } return false ; }
bool searchMatrix ( int matrix [ M ] [ N ] , int K ) { int low = 0 ; int high = M - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( K >= matrix [ mid ] [ 0 ] && K <= matrix [ mid ] [ N - 1 ] ) return binarySearch1D ( matrix [ mid ] , K ) ; if ( K < matrix [ mid ] [ 0 ] ) high = mid - 1 ; else low = mid + 1 ; } return false ; }
int longestsubarray ( int arr [ ] , int n , int k ) { int current_count = 0 ; int max_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) current_count ++ ; else current_count = 0 ; max_count = max ( current_count , max_count ) ; } return max_count ; }
int countSegments ( int a [ ] , int n , int x ) { bool flag = false ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { flag = true ; } else { if ( flag ) count += 1 ; flag = false ; } } if ( flag ) count += 1 ; return count ; }
void findElements ( int arr [ ] , int n , int l , int r ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; ++ i ) { mp [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n ; ++ i ) { if ( l <= mp [ arr [ i ] ] && mp [ arr [ i ] <= r ] ) { cout << arr [ i ] << " " ; } } }
void findElementsAfterDel ( int arr [ ] , int m , int del [ ] , int n , int k ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; ++ i ) { mp [ del [ i ] ] ++ ; } priority_queue < int , vector < int > , greater < int > > heap ; for ( int i = 0 ; i < m ; ++ i ) { if ( mp . find ( arr [ i ] ) != mp . end ( ) ) { mp [ arr [ i ] ] -- ; if ( mp [ arr [ i ] ] == 0 ) mp . erase ( arr [ i ] ) ; } else heap . push ( arr [ i ] ) ; } for ( int i = 0 ; i < k ; ++ i ) { cout << heap . top ( ) << " " ; heap . pop ( ) ; } }
void removeElements ( int arr [ ] , int n , int k ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; ++ i ) { mp [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n ; ++ i ) { if ( mp [ arr [ i ] ] >= k ) { cout << arr [ i ] << " " ; } } }
bool check ( string s ) { for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return true ; return false ; }
void RemoveElements ( int arr [ ] , int n , int k ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; ++ i ) { mp [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n ; ++ i ) { if ( mp [ arr [ i ] ] <= k ) { cout << arr [ i ] << " " ; } } }
int findSmallestAfterDel ( int arr [ ] , int m , int del [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; ++ i ) { mp [ del [ i ] ] ++ ; } int smallestElement = INT_MAX ; for ( int i = 0 ; i < m ; ++ i ) { if ( mp . find ( arr [ i ] ) != mp . end ( ) ) { mp [ arr [ i ] ] -- ; if ( mp [ arr [ i ] ] == 0 ) mp . erase ( arr [ i ] ) ; } else smallestElement = min ( smallestElement , arr [ i ] ) ; } return smallestElement ; }
int findlargestAfterDel ( int arr [ ] , int m , int del [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; ++ i ) { mp [ del [ i ] ] ++ ; } int largestElement = INT_MIN ; for ( int i = 0 ; i < m ; ++ i ) { if ( mp . find ( arr [ i ] ) != mp . end ( ) ) { mp [ arr [ i ] ] -- ; if ( mp [ arr [ i ] ] == 0 ) mp . erase ( arr [ i ] ) ; } else largestElement = max ( largestElement , arr [ i ] ) ; } return largestElement ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int divTermCount ( int a , int b , int lcm , int num ) { return num / a + num / b - num / lcm ; }
int findNthTerm ( int a , int b , int n ) { int low = 1 , high = INT_MAX , mid ; int lcm = ( a * b ) / gcd ( a , b ) ; while ( low < high ) { mid = low + ( high - low ) / 2 ; if ( divTermCount ( a , b , lcm , mid ) < n ) low = mid + 1 ; else high = mid ; } return low ; }
int LongestFibSubseq ( int A [ ] , int n ) { unordered_set < int > S ( A , A + n ) ; int maxLen = 0 , x , y ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { x = A [ j ] ; y = A [ i ] + A [ j ] ; int length = 2 ; while ( S . find ( y ) != S . end ( ) ) { int z = x + y ; x = y ; y = z ; maxLen = max ( maxLen , ++ length ) ; } } } return maxLen >= 3 ? maxLen : 0 ; }
int numberOfElements ( int height [ ] , int n ) { int max_so_far = 0 ; int coun = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( height [ i ] > max_so_far ) { max_so_far = height [ i ] ; coun ++ ; } } return coun ; }
bool isPossible ( int A [ ] , int n , int H , int K ) { int time = 0 ; for ( int i = 0 ; i < n ; ++ i ) time += ( A [ i ] - 1 ) / K + 1 ; return time <= H ; }
int minJobSpeed ( int A [ ] , int n , int H ) { if ( H < n ) return -1 ; int * max = max_element ( A , A + n ) ; int lo = 1 , hi = * max ; while ( lo < hi ) { int mi = lo + ( hi - lo ) / 2 ; if ( ! isPossible ( A , n , H , mi ) ) lo = mi + 1 ; else hi = mi ; } return lo ; }
int kthSmallestLargest ( int * arr , int n , int k ) { int max_val = * max_element ( arr , arr + n ) ; int hash [ max_val + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) hash [ arr [ i ] ] ++ ; int count = 0 ; for ( int i = 0 ; i <= max_val ; i ++ ) { while ( hash [ i ] > 0 ) { count ++ ; if ( count == k ) return i ; hash [ i ] -- ; } } return -1 ; }
int countAnomalies ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && abs ( arr [ i ] - arr [ j ] ) <= k ) break ; if ( j == n ) res ++ ; } return res ; }
int countAnomalies ( int a [ ] , int n , int k ) { sort ( a , a + n ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int * u = upper_bound ( a , a + n , a [ i ] ) ; if ( u != a + n && ( ( * u ) - a [ i ] ) <= k ) continue ; int * s = lower_bound ( a , a + n , a [ i ] ) ; if ( u - s > 1 ) continue ; if ( s != a && ( * ( s - 1 ) - a [ i ] ) <= k ) continue ; res ++ ; } return res ; }
void solve ( int arr [ ] , int n , int k ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { m [ arr [ i ] ] ++ ; } int max = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( m [ arr [ i ] ] == k && max == INT_MIN ) { max = arr [ i ] ; } else if ( m [ arr [ i ] ] == k && max < arr [ i ] ) { max = arr [ i ] ; } } if ( max == INT_MIN ) cout << "No such element" << endl ; else cout << max << endl ; }
int majorityInMatrix ( int arr [ N ] [ M ] ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { mp [ arr [ i ] [ j ] ] ++ ; } } int countMajority = 0 ; for ( auto itr = mp . begin ( ) ; itr != mp . end ( ) ; itr ++ ) { if ( itr -> second >= ( ( N * M ) / 2 ) ) { countMajority ++ ; } } return countMajority ; }
int getMin ( int arr [ ] , int n ) { int res = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) res = min ( res , arr [ i ] ) ; return res ; }
int findSum ( int arr [ ] , int n ) { int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; return min + max ; }
int findProduct ( int arr [ ] , int n ) { int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; return min * max ; }
void countEle ( stack < int > & s , int a [ ] , int N ) { unordered_map < int , bool > mp ; for ( int i = 0 ; i < N ; ++ i ) { int num = a [ i ] ; if ( mp . find ( num ) != mp . end ( ) ) cout << "0 " ; else { int cnt = 0 ; while ( s . top ( ) != num ) { mp [ s . top ( ) ] = true ; s . pop ( ) ; cnt ++ ; } s . pop ( ) ; cnt ++ ; cout << cnt << " " ; } } }
int bsearch ( vector < int > A , int key_to_search ) { int n = ( int ) A . size ( ) ; int lg = log2 ( n - 1 ) + 1 ; int pos = 0 ; for ( int i = lg ; i >= 0 ; i -- ) { if ( A [ pos ] == key_to_search ) return pos ; int new_pos = pos | ( 1 << i ) ; if ( ( new_pos < n ) && ( A [ new_pos ] <= key_to_search ) ) pos = new_pos ; } return ( ( A [ pos ] == key_to_search ) ? pos : -1 ) ; }
int colMaxDiff ( int mat [ N ] [ N ] ) { int max_diff = INT_MIN ; for ( int i = 0 ; i < N ; i ++ ) { int max_val = mat [ 0 ] [ i ] , min_val = mat [ 0 ] [ i ] ; for ( int j = 1 ; j < N ; j ++ ) { max_val = max ( max_val , mat [ j ] [ i ] ) ; min_val = min ( min_val , mat [ j ] [ i ] ) ; } max_diff = max ( max_diff , max_val - min_val ) ; } return max_diff ; }
int countChar ( string str ) { int n = str . length ( ) ; if ( n <= 2 ) return n ; int count = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( str [ i - 1 ] == str [ i + 1 ] ) count ++ ; return count ; }
float findmedian ( int a [ ] , int n1 , int b [ ] , int n2 ) { int i = 0 ; int j = 0 ; int k ; int m1 = -1 , m2 = -1 ; for ( k = 0 ; k <= ( n1 + n2 ) / 2 ; k ++ ) { if ( i < n1 && j < n2 ) { if ( a [ i ] < b [ j ] ) { m2 = m1 ; m1 = a [ i ] ; i ++ ; } else { m2 = m1 ; m1 = b [ j ] ; j ++ ; } } else if ( i == n1 ) { m2 = m1 ; m1 = b [ j ] ; j ++ ; } else if ( j == n2 ) { m2 = m1 ; m1 = a [ i ] ; i ++ ; } } if ( ( n1 + n2 ) % 2 == 0 ) return ( m1 + m2 ) * 1.0 / 2 ; return m1 ; }
int search ( int ar [ ] , int size ) { int a = 0 , b = size - 1 ; int mid ; while ( ( b - a ) > 1 ) { mid = ( a + b ) / 2 ; if ( ( ar [ a ] - a ) != ( ar [ mid ] - mid ) ) b = mid ; else if ( ( ar [ b ] - b ) != ( ar [ mid ] - mid ) ) a = mid ; } return ( ar [ a ] + 1 ) ; }
int deleteElement ( int A [ ] , int L , int R , int N ) { int i , j = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i <= L i >= R ) { A [ j ] = A [ i ] ; j ++ ; } } return j ; }
bool search ( int arr [ ] , int n , int x ) { int res = -1 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res = i ; if ( res == -1 ) return false ; int temp = arr [ res ] ; for ( int i = res ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = temp ; return true ; }
float kPresentProbability ( int a [ ] , int n , int k ) { float count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == k ) count ++ ; return count / n ; }
int binarySearch ( int * searchSpace , int s , int e , int num ) { int ans ; while ( s <= e ) { int mid = ( s + e ) / 2 ; if ( searchSpace [ mid ] >= num ) { ans = mid ; e = mid - 1 ; } else s = mid + 1 ; } return ans ; }
int longestSubArr ( int * arr , int n ) { int searchSpace [ n ] ; int index [ n ] ; int j = 0 ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( j == 0 or searchSpace [ j - 1 ] < arr [ i ] ) { searchSpace [ j ] = arr [ i ] ; index [ j ] = i ; j ++ ; } int idx = binarySearch ( searchSpace , 0 , j - 1 , arr [ i ] ) ; ans = max ( ans , i - index [ idx ] + 1 ) ; } return ans ; }
int findmissing ( int ar [ ] , int N ) { int l = 0 , r = N - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( ar [ mid ] != mid + 1 && ar [ mid - 1 ] == mid ) return mid + 1 ; if ( ar [ mid ] != mid + 1 ) r = mid - 1 ; else l = mid + 1 ; } return -1 ; }
int findFirst ( int arr [ ] , int n , int x ) { sort ( arr , arr + n ) ; int * ptr = lower_bound ( arr , arr + n , x ) ; return ( * ptr != x ) ? -1 : ( ptr - arr ) ; }
int findFirst ( int arr [ ] , int n , int x ) { int count = 0 ; bool isX = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) isX = true ; else if ( arr [ i ] < x ) count ++ ; } return ( isX == false ) ? -1 : count ; }
int findDuplicate ( int arr [ ] ) { int slow = arr [ 0 ] ; int fast = arr [ 0 ] ; do { slow = arr [ slow ] ; fast = arr [ arr [ fast ] ] ; } while ( slow != fast ) ; int ptr1 = arr [ 0 ] ; int ptr2 = slow ; while ( ptr1 != ptr2 ) { ptr1 = arr [ ptr1 ] ; ptr2 = arr [ ptr2 ] ; } return ptr1 ; }
int isSafe ( int x , int y , int sol [ N ] [ N ] ) { return ( x >= 0 && x < N && y >= 0 && y < N && sol [ x ] [ y ] == -1 ) ; }
void prevGreater ( int arr [ ] , int n ) { cout << "-1, " ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { cout << arr [ j ] << ", " ; break ; } } if ( j == -1 ) cout << "-1, " ; } }
void prevGreater ( int arr [ ] , int n ) { stack < int > s ; s . push ( arr [ 0 ] ) ; cout << "-1, " ; for ( int i = 1 ; i < n ; i ++ ) { while ( s . empty ( ) == false && s . top ( ) < arr [ i ] ) s . pop ( ) ; s . empty ( ) ? cout << "-1, " : cout << s . top ( ) << ", " ; s . push ( arr [ i ] ) ; } }
void printGreaterCount ( string str ) { int len = str . length ( ) , right [ len ] = { 0 } ; for ( int i = 0 ; i < len ; i ++ ) for ( int j = i + 1 ; j < len ; j ++ ) if ( str [ i ] < str [ j ] ) right [ i ] ++ ; for ( int i = 0 ; i < len ; i ++ ) cout << right [ i ] << " " ; }
void printGreaterCount ( string str ) { int len = str . length ( ) ; int ans [ len ] = { 0 } , count [ MAX_CHAR ] = { 0 } ; for ( int i = len - 1 ; i >= 0 ; i -- ) { count [ str [ i ] - 'a' ] ++ ; for ( int j = str [ i ] - 'a' + 1 ; j < MAX_CHAR ; j ++ ) ans [ i ] += count [ j ] ; } for ( int i = 0 ; i < len ; i ++ ) cout << ans [ i ] << " " ; }
int findMissingNo ( int arr [ ] , int n ) { int val ; int nextval ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= 0 arr [ i ] > n ) continue ; val = arr [ i ] ; while ( arr [ val - 1 ] != val ) { nextval = arr [ val - 1 ] ; arr [ val - 1 ] = val ; val = nextval ; if ( val <= 0 val > n ) break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != i + 1 ) { return i + 1 ; } } return n + 1 ; }
int solve ( int a [ ] , int n ) { int max1 = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; }
int solve ( int a [ ] , int n ) { int min1 = a [ 0 ] ; int max1 = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return abs ( min1 - max1 ) ; }
int maxProduct ( int arr [ ] , int n ) { if ( n < 4 ) return -1 ; int max_product = INT_MIN ; for ( int i = 0 ; i < n - 3 ; i ++ ) for ( int j = i + 1 ; j < n - 2 ; j ++ ) for ( int k = j + 1 ; k < n - 1 ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] * arr [ l ] ) ; return max_product ; }
int maxSum ( int arr [ ] , int n ) { if ( n < 2 ) return -1 ; int ans = arr [ 0 ] + arr [ 1 ] ; for ( int i = 1 ; i + 1 < n ; i ++ ) ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) ; return ans ; }
int getCount ( int M , int N ) { int count = 0 ; if ( M == 1 ) return N ; if ( N == 1 ) return M ; if ( N > M ) { for ( int i = 1 ; i <= M ; i ++ ) { int numerator = N * i - N + M - i ; int denominator = M - 1 ; if ( numerator % denominator == 0 ) { int j = numerator / denominator ; if ( j >= 1 && j <= N ) count ++ ; } } } else { for ( int j = 1 ; j <= N ; j ++ ) { int numerator = M * j - M + N - j ; int denominator = N - 1 ; if ( numerator % denominator == 0 ) { int i = numerator / denominator ; if ( i >= 1 && i <= M ) count ++ ; } } } return count ; }
int countTripletsLessThanL ( int n , int L , int * arr ) { sort ( arr , arr + n ) ; int ways = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { int mostDistantDistance = arr [ k ] - arr [ i ] ; if ( mostDistantDistance <= L ) { ways ++ ; } } } } return ways ; }
int appearsNBy3 ( int arr [ ] , int n ) { int count1 = 0 , count2 = 0 ; int first = INT_MAX , second = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( first == arr [ i ] ) count1 ++ ; else if ( second == arr [ i ] ) count2 ++ ; else if ( count1 == 0 ) { count1 ++ ; first = arr [ i ] ; } else if ( count2 == 0 ) { count2 ++ ; second = arr [ i ] ; } else { count1 -- ; count2 -- ; } } count1 = 0 ; count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == first ) count1 ++ ; else if ( arr [ i ] == second ) count2 ++ ; } if ( count1 > n / 3 ) return first ; if ( count2 > n / 3 ) return second ; return -1 ; }
int binary_lower ( int value , int arr [ ] , int n ) { int start = 0 ; int end = n - 1 ; int ans = -1 ; int mid ; while ( start <= end ) { mid = ( start + end ) / 2 ; if ( arr [ mid ] >= value ) { end = mid - 1 ; ans = mid ; } else { start = mid + 1 ; } } return ans ; }
int countTriplet ( int arr [ ] , int n , int k ) { int count = 0 ; sort ( arr , arr + n ) ; for ( int i = 2 ; i < n ; i ++ ) { int cur = binary_lower ( arr [ i ] - k , arr , n ) ; if ( cur <= i - 2 ) { count += ( ( i - cur ) * ( i - cur - 1 ) ) / 2 ; } } return count ; }
bool isSuffix ( string s1 , string s2 ) { int n1 = s1 . length ( ) , n2 = s2 . length ( ) ; if ( n1 > n2 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; }
void replaceOriginal ( string s , int n ) { string r ( n , ' ' ) ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s [ n - 1 - i ] ; if ( s [ i ] != 'a' && s [ i ] != 'e' && s [ i ] != 'i' && s [ i ] != 'o' && s [ i ] != 'u' ) { cout << r [ i ] ; } } cout << endl ; }
bool swapElement ( int arr1 [ ] , int arr2 [ ] , int n ) { int wrongIdx = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr1 [ i ] < arr1 [ i - 1 ] ) wrongIdx = i ; int maximum = INT_MIN ; int maxIdx = -1 ; bool res = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr2 [ i ] > maximum && arr2 [ i ] >= arr1 [ wrongIdx - 1 ] ) { if ( wrongIdx + 1 <= n - 1 && arr2 [ i ] <= arr1 [ wrongIdx + 1 ] ) { maximum = arr2 [ i ] ; maxIdx = i ; res = true ; } } } if ( res ) swap ( arr1 [ wrongIdx ] , arr2 [ maxIdx ] ) ; return res ; } void getSortedArray ( int arr1 [ ] , int arr2 [ ] , int n ) { if ( swapElement ( arr1 , arr2 , n ) ) for ( int i = 0 ; i < n ; i ++ ) cout << arr1 [ i ] << " " ; else cout << "Not Possible" << endl ; } int main ( ) { int arr1 [ ] = { 1 , 3 , 7 , 4 , 10 } ; int arr2 [ ] = { 2 , 1 , 6 , 8 , 9 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; getSortedArray ( arr1 , arr2 , n ) ; }
bool ElementsCalculationFunc ( int pre [ ] , int maxx [ ] , int x , int k , int n ) { for ( int i = 0 , j = x ; j <= n ; j ++ , i ++ ) { if ( x * maxx [ j ] - ( pre [ j ] - pre [ i ] ) <= k ) return true ; } return false ; }
int costToBalance ( string s ) { if ( s . length ( ) == 0 ) cout << 0 << endl ; int ans = 0 ; int o = 0 , c = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '(' ) o ++ ; if ( s [ i ] == ')' ) c ++ ; } if ( o != c ) return -1 ; int a [ s . size ( ) ] ; if ( s [ 0 ] == '(' ) a [ 0 ] = 1 ; else a [ 0 ] = -1 ; if ( a [ 0 ] < 0 ) ans += abs ( a [ 0 ] ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '(' ) a [ i ] = a [ i - 1 ] + 1 ; else a [ i ] = a [ i - 1 ] - 1 ; if ( a [ i ] < 0 ) ans += abs ( a [ i ] ) ; } return ans ; }
bool checkIfAllTogether ( string s , char c ) { bool oneSeen = false ; int i = 0 , n = s . length ( ) ; while ( i < n ) { if ( s [ i ] == c ) { if ( oneSeen == true ) return false ; while ( i < n && s [ i ] == c ) i ++ ; oneSeen = true ; } else i ++ ; } return true ; }
int f ( int n ) { return n * ( 2 * n * n - 1 ) ; }
bool binarySearch ( int low , int high , int x ) { while ( low <= high ) { long long mid = ( low + high ) / 2 ; if ( f ( mid ) < x ) low = mid + 1 ; else if ( f ( mid ) > x ) high = mid - 1 ; else return true ; } return false ; }
bool isStellaOctangula ( int x ) { if ( x == 0 ) return true ; int i = 1 ; while ( f ( i ) < x ) i = i * 2 ; if ( f ( i ) == x ) return true ; return binarySearch ( i / 2 , i , x ) ; }
bool search ( int arr [ ] , int n , int x ) { int front = 0 , back = n - 1 ; while ( front <= back ) { if ( arr [ front ] == x arr [ back ] == x ) return true ; front ++ ; back -- ; } return false ; }
bool isSafe ( bool graph [ V ] [ V ] , int color [ ] ) { for ( int i = 0 ; i < V ; i ++ ) for ( int j = i + 1 ; j < V ; j ++ ) if ( graph [ i ] [ j ] && color [ j ] == color [ i ] ) return false ; return true ; }
bool graphColoring ( bool graph [ V ] [ V ] , int m , int i , int color [ V ] ) { if ( i == V ) { if ( isSafe ( graph , color ) ) { printSolution ( color ) ; return true ; } return false ; } for ( int j = 1 ; j <= m ; j ++ ) { color [ i ] = j ; if ( graphColoring ( graph , m , i + 1 , color ) ) return true ; color [ i ] = 0 ; } return false ; }
int getGreatestSum ( int a [ ] [ N ] ) { int prev_max = 0 ; for ( int j = 0 ; j < N ; j ++ ) if ( prev_max < a [ N - 1 ] [ j ] ) prev_max = a [ N - 1 ] [ j ] ; int sum = prev_max ; for ( int i = N - 2 ; i >= 0 ; i -- ) { int curr_max = INT_MIN ; for ( int j = 0 ; j < N ; j ++ ) if ( prev_max > a [ i ] [ j ] && a [ i ] [ j ] > curr_max ) curr_max = a [ i ] [ j ] ; if ( curr_max == INT_MIN ) return -1 ; prev_max = curr_max ; sum += prev_max ; } return sum ; }
int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
int missingNum ( int arr [ ] , int n ) { int minvalue = * min_element ( arr , arr + n ) ; int xornum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xornum ^= ( minvalue ) ^ arr [ i ] ; minvalue ++ ; } return xornum ^ minvalue ; }
void findElement ( int n , int k ) { int left = 1 ; int right = pow ( 2 , n ) - 1 ; while ( 1 ) { int mid = ( left + right ) / 2 ; if ( k == mid ) { cout << ans << endl ; break ; } ans -- ; if ( k < mid ) right = mid - 1 ; else left = mid + 1 ; } }
int firstCommon ( struct Node * head1 , struct Node * head2 ) { for ( ; head1 != NULL ; head1 = head1 -> next ) for ( Node * p = head2 ; p != NULL ; p = p -> next ) if ( p -> data == head1 -> data ) return head1 -> data ; return 0 ; }
int findmin ( Point p [ ] , int n ) { int a = 0 , b = 0 , c = 0 , d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] . x <= 0 ) a ++ ; else if ( p [ i ] . x >= 0 ) b ++ ; if ( p [ i ] . y >= 0 ) c ++ ; else if ( p [ i ] . y <= 0 ) d ++ ; } return min ( { a , b , c , d } ) ; }
int findLastIndex ( string & str , char x ) { int index = -1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str [ i ] == x ) index = i ; return index ; }
int findLastIndex ( string & str , char x ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) if ( str [ i ] == x ) return i ; return -1 ; }
int checkBit ( int pattern , int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( ( pattern & arr [ i ] ) == pattern ) count ++ ; return count ; }
int countMaxSumPairs ( int a [ ] , int n ) { int first = INT_MIN , second = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > first ) { second = first ; first = a [ i ] ; } else if ( a [ i ] > second && a [ i ] != first ) second = a [ i ] ; } int cnt1 = 0 , cnt2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == first ) if ( a [ i ] == second ) } if ( cnt1 == 1 ) return cnt2 ; if ( cnt1 > 1 ) return cnt1 * ( cnt1 - 1 ) / 2 ; } float findMaxSumProbability ( int a [ ] , int n ) { int total = n * ( n - 1 ) / 2 ; int max_sum_pairs = countMaxSumPairs ( a , n ) ; return ( float ) max_sum_pairs / ( float ) total ; } int main ( ) { int a [ ] = { 1 , 2 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << findMaxSumProbability ( a , n ) ; return 0 ; }
int middleOfThree ( int a , int b , int c ) { int middleOfThree ( int a , int b , int c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; } int main ( ) { int a = 20 , b = 30 , c = 40 ; cout << middleOfThree ( a , b , c ) ; return 0 ; }
int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } }
int findValue ( int X , int Y , int P ) { if ( P % 2 == 0 ) return ( max ( X , Y ) / min ( X , Y ) ) ; else return ( max ( 2 * X , Y ) / min ( 2 * X , Y ) ) ; }
int countMaxSetBits ( int left , int right ) { int max_count = -1 , num ; for ( int i = left ; i <= right ; ++ i ) { int temp = i , cnt = 0 ; while ( temp ) { if ( temp & 1 ) ++ cnt ; temp >>= 1 ; } if ( cnt > max_count ) { max_count = cnt ; num = i ; } } return num ; }
int sum ( int arr [ ] , int from , int to ) { int total = 0 ; for ( int i = from ; i <= to ; i ++ ) total += arr [ i ] ; return total ; }
int findMax ( int arr [ ] , int n , int k ) { int dp [ k + 1 ] [ n + 1 ] = { 0 } ; for ( int i = 1 ; i <= n ; i ++ ) dp [ 1 ] [ i ] = sum ( arr , 0 , i - 1 ) ; for ( int i = 1 ; i <= k ; i ++ ) dp [ i ] [ 1 ] = arr [ 0 ] ; for ( int j = 2 ; j <= n ; j ++ ) { int best = INT_MAX ; for ( int p = 1 ; p <= j ; p ++ ) best = min ( best , max ( dp [ i - 1 ] [ p ] , sum ( arr , p , j - 1 ) ) ) ; dp [ i ] [ j ] = best ; } }
int findFloor ( Node * root , int key ) { Node * curr = root , * ans = NULL ; while ( curr ) { if ( curr -> key <= key ) { ans = curr ; curr = curr -> right ; } else curr = curr -> left ; } if ( ans ) return ans -> key ; return -1 ; }
int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n ; if ( sum == s ) return n ; } return -1 ; }
ll int isvalid ( ll int s ) { float k = ( -1 + sqrt ( 1 + 8 * s ) ) / 2 ; if ( ceil ( k ) == floor ( k ) ) return k ; else return -1 ; }
int calcSafe ( int pos ) { int j = pos % 10 ; int i = pos / 10 ; int dis_11 = min ( abs ( 1 - i ) , abs ( 1 - j ) ) ; int dis_18 = min ( abs ( 1 - i ) , abs ( 8 - j ) ) ; int dis_81 = min ( abs ( 8 - i ) , abs ( 1 - j ) ) ; int dis_88 = min ( abs ( 8 - i ) , abs ( 8 - j ) ) ; int sum = dis_11 + dis_18 + dis_81 + dis_88 + 1 ; return ( 64 - sum ) ; }
int countCrossLine ( int arr [ ] , int n ) { int count_crossline = 0 ; int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; count_crossline ++ ; } arr [ j + 1 ] = key ; } return count_crossline ; }
int getCount ( int arr [ ] , int n , int num1 , int num2 ) { int i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; int j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; }
bool check_elements ( int arr [ ] , int n , int A , int B ) { int range = B - A ; for ( int i = 0 ; i < n ; i ++ ) { if ( abs ( arr [ i ] ) >= A && abs ( arr [ i ] ) <= B ) { int z = abs ( arr [ i ] ) - A ; if ( arr [ z ] > 0 ) { arr [ z ] = arr [ z ] * -1 ; } } } int count = 0 ; for ( int i = 0 ; i <= range && i < n ; i ++ ) { if ( arr [ i ] > 0 ) return false ; else count ++ ; } if ( count != ( range + 1 ) ) return false ; return true ; }
int sumOfDigit ( int K ) { int sod = 0 ; while ( K ) { sod += K % 10 ; K /= 10 ; } return sod ; }
int findMinRec ( int A [ ] , int n ) { if ( n == 1 ) return A [ 0 ] ; return min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) ; }
int findMaxRec ( int A [ ] , int n ) { if ( n == 1 ) return A [ 0 ] ; return max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) ) ; }
int getRandom ( int x , int y ) { srand ( time ( NULL ) ) ; return ( x + rand ( ) % ( y - x + 1 ) ) ; }
int randomizedBinarySearch ( int arr [ ] , int l , int r , int x ) { while ( l <= r ) { int m = getRandom ( l , r ) ; if ( arr [ m ] == x ) return m ; if ( arr [ m ] < x ) l = m + 1 ; else r = m - 1 ; } return -1 ; }
int countBuildings ( int arr [ ] , int n ) { int count = 1 ; int curr_max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > curr_max arr [ i ] == curr_max ) { count ++ ; curr_max = arr [ i ] ; } } return count ; }
int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; }
int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { int index = n ; int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; }
int findPages ( int arr [ ] , int n , int m ) { long long sum = 0 ; if ( n < m ) return -1 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int start = 0 , end = sum ; int result = INT_MAX ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( isPossible ( arr , n , m , mid ) ) { result = mid ; end = mid - 1 ; } else start = mid + 1 ; } return result ; }
int minCostToMakeElementEqual ( int arr [ ] , int N ) { int low , high ; low = high = arr [ 0 ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( low > arr [ i ] ) low = arr [ i ] ; if ( high < arr [ i ] ) high = arr [ i ] ; } while ( ( high - low ) > 2 ) { int mid1 = low + ( high - low ) / 3 ; int mid2 = high - ( high - low ) / 3 ; int cost1 = computeCost ( arr , N , mid1 ) ; int cost2 = computeCost ( arr , N , mid2 ) ; if ( cost1 < cost2 ) high = mid2 ; else low = mid1 ; } return computeCost ( arr , N , ( low + high ) / 2 ) ; }
void minJumps ( int w [ ] , int l [ ] , int n ) { if ( n == 1 ) { cout << 0 ; return ; } int ans = 0 ; unordered_map < int , int > pos , jump ; unordered_map < int , bool > filled ; int a [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { pos [ w [ i ] ] = i ; filled [ i ] = true ; jump [ w [ i ] ] = l [ i ] ; a [ i ] = w [ i ] ; } sort ( a , a + n ) ; for ( int curr = 1 ; curr < n ; curr ++ ) { int currElementPos = pos [ a [ curr ] ] ; int prevElementPos = pos [ a [ curr - 1 ] ] ; if ( currElementPos > prevElementPos ) continue ; while ( currElementPos <= prevElementPos filled [ currElementPos ] ) { currElementPos += jump [ a [ curr ] ] ; ans ++ ; } pos [ a [ curr ] ] = currElementPos ; filled [ currElementPos ] = true ; } cout << ans ; }
void check ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] >= ( i - 1 ) ) { int p = arr [ i - 1 ] - ( i - 1 ) ; arr [ i ] += p ; arr [ i - 1 ] -= p ; } } for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= arr [ i - 1 ] ) { cout << "No" ; return ; } } cout << "Yes" ; }
void minimumSize ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; reverse ( arr , arr + N ) ; if ( count ( arr , arr + N , 0 ) == N ) cout << 0 ; else if ( K >= N ) cout << 1 << endl ; else cout << arr [ K ] << endl ; }
void isPossibleToSort ( int arr [ ] , int N ) { int idx = -1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == 1 && arr [ i - 1 ] == 1 ) { idx = i ; break ; } } if ( idx == -1 ) { cout << "YES" ; return ; } for ( int i = idx + 1 ; i < N ; i ++ ) { if ( arr [ i ] == 0 && arr [ i - 1 ] == 0 ) { cout << "NO" ; return ; } } cout << "YES" ; }
bool check ( int arr [ ] , int n ) { int count = 0 ; int index = -1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] ) { count ++ ; index = i ; } } if ( count > 1 ) return false ; if ( count == 0 ) return true ; if ( index == n - 1 index == 1 ) return true ; if ( arr [ index - 1 ] < arr [ index + 1 ] ) return true ; if ( index - 2 >= 0 && arr [ index - 2 ] < arr [ index ] ) return true ; if ( index < 0 ) return true ; return false ; }
string isPossibleToSort ( pair < int , int > * arr , int N ) { int group = arr [ 0 ] . second ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] . second != group ) { return "Yes" ; } } if ( isSorted ( arr , N ) ) { return "Yes" ; } else { return "No" ; } }
int maximumSum ( int arr [ ] , int S [ ] , int N , int K ) { int ans = 0 ; sort ( arr , arr + N , greater < int > ( ) ) ; for ( int i = 0 ; i < K ; i ++ ) ans += arr [ i ] ; sort ( S , S + K ) ; for ( int i = 0 ; i < K ; i ++ ) { if ( S [ i ] == 1 ) ans += arr [ i ] ; S [ i ] -- ; } int counter = K - 1 ; for ( int i = 0 ; i < K ; i ++ ) { counter = counter + S [ i ] ; if ( S [ i ] != 0 ) ans += arr [ counter ] ; } return ans ; }
int minimumDeletion ( string s , int n ) { map < char , int > countMap ; for ( int i = 0 ; i < n ; i ++ ) { countMap [ s [ i ] ] ++ ; } multiset < int > countMultiset ; for ( auto it : countMap ) { countMultiset . insert ( it . second ) ; } int ans = INT_MAX ; int i = 0 ; int m = countMultiset . size ( ) ; for ( auto j : countMultiset ) { ans = min ( ans , n - ( m - i ) * j ) ; i ++ ; } return ans ; }
void maxLenSubset ( int a [ ] , int n ) { sort ( a , a + n ) ; int index = 0 , maxlen = -1 ; int i = 0 ; while ( i < n ) { int j = i ; int len = 1 ; while ( j < n - 1 ) { if ( 2 * a [ j ] >= a [ j + 1 ] ) { len ++ ; } else break ; j ++ ; } if ( maxlen < len ) { maxlen = len ; index = i ; } j ++ ; i = j ; } i = index ; while ( maxlen > 0 ) { cout << a [ i ] << " " ; maxlen -- ; i ++ ; } }
void maximumMex ( int arr [ ] , int N ) { vector < int > ans ; sort ( arr , arr + N ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 arr [ i ] != arr [ i - 1 ] ) ans . push_back ( arr [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { if ( i > 0 && arr [ i ] == arr [ i - 1 ] ) ans . push_back ( arr [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) cout << ans [ i ] << " " ; }
void canReduceArray ( int arr [ ] , int N , int K ) { sort ( arr , arr + N , greater < int > ( ) ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] - arr [ i + 1 ] > K ) { cout << "No" ; return ; } } cout << "Yes" ; }
void mergeStrings ( string s1 , string s2 ) { int len1 = s1 . size ( ) ; int len2 = s2 . size ( ) ; int pntr1 = 0 ; int pntr2 = 0 ; string ans = "" ; while ( pntr1 < len1 && pntr2 < len2 ) { if ( s1 [ pntr1 ] < s2 [ pntr2 ] ) { ans += s1 [ pntr1 ] ; pntr1 ++ ; } else { ans += s2 [ pntr2 ] ; pntr2 ++ ; } } if ( pntr1 < len1 ) { ans += s1 . substr ( pntr1 , len1 ) ; } if ( pntr2 < len2 ) { ans += s2 . substr ( pntr2 , len2 ) ; } cout << ans ; }
vector < int > bubble_sort ( vector < int > ar ) { if ( ar . size ( ) <= 1 ) return ar ; if ( ar . size ( ) == 2 ) { if ( ar [ 0 ] < ar [ 1 ] ) return ar ; else return { ar [ 1 ] , ar [ 0 ] } ; } int a = ar [ 0 ] ; int b = ar [ 1 ] ; vector < int > bs ; for ( int i = 2 ; i < ar . size ( ) ; i ++ ) bs . push_back ( ar [ i ] ) ; vector < int > res ; if ( a < b ) { vector < int > temp1 ; temp1 . push_back ( b ) ; for ( int i = 0 ; i < bs . size ( ) ; i ++ ) temp1 . push_back ( bs [ i ] ) ; vector < int > v = bubble_sort ( temp1 ) ; v . insert ( v . begin ( ) , a ) ; res = v ; } else { vector < int > temp1 ; temp1 . push_back ( a ) ; for ( int i = 0 ; i < bs . size ( ) ; i ++ ) temp1 . push_back ( bs [ i ] ) ; vector < int > v = bubble_sort ( temp1 ) ; v . insert ( v . begin ( ) , b ) ; res = v ; } vector < int > pass ; for ( int i = 0 ; i < res . size ( ) - 1 ; i ++ ) pass . push_back ( res [ i ] ) ; vector < int > ans = bubble_sort ( pass ) ; ans . push_back ( res [ res . size ( ) - 1 ] ) ; return ans ; }
void sortBoundaryWise ( vector < vector < int > > a ) { int i , k = 0 , l = 0 ; int m = a . size ( ) , n = a [ 0 ] . size ( ) ; int n_i , n_k = 0 , n_l = 0 , n_m = m , n_n = n ; while ( k < m && l < n ) { vector < int > boundary ; for ( i = l ; i < n ; ++ i ) { boundary . push_back ( a [ k ] [ i ] ) ; } k ++ ; for ( i = k ; i < m ; ++ i ) { boundary . push_back ( a [ i ] [ n - 1 ] ) ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { boundary . push_back ( a [ m - 1 ] [ i ] ) ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { boundary . push_back ( a [ i ] [ l ] ) ; } l ++ ; } sort ( boundary . begin ( ) , boundary . end ( ) ) ; int ind = 0 ; for ( i = n_l ; i < n_n ; ++ i ) { a [ n_k ] [ i ] = boundary [ ind ++ ] ; } n_k ++ ; for ( i = n_k ; i < n_m ; ++ i ) { a [ i ] [ n_n - 1 ] = boundary [ ind ++ ] ; } n_n -- ; if ( n_k < n_m ) { for ( i = n_n - 1 ; i >= n_l ; -- i ) { a [ n_m - 1 ] [ i ] = boundary [ ind ++ ] ; } n_m -- ; } if ( n_l < n_n ) { for ( i = n_m - 1 ; i >= n_k ; -- i ) { a [ i ] [ n_l ] = boundary [ ind ++ ] ; } n_l ++ ; } } printMatrix ( a ) ; }
void countPairs ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int high = upper_bound ( arr , arr + n , k * arr [ i ] ) - arr ; ans += high - i - 1 ; } cout << ans ; }
void findXOR ( vector < vector < int > > mat , int K ) { int N = mat . size ( ) ; int M = mat [ 0 ] . size ( ) ; vector < int > digXOR ; for ( int l = 1 ; l <= ( N + M - 1 ) ; l ++ ) { int s_col = max ( 0 , l - N ) ; int count = min ( { l , ( M - s_col ) , N } ) ; int currXOR = 0 ; for ( int j = 0 ; j < count ; j ++ ) { currXOR = ( currXOR ^ mat [ min ( N , l ) - j - 1 ] [ s_col + j ] ) ; } digXOR . push_back ( currXOR ) ; } sort ( digXOR . begin ( ) , digXOR . end ( ) ) ; cout << digXOR [ N + M - 1 - K ] ; }
void countArraysUtil ( vector < int > & arr , int X , int K , int xorVal ) { if ( X == 0 ) { int cnt = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( arr [ i ] > xorVal ) cnt ++ ; } if ( cnt >= K ) ans ++ ; return ; } int temp = arr [ 0 ] ; arr . erase ( arr . begin ( ) ) ; countArraysUtil ( arr , X - 1 , K , xorVal ) ; arr . insert ( arr . begin ( ) , temp ) ; temp = arr . back ( ) ; arr . pop_back ( ) ; countArraysUtil ( arr , X - 1 , K , xorVal ) ; arr . push_back ( temp ) ; arr [ 0 ] ++ ; countArraysUtil ( arr , X - 1 , K , xorVal ) ; arr [ 0 ] -- ; arr [ arr . size ( ) - 1 ] ++ ; countArraysUtil ( arr , X - 1 , K , xorVal ) ; arr [ arr . size ( ) - 1 ] -- ; }
void countArrays ( vector < int > & arr , int X , int K ) { int xorVal = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) xorVal = xorVal ^ arr [ i ] ; countArraysUtil ( arr , X , K , xorVal ) ; cout << ans ; }
void maximumSum ( int arr [ ] , int N ) { int sum ; sort ( arr , arr + N ) ; sum = ( arr [ N - 1 ] - arr [ 0 ] ) + ( arr [ N - 2 ] - arr [ 0 ] ) + ( arr [ N - 1 ] - arr [ N - 2 ] ) ; cout << sum ; }
int getBuckets ( int arr [ ] , int N ) { int availableWater = N * ( N - 1 ) / 2 ; sort ( arr , arr + N ) ; int i = 0 , sum = 0 ; while ( sum <= availableWater ) { sum += arr [ i ] ; i ++ ; } cout << i - 1 ; }
int minimum_sum ( int A [ ] , int N ) { sort ( A , A + N ) ; int sum = INT_MAX ; for ( int i = 0 ; i <= N - 3 ; i ++ ) { sum = min ( sum , abs ( A [ i ] - A [ i + 1 ] ) + abs ( A [ i + 1 ] - A [ i + 2 ] ) ) ; } cout << sum ; }
int minimumIncreasingSubsequences ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int count = 0 ; int i = 0 ; while ( i < N ) { int x = arr [ i ] ; int freqX = 0 ; while ( i < N && arr [ i ] == x ) { freqX ++ ; i ++ ; } count = max ( count , freqX ) ; } cout << count ; }
void maxOps ( int a , int b , int c ) { int arr [ ] = { a , b , c } ; int count = 0 ; while ( 1 ) { sort ( arr , arr + 3 ) ; if ( ! arr [ 0 ] && ! arr [ 1 ] ) break ; arr [ 1 ] -= 1 ; arr [ 2 ] -= 1 ; count += 1 ; } cout << count ; }
int hashFunction ( int N ) { int prime [ 10 ] = { 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 } ; int value = 1 , r ; while ( N != 0 ) { r = N % 10 ; value = value * prime [ r ] ; N = N / 10 ; } return value ; }
void findDiff ( int arr [ ] , int n ) { map < int , vector < int > > m ; int h , min , max ; for ( int i = 0 ; i < n ; i ++ ) { h = hashFunction ( arr [ i ] ) ; m [ h ] . push_back ( arr [ i ] ) ; } for ( auto i = 0 ; i != m . size ( ) ; i ++ ) { if ( m [ i ] . size ( ) > 1 ) { min = * min_element ( m [ i ] . begin ( ) , m [ i ] . end ( ) ) ; max = * max_element ( m [ i ] . begin ( ) , m [ i ] . end ( ) ) ; cout << max - min ; break ; } else if ( i == m . size ( ) - 1 ) cout << -1 ; } }
int maxScore ( int i , int A [ ] , int K , int N , int dp [ ] ) { if ( i >= N - 1 ) return A [ N - 1 ] ; if ( dp [ i ] != -1 ) return dp [ i ] ; int score = INT_MIN ; for ( int j = 1 ; j <= K ; j ++ ) { score = max ( score , maxScore ( i + j , A , K , N , dp ) ) ; } return dp [ i ] = score + A [ i ] ; }
int getScore ( int A [ ] , int N , int K ) { int dp [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] = -1 ; cout << maxScore ( 0 , A , K , N , dp ) ; }
bool checkifSorted ( int A [ ] , int B [ ] , int N ) { bool flag = false ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { flag = true ; break ; } } if ( ! flag ) { return true ; } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 0 ) { count ++ ; break ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 1 ) { count ++ ; break ; } } if ( count == 2 ) { return true ; } return false ; }
void minOperation ( int a [ ] , int N ) { int totOps = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { totOps += abs ( a [ i ] - a [ i + 1 ] ) ; } int maxOps = max ( abs ( a [ 0 ] - a [ 1 ] ) , abs ( a [ N - 1 ] - a [ N - 2 ] ) ) ; for ( int i = 1 ; i < N - 1 ; i ++ ) { maxOps = max ( maxOps , abs ( a [ i ] - a [ i - 1 ] ) + abs ( a [ i ] - a [ i + 1 ] ) - abs ( a [ i - 1 ] - a [ i + 1 ] ) ) ; } cout << totOps - maxOps << endl ; }
void maxPossibleSum ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int sum = 0 ; int j = N - 3 ; while ( j >= 0 ) { sum += arr [ j ] ; j -= 3 ; } cout << sum ; }
void findMaxDifference ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int Leftsum = 0 ; int Totalsum = 0 ; int Min = INT_MAX , Max = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) Totalsum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int leftNumbers = i ; int rightNumbers = n - i - 1 ; Totalsum = Totalsum - arr [ i ] ; int sum = ( leftNumbers * arr [ i ] ) - Leftsum + Totalsum - ( rightNumbers * arr [ i ] ) ; Min = min ( Min , sum ) ; Max = max ( Max , sum ) ; Leftsum += arr [ i ] ; } cout << Max - Min ; }
bool sameStrings ( string str1 , string str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; if ( N != M ) { return false ; } int a [ 256 ] = { 0 } , b [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { a [ str1 [ i ] - 'a' ] ++ ; b [ str2 [ i ] - 'a' ] ++ ; } int i = 0 ; while ( i < 256 ) { if ( ( a [ i ] == 0 && b [ i ] == 0 ) || ( a [ i ] != 0 && b [ i ] != 0 ) ) { i ++ ; } else { return false ; } } sort ( a , a + 256 ) ; sort ( b , b + 256 ) ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( a [ i ] != b [ i ] ) return false ; } return true ; }
int minSteps ( string A , string B , int M , int N ) { if ( A [ 0 ] > B [ 0 ] ) return 0 ; if ( B [ 0 ] > A [ 0 ] ) { return 1 ; } if ( M <= N && A [ 0 ] == B [ 0 ] && count ( A . begin ( ) , A . end ( ) , A [ 0 ] ) == M && count ( B . begin ( ) , B . end ( ) , B [ 0 ] ) == N ) return -1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( B [ i ] > B [ 0 ] ) return 1 ; } for ( int i = 1 ; i < M ; i ++ ) { if ( A [ i ] < A [ 0 ] ) return 1 ; } for ( int i = 1 ; i < M ; i ++ ) { if ( A [ i ] > A [ 0 ] ) { swap ( A [ i ] , B [ 0 ] ) ; swap ( A [ 0 ] , B [ 0 ] ) ; return 2 ; } } for ( int i = 1 ; i < N ; i ++ ) { if ( B [ i ] < B [ 0 ] ) { swap ( A [ 0 ] , B [ i ] ) ; swap ( A [ 0 ] , B [ 0 ] ) ; return 2 ; } } return 0 ; }
long int merge ( int A [ ] , int left , int mid , int right ) { long int swaps = 0 ; int i = left , j = mid , k = left ; while ( i < mid && j <= right ) { if ( A [ i ] <= A [ j ] ) { temp [ k ] = A [ i ] ; k ++ , i ++ ; } else { temp [ k ] = A [ j ] ; k ++ , j ++ ; swaps += mid - i ; } } while ( i < mid ) { temp [ k ] = A [ i ] ; k ++ , i ++ ; } while ( j <= right ) { temp [ k ] = A [ j ] ; k ++ , j ++ ; } while ( left <= right ) { A [ left ] = temp [ left ] ; left ++ ; } return swaps ; }
long int mergeInsertionSwap ( int A [ ] , int left , int right ) { long int swaps = 0 ; if ( left < right ) { int mid = left + ( right - left ) / 2 ; swaps += mergeInsertionSwap ( A , left , mid ) ; swaps += mergeInsertionSwap ( A , mid + 1 , right ) ; swaps += merge ( A , left , mid + 1 , right ) ; } return swaps ; }
bool findAns ( int A [ ] , int N , int X ) { if ( check ( A , X , N ) ) { return true ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int g = __gcd ( A [ i ] , A [ j ] ) ; if ( g != 1 ) { if ( g <= X ) { return true ; } } } } return false ; }
string check ( int a [ ] , int b [ ] , int Na , int Nb , int k , int m ) { if ( Na < k Nb < m ) return "No" ; sort ( a , a + Na ) ; sort ( b , b + Nb ) ; if ( a [ k - 1 ] < b [ Nb - m ] ) { return "Yes" ; } return "No" ; }
int splitArray ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int result = INT_MAX ; for ( int i = 1 ; i < N ; i ++ ) { result = min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; }
int maxCntRemovedfromArray ( int arr [ ] , int N , int brr [ ] , int M ) { sort ( arr , arr + N ) ; int i = 0 ; int sumArr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sumArr += arr [ i ] ; } int sumBrr = 0 ; for ( int i = 0 ; i < M ; i ++ ) { sumBrr += brr [ i ] ; } int cntRemElem = 0 ; while ( i < N and sumArr > = sumBrr ) { sumArr -= arr [ i ] ; i += 1  ; if ( sumArr >= sumBrr ) { cntRemElem += 1 ; } }
void findPair ( pair < int , int > * arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int a = arr [ i ] . first , b = arr [ i ] . second ; for ( int j = i + 1 ; j < N ; j ++ ) { int c = arr [ j ] . first , d = arr [ j ] . second ; if ( a < c && b > d ) { cout << "(" << a << " " << b << "), (" << c << " " << d << ")\n" ; return ; } } } cout << "NO SUCH PAIR EXIST\n" ; }
void printOrder ( int order [ ] , int N , int X ) { vector < pair < int , int > > vect ; for ( int i = 0 ; i < N ; i ++ ) { if ( order [ i ] % X == 0 ) { vect . push_back ( { order [ i ] / X , i + 1 } ) ; } else { vect . push_back ( { order [ i ] / X + 1 , i + 1 } ) ; } } sort ( vect . begin ( ) , vect . end ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { cout << vect [ i ] . second << " " ; } cout << endl ; }
int CountMaximum ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
int CountMaximum ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; }
void numOperation ( int arr [ ] , int N , int D ) { sort ( arr , arr + N ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( ( arr [ i + 1 ] - arr [ i ] ) % D != 0 ) { cout << "-1" ; return ; } } int count = 0 ; int mid = arr [ N / 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { count += abs ( mid - arr [ i ] ) / D ; } cout << count ; }
void findSum ( int A [ ] , int N , int K ) { sort ( A , A + N ) ; int sum = 0 ; for ( int i = N / K ; i < N ; i += K - 1 ) { sum += A [ i ] ; } cout << sum ; }
int maxcntPairsSumKRemoved ( vector < int > arr , int k ) { int cntPairs = 0 ; if ( arr . size ( ) <= 1 ) return cntPairs ; sort ( arr . begin ( ) , arr . end ( ) ) ; int left = 0 ; int right = arr . size ( ) - 1 ; while ( left < right ) { int s = arr [ left ] + arr [ right ] ; if ( s == k ) { cntPairs += 1 ; left += 1 ; right -= 1 ; } else if ( s > k ) right -= 1 ; else left += 1 ; } return cntPairs ; }
void selectionSort ( int arr [ ] , int n ) { int i , j , min_idx ; for ( i = 0 ; i < n - 1 ; i ++ ) { min_idx = i ; for ( j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ] ) min_idx = j ; swap ( & arr [ min_idx ] , & arr [ i ] ) ; } }
int findSmallestNumLeft ( int arr [ ] , int N ) { priority_queue < int > PQ ; for ( int i = 0 ; i < N ; i ++ ) { PQ . push ( arr [ i ] ) ; } while ( PQ . size ( ) > 1 ) { int top1 = PQ . top ( ) ; PQ . pop ( ) ; int top2 = PQ . top ( ) ; PQ . pop ( ) ; PQ . push ( ( top1 + top2 + 1 ) / 2 ) ; } return PQ . top ( ) ; }
int digitProduct ( int number ) { int product = 1 ; while ( number > 0 ) { product *= ( number % 10 ) ; number /= 10 ; } return product ; }
bool compositedigitProduct ( int num ) { int res = digitProduct ( num ) ; if ( res == 1 ) { return false ; } if ( isComposite ( res ) ) { return true ; } return false ; }
int largestCompositeDigitProduct ( int a [ ] , int n , int k ) { vector < pair < int , int > > pq ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i % k ) == 0 ) { continue ; } if ( compositedigitProduct ( a [ i ] ) ) { int b = digitProduct ( a [ i ] ) ; pq . push_back ( make_pair ( b , a [ i ] ) ) ; } } sort ( pq . begin ( ) , pq . end ( ) ) ; return pq . back ( ) . second ; }
void maxSum ( int * arr , int * brr , int N , int K ) { vector < int > crr ; for ( int i = 0 ; i < N ; i ++ ) { crr . push_back ( arr [ i ] ) ; } for ( int i = 0 ; i < K ; i ++ ) { crr . push_back ( brr [ i ] ) ; } sort ( crr . begin ( ) , crr . end ( ) , greater < int > ( ) ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( crr [ i ] > 0 ) { sum += crr [ i ] ; } else { break ; } } cout << sum << endl ; }
int findMinimum ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int ans = 0 ; for ( int i = 1 ; i < 2 * ( N / K ) ; i += 2 ) { ans += arr [ i ] ; } cout << ans ; }
void findSubarrays ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int i = 0 ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { cout << "YES" << endl ; return ; } } cout << "NO" << endl ; }
void maxFreqElements ( int arr [ ] , int N , int K ) { map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } while ( K > 0 ) { int max = 0 ; int element ; for ( auto i : mp ) { if ( i . second > max ) { max = i . second ; element = i . first ; } } cout << element << " " ; mp [ element ] -- ; K -- ; } }
int getPairs ( int arr [ ] , int N , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] > K * arr [ i + 1 ] ) count ++ ; } } cout << count ; }
int merge ( int arr [ ] , int temp [ ] , int l , int m , int r , int K ) { int i = l ; int j = m + 1 ; int cnt = 0 ; for ( int l = 0 ; i <= m ; i ++ ) { bool found = false ; while ( j <= r ) { if ( arr [ i ] >= K * arr [ j ] ) { found = true ; } else break ; j ++ ; } if ( found ) { cnt += j - ( m + 1 ) ; j -- ; } } int k = l ; i = l ; j = m + 1 ; while ( i <= m && j <= r ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else temp [ k ++ ] = arr [ j ++ ] ; } while ( i <= m ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= r ) temp [ k ++ ] = arr [ j ++ ] ; for ( int i = l ; i <= r ; i ++ ) arr [ i ] = temp [ i ] ; return cnt ; }
int mergeSort ( int arr [ ] , int N , int K ) { int temp [ N ] ; cout << mergeSortUtil ( arr , temp , 0 , N - 1 , K ) ; }
void Selection_Sort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; ++ i ) { int min_index = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( arr [ j ] < arr [ min_index ] ) min_index = j ; } swap ( arr [ i ] , arr [ min_index ] ) ; } }
void Bubble_Sort ( int arr [ ] , int n ) { bool flag ; for ( int i = 1 ; i < n ; ++ i ) { flag = false ; for ( int j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { swap ( arr [ j ] , arr [ j + 1 ] ) ; flag = true ; } } if ( flag == false ) break ; } }
void NDivKWithFreq ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; for ( int i = 0 ; i < N ; ) { int cnt = 1 ; while ( ( i + 1 ) < N && arr [ i ] == arr [ i + 1 ] ) { cnt ++ ; i ++ ; } if ( cnt > ( N / K ) ) { cout << arr [ i ] << " " ; } i ++ ; } }
int upperBound ( int arr [ ] , int N , int K ) { int l = 0 ; int r = N ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( arr [ mid ] <= K ) { l = mid + 1 ; } else { r = mid ; } } return l ; }
void NDivKWithFreq ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int i = 0 ; while ( i < N ) { int X = upperBound ( arr , N , arr [ i ] ) ; if ( ( X - i ) > N / 4 ) { cout << arr [ i ] << " " ; } i = X ; } }
bool checkSubsetSum ( int A [ ] , int B [ ] , int N , int K ) { sort ( A , A + N ) ; sort ( B , B + N , greater < int > ( ) ) ; int sum1 = 0 ; int sum2 = 0 ; for ( int i = 0 ; i < K ; i ++ ) { sum1 += A [ i ] ; sum2 += B [ i ] ; } if ( sum1 > sum2 ) { return true ; } return false ; }
void printCircularArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { cout << arr [ i ] << " " ; } }
void sortCircularArray ( int arr [ ] , int n , int k , int m ) { for ( int i = 0 ; i < m ; i ++ ) { for ( int j = k ; j < k + m - 1 ; j ++ ) { if ( arr [ j % n ] > arr [ ( j + 1 ) % n ] ) { swap ( arr [ j % n ] , arr [ ( j + 1 ) % n ] ) ; } } } printCircularArray ( arr , n ) ; }
void rearrangeArray ( int a [ ] , int n ) { sort ( a , a + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] == i + 1 ) { swap ( a [ i ] , a [ i + 1 ] ) ; } } if ( a [ n - 1 ] == n ) { swap ( a [ n - 1 ] , a [ n - 2 ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { cout << a [ i ] << " " ; } }
int maximumKthLargestsumPart ( int arr [ ] , int N , int M , int K ) { int maxSum = 0 ; if ( N % M ) return -1 ; int sz = ( N / M ) ; if ( K > sz ) return -1 ; sort ( arr , arr + N , greater < int > ( ) ) ; for ( int i = 1 ; i <= M ; i ++ ) { maxSum += arr [ i * K - 1 ] ; } return maxSum ; }
void splitArray ( int arr [ ] , int n , int K ) { sort ( arr , arr + n ) ; int i = n - 1 ; int result = 0 ; while ( K -- ) { result += arr [ i - 1 ] ; i -= 2 ; } cout << result ; }
void merge ( int * indices , int * a , int l , int mid , int r ) { int temp_ind [ r - l + 1 ] , j = mid + 1 ; int i = 0 , temp_l = l , k ; while ( l <= mid && j <= r ) { if ( a [ indices [ l ] ] < a [ indices [ j ] ] ) temp_ind [ i ++ ] = indices [ l ++ ] ; else temp_ind [ i ++ ] = indices [ j ++ ] ; } while ( l <= mid ) temp_ind [ i ++ ] = indices [ l ++ ] ; while ( j <= r ) temp_ind [ i ++ ] = indices [ j ++ ] ; for ( k = 0 ; k < i ; k ++ ) indices [ temp_l ++ ] = temp_ind [ k ] ; }
void divide ( int * indices , int * a , int l , int r ) { if ( l >= r ) return ; int mid = l / 2 + r / 2 ; divide ( indices , a , l , mid ) ; divide ( indices , a , mid + 1 , r ) ; merge ( indices , a , l , mid , r ) ; }
void noOfSubsequences ( int arr [ ] , int N ) { int indices [ N ] , i ; for ( i = 0 ; i < N ; i ++ ) indices [ i ] = i ; divide ( indices , arr , 0 , N - 1 ) ; int B [ N ] ; int subseq = 1 ; for ( i = 0 ; i < N ; i ++ ) { B [ indices [ i ] ] = subseq ; subseq *= 2 ; } for ( i = 0 ; i < N ; i ++ ) cout << B [ i ] << " " ; }
bool checkStr1CanConStr2 ( string & str1 , string & str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; set < int > st1 ; set < int > st2 ; int hash1 [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { hash1 [ str1 [ i ] ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { st1 . insert ( str1 [ i ] ) ; } for ( int i = 0 ; i < M ; i ++ ) { st2 . insert ( str2 [ i ] ) ; } if ( st1 != st2 ) { return false ; } int hash2 [ 256 ] = { 0 } ; for ( int i = 0 ; i < M ; i ++ ) { hash2 [ str2 [ i ] ] ++ ; } sort ( hash1 , hash1 + 256 ) ; sort ( hash2 , hash2 + 256 ) ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( hash1 [ i ] != hash2 [ i ] ) { return false ; } } return true ; }
void sortArrayInDescAsc ( int arr [ ] , int N , int K ) { sort ( arr , arr + N , greater < int > ( ) ) ; sort ( arr + K , arr + N ) ; for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << " " ; } }
int maxCostToRemove ( int arr [ ] , int N , int K ) { int maxCost = 0 ; sort ( arr , arr + N ) ; for ( int i = 0 ; i < N ; i += K ) { maxCost += arr [ i + 1 ] ; } return maxCost ; }
static void lexNumbers ( int n ) { vector < string > s ; for ( int i = 1 ; i <= n ; i ++ ) { s . push_back ( convert_to_words ( i ) ) ; } sort ( s . begin ( ) , s . end ( ) ) ; vector < string > ans ; for ( int i = 0 ; i < n ; i ++ ) ans . push_back ( s [ i ] ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) cout << ans [ i ] << ", " ; cout << ans [ n - 1 ] ; }
void minimumCost ( int * binary , int n , int a , int b ) { vector < int > groupOfZeros ; int len = 0 , i = 0 ; bool increment_need = true ; while ( i < n ) { increment_need = true ; while ( i < n && binary [ i ] == 0 ) { len ++ ; i ++ ; increment_need = false ; } if ( increment_need == true ) { i ++ ; } if ( len != 0 ) { groupOfZeros . push_back ( len ) ; } len = 0 ; } sort ( groupOfZeros . begin ( ) , groupOfZeros . end ( ) ) ; i = 0 ; bool found_ones = false ; int NumOfOnes = 0 ; while ( i < n ) { found_ones = false ; while ( i < n && binary [ i ] == 1 ) { i ++ ; found_ones = true ; } if ( found_ones == false ) i ++ ; else NumOfOnes ++ ; } int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int curr = 0 , totalOnes = NumOfOnes ; if ( i == 0 ) { curr = totalOnes * a ; } else { int mark = i , num_of_changes = 0 ; for ( int x : groupOfZeros ) { if ( mark >= x ) { totalOnes -- ; mark -= x ; num_of_changes += x ; } else { break ; } } curr = ( num_of_changes * b ) + ( totalOnes * a ) ; } ans = min ( ans , curr ) ; } cout << ans ; }
int isSortedparitions ( int arr [ ] , int i , int j ) { for ( int k = i + 1 ; k <= j ; k ++ ) { if ( arr [ k ] < arr [ k - 1 ] ) { return 0 ; } } return 1 ; }
int partitionsArr ( int arr [ ] , int i , int j ) { if ( i >= j ) return 1 ; bool flag = isSortedparitions ( arr , i , j ) ; if ( flag ) { return ( j - i + 1 ) ; } int mid = ( i + j ) / 2 ; int X = partitionsArr ( arr , i , mid ) ; int Y = partitionsArr ( arr , mid + 1 , j ) ; return max ( X , Y ) ; }
bool checkIfPossibleMerge ( int A [ ] , int B [ ] , int N ) { int i = 0 ; int j = 0 ; int prev = -1 ; int flag = 1 ; while ( i < N && j < N ) { if ( A [ i ] < B [ j ] && prev != 0 ) { prev = 0 ; i ++ ; } else if ( B [ j ] < A [ i ] && prev != 1 ) { prev = 1 ; j ++ ; } else if ( A [ i ] == B [ j ] ) { if ( prev != 1 ) { prev = 1 ; j ++ ; } else { prev = 0 ; i ++ ; } } else { flag = 0 ; break ; } } return flag ; }
int maxSum ( int n , int a [ ] , int l [ ] [ 2 ] , int q ) { vector < int > v ; int d [ n ] = { 0 } ; for ( int i = 0 ; i < q ; i ++ ) { for ( int x = l [ i ] [ 0 ] ; x <= l [ i ] [ 1 ] ; x ++ ) { if ( d [ x ] == 0 ) { d [ x ] = 1 ; } } } set < int > st ; for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] == 0 ) { v . push_back ( a [ i ] ) ; st . insert ( i ) ; } } sort ( v . begin ( ) , v . end ( ) , greater < int > ( ) ) ; int c = 0 ; for ( auto it : st ) { a [ it ] = v ; c ++ ; } int pref_sum = 0 ; int temp_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp_sum += a [ i ] ; pref_sum += temp_sum ; } return pref_sum ; }
void countPairs ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int xo = ( A [ i ] ^ A [ j ] ) ; int mx = max ( A [ i ] , A [ j ] ) ; if ( xo > mx ) { count ++ ; } } } cout << count ; }
int findMedianOfsubSum ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } sort ( arr , arr + N ) ; int dp [ N ] [ sum + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } dp [ 0 ] [ arr [ 0 ] ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j >= arr [ i ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - arr [ i ] ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } } vector < int > sumSub ; for ( int j = 1 ; j <= sum ; j ++ ) { int M = dp [ N - 1 ] [ j ] ; for ( int i = 1 ; i <= M ; i ++ ) { sumSub . push_back ( j ) ; } } int mid = sumSub [ sumSub . size ( ) / 2 ] ; return mid ; }
int maxDiffLargSmallOper ( int arr [ ] , int N , int K ) { int maxDiff = 0 ; sort ( arr , arr + N , greater < int > ( ) ) ; for ( int i = 0 ; i <= min ( K , N - 1 ) ; i ++ ) { maxDiff += arr [ i ] ; } return maxDiff ; }
void findTheOrder ( int arr [ ] , string s , int N ) { vector < int > ans ; pair < int , int > A [ N ] ; for ( int i = 0 ; i < N ; i ++ ) A [ i ] =  { arr [ i ] , i + 1 } ; sort ( A , A + N ) ; priority_queue < pair < int , int > > q ; int index = 0 ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( s [ i ] == '0' ) { ans . push_back ( A [ index ] . second ) ; q . push ( A [ index ] ) ; index ++ ; } else { ans . push_back ( q . top ( ) . second ) ; q . pop ( ) ; } } for ( auto i : ans ) { cout << i << " " ; } }
void checkArrangement ( int A1 [ ] , int A2 [ ] , int n , int k ) { sort ( A1 , A1 + n ) ; sort ( A2 , A2 + n , greater < int > ( ) ) ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( A1 [ i ] + A2 [ i ] > k ) || ( A1 [ i ] + A2 [ i ] < k / 2 ) ) { flag = 1 ; break ; } } if ( flag == 1 ) cout << "No" ; else cout << "Yes" ; }
int MaxRearrngeSum ( int A [ ] , int B [ ] , int N ) { sort ( A , A + N ) ; sort ( B , B + N , greater < int > ( ) ) ; int maxSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { maxSum += abs ( A [ i ] - B [ i ] ) ; } return maxSum ; }
int largestArea ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int end = 0 , start = 0 , i = 0 , j = 0 ; sort ( arr1 , arr1 + n ) ; sort ( arr2 , arr2 + m ) ; while ( i < n and j < m ) { if ( arr1 [ i ] == arr2 [ j ] ) { if ( start == 0 ) start = arr1 [ i ] ; else end = arr1 [ i ] ; i ++ ; j ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) j ++ ; else i ++ ; } if ( end == 0 or start == 0 ) return 0 ; else return ( end - start ) ; }
int count_pairs ( int arr [ ] , int brr [ ] , int N , int M , int K ) { int i = 0 ; int j = 0 ; int cntPairs = 0 ; sort ( arr , arr + N ) ; sort ( brr , brr + M ) ; while ( i < N && j < M ) { if ( brr [ j ] - arr [ i ] > K ) { cntPairs += ( M - j ) ; i ++ ; } else { j ++ ; } } return cntPairs ; }
void firstSubsequence ( string s ) { vector < string > allsubseq ; string k ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { k = s ; k . erase ( i , 1 ) ; allsubseq . push_back ( k ) ; } sort ( allsubseq . begin ( ) , allsubseq . end ( ) ) ; cout << allsubseq [ 0 ] ; }
void firstSubsequence ( string s ) { int isMax = -1 ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) { isMax = i ; break ; } } if ( isMax >= 0 ) { s . erase ( isMax , 1 ) ; } else { s . erase ( s . length ( ) - 1 , 1 ) ; } cout << s ; }
void minHeapify ( int brr [ ] , int i , int M ) { int left = 2 * i + 1 ; int right = 2 * i + 2 ; int smallest = i ; if ( left < M && brr [ left ] < brr [ smallest ] ) { smallest = left ; } if ( right < M && brr [ right ] < brr [ smallest ] ) { smallest = right ; } if ( smallest != i ) { swap ( brr [ i ] , brr [ smallest ] ) ; minHeapify ( brr , smallest , M ) ; } }
void merge ( int arr [ ] , int brr [ ] , int N , int M ) { for ( int i = 0 ; i < N ; ++ i ) { if ( arr [ i ] > brr [ 0 ] ) { swap ( arr [ i ] , brr [ 0 ] ) ; minHeapify ( brr , 0 , M ) ; } } sort ( brr , brr + M ) ; }
void printArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) cout << arr [ i ] << " " ; }
int rankLessThanK ( int * arr , int k , int n ) { int rank = 1 ; int position = 1 ; sort ( arr , arr + n ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i == n - 1 arr [ i ] != arr [ i + 1 ] ) { rank = position ; if ( rank > k ) return position - 1 ; } position ++ ; } return n ; }
void calculateFib ( int fib [ ] , int n ) { fib [ 0 ] = fib [ 1 ] = 1 ; for ( int x = 2 ; x < n ; x ++ ) { fib [ x ] = fib [ x - 1 ] + fib [ x - 2 ] ; } }
int find_mth_bit ( int n , int m , int fib [ ] ) { if ( n <= 1 ) { return n ; } int len_left = fib [ n - 2 ] ; int len_right = fib [ n - 1 ] ; if ( m <= len_left ) { return find_mth_bit ( n - 2 , len_left + 1 - m , fib ) ; } else { return find_mth_bit ( n - 1 , len_right + 1 - ( m - len_left ) , fib ) ; } }
int KthSmallestNum ( pair < int , int > arr [ ] , int n , int k ) { priority_queue < pair < int , int > , vector < pair < int , int > > , greater < pair < int , int > > > pq ; for ( int i = 0 ; i < n ; i ++ ) { pq . push ( { arr [ i ] . first , arr [ i ] . second } ) ; } int cnt = 1 ; while ( cnt < k ) { pair < int , int > interval = pq . top ( ) ; pq . pop ( ) ; if ( interval . first < interval . second ) { pq . push ( { interval . first + 1 , interval . second } ) ; } cnt ++ ; } return pq . top ( ) . first ; }
void maxArea ( int point_x [ ] , int point_y [ ] , int n , int length , int width ) { sort ( point_x , point_x + n ) ; sort ( point_y , point_y + n ) ; int dx = point_x [ 0 ] ; int dy = point_y [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dx = max ( dx , point_x [ i ] - point_x [ i - 1 ] ) ; dy = max ( dy , point_y [ i ] - point_y [ i - 1 ] ) ; } dx = max ( dx , ( length + 1 ) - point_x [ n - 1 ] ) ; dy = max ( dy , ( width + 1 ) - point_y [ n - 1 ] ) ; cout << ( dx - 1 ) * ( dy - 1 ) ; cout << endl ; }
int LongestSequence ( int a [ ] , int n ) { map < int , int > m ; int ar [ n + 1 ] , i , j ; for ( i = 1 ; i <= n ; i ++ ) { ar [ i ] = a [ i - 1 ] ; } sort ( a , a + n ) ; int c = 1 ; m [ a [ 0 ] ] = c ; for ( i = 1 ; i <= n ; i ++ ) { if ( a [ i ] != a [ i - 1 ] ) { c ++ ; m [ a [ i ] ] = c ; } } map < int , int > cnt ; int dp [ n + 1 ] [ 3 ] = { 0 } ; cnt [ 0 ] = 0 ; for ( i = 1 ; i <= n ; i ++ ) { ar [ i ] = m [ ar [ i ] ] ; cnt [ ar [ i ] ] ++ ; } int ans = 0 , x ; for ( i = 1 ; i <= n ; i ++ ) { x = ar [ i ] ; if ( dp [ x ] [ 0 ] == 0 ) { if ( dp [ x - 1 ] [ 0 ] == cnt [ x - 1 ] ) { dp [ x ] [ 1 ] = dp [ x - 1 ] [ 1 ] ; dp [ x ] [ 2 ] = dp [ x - 1 ] [ 1 ] ; } else { dp [ x ] [ 1 ] = dp [ x - 1 ] [ 0 ] ; } } dp [ x ] [ 2 ] = max ( dp [ x - 1 ] [ 0 ] , dp [ x ] [ 2 ] ) ; if ( dp [ x - 1 ] [ 0 ] == cnt [ x - 1 ] ) { dp [ x ] [ 2 ] = max ( dp [ x ] [ 2 ] , dp [ x - 1 ] [ 1 ] ) ; } for ( j = 0 ; j < 3 ; j ++ ) { dp [ x ] [ j ] ++ ; ans = max ( ans , dp [ x ] [ j ] ) ; } } return ans ; }
int solve ( vector < int > & values , vector < int > & salary ) { long long ret = 1 ; int amt = 0 ; sort ( values . begin ( ) , values . end ( ) ) ; sort ( salary . begin ( ) , salary . end ( ) ) ; while ( salary . size ( ) ) { while ( values . size ( ) && values . back ( ) >= salary . back ( ) ) { amt ++ ; values . pop_back ( ) ; } if ( amt == 0 ) return 0 ; ret *= amt -- ; ret %= MOD ; salary . pop_back ( ) ; } return ret ; }
void precompute_sum ( vector < int > & arr , vector < int > & brr ) { int N = ( int ) arr . size ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; brr [ i ] = brr [ i ] + brr [ i - 1 ] ; } }
void find_sum ( vector < int > & arr , int q , int Queries [ ] [ 3 ] ) { vector < int > brr ( arr ) ; int N = ( int ) arr . size ( ) ; sort ( brr . begin ( ) , brr . end ( ) ) ; precompute_sum ( arr , brr ) ; for ( int i = 0 ; i < q ; i ++ ) { int m = Queries [ i ] [ 0 ] ; int a = Queries [ i ] [ 1 ] ; int b = Queries [ i ] [ 2 ] ; if ( m == 1 ) { cout << range_sum ( arr , a , b ) << ' ' ; } else if ( m == 2 ) { cout << range_sum ( brr , a , b ) << ' ' ; } } }
int minsteps ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += abs ( arr [ i ] - pow ( 2 , i ) ) ; } return ans ; }
int findCost ( int * a , int n ) { sort ( a , a + n , greater < int > ( ) ) ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int p = a [ j ] - j ; a [ j ] = 0 ; if ( p < 0 ) { p = 0 ; continue ; } count += p ; } return count ; }
int make_cuts ( int arr [ ] , int n , int K ) { int ans = 0 ; vector < int > poss ; int ce = 0 ; int co = 0 ; for ( int x = 0 ; x < n - 1 ; x ++ ) { if ( arr [ x ] % 2 == 0 ) ce ++ ; else co ++ ; if ( ce == co && co > 0 && ce > 0 ) { poss . push_back ( abs ( arr [ x ] - arr [ x + 1 ] ) ) ; } } sort ( poss . begin ( ) , poss . end ( ) ) ; for ( int x : poss ) { if ( K >= x ) { ans ++ ; K -= x ; } else break ; } return ans ; }
void Arrange ( int arr [ ] , int n ) { int cost = 0 ; unordered_map < int , int > index ; for ( int i = 0 ; i < n ; i ++ ) { index [ arr [ i ] ] = i ; } sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { if ( arr [ i ] > arr [ i + 1 ] + arr [ n - 1 ] ) { cout << "-1" ; return ; } else { cost += abs ( index [ arr [ i ] ] - i ) ; } } else if ( i == n - 1 ) { if ( arr [ i ] > arr [ i - 1 ] + arr [ 0 ] ) { cout << "-1" ; return ; } else { cost += abs ( index [ arr [ i ] ] - i ) ; } } else { if ( arr [ i ] > arr [ i - 1 ] + arr [ i + 1 ] ) { cout << "-1" ; return ; } else { cost += abs ( index [ arr [ i ] ] - i ) ; } } } cout << cost ; return ; }
int maxDistinctChar ( string s , int n , int k ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) freq [ s [ i ] ] ++ ; vector < int > v ; for ( auto it = freq . begin ( ) ; it != freq . end ( ) ; it ++ ) { v . push_back ( it -> second ) ; } sort ( v . begin ( ) , v . end ( ) ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int mn = min ( v [ i ] - 1 , k ) ; v [ i ] -= mn ; k -= mn ; } if ( k > 0 ) { for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int mn = min ( v [ i ] , k ) ; v [ i ] -= mn ; k -= mn ; } } int res = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) if ( v [ i ] == 1 ) res ++ ; return res ; }
int getMaxSum ( int i , int j , int k , int arr1 [ ] , int arr2 [ ] , int arr3 [ ] ) { int cnt = 0 ; if ( i >= n1 ) cnt ++ ; if ( j >= n2 ) cnt ++ ; if ( k >= n3 ) cnt ++ ; if ( cnt >= 2 ) return 0 ; if ( dp [ i ] [ j ] [ k ] != -1 ) return dp [ i ] [ j ] [ k ] ; int ans = 0 ; if ( i < n1 && j < n2 ) ans = max ( ans , getMaxSum ( i + 1 , j + 1 , k , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr2 [ j ] ) ; if ( i < n1 && k < n3 ) ans = max ( ans , getMaxSum ( i + 1 , j , k + 1 , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr3 [ k ] ) ; if ( j < n2 && k < n3 ) ans = max ( ans , getMaxSum ( i , j + 1 , k + 1 , arr1 , arr2 , arr3 ) + arr2 [ j ] * arr3 [ k ] ) ; dp [ i ] [ j ] [ k ] = ans ; return dp [ i ] [ j ] [ k ] ; }
int maxProductSum ( int arr1 [ ] , int arr2 [ ] , int arr3 [ ] ) { memset ( dp , -1 , sizeof ( dp ) ) ; sort ( arr1 , arr1 + n1 ) ; reverse ( arr1 , arr1 + n1 ) ; sort ( arr2 , arr2 + n2 ) ; reverse ( arr2 , arr2 + n2 ) ; sort ( arr3 , arr3 + n3 ) ; reverse ( arr3 , arr3 + n3 ) ; return getMaxSum ( 0 , 0 , 0 , arr1 , arr2 , arr3 ) ; }
void SieveOfEratosthenes ( ) { bool prime [ 10005 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= 1000 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= 1000 ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= 1000 ; p ++ ) if ( prime [ p ] ) primes . push_back ( p ) ; }
ll findMaxValue ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; ll ans = arr [ n - 1 ] ; ll maxPossible = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( maxPossible > 0 ) { if ( arr [ i ] >= maxPossible ) { ans += ( maxPossible - 1 ) ; maxPossible = maxPossible - 1 ; } else { maxPossible = arr [ i ] ; ans += maxPossible ; } } } return ans ; }
int countPairs ( int arr [ ] , int n ) { int ans = 0 ; sort ( arr , arr + n ) ; int left = 0 , right = 1 ; while ( right < n ) { if ( arr [ left ] == arr [ right ] ) ans += right - left ; else left = right ; right ++ ; } return ans ; }
int maximizeFinalElement ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; if ( arr [ 0 ] != 1 ) arr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 1 ) { arr [ i ] = arr [ i - 1 ] + 1 ; } } return arr [ n - 1 ] ; }
int findLeastDist ( int A [ ] , int N ) { sort ( A , A + N ) ; if ( N % 2 == 0 ) { return A [ ( N - 1 ) / 2 ] ; } else { return A [ N / 2 ] ; } }
int maxSubMatSum ( vector < vector < int > > mat ) { int n = mat . size ( ) ; int m = mat [ 0 ] . size ( ) ; int i , j ; int dp [ n ] [ m ] ; dp [ n - 1 ] [ m - 1 ] = mat [ n - 1 ] [ m - 1 ] ; int res = dp [ n - 1 ] [ m - 1 ] ; for ( i = m - 2 ; i >= 0 ; i -- ) { dp [ n - 1 ] [ i ] = mat [ n - 1 ] [ i ] + dp [ n - 1 ] [ i + 1 ] ; res = max ( res , dp [ n - 1 ] [ i ] ) ; } for ( i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] [ m - 1 ] = mat [ i ] [ m - 1 ] + dp [ i + 1 ] [ m - 1 ] ; res = max ( res , dp [ i ] [ m - 1 ] ) ; } for ( i = n - 2 ; i >= 0 ; i -- ) { for ( j = m - 2 ; j >= 0 ; j -- ) { dp [ i ] [ j ] = mat [ i ] [ j ] + dp [ i ] [ j + 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j + 1 ] ; res = max ( res , dp [ i ] [ j ] ) ; } } return res ; }
int solution ( int A , int B , int C ) { int arr [ 3 ] ; arr [ 0 ] = A , arr [ 1 ] = B , arr [ 2 ] = C ; sort ( arr , arr + 3 ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; }
int removeElements ( ll arr [ ] , int n ) { sort ( arr , arr + n , greater < int > ( ) ) ; ll ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += arr [ i ] * pow ( 2 , i ) ; } return ans ; }
bool canMadeEqual ( int A [ ] , int B [ ] , int n ) { sort ( A , A + n ) ; sort ( B , B + n ) ; for ( int i = 0 ; i < n ; i ++ ) if ( A [ i ] != B [ i ] ) return false ; return true ; }
int maxMinDifference ( int arr [ ] , int n , int k ) { if ( k >= n - 1 ) return 0 ; sort ( arr , arr + n ) ; int ans = arr [ n - 1 ] - arr [ 0 ] ; for ( int i = k , j = n - 1 ; i >= 0 ; -- i , -- j ) { ans = min ( arr [ j ] - arr [ i ] , ans ) ; } return ans ; }
int inversionCount ( string & s ) { int freq [ 26 ] = { 0 } ; int inv = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int temp = 0 ; for ( int j = 0 ; j < int ( s [ i ] - 'a' ) ; j ++ ) temp += freq [ j ] ; inv += ( i - temp ) ; freq [ s [ i ] - 'a' ] ++ ; } return inv ; }
int numberofpairs ( int arr [ ] , int N ) { int answer = 0 ; sort ( arr , arr + N ) ; int minDiff = INT_MAX ; for ( int i = 0 ; i < N - 1 ; i ++ ) minDiff = min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff ) answer ++ ; } return answer ; }
long dist ( pair < long , long > p1 , pair < long , long > p2 ) { long x0 = p1 . first - p2 . first ; long y0 = p1 . second - p2 . second ; return x0 * x0 + y0 * y0 ; }
void maximumSum ( int arr [ ] , int n , int k ) { int elt = n / k ; int sum = 0 ; sort ( arr , arr + n ) ; int count = 0 ; int i = n - 1 ; while ( count < k ) { sum += arr [ i ] ; i -- ; count ++ ; } count = 0 ; i = 0 ; while ( count < k ) { sum += arr [ i ] ; i += elt - 1 ; count ++ ; } cout << sum << "\n" ; }
int countMinSteps ( int arr [ ] , int target , int n ) { sort ( arr , arr + n ) ; int minimumSteps = 0 ; int i = 0 , j = n - 1 ; while ( i <= j ) { if ( arr [ i ] + arr [ j ] <= target ) { i ++ ; j -- ; } else { j -- ; } minimumSteps ++ ; } return minimumSteps ; }
int build_num ( int bit [ ] ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) if ( bit [ i ] ) ans += ( 1 << i ) ; return ans ; }
int maximumOR ( int arr [ ] , int n , int k ) { int bit [ 32 ] = { 0 } ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( bit [ i ] == 0 && k > 0 ) { int temp = build_num ( bit ) ; int temp1 = temp ; int val = -1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( temp1 < ( temp arr [ j ] ) ) { temp1 = temp | arr [ j ] ; val = arr [ j ] ; } } if ( val != -1 ) { k -- ; for ( int j = 0 ; j < 32 ; j ++ ) { if ( val & ( 1 << j ) ) bit [ j ] ++ ; } } } } return build_num ( bit ) ; }
int findMinSum ( int arr [ ] , int K , int L , int size ) { if ( K * L > size ) return -1 ; int minsum = 0 ; sort ( arr , arr + size ) ; for ( int i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ; return minsum ; }
void find_max_length ( vector < int > & arr , int index , int sum , int k ) { sum = sum + arr [ index ] ; store . push_back ( arr [ index ] ) ; if ( sum == k ) { if ( max_length < store . size ( ) ) { max_length = store . size ( ) ; ans = store ; } } for ( int i = index + 1 ; i < arr . size ( ) ; i ++ ) { if ( sum + arr [ i ] <= k ) { find_max_length ( arr , i , sum , k ) ; store . pop_back ( ) ; } else return ; } return ; }
int longestSubsequence ( vector < int > arr , int n , int k ) { sort ( arr . begin ( ) , arr . end ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_length >= n - i ) break ; store . clear ( ) ; find_max_length ( arr , i , 0 , k ) ; } return max_length ; }
void minBox ( int arr [ ] , int n ) { int box = n ; sort ( arr , arr + n ) ; int curr_box = 0 , next_box = 1 ; while ( curr_box < n && next_box < n ) { if ( arr [ curr_box ] < arr [ next_box ] ) { box -- ; curr_box ++ ; next_box ++ ; } else if ( arr [ curr_box ] == arr [ next_box ] ) next_box ++ ; } cout << box << endl ; }
void setData ( node * head ) { node * tmp ; tmp = head ; while ( tmp != NULL ) { cout << tmp -> data << " -> " ; tmp = tmp -> next ; } }
double findMedian ( int a [ ] , int n ) { if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; }
void kStrongest ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; double median = findMedian ( arr , n ) ; int diff [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { diff [ i ] = abs ( median - arr [ i ] ) ; } int i = 0 , j = n - 1 ; while ( k > 0 ) { if ( diff [ i ] > diff [ j ] ) { cout << arr [ i ] << " " ; i ++ ; } else { cout << arr [ j ] << " " ; j -- ; } k -- ; } }
bool sorting_possible ( int a [ ] , int b [ ] , int n ) { bool sorted = true ; int type1 = 0 , type0 = 0 , i ; for ( i = 1 ; i < n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] ) { sorted = false ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( b [ i ] == 0 ) type0 ++ ; else type1 ++ ; } if ( sorted ) return true ; else if ( type1 == n type0 == n ) return false ; else return true ; }
void lexNumbers ( int n ) { vector < string > s ; for ( int i = 1 ; i <= n ; i ++ ) { s . push_back ( to_string ( i ) ) ; } sort ( s . begin ( ) , s . end ( ) ) ; vector < int > ans ; for ( int i = 0 ; i < n ; i ++ ) ans . push_back ( stoi ( s [ i ] ) ) ; for ( int i = 0 ; i < n ; i ++ ) cout << ans [ i ] << " " ; }
void dfs ( int temp , int n , vector < int > & sol ) { if ( temp > n ) return ; sol . push_back ( temp ) ; dfs ( temp * 10 , n , sol ) ; if ( temp % 10 != 9 ) dfs ( temp + 1 , n , sol ) ; }
int findMinDif ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; return ( arr [ N - 1 ] - arr [ N - 2 ] ) ; }
int partition ( int arr [ ] , int l , int h ) { int pivot = arr [ l ] ; int i = l + 1 ; int j = h ; while ( i <= j ) { while ( i <= h && arr [ i ] < pivot ) { i ++ ; } while ( j > l && arr [ j ] > pivot ) { j -- ; } if ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; i ++ ; j -- ; } else i ++ ; } arr [ l ] = arr [ j ] ; arr [ j ] = pivot ; return j ; }
void sortArray ( int arr [ ] , int l , int h ) { if ( l >= h ) return ; int pivot = partition ( arr , l , h ) ; sortArray ( arr , l , pivot - 1 ) ; sortArray ( arr , pivot + 1 , h ) ; }
int findMaxIntervals ( int start [ ] , int end [ ] , int n , int R ) { int ans = 0 ; int prev = 0 ; int currActive = 0 ; int i = 0 ; int j = 0 ; if ( start [ 0 ] > 0 ) ans ++ ; while ( i < n && j < n ) { if ( start [ i ] < end [ j ] ) { i ++ ; currActive ++ ; } else if ( start [ i ] > end [ j ] ) { j ++ ; currActive -- ; } else { i ++ ; j ++ ; } if ( currActive == 0 ) { ans ++ ; } } if ( end [ n - 1 ] < R ) ans ++ ; return ans ; }
void sortArray ( int A [ ] , int N ) { int x , y , z ; if ( N % 4 == 0 N % 4 == 1 ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } cout << "Sorted Array: " ; for ( int i = 0 ; i < N ; i ++ ) cout << A [ i ] << " " ; } else cout << "-1" ; }
void check_vector ( vector < int > A , int n , vector < int > p ) { vector < int > pos ( A . size ( ) ) ; for ( int i = 0 ; i < p . size ( ) ; i ++ ) { pos [ p [ i ] - 1 ] = 1 ; } int flag = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( pos [ i ] == 0 ) continue ; int j = i ; while ( j < n && pos [ j ] ) ++ j ; sort ( A . begin ( ) + i , A . begin ( ) + j + 1 ) ; i = j ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) cout << "Yes" ; else cout << "No" ; }
void dfs ( int x ) { vector < int > v ; v . clear ( ) ; ns . clear ( ) ; for ( int it : s ) { if ( ! g [ x ] [ it ] ) { v . push_back ( it ) ; } else { ns . insert ( it ) ; } } s = ns ; for ( int i : v ) { dfs ( i ) ; } }
void weightOfMST ( int N ) { int cnt = 0 ; for ( int i = 1 ; i <= N ; ++ i ) { s . insert ( i ) ; } for ( ; s . size ( ) ; ) { ++ cnt ; int t = * s . begin ( ) ; s . erase ( t ) ; dfs ( t ) ; } cout << cnt - 1 ; }
void sortDiff ( vector < int > arr , int n ) { sort ( arr . begin ( ) , arr . end ( ) ) ; vector < int > out ; while ( n > 0 ) { out . push_back ( arr [ n / 2 ] ) ; arr . erase ( arr . begin ( ) + n / 2 ) ; n = n - 1 ; } for ( auto i : out ) cout << i << " " ; }
void minimumCost ( int arr [ ] , int N , int M ) { sort ( arr , arr + N ) ; int pref [ N ] ; pref [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { pref [ i ] = arr [ i ] + pref [ i - 1 ] ; } for ( int i = M ; i < N ; i ++ ) { pref [ i ] += pref [ i - M ] ; } for ( int i = 0 ; i < N ; i ++ ) { cout << pref [ i ] << ' ' ; } }
int countPairs ( vector < int > A , vector < int > B ) { int n = A . size ( ) ; sort ( A . begin ( ) , A . end ( ) ) ; sort ( B . begin ( ) , B . end ( ) ) ; int ans = 0 , i ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; }
int uniqueSum ( int A [ ] , int R [ ] [ 2 ] , int N , int M ) { for ( int i = 0 ; i < M ; ++ i ) { int l = R [ i ] [ 0 ] , r = R [ i ] [ 1 ] + 1 ; l -- ; r -- ; A [ l ] ++ ; if ( r < N ) A [ r ] -- ; } for ( int i = 1 ; i < N ; ++ i ) { A [ i ] += A [ i - 1 ] ; } int ans = 0 ; unordered_set < int > s ; for ( int i = 0 ; i < N ; ++ i ) { if ( s . find ( A [ i ] ) == s . end ( ) ) ans += A [ i ] ; s . insert ( A [ i ] ) ; } return ans ; }
void kthpair ( int n , int k , int arr [ ] ) { int i , t ; sort ( arr , arr + n ) ; -- k ; for ( i = 0 ; i < n ; i += t ) { for ( t = 1 ; arr [ i ] == arr [ i + t ] ; ++ t ) ; if ( t * n > k ) break ; k = k - t * n ; } cout << arr [ i ] << ' ' << arr [ k / t ] ; }
int minOperations ( string s ) { int freq [ 26 ] = { 0 } ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { freq [ s [ i ] - 'A' ] ++ ; } sort ( freq , freq + 26 , greater < int > ( ) ) ; int answer = n ; for ( int i = 1 ; i <= 26 ; i ++ ) { if ( n % i == 0 ) { int x = n / i ; int y = 0 ; for ( int j = 0 ; j < i ; j ++ ) { y += min ( freq [ j ] , x ) ; } answer = min ( answer , n - y ) ; } } return answer ; }
void printArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << ' ' ; } }
void sortArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; ) { if ( arr [ i ] == i + 1 ) { i ++ ; } else { swap ( & arr [ i ] , & arr [ arr [ i ] - 1 ] ) ; } } }
bool fun ( int arr [ ] , int n , int k ) { vector < int > v ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i ; j < n ; j += k ) { v . push_back ( arr [ j ] ) ; } sort ( v . begin ( ) , v . end ( ) ) ; int x = 0 ; for ( int j = i ; j < n ; j += k ) { arr [ j ] = v [ x ] ; x ++ ; } v . clear ( ) ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) return false ; } return true ; }
void CheckSort ( vector < int > arr , int k , int n ) { vector < int > sortarr ( arr . begin ( ) , arr . end ( ) ) ; sort ( sortarr . begin ( ) , sortarr . end ( ) ) ; if ( k == 1 ) printf ( "yes" ) ; else { int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { flag = 0 ; for ( int j = i ; j < n ; j += k ) { if ( sortarr [ i ] == arr [ j ] ) { swap ( arr [ i ] , arr [ j ] ) ; flag = 1 ; break ; } if ( j + k >= n ) break ; } if ( flag == 0 ) break ; } if ( flag == 0 ) printf ( "Not possible to sort" ) ; else printf ( "Possible to sort" ) ; } }
void sortedAdjacentDifferences ( int arr [ ] , int n ) { int ans [ n ] ; sort ( arr + 0 , arr + n ) ; int l = 0 , r = n - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 ) { ans [ i ] = arr [ l ] ; l ++ ; } else { ans [ i ] = arr [ r ] ; r -- ; } } for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << " " ; } }
int get_permutation ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { result += abs ( arr [ i ] - ( i + 1 ) ) ; } return result ; }
int minimumIncDec ( int arr [ ] , int N , int maxE , int minE ) { if ( N == 0 ) { return 0 ; } if ( dp [ N ] [ maxE ] ) return dp [ N ] [ maxE ] ; int ans = INT_MAX ; for ( int k = minE ; k <= maxE ; k ++ ) { int x = minimumIncDec ( arr , N - 1 , k , minE ) ; ans = min ( ans , x + abs ( arr [ N - 1 ] - k ) ) ; } dp [ N ] [ maxE ] = ans ; return dp [ N ] [ maxE ] ; }
int maxSumArrangement ( int A [ ] , int R [ ] [ 2 ] , int N , int M ) { int count [ N ] ; memset ( count , 0 , sizeof count ) ; for ( int i = 0 ; i < M ; ++ i ) { int l = R [ i ] [ 0 ] , r = R [ i ] [ 1 ] + 1 ; l -- ; r -- ; count [ l ] ++ ; if ( r < N ) count [ r ] -- ; } for ( int i = 1 ; i < N ; ++ i ) { count [ i ] += count [ i - 1 ] ; } for ( int i = 0 ; i < N ; ++ i ) { cout << count [ i ] ; } int ans = 0 ; sort ( count , count + N ) ; sort ( A , A + N ) ; for ( int i = 0 ; i < N ; ++ i ) { cout << endl << A [ i ] ; } for ( int i = N - 1 ; i >= 0 ; -- i ) { ans += A [ i ] * count [ i ] ; } return ans ; }
int make_permutation ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += abs ( i + 1 - arr [ i ] ) ; return ans ; }
int maxSum ( vector < vector < int > > & V , int n , int m ) { int ans = 0 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { vector < pair < int , int > > aux ; for ( int j = 0 ; j < m ; ++ j ) { aux . push_back ( { V [ i + 1 ] [ j ] , j } ) ; } sort ( aux . begin ( ) , aux . end ( ) ) ; reverse ( aux . begin ( ) , aux . end ( ) ) ; for ( int j = 0 ; j < m ; ++ j ) { for ( int k = 0 ; k < m ; ++ k ) { if ( aux [ k ] . second - j == 0 || abs ( aux [ k ] . second - j ) > 1 ) { V [ i ] [ j ] += aux [ k ] . first ; break ; } } } } for ( int i = 0 ; i < m ; ++ i ) { ans = max ( ans , V [ 0 ] [ i ] ) ; } return ans ; }
int minimumProduct ( int * arr , int n ) { sort ( arr , arr + n ) ; int product = 1 ; for ( int i = 0 ; i < n ; i += 2 ) { product *= ( arr [ i ] + arr [ i + 1 ] ) ; } return product ; }
bool isVowel ( char ch ) { ch = toupper ( ch ) ; return ( ch == 'A' ch == 'E' ch == 'I' ch == 'O' ch == 'U' ) ; }
void sortArr ( string arr [ ] , int n ) { vector < pair < int , string > > vp ; for ( int i = 0 ; i < n ; i ++ ) { vp . push_back ( make_pair ( countVowels ( arr [ i ] ) , arr [ i ] ) ) ; } sort ( vp . begin ( ) , vp . end ( ) ) ; for ( int i = 0 ; i < vp . size ( ) ; i ++ ) cout << vp [ i ] . second << " " ; }
bool checkIsGP ( double arr [ ] , int n ) { if ( n == 1 ) return true ; sort ( arr , arr + n ) ; double r = arr [ 1 ] / arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] / arr [ i - 1 ] != r ) return false ; } return true ; }
bool checkIsHP ( double arr [ ] , int n ) { if ( n == 1 ) { return true ; } double rec [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { rec [ i ] = ( ( 1 / arr [ i ] ) ) ; } if ( checkIsAP ( rec , n ) ) return true ; else return false ; }
int reversDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }
void sortArr ( int arr [ ] , int n ) { vector < pair < int , int > > vp ; for ( int i = 0 ; i < n ; i ++ ) { vp . push_back ( make_pair ( reversDigits ( arr [ i ] ) , arr [ i ] ) ) ; } sort ( vp . begin ( ) , vp . end ( ) ) ; for ( int i = 0 ; i < vp . size ( ) ; i ++ ) cout << vp [ i ] . second << " " ; }
void sortMat ( int data [ N ] [ M ] , int row , int col ) { int size = row * col ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = 0 ; j < size - 1 ; j ++ ) { if ( data [ j / col ] [ j % col ] > data [ ( j + 1 ) / col ] [ ( j + 1 ) % col ] ) { int temp = data [ j / col ] [ j % col ] ; data [ j / col ] [ j % col ] = data [ ( j + 1 ) / col ] [ ( j + 1 ) % col ] ; data [ ( j + 1 ) / col ] [ ( j + 1 ) % col ] = temp ; } } } }
int minimiseMedian ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; return abs ( arr [ n / 2 ] - arr [ ( n / 2 ) - 1 ] ) ; }
int sortByFreq ( int * arr , int n ) { int maxE = -1 ; for ( int i = 0 ; i < n ; i ++ ) { maxE = max ( maxE , arr [ i ] ) ; } int freq [ maxE + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int cnt = 0 ; for ( int i = 0 ; i <= maxE ; i ++ ) { if ( freq [ i ] > 0 ) { int value = 100000 - i ; arr [ cnt ] = 100000 * freq [ i ] + value ; cnt ++ ; } } return cnt ; }
void printSortedArray ( int * arr , int cnt ) { for ( int i = 0 ; i < cnt ; i ++ ) { int frequency = arr [ i ] / 100000 ; int value = 100000 - ( arr [ i ] % 100000 ) ; for ( int j = 0 ; j < frequency ; j ++ ) { cout << value << ' ' ; } } }
bool canBeEqual ( int a , int b , int c , int k ) { int arr [ 3 ] ; arr [ 0 ] = a ; arr [ 1 ] = b ; arr [ 2 ] = c ; sort ( arr , arr + 3 ) ; int diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; k = k - diff ; if ( k < 0 k % 3 != 0  ) return false ; return true ; }
int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return -1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( ( arr [ l ] == arr [ mid ] ) && ( arr [ h ] == arr [ mid ] ) ) { ++ l ; -- h ; return search ( arr , l , h , key ) ; } if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; }
vector < int > orgazineInOrder ( vector < int > vec , vector < int > op , int n ) { vector < int > result ( n ) ; sort ( vec . begin ( ) , vec . end ( ) ) ; int i = 0 , j = n - 1 , k = 0 ; while ( i <= j && k <= n - 2 ) { if ( op [ k ] == '<' ) { result [ k ] = vec [ i ++ ] ; } else { result [ k ] = vec [ j -- ] ; } k ++ ; } result [ n - 1 ] = vec [ i ] ; return result ; }
int minimumCost ( ll price [ ] , int n ) { sort ( price , price + n ) ; ll totalCost = 0 ; for ( int i = n - 1 ; i > 1 ; i -= 2 ) { if ( i == 2 ) { totalCost += price [ 2 ] + price [ 0 ] ; } else { ll price_first = price [ i ] + price [ 0 ] + 2 * price [ 1 ] ; ll price_second = price [ i ] + price [ i - 1 ] + 2 * price [ 0 ] ; totalCost += min ( price_first , price_second ) ; } } if ( n == 1 ) { totalCost += price [ 0 ] ; } else { totalCost += price [ 1 ] ; } return totalCost ; }
bool checkRectangles ( int * arr , int n ) { bool ans = true ; sort ( arr , arr + 4 * n ) ; int area = arr [ 0 ] * arr [ 4 * n - 1 ] ; for ( int i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) { ans = false ; break ; } } if ( ans ) return true ; return false ; }
int findMin ( int * arr , int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n and arr [ j ] > = arr [ j - 1 ] ) j ++ ; ans = max ( ans , j - i )  ; i = j - 1 ; } return n - ans ; }
int countSubSeq ( int a [ ] , int n , int k ) { sort ( a , a + n ) ; vector < int > arr ; for ( int i = 0 ; i < n ; ) { int count = 1 , x = a [ i ] ; i ++ ; while ( i < n && a [ i ] == x ) { count ++ ; i ++ ; } arr . push_back ( count ) ; } int m = arr . size ( ) ; n = min ( m , k ) ; int count = 1 ; int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = m ; j >= 0 ; j -- ) { if ( j > m - i ) dp [ i ] [ j ] = 0 ; else { dp [ i ] [ j ] = dp [ i ] [ j + 1 ] + arr [ j ] * dp [ i - 1 ] [ j + 1 ] ; } } count = count + dp [ i ] [ 0 ] ; } return count ; }
int maxMod ( int arr [ ] , int n ) { int maxVal = * max_element ( arr , arr + n ) ; int secondMax = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < maxVal && arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } } return secondMax ; }
string partOdd ( string s ) { string st = "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( i % 2 != 0 ) st += s [ i ] ; } return st ; }
string partEven ( string str ) { string s = "" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( i % 2 == 0 ) s += str [ i ] ; } return s ; }
void sortStack ( stack < int > & input , int k ) { stack < int > tmpStack ; while ( ! input . empty ( ) ) { int tmp = input . top ( ) ; input . pop ( ) ; while ( ! tmpStack . empty ( ) ) { int tmpStackMod = tmpStack . top ( ) % k ; int tmpMod = tmp % k ; if ( ( tmpStackMod > tmpMod ) || ( tmpStackMod == tmpMod && tmpStack . top ( ) > tmp ) ) { input . push ( tmpStack . top ( ) ) ; tmpStack . pop ( ) ; } else break ; } tmpStack . push ( tmp ) ; } while ( ! tmpStack . empty ( ) ) { input . push ( tmpStack . top ( ) ) ; tmpStack . pop ( ) ; } while ( ! input . empty ( ) ) { cout << input . top ( ) << " " ; input . pop ( ) ; } }
int maxLen ( int * arr , int n ) { int c_sum = 0 ; sort ( arr , arr + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { c_sum += arr [ i ] ; if ( c_sum < 0 ) return i ; } return n ; }
bool isPossible ( int range [ ] [ 3 ] , int N ) { interval test [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { test [ i ] . l = range [ i ] [ 0 ] ; test [ i ] . r = range [ i ] [ 1 ] ; test [ i ] . v = range [ i ] [ 2 ] ; } sort ( test , test + N , cmp ) ; for ( int i = 0 ; i < N ; i ++ ) { int count [ MAX ] = { 0 } ; int current_velocity = test [ i ] . v ; int j = i ; while ( j < N && test [ j ] . v == current_velocity ) { for ( int k = test [ j ] . l ; k <= test [ j ] . r ; k ++ ) { count [ k ] ++ ; if ( count [ k ] >= 3 ) return false ; } j ++ ; } i = j - 1 ; } return true ; }
int maxSum ( int a [ ] , int n ) { sort ( a , a + n ) ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i += 2 ) { sum += a [ i ] ; } return sum ; }
int minSteps ( int arr [ ] , int n ) { int maxVal = * max_element ( arr , arr + n ) ; return maxVal ; }
bool isPossible ( int A [ ] , int B [ ] , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; sort ( A , A + n ) ; sort ( B , B + m ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; }
void sortWithRemainder ( int arr [ ] , int n , int k ) { vector < int > v [ k ] ; for ( int i = 0 ; i < n ; i ++ ) { v [ arr [ i ] % k ] . push_back ( arr [ i ] ) ; } for ( int i = 0 ; i < k ; i ++ ) sort ( v [ i ] . begin ( ) , v [ i ] . end ( ) ) ; int j = 0 ; for ( int i = 0 ; i < k ; i ++ ) { for ( vector < int > :: iterator it = v [ i ] . begin ( ) ; it != v [ i ] . end ( ) ; it ++ ) { arr [ j ] = * it ; j ++ ; } } printArr ( arr , n ) ; }
int minOperations ( vector < int > ar , int k ) { sort ( ar . begin ( ) , ar . end ( ) ) ; int opsNeeded = 0 ; for ( int i = 0 ; i < k ; i ++ ) { opsNeeded += ar [ k - 1 ] - ar [ i ] ; } int ans = opsNeeded ; for ( int i = k ; i < ar . size ( ) ; i ++ ) { opsNeeded = opsNeeded - ( ar [ i - 1 ] - ar [ i - k ] ) ; opsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) ; ans = min ( ans , opsNeeded ) ; } return ans ; }
int getNumber ( int n , int k ) { int arr [ n ] ; int i = 0 ; int odd = 1 ; while ( odd <= n ) { arr [ i ++ ] = odd ; odd += 2 ; } int even = 2 ; while ( even <= n ) { arr [ i ++ ] = even ; even += 2 ; } return arr [ k - 1 ] ; }
int getNumber ( int n , int k ) { int pos ; if ( n % 2 == 0 ) { pos = n / 2 ; } else { pos = ( n / 2 ) + 1 ; } if ( k <= pos ) { return ( k * 2 - 1 ) ; } else return ( ( k - pos ) * 2 ) ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
int CountPermutation ( int a [ ] , int n ) { int ways = 1 ; sort ( a , a + n ) ; int size = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { size ++ ; } else { ways *= fact [ size ] ; size = 1 ; } } ways *= fact [ size ] ; return ways ; }
void dfs ( int num , int left , int ct ) { if ( ct >= 15 ) return ; if ( left == 0 ) ans . insert ( num ) ; for ( int i = 0 ; i <= min ( left , 9LL ) ; i ++ ) dfs ( num * 10 + i , left - i , ct + 1 ) ; }
int getKthNum ( int m , int k ) { dfs ( 0 , m , 0 ) ; int ct = 0 ; for ( auto it : ans ) { ct ++ ; if ( ct == k ) { return it ; } } return -1 ; }
int Min_Replace ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int freq [ MAX ] ; memset ( freq , 0 , sizeof freq ) ; int p = 0 ; freq [ p ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } sort ( freq , freq + n , greater < int > ( ) ) ; int ans = 0 ; for ( int i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; }
int minCost ( int cost [ ] [ N ] ) { int dist [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; }
int Segment ( int x [ ] , int l [ ] , int n ) { if ( n == 1 ) return 1 ; int ans = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ; else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) { x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } } return ans ; }
int Next_greater ( int a [ ] , int n , int x ) { sort ( a , a + n ) ; int low = 0 , high = n - 1 , ans = x + 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( a [ mid ] <= ans ) { if ( a [ mid ] == ans ) { ans ++ ; high = n - 1 ; } low = mid + 1 ; } else high = mid - 1 ; } return ans ; }
void Combination ( vector < int > A , int K ) { sort ( A . begin ( ) , A . end ( ) ) ; vector < int > local ; unique_combination ( 0 , 0 , K , local , A ) ; }
void xorOnSortedArray ( int arr [ ] , int n , int k , int x ) { int arr1 [ MAX + 1 ] = { 0 } ; int arr2 [ MAX + 1 ] = { 0 } ; int xor_val [ MAX + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) arr1 [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= MAX ; i ++ ) xor_val [ i ] = i ^ x ; while ( k -- ) { int count = 0 ; for ( int i = 0 ; i <= MAX ; i ++ ) { int store = arr1 [ i ] ; if ( arr1 [ i ] > 0 ) { if ( count % 2 == 0 ) { int div = ceil ( ( float ) arr1 [ i ] / 2 ) ; arr1 [ i ] = arr1 [ i ] - div ; arr2 [ xor_val [ i ] ] += div ; } else if ( count % 2 != 0 ) { int div = arr1 [ i ] / 2 ; arr1 [ i ] = arr1 [ i ] - div ; arr2 [ xor_val [ i ] ] += div ; } } count = count + store ; } for ( int i = 0 ; i <= MAX ; i ++ ) { arr1 [ i ] = arr1 [ i ] + arr2 [ i ] ; arr2 [ i ] = 0 ; } } int min = INT_MAX ; int max = INT_MIN ; for ( int i = 0 ; i <= MAX ; i ++ ) { if ( arr1 [ i ] > 0 ) { if ( min > i ) min = i ; if ( max < i ) max = i ; } } cout << min << " " << max << endl ; }
int pairs_count ( int arr [ ] , int n , int sum ) { int ans = 0 ; sort ( arr , arr + n ) ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { int x = arr [ i ] , xx = i ; while ( i < j and arr [ i ] == x ) i ++ ; int y = arr [ j ] , yy = j ; while ( j >= i and arr [ j ] == y ) j -- ; if ( x == y ) { int temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; }
vector < int > findSubarray ( int a [ ] , int k , int n ) { vector < vector < int > > vec ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { vector < int > temp ; for ( int j = i ; j < i + k ; j ++ ) { temp . push_back ( a [ j ] ) ; } vec . push_back ( temp ) ; } sort ( vec . begin ( ) , vec . end ( ) ) ; return vec [ vec . size ( ) - 1 ] ; }
float knapSack ( int W , float wt [ ] , float val [ ] , int n ) { float maxratio = INT_MIN ; int maxindex = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( val [ i ] / wt [ i ] ) > maxratio ) { maxratio = ( val [ i ] / wt [ i ] ) ; maxindex = i ; } } return ( W * maxratio ) ; }
void sortArray ( int a [ ] , int n ) { vector < int > ans ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) ans . push_back ( a [ i ] ) ; } sort ( ans . begin ( ) , ans . end ( ) ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) { a [ i ] = ans [ j ] ; j ++ ; } } for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << " " ; }
int solution ( vector < int > & arr , int x ) { int closestSum = INT_MAX ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < arr . size ( ) ; j ++ ) { for ( int k = j + 1 ; k < arr . size ( ) ; k ++ ) { if ( abs ( x - closestSum ) > abs ( x - ( arr [ i ] + arr [ j ] + arr [ k ] ) ) ) closestSum = ( arr [ i ] + arr [ j ] + arr [ k ] ) ; } } } return closestSum ; }
int solution ( vector < int > & arr , int x ) { sort ( arr . begin ( ) , arr . end ( ) ) ; int closestSum = 1000000000 ; for ( int i = 0 ; i < arr . size ( ) - 2 ; i ++ ) { int ptr1 = i + 1 , ptr2 = arr . size ( ) - 1 ; while ( ptr1 < ptr2 ) { int sum = arr [ i ] + arr [ ptr1 ] + arr [ ptr2 ] ; if ( abs ( 1LL * x - sum ) < abs ( 1LL * x - closestSum ) ) { closestSum = sum ; } if ( sum > x ) { ptr2 -- ; } else { ptr1 ++ ; } } } return closestSum ; }
vector < int > makearray ( vector < vector < int > > v , int V ) { vector < int > adj [ V ] ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { for ( int j = 0 ; j < v [ i ] . size ( ) - 1 ; j ++ ) { addEdge ( adj , v [ i ] [ j ] , v [ i ] [ j + 1 ] ) ; } } vector < int > indeg ( V , 0 ) ; getindeg ( adj , V , indeg ) ; vector < int > res = topo ( adj , V , indeg ) ; return res ; }
bool existsTriplet ( int a [ ] , int b [ ] , int c [ ] , int x , int l1 , int l2 , int l3 ) { if ( l2 <= l1 and l2 <= l3 ) swap ( l2 , l1 ) , swap ( a , b ) ; else if ( l3 <= l1 and l3 <= l2 ) swap ( l3 , l1 ) , swap ( a , c ) ; for ( int i = 0 ; i < l1 ; i ++ ) { int j = 0 , k = l3 - 1 ; while ( j < l2 and k > = 0 ) { if ( a [ i ] + b [ j ] + c [ k ] == x ) return true ; if ( a [ i ] + b [ j ] + c [ k ] < x ) j ++ ; else k -- ; } } return false ; }
void compressArr ( int arr [ ] , int n ) { int i = 0 , j = 0 ; sort ( arr , arr + n ) ; while ( i < n ) { j = i ; while ( ( j + 1 < n ) && ( arr [ j + 1 ] == arr [ j ] + 1 ) ) { j ++ ; } if ( i == j ) { cout << arr [ i ] << " " ; i ++ ; } else { cout << arr [ i ] << "-" << arr [ j ] << " " ; i = j + 1 ; } } }
int partition ( char arr [ ] , int low , int high , int mod ) { char pivot = arr [ high ] ; int i = ( low - 1 ) ; int piv = pivot % mod ; for ( int j = low ; j <= high - 1 ; j ++ ) { int a = arr [ j ] % mod ; if ( a <= piv ) { i ++ ; swap ( & arr [ i ] , & arr [ j ] ) ; } } swap ( & arr [ i + 1 ] , & arr [ high ] ) ; return ( i + 1 ) ; }
void printArray ( char arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " " ; }
bool check ( int * arr , int n ) { int modify = 0 ; if ( arr [ n - 1 ] >= arr [ n - 2 ] ) { arr [ n - 1 ] = arr [ n - 2 ] - 1 ; modify ++ ; } if ( arr [ 0 ] <= arr [ 1 ] ) { arr [ 0 ] = arr [ 1 ] + 1 ; modify ++ ; } for ( int i = n - 2 ; i > 0 ; i -- ) { if ( ( arr [ i - 1 ] <= arr [ i ] && arr [ i + 1 ] <= arr [ i ] ) || ( arr [ i - 1 ] >= arr [ i ] && arr [ i + 1 ] >= arr [ i ] ) ) { arr [ i ] = ( arr [ i - 1 ] + arr [ i + 1 ] ) / 2 ; modify ++ ; if ( arr [ i ] == arr [ i - 1 ] arr [ i ] == arr [ i + 1 ] ) return false ; } } if ( modify > 1 ) return false ; return true ; }
void inorder ( Node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; cout << root -> data << " " ; inorder ( root -> right ) ; } }
void merge ( Node * root1 , Node * root2 ) { if ( ! root1 && ! root2 ) return ; if ( ! root1 ) { inorder ( root2 ) ; return ; } if ( ! root2 ) { inorder ( root1 ) ; return ; } Node * temp1 = root1 ; Node * prev1 = NULL ; while ( temp1 -> left ) { prev1 = temp1 ; temp1 = temp1 -> left ; } Node * temp2 = root2 ; Node * prev2 = NULL ; while ( temp2 -> left ) { prev2 = temp2 ; temp2 = temp2 -> left ; } if ( temp1 -> data <= temp2 -> data ) { cout << temp1 -> data << " " ; if ( prev1 == NULL ) { merge ( root1 -> right , root2 ) ; } else { prev1 -> left = temp1 -> right ; merge ( root1 , root2 ) ; } } else { cout << temp2 -> data << " " ; if ( prev2 == NULL ) { merge ( root1 , root2 -> right ) ; } else { prev2 -> left = temp2 -> right ; merge ( root1 , root2 ) ; } } }
bool IsSorted ( int A [ ] , int B [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int x , y ; x = max ( A [ i ] , B [ i ] ) ; y = min ( A [ i ] , B [ i ] ) ; A [ i ] = x ; B [ i ] = y ; } for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] <= A [ i - 1 ] B [ i ] <= B [ i - 1 ] ) return false ; } return true ; }
void removeElements ( int arr [ ] , int n ) { int brr [ n ] , l = 1 ; brr [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( brr [ l - 1 ] <= arr [ i ] ) { brr [ l ] = arr [ i ] ; l ++ ; } } for ( int i = 0 ; i < l ; i ++ ) cout << brr [ i ] << " " ; }
int maxWater ( int height [ ] , int n ) { int maximum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int current = ( min ( height [ i ] , height [ j ] ) * ( j - i - 1 ) ) ; maximum = max ( maximum , current ) ; } } return maximum ; }
int maxSelectionCount ( int a [ ] , int n ) { int res = 0 ; sort ( a , a + n ) ; int select = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= select ) { res ++ ; select ++ ; } } return res ; }
void findCombinations ( int n ) { int a [ n ] ; findCombinationsUtil ( a , 0 , n , n ) ; }
bool check ( int arr [ ] , int n ) { int modify = 0 ; if ( arr [ 0 ] > arr [ 1 ] ) { arr [ 0 ] = arr [ 1 ] / 2 ; modify ++ ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( arr [ i - 1 ] < arr [ i ] && arr [ i + 1 ] < arr [ i ] ) || ( arr [ i - 1 ] > arr [ i ] && arr [ i + 1 ] > arr [ i ] ) ) { arr [ i ] = ( arr [ i - 1 ] + arr [ i + 1 ] ) / 2 ; if ( arr [ i ] == arr [ i - 1 ] arr [ i ] == arr [ i + 1 ] ) return false ; modify ++ ; } } if ( arr [ n - 1 ] < arr [ n - 2 ] ) modify ++ ; if ( modify > 1 ) return false ; return true ; }
bool checkDivisors ( int a [ ] , int n ) { int X = * max_element ( a , a + n ) ; vector < int > b ; for ( int i = 1 ; i * i <= X ; i ++ ) { if ( X % i == 0 ) { b . push_back ( i ) ; if ( X / i != i ) b . push_back ( X / i ) ; } } if ( b . size ( ) != n ) return false ; sort ( a , a + n ) ; sort ( b . begin ( ) , b . end ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( b [ i ] != a [ i ] ) return false ; } return true ; }
int findX ( int a [ ] , int n ) { sort ( a , a + n ) ; int x = a [ 0 ] * a [ n - 1 ] ; vector < int > vec ; for ( int i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { vec . push_back ( i ) ; if ( ( x / i ) != i ) vec . push_back ( x / i ) ; } } sort ( vec . begin ( ) , vec . end ( ) ) ; if ( vec . size ( ) != n ) return -1 ; else { int i = 0 ; for ( auto it : vec ) { if ( a [ i ++ ] != it ) return -1 ; } } return x ; }
void seive ( ) { for ( int i = 2 ; i < N ; i ++ ) { if ( ! prime [ i ] ) { for ( int j = i + i ; j < N ; j += i ) { prime [ j ] = 1 ; } } } prime [ 1 ] = 1 ; }
int maxSizeArr ( int * arr , int n , int k ) { vector < int > v , diff ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) v . push_back ( i ) ; } for ( int i = 1 ; i < v . size ( ) ; i ++ ) { diff . push_back ( v [ i ] - v [ i - 1 ] - 1 ) ; } sort ( diff . begin ( ) , diff . end ( ) ) ; for ( int i = 1 ; i < diff . size ( ) ; i ++ ) { diff [ i ] += diff [ i - 1 ] ; } if ( k > n || ( k == 0 && v . size ( ) ) ) { return -1 ; } else if ( v . size ( ) <= k ) { return ( n - k ) ; } else if ( v . size ( ) > k ) { int tt = v . size ( ) - k ; int sum = 0 ; sum += diff [ tt - 1 ] ; int res = n - ( v . size ( ) + sum ) ; return res ; } }
void pendulumArrangement ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int odd , temp , in , pos ; pos = n - 1 ; if ( n % 2 == 0 ) odd = n - 1 ; else odd = n - 2 ; while ( odd > 0 ) { temp = arr [ odd ] ; in = odd ; while ( in != pos ) { arr [ in ] = arr [ in + 1 ] ; in ++ ; } arr [ in ] = temp ; odd = odd - 2 ; pos = pos - 1 ; } int start = 0 , end = ( n - 1 ) / 2 ; for ( ; start < end ; start ++ , end -- ) { temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; } for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
long long CountSubset ( int * arr , int n ) { long long ans = powmod ( 2 , n - 1 ) ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; ++ i ) { int j = i + 1 ; while ( j < n && arr [ j ] == arr [ i ] ) { int r = n - 1 - j ; int l = i ; ans = ( ans + nCr ( l + r , l ) ) % mod ; j ++ ; } } return ans ; }
void Preprocess ( ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= 1000 ; ++ i ) { arr [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i ; ++ j ) { arr [ i ] [ j ] = ( arr [ i - 1 ] [ j - 1 ] + arr [ i - 1 ] [ j ] ) % mod ; } arr [ i ] [ i ] = 1 ; } }
long long powmod ( long long a , long long n ) { if ( ! n ) return 1 ; long long pt = powmod ( a , n / 2 ) ; pt = ( pt * pt ) % mod ; if ( n % 2 ) return ( pt * a ) % mod ; else return pt ; }
long long CountSubset ( int * val , int n ) { long long ans = powmod ( 2 , n - 1 ) ; sort ( val , val + n ) ; for ( int i = 0 ; i < n ; ++ i ) { int j = i + 1 ; while ( j < n && val [ j ] == val [ i ] ) { int r = n - 1 - j ; int l = i ; ans = ( ans + arr [ l + r ] [ l ] ) % mod ; j ++ ; } } return ans ; }
void reArrange ( string words [ ] , int n ) { map < string , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ words [ i ] ] = i + 1 ; sort ( words , words + n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << mp [ words [ i ] ] << " " ; }
int findNumber ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int max = arr [ n - 1 ] ; int table [ ( 2 * max ) + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) table [ i ] = INT_MAX ; int ans = -1 ; for ( int i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] <= i ) { int res = table [ i - arr [ j ] ] ; if ( res != INT_MAX && res + 1 < table [ i ] ) table [ i ] = res + 1 ; } } if ( i > arr [ n - 1 ] && table [ i ] == INT_MAX ) { ans = i ; break ; } } return ans ; }
ll power ( ll x , unsigned ll y ) { unsigned ll res = 1 ; x = x % MOD ; while ( y > 0 ) { if ( y & 1 ) { res = ( res * x ) % MOD ; } y = y >> 1 ; x = ( x * x ) % MOD ; } return res % MOD ; }
void combi ( int n , int k ) { int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] % MOD + C [ i - 1 ] [ j ] % MOD ) % MOD ; } } }
int findSumofEle ( int arr1 [ ] , int m , int arr2 [ ] , int n ) { int hash [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) hash [ arr2 [ i ] ] ++ ; for ( int i = 1 ; i < MAX ; i ++ ) hash [ i ] = hash [ i ] + hash [ i - 1 ] ; int maximumFreq = 0 ; for ( int i = 0 ; i < m ; i ++ ) maximumFreq = max ( maximumFreq , hash [ arr1 [ i ] ] ) ; int sumOfElements = 0 ; for ( int i = 0 ; i < m ; i ++ ) sumOfElements += ( maximumFreq == hash [ arr1 [ i ] ] ) ? arr1 [ i ] : 0 ; return sumOfElements ; }
int MinimizeleftOverSum ( int a [ ] , int n ) { vector < int > v1 , v2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 ) v1 . push_back ( a [ i ] ) ; else v2 . push_back ( a [ i ] ) ; } if ( v1 . size ( ) > v2 . size ( ) ) { sort ( v1 . begin ( ) , v1 . end ( ) ) ; sort ( v2 . begin ( ) , v2 . end ( ) ) ; int x = v1 . size ( ) - v2 . size ( ) - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v1 [ i ++ ] ; } return sum ; } else if ( v2 . size ( ) > v1 . size ( ) ) { sort ( v1 . begin ( ) , v1 . end ( ) ) ; sort ( v2 . begin ( ) , v2 . end ( ) ) ; int x = v2 . size ( ) - v1 . size ( ) - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v2 [ i ++ ] ; } return sum ; } else return 0 ; }
void printList ( Node * head ) { while ( head ) { cout << head -> data << " " ; head = head -> next ; } }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] ; }
bool compare ( int num1 , int num2 ) { string A = to_string ( num1 ) ; string B = to_string ( num2 ) ; return ( A + B ) <= ( B + A ) ; }
void printSmallest ( int N , int arr [ ] ) { sort ( arr , arr + N , compare ) ; printArr ( arr , N ) ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
bool isUgly ( int n ) { while ( n % 2 == 0 ) n = n / 2 ; while ( n % 3 == 0 ) n = n / 3 ; while ( n % 5 == 0 ) n = n / 5 ; if ( n == 1 ) return true ; return false ; }
void sortUglyNumbers ( int arr [ ] , int n ) { vector < int > list ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( isUgly ( arr [ i ] ) ) { list . push_back ( arr [ i ] ) ; arr [ i ] = -1 ; } } sort ( list . begin ( ) , list . end ( ) ) ; int j = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == -1 ) cout << list [ j ++ ] << " " ; else cout << arr [ i ] << " " ; } }
float getMaxMedian ( int arr [ ] , int n , int k ) { int size = n + k ; sort ( arr , arr + n ) ; if ( size % 2 == 0 ) { float median = ( float ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } float median = arr [ size / 2 ] ; return median ; }
void sortArr ( int arr [ ] , int n , int k ) { int prev = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { if ( prev != -1 ) sort ( arr + prev + 1 , arr + i ) ; prev = i ; } } printArr ( arr , n ) ; }
void findSquare ( int n ) { int points [ n ] [ 2 ] = { { 1 , 2 } , { -3 , 4 } , { 1 , 78 } , { -3 , -7 } } ; int a [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int x , y ; x = points [ i ] [ 0 ] ; y = points [ i ] [ 1 ] ; a [ i ] = max ( mod ( x ) , mod ( y ) ) ; } sort ( a , a + n ) ; int index = floor ( n / 2 ) - 1 ; cout << "Minimum M required is: " << a [ index ] << endl ; }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
void removeMin ( int arr [ ] , int n ) { int i , minVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) minVal = min ( minVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] - minVal ; }
void removeFromMax ( int arr [ ] , int n ) { int i , maxVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) maxVal = max ( maxVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = maxVal - arr [ i ] ; }
void modifyArray ( int arr [ ] , int n , int k ) { if ( k % 2 == 0 ) removeMin ( arr , n ) ; else removeFromMax ( arr , n ) ; printArray ( arr , n ) ; }
int findKth ( int arr [ ] , int n , int k ) { unordered_set < int > missing ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) missing . insert ( arr [ i ] ) ; int maxm = * max_element ( arr , arr + n ) ; int minm = * min_element ( arr , arr + n ) ; for ( int i = minm + 1 ; i < maxm ; i ++ ) { if ( missing . find ( i ) == missing . end ( ) ) count ++ ; if ( count == k ) return i ; } return -1 ; }
void minOperation ( string S , int N , int K ) { if ( N % K ) { cout << "Not Possible" << endl ; return ; } int count [ 26 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { count [ S [ i ] - 97 ] ++ ; } int E = N / K ; vector < int > greaterE ; vector < int > lessE ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] < E ) lessE . push_back ( E - count [ i ] ) ; else greaterE . push_back ( count [ i ] - E ) ; } sort ( greaterE . begin ( ) , greaterE . end ( ) ) ; sort ( lessE . begin ( ) , lessE . end ( ) ) ; int mi = INT_MAX ; for ( int i = 0 ; i <= K ; i ++ ) { int set1 = i ; int set2 = K - i ; if ( greaterE . size ( ) >= set1 && lessE . size ( ) >= set2 ) { int step1 = 0 ; int step2 = 0 ; for ( int j = 0 ; j < set1 ; j ++ ) step1 += greaterE [ j ] ; for ( int j = 0 ; j < set2 ; j ++ ) step2 += lessE [ j ] ; mi = min ( mi , max ( step1 , step2 ) ) ; } } cout << mi << endl ; }
void printPermutations ( int n , int a [ ] , int k ) { pair < int , int > arr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] . first = a [ i ] ; arr [ i ] . second = i ; } sort ( arr , arr + n ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] . first == arr [ i - 1 ] . first ) count ++ ; if ( count < k ) { cout << "-1" ; return ; } for ( int i = 0 ; i < k - 1 ; i ++ ) { printIndices ( n , arr ) ; for ( int j = next_pos ; j < n ; j ++ ) { if ( arr [ j ] . first == arr [ j - 1 ] . first ) { swap ( arr [ j ] , arr [ j - 1 ] ) ; next_pos = j + 1 ; break ; } } } printIndices ( n , arr ) ; }
unsigned long long findAnswer ( int n , vector < int > & arr ) { sort ( arr . begin ( ) , arr . end ( ) ) ; unsigned long long sum = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) { sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ; } return sum ; }
void merge ( int l , int r , int * output ) { int l_in = l * n , r_in = ( ( l + r ) / 2 + 1 ) * n ; int l_c = ( ( l + r ) / 2 - l + 1 ) * n ; int r_c = ( r - ( l + r ) / 2 ) * n ; int l_arr [ l_c ] , r_arr [ r_c ] ; for ( int i = 0 ; i < l_c ; i ++ ) l_arr [ i ] = output [ l_in + i ] ; for ( int i = 0 ; i < r_c ; i ++ ) r_arr [ i ] = output [ r_in + i ] ; int l_curr = 0 , r_curr = 0 ; int in = l_in ; while ( l_curr + r_curr < l_c + r_c ) { if ( r_curr == r_c || ( l_curr != l_c && l_arr [ l_curr ] < r_arr [ r_curr ] ) ) output [ in ] = l_arr [ l_curr ] , l_curr ++ , in ++ ; else output [ in ] = r_arr [ r_curr ] , r_curr ++ , in ++ ; } }
void divide ( int l , int r , int * output , int arr [ ] [ n ] ) { if ( l == r ) { for ( int i = 0 ; i < n ; i ++ ) output [ l * n + i ] = arr [ l ] [ i ] ; return ; } divide ( l , ( l + r ) / 2 , output , arr ) ; divide ( ( l + r ) / 2 + 1 , r , output , arr ) ; merge ( l , r , output ) ; }
int minSum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int x = arr [ n / 2 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += abs ( arr [ i ] - x ) ; return sum ; }
int minOperations ( int n , int m , int k , vector < vector < int > > & matrix ) { vector < int > arr ( n * m , 0 ) ; int mod = matrix [ 0 ] [ 0 ] % k ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { arr [ i * m + j ] = matrix [ i ] [ j ] ; if ( matrix [ i ] [ j ] % k != mod ) { return -1 ; } } } sort ( arr . begin ( ) , arr . end ( ) ) ; int median = arr [ ( n * m ) / 2 ] ; int minOperations = 0 ; for ( int i = 0 ; i < n * m ; ++ i ) minOperations += abs ( arr [ i ] - median ) / k ; if ( ( n * m ) % 2 == 0 ) { int median2 = arr [ ( ( n * m ) / 2 ) - 1 ] ; int minOperations2 = 0 ; for ( int i = 0 ; i < n * m ; ++ i ) minOperations2 += abs ( arr [ i ] - median2 ) / k ; minOperations = min ( minOperations , minOperations2 ) ; } return minOperations ; }
int minOperations ( int n , int m , int k , vector < vector < int > > & matrix ) { vector < int > arr ; int mod ; if ( matrix [ 0 ] [ 0 ] < 0 ) { mod = k - ( abs ( matrix [ 0 ] [ 0 ] ) % k ) ; } else { mod = matrix [ 0 ] [ 0 ] % k ; } for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { arr . push_back ( matrix [ i ] [ j ] ) ; int val = matrix [ i ] [ j ] ; if ( val < 0 ) { int res = k - ( abs ( val ) % k ) ; if ( res != mod ) { return -1 ; } } else { int foo = matrix [ i ] [ j ] ; if ( foo % k != mod ) { return -1 ; } } } } sort ( arr . begin ( ) , arr . end ( ) ) ; int median = arr [ ( n * m ) / 2 ] ; int minOperations = 0 ; for ( int i = 0 ; i < n * m ; ++ i ) minOperations += abs ( arr [ i ] - median ) / k ; if ( ( n * m ) % 2 == 0 ) { int median2 = arr [ ( ( n * m ) / 2 ) - 1 ] ; int minOperations2 = 0 ; for ( int i = 0 ; i < n * m ; ++ i ) minOperations2 += abs ( arr [ i ] - median2 ) / k ; minOperations = min ( minOperations , minOperations2 ) ; } return minOperations ; }
int countDistinct ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 1 ; i < n ; i ++ ) { int j = 0 ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) break ; if ( i == j ) res ++ ; } return res ; }
int countDistinct ( int arr [ ] , int n ) { unordered_set < int > s ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( arr [ i ] ) == s . end ( ) ) { s . insert ( arr [ i ] ) ; res ++ ; } } return res ; }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
void printMaxMean ( int arr [ ] , int n ) { int newArr [ n ] ; sort ( arr , arr + 2 * n ) ; for ( int i = 0 ; i < n ; i ++ ) newArr [ i ] = arr [ i + n ] ; printArray ( newArr , n ) ; }
int Minimum_Cells ( vector < pair < int , int > > v ) { int col [ 3 ] , i , j ; for ( i = 0 ; i < 3 ; i ++ ) { int column_number = v [ i ] . second ; col [ i ] = column_number ; } sort ( col , col + 3 ) ; sort ( v . begin ( ) , v . end ( ) ) ; int MidRow = v [ 1 ] . first ; set < pair < int , int > > s ; int Maxcol = col [ 2 ] , MinCol = col [ 0 ] ; for ( i = MinCol ; i <= Maxcol ; i ++ ) { s . insert ( { MidRow , i } ) ; } for ( i = 0 ; i < 3 ; i ++ ) { if ( v [ i ] . first == MidRow ) continue ; for ( j = min ( v [ i ] . first , MidRow ) ; j <= max ( v [ i ] . first , MidRow ) ; j ++ ) { s . insert ( { j , v [ i ] . second } ) ; } } return s . size ( ) ; }
int countPairs ( int a [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ a [ i ] ] ++ ; sort ( a , a + n , greater < int > ( ) ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp [ a [ i ] ] < 1 ) continue ; int cur = 1 ; while ( cur <= a [ i ] ) cur <<= 1 ; if ( mp [ cur - a [ i ] ] ) { if ( cur - a [ i ] == a [ i ] and mp [ a [ i ] ] == 1 ) continue ; count ++ ; mp [ cur - a [ i ] ] -- ; mp [ a [ i ] ] -- ; } } return count ; }
int countSequences ( int arr [ ] , int n ) { int count = 1 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; }
double average ( int arr [ ] , int n , int k ) { double total = 0 ; if ( 2 * k >= n ) return 0 ; sort ( arr , arr + n ) ; int start = k , end = n - k - 1 ; for ( int i = start ; i <= end ; i ++ ) total += arr [ i ] ; return ( total / ( n - 2 * k ) ) ; }
void partSort ( int arr [ ] , int N , int a , int b ) { int l = min ( a , b ) ; int r = max ( a , b ) ; int temp [ r - l + 1 ] ; int j = 0 ; for ( int i = l ; i <= r ; i ++ ) { temp [ j ] = arr [ i ] ; j ++ ; } sort ( temp , temp + r - l + 1 ) ; j = 0 ; for ( int i = l ; i <= r ; i ++ ) { arr [ i ] = temp [ j ] ; j ++ ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << " " ; } }
void partSort ( int arr [ ] , int N , int a , int b ) { int l = min ( a , b ) ; int r = max ( a , b ) ; vector < int > v ( arr , arr + N ) ; sort ( v . begin ( ) + l , v . begin ( ) + r + 1 ) ; for ( int i = 0 ; i < N ; i ++ ) cout << v [ i ] << " " ; }
int minMovesToSort ( int arr [ ] , int n ) { int moves = 0 ; int i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; } return moves ; }
void transpose ( int mat [ ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) swap ( mat [ i ] [ j ] , mat [ j ] [ i ] ) ; }
void sortMatRowAndColWise ( int mat [ ] [ MAX_SIZE ] , int n ) { sortByRow ( mat , n , true ) ; transpose ( mat , n ) ; sortByRow ( mat , n , false ) ; transpose ( mat , n ) ; }
long long minimumMoves ( int a [ ] , int n ) { long long operations = 0 ; sort ( a , a + n ) ; for ( int i = 0 ; i < n ; i ++ ) operations += abs ( a [ i ] - ( i + 1 ) ) ; return operations ; }
int min_sum ( int n , int k , int a [ ] ) { sort ( a , a + n ) ; if ( a [ 0 ] < 0 ) return -1 ; if ( k == 0 ) { if ( a [ 0 ] == a [ n - 1 ] ) return ( n * a [ 0 ] ) ; else return -1 ; } else { int f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int p = a [ i ] - a [ 0 ] ; if ( p % k == 0 ) continue ; else { f = 1 ; break ; } } if ( f ) return -1 ; else { if ( k == 1 ) return n ; else return ( n * ( a [ 0 ] % k ) ) ; } } }
void printCase ( int n ) { if ( n <= 2 ) { cout << -1 ; return ; } for ( int i = n ; i >= 1 ; i -- ) cout << i << " " ; }
void merge ( int arr [ ] , int start , int mid , int end ) { int start2 = mid + 1 ; if ( arr [ mid ] <= arr [ start2 ] ) { return ; } while ( start <= mid && start2 <= end ) { if ( arr [ start ] <= arr [ start2 ] ) { start ++ ; } else { int value = arr [ start2 ] ; int index = start2 ; while ( index != start ) { arr [ index ] = arr [ index - 1 ] ; index -- ; } arr [ start ] = value ; start ++ ; mid ++ ; start2 ++ ; } } }
void mergeSort ( int arr [ ] , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; mergeSort ( arr , l , m ) ; mergeSort ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } }
int minCost ( int A [ ] , int n ) { int cost = 0 ; sort ( A , A + n ) ; int K = A [ n / 2 ] ; for ( int i = 0 ; i < n ; ++ i ) cost += abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { int tempCost = 0 ; K = A [ ( n / 2 ) - 1 ] ; for ( int i = 0 ; i < n ; ++ i ) tempCost += abs ( A [ i ] - K ) ; cost = min ( cost , tempCost ) ; } return cost ; }
static bool check ( int n , int k , int * a , int * b ) { sort ( a , a + n ) ; sort ( b , b + n ) ; bool fl = false ; int ind = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) { if ( fl == true ) { return false ; } fl = true ; ind = i ; } } if ( ind == -1 | abs ( a [ ind ] - b [ ind ] ) <= k ) { return true ; } return false ; }
int items ( int n , int a [ ] ) { sort ( a , a + n ) ; int z = a [ n - 1 ] ; int x = 1 ; int s = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { s += a [ i ] ; if ( s <= z ) x += 1 ; else break ; } return x ; }
void sortWithSetbits ( int arr [ ] , int n , int k ) { vector < int > v1 , v2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( __builtin_popcount ( arr [ i ] ) == k ) { v1 . push_back ( i ) ; v2 . push_back ( arr [ i ] ) ; } } sort ( v2 . begin ( ) , v2 . end ( ) ) ; for ( int i = 0 ; i < v1 . size ( ) ; i ++ ) arr [ v1 [ i ] ] = v2 [ i ] ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
static int findOptimalSolution ( int a [ ] , int N ) { sort ( a , a + N ) ; int points = 0 ; for ( int i = 0 ; i < N ; i ++ ) { points += a [ i ] * i ; } return points ; }
void printArray ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int l = 0 , r = n - 1 , flag = 0 , i ; int k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) cout << arr [ i ] << " " ; flag = 1 ; l = i ; } { for ( i = r ; i > r - k && i >= l ; i -- ) cout << arr [ i ] << " " ; flag = 0 ; r = i ; } k ++ ; } }
void sortMultiples ( int arr [ ] , int n , int x ) { vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % x == 0 ) v . push_back ( arr [ i ] ) ; sort ( v . begin ( ) , v . end ( ) ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % x == 0 ) arr [ i ] = v [ j ++ ] ; } }
void kThLexString ( string st , int k , int n ) { set < string > z ; for ( int i = 0 ; i < n ; i ++ ) { string pp ; for ( int j = i ; j < i + k ; j ++ ) { if ( j >= n ) break ; pp += st [ j ] ; z . insert ( pp ) ; } } vector < string > fin ( z . begin ( ) , z . end ( ) ) ; sort ( fin . begin ( ) , fin . end ( ) ) ; cout << fin [ k - 1 ] ; }
void SieveOfEratosthenes ( int n ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } }
void sortPrimes ( int arr [ ] , int n ) { SieveOfEratosthenes ( 100005 ) ; vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) v . push_back ( arr [ i ] ) ; } sort ( v . begin ( ) , v . end ( ) , greater < int > ( ) ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) arr [ i ] = v [ j ++ ] ; } }
int number_of_tower ( int house [ ] , int range , int n ) { sort ( house , house + n ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; }
int countPairs ( struct Node * first , struct Node * second , int value ) { int count = 0 ; while ( first != NULL && second != NULL && first != second && second -> next != first ) { if ( ( first -> data * second -> data ) == value ) { count ++ ; first = first -> next ; second = second -> prev ; } else if ( ( first -> data * second -> data ) > value ) second = second -> prev ; else first = first -> next ; } return count ; }
int countTriplets ( struct Node * head , int x ) { if ( head == NULL ) return 0 ; struct Node * current , * first , * last ; int count = 0 ; last = head ; while ( last -> next != NULL ) last = last -> next ; for ( current = head ; current != NULL ; current = current -> next ) { first = current -> next ; count += countPairs ( first , last , x / current -> data ) ; } return count ; }
bool isAlphabaticOrder ( string s ) { int n = s . length ( ) ; char c [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = s [ i ] ; } sort ( c , c + n ) ; for ( int i = 0 ; i < n ; i ++ ) if ( c [ i ] != s [ i ] ) return false ; return true ; }
bool isAlphabaticOrder ( string s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] < s [ i - 1 ] ) return false ; } return true ; }
void SieveOfEratosthenes ( int n ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } }
void sortedArray ( int arr [ ] , int n ) { SieveOfEratosthenes ( 100005 ) ; std :: vector < int > v ; for ( int i = 0 ; i < n ; ++ i ) { if ( prime [ arr [ i ] ] == 0 ) v . push_back ( arr [ i ] ) ; } sort ( v . begin ( ) , v . end ( ) ) ; int j = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( prime [ arr [ i ] ] == true ) cout << arr [ i ] << " " ; else { cout << v [ j ] << " " ; j ++ ; } } }
int findProduct ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) prod = prod * arr [ i ] ; } return prod ; }
int rotateRec ( int n , int L [ ] , int B [ ] ) { int m = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( max ( L [ i ] , B [ i ] ) <= m ) m = max ( L [ i ] , B [ i ] ) ; else if ( min ( L [ i ] , B [ i ] ) <= m ) m = min ( L [ i ] , B [ i ] ) ; else { return 0 ; } } return 1 ; }
int minimumIncrease ( int a , int b , int c ) { int arr [ ] = { a , b , c } ; sort ( arr , arr + 3 ) ; if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; }
bool sortList ( struct Node * head ) { int startVal = 1 ; while ( head != NULL ) { head -> data = startVal ; startVal ++ ; head = head -> next ; } }
void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; }
void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; }
void minDistance ( int n , int k , vector < vector < int > > & point ) { for ( int i = 0 ; i < k ; ++ i ) sort ( point [ i ] . begin ( ) , point [ i ] . end ( ) ) ; for ( int i = 0 ; i < k ; ++ i ) cout << point [ i ] [ ( ceil ( ( double ) n / 2 ) - 1 ) ] << " " ; }
int solve ( int N , int M , int cp [ ] , int sp [ ] ) { int profit [ N ] ; for ( int i = 0 ; i < N ; i ++ ) profit [ i ] = sp [ i ] - cp [ i ] ; sort ( profit , profit + N , greater < int > ( ) ) ; int sum = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( profit [ i ] > 0 ) sum += profit [ i ] ; else break ; } return sum ; }
void printOrder ( int arr [ ] , int n , int k ) { int len1 = k , len2 = n - k ; int arr1 [ k ] , arr2 [ n - k ] ; for ( int i = 0 ; i < k ; i ++ ) arr1 [ i ] = arr [ i ] ; for ( int i = k ; i < n ; i ++ ) arr2 [ i - k ] = arr [ i ] ; sort ( arr1 , arr1 + len1 ) ; sort ( arr2 , arr2 + len2 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) arr [ i ] = arr1 [ i ] ; else { arr [ i ] = arr2 [ len2 - 1 ] ; len2 -- ; } } for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
void findMaxNum ( int arr [ ] , int n ) { int hash [ 10 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( int i = 9 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) cout << i ; } }
int sortK ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; }
int minimumSets ( int arr [ ] , int n , int key ) { int i , j ; sort ( arr , arr + n ) ; for ( i = 0 , j = n - 1 ; i <= j ; ++ i ) if ( arr [ i ] + arr [ j ] <= key ) j -- ; return i ; }
int distribution ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return min ( count , n / 2 ) ; }
int distribution ( int arr [ ] , int n ) { set < int , greater < int > > resources ; for ( int i = 0 ; i < n ; i ++ ) resources . insert ( arr [ i ] ) ; int m = resources . size ( ) ; return min ( m , n / 2 ) ; }
void merge ( int arr [ ] , int beg , int mid , int end , int maxele ) { int i = beg ; int j = mid + 1 ; int k = beg ; while ( i <= mid && j <= end ) { if ( arr [ i ] % maxele <= arr [ j ] % maxele ) { arr [ k ] = arr [ k ] + ( arr [ i ] % maxele ) * maxele ; k ++ ; i ++ ; } else { arr [ k ] = arr [ k ] + ( arr [ j ] % maxele ) * maxele ; k ++ ; j ++ ; } } while ( i <= mid ) { arr [ k ] = arr [ k ] + ( arr [ i ] % maxele ) * maxele ; k ++ ; i ++ ; } while ( j <= end ) { arr [ k ] = arr [ k ] + ( arr [ j ] % maxele ) * maxele ; k ++ ; j ++ ; } for ( int i = beg ; i <= end ; i ++ ) arr [ i ] = arr [ i ] / maxele ; }
void mergeSortRec ( int arr [ ] , int beg , int end , int maxele ) { if ( beg < end ) { int mid = ( beg + end ) / 2 ; mergeSortRec ( arr , beg , mid , maxele ) ; mergeSortRec ( arr , mid + 1 , end , maxele ) ; merge ( arr , beg , mid , end , maxele ) ; } }
void mergeSort ( int arr [ ] , int n ) { int maxele = * max_element ( arr , arr + n ) + 1 ; mergeSortRec ( arr , 0 , n - 1 , maxele ) ; }
void printSorted ( string s , int l ) { stack < char > Stack ; stack < char > tempstack ; Stack . push ( s [ 0 ] ) ; for ( int i = 1 ; i < l ; i ++ ) { int a = s [ i ] ; int b = Stack . top ( ) ; if ( ( a - b ) >= 1 or ( a == b ) ) Stack . push ( s [ i ] ) ; else if ( ( b - a ) >= 1 ) { while ( ( b - a ) >= 1 ) { tempstack . push ( Stack . top ( ) ) ; Stack . pop ( ) ; if ( Stack . size ( ) > 0 ) b = Stack . top ( ) ; else break ; } Stack . push ( s [ i ] ) ; while ( tempstack . size ( ) > 0 ) { Stack . push ( tempstack . top ( ) ) ; tempstack . pop ( ) ; } } } string answer ; while ( Stack . size ( ) > 0 ) { answer = Stack . top ( ) + answer ; Stack . pop ( ) ; } cout << answer << endl ; }
int countTriplets ( int arr [ ] , int n , int a , int b ) { int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] >= a && arr [ i ] + arr [ j ] + arr [ k ] <= b ) ans ++ ; } } return ans ; }
int countTriplets ( int arr [ ] , int n , int a , int b ) { int res ; res = countTripletsLessThan ( arr , n , b ) - countTripletsLessThan ( arr , n , a - 1 ) ; return res ; }
bool checkFittingArrays ( int A [ ] , int B [ ] , int N ) { sort ( A , A + N ) ; sort ( B , B + N ) ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; }
int maximum_toys ( int cost [ ] , int N , int K ) { int count = 0 , sum = 0 ; sort ( cost , cost + N ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( sum + cost [ i ] <= K ) { sum = sum + cost [ i ] ; count ++ ; } } return count ; }
int findMinimumSwaps ( int * arr , int n , int k ) { int pos , num_min , num_max , need_minimum , need_maximum , swaps ; num_min = num_max = need_minimum = 0 ; need_maximum = swaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < k ) num_min ++ ; else if ( arr [ i ] > k ) num_max ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == k ) { pos = i ; break ; } } int left , right , mid ; left = 0 ; right = n - 1 ; while ( left <= right ) { mid = ( left + right ) / 2 ; if ( arr [ mid ] == k ) { break ; } else if ( arr [ mid ] > k ) { if ( pos > mid ) need_minimum ++ ; else num_min -- ; left = mid + 1 ; } else { if ( pos < mid ) need_maximum ++ ; else num_max -- ; right = mid - 1 ; } } if ( need_minimum > need_maximum ) { swaps = swaps + need_maximum ; num_min = num_min - need_maximum ; need_minimum = need_minimum - need_maximum ; need_maximum = 0 ; } else { swaps = swaps + need_minimum ; num_max = num_max - need_minimum ; need_maximum = need_maximum - need_minimum ; need_minimum = 0 ; } if ( need_maximum > num_max need_minimum > num_min ) return -1 ; else return ( swaps + need_maximum + need_minimum ) ; }
void findOptimalPairs ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; for ( int i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) cout << "(" << arr [ i ] << ", " << arr [ j ] << ")" << " " ; }
stack < int > sortStack ( stack < int > & input ) { stack < int > tmpStack ; while ( ! input . empty ( ) ) { int tmp = input . top ( ) ; input . pop ( ) ; while ( ! tmpStack . empty ( ) && tmpStack . top ( ) > tmp ) { input . push ( tmpStack . top ( ) ) ; tmpStack . pop ( ) ; } tmpStack . push ( tmp ) ; } return tmpStack ; }
stack < int > sortedMerge ( stack < int > & s1 , stack < int > & s2 ) { stack < int > res ; while ( ! s1 . empty ( ) ) { res . push ( s1 . top ( ) ) ; s1 . pop ( ) ; } while ( ! s2 . empty ( ) ) { res . push ( s2 . top ( ) ) ; s2 . pop ( ) ; } return sortStack ( res ) ; }
int MaxTotalRectangleArea ( int a [ ] , int n ) { sort ( a , a + n , greater < int > ( ) ) ; int sum = 0 ; bool flag = false ; int len ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == a [ i + 1 ] a [ i ] - a [ i + 1 ] == 1 ) && ( ! flag ) ) { flag = true ; len = a [ i + 1 ] ; i ++ ; } else if ( ( a [ i ] == a [ i + 1 ] a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i ++ ; } } return sum ; }
bool isSortedDesc ( struct Node * head ) { if ( head == NULL ) return true ; for ( Node * t = head ; t -> next != NULL ; t = t -> next ) if ( t -> data <= t -> next -> data ) return false ; return true ; }
void evenOddInsertionSort ( int arr [ ] , int n ) { for ( int i = 2 ; i < n ; i ++ ) { int j = i - 2 ; int temp = arr [ i ] ; if ( ( i + 1 ) & 1 == 1 ) { while ( temp >= arr [ j ] && j >= 0 ) { arr [ j + 2 ] = arr [ j ] ; j -= 2 ; } arr [ j + 2 ] = temp ; } else { while ( temp <= arr [ j ] && j >= 0 ) { arr [ j + 2 ] = arr [ j ] ; j -= 2 ; } arr [ j + 2 ] = temp ; } } }
void sort ( vector < int > a , int n ) { for ( int i = n ; i >= 0 ; i -- ) for ( int j = n ; j > n - i ; j -- ) if ( a [ j ] > a [ j - 1 ] ) swap ( a [ j ] , a [ j - 1 ] ) ; print ( a , n ) ; }
void insertionSort ( Vector & V ) { int N = V . size ( ) ; int i , j , key ; for ( i = 1 ; i < N ; i ++ ) { j = i ; while ( j > 0 and V [ j ] < V [ j - 1 ] ) { swap ( V [ j ] , V [ j - 1 ] ) ; j -= 1 ; } } }
void insertionSortRecursive ( Vector & V , int N ) { if ( N <= 1 ) return ; insertionSortRecursive ( V , N - 1 ) ; int j = N - 1 ; while ( j > 0 and V [ j ] < V [ j - 1 ] ) { swap ( V [ j ] , V [ j - 1 ] ) ; j -= 1 ; } }
void sort012 ( int * arr , int n ) { int count0 = 0 , count1 = 0 , count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) count0 ++ ; if ( arr [ i ] == 1 ) count1 ++ ; if ( arr [ i ] == 2 ) count2 ++ ; } for ( int i = 0 ; i < count0 ; i ++ ) arr [ i ] = 0 ; for ( int i = count0 ; i < ( count0 + count1 ) ; i ++ ) arr [ i ] = 1 ; for ( int i = ( count0 + count1 ) ; i < n ; i ++ ) arr [ i ] = 2 ; return ; }
void printArray ( int * arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; cout << endl ; }
int minElements ( int arr [ ] , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; sort ( arr , arr + n , greater < int > ( ) ) ; int res = 0 , curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; }
int distancesum ( int x [ ] , int y [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) ; return sum ; }
int distancesum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int res = 0 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res += ( arr [ i ] * i - sum ) ; sum += arr [ i ] ; } return res ; }
int totaldistancesum ( int x [ ] , int y [ ] , int n ) { return distancesum ( x , n ) + distancesum ( y , n ) ; }
int minimumBox ( int arr [ ] , int n ) { queue < int > q ; queue < int > q ; sort ( arr , arr + n ) ; q . push ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q . front ( ) ; if ( arr [ i ] >= 2 * now ) q . pop ( ) ; q . push ( arr [ i ] ) ; } return q . size ( ) ; }
void sortRec ( int arr [ ] , int index , int k , int n ) { if ( k == 0 ) { for ( int i = 1 ; i < n ; i ++ ) cout << arr [ i ] << " " ; cout << 999 ; return ; } else if ( k > 0 && index == 0 ) { index = n - 2 ; for ( int i = 1 ; i <= index ; i ++ ) { arr [ i - 1 ] = arr [ i ] ; } arr [ index ] = 999 ; } if ( index - 1 >= 0 && index + 1 < n && arr [ index - 1 ] > arr [ index + 1 ] ) { swap ( arr [ index ] , arr [ index + 1 ] ) ; swap ( arr [ index - 1 ] , arr [ index + 1 ] ) ; } else swap ( arr [ index ] , arr [ index - 1 ] ) ; sortRec ( arr , index - 1 , k - 1 , n ) ; }
void sortString ( string & str ) { int charCount [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) charCount [ str [ i ] - 'a' ] ++ ; for ( int i = MAX_CHAR - 1 ; i >= 0 ; i -- ) for ( int j = 0 ; j < charCount [ i ] ; j ++ ) cout << ( char ) ( 'a' + i ) ; }
void printMedian ( int arr [ ] , int n , int K ) { sort ( arr , arr + n ) ; cout << arr [ ( n + K ) / 2 ] ; }
void stableSelectionSort ( int a [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { int min = i ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ min ] > a [ j ] ) min = j ; int key = a [ min ] ; while ( min > i ) { a [ min ] = a [ min - 1 ] ; min -- ; } a [ i ] = key ; } }
void sortBinaryArray ( int a [ ] , int n ) { int j = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 ) { j ++ ; swap ( a [ i ] , a [ j ] ) ; } } }
bool almostSort ( int A [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { swap ( A [ i ] , A [ i + 1 ] ) ; i ++ ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) if ( A [ i ] > A [ i + 1 ] ) return false ; return true ; }
void minMaxSelectionSort ( int * arr , int n ) { for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { int min = arr [ i ] , max = arr [ i ] ; int min_i = i , max_i = i ; for ( int k = i ; k <= j ; k ++ ) { if ( arr [ k ] > max ) { max = arr [ k ] ; max_i = k ; } else if ( arr [ k ] < min ) { min = arr [ k ] ; min_i = k ; } } swap ( arr [ i ] , arr [ min_i ] ) ; if ( arr [ min_i ] == max ) swap ( arr [ j ] , arr [ min_i ] ) ; else swap ( arr [ j ] , arr [ max_i ] ) ; } }
int nextGap ( int gap ) { if ( gap <= 1 ) return 0 ; return ( gap / 2 ) + ( gap % 2 ) ; }
void arrange ( int arr [ ] , int n , int x ) { for ( int i = 1 ; i < n ; i ++ ) { int diff = abs ( arr [ i ] - x ) ; int j = i - 1 ; if ( abs ( arr [ j ] - x ) > diff ) { int temp = arr [ i ] ; while ( abs ( arr [ j ] - x ) > diff && j >= 0 ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = temp ; } } }
void printOrder ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) cout << arr [ i ] << " " ; for ( int j = n - 1 ; j >= n / 2 ; j -- ) cout << arr [ j ] << " " ; }
int findDuplicate ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int i = 0 ; while ( i < n ) { int j , count = 1 ; for ( j = i + 1 ; j < n && arr [ j ] == arr [ i ] ; j ++ ) count ++ ; if ( count == k ) return arr [ i ] ; i = j ; } return -1 ; }
int findDuplicate ( int arr [ ] , int n , int k ) { int freq [ MAX ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 1 && arr [ i ] > MAX ) { cout << "Out of range" ; return -1 ; } freq [ arr [ i ] ] += 1 ; } for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == k ) return i ; } return -1 ; }
int maxProductSubarrayOfSizeK ( int A [ ] , int n , int k ) { sort ( A , A + n ) ; int product = 1 ; if ( A [ n - 1 ] == 0 && ( k & 1 ) ) return 0 ; if ( A [ n - 1 ] <= 0 && ( k & 1 ) ) { for ( int i = n - 1 ; i >= n - k ; i -- ) product *= A [ i ] ; return product ; } int i = 0 ; int j = n - 1 ; if ( k & 1 ) { product *= A [ j ] ; j -- ; k -- ; } k >>= 1 ; for ( int itr = 0 ; itr < k ; itr ++ ) { int left_product = A [ i ] * A [ i + 1 ] ; int right_product = A [ j ] * A [ j - 1 ] ; if ( left_product > right_product ) { product *= left_product ; i += 2 ; } else { product *= right_product ; j -= 2 ; } } return product ; }
int findMaximum ( int arr [ ] , int n , int k ) { int res = 0 , index = 0 ; for ( int i = n - 1 ; i >= index ; i -- ) { res += arr [ i ] ; index += k ; } return res ; }
void insertionSort ( int arr [ ] , int left , int right ) { for ( int i = left + 1 ; i <= right ; i ++ ) { int temp = arr [ i ] ; int j = i - 1 ; while ( j >= left && arr [ j ] > temp ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = temp ; } }
void merge ( int arr [ ] , int l , int m , int r ) { int len1 = m - l + 1 , len2 = r - m ; int left [ len1 ] , right [ len2 ] ; for ( int i = 0 ; i < len1 ; i ++ ) left [ i ] = arr [ l + i ] ; for ( int i = 0 ; i < len2 ; i ++ ) right [ i ] = arr [ m + 1 + i ] ; int i = 0 ; int j = 0 ; int k = l ; while ( i < len1 && j < len2 ) { if ( left [ i ] <= right [ j ] ) { arr [ k ] = left [ i ] ; i ++ ; } else { arr [ k ] = right [ j ] ; j ++ ; } k ++ ; } while ( i < len1 ) { arr [ k ] = left [ i ] ; k ++ ; i ++ ; } while ( j < len2 ) { arr [ k ] = right [ j ] ; k ++ ; j ++ ; } }
bool checkForSorting ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) swap ( arr [ i ] , arr [ i + 1 ] ) ; else return false ; } } return true ; }
void sort ( string s [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { string temp = s [ i ] ; int j = i - 1 ; while ( j >= 0 && temp . length ( ) < s [ j ] . length ( ) ) { s [ j + 1 ] = s [ j ] ; j -- ; } s [ j + 1 ] = temp ; } }
void printArraystring ( string str [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << str [ i ] << " " ; }
int maxLevel ( int boxes [ ] , int n ) { sort ( boxes , boxes + n ) ; int prev_width = boxes [ 0 ] ; int prev_count = 1 ; int curr_count = 0 ; int curr_width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; }
void stoogesort ( int arr [ ] , int l , int h ) { if ( l >= h ) return ; if ( arr [ l ] > arr [ h ] ) swap ( arr [ l ] , arr [ h ] ) ; if ( h - l + 1 > 2 ) { int t = ( h - l + 1 ) / 3 ; stoogesort ( arr , l , h - t ) ; stoogesort ( arr , l + t , h ) ; stoogesort ( arr , l , h - t ) ; } }
int merge ( int arr [ ] , int temp [ ] , int left , int mid , int right ) { int inv_count = 0 ; int i = left ; int j = mid ; int k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else { temp [ k ++ ] = arr [ j ++ ] ; inv_count = inv_count + ( mid - i ) ; } } while ( i <= mid - 1 ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= right ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = left ; i <= right ; i ++ ) arr [ i ] = temp [ i ] ; return inv_count ; }
int mergeSort ( int arr [ ] , int array_size ) { int * temp = ( int * ) malloc ( sizeof ( int ) * array_size ) ; return _mergeSort ( arr , temp , 0 , array_size - 1 ) ; }
int minDifferenceAmongMaxMin ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int res = INT_MAX ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { int curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = min ( res , curSeqDiff ) ; } return res ; }
void insertionSortRecursive ( int arr [ ] , int n ) { if ( n <= 1 ) return ; insertionSortRecursive ( arr , n - 1 ) ; int last = arr [ n - 1 ] ; int j = n - 2 ; while ( j >= 0 && arr [ j ] > last ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = last ; }
void twoWaySort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] *= -1 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= -1 ; }
int partition ( int arr [ ] , int low , int high ) { int pivot = arr [ low ] ; int i = low - 1 , j = high + 1 ; while ( true ) { do { i ++ ; } while ( arr [ i ] < pivot ) ; do { j -- ; } while ( arr [ j ] > pivot ) ; if ( i >= j ) return j ; swap ( arr [ i ] , arr [ j ] ) ; } }
void quickSort ( int arr [ ] , int low , int high ) { if ( low < high ) { int pi = partition ( arr , low , high ) ; quickSort ( arr , low , pi ) ; quickSort ( arr , pi + 1 , high ) ; } }
int ksmallest ( int arr [ ] , int n , int k ) { int b [ MAX ] ; memset ( b , 0 , sizeof b ) ; for ( int i = 0 ; i < n ; i ++ ) b [ arr [ i ] ] = 1 ; for ( int j = 1 ; j < MAX ; j ++ ) { if ( b [ j ] != 1 ) k -- ; if ( ! k ) return j ; } }
int ksmallest ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; if ( k < arr [ 0 ] ) return k ; if ( k == arr [ 0 ] ) return arr [ 0 ] + 1 ; if ( k > arr [ n - 1 ] ) return k + n ; if ( arr [ 0 ] == 1 ) k -- ; else k -= ( arr [ 0 ] - 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { int c = arr [ i ] - arr [ i - 1 ] - 1 ; if ( k <= c ) return arr [ i - 1 ] + k ; else k -= c ; } return arr [ n - 1 ] + k ; }
void multiply ( int A [ ] [ V ] , int B [ ] [ V ] , int C [ ] [ V ] ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { C [ i ] [ j ] = 0 ; for ( int k = 0 ; k < V ; k ++ ) C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] ; } } }
int getTrace ( int graph [ ] [ V ] ) { int trace = 0 ; for ( int i = 0 ; i < V ; i ++ ) trace += graph [ i ] [ i ] ; return trace ; }
int triangleInGraph ( int graph [ ] [ V ] ) { int aux2 [ V ] [ V ] ; int aux3 [ V ] [ V ] ; for ( int i = 0 ; i < V ; ++ i ) for ( int j = 0 ; j < V ; ++ j ) aux2 [ i ] [ j ] = aux3 [ i ] [ j ] = 0 ; multiply ( graph , graph , aux2 ) ; multiply ( graph , aux2 , aux3 ) ; int trace = getTrace ( aux3 ) ; return trace / 6 ; }
int minSum ( int arr [ ] , int n ) { vector < int > evenArr ; vector < int > oddArr ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) oddArr . push_back ( arr [ i ] ) ; else evenArr . push_back ( arr [ i ] ) ; } sort ( evenArr . begin ( ) , evenArr . end ( ) , greater < int > ( ) ) ; int i = 0 , sum = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) { arr [ i ++ ] = evenArr [ j ] ; arr [ i ++ ] = oddArr [ j ] ; sum += evenArr [ j ] * oddArr [ j ] ; } return sum ; }
void mergeTwoHalf ( int A [ ] , int n ) { sort ( A , A + n ) ; }
int minDiff ( int arr [ ] , int n , int k ) { int result = INT_MAX ; sort ( arr , arr + n ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
bool isPossible ( int a [ ] , int b [ ] , int n , int k ) { sort ( a , a + n ) ; sort ( b , b + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; }
void bitonicGenerator ( int arr [ ] , int n ) { vector < int > evenArr ; vector < int > oddArr ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( i % 2 ) ) evenArr . push_back ( arr [ i ] ) ; else oddArr . push_back ( arr [ i ] ) ; } sort ( evenArr . begin ( ) , evenArr . end ( ) ) ; sort ( oddArr . begin ( ) , oddArr . end ( ) , greater < int > ( ) ) ; int i = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) arr [ i ++ ] = evenArr [ j ] ; for ( int j = 0 ; j < oddArr . size ( ) ; j ++ ) arr [ i ++ ] = oddArr [ j ] ; }
int findMinDiff ( int arr [ ] , int n , int m ) { if ( m == 0 n == 0 ) return 0 ; sort ( arr , arr + n ) ; if ( n < m ) return -1 ; int min_diff = INT_MAX ; for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) min_diff = diff ; } return min_diff ; }
long long int minValue ( int A [ ] , int B [ ] , int n ) { sort ( A , A + n ) ; sort ( B , B + n ) ; long long int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }
int merge ( int arr [ ] , int temp [ ] , int left , int mid , int right ) { int inv_count = 0 ; int i = left ; int j = mid ; int k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else { temp [ k ++ ] = arr [ j ++ ] ; inv_count = inv_count + ( mid - i ) ; } } while ( i <= mid - 1 ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= right ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = left ; i <= right ; i ++ ) arr [ i ] = temp [ i ] ; return inv_count ; }
int _mergeSort ( int arr [ ] , int temp [ ] , int left , int right ) { int mid , inv_count = 0 ; if ( right > left ) { mid = ( right + left ) / 2 ; inv_count = _mergeSort ( arr , temp , left , mid ) ; inv_count += _mergeSort ( arr , temp , mid + 1 , right ) ; inv_count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_count ; }
bool isEven ( int n ) { return ( n % 2 == 0 ) ; }
bool isEven ( int n ) { return ( ! ( n & 1 ) ) ; }
int findSubsequenceCount ( string S , string T ) { int m = T . length ( ) , n = S . length ( ) ; if ( m > n ) return 0 ; int mat [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; }
int countBits ( int a ) { int count = 0 ; while ( a ) { if ( a & 1 ) count += 1 ; a = a >> 1 ; } return count ; }
void insertionSort ( int arr [ ] , int aux [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { int key1 = aux [ i ] ; int key2 = arr [ i ] ; int j = i - 1 ; while ( j >= 0 && aux [ j ] < key1 ) { aux [ j + 1 ] = aux [ j ] ; arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } aux [ j + 1 ] = key1 ; arr [ j + 1 ] = key2 ; } }
void sortBySetBitCount ( int arr [ ] , int n ) { int aux [ n ] ; for ( int i = 0 ; i < n ; i ++ ) aux [ i ] = countBits ( arr [ i ] ) ; insertionSort ( arr , aux , n ) ; }
int countBits ( int a ) { int count = 0 ; while ( a ) { if ( a & 1 ) count += 1 ; a = a >> 1 ; } return count ; }
void sortBySetBitCount ( int arr [ ] , int n ) { vector < vector < int > > count ( 32 ) ; int setbitcount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { setbitcount = countBits ( arr [ i ] ) ; count [ setbitcount ] . push_back ( arr [ i ] ) ; } for ( int i = 31 ; i >= 0 ; i -- ) { vector < int > v1 = count [ i ] ; for ( int i = 0 ; i < v1 . size ( ) ; i ++ ) arr [ j ++ ] = v1 [ i ] ; } }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
void findSurpasser ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; cout << count << " " ; } }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) printf ( "%d " , arr [ i ] ) ; printf ( "\n" ) ; }
int solve ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i & 1 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; }
int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) return -1 ; int max_product = INT_MIN ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }
int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) return -1 ; vector < int > leftMin ( n , -1 ) ; vector < int > rightMin ( n , -1 ) ; vector < int > leftMax ( n , -1 ) ; vector < int > rightMax ( n , -1 ) ; int max_product = INT_MIN ; int max_sum = arr [ 0 ] ; int min_sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { leftMax [ i ] = max_sum ; if ( arr [ i ] > max_sum ) max_sum = arr [ i ] ; leftMin [ i ] = min_sum ; if ( arr [ i ] < min_sum ) min_sum = arr [ i ] ; } max_sum = arr [ n - 1 ] ; min_sum = arr [ n - 1 ] ; for ( int j = n - 2 ; j >= 0 ; j -- ) { rightMax [ j ] = max_sum ; if ( arr [ j ] > max_sum ) max_sum = arr [ j ] ; rightMin [ j ] = min_sum ; if ( arr [ j ] < min_sum ) min_sum = arr [ j ] ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { int max1 = max ( arr [ i ] * leftMax [ i ] * rightMax [ i ] , arr [ i ] * leftMin [ i ] * rightMin [ i ] ) ; int max2 = max ( arr [ i ] * leftMax [ i ] * rightMin [ i ] , arr [ i ] * leftMin [ i ] * rightMax [ i ] ) ; max_product = max ( max_product , max ( max1 , max2 ) ) ; } return max_product ; }
int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) return -1 ; sort ( arr , arr + n ) ; return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; }
int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) return -1 ; int maxA = INT_MIN , maxB = INT_MIN , maxC = INT_MIN ; int minA = INT_MAX , minB = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; if ( arr [ i ] < minA ) { minB = minA ; minA = arr [ i ] ; } else if ( arr [ i ] < minB ) minB = arr [ i ] ; } return max ( minA * minB * maxA , maxA * maxB * maxC ) ; }
int distinctCount ( int arr [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( abs ( arr [ i ] ) ) ; return s . size ( ) ; }
int distinctCount ( int arr [ ] , int n ) { int count = n ; int i = 0 , j = n - 1 , sum = 0 ; while ( i < j ) { while ( i != j && arr [ i ] == arr [ i + 1 ] ) count -- , i ++ ; while ( i != j && arr [ j ] == arr [ j - 1 ] ) count -- , j -- ; if ( i == j ) break ; sum = arr [ i ] + arr [ j ] ; if ( sum == 0 ) { count -- ; i ++ , j -- ; } else if ( sum < 0 ) i ++ ; else j -- ; } return count ; }
void findMaxGuests ( int arrl [ ] , int exit [ ] , int n ) { sort ( arrl , arrl + n ) ; sort ( exit , exit + n ) ; int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } cout << "Maximum Number of Guests = " << max_guests << " at time " << time ; }
int binarySearch ( int a [ ] , int item , int low , int high ) { while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( item == a [ mid ] ) return mid + 1 ; else if ( item > a [ mid ] ) low = mid + 1 ; else high = mid - 1 ; } return low ; }
void insertionSort ( int a [ ] , int n ) { int i , loc , j , k , selected ; for ( i = 1 ; i < n ; ++ i ) { j = i - 1 ; selected = a [ i ] ; loc = binarySearch ( a , selected , 0 , j ) ; while ( j >= loc ) { a [ j + 1 ] = a [ j ] ; j -- ; } a [ j + 1 ] = selected ; } }
int findMax ( int arr [ ] , int n ) { int mi , i ; for ( mi = 0 , i = 0 ; i < n ; ++ i ) if ( arr [ i ] > arr [ mi ] ) mi = i ; return mi ; }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) cout << arr [ i ] << " " ; }
int minMoves ( vector < vector < char > > a , vector < vector < char > > b , int K ) { int n = a . size ( ) , m = a [ 0 ] . size ( ) ; int cntOperations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( a [ i ] [ j ] != b [ i ] [ j ] ) { cntOperations ++ ; if ( i + K - 1 >= n j + K - 1 >= m ) { return -1 ; } for ( int p = 0 ; p <= K - 1 ; p ++ ) { for ( int q = 0 ; q <= K - 1 ; q ++ ) { if ( a [ i + p ] [ j + q ] == '0' ) { a [ i + p ] [ j + q ] = '1' ; } else { a [ i + p ] [ j + q ] = '0' ; } } } } } } return cntOperations ; }
int maxConsecutiveCnt ( vector < int > arr ) { int X = 0 ; sort ( arr . begin ( ) , arr . end ( ) ) ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( arr [ i ] <= ( X + 1 ) ) { X = X + arr [ i ] ; } else { break ; } } return X + 1 ; }
void findPermutation ( int N , int L , int R , int S ) { int x = R - L + 1 ; if ( ! possible ( x , S , N ) ) { cout << -1 ; return ; } else { vector < int > v ; for ( int i = N ; i >= 1 ; -- i ) { if ( ( S - i ) >= 0 && possible ( x - 1 , S - i , i - 1 ) ) { S = S - i ; x -- ; v . push_back ( i ) ; } if ( S == 0 ) { break ; } } if ( S != 0 ) { cout << -1 ; return ; } vector < int > v1 ; for ( int i = 1 ; i <= N ; ++ i ) { vector < int > :: iterator it = find ( v . begin ( ) , v . end ( ) , i ) ; if ( it == v . end ( ) ) { v1 . push_back ( i ) ; } } int j = 0 , f = 0 ; for ( int i = 1 ; i < L ; ++ i ) { cout << v1 [ j ] << " " ; j ++ ; } for ( int i = L ; i <= R ; ++ i ) { cout << v [ f ] << " " ; f ++ ; } for ( int i = R + 1 ; i <= N ; ++ i ) { cout << v1 [ j ] << " " ; j ++ ; } } return ; }
int maxShiftArrayValue ( int arr [ ] , int cap [ ] , int N ) { int sumVals = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sumVals += arr [ i ] ; } int maxCapacity = 0 ; for ( int i = 0 ; i < N ; i ++ ) { maxCapacity = max ( cap [ i ] , maxCapacity ) ; } return min ( maxCapacity , sumVals ) ; }
int minimumSizeArray ( int S , int P ) { if ( S == P ) { return 1 ; } for ( int i = 2 ; i <= S ; i ++ ) { double d = i ; if ( ( S / d ) >= pow ( P , 1.0 / d ) ) { return i ; } } return -1 ; }
int countPoints ( int D ) { int count = 0 ; for ( int x = 1 ; x * x < D * D ; x ++ ) { int y = ( int ) sqrt ( double ( D * D - x * x ) ) ; if ( x * x + y * y == D * D ) { count += 4 ; } } count += 4 ; return count ; }
int minimizeCost ( int A , int B , int C ) { int ans = A + B + C ; for ( int i = 1 ; i <= 2 * C ; i ++ ) { int j = 0 ; while ( i * j <= 2 * C ) { ans = min ( ans , abs ( A - i ) + abs ( B - j ) + abs ( i * j - C ) ) ; j ++ ; } } return ans ; }
double averageSetBits ( int N , int K , int arr [ ] ) { double p = N ; double q = 0 ; for ( int i = 0 ; i < K ; i ++ ) { double _p = p , _q = q ; p = _p - _p * arr [ i ] / N + _q * arr [ i ] / N ; q = _q - _q * arr [ i ] / N + _p * arr [ i ] / N ; } return p ; }
long long KthSolution ( long long X , long long K ) { long long ans = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ! ( X & ( 1LL << i ) ) ) { if ( K & 1 ) { ans |= ( 1LL << i ) ; } K >>= 1 ; if ( ! K ) { break ; } } } return ans ; }
int minimumcoins ( int arr [ ] , int N ) { int coins = 0 ; int j = 0 ; if ( arr [ 0 ] == 1 ) coins ++ ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == 2 ) continue ; j = i ; while ( j < N && arr [ j ] == 1 ) { j ++ ; } int x = ( j - i ) ; coins += x / 3 ; i = j - 1 ; } return coins ; }
int maximumUniqueSquares ( int N ) { int ans = 0 ; if ( N < 4 ) { return 0 ; } int len = ( sqrt ( double ( N ) ) ) ; N -= len * len ; for ( int i = 1 ; i < len ; i ++ ) { ans += i * i ; } if ( N >= len ) { N -= len ; for ( int i = 1 ; i < len ; i ++ ) { ans += i ; } } for ( int i = 1 ; i < N ; i ++ ) { ans += i ; } return ans ; }
void rearrange ( int arr [ ] , int N ) { if ( N & 1 ) N -- ; int odd_idx = 1 , even_idx = 0 ; int i , max_elem = arr [ N - 1 ] + 1 ; for ( i = 0 ; i < N / 2 ; i ++ ) { arr [ i ] += ( arr [ odd_idx ] % max_elem ) * max_elem ; odd_idx += 2 ; } for ( ; i < N ; i ++ ) { arr [ i ] += ( arr [ even_idx ] % max_elem ) * max_elem ; even_idx += 2 ; } for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = arr [ i ] / max_elem ; } }
void generateString ( int k1 , int k2 , string s ) { int C1s = 0 , C0s = 0 ; int flag = 0 ; vector < int > pos ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '0' ) { C0s ++ ; if ( ( i + 1 ) % k1 != 0 && ( i + 1 ) % k2 != 0 ) { pos . push_back ( i ) ; } } else { C1s ++ ; } if ( C0s >= C1s ) { if ( pos . size ( ) == 0 ) { cout << -1 ; flag = 1 ; break ; } else { int k = pos . back ( ) ; s [ k ] = '1' ; C0s -- ; C1s ++ ; pos . pop_back ( ) ; } } } if ( flag == 0 ) { cout << s ; } }
void findRange ( int arr [ ] , int N , int K ) { int L = INT_MIN ; int R = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { int l = ( int ) ceil ( 1.0 * arr [ i ] * K / ( i + 1 ) ) ; int r = ( int ) ceil ( ( 1.0 + arr [ i ] ) * K / ( i + 1 ) ) - 1 ; L = max ( L , l ) ; R = min ( R , r ) ; } cout << L << " " << R ; }
void findAnagram ( string s ) { string check = s ; int i = 0 , j = s . length ( ) - 1 ; while ( i < s . length ( ) && j >= 0 ) { if ( s [ i ] != s [ j ] && check [ i ] != s [ j ] && check [ j ] != s [ i ] ) { swap ( s [ i ] , s [ j ] ) ; i ++ ; j = s . length ( ) - 1 ; } else { j -- ; } } if ( s . length ( ) % 2 != 0 ) { int mid = s . length ( ) / 2 ; if ( check [ mid ] == s [ mid ] ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( check [ i ] != s [ mid ] && s [ i ] != s [ mid ] ) { swap ( s [ i ] , s [ mid ] ) ; break ; } } } } bool ok = true ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( check [ i ] == s [ i ] ) { ok = false ; break ; } } if ( ok ) cout << s ; else cout << -1 ; }
void maximizeProduct ( int N ) { int MSB = ( int ) log2 ( N ) ; int X = 1 << MSB ; int Y = N - ( 1 << MSB ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ! ( N & ( 1 << i ) ) ) { X += 1 << i ; Y += 1 << i ; } } cout << X << " " << Y ; }
void constructPermutation ( string S , int N ) { int ans [ N ] ; ans [ 0 ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) { if ( S [ i - 1 ] == '0' ) { ans [ i ] = i + 1 ; } else { ans [ i ] = ans [ i - 1 ] ; } for ( int j = 0 ; j < i ; ++ j ) { if ( ans [ j ] >= ans [ i ] ) { ans [ j ] ++ ; } } } for ( int i = 0 ; i < N ; i ++ ) { cout << ans [ i ] ; if ( i != N - 1 ) { cout << " " ; } } }
int findRemainingIndex ( int N ) { int ans = N ; while ( N > 1 ) { int discard = int ( sqrt ( N ) ) ; if ( discard * discard == N ) { ans -- ; } N -= discard ; } return ans ; }
void findRemainingElement ( int arr [ ] , int N ) { int remainingIndex = findRemainingIndex ( N ) ; cout << arr [ remainingIndex - 1 ] ; }
bool check ( int num ) { int sm = 0 ; int num2 = num * num ; while ( num ) { sm += num % 10 ; num /= 10 ; } int sm2 = 0 ; while ( num2 ) { sm2 += num2 % 10 ; num2 /= 10 ; } return ( ( sm * sm ) == sm2 ) ; }
void generate ( string s , int len , set < int > & uniq ) { if ( s . size ( ) == len ) { if ( check ( convert ( s ) ) ) { uniq . insert ( convert ( s ) ) ; } return ; } for ( int i = 0 ; i <= 3 ; i ++ ) { generate ( s + char ( i + '0' ) , len , uniq ) ; } }
int totalNumbers ( int L , int R ) { int ans = 0 ; int max_len = log10 ( R ) + 1 ; set < int > uniq ; for ( int i = 1 ; i <= max_len ; i ++ ) { generate ( "" , i , uniq ) ; } for ( auto x : uniq ) { if ( x >= L && x <= R ) { ans ++ ; } } return ans ; }
void findMaximumSumWithMflips ( int arr [ ] , int N , int M ) { priority_queue < int , vector < int > , greater < int > > pq ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { pq . push ( arr [ i ] ) ; sum += arr [ i ] ; } while ( M -- ) { sum -= pq . top ( ) ; int temp = -1 * pq . top ( ) ; pq . pop ( ) ; sum += temp ; pq . push ( temp ) ; } cout << sum ; }
bool check ( int x , int N ) { while ( 1 ) { N -= x ; if ( x < 10 ) break ; int temp2 = 0 ; while ( x ) { temp2 *= 10 ; temp2 += ( x % 10 ) ; x /= 10 ; } x = temp2 ; } if ( ( x < 10 ) && ( N == 0 ) ) { return 1 ; } return 0 ; }
int minimumMoves ( int A [ ] , int B [ ] , int N ) { int ans = 0 ; int sum_A = 0 , sum_B = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum_A += A [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { sum_B += B [ i ] ; } if ( sum_A != sum_B ) { return -1 ; } int i = 0 ; while ( i < N ) { if ( A [ i ] > B [ i ] ) { int temp = A [ i ] - B [ i ] ; int j = i - 1 ; while ( j >= 0 && temp > 0 ) { if ( B [ j ] > A [ j ] ) { int cnt = min ( temp , ( B [ j ] - A [ j ] ) ) ; A [ j ] += cnt ; temp -= cnt ; ans += ( cnt * abs ( j - i ) ) ; } j -- ; } if ( temp > 0 ) { int j = i + 1 ; while ( j < N && temp > 0 ) { if ( B [ j ] > A [ j ] ) { int cnt = min ( temp , ( B [ j ] - A [ j ] ) ) ; A [ j ] += cnt ; temp -= cnt ; ans += ( cnt * abs ( j - i ) ) ; } j ++ ; } } } i ++ ; } return ans ; }
int possibleReachingSequence ( int X , int D , int T ) { if ( X < T ) { cout << "NO" ; return 0 ; } if ( T * D < X ) { cout << "NO" ; return 0 ; } if ( ( X - T ) % ( D - 1 ) == 0 ) { cout << "YES" ; } else { cout << "NO" ; } return 0 ; }
int maxSumAfterPartition ( int arr [ ] , int n ) { vector < int > pos ; vector < int > neg ; int zero = 0 ; int pos_sum = 0 ; int neg_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { pos . push_back ( arr [ i ] ) ; pos_sum += arr [ i ] ; } else if ( arr [ i ] < 0 ) { neg . push_back ( arr [ i ] ) ; neg_sum += arr [ i ] ; } else { zero ++ ; } } int ans = 0 ; sort ( pos . begin ( ) , pos . end ( ) ) ; sort ( neg . begin ( ) , neg . end ( ) , greater < int > ( ) ) ; if ( pos . size ( ) > 0 && neg . size ( ) > 0 ) { ans = ( pos_sum - neg_sum ) ; } else if ( pos . size ( ) > 0 ) { if ( zero > 0 ) { ans = ( pos_sum ) ; } else { ans = ( pos_sum - 2 * pos [ 0 ] ) ; } } else { if ( zero > 0 ) { ans = ( -1 * neg_sum ) ; } else { ans = ( neg [ 0 ] - ( neg_sum - neg [ 0 ] ) ) ; } } return ans ; }
int arrayDivisionByTwo ( int arr [ ] , int n ) { int cnt = 0 ; int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { cnt = 0 ; while ( arr [ i ] % 2 == 0 ) { arr [ i ] = arr [ i ] / 2 ; cnt ++ ; } ans = min ( ans , cnt ) ; } return ans ; }
int minPushes ( int N , int K , vector < int > arr ) { vector < int > dp ( 100000 , -1 ) ; dp [ N ] = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { for ( int xx = 0 ; xx < 100000 ; xx ++ ) { int x = xx ; if ( dp [ x ] == -1 ) continue ; int next = ( x + arr [ i ] ) % 100000 ; while ( dp [ next ] == -1 dp [ next ] > dp [ x ] + 1 ) { dp [ next ] = dp [ x ] + 1 ; x = next ; next = ( next + arr [ i ] ) % 100000 ; } } } return dp [ K ] ; }
int minimumOperations ( int A [ ] , int N ) { int cur_prefix_1 = 0 ; int parity = -1 ; int minOperationsCase1 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { cur_prefix_1 += A [ i ] ; if ( cur_prefix_1 == 0 parity * cur_prefix_1 < 0 ) { minOperationsCase1 += abs ( parity - cur_prefix_1 ) ; cur_prefix_1 = parity ; } parity *= -1 ; } int cur_prefix_2 = 0 ; parity = 1 ; int minOperationsCase2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { cur_prefix_2 += A [ i ] ; if ( cur_prefix_2 == 0 parity * cur_prefix_2 < 0 ) { minOperationsCase2 += abs ( parity - cur_prefix_2 ) ; cur_prefix_2 = parity ; } parity *= -1 ; } return min ( minOperationsCase1 , minOperationsCase2 ) ; }
void maximumSumArray ( int arr [ ] , int N ) { vector < int > arrA ( N ) , ans ( N ) ; int maxSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) arrA [ i ] = arr [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { vector < int > arrB ( N ) ; int maximum = arrA [ i ] ; arrB [ i ] = maximum ; for ( int j = i - 1 ; j >= 0 ; j -- ) { arrB [ j ] = min ( maximum , arrA [ j ] ) ; maximum = arrB [ j ] ; } maximum = arrA [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { arrB [ j ] = min ( maximum , arrA [ j ] ) ; maximum = arrB [ j ] ; } int sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) sum += arrB [ j ] ; if ( sum > maxSum ) { maxSum = sum ; ans = arrB ; } } for ( int val : ans ) { cout << val << " " ; } }
int minProductUtil ( int R1 , int B1 , int R2 , int B2 , int M ) { int x = min ( R1 - B1 , M ) ; M -= x ; R1 -= x ; if ( M > 0 ) { int y = min ( R2 - B2 , M ) ; M -= y ; R2 -= y ; } return R1 * R2 ; }
int minProduct ( int R1 , int B1 , int R2 , int B2 , int M ) { int res1 = minProductUtil ( R1 , B1 , R2 , B2 , M ) ; int res2 = minProductUtil ( R2 , B2 , R1 , B1 , M ) ; return min ( res1 , res2 ) ; }
int maxAmount ( int n , int k , int arr [ ] ) { int A [ 1000001 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { A [ arr [ i ] ] ++ ; } int j = 0 ; for ( int i = 0 ; i < 1000001 ; i ++ ) { while ( A [ i ] != 0 ) { arr [ j ++ ] = i ; A [ i ] -- ; } } long long int ans = 0 ; int mod = 1e9 + 7 ; int i = n - 1 ; j = n - 2 ; while ( k > 0 && j >= 0 ) { if ( arr [ i ] > arr [ j ] ) { ans = ans + min ( k , ( i - j ) ) * arr [ i ] ; k = k - ( i - j ) ; arr [ i ] -- ; } else { while ( j >= 0 && arr [ j ] == arr [ i ] ) j -- ; if ( j < 0 ) break ; ans = ans + min ( k , ( i - j ) ) * arr [ i ] ; k = k - ( i - j ) ; arr [ i ] -- ; } } while ( k > 0 && arr [ i ] != 0 ) { ans = ans + min ( n , k ) * arr [ i ] ; k -= n ; arr [ i ] -- ; } ans = ans % mod ; int x = ans ; return x ; }
int validPermutations ( string str ) { unordered_map < char , int > m ; int count = str . length ( ) , ans = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { m [ str [ i ] ] ++ ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { ans += count - m [ str [ i ] ] ; m [ str [ i ] ] -- ; count -- ; } return ans + 1 ; }
void maxAverage ( int A [ ] , int N , int X , int Y ) { sort ( A , A + N ) ; int sum = 0 ; double res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; count ++ ; if ( count == X ) { if ( N - i - 1 < X ) { i ++ ; int cnt = 0 ; while ( i < N ) { cnt ++ ; sum += A [ i ] ; i ++ ; } X = X + cnt ; res += ( double ) sum / double ( X ) ; break ; } res += ( double ) sum / double ( X ) ; sum = 0 ; count = 0 ; } } cout << fixed << setprecision ( 2 ) << res << "\n" ; }
int maxSum ( vector < vector < int > > arr ) { int m = ( int ) arr . size ( ) ; int n = ( int ) arr [ 0 ] . size ( ) - 1 ; int dp [ m ] [ n + 1 ] ; memset ( arr , 0 , sizeof ( arr ) ) ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i < m ; ++ i ) dp [ i ] [ 1 ] = arr [ i ] [ 1 ] ; for ( int i = 1 ; i < n + 1 ; ++ i ) { for ( int j = 1 ; j < m ; ++ j ) { int mx = 0 ; for ( int k = 1 ; k < m ; ++ k ) { if ( k != j ) { if ( dp [ k ] [ i - 1 ] > mx ) { mx = dp [ k ] [ i - 1 ] ; } } } if ( mx and arr [ j ] [ i ] ) { dp [ j ] [ i ] = arr [ j ] [ i ] + mx ; } } } int ans = -1 ; for ( int i = 1 ; i <= m ; ++ i ) { if ( dp [ i ] [ n ] ) ans = max ( ans , dp [ i ] [ n ] ) ; } return ans ; }
int findMaximumPoints ( int N , int X [ ] , int H [ ] ) { int ans = 0 ; int prev = INT_MIN ; for ( int i = 0 ; i < N ; ++ i ) { if ( prev < ( X [ i ] - H [ i ] ) ) { ++ ans ; prev = X [ i ] ; } else if ( i == N - 1 || ( X [ i ] + H [ i ] ) < X [ i + 1 ] ) { ++ ans ; prev = X [ i ] + H [ i ] ; } else { prev = X [ i ] ; } } return ans ; }
void maxGcd ( int a , int b ) { cout << abs ( a - b ) ; }
void sumOfCombinationOf4OR5 ( vector < int > arr , int N ) { vector < int > ans ( N , -1 ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 4 ) { continue ; } int sum = INT_MAX , cnt = 0 ; for ( int j = 0 ; j <= arr [ i ] ; j += 4 ) { if ( ( arr [ i ] - j ) % 5 == 0 ) { sum = min ( sum , cnt + ( arr [ i ] - j ) / 5 ) ; } cnt ++ ; } if ( sum != INT_MAX ) ans [ i ] = sum ; } for ( auto num : ans ) cout << num << " " ; }
int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
void printBinaryString ( int arr [ ] [ 3 ] , int N ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 ) { cout << 0 ; } else { cout << 1 ; } } }
int MinCost ( int days [ ] , int cost [ ] , int N ) { int size = days [ N - 1 ] + 1 ; int dp [ size ] ; dp [ size - 1 ] = min ( cost [ 0 ] , min ( cost [ 1 ] , cost [ 2 ] ) ) ; int ptr = N - 2 ; for ( int i = size - 2 ; i > 0 ; i -- ) { if ( ptr >= 0 && days [ ptr ] == i ) { int val1 = dp [ i + 1 ] + cost [ 0 ] ; int val2 = cost [ 1 ] + ( ( i + 7 >= size ) ? 0 : dp [ i + 7 ] ) ; int val3 = cost [ 2 ] + ( ( i + 30 >= size ) ? 0 : dp [ i + 30 ] ) ; dp [ i ] = min ( val1 , min ( val2 , val3 ) ) ; ptr -- ; } else { dp [ i ] = dp [ i + 1 ] ; } } return dp [ 1 ] ; }
int minElements ( int arr [ ] , int N , int K ) { int count = 0 ; long long requiredNum = 1 ; int i = 0 ; while ( requiredNum <= K ) { if ( i < N && requiredNum >= arr [ i ] ) { requiredNum += arr [ i ] ; i ++ ; } else { count ++ ; requiredNum += requiredNum ; } } return count ; }
int minimumSteps ( int a , int b ) { int cnt = 0 ; a = abs ( a - b ) ; cnt = ( a / 5 ) + ( a % 5 ) / 2 + ( a % 5 ) % 2 ; return cnt ; }
int maximumCount ( int arr [ ] , int N ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 ) odd ++ ; else even ++ ; } if ( odd and even ) return N - 2 ; else return N - 1 ; }
void miniOperToMakeAllEleEqual ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } if ( sum % n ) { cout << -1 ; return ; } int valueAfterDivision = sum / n ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( abs ( valueAfterDivision - arr [ i ] ) % k != 0 ) { cout << -1 ; return ; } count += abs ( valueAfterDivision - arr [ i ] ) / k ; } cout << count / 2 << endl ; }
int countOpenDoors ( int N ) { int doorsOpen = sqrt ( N ) ; return doorsOpen ; }
int minPossibleValue ( int N , int K , int X ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( X <= K ) { X = X * 2 ; } else { X = X + K ; } } return X ; }
void findMissingValue ( int arr [ ] , int N ) { int minE = INT_MAX , maxE = INT_MIN ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == -1 && arr [ i + 1 ] != -1 ) { minE = min ( minE , arr [ i + 1 ] ) ; maxE = max ( maxE , arr [ i + 1 ] ) ; } if ( arr [ i ] != -1 && arr [ i + 1 ] == -1 ) { minE = min ( minE , arr [ i ] ) ; maxE = max ( maxE , arr [ i ] ) ; } } if ( minE == INT_MAX and maxE == INT_MIN ) { cout << "0" ; } else { cout << ( minE + maxE ) / 2 ; } }
void findLastElement ( int N , vector < int > A ) { int l = A . size ( ) ; int j = 0 ; while ( N > l * ( pow ( 2 , j ) ) ) { N = N - l * pow ( 2 , j ) ; j += 1 ; } int k = 1 ; int r = pow ( 2 , j ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( N > r * i ) k += 1 ; } for ( int i = 0 ; i < l ; i ++ ) { if ( i + 1 == k ) { cout << ( A [ i ] ) ; return ; } } }
int findMaxD ( int arr [ ] , int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = abs ( arr [ i ] - K ) ; } int D = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { D = gcd ( D , arr [ i ] ) ; } return D ; }
void minOperations ( vector < int > a ) { int res = INT_MAX ; int N = a . size ( ) ; for ( int r = 0 ; r < 2 ; r ++ ) { int sum = 0 , ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( ( i + r ) % 2 ) { if ( sum <= 0 ) { ans += - sum + 1 ; sum = 1 ; } } else { if ( sum >= 0 ) { ans += sum + 1 ; sum = -1 ; } } } res = min ( res , ans ) ; } cout << res ; }
int maxOperations ( string S , int N ) { int X = 0 ; int Y = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '0' ) break ; Y ++ ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( S [ i ] == '1' ) break ; X ++ ; } if ( N == X + Y ) return 0 ; return N - ( X + Y ) - 1 ; }
int maximumSum ( string S , int N , int K ) { int sum = 0 ; int freq [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { freq [ int ( S [ i ] ) ] ++ ; } sort ( freq , freq + 256 , greater < int > ( ) ) ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( K > freq [ i ] ) { sum += freq [ i ] * freq [ i ] ; K -= freq [ i ] ; } else { sum += freq [ i ] * K ; break ; } } return sum ; }
void possibleNumbers ( set < int > & numbers , int N , int M , int A , int B ) { if ( M == 0 ) { numbers . insert ( N ) ; return ; } possibleNumbers ( numbers , N + A , M - 1 , A , B ) ; possibleNumbers ( numbers , N + B , M - 1 , A , B ) ; }
void possibleNumbers ( int N , int M , int A , int B ) { if ( A > B ) { swap ( A , B ) ; } int number = N + M * A ; cout << number << " " ; if ( A != B ) { for ( int i = 0 ; i < M ; i ++ ) { number = number - A + B ; cout << number << " " ; } } }
void maxSum ( int arr [ ] , int n ) { int sum = 0 ; int max_neg = INT_MAX ; int tempsum = 0 ; int small = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; small = min ( small , arr [ i ] ) ; if ( arr [ i ] > 0 ) { tempsum = 0 ; } else { tempsum += arr [ i ] ; } max_neg = min ( max_neg , tempsum ) ; } if ( max_neg == 0 ) { max_neg = small ; } cout << sum - max_neg ; }
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
int findVertices ( int n ) { return fib ( n + 2 ) ; }
int MaxBuildingsCovered ( int arr [ ] , int N , int L ) { double curr_sum = 0 ; int start = 0 , curr_count = 0 , max_count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { curr_sum = curr_sum + ( ( double ) arr [ i ] * Pi ) ; if ( i != 0 ) curr_sum += 1 ; if ( curr_sum <= L ) { curr_count ++ ; } else if ( curr_sum > L ) { curr_sum = curr_sum - ( ( double ) arr [ start ] * Pi ) ; curr_sum -= 1 ; start ++ ; curr_count -- ; } max_count = max ( curr_count , max_count ) ; } return max_count ; }
int num_candyTypes ( vector < int > & candies ) { unordered_set < int > s ; for ( int i = 0 ; i < candies . size ( ) ; i ++ ) { s . insert ( candies [ i ] ) ; } return s . size ( ) ; }
void distribute_candies ( vector < int > & candies ) { int allowed = candies . size ( ) / 2 ; int types = num_candyTypes ( candies ) ; if ( types < allowed ) cout << types ; else cout << allowed ; }
int countUnsetBits ( int N ) { int c = 0 ; while ( N ) { if ( N % 2 == 0 ) { c += 1 ; } N = N >> 1 ; } return c ; }
void countBitwiseZero ( int N ) { int unsetBits = countUnsetBits ( N ) ; cout << ( 1 << unsetBits ) ; }
bool isPossible ( string s ) { int n = s . size ( ) ; int count_0 = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) ++ count_0 ; else ++ count_1 ; if ( count_1 > count_0 ) return false ; } if ( count_0 != ( 2 * count_1 ) ) return false ; count_0 = 0 , count_1 = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == '0' ) ++ count_0 ; else ++ count_1 ; if ( count_1 > count_0 ) return false ; } return true ; }
int minimumOperation ( string a , string b ) { int n = a . length ( ) ; int i = 0 ; int minoperation = 0 ; while ( i < n ) { if ( a [ i ] == b [ i ] ) { i = i + 1 ; continue ; } else if ( a [ i ] == b [ i + 1 ] && a [ i + 1 ] == b [ i ] && i < n - 1 ) { minoperation ++ ; i = i + 2 ; } else if ( a [ i ] != b [ i ] ) { minoperation ++ ; i = i + 1 ; } else { ++ i ; } } cout << minoperation ; }
void leastBricks ( vector < vector < int > > wall ) { unordered_map < int , int > map ; int res = 0 ; for ( vector < int > list : wall ) { int width = 0 ; for ( int i = 0 ; i < list . size ( ) - 1 ; i ++ ) { width += list [ i ] ; map [ width ] ++ ; res = max ( res , map [ width ] ) ; } } cout << wall . size ( ) - res ; }
void minimumProdArray ( vector < int > & a , vector < int > & b , int l ) { int total = 0 ; for ( int i = 0 ; i < a . size ( ) ; ++ i ) { total += a [ i ] * b [ i ] ; } int min = INT_MAX ; int first = 0 ; int second = 0 ; for ( int i = 0 ; i < a . size ( ) ; ++ i ) { int left = i - 1 ; int right = i + 1 ; int total1 = total ; while ( left >= 0 && right < a . size ( ) ) { total1 -= a [ left ] * b [ left ] + a [ right ] * b [ right ] ; total1 += a [ left ] * b [ right ] + a [ right ] * b [ left ] ; if ( min >= total1 ) { min = total1 ; first = left ; second = right ; } -- left ; ++ right ; } } for ( int i = 0 ; i < a . size ( ) ; ++ i ) { int left = i ; int right = i + 1 ; int total1 = total ; while ( left >= 0 && right < a . size ( ) ) { total1 -= a [ left ] * b [ left ] + a [ right ] * b [ right ] ; total1 += a [ left ] * b [ right ] + a [ right ] * b [ left ] ; if ( min >= total1 ) { min = total1 ; first = left ; second = right ; } -- left ; ++ right ; } } if ( min < total ) { reverse1 ( first , second , a ) ; print1 ( a , b ) ; } else { print1 ( a , b ) ; } }
int numberOfWays ( int N , int X , int Y ) { int S1 = ( N - 1 ) * X + Y ; int S2 = ( N - 1 ) * Y + X ; return ( S2 - S1 + 1 ) ; }
int countPermutations ( int N ) { vector < vector < int > > adj ( 105 ) ; int indeg = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i == j ) continue ; int sum = i + j ; if ( ceil ( sqrt ( sum ) ) == floor ( sqrt ( sum ) ) ) { adj [ i ] . push_back ( j ) ; } } if ( adj [ i ] . size ( ) == 1 ) indeg ++ ; } if ( indeg == 0 ) return N ; else if ( indeg <= 2 ) return 2 ; else return 0 ; }
int reduceToOne ( long long int N ) { int cnt = 0 ; while ( N != 1 ) { if ( N == 2 or ( N % 2 == 1 ) ) { N = N - 1 ; cnt ++ ; } else if ( N % 2 == 0 ) { N = N / ( N / 2 ) ; cnt ++ ; } } return cnt ; }
void getDate ( int d , string m ) { int days [ ] = { 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; string month [ ] = { "January" , "February" , "March" , "April" , "May" , "June" , "July" , "August" , "September" , "October" , "November" , "December" } ; int cnt = 183 ; int cur_month ; for ( int i = 0 ; i < 12 ; i ++ ) if ( m == month [ i ] ) cur_month = i ; int cur_date = d ; while ( 1 ) { while ( cnt > 0 && cur_date <= days [ cur_month ] ) { cnt -= 1 ; cur_date += 1 ; } if ( cnt == 0 ) break ; cur_month = ( cur_month + 1 ) % 12 ; cur_date = 1 ; } cout << cur_date << " " << month [ cur_month ] << endl ; }
void maxDiamonds ( int A [ ] , int N , int K ) { priority_queue < int > pq ; for ( int i = 0 ; i < N ; i ++ ) { pq . push ( A [ i ] ) ; } int ans = 0 ; while ( ! pq . empty ( ) && K -- ) { int top = pq . top ( ) ; pq . pop ( ) ; ans += top ; top = top / 2 ; pq . push ( top ) ; } cout << ans ; }
void findMaximumProfit ( int arr [ ] , int M , int N ) { priority_queue < int > max_heap ; int maxProfit = 0 ; for ( int i = 0 ; i < N ; i ++ ) max_heap . push ( arr [ i ] ) ; while ( M > 0 ) { M -- ; int X = max_heap . top ( ) ; max_heap . pop ( ) ; maxProfit += X ; max_heap . push ( X - 1 ) ; } cout << maxProfit ; }
long largestNumber ( int N ) { if ( N > 45 ) return -1 ; int num = 0 , digit = 9 ; while ( N > 0 && digit > 0 ) { if ( digit <= N ) { num *= 10 ; num += digit ; N -= digit ; } digit -= 1 ; } return num * 10 ; }
int minimumSum ( int A [ ] , int N , string S ) { int mul = 0 ; for ( int i = 0 ; i < ( int ) S . size ( ) ; i ++ ) { if ( S [ i ] == '*' ) mul += 1 ; } int ans = 1000000 ; for ( int i = 0 ; i < ( 1 << ( N - 1 ) ) ; i ++ ) { int cnt = 0 ; vector < char > v ; for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( ( 1 << j ) & ( i ) ) { cnt += 1 ; v . push_back ( '*' ) ; } else { v . push_back ( '+' ) ; } } if ( cnt == mul ) { deque < int > d ; d . push_back ( A [ 0 ] ) ; for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( v [ j ] == '*' ) { int x = d . back ( ) ; d . pop_back ( ) ; x = x * A [ j + 1 ] ; d . push_back ( x ) ; } else { d . push_back ( A [ j + 1 ] ) ; } } int sum = 0 ; while ( d . size ( ) > 0 ) { int x = d . front ( ) ; sum += x ; d . pop_front ( ) ; } ans = min ( ans , sum ) ; } } return ans ; }
int MinimumOperations ( int A [ ] , int N , int K ) { int Count = 0 ; int i = 0 ; while ( i < N - 1 ) { i = i + K - 1 ; Count ++ ; } return Count ; }
void findSequence ( int n , int k ) { int arr [ n ] ; int sumPos = 0 , sumNeg = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { arr [ i ] = - ( i + 1 ) ; sumNeg += arr [ i ] ; } for ( int i = n - k ; i < n ; i ++ ) { arr [ i ] = i + 1 ; sumPos += arr [ i ] ; } if ( abs ( sumNeg ) >= sumPos ) { cout << -1 ; return ; } for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
void sumOfMedians ( int arr [ ] , int N , int K ) { int selectMedian = ( K + 1 ) / 2 ; int totalArrays = N / K ; int minSum = 0 ; int i = selectMedian - 1 ; while ( i < N and totalArrays != 0 ) { minSum = minSum + arr [ i ] ; i = i + selectMedian ; totalArrays -- ; } cout << minSum ; }
void generateString ( int K ) { string s = "" ; for ( int i = 97 ; i < 97 + K ; i ++ ) { s = s + char ( i ) ; for ( int j = i + 1 ; j < 97 + K ; j ++ ) { s += char ( i ) ; s += char ( j ) ; } } s += char ( 97 ) ; cout << s ; }
int countEqual ( int A [ ] , int B [ ] , int N ) { int first = 0 ; int second = N - 1 ; int count = 0 ; while ( first < N && second >= 0 ) { if ( A [ first ] < B [ second ] ) { first ++ ; } else if ( B [ second ] < A [ first ] ) { second -- ; } else { count ++ ; first ++ ; second -- ; } } return count ; }
int minimumValue ( int N , int K ) { return ceil ( ( double ) K / ( double ) N ) ; }
void minSizeArr ( int A [ ] , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += A [ i ] ; if ( K > sum ) { cout << -1 ; return ; } if ( K == sum ) { for ( int i = 0 ; i < N ; i ++ ) { cout << A [ i ] << " " ; } return ; } int tar = sum - K ; unordered_map < int , int > um ; um [ 0 ] = -1 ; int left , right ; int cur = 0 , maxi = -1 ; for ( int i = 0 ; i < N ; i ++ ) { cur += A [ i ] ; if ( um . find ( cur - tar ) != um . end ( ) && i - um [ cur - tar ] > maxi ) { maxi = i - um [ cur - tar ] ; right = i ; left = um [ cur - tar ] ; } if ( um . find ( cur ) == um . end ( ) ) um [ cur ] = i ; } if ( maxi == -1 ) cout << -1 ; else { for ( int i = 0 ; i <= left ; i ++ ) cout << A [ i ] << " " ; for ( int i = 0 ; i < right ; i ++ ) cout << A [ N - i - 1 ] << " " ; } }
void findPath ( vector < vector < int > > & arr , int M , int N ) { for ( int row = 0 ; row < M ; row ++ ) { char dir = 'L' ; int i = row ; int j = 0 ; while ( j < N ) { if ( arr [ i ] [ j ] == 1 ) { if ( dir == 'L' ) { i -- ; dir = 'D' ; } else if ( dir == 'U' ) { j -- ; dir = 'R' ; } else if ( dir == 'R' ) { i ++ ; dir = 'U' ; } else if ( dir == 'D' ) { j ++ ; dir = 'L' ; } } else { if ( dir == 'L' ) { i ++ ; dir = 'U' ; } else if ( dir == 'U' ) { j ++ ; dir = 'L' ; } else if ( dir == 'R' ) { i -- ; dir = 'D' ; } else if ( dir == 'D' ) { j -- ; dir = 'R' ; } } if ( i < 0 i == M j < 0 j == N  ) break ; } if ( j == N ) cout << i << " " ; else cout << -1 << " " ; } }
int getSum ( int n ) { int ans = 0 ; string arr = to_string ( n ) ; for ( int i = 0 ; i < arr . length ( ) ; i ++ ) { ans += int ( arr [ i ] ) ; } return ans ; }
void minModulo ( int L , int R , int N ) { if ( R - L < N ) { int ans = INT_MAX ; for ( ll i = L ; i <= R ; i ++ ) for ( ll j = L ; j <= R ; j ++ ) if ( i != j ) ans = min ( 0ll + ans , ( i * j ) % N ) ; cout << ans ; } else { cout << 0 ; } }
int countNumbers ( int N ) { int count = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { count ++ ; if ( N / i != i ) { count ++ ; } } } return count ; }
void findEquation ( int A , int B , int C , int K ) { cout << A << " " << K * B << " " << K * K * C ; }
int calc ( int a , int b ) { return a * b + ( b - a ) ; }
int findMaximum ( vector < int > arr , int N ) { sort ( arr . begin ( ) , arr . end ( ) ) ; int ans = -1e9 ; ans = max ( ans , calc ( arr [ 0 ] , arr [ 1 ] ) ) ; ans = max ( ans , calc ( arr [ N - 2 ] , arr [ N - 1 ] ) ) ; return ans ; }
int findMin ( int arr [ ] , int N , int k ) { int pairs = 0 ; for ( int i = 0 ; i < N ; i ++ ) { pairs += arr [ i ] / 2 ; } if ( k > pairs ) return -1 ; else return 2 * k + N - 1 ; }
int minOperations ( int arr [ ] , int n ) { int oddcount = 0 , evencount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) oddcount ++ ; else evencount ++ ; } return min ( oddcount , evencount ) ; }
int minimumFlips ( int A , int B , int C ) { int res = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { int x = 0 , y = 0 , z = 0 ; if ( A & ( 1 << i ) ) { x = 1 ; } if ( B & ( 1 << i ) ) { y = 1 ; } if ( C & ( 1 << i ) ) { z = 1 ; } if ( z == 0 ) { if ( x ) { res ++ ; } if ( y ) { res ++ ; } } if ( z == 1 ) { if ( x == 0 && y == 0 ) { res ++ ; } } } return res ; }
long long gcd ( long long a , long long b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void countDistinctNumbers ( long long A , long long B , long long C ) { long long g = gcd ( A , B ) ; long long count = C / g ; cout << count ; }
void printLastElement ( int arr [ ] , int N ) { bool leftTurn = true ; int remainElements = N ; int step = 1 ; int head = 1 ; while ( remainElements > 1 ) { if ( leftTurn ) { head = head + step ; } else { if ( remainElements % 2 == 1 ) head = head + step ; } remainElements = remainElements / 2 ; step = step * 2 ; leftTurn = ! leftTurn ; } cout << arr [ head - 1 ] ; }
void findPrefixCount ( vector < int > arr , int size ) { for ( int i = 0 ; i < 32 ; i ++ ) { prefixCount [ i ] [ 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) ; for ( int j = 1 ; j < size ; j ++ ) { prefixCount [ i ] [ j ] = ( ( arr [ j ] >> i ) & 1 ) ; prefixCount [ i ] [ j ] += prefixCount [ i ] [ j - 1 ] ; } } }
void applyQuery ( int currentVal , int newVal , int size ) { for ( int i = 0 ; i < 32 ; i ++ ) { int bit1 = ( ( currentVal >> i ) & 1 ) ; int bit2 = ( ( newVal >> i ) & 1 ) ; if ( bit2 > 0 && bit1 == 0 ) prefixCount [ i ] [ size - 1 ] ++ ; else if ( bit1 > 0 && bit2 == 0 ) prefixCount [ i ] [ size - 1 ] -- ; } }
void shortestSubarray ( int * A , int N ) { int i ; int left_index ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] + 1 != A [ i + 1 ] ) break ; } left_index = i ; int right_index ; for ( i = N - 1 ; i >= 1 ; i -- ) { if ( A [ i ] != A [ i - 1 ] + 1 ) break ; } right_index = i ; int updated_right ; int minLength = min ( N - left_index - 1 , right_index ) ; if ( A [ right_index ] <= A [ left_index ] + 1 ) { updated_right = right_index + A [ left_index ] - A [ right_index ] + 1 ; if ( updated_right < N ) minLength = min ( minLength , updated_right - left_index - 1 ) ; } cout << minLength ; }
string freqCheck ( string S , int N ) { int hash [ 26 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { hash [ S [ i ] - 'a' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( hash [ i ] > 2 ) { return "Yes" ; } } return "No" ; }
int countTriplets ( int N , int K ) { if ( K % 2 == 0 ) { long long int x = N / K ; long long int y = ( N + ( K / 2 ) ) / K ; return x * x * x + y * y * y ; } else { long long int x = N / K ; return x * x * x ; } }
int minLength ( string s ) { int i = 0 , j = s . length ( ) - 1 ; for ( ; i < j && s [ i ] == s [ j ] ; ) { char d = s [ i ] ; while ( i <= j && s [ i ] == d ) i ++ ; while ( i <= j && s [ j ] == d ) j -- ; } return j - i + 1 ; }
int power ( long long x , unsigned int y ) { int res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
int CountBST ( int H ) { return power ( 2 , H ) ; }
void canBeEmptied ( int A , int B ) { if ( max ( A , B ) > 2 * min ( A , B ) ) { cout << "No" ; return ; } if ( ( A + B ) % 3 == 0 ) cout << "Yes" ; else cout << "No" ; }
bool Check ( int A [ ] [ 2 ] , int B [ ] [ 2 ] , int M , int N , int X ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j <= N - X ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { int diff = B [ i ] [ j ] - A [ i ] [ j ] ; for ( int k = 0 ; k < X ; k ++ ) { A [ i ] [ j + k ] = A [ i ] [ j + k ] + diff ; } } } } for ( int i = 0 ; i <= M - X ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { int diff = B [ i ] [ j ] - A [ i ] [ j ] ; for ( int k = 0 ; k < X ; k ++ ) { A [ i + k ] [ j ] = A [ i + k ] [ j ] + diff ; } } } } for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { return 0 ; } } } return 1 ; }
void check ( int X , int Y ) { if ( X > 3 ) { cout << "Yes" ; } else if ( X == 1 and Y == 1 ) { cout << "Yes" ; } else if ( X == 2 and Y <= 3 ) { cout << "Yes" ; } else if ( X == 3 and Y <= 3 ) { cout << "Yes" ; } else { cout << "No" ; } }
bool isPrime ( int n ) { if ( n <= 1 ) { return false ; } for ( int i = 2 ; i <= n / 2 ; ++ i ) { if ( n % i == 0 ) return false ; } return true ; }
void precompute ( ) { for ( int i = 1 ; i <= 100000 ; i ++ ) { if ( isPalindrome ( i ) ) { int sum = sumOfDigits ( i ) ; if ( isPrime ( sum ) ) arr [ i ] = 1 ; else arr [ i ] = 0 ; } else arr [ i ] = 0 ; } for ( int i = 1 ; i <= 100000 ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; } }
void minimumOperations ( vector < int > & A , int K ) { vector < int > isflipped ( A . size ( ) , 0 ) ; int ans = 0 ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) { if ( i > 0 ) { isflipped [ i ] += isflipped [ i - 1 ] ; isflipped [ i ] %= 2 ; } if ( A [ i ] == 0 && ! isflipped [ i ] ) { if ( ( A . size ( ) - i + 1 ) <= K ) { cout << -1 ; return ; } ans ++ ; isflipped [ i ] ++ ; isflipped [ i + K ] -- ; } else if ( A [ i ] == 1 && isflipped [ i ] ) { if ( ( A . size ( ) - i + 1 ) <= K ) { cout << -1 ; return ; } ans ++ ; isflipped [ i ] ++ ; isflipped [ i + K ] -- ; } } cout << ans ; }
void findScoreSum ( int n ) { int total = 0 ; int prev_monday = 0 , curr_day = 0 ; for ( int day = 1 ; day <= n ; day ++ ) { if ( day % 7 == 1 ) { prev_monday ++ ; curr_day = prev_monday ; } total += curr_day ++ ; } cout << total ; }
void findScoreSum ( int n ) { int F = n / 7 ; int D = n % 7 ; int fullWeekScore = ( 49 + 7 * F ) * F / 2 ; int lastNonFullWeekScore = ( 2 * F + D + 1 ) * D / 2 ; cout << fullWeekScore + lastNonFullWeekScore ; }
void evenXorSubarray ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int XOR = 0 ; for ( int j = i ; j < n ; j ++ ) { XOR = XOR ^ arr [ j ] ; if ( ( XOR & 1 ) == 0 ) ans ++ ; } } cout << ans ; }
void evenXorSubarray ( int arr [ ] , int n ) { int ans = 0 ; int freq [ ] = { 0 , 0 } ; int XOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { XOR = XOR ^ arr [ i ] ; if ( XOR % 2 == 0 ) { ans += freq [ 0 ] + 1 ; freq [ 0 ] ++ ; } else { ans += freq [ 1 ] ; freq [ 1 ] ++ ; } } cout << ans ; }
int getArea ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2 ) ; }
int isInside ( vector < vector < int > > triangle , vector < int > point ) { vector < int > A = triangle [ 0 ] ; vector < int > B = triangle [ 1 ] ; vector < int > C = triangle [ 2 ] ; int x = point [ 0 ] ; int y = point [ 1 ] ; int ABC = getArea ( A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] , C [ 0 ] , C [ 1 ] ) ; int BPC = getArea ( x , y , B [ 0 ] , B [ 1 ] , C [ 0 ] , C [ 1 ] ) ; int APC = getArea ( A [ 0 ] , A [ 1 ] , x , y , C [ 0 ] , C [ 1 ] ) ; int APB = getArea ( A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] , x , y ) ; return ABC == ( APC + APB + BPC ) ; }
int GCD ( int a , int b ) { if ( ! b ) return a ; return GCD ( b , a % b ) ; }
int GCDArr ( vector < int > a ) { int ans = a [ 0 ] ; for ( int i : a ) ans = GCD ( ans , i ) ; return ans ; }
bool findSubseqUtil ( vector < int > a , vector < int > b , vector < int > & ans , int k , int i ) { if ( ans . size ( ) == a . size ( ) ) { if ( GCDArr ( ans ) == k ) { cout << "[" ; int m = ans . size ( ) ; for ( int i = 0 ; i < m - 1 ; i ++ ) cout << ans [ i ] << ", " ; cout << ans [ m - 1 ] << "]" ; return true ; } else return false ; } ans . push_back ( a [ i ] ) ; bool temp = findSubseqUtil ( a , b , ans , k , i + 1 ) ; if ( temp ) return true ; ans . pop_back ( ) ; ans . push_back ( b [ i ] ) ; temp = findSubseqUtil ( a , b , ans , k , i + 1 ) ; if ( temp ) return true ; ans . pop_back ( ) ; return false ; }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
int GCDArr ( vector < int > a ) { int ans = a [ 0 ] ; for ( auto val : a ) { ans = GCD ( ans , val ) ; } return ans ; }
void findString ( char S [ ] , int N ) { int strLen = 4 * N ; for ( int i = 1 ; i <= N ; i ++ ) { S [ strLen - 1 ] = '1' ; strLen -= 2 ; } for ( int i = 0 ; i < 4 * N ; i ++ ) { cout << S [ i ] ; } }
void minimumOperations ( int A [ ] , int n ) { int cnt = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( A [ i ] != ( i + 1 ) ) { if ( ( ( i - 1 ) >= 0 ) && A [ i - 1 ] == ( i + 1 ) ) { cnt ++ ; swap ( A [ i ] , A [ i - 1 ] ) ; } else if ( ( ( i - 2 ) >= 0 ) && A [ i - 2 ] == ( i + 1 ) ) { cnt += 2 ; A [ i - 2 ] = A [ i - 1 ] ; A [ i - 1 ] = A [ i ] ; A [ i ] = i + 1 ; } else { cout << -1 ; return ; } } } cout << cnt ; }
int countOccurrences ( int n , int x ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( x % i == 0 ) { if ( x / i <= n ) count ++ ; } } cout << count ; }
int countOccurrences ( int N , int X ) { int count = 0 ; for ( int i = 1 ; i < sqrt ( X ) ; i ++ ) { if ( X % i == 0 ) { int a = i ; int b = X / i ; if ( a <= N && b <= N ) { if ( a == b ) count += 1 ; else count += 2 ; } } } return count ; }
void countOfPrimefactors ( vector < int > & CountDistinct ) { bool prime [ MAX + 1 ] ; for ( int i = 0 ; i <= MAX ; i ++ ) { CountDistinct [ i ] = 0 ; prime [ i ] = true ; } for ( long long int i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) { CountDistinct [ i ] = 1 ; for ( long long int j = i * 2 ; j <= MAX ; j += i ) { CountDistinct [ j ] ++ ; prime [ j ] = false ; } } } }
int CountEvenPair ( int A [ ] , int B [ ] , int N , int M ) { vector < int > countDistinct ( MAX + 1 ) ; countOfPrimefactors ( countDistinct ) ; int evenCount = 0 ; int oddCount = 0 ; int evenPairs = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( countDistinct [ B [ i ] ] == 0 ) continue ; if ( countDistinct [ B [ i ] ] & 1 ) { oddCount ++ ; } else { evenCount ++ ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( countDistinct [ A [ i ] ] == 0 ) continue ; if ( countDistinct [ A [ i ] ] & 1 ) { evenPairs += ( evenCount ) ; } else { evenPairs += evenCount + oddCount ; } } return evenPairs ; }
void maxOccuringCharacter ( string s ) { int count0 = 0 , count1 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '1' ) { count1 ++ ; } else if ( s [ i ] == '0' ) { count0 ++ ; } } int prev = -1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '1' ) { prev = i ; break ; } } for ( int i = prev + 1 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != 'X' ) { if ( s [ i ] == '1' ) { count1 += i - prev - 1 ; prev = i ; } else { bool flag = true ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s [ j ] == '1' ) { flag = false ; prev = j ; break ; } } if ( ! flag ) { i = prev ; } else { i = s . length ( ) ; } } } } prev = -1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '0' ) { prev = i ; break ; } } for ( int i = prev + 1 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != 'X' ) { if ( s [ i ] == '0' ) { count0 += i - prev - 1 ; prev = i ; } else { bool flag = true ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s [ j ] == '0' ) { prev = j ; flag = false ; break ; } } if ( ! flag ) { i = prev ; } else { i = s . length ( ) ; } } } } if ( s [ 0 ] == 'X' ) { int count = 0 ; int i = 0 ; while ( s [ i ] == 'X' ) { count ++ ; i ++ ; } if ( s [ i ] == '1' ) { count1 += count ; } } if ( s [ ( s . length ( ) - 1 ) ] == 'X' ) { int count = 0 ; int i = s . length ( ) - 1 ; while ( s [ i ] == 'X' ) { count ++ ; i -- ; } if ( s [ i ] == '0' ) { count0 += count ; } } if ( count0 == count1 ) { cout << "X" << endl ; } else if ( count0 > count1 ) { cout << 0 << endl ; } else cout << 1 << endl ; }
void minRequiredOperation ( int arr [ ] , int N , int K ) { int TotalSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) TotalSum += arr [ i ] ; int maxLen = longestSubarray ( arr , N , TotalSum - K ) ; if ( maxLen == -1 ) { cout << -1 ; } else cout << N - maxLen ; }
void minimumDeletions ( string s ) { int n = s . length ( ) ; int ans = n ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int t = s [ i ] - '0' ; if ( t % 2 == 0 ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { int num = ( s [ j ] - '0' ) * 10 + t ; if ( num % 4 == 0 ) { int k1 = i - j - 1 ; int k2 = n - i - 1 ; ans = min ( ans , k1 + k2 ) ; } } } } if ( ans == n ) { for ( int i = 0 ; i < n ; i ++ ) { int num = s [ i ] - '0' ; if ( num % 4 == 0 ) { ans = n - 1 ; } } } cout << ans ; }
bool isVowel ( char ch ) { if ( ch == 'a' ch == 'e' ch == 'i' ch == 'o' ch == 'u' ) return true ; if ( ch == 'A' ch == 'E' ch == 'I' ch == 'O' ch == 'U' ) return true ; return false ; }
void winner ( int arr [ ] , int N ) { if ( N % 2 == 1 ) { cout << "A" ; } else { cout << "B" ; } }
void LCMPairs ( int arr [ ] , int N ) { int total_pairs = ( N * ( N - 1 ) ) / 2 ; int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; } odd = ( odd * ( odd - 1 ) ) / 2 ; cout << "Even = " << total_pairs - odd << ", Odd = " << odd ; }
void getMaxSum ( vector < vector < int > > A , int M , int N ) { int sum = 0 ; int negative = 0 ; int minVal = INT_MAX ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { sum += abs ( A [ i ] [ j ] ) ; if ( A [ i ] [ j ] < 0 ) { negative ++ ; } minVal = min ( minVal , abs ( A [ i ] [ j ] ) ) ; } } if ( negative % 2 ) { sum -= 2 * minVal ; } cout << sum ; }
static int printNumber ( int N , int K , int M ) { int sum = K * ( M * ( M + 1 ) / 2 ) ; return sum - N ; }
void countEvenOdd ( int L , int R ) { int range = R - L + 1 ; int even = ( range / 4 ) * 2 ; if ( ( L & 1 ) && ( range % 4 == 3 ) ) { even ++ ; } else if ( ! ( L & 1 ) && ( range % 4 ) ) { even ++ ; } cout << "Even = " << even << ", Odd = " << range - even ; }
void findPerfectIndex ( int N , int K ) { int i = 0 ; for ( ; i < K ; i ++ ) { cout << ( N - K + 1 ) + i << " " ; } for ( ; i < N ; i ++ ) { cout << i - K + 1 << " " ; } }
bool isPrime ( int N ) { if ( N <= 1 ) return false ; for ( int i = 2 ; i <= sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; }
void countPrimeTuples ( int N ) { int count = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( isPrime ( i ) && isPrime ( i - 2 ) ) count ++ ; } cout << count ; }
void countPairs ( int A [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( A [ i ] A [ j ] ) > ( A [ i ] & A [ j ] ) ) { count ++ ; } } cout << count ; }
void checkArrays ( int arr1 [ ] , int arr2 [ ] , int N ) { int count = 0 ; bool flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) { if ( arr1 [ i ] == 0 ) count ++ ; else { count -- ; if ( count < 0 ) { flag = 0 ; break ; } } } } if ( flag && count == 0 ) cout << "Yes" << endl ; else cout << "No" << endl ; }
void construct_Array ( int N , int K ) { for ( int i = 1 ; i <= N ; i ++ ) { cout << K * i << " " ; } }
int maxSumOfDistinctPrimeFactors ( int arr [ ] , int N , int K ) { int CountDistinct [ MAX + 1 ] ; bool prime [ MAX + 1 ] ; for ( int i = 0 ; i <= MAX ; i ++ ) { CountDistinct [ i ] = 0 ; prime [ i ] = true ; } for ( long long int i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) { CountDistinct [ i ] = 1 ; for ( long long int j = i * 2 ; j <= MAX ; j += i ) { CountDistinct [ j ] ++ ; prime [ j ] = false ; } } } int sum = 0 ; int PrimeFactor [ 20 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { PrimeFactor [ CountDistinct [ arr [ i ] ] ] ++ ; } for ( int i = 19 ; i >= 1 ; i -- ) { while ( PrimeFactor [ i ] > 0 ) { sum += i ; PrimeFactor [ i ] -- ; K -- ; if ( K == 0 ) break ; } if ( K == 0 ) break ; } cout << sum ; }
void Print ( int N ) { if ( ( N / 2 ) % 2 == 1 || ( N % 2 == 1 ) ) { cout << -1 << endl ; return ; } int CurEven = 2 , CurOdd = 1 ; int SumOdd = 0 , SumEven = 0 ; for ( int i = 0 ; i < ( N / 2 ) ; i ++ ) { cout << CurEven << " " ; SumEven += CurEven ; CurEven += 2 ; } for ( int i = 0 ; i < N / 2 - 1 ; i ++ ) { cout << CurOdd << " " ; SumOdd += CurOdd ; CurOdd += 2 ; } CurOdd = SumEven - SumOdd ; cout << CurOdd << '' ; }
int minimize ( int n ) { int optEle = n ; string strEle = to_string ( n ) ; for ( int idx = 0 ; idx < strEle . length ( ) ; idx ++ ) { int temp = stoi ( strEle . substr ( idx ) + strEle . substr ( 0 , idx ) ) ; optEle = min ( optEle , temp ) ; } return optEle ; }
int maximize ( int n ) { int optEle = n ; string strEle = to_string ( n ) ; for ( int idx = 0 ; idx < strEle . length ( ) ; idx ++ ) { int temp = stoi ( strEle . substr ( idx ) + strEle . substr ( 0 , idx ) ) ; optEle = max ( optEle , temp ) ; } return optEle ; }
int minOperations ( int arr [ ] , int N ) { map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { int res = arr [ i ] ; while ( res ) { mp [ res ] ++ ; res /= 2 ; } } int mx = 1 ; for ( auto it : mp ) { if ( it . second == N ) { mx = it . first ; } } int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int res = arr [ i ] ; while ( res != mx ) { ans ++ ; res /= 2 ; } } cout << ans ; }
int MinimumMoves ( int A [ ] , int B [ ] , int N ) { int totalOperations = 0 ; int carry = 0 ; int K = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { int nearestMultiple = ceil ( ( double ) ( A [ i ] + carry ) / ( double ) ( B [ i ] ) ) * B [ i ] ; K = nearestMultiple - ( A [ i ] + carry ) ; totalOperations += K ; carry += K ; } return totalOperations ; }
int maxSheets ( int A , int B ) { int area = A * B ; int count = 1 ; while ( area % 2 == 0 ) { area /= 2 ; count *= 2 ; } return count ; }
void minimumDeviation ( int A [ ] , int N ) { set < int > s ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) s . insert ( A [ i ] ) ; else s . insert ( 2 * A [ i ] ) ; } int diff = * s . rbegin ( ) - * s . begin ( ) ; while ( ( int ) s . size ( ) && * s . rbegin ( ) % 2 == 0 ) { int maxEl = * s . rbegin ( ) ; s . erase ( maxEl ) ; s . insert ( maxEl / 2 ) ; diff = min ( diff , * s . rbegin ( ) - * s . begin ( ) ) ; } cout << diff ; }
int findMaxNum ( int num ) { bitset < 4 > b ( num ) ; string binaryNumber = b . to_string ( ) ; string maxBinaryNumber = "" ; int count0 = 0 , count1 = 0 ; int N = 4 ; for ( int i = 0 ; i < N ; i ++ ) { if ( binaryNumber [ i ] == '1' ) { count1 ++ ; } else { count0 ++ ; } } for ( int i = 0 ; i < count1 ; i ++ ) { maxBinaryNumber += '1' ; } for ( int i = 0 ; i < count0 ; i ++ ) { maxBinaryNumber += '0' ; } return stoi ( maxBinaryNumber , 0 , 2 ) ; }
void findMinMoves ( int a , int b ) { int ans = 0 ; if ( a == b || abs ( a - b ) == 1 ) { ans = a + b ; } else { int k = min ( a , b ) ; int j = max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; } cout << ans ; }
void FindwinnerOfGame ( string & S ) { int cntZero = 0 ; int cntConOne = 0 ; int nimSum = 0 ; int N = S . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '1' ) { cntConOne += 1 ; } else { nimSum ^= cntConOne ; cntConOne = 0 ; cntZero ++ ; } } nimSum ^= cntConOne ; if ( cntZero % 2 == 0 ) { cout << "Tie" ; } else if ( nimSum ) { cout << "player 1" ; } else { cout << "player 2" ; } }
string check ( int current_row , int current_col , int destination_row , int destination_col ) { if ( current_row == destination_row ) return "POSSIBLE" ; else if ( current_col == destination_col ) return "POSSIBLE" ; else return "NOT POSSIBLE" ; }
int maxChange ( string str ) { if ( str . size ( ) <= 1 ) { return 0 ; } int minChanges = 0 ; for ( int i = 0 ; i < str . size ( ) - 1 ; i ++ ) { if ( str [ i ] == str [ i + 1 ] ) { str [ i + 1 ] = 'N' ; minChanges += 1 ; } else if ( i > 0 && str [ i - 1 ] == str [ i + 1 ] ) { str [ i + 1 ] = 'N' ; minChanges += 1 ; } } return minChanges ; }
void generatepermutation ( int N ) { vector < int > answer ; answer . push_back ( N ) ; for ( int i = 1 ; i < N ; i ++ ) { answer . push_back ( i ) ; } for ( int i : answer ) cout << i << " " ; }
int maxNumPalindrome ( string S ) { int i = 0 ; int freq [ 26 ] = { 0 } ; int freqPair = 0 ; int len = S . length ( ) / 3 ; while ( i < S . length ( ) ) { freq [ S [ i ] - 'a' ] ++ ; i ++ ; } for ( i = 0 ; i < 26 ; i ++ ) { freqPair += ( freq [ i ] / 2 ) ; } return min ( freqPair , len ) ; }
long long cntEvenSumPairs ( long long X , long long Y ) { long long cntXEvenNums = X / 2 ; long long cntXOddNums = ( X + 1 ) / 2 ; long long cntYEvenNums = Y / 2 ; long long cntYOddNums = ( Y + 1 ) / 2 ; long long cntPairs = ( cntXEvenNums * 1LL * cntYEvenNums ) + ( cntXOddNums * 1LL * cntYOddNums ) ; return cntPairs ; }
void farthestCellDistance ( int N , int M , int R , int C ) { int d1 = N + M - R - C ; int d2 = R + C - 2 ; int d3 = N - R + C - 1 ; int d4 = M - C + R - 1 ; int maxDistance = max ( d1 , max ( d2 , max ( d3 , d4 ) ) ) ; cout << maxDistance ; }
int maxSum ( int arr [ ] , int N ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { int t = i ; if ( t + arr [ i ] < N ) { arr [ i ] += arr [ t + arr [ i ] ] ; } } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << ' ' ; } }
void constructArray ( int arr [ ] , int N ) { int brr [ N ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int K = log ( arr [ i ] ) / log ( 2 ) ; int R = pow ( 2 , K ) ; brr [ i ] = R ; } for ( int i = 0 ; i < N ; i ++ ) { cout << brr [ i ] << " " ; } }
void findMinKToMakeAllEqual ( int N , int A [ ] ) { set < int > B ; for ( int i = 0 ; i < N ; i ++ ) B . insert ( A [ i ] ) ; int M = B . size ( ) ; set < int > :: iterator itr = B . begin ( ) ; if ( M > 3 ) printf ( "-1" ) ; else if ( M == 3 ) { int B_1 = * itr ; int B_2 = * ( ++ itr ) ; int B_3 = * ( ++ itr ) ; if ( B_2 - B_1 == B_3 - B_2 ) printf ( "%d" , B_2 - B_1 ) ; else printf ( "-1" ) ; } else if ( M == 2 ) { int B_1 = * itr ; int B_2 = * ( ++ itr ) ; if ( ( B_2 - B_1 ) % 2 == 0 ) printf ( "%d" , ( B_2 - B_1 ) / 2 ) ; else printf ( "%d" , B_2 - B_1 ) ; } else printf ( "%d" , 0 ) ; }
void minOpsToTurnArrToZero ( int arr [ ] , int N ) { unordered_set < int > st ; for ( int i = 0 ; i < N ; i ++ ) { if ( st . find ( arr [ i ] ) != st . end ( ) arr [ i ] == 0 ) { continue ; } else { st . insert ( arr [ i ] ) ; } } cout << st . size ( ) << endl ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void splitArray ( int arr [ ] , int N ) { map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } int G = 0 ; for ( auto i : mp ) { G = gcd ( G , i . second ) ; } if ( G > 1 ) cout << "YES" ; else cout << "NO" ; }
int minMoves ( vector < int > arr ) { int N = arr . size ( ) ; if ( N <= 2 ) return 0 ; int ans = INT_MAX ; for ( int i = -1 ; i <= 1 ; i ++ ) { for ( int j = -1 ; j <= 1 ; j ++ ) { int num1 = arr [ 0 ] + i ; int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = abs ( i ) + abs ( j ) ; for ( int idx = 2 ; idx < N ; idx ++ ) { int num = num1 + num2 ; if ( abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag ) ans = min ( ans , moves ) ; } } if ( ans == INT_MAX ) return -1 ; return ans ; }
void querySum ( int arr [ ] , int N , int Q [ ] [ 2 ] , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ; int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } cout << sum << " " ; } }
bool CheckAllEqual ( int arr [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return false ; } } return true ; }
int minCntOperations ( int arr [ ] , int N ) { int Max = * max_element ( arr , arr + N ) ; bool isPower2 = ! ( Max && ( Max & ( Max - 1 ) ) ) ; if ( isPower2 && CheckAllEqual ( arr , N ) ) { return log2 ( Max ) ; } else { return ceil ( log2 ( Max ) ) + 1 ; } }
string greatestReducedNumber ( string num , string s ) { vector < bool > vis_s ( 10 , false ) ; for ( int i = 0 ; i < ( int ) s . size ( ) ; i ++ ) { vis_s [ int ( s [ i ] ) - 48 ] = true ; } int n = num . size ( ) ; int in = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis_s [ ( int ) num [ i ] - '0' ] ) { in = i ; break ; } } if ( in == -1 ) { return num ; } for ( char dig = num [ in ] ; dig >= '0' ; dig -- ) { if ( vis_s [ ( int ) dig - '0' ] == 0 ) { num [ in ] = dig ; break ; } } char LargestDig = '0' ; for ( char dig = '9' ; dig >= '0' ; dig -- ) { if ( vis_s [ dig - '0' ] == false ) { LargestDig = dig ; break ; } } for ( int i = in + 1 ; i < n ; i ++ ) { num [ i ] = LargestDig ; } int Count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( num [ i ] == '0' ) Count ++ ; else break ; } num . erase ( 0 , Count ) ; if ( ( int ) num . size ( ) == 0 ) return "0" ; return num ; }
void minXOR ( vector < int > & Arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( Arr [ i ] == 2 ) { cout << ( Arr [ i ] ^ 3 ) << " " ; } else { cout << ( Arr [ i ] ^ 2 ) << " " ; } } }
vector < int > findArray ( int n ) { vector < int > Arr ( n + 1 ) ; Arr [ 0 ] = 0 ; Arr [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { Arr [ i ] = Arr [ i / 2 ] ; } else { Arr [ i ] = Arr [ ( i - 1 ) / 2 ] + Arr [ ( i - 1 ) / 2 + 1 ] ; } } return Arr ; }
int maxElement ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; vector < int > Arr = findArray ( n ) ; return * max_element ( Arr . begin ( ) , Arr . end ( ) ) ; }
int findMaxValByRearrArr ( int arr [ ] , int N ) { int res = 0 ; res = ( N * ( N + 1 ) ) / 2 ; return res ; }
int min_steps_required ( int n , int m , int r , int c ) { int i , j ; int corner_steps_req = INT_MAX ; i = 1 ; j = 1 ; corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; i = n ; j = 1 ; corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; i = 1 ; j = m ; corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; i = n ; j = m ; corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; int minimum_steps = min ( 2 * ( n - 1 ) + m - 1 , 2 * ( m - 1 ) + n - 1 ) ; return minimum_steps + corner_steps_req ; }
int min_elements ( int arr [ ] , int N , int K ) { map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } vector < int > Freq ; for ( auto it : mp ) { int i = it . first ; Freq . push_back ( mp [ i ] ) ; } sort ( Freq . rbegin ( ) , Freq . rend ( ) ) ; int len = Freq . size ( ) ; if ( len <= K ) { return 0 ; } int cntMin = 0 ; for ( int i = K ; i < len ; i ++ ) { cntMin += Freq [ i ] ; } return cntMin ; }
int sumzero ( int arr [ ] , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum == 0 ) cout << "Yes" ; else if ( sum > 0 ) { if ( sum % K == 0 ) cout << "Yes" ; else cout << "No" ; } else cout << "No" ; return 0 ; }
int cntOnesArrWithGivenOp ( int arr [ ] , int N ) { int cntOnes = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i - 1 ; j < N ; j += i ) { arr [ j ] = ! ( arr [ j ] ) ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) { cntOnes += 1 ; } } return cntOnes ; }
int cntOnesArrWithGivenOp ( int arr [ ] , int N ) { int cntOnes = 0 ; cntOnes = sqrt ( N ) ; return cntOnes ; }
void minimumMoves ( int arr [ ] , int N ) { int sum = 0 ; int maxelement = -1 ; if ( N == 2 ) { cout << 0 ; } for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; maxelement = max ( maxelement , arr [ i ] ) ; } int K = ( sum + N - 2 ) / ( N - 1 ) ; K = max ( maxelement , K ) ; int ans = K * ( N - 1 ) - sum ; cout << ans ; }
void minimumSwaps ( int arr1 [ ] , int arr2 [ ] , int n ) { int sumArr1 = 0 , sumArr2 = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sumArr1 += arr1 [ i ] ; sumArr2 += arr2 [ i ] ; } if ( sumArr1 % 2 == 0 && sumArr2 % 2 == 0 ) { cout << 0 ; return ; } if ( sumArr1 % 2 != 0 && sumArr2 % 2 != 0 ) { int flag = -1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ( arr1 [ i ] + arr2 [ i ] ) % 2 == 1 ) { flag = 1 ; break ; } } cout << flag ; return ; } cout << -1 ; }
void corpFlightBookings ( vector < vector < int > > & Bookings , int N ) { vector < int > res ( N , 0 ) ; for ( int i = 0 ; i < Bookings . size ( ) ; i ++ ) { int l = Bookings [ i ] [ 0 ] ; int r = Bookings [ i ] [ 1 ] ; int K = Bookings [ i ] [ 2 ] ; res [ l - 1 ] = res [ l - 1 ] + K ; if ( r <= res . size ( ) - 1 ) res [ r ] = ( - K ) + res [ r ] ; } for ( int i = 1 ; i < res . size ( ) ; i ++ ) res [ i ] = res [ i ] + res [ i - 1 ] ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) { cout << res [ i ] << " " ; } }
void findOddXOR ( int n ) { if ( n % 2 == 0 ) cout << ( ( findXOR ( n ) ) ^ ( 2 * findXOR ( n / 2 ) ) ) ; else cout << ( ( findXOR ( n ) ) ^ ( 2 * findXOR ( ( n - 1 ) / 2 ) ) ) ; }
void findSmallestNumber ( int n ) { for ( int i = n ; i <= ( n + 2520 ) ; ++ i ) { bool possible = 1 ; int temp = i ; while ( temp ) { if ( temp % 10 != 0 ) { int digit = temp % 10 ; if ( i % digit != 0 ) { possible = 0 ; break ; } } temp /= 10 ; } if ( possible == 1 ) { cout << i ; return ; } } }
void path_to_root ( int node ) { while ( node >= 1 ) { cout << node << ' ' ; node /= 2 ; } }
int minValue ( int arr [ ] , int n ) { int minimum = * min_element ( arr , arr + n ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] - minimum ) ; } return sum ; }
void computeLPSArray ( string pat , int M , int * lps ) { int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < M ) { if ( pat [ i ] == pat [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } }
char lastRemovedCharacter ( string str ) { int n = str . length ( ) ; if ( n == 1 ) return str [ 0 ] ; if ( str [ n - 2 ] == '0' ) { return ( '1' - str [ n - 1 ] + '0' ) ; } else return str [ n - 1 ] ; }
void findNumbers ( int aXORb , int aANDb , int aXORc , int aANDc , int bXORc , int bANDc ) { int a , b , c ; int aSUMb ; int aSUMc ; int bSUMc ; aSUMb = aXORb + aANDb * 2 ; aSUMc = aXORc + aANDc * 2 ; bSUMc = bXORc + bANDc * 2 ; a = ( aSUMb - bSUMc + aSUMc ) / 2 ; b = aSUMb - a ; c = aSUMc - a ; cout << "a = " << a ; cout << ", b = " << b ; cout << ", c = " << c ; }
void findArray ( int N , int K ) { if ( N == 1 ) { cout << " " << K ; return ; } if ( N == 2 ) { cout << 0 << " " << K ; return ; } int P = N - 2 ; int Q = N - 1 ; int VAL = 0 ; for ( int i = 1 ; i <= ( N - 3 ) ; i ++ ) { cout << " " << i ; VAL ^= i ; } if ( VAL == K ) { cout << P << " " << Q << " " << ( P ^ Q ) ; } else { cout << 0 << " " << P << " " << ( P ^ K ^ VAL ) ; } }
int findNumber ( int N ) { int count = 0 ; while ( ( N & 1 ) == 1 ) { N = N >> 1 ; count ++ ; } return N << count ; }
int findNumber ( int N ) { return N & ( N + 1 ) ; }
void array_divisbleby_k ( int N , int K ) { bool flag = false ; int d1 , d2 ; for ( int i = 2 ; i * i <= K ; i ++ ) { if ( K % i == 0 ) { flag = true ; d1 = i ; d2 = K / i ; break ; } } if ( flag ) { for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 1 ) { cout << d2 << " " ; } else { cout << d1 << " " ; } } } else { cout << -1 ; } }
int min_elements ( int arr [ ] , int N ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } int cntMinRem = 0 ; for ( auto it : mp ) { int i = it . first ; if ( mp [ i ] < i ) { cntMinRem += mp [ i ] ; } else if ( mp [ i ] > i ) { cntMinRem += ( mp [ i ] - i ) ; } } return cntMinRem ; }
bool CheckAllarrayEqual ( int arr [ ] , int N ) { if ( N == 1 ) { return true ; } int totalSum = arr [ 0 ] ; int secMax = INT_MIN ; int Max = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] >= Max ) { secMax = Max ; Max = arr [ i ] ; } else if ( arr [ i ] > secMax ) { secMax = arr [ i ] ; } totalSum += arr [ i ] ; } if ( ( secMax * ( N - 1 ) ) > totalSum ) { return false ; } if ( totalSum % ( N - 1 ) ) { return false ; } return true ; }
int getSum ( vector < int > & ar ) { int sum = 0 ; for ( int i : ar ) { sum += i ; } return sum ; }
int getMinSum ( int pos , vector < int > & arr , vector < int > & primePow ) { if ( pos == primePow . size ( ) ) { return getSum ( arr ) ; } int res = INT_MAX ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { arr [ i ] *= primePow [ pos ] ; res = min ( res , getMinSum ( pos + 1 , arr , primePow ) ) ; arr [ i ] /= primePow [ pos ] ; } return res ; }
int minimumSumWithGivenLCM ( int k , int x ) { vector < int > primePow = primePower ( x ) ; int n = primePow . size ( ) ; int sum = 0 ; if ( n <= k ) { for ( int i : primePow ) { sum += i ; } sum += k - n ; } else { vector < int > arr ( k , 1 ) ; sum = getMinSum ( 0 , arr , primePow ) ; } return sum ; }
int IsPresent ( string & str , string & target ) { if ( str . find ( target ) != string :: npos ) { return 1 ; } return -1 ; }
int findBitwiseORGivenXORAND ( int X , int Y ) { return X + Y ; }
void minOperation ( int X [ ] , int Y [ ] , int n ) { int C = 0 ; int count = 0 ; for ( int i = 1 ; i < n ; i = i + 2 ) { if ( X [ i ] != Y [ i ] ) { count ++ ; } else { if ( count != 0 ) C ++ ; count = 0 ; } } if ( count != 0 ) C ++ ; count = 0 ; for ( int i = 0 ; i < n ; i = i + 2 ) { if ( X [ i ] != Y [ i ] ) { count ++ ; } else { if ( count != 0 ) C ++ ; count = 0 ; } } if ( count != 0 ) C ++ ; cout << C ; }
int minimumcntOperationReq ( int arr [ ] , int N ) { int cntOp = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { cntOp ++ ; } } return ( cntOp + 1 ) / 2 ; }
void ConstArrayAdjacentCoprime ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { cout << i << " " ; } }
int cntIndexesToMakeBalance ( int arr [ ] , int n ) { if ( n == 1 ) { return 1 ; } if ( n == 2 ) return 0 ; int sumEven = 0 ; int sumOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { sumEven += arr [ i ] ; } else { sumOdd += arr [ i ] ; } } int currOdd = 0 ; int currEven = arr [ 0 ] ; int res = 0 ; int newEvenSum = 0 ; int newOddSum = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( i % 2 ) { currOdd += arr [ i ] ; newEvenSum = currEven + sumOdd - currOdd ; newOddSum = currOdd + sumEven - currEven - arr [ i ] ; } else { currEven += arr [ i ] ; newOddSum = currOdd + sumEven - currEven ; newEvenSum = currEven + sumOdd - currOdd - arr [ i ] ; } if ( newEvenSum == newOddSum ) { res ++ ; } } if ( sumOdd == sumEven - arr [ 0 ] ) { res ++ ; } if ( n % 2 == 1 ) { if ( sumOdd == sumEven - arr [ n - 1 ] ) { res ++ ; } } else { if ( sumEven == sumOdd - arr [ n - 1 ] ) { res ++ ; } } return res ; }
int findMinOperationsReqEmpStr ( string str ) { int cntOne = 0 ; int cntZero = 0 ; int N = str . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == '0' ) { if ( cntOne ) { cntOne -- ; } cntZero ++ ; } else { if ( cntZero ) { cntZero -- ; } cntOne ++ ; } } return ( cntOne + cntZero ) ; }
int minimumOperations ( string & S , int m ) { int V = 100 ; vector < int > adj [ V ] ; int total = 0 , N = S . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { addEdge ( adj , i , N - i - 1 ) ; addEdge ( adj , N - i - 1 , i ) ; } for ( int i = 0 ; i < N - m ; i ++ ) { addEdge ( adj , i , i + m ) ; addEdge ( adj , i + m , i ) ; } vector < bool > visited ( V , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! visited [ i ] ) { int fre [ 26 ] = { 0 } ; int cnt = 0 , maxx = -1 ; DFS ( i , adj , cnt , visited , fre , S ) ; for ( int j = 0 ; j < 26 ; j ++ ) maxx = max ( maxx , fre [ j ] ) ; total += cnt - maxx ; } } cout << total ; }
int countChanges ( vector < vector < char > > mat ) { int n = mat . size ( ) ; int m = mat [ 0 ] . size ( ) ; int ans = 0 ; for ( int j = 0 ; j < m - 1 ; j ++ ) { if ( mat [ n - 1 ] [ j ] != 'R' ) ans ++ ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( mat [ i ] [ m - 1 ] != 'D' ) ans ++ ; } return ans ; }
int findMaxSumByAlternatingSign ( int arr [ ] , int N ) { int cntNeg = 0 ; int MaxAltSum = 0 ; int SmValue = 0 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 0 ) { cntNeg += 1 ; } sum += abs ( arr [ i ] ) ; SmValue = min ( SmValue , abs ( arr [ i ] ) ) ; } MaxAltSum = sum ; if ( cntNeg & 1 ) { MaxAltSum -= 2 * SmValue ; } return MaxAltSum ; }
int minCntCharDeletionsfrequency ( string & str , int N ) { unordered_map < char , int > mp ; priority_queue < int > pq ; int cntChar = 0 ; for ( int i = 0 ; i < N ; i ++ ) { mp [ str [ i ] ] ++ ; } for ( auto it : mp ) { pq . push ( it . second ) ; } while ( ! pq . empty ( ) ) { int frequent = pq . top ( ) ; pq . pop ( ) ; if ( pq . empty ( ) ) { return cntChar ; } if ( frequent == pq . top ( ) ) { if ( frequent > 1 ) { pq . push ( frequent - 1 ) ; } cntChar ++ ; } } return cntChar ; }
void constructNewArraySumZero ( int arr [ ] , int N ) { int newArr [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { newArr [ i ] = arr [ i + 1 ] ; } else { newArr [ i ] = - arr [ i - 1 ] ; } } for ( int i = 0 ; i < N ; i ++ ) { cout << newArr [ i ] << " " ; } }
int minimumCntOfFlipsRequired ( string str ) { int n = str . length ( ) ; int zeros = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) { zeros ++ ; } } if ( zeros == 0 zeros == n ) { return 0 ; } int minFlips = INT_MAX ; int currOnes = 0 ; int flips ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { currOnes ++ ; } flips = currOnes + ( zeros - ( i + 1 - currOnes ) ) ; minFlips = min ( minFlips , flips ) ; } return minFlips ; }
void constructMEX ( int arr [ ] , int N ) { int hash [ MAXN ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { hash [ arr [ i ] ] = 1 ; } int MexOfArr ; for ( int i = 1 ; i < MAXN ; i ++ ) { if ( hash [ i ] == 0 ) { MexOfArr = i ; break ; } } int B [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < MexOfArr ) B [ i ] = arr [ i ] ; else B [ i ] = MexOfArr ; } for ( int i = 0 ; i < N ; i ++ ) cout << B [ i ] << ' ' ; }
void smallestNumberLeftInPQ ( int arr [ ] , int N ) { priority_queue < int > pq ; vector < pair < int , int > > pairsArr ; for ( int i = 0 ; i < N ; i ++ ) { pq . push ( arr [ i ] ) ; } while ( pq . size ( ) > 1 ) { int X = pq . top ( ) ; pq . pop ( ) ; int Y = pq . top ( ) ; pq . pop ( ) ; pq . push ( ( X + Y + 1 ) / 2 ) ; pairsArr . push_back ( { X , Y } ) ; } cout << "{" << pq . top ( ) << "}, " ; int sz = pairsArr . size ( ) ; for ( int i = 0 ; i < sz ; i ++ ) { if ( i == 0 ) { cout << "{ " ; } cout << "(" << pairsArr [ i ] . first << ", " << pairsArr [ i ] . second << ")" ; if ( i != sz - 1 ) { cout << ", " ; } if ( i == sz - 1 ) { cout << " }" ; } } }
void findPairs ( int N ) { for ( int i = 0 ; i <= N ; i ++ ) { cout << "(" << i << ", " << N - i << "), " ; } }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
void canReach ( int N , int A , int B , int K ) { int gcd = GCD ( N , K ) ; if ( abs ( A - B ) % gcd == 0 ) { cout << "Yes" ; } else { cout << "No" ; } }
int sum ( int n ) { int res = 0 ; while ( n > 0 ) { res += n % 10 ; n /= 10 ; } return res ; }
int smallestNumber ( int n , int s ) { if ( sum ( n ) <= s ) { return n ; } int ans = n , k = 1 ; for ( int i = 0 ; i < 9 ; ++ i ) { int digit = ( ans / k ) % 10 ; int add = k * ( ( 10 - digit ) % 10 ) ; ans += add ; if ( sum ( ans ) <= s ) { break ; } k *= 10 ; } return ans ; }
int separate ( int arr [ ] , int n , int parity ) { int count = 1 , res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( ( arr [ i ] + parity ) & 1 ) && ( ( arr [ i - 1 ] + parity ) & 1 ) ) count ++ ; else { if ( count > 1 ) res += count - 1 ; count = 1 ; } } return res ; }
void requiredOps ( int arr [ ] , int N ) { int res1 = separate ( arr , N , 0 ) ; int res2 = separate ( arr , N , 1 ) ; cout << max ( res1 , res2 ) ; }
vector < bool > SieveOfEratosthenes ( int N ) { vector < bool > isPrime ( N , true ) ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( isPrime [ p ] ) { for ( int i = p * p ; i <= N ; i += p ) { isPrime [ i ] = false ; } } } return isPrime ; }
int cntPairsdiffOfPrimeisPrime ( int N ) { int cntPairs = 0 ; vector < bool > isPrime = SieveOfEratosthenes ( N ) ; for ( int i = 2 ; i <= N ; i ++ ) { if ( isPrime [ i ] && isPrime [ i - 2 ] ) { cntPairs += 2 ; } } return cntPairs ; }
void longestSubsequence ( int arr [ ] , int N ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count ++ ; } } cout << count << endl ; }
int substringCount ( string s ) { vector < int > freq ( 26 , 0 ) ; char max_char = '#' ; int maxfreq = INT_MIN ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { freq [ s [ i ] - 'a' ] ++ ; if ( maxfreq < freq [ s [ i ] - 'a' ] ) maxfreq = freq [ s [ i ] - 'a' ] ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( maxfreq == freq [ i ] ) { max_char = ( char ) ( i + 'a' ) ; break ; } } int ans = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { char ch = s [ i ] ; if ( max_char == ch ) { ans += ( s . size ( ) - i ) ; } } return ans ; }
int findSum ( vector < int > S , int n , int x ) { vector < vector < int > > table ( n + 1 , vector < int > ( x + 1 , 0 ) ) ; for ( int i = 1 ; i <= x ; i ++ ) { table [ 0 ] [ i ] = INT_MAX - 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= x ; j ++ ) { if ( S [ i - 1 ] > j ) { table [ i ] [ j ] = table [ i - 1 ] [ j ] ; } else { table [ i ] [ j ] = min ( table [ i - 1 ] [ j ] , table [ i ] [ j - S [ i - 1 ] ] + 1 ) ; } } } return ( table [ n ] [ x ] > n ) ? -1 : table [ n ] [ x ] ; }
void minRemovals ( vector < int > arr , int n , int m , int x ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int requied_Sum = 0 ; if ( sum % m < x ) requied_Sum = m + sum % m - x ; else requied_Sum = sum % m - x ; cout << findSum ( arr , n , requied_Sum ) ; }
void findXandYwithminABSX_Y ( int N ) { if ( N % 2 == 1 ) { cout << ( N / 2 ) << " " << ( N / 2 + 1 ) ; } else { cout << ( N / 2 - 1 ) << " " << ( N / 2 + 1 ) ; } }
string removeDuplicateLetters ( string s ) { int cnt [ 26 ] = { 0 } ; int vis [ 26 ] = { 0 } ; int n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) cnt [ s [ i ] - 'a' ] ++ ; string res = "" ; for ( int i = 0 ; i < n ; i ++ ) { cnt [ s [ i ] - 'a' ] -- ; if ( ! vis [ s [ i ] - 'a' ] ) { while ( res . size ( ) > 0 && res . back ( ) > s [ i ] && cnt [ res . back ( ) - 'a' ] > 0 ) { vis [ res . back ( ) - 'a' ] = 0 ; res . pop_back ( ) ; } res += s [ i ] ; vis [ s [ i ] - 'a' ] = 1 ; } } return res ; }
int minChange ( string s , int n ) { int L [ 26 ] = { 0 } ; int R [ 26 ] = { 0 } ; for ( int i = 0 ; i < n / 2 ; i ++ ) { char ch = s [ i ] ; L [ ch - 'a' ] ++ ; } for ( int i = n / 2 ; i < n ; i ++ ) { char ch = s [ i ] ; R [ ch - 'a' ] ++ ; } int count = n ; for ( char ch = 'a' ; ch <= 'z' ; ch ++ ) { count = min ( count , n - L [ ch - 'a' ] - R [ ch - 'a' ] ) ; } int change = n / 2 ; for ( int d = 0 ; d + 1 < 26 ; d ++ ) { change -= L [ d ] ; change += R [ d ] ; count = min ( count , change ) ; } change = n / 2 ; for ( int d = 0 ; d + 1 < 26 ; d ++ ) { change -= R [ d ] ; change += L [ d ] ; count = min ( change , count ) ; } return count ; }
int minSteps ( string S ) { string new_str ; int N = S . length ( ) ; int i = 0 ; while ( i < N ) { new_str += S [ i ] ; int j = i ; while ( i < N && S [ i ] == S [ j ] ) ++ i ; } cout << ceil ( ( new_str . size ( ) + 1 ) / 2.0 ) ; }
int MaximumSides ( int n ) { if ( n < 4 ) return -1 ; return n % 2 == 0 ? n / 2 : -1 ; }
int minimumMoves ( int n ) { int cnt2 = 0 , cnt5 = 0 ; while ( n % 2 == 0 ) { n /= 2 ; cnt2 ++ ; } while ( n % 5 == 0 ) { n /= 5 ; cnt5 ++ ; } if ( n == 1 && cnt2 <= cnt5 ) { return 2 * cnt5 - cnt2 ; } else return -1 ; }
void check ( int n ) { if ( ( n & n - 1 ) != 0 ) cout << "YES" << endl ; else cout << "NO" << endl ; }
void rearrangeArrayUtil ( vector < int > & A , vector < int > & B , int N ) { vector < int > ans = rearrangeArray ( A , B , N ) ; if ( ans . size ( ) ) { for ( auto x : ans ) { cout << x << " " ; } } else { cout << "-1" ; } }
int countOfSubarray ( int arr [ ] , int N ) { unordered_map < int , int > mp ; int answer = 0 ; int sum = 0 ; mp [ 1 ] ++ ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; answer += mp [ sum - i ] ; mp [ sum - i ] ++ ; } cout << answer ; }
void countInverse ( int arr [ ] , int N , int M ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int gcdOfMandelement = gcd ( M , arr [ i ] ) ; if ( gcdOfMandelement == 1 ) { XOR ^= arr [ i ] ; } } cout << XOR << ' ' ; }
int Moves_Calculator ( int x , int y , int row , int col ) { int total_moves = 0 ; if ( ( row - x ) > 0 && ( col - y ) > 0 ) total_moves += min ( ( row - x ) , ( col - y ) ) ; if ( ( y - 1 ) > 0 && ( x - 1 ) > 0 ) total_moves += min ( ( y - 1 ) , ( x - 1 ) ) ; if ( ( x - 1 ) > 0 && ( col - y ) > 0 ) total_moves += min ( ( x - 1 ) , ( col - y ) ) ; if ( ( row - x ) > 0 && ( y - 1 ) > 0 ) total_moves += min ( ( row - x ) , ( y - 1 ) ) ; total_moves += ( row - 1 ) + ( col - 1 ) ; int king_moves = 0 ; if ( x + 1 <= row ) king_moves += 1 ; if ( x - 1 > 0 ) king_moves += 1 ; if ( y + 1 <= col ) king_moves += 1 ; if ( y - 1 > 0 ) king_moves += 1 ; if ( x + 1 <= row && y + 1 <= col ) king_moves += 1 ; if ( x + 1 <= row && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y + 1 <= col ) king_moves += 1 ; return total_moves - king_moves ; }
int clstNum ( int N ) { return ( N - 1 ) ; }
int findMax ( vector < int > & a , int dp [ ] [ 2 ] , int i , int flag ) { if ( i == ( int ) a . size ( ) ) { return 0 ; } if ( dp [ i ] [ flag ] != -1 ) { return dp [ i ] [ flag ] ; } int ans ; if ( flag == 0 ) { ans = max ( findMax ( a , dp , i + 1 , 0 ) , a [ i ] + findMax ( a , dp , i + 1 , 1 ) ) ; } else { ans = max ( findMax ( a , dp , i + 1 , 1 ) , -1 * a [ i ] + findMax ( a , dp , i + 1 , 0 ) ) ; } return dp [ i ] [ flag ] = ans ; }
void findMaxSumUtil ( vector < int > & arr , int N ) { int dp [ N ] [ 2 ] ; memset ( dp , -1 , sizeof dp ) ; cout << findMax ( arr , dp , 0 , 0 ) ; }
int equvInverse ( int arr [ ] , int N , int P ) { int cntElem = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] * arr [ i ] ) % P == 1 ) { cntElem ++ ; } } return cntElem ; }
int power ( int K , int M ) { int res = 1 ; while ( M > 0 ) { if ( ( M & 1 ) == 1 ) { res = ( res * K ) ; } M = M >> 1 ; K = ( K * K ) ; } return res ; }
int cntWays ( int arr [ ] , int N , int K ) { int cntways = 0 ; int M = 0 ; unordered_set < int > st ; for ( int i = 0 ; i < N ; i ++ ) { st . insert ( arr [ i ] ) ; } M = st . size ( ) ; cntways = power ( K , M ) ; return cntways ; }
void minCost ( string s , int k ) { int n = s . size ( ) ; int ans = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int a [ 26 ] ; for ( int p = 0 ; p < 26 ; p ++ ) { a [ p ] = 0 ; } for ( int j = i ; j < n ; j += k ) { a [ s [ j ] - 'a' ] ++ ; } int min_cost = INT_MAX ; for ( int ch = 0 ; ch < 26 ; ch ++ ) { int cost = 0 ; for ( int tr = 0 ; tr < 26 ; tr ++ ) cost += abs ( ch - tr ) * a [ tr ] ; min_cost = min ( min_cost , cost ) ; } ans += min_cost ; } cout << ( ans ) ; }
float pairProductMean ( int arr [ ] , int N ) { vector < int > pairArray ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int pairProduct = arr [ i ] * arr [ j ] ; pairArray . push_back ( pairProduct ) ; } } int length = pairArray . size ( ) ; float sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) sum += pairArray [ i ] ; float mean ; if ( length != 0 ) mean = sum / length ; else mean = 0 ; return mean ; }
float pairProductMean ( int arr [ ] , int N ) { int suffixSumArray [ N ] ; suffixSumArray [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { suffixSumArray [ i ] = suffixSumArray [ i + 1 ] + arr [ i ] ; } int length = ( N * ( N - 1 ) ) / 2 ; float res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { res += arr [ i ] * suffixSumArray [ i + 1 ] ; } float mean ; if ( length != 0 ) mean = res / length ; else mean = 0 ; return mean ; }
int TotalXorPair ( int arr [ ] , int N ) { int totalXOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { totalXOR ^= arr [ i ] ^ arr [ j ] ; } } return totalXOR ; }
int minAbsDiff ( int N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; }
void findWinner ( string s ) { int vowels_count = 0 , consonants_count = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == 'a' s [ i ] == 'e' s [ i ] == 'i' s [ i ] == 'o' s [ i ] == 'u' ) { vowels_count ++ ; } else { consonants_count ++ ; } } if ( vowels_count == 0 ) { if ( consonants_count % 2 == 0 ) { cout << "Player B" ; } else { cout << "Player A" ; } } else if ( vowels_count == 1 && consonants_count % 2 != 0 ) { cout << "Player A" ; } else { cout << "D" ; } }
void possibleAcyclicGraph ( int N ) { cout << pow ( 2 , N - 1 ) ; return ; }
int minProd ( int X , int Y , int N ) { if ( X <= Y ) { if ( N < X ) return ( X - N ) * Y ; else { return max ( Y - ( N - X + 1 ) , 1 ) ; } } if ( Y >= N ) return ( Y - N ) * X ; return max ( X - ( N - Y + 1 ) , 1 ) ; ; }
void sieve ( ) { for ( int i = 3 ; i < MAXN ; i += 2 ) { is_prime [ i ] = 1 ; } for ( int i = 3 ; i * i < MAXN ; i += 2 ) { if ( is_prime [ i ] ) for ( int j = i * i ; j < MAXN ; j += i ) { is_prime [ j ] = 0 ; } } is_prime [ 2 ] = 1 ; for ( int i = 1 ; i < MAXN ; i ++ ) count_of_primes [ i ] = count_of_primes [ i - 1 ] + is_prime [ i ] ; }
long long int power ( long long int x , long long int y , long long int p ) { long long result = 1 ; while ( y > 0 ) { if ( y & 1 == 1 ) result = ( result * x ) % p ; x = ( x * x ) % p ; y >>= 1 ; } return result ; }
void maxSumOfSquares ( int N , int S ) { int res = 0 ; if ( S < N S > 9 * N ) { cout << ( -1 ) ; return ; } S = S - N ; int c = 0 ; while ( S > 0 ) { c ++ ; if ( S / 8 > 0 ) { res += 9 * 9 ; S -= 8 ; } else { res += ( S + 1 ) * ( S + 1 ) ; break ; } } res = res + ( N - c ) ; cout << ( res ) ; }
int cntMinSub ( int arr [ ] , int N , int K ) { int res = 0 ; int start = 0 ; int end = N - 1 ; sort ( arr , arr + N ) ; while ( end - start > 1 ) { if ( arr [ start ] + arr [ end ] <= K ) { start ++ ; } else { res ++ ; end -- ; } } if ( end - start == 1 ) { if ( arr [ start ] + arr [ end ] <= K ) { res ++ ; start ++ ; end -- ; } else { res ++ ; end -- ; } } if ( start == end ) { res ++ ; } return res ; }
int condition ( int a , int b ) { int d = abs ( a - b ) , count = 0 ; for ( int i = 1 ; i <= sqrt ( d ) ; i ++ ) { if ( d % i == 0 ) { if ( d / i == i ) count += 1 ; else count += 2 ; } } return count ; }
bool isComposite ( int N ) { for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return true ; } } return false ; }
int compositePair ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int prod = arr [ i ] * arr [ j ] ; if ( isComposite ( prod ) ) { res ++ ; } } } return res ; }
vector < bool > getPrimeNum ( ) { vector < bool > isPrime ( X , true ) ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= X ; i ++ ) { if ( isPrime [ i ] == true ) { for ( int j = i * i ; j < X ; j += i ) { isPrime [ j ] = false ; } } } return isPrime ; }
long long power ( int x , int y ) { if ( y == 0 ) return 1 ; long long int p = power ( x , y / 2 ) % mod ; p = ( p * p ) % mod ; if ( y & 1 ) { p = ( x * p ) % mod ; } return p ; }
bool checkDigits ( int n ) { do { int r = n % 10 ; if ( r == 3 r == 4 r == 6 r == 7 r == 9 ) return false ; n /= 10 ; } while ( n != 0 ) ; return true ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
int isAllPrime ( int n ) { return isPrime ( n ) && checkDigits ( n ) ; }
void generateArray ( int arr [ ] , int n ) { deque < int > ans ; for ( int i = 0 ; i < n ; i ++ ) { if ( i & 1 ) ans . push_front ( arr [ i ] ) ; else ans . push_back ( arr [ i ] ) ; } if ( n & 1 ) { reverse ( ans . begin ( ) , ans . end ( ) ) ; } for ( auto x : ans ) { cout << x << " " ; } cout << endl ; }
int No_Of_subsequences ( map < int , int > mp ) { int count = 0 ; int left = 0 ; for ( auto x : mp ) { x . second += left ; count += ( x . second / x . first ) ; left = x . second % x . first ; } return count ; }
void maximumsubsequences ( int arr [ ] , int n ) { map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; cout << No_Of_subsequences ( mp ) ; }
int power ( int X , int n ) { int res = 1 ; while ( n ) { if ( n & 1 ) res = res * X ; X = X * X ; n = n >> 1 ; } return res ; }
int closestgtNum ( int N ) { int n = log10 ( N ) + 1 ; int P = power ( 10 , n - 1 ) ; int Y = N % P ; int res = N + ( P - Y ) ; return res ; }
string closestgtNum ( string str ) { string res = "" ; int n = str . length ( ) ; if ( str [ 0 ] < '9' ) { res . push_back ( str [ 0 ] + 1 ) ; } else { res . push_back ( '1' ) ; res . push_back ( '0' ) ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { res . push_back ( '0' ) ; } return res ; }
int find_next ( int n , int k ) { int M = n + 1 ; while ( 1 ) { if ( M & ( 1ll << k ) ) break ; M ++ ; } return M ; }
bool check ( vector < int > & arr , vector < vector < int > > & pieces ) { unordered_map < int , int > m ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) m [ arr [ i ] ] = i + 1 ; for ( int i = 0 ; i < pieces . size ( ) ; i ++ ) { if ( pieces [ i ] . size ( ) == 1 && m [ pieces [ i ] [ 0 ] ] != 0 ) { continue ; } else if ( pieces [ i ] . size ( ) > 1 && m [ pieces [ i ] [ 0 ] ] != 0 ) { int idx = m [ pieces [ i ] [ 0 ] ] - 1 ; idx ++ ; if ( idx >= arr . size ( ) ) return false ; for ( int j = 1 ; j < pieces [ i ] . size ( ) ; j ++ ) { if ( arr [ idx ] == pieces [ i ] [ j ] ) { idx ++ ; if ( idx >= arr . size ( ) && j < pieces [ i ] . size ( ) - 1 ) return false ; } else { return false ; } } } else { return false ; } } return true ; }
int maximumSubarrays ( int arr [ ] , int N , int target ) { int ans = 0 ; int availIdx = -1 ; int cur_sum = 0 ; unordered_map < int , int > mp ; mp [ 0 ] = -1 ; for ( int i = 0 ; i < N ; i ++ ) { cur_sum += arr [ i ] ; if ( mp . find ( cur_sum - target ) != mp . end ( ) && mp [ cur_sum - target ] >= availIdx ) { ans ++ ; availIdx = i ; } mp [ cur_sum ] = i ; } return ans ; }
int power ( int x , int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }
void maximumPossibleSum ( int N , int X ) { cout << ( X * ( power ( 2 , N ) - 1 ) ) << endl ; }
int countOfPairs ( int x , int y ) { int counter = 1 ; while ( x y ) { int bit1 = x % 2 ; int bit2 = y % 2  ; x >>= 1 ; y >>= 1 ; if ( bit1 == 1 and bit2 == 0 ) { counter *= 2 ; continue ; } if ( bit1 & bit2 ) { counter = 0 ; break ; } }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findGCD ( int arr [ ] , int N ) { int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) { result = gcd ( result , arr [ i ] ) ; if ( result == 1 ) { return 1 ; } } return result ; }
bool check_digits ( long N ) { while ( N > 0 ) { int n = N % 10 ; if ( ( n != 0 ) && ( n != 1 ) && ( n != 4 ) && ( n != 9 ) ) { return 0 ; } N = N / 10 ; } return 1 ; }
void isFullSquare ( long N ) { if ( is_perfect ( N ) && check_digits ( N ) ) { cout << "Yes" ; } else { cout << "No" ; } }
int maxBottles ( int n , int e ) { int s = 0 , b = 0 ; int a = n ; while ( a != 0 ) { s = s + a ; a = ( a + b ) / e ; b = n - ( a * e ) ; n = a + b ; } return s ; }
ll power ( ll x , ll n ) { ll temp ; if ( n == 0 ) return 1 ; temp = power ( x , n / 2 ) ; if ( n % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }
ll count_Total_Numbers ( ll n , ll x ) { ll total , multiples = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( i % x == 0 ) multiples ++ ; } if ( n == 1 ) return multiples ; total = ( multiples - 1 ) * power ( multiples , n - 1 ) ; return total ; }
int getPosition ( int N , int M ) { if ( M > ( N / 2 ) ) { return ( M - ( N / 2 ) ) ; } return ( M + ( N / 2 ) ) ; }
void number_of_strings ( int N , int M ) { int ans = 0 ; while ( N > 0 && M > 0 ) { if ( N > M ) { if ( N >= 2 ) { N -= 2 ; -- M ; ++ ans ; } else { break ; } } else { if ( M >= 2 ) { M -= 2 ; -- N ; ++ ans ; } else { break ; } } } cout << ans ; }
int clearLastBit ( int N , int K ) { int mask = ( -1 << K + 1 ) ; return N = N & mask ; }
void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p < maxm ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i < maxm ; i += p ) prime [ i ] = false ; } } prime [ 0 ] = false ; prime [ 1 ] = false ; }
void num_prime ( ) { prime_number [ 0 ] = 0 ; for ( int i = 1 ; i <= maxm ; i ++ ) prime_number [ i ] = prime_number [ i - 1 ] + prime [ i ] ; }
void min_steps ( int arr [ ] , int n ) { SieveOfEratosthenes ( ) ; num_prime ( ) ; if ( n == 1 ) cout << "0\n" ; else if ( n == 2 ) cout << "1\n" ; else cout << prime_number [ n ] - 1 + ( n - 2 ) ; }
void findWinner ( int a [ ] , int n ) { int win = 0 ; if ( n % 2 == 0 ) win = 1 ; else win = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( i % 2 == 1 ) { if ( win == 0 && a [ i ] > 1 ) win = 1 ; } else { if ( win == 1 && a [ i ] > 1 ) win = 0 ; } } if ( win == 0 ) cout << "A" ; else cout << "B" ; }
bool isPossible ( int r , int b , int g ) { r = r % 3 ; b = b % 3 ; g = g % 3 ; if ( r == b b == g g == r ) { return true ; } else { return false ; } }
void checkWinner ( int N , int K ) { if ( N % ( K + 1 ) ) { cout << "A" ; } else { cout << "B" ; } }
int ncr ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
int countPath ( int N , int M , int K ) { int answer ; if ( K >= 2 ) answer = 0 ; else if ( K == 0 ) answer = ncr ( N + M - 2 , N - 1 ) ; else { answer = ncr ( N + M - 2 , N - 1 ) ; int X = ( N - 1 ) / 2 + ( M - 1 ) / 2 ; int Y = ( N - 1 ) / 2 ; int midCount = ncr ( X , Y ) ; X = ( ( N - 1 ) - ( N - 1 ) / 2 ) + ( ( M - 1 ) - ( M - 1 ) / 2 ) ; Y = ( ( N - 1 ) - ( N - 1 ) / 2 ) ; midCount *= ncr ( X , Y ) ; answer -= midCount ; } return answer ; }
int calculate_steps ( int arr [ ] , int n , int minimum ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int val = arr [ i ] ; if ( arr [ i ] > minimum ) { arr [ i ] = arr [ i ] - minimum ; count += arr [ i ] / 5 ; arr [ i ] = arr [ i ] % 5 ; count += arr [ i ] / 2 ; arr [ i ] = arr [ i ] % 2 ; if ( arr [ i ] ) { count ++ ; } } arr [ i ] = val ; } return count ; }
int solve ( int arr [ ] , int n ) { sort ( arr , arr + n , greater < int > ( ) ) ; int minimum = arr [ n - 1 ] ; int count1 = 0 , count2 = 0 , count3 = 0 ; count1 = calculate_steps ( arr , n , minimum ) ; count2 = calculate_steps ( arr , n , minimum - 1 ) ; count3 = calculate_steps ( arr , n , minimum - 2 ) ; return min ( count1 , min ( count2 , count3 ) ) ; }
int maxSubset ( int arr [ ] , int N , int X ) { sort ( arr , arr + N , comp ) ; int counter = 0 ; int sz = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sz ++ ; if ( arr [ i ] * sz >= X ) { counter ++ ; sz = 0 ; } } return counter ; }
int getCount ( int N , int M ) { int total_count = 0 ; total_count += ( N / 10 ) ; int x = ( N / 10 ) * 10 ; if ( ( N - x ) >= M ) { total_count = total_count + 1 ; } return total_count ; }
int maximumModuloValue ( int A [ ] , int n ) { int mn = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { mn = min ( A [ i ] , mn ) ; } return mn ; }
int RightAngled ( int a [ ] [ 2 ] , int n ) { unordered_map < int , int > xpoints ; unordered_map < int , int > ypoints ; for ( int i = 0 ; i < n ; i ++ ) { xpoints [ a [ i ] [ 0 ] ] ++ ; ypoints [ a [ i ] [ 1 ] ] ++ ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( xpoints [ a [ i ] [ 0 ] ] >= 1 && ypoints [ a [ i ] [ 1 ] ] >= 1 ) { count += ( xpoints [ a [ i ] [ 0 ] ] - 1 ) * ( ypoints [ a [ i ] [ 1 ] ] - 1 ) ; } } return count ; }
void updateQuery ( int from_x , int from_y , int to_x , int to_y , int k , int aux [ ] [ M ] ) { aux [ from_x ] [ from_y ] += k ; if ( to_x + 1 < N ) aux [ to_x + 1 ] [ from_y ] -= k ; if ( to_x + 1 < N && to_y + 1 < M ) aux [ to_x + 1 ] [ to_y + 1 ] += k ; if ( to_y + 1 < M ) aux [ from_x ] [ to_y + 1 ] -= k ; }
void RepeatingSubarray ( int arr [ ] , int N ) { if ( N < 2 ) { cout << "-1" ; } vector < int > brr ; brr . push_back ( arr [ 0 ] ) ; brr . push_back ( arr [ 1 ] ) ; for ( int i = 2 ; i < N / 2 + 1 ; i ++ ) { if ( N % i == 0 ) { bool a = false ; int n = brr . size ( ) ; int j = i ; while ( j < N ) { int K = j % i ; if ( arr [ j ] == brr [ K ] ) { j ++ ; } else { a = true ; break ; } } if ( ! a && j == N ) { printArray ( brr ) ; return ; } } brr . push_back ( arr [ i ] ) ; } cout << "-1" ; return ; }
void SieveOfEratosthenes ( int n ) { memset ( isprime , true , sizeof ( isprime ) ) ; isprime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isprime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) isprime [ i ] = false ; } } }
int KDistinctPrime ( int arr [ ] , int n , int k ) { SieveOfEratosthenes ( 2000000 ) ; map < int , int > cnt ; int result = -1 ; for ( int i = 0 , j = -1 ; i < n ; ++ i ) { int x = arr [ i ] ; if ( isprime [ x ] ) { if ( ++ cnt [ x ] == 1 ) { -- k ; } } while ( k < 0 ) { x = arr [ ++ j ] ; if ( isprime [ x ] ) { if ( -- cnt [ x ] == 0 ) { ++ k ; } } } if ( k == 0 ) result = max ( result , i - j ) ; } return result ; }
void printMissingElements ( int arr [ ] , int N ) { int b [ arr [ N - 1 ] + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( int i = arr [ 0 ] ; i <= arr [ N - 1 ] ; i ++ ) { if ( b [ i ] == 0 ) { cout << i << " " ; } } }
void SieveOfEratosthenes ( vector < int > & StorePrimes ) { bool IsPrime [ MAX_SIZE ] ; memset ( IsPrime , true , sizeof ( IsPrime ) ) ; for ( int p = 2 ; p * p < MAX_SIZE ; p ++ ) { if ( IsPrime [ p ] == true ) { for ( int i = p * p ; i < MAX_SIZE ; i += p ) IsPrime [ i ] = false ; } } for ( int p = 2 ; p < MAX_SIZE ; p ++ ) if ( IsPrime [ p ] ) StorePrimes . push_back ( p ) ; }
int Smallest_non_Prime ( vector < int > StorePrimes , int N ) { int x = StorePrimes [ N ] ; return x * x ; }
int countNestedPolygons ( int sides ) { int count = 0 ; while ( sides > 5 ) { sides /= 2 ; count += 1 ; } return count ; }
long smallestCommon ( long a , long b , long c , long d ) { if ( a == c ) return a ; if ( a > c ) { swap ( a , c ) ; swap ( b , d ) ; } long first_term_diff = ( c - a ) ; long possible_y ; for ( possible_y = 0 ; possible_y < b ; possible_y ++ ) { if ( ( first_term_diff % b + possible_y * d ) % b == 0 ) { break ; } } if ( possible_y != b ) { return c + possible_y * d ; } return -1 ; }
int isprm ( int n ) { if ( n <= 1 ) return 0 ; if ( n <= 3 ) return 1 ; if ( n % 2 == 0 n % 3 == 0 ) return 0 ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return 0 ; return 1 ; }
int NumberOfTrees ( int arr [ ] , int N ) { int maxElement = * max_element ( arr , arr + N ) ; int level [ maxElement + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { level [ arr [ i ] ] ++ ; } if ( arr [ 0 ] != 0 level [ 0 ] != 1 ) { return 0 ; } int ans = 1 ; for ( int i = 0 ; i < maxElement ; i ++ ) { for ( int j = 0 ; j < level [ i + 1 ] ; j ++ ) { ans = ( ans * level [ i ] ) % mod ; } } return ans ; }
int power ( int x , int y ) { if ( y == 0 ) return 1 ; int p = power ( x , y / 2 ) % mod ; p = ( p * p ) % mod ; if ( y & 1 ) p = ( x * p ) % mod ; return p ; }
int NumberOfTrees ( int arr [ ] , int N ) { int maxElement = * max_element ( arr , arr + N ) ; int level [ maxElement + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { level [ arr [ i ] ] ++ ; } if ( arr [ 0 ] != 0 level [ 0 ] != 1 ) { return 0 ; } int ans = 1 ; for ( int i = 0 ; i < maxElement ; i ++ ) { ans = ( ans * power ( level [ i ] , level [ i + 1 ] ) ) % mod ; } return ans ; }
int carryCount ( int num1 , int num2 ) { int count = 0 ; while ( num2 != 0 ) { int carry = num1 & num2 ; num1 = num1 ^ num2 ; num2 = carry << 1 ; count += __builtin_popcount ( num2 ) ; } return count ; }
int power ( int X , int Y , int Mod ) { if ( Y == 0 ) return 1 ; int p = power ( X , Y / 2 , Mod ) % Mod ; p = ( p * p ) % Mod ; if ( Y & 1 ) { p = ( X * p ) % Mod ; } return p ; }
int Inversefactorial ( int N ) { if ( N <= 0 ) return 1 ; int fact = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = ( fact * i ) % Mod ; } return power ( fact , Mod - 2 , Mod ) ; }
int nck ( int N , int K ) { int factN = factorial ( N ) ; int inv = Inversefactorial ( K ) ; int invFact = Inversefactorial ( N - K ) ; return ( ( ( factN * inv ) % Mod ) * invFact ) % Mod ; }
bool checkEvenSum ( int arr [ ] , int N , int size ) { int even_freq = 0 , odd_freq = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & 1 ) odd_freq ++ ; else even_freq ++ ; } if ( even_freq >= N ) return true ; else { if ( odd_freq & 1 ) { int taken = odd_freq - 1 ; int req = N - taken ; if ( even_freq < req ) { return false ; } else return true ; } else { int taken = odd_freq ; int req = N - taken ; if ( even_freq < req ) { return false ; } else return true ; } } return false ; }
int digitsOf ( int num ) { return to_string ( num ) . size ( ) ; }
int count ( int a , int tn ) { int diff = pow ( 10 , digitsOf ( a ) ) ; return ( ( tn - a ) / diff ) + 1 ; }
int countOfSubarray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) arr [ i ] -- ; int pref [ N ] ; pref [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) pref [ i ] = pref [ i - 1 ] + arr [ i ] ; map < int , int > mp ; int answer = 0 ; mp [ 0 ] ++ ; for ( int i = 0 ; i < N ; i ++ ) { answer += mp [ pref [ i ] ] ; mp [ pref [ i ] ] ++ ; } return answer ; }
int minOperations ( int a [ ] , int N ) { int num_of_ops1 , num_of_ops2 , sum ; num_of_ops1 = num_of_ops2 = sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( i % 2 == 0 && sum >= 0 ) { num_of_ops1 += ( 1 + abs ( sum ) ) ; sum = -1 ; } else if ( i % 2 == 1 && sum <= 0 ) { num_of_ops1 += ( 1 + abs ( sum ) ) ; sum = 1 ; } } sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( i % 2 == 1 && sum >= 0 ) { num_of_ops2 += ( 1 + abs ( sum ) ) ; sum = -1 ; } else if ( i % 2 == 0 && sum <= 0 ) { num_of_ops2 += ( 1 + abs ( sum ) ) ; sum = 1 ; } } return min ( num_of_ops1 , num_of_ops2 ) ; }
void printSubset ( lli n , int k ) { vector < lli > answer ; while ( n > 0 ) { lli p = log2 ( n ) ; answer . push_back ( pow ( k , p ) ) ; n %= ( int ) pow ( 2 , p ) ; } reverse ( answer . begin ( ) , answer . end ( ) ) ; for ( auto x : answer ) { cout << x << " " ; } }
void printsubset ( int n , int k ) { int count = 0 , x = 0 ; vector < int > vec ; while ( n ) { x = n & 1 ; if ( x ) { vec . push_back ( pow ( k , count ) ) ; } n = n >> 1 ; count ++ ; } for ( int i = 0 ; i < vec . size ( ) ; i ++ ) cout << vec [ i ] << " " ; }
bool checkEquall ( int arr [ ] , int N ) { int sumEven = 0 , sumOdd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i & 1 ) sumOdd += arr [ i ] ; else sumEven += arr [ i ] ; } if ( sumEven == sumOdd ) return true ; else return false ; }
bool isSumOfPower ( int n ) { bool isSum [ n + 1 ] ; vector < int > perfectPowers ; perfectPowers . push_back ( 1 ) ; for ( int i = 0 ; i < ( n + 1 ) ; i ++ ) { isSum [ i ] = false ; } for ( long long int i = 2 ; i < ( n + 1 ) ; i ++ ) { if ( isSum [ i ] == true ) { perfectPowers . push_back ( i ) ; continue ; } for ( long long int j = i * i ; j > 0 && j < ( n + 1 ) ; j *= i ) { isSum [ j ] = true ; } } for ( int i = 0 ; i < perfectPowers . size ( ) ; i ++ ) { isSum [ perfectPowers [ i ] ] = false ; } for ( int i = 0 ; i < perfectPowers . size ( ) ; i ++ ) { for ( int j = i ; j < perfectPowers . size ( ) ; j ++ ) { int sum = perfectPowers [ i ] + perfectPowers [ j ] ; if ( sum < ( n + 1 ) ) isSum [ sum ] = true ; } } return isSum [ n ] ; }
int countEvenSum ( int low , int high , int k ) { int even_count = high / 2 - ( low - 1 ) / 2 ; int odd_count = ( high + 1 ) / 2 - low / 2 ; long even_sum = 1 ; long odd_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { long prev_even = even_sum ; long prev_odd = odd_sum ; even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ; odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; } cout << ( even_sum ) ; }
void update ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] += ( i + 1 ) ; } }
void incrementCount ( int arr [ ] , int N ) { int min = 0 ; while ( check ( arr , N ) != true ) { update ( arr , N ) ; min ++ ; } cout << min ; }
void incrementCount ( int arr [ ] , int N ) { int mini = arr [ 0 ] - arr [ 1 ] ; for ( int i = 2 ; i < N ; i ++ ) { mini = min ( mini , arr [ i - 1 ] - arr [ i ] ) ; } cout << mini ; }
double Length_Diagonals ( int a , double theta ) { double p = a * sqrt ( 2 + ( 2 * cos ( theta * ( 3.141 / 180 ) ) ) ) ; double q = a * sqrt ( 2 - ( 2 * cos ( theta * ( 3.141 / 180 ) ) ) ) ; cout << fixed << setprecision ( 2 ) << p << " " << q ; }
int solve ( string s , int x , int y ) { int res = 0 ; for ( auto c : s ) { if ( c - '0' == x ) { res ++ ; swap ( x , y ) ; } } if ( x != y && res % 2 == 1 ) -- res ; return res ; }
int find_min ( string s ) { int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { count = max ( count , solve ( s , i , j ) ) ; } } return count ; }
int maxORminusXOR ( int N ) { int MSB = log2 ( N ) ; int M = 0 ; for ( int i = 0 ; i <= MSB ; i ++ ) M += ( 1 << i ) ; return M ; }
int No_of_Triangle ( int N , int K ) { if ( N < K ) return -1 ; else { int Tri_up = 0 ; Tri_up = ( ( N - K + 1 ) * ( N - K + 2 ) ) / 2 ; int Tri_down = 0 ; Tri_down = ( ( N - 2 * K + 1 ) * ( N - 2 * K + 2 ) ) / 2 ; return Tri_up + Tri_down ; } }
void AddEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; }
void Matching_dfs ( int u , int p ) { for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) { if ( adj [ u ] [ i ] != p ) { Matching_dfs ( adj [ u ] [ i ] , u ) ; } } if ( ! used [ u ] and ! used [ p ] and p != 0 ) { max_matching ++ ; used [ u ] = used [ p ] = 1 ; } }
bool canMake ( int n , int ar [ ] ) { if ( n == 1 ) return true ; else { if ( ar [ 0 ] < ar [ 1 ] ) { int i = 1 ; while ( i < n && ar [ i - 1 ] < ar [ i ] ) { i ++ ; } while ( i + 1 < n && ar [ i ] > ar [ i + 1 ] ) { i ++ ; } if ( i >= n - 1 ) return true ; else return false ; } else if ( ar [ 0 ] > ar [ 1 ] ) { int i = 1 ; while ( i < n && ar [ i - 1 ] > ar [ i ] ) { i ++ ; } while ( i + 1 < n && ar [ i ] < ar [ i + 1 ] ) { i ++ ; } if ( i >= n - 1 ) return true ; else return false ; } else { for ( int i = 2 ; i < n ; i ++ ) { if ( ar [ i - 1 ] <= ar [ i ] ) return false ; } return true ; } } }
int check_length ( int n ) { int ans = 0 ; while ( n ) { n = n >> 1 ; ans ++ ; } return ans ; }
int check_ith_bit ( int n , int i ) { return ( n & ( 1 << ( i - 1 ) ) ) ? true : false ; }
void findPair ( int A , int B , int N ) { int X , Y ; X = N - B + A ; if ( X % 2 != 0 ) { cout << "-1" ; } else { X = X / 2 ; Y = N - X ; cout << X << " " << Y ; } }
unsigned int countSetBitsUtil ( unsigned int x ) { if ( x <= 0 ) return 0 ; return ( ( x % 2 == 0 ? 0 : 1 ) + countSetBitsUtil ( x / 2 ) ) ; }
unsigned int countSetBits ( unsigned int L , unsigned int R ) { int bitCount = 0 ; for ( int i = L ; i <= R ; i ++ ) { bitCount += countSetBitsUtil ( i ) ; } return bitCount ; }
int countSetBit ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { bool k = 0 ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { ans += k ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
int countSetBits ( int L , int R ) { return abs ( countSetBit ( R ) - countSetBit ( L - 1 ) ) ; }
int countSetBits ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { int n = i ; while ( n > 0 ) { count += ( n & 1 ) ; n = n >> 1 ; } } return count ; }
void countElement ( int A [ ] , int N , int B [ ] , int M , int K ) { int cnt = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int currentElement = B [ i ] ; for ( int j = 0 ; j < N ; j ++ ) { int diff = abs ( currentElement - A [ j ] ) ; if ( diff <= K ) { cnt ++ ; break ; } } } cout << cnt ; }
double AreaofRectangle ( int L , int W ) { double area = ( W + L ) * ( W + L ) / 2 ; return area ; }
int downToZero ( int n ) { if ( n <= 3 ) return n ; vector < int > dp ( n + 1 , -1 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; int sqr ; for ( int i = 4 ; i <= n ; i ++ ) { sqr = sqrt ( i ) ; int best = INT_MAX ; while ( sqr > 1 ) { if ( i % sqr == 0 ) { best = min ( best , 1 + dp [ sqr ] ) ; } sqr -- ; } best = min ( best , 1 + dp [ i - 1 ] ) ; dp [ i ] = best ; } return dp [ n ] ; }
int downToZero ( int n ) { if ( n <= 3 ) return n ; return n % 2 == 0 ? 3 : 4 ; }
int maxSubset ( vector < int > & A , bool flag ) { int n = A . size ( ) ; int sum = 0 ; if ( flag ) { for ( int i = 1 ; i < n ; i ++ ) A [ i ] = - A [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] > 0 ) { sum += A [ i ] ; } } return sum ; }
int findBest ( vector < int > A ) { int x = maxSubset ( A , 0 ) ; int y = maxSubset ( A , 1 ) ; y = - y ; y += A [ 0 ] ; y = - y ; return max ( x , y ) ; }
int getMinCost ( vector < int > A , vector < int > B , int N ) { int mini = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { mini = min ( mini , min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; }
int countSwaps ( int A [ ] , int n ) { sort ( A , A + n ) ; int ind = 1 , res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( ind < n and A [ ind ] == A [ i ] ) ind ++ ; if ( ind < n and A [ ind ] > A [ i ] ) { res ++ ; ind ++ ; } if ( ind >= n ) break ; } return res ; }
int countSwaps ( int A [ ] , int n ) { map < int , int > mp ; int max_frequency = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mp [ A [ i ] ] ++ ; max_frequency = max ( max_frequency , mp [ A [ i ] ] ) ; } return n - max_frequency ; }
int min_operation ( int a [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 ) ans += abs ( a [ i ] - a [ i - 1 ] ) ; else ans += abs ( a [ i ] ) ; } return ans ; }
int minimumrequired ( int A [ ] , int N ) { int K = N ; int ans ; while ( K > 0 ) { if ( K % 2 == 1 ) { ans = K ; break ; } bool ispalindrome = 1 ; for ( int i = 0 ; i < K / 2 ; i ++ ) { if ( A [ i ] != A [ K - 1 - i ] ) ispalindrome = 0 ; } if ( ispalindrome ) { ans = K / 2 ; K /= 2 ; } else { ans = K ; break ; } } return ans ; }
void count ( int n , int k ) { long count = ( long ) ( pow ( 10 , k ) - pow ( 10 , k - 1 ) ) ; cout << ( count ) ; }
int maxSelections ( int A [ ] , int n , int k ) { sort ( A , A + n ) ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + A [ i ] ; if ( sum > k ) { break ; } count ++ ; } return count ; }
int getMaxDifference ( int N ) { int M = -1 ; int maxDiff = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int diff = ( N ^ i ) - ( N & i ) ; if ( diff >= maxDiff ) { maxDiff = diff ; M = i ; } } return M ; }
int findM ( int N ) { int M = 0 ; int MSB = ( int ) log2 ( N ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ! ( N & ( 1 << i ) ) ) M += ( 1 << i ) ; } return M ; }
int func ( int N , int P ) { int sumUptoN = ( N * ( N + 1 ) / 2 ) ; int sumOfMultiplesOfP ; if ( N < P ) { return sumUptoN ; } else if ( ( N / P ) == 1 ) { return sumUptoN - P + 1 ; } sumOfMultiplesOfP = ( ( N / P ) * ( 2 * P + ( N / P - 1 ) * P ) ) / 2 ; return ( sumUptoN + func ( N / P , P ) - sumOfMultiplesOfP ) ; }
long long countStrings ( long long A , long long B , long long K ) { long long X = ( A + B ) / ( K + 1 ) ; return ( min ( A , min ( B , X ) ) * ( K + 1 ) ) ; }
int countPairs ( vector < int > a , int n , int k ) { vector < int > len ( n ) ; vector < int > p ( 11 ) ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= 10 ; i ++ ) { p [ i ] = ( p [ i - 1 ] * 10 ) % k ; } for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; while ( x > 0 ) { len [ i ] ++ ; x /= 10 ; } rem [ len [ i ] ] [ a [ i ] % k ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= 10 ; j ++ ) { int r = ( a [ i ] * p [ j ] ) % k ; int xr = ( k - r ) % k ; ans += rem [ j ] [ xr ] ; if ( len [ i ] == j && ( r + a [ i ] % k ) % k == 0 ) ans -- ; } } return ans ; }
bool isDivisible ( int N ) { return ( N - 1 ) % 3 != 0 ; }
void maxLengthSubArray ( int A [ ] , int N ) { int forward [ N ] , backward [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 A [ i ] != A [ i - 1 ] ) { forward [ i ] = 1 ; } else forward [ i ] = forward [ i - 1 ] + 1 ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 A [ i ] != A [ i + 1 ] ) { backward [ i ] = 1 ; } else backward [ i ] = backward [ i + 1 ] + 1 ; } int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) ans = max ( ans , min ( forward [ i ] , backward [ i + 1 ] ) * 2 ) ; } cout << ans ; }
int countDigitSum ( int N , int K ) { int l = ( int ) pow ( 10 , N - 1 ) , r = ( int ) pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; int digits [ N ] ; for ( int j = N - 1 ; j >= 0 ; j -- ) { digits [ j ] = num % 10 ; num /= 10 ; } int sum = 0 , flag = 0 ; for ( int j = 0 ; j < K ; j ++ ) sum += digits [ j ] ; for ( int j = 1 ; j < N - K + 1 ; j ++ ) { int curr_sum = 0 ; for ( int m = j ; m < j + K ; m ++ ) curr_sum += digits [ m ] ; if ( sum != curr_sum ) { flag = 1 ; break ; } } if ( flag == 0 ) { count ++ ; } } return count ; }
int countDigitSum ( int N , int K ) { int l = ( int ) pow ( 10 , N - 1 ) , r = ( int ) pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; int digits [ N ] ; for ( int j = N - 1 ; j >= 0 ; j -- ) { digits [ j ] = num % 10 ; num /= 10 ; } int sum = 0 , flag = 0 ; for ( int j = 0 ; j < K ; j ++ ) sum += digits [ j ] ; for ( int j = K ; j < N ; j ++ ) { if ( sum - digits [ j - K ] + digits [ j ] != sum ) { flag = 1 ; break ; } } if ( flag == 0 ) count ++ ; } return count ; }
int nth_angle ( int N , int a , int b , int n ) { int nth = 0 ; nth = a + ( n - 1 ) * b ; return nth ; }
bool findTriplet ( vector < int > & arr ) { int n = arr . size ( ) ; stack < int > st ; int h3 = INT_MIN , h1 = INT_MAX ; for ( int i = n - 1 ; i >= 0 ; i -- ) { h1 = arr [ i ] ; while ( ! st . empty ( ) && st . top ( ) < arr [ i ] ) { h3 = st . top ( ) ; st . pop ( ) ; } st . push ( arr [ i ] ) ; if ( h1 < h3 ) { return true ; } } return false ; }
void findWays ( vector < int > & arr , int i , int n ) { if ( n == 0 ) printVector ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . push_back ( j ) ; findWays ( arr , j , n - j ) ; arr . pop_back ( ) ; } }
int distinctNumbers ( int arr [ ] , int m , int n ) { unordered_map < int , int > count ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; vector < int > fre_arr ( n + 1 , 0 ) ; for ( auto it : count ) { fre_arr [ it . second ] ++ ; } int ans = count . size ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { int temp = fre_arr [ i ] ; if ( temp == 0 ) continue ; int t = min ( temp , m / i ) ; ans -= t ; m -= i * t ; } return ans ; }
void no_of_moves ( int Matrix [ M ] [ N ] , int x , int y ) { int moves = 0 ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( Matrix [ i ] [ j ] != 0 ) { moves += abs ( x - i ) ; moves += abs ( y - j ) ; } } } cout << moves << "\n" ; }
int is_linear ( string s ) { int tmp = 0 ; char first = s [ 0 ] ; for ( int pos = 0 ; pos < s . length ( ) ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } tmp ++ ; } return true ; }
void DFS ( int U , int * vis , vector < int > adj [ ] ) { vis [ U ] = 1 ; for ( int V : adj [ U ] ) { if ( vis [ V ] == 0 ) DFS ( V , vis , adj ) ; } }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int find_gcd ( vector < int > arr ) { if ( arr . size ( ) == 1 ) return arr [ 0 ] ; int g = arr [ 0 ] ; for ( int i = 1 ; i < arr . size ( ) ; i ++ ) { g = gcd ( g , arr [ i ] ) ; } return g ; }
void maxm_gcd ( Node * root , vector < int > ans ) { if ( ! root ) return ; if ( root -> left == NULL and root -> right == NULL ) { ans . push_back ( root -> val ) ; maxm = max ( find_gcd ( ans ) , maxm ) ; return ; } ans . push_back ( root -> val ) ; maxm_gcd ( root -> left , ans ) ; maxm_gcd ( root -> right , ans ) ; }
void checkInfinite ( string s ) { bool flag = 1 ; int N = s . length ( ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( s [ i ] == char ( int ( s [ i + 1 ] ) + 1 ) ) { continue ; } else if ( s [ i ] == 'a' && s [ i + 1 ] == 'z' ) { continue ; } else { flag = 0 ; break ; } } if ( flag == 0 ) cout << "NO" ; else cout << "YES" ; }
int calculateWays ( int arr1 [ ] , int arr2 [ ] , int N ) { int A = arr2 [ 0 ] , B = arr2 [ 1 ] ; int C = arr2 [ 2 ] , D = arr2 [ 3 ] ; int ans = 0 ; for ( int b = 0 ; b <= B && b * 5 <= ( N ) ; b ++ ) for ( int c = 0 ; c <= C && b * 5 + c * 10 <= ( N ) ; c ++ ) for ( int d = 0 ; d <= D && b * 5 + c * 10 + d * 20 <= ( N ) ; d ++ ) if ( ( b * 5 ) + ( c * 10 ) + ( d * 20 ) >= ( N - A ) ) ans ++ ; return ans ; }
int calculateWays ( int arr1 [ ] , int arr2 [ ] , int N ) { int A = arr2 [ 0 ] , B = arr2 [ 1 ] ; int C = arr2 [ 2 ] , D = arr2 [ 3 ] ; int ans = 0 ; for ( int b = 0 ; b <= B && b * 5 <= N ; b ++ ) { for ( int a = 0 ; a <= A && a * 1 + b * 5 <= N ; a ++ ) { ways [ a + b * 5 ] ++ ; } } for ( int c = 0 ; c <= C && c * 10 <= ( N ) ; c ++ ) { for ( int d = 0 ; d <= D && c * 10 + d * 20 <= ( N ) ; d ++ ) { ans += ways [ N - c * 10 - d * 20 ] ; } } return ans ; }
void removeAll ( int arr [ ] , int n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) cout << "YES" ; else cout << "NO" ; }
void minNum ( int n ) { if ( n < 3 ) cout << -1 ; else cout << ( 210 * ( ( int ) ( pow ( 10 , n - 1 ) / 210 ) + 1 ) ) ; }
void findMinimum ( string s ) { int n = s . size ( ) ; int x [ n + 1 ] = { 0 } ; reverse ( s . begin ( ) , s . end ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) { if ( x [ i ] == 1 ) { x [ i + 1 ] = 1 ; x [ i ] = 0 ; } else if ( i and x [ i - 1 ] == 1 ) { x [ i + 1 ] = 1 ; x [ i - 1 ] = -1 ; } else x [ i ] = 1 ; } } int c = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( x [ i ] != 0 ) c ++ ; } cout << c << endl ; }
void splitIntoFibonacci ( string S ) { vector < int > seq ; splitIntoFibonacciHelper ( 0 , S , seq ) ; if ( seq . size ( ) >= 3 ) { for ( int i : seq ) cout << i << " " ; } else { cout << -1 ; } }
int countChanges ( int matrix [ ] [ N ] , int n , int m ) { int dist = n + m - 1 ; int freq [ dist ] [ 10 ] ; for ( int i = 0 ; i < dist ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) freq [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { freq [ i + j ] [ matrix [ i ] [ j ] ] ++ ; } } int min_changes_sum = 0 ; for ( int i = 0 ; i < dist / 2 ; i ++ ) { int maximum = 0 ; int total_values = 0 ; for ( int j = 0 ; j < 10 ; j ++ ) { maximum = max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; } min_changes_sum += ( total_values - maximum ) ; } return min_changes_sum ; }
int numberOfPairs ( int n ) { if ( n % 2 == 0 ) return n / 2 - 1 ; else return n / 2 ; }
int good_pair ( string str [ ] , int N ) { int countStr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { string res = str [ i ] + str [ j ] ; int vowel [ 5 ] = { 0 } ; for ( int k = 0 ; k < res . length ( ) ; k ++ ) { if ( res [ k ] == 'a' ) vowel [ 0 ] = 1 ; else if ( res [ k ] == 'e' ) vowel [ 1 ] = 1 ; else if ( res [ k ] == 'i' ) vowel [ 2 ] = 1 ; else if ( res [ k ] == 'o' ) vowel [ 3 ] = 1 ; else if ( res [ k ] == 'u' ) vowel [ 4 ] = 1 ; } int temp = 0 ; for ( int ind = 0 ; ind < 5 ; ind ++ ) { if ( vowel [ ind ] == 1 ) temp ++ ; } if ( temp == 5 ) countStr ++ ; } } return countStr ; }
void sieveOfEratosthenes ( int N , int s [ ] ) { vector < bool > prime ( N + 1 , false ) ; for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= N ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } }
int generatePrimeFactors ( int N ) { int s [ N + 1 ] ; int sum = 0 ; sieveOfEratosthenes ( N , s ) ; int curr = s [ N ] ; int cnt = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( curr == s [ N ] ) { cnt ++ ; continue ; } sum = sum + cnt ; curr = s [ N ] ; cnt = 1 ; } return sum ; }
int LCM ( int a , int b ) { int lcm = a > b ? a : b ; while ( true ) { if ( lcm % a == 0 && lcm % b == 0 ) break ; else lcm ++ ; } return lcm ; }
int countSubstrings ( string s ) { int n = s . length ( ) ; int answer = ( n * ( n - 1 ) ) / 2 ; int cnt = 1 ; vector < int > v ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) cnt ++ ; else { v . push_back ( cnt ) ; cnt = 1 ; } } if ( cnt > 0 ) v . push_back ( cnt ) ; for ( int i = 0 ; i < v . size ( ) - 1 ; i ++ ) { answer -= ( v [ i ] + v [ i + 1 ] - 1 ) ; } return answer ; }
int find_max ( int n , int k ) { bitset < 32 > X ( 0 ) ; int cnt = 0 ; for ( int i = 31 ; i >= 0 && cnt != k ; i -- ) { if ( n & ( 1 << i ) ) { X [ i ] = 1 ; cnt ++ ; } } return X . to_ulong ( ) ; }
int get_palindrome_time ( string str ) { int hh , mm ; hh = ( str [ 0 ] - 48 ) * 10 + ( str [ 1 ] - 48 ) ; mm = ( str [ 3 ] - 48 ) * 10 + ( str [ 4 ] - 48 ) ; int requiredTime = 0 ; while ( hh % 10 != mm / 10 hh / 10 != mm % 10 ) { ++ mm ; if ( mm == 60 ) { mm = 0 ; ++ hh ; } if ( hh == 24 ) hh = 0 ; ++ requiredTime ; } return requiredTime ; }
int maximumSubarraySum ( int a [ ] , int n , vector < pair < int , int > > & subarrays ) { int i , maxsum = 0 ; int prefixArray [ n ] = { 0 } ; for ( i = 0 ; i < subarrays . size ( ) ; ++ i ) { prefixArray [ subarrays [ i ] . first - 1 ] ++ ; prefixArray [ subarrays [ i ] . second ] -- ; } for ( i = 1 ; i < n ; i ++ ) { prefixArray [ i ] += prefixArray [ i - 1 ] ; } sort ( prefixArray , prefixArray + n , greater < int > ( ) ) ; sort ( a , a + n , greater < int > ( ) ) ; for ( i = 0 ; i < n ; i ++ ) maxsum += a [ i ] * prefixArray [ i ] ; return maxsum ; }
int maxProfit ( vector < int > value , int N , int K ) { sort ( value . begin ( ) , value . end ( ) ) ; int maxval = value [ N - 1 ] ; int maxProfit = 0 ; int curr_val ; do { curr_val = 0 ; for ( int i = 0 ; i < N ; i ++ ) { curr_val += value [ i ] ; if ( curr_val <= K ) { maxProfit = max ( curr_val + maxval * ( i + 1 ) , maxProfit ) ; } } } while ( next_permutation ( value . begin ( ) , value . end ( ) ) ) ; return maxProfit ; }
long long findways ( string s , int x ) { if ( x > ( int ) s . length ( ) ) return 0 ; long long int n = ( int ) s . length ( ) ; int freq [ 26 ] ; memset ( freq , 0 , sizeof freq ) ; for ( int i = 0 ; i < n ; ++ i ) freq [ s [ i ] - 'a' ] ++ ; multiset < int > se ; for ( int i = 0 ; i < 26 ; ++ i ) if ( freq [ i ] > 0 ) se . insert ( freq [ i ] ) ; long long ans = 1 ; for ( int i = 0 ; i < x / 2 ; ++ i ) { long long int count = 0 ; for ( auto u : se ) { if ( u >= 2 ) count ++ ; } if ( count == 0 ) return 0 ; else ans = ans * count ; auto p = se . end ( ) ; p -- ; int val = * p ; se . erase ( p ) ; if ( val > 2 ) se . insert ( val - 2 ) ; } if ( x % 2 != 0 ) { long long int count = 0 ; for ( auto u : se ) if ( u > 0 ) count ++ ; ans = ans * count ; } return ans ; }
bool checkUniqueFrequency ( int arr [ ] , int n ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } unordered_set < int > uniqueFreq ; for ( auto & i : freq ) { if ( uniqueFreq . count ( i . second ) ) return false ; else uniqueFreq . insert ( i . second ) ; } return true ; }
double specialSum ( int n ) { double sum = n * ( n + 1 ) / 2 ; int a = Log2 ( n ) ; sum = sum + power ( 2 , a + 1 ) - 1 ; return sum ; }
string findMin ( int x , int Y ) { string y = to_string ( Y ) ; int n = y . size ( ) ; vector < int > p ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = y [ i ] - '0' ; if ( i > 0 ) p [ i ] += p [ i - 1 ] ; } for ( int i = n - 1 , k = 0 ; ; i -- , k ++ ) { int d = 0 ; if ( i >= 0 ) d = y [ i ] - '0' ; for ( int j = d + 1 ; j <= 9 ; j ++ ) { int r = ( i > 0 ) * p [ i - 1 ] + j ; if ( x - r >= 0 and x - r <= 9 * k ) { string suf = helper ( k , x - r ) ; string pre = "" ; if ( i > 0 ) pre = y . substr ( 0 , i ) ; char cur = ( char ) j + '0' ; pre += cur ; return pre + suf ; } } } }
void largestNumber ( int n , int X , int Y ) { int maxm = max ( X , Y ) ; Y = X + Y - maxm ; X = maxm ; int Xs = 0 ; int Ys = 0 ; while ( n > 0 ) { if ( n % Y == 0 ) { Xs += n ; n = 0 ; } else { n -= X ; Ys += X ; } } if ( n == 0 ) { while ( Xs -- > 0 ) cout << X ; while ( Ys -- > 0 ) cout << Y ; } else cout << "-1" ; }
int check ( int unit_digit , int X ) { int times , digit ; for ( int times = 1 ; times <= 10 ; times ++ ) { digit = ( X * times ) % 10 ; if ( digit == unit_digit ) return times ; } return -1 ; }
int getNum ( int N , int X ) { int unit_digit ; unit_digit = N % 10 ; int times = check ( unit_digit , X ) ; if ( times == -1 ) return times ; else { if ( N >= ( times * X ) ) return times ; else return -1 ; } }
int dfs ( vector < vector < int > > & g , int * cost , int u , int pre ) { vis [ u ] = true ; dp [ u ] = cost [ u ] ; bool check = 1 ; int cur = cost [ u ] ; for ( auto & x : g [ u ] ) { if ( vis [ x ] && x != pre ) { check = 0 ; } else if ( ! vis [ x ] ) { check &= dfs ( g , cost , x , u ) ; cur = max ( cur , cost [ u ] + dp [ x ] ) ; } } dp [ u ] = cur ; if ( ! check ) { canTake += cost [ u ] ; } else { best = max ( best , dp [ u ] ) ; } return check ; }
int FindMaxCost ( vector < vector < int > > & g , int * cost , int source ) { dfs ( g , cost , source , -1 ) ; cout << canTake + best ; }
int after_rev ( vector < int > v ) { int mini = 0 , count = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { count += v [ i ] ; if ( count > 0 ) count = 0 ; if ( mini > count ) mini = count ; } return mini ; }
int moduloEquality ( int A [ ] , int B [ ] , int n , int m ) { map < int , int > mapA , mapB ; for ( int i = 0 ; i < n ; i ++ ) { mapA [ A [ i ] ] ++ ; mapB [ B [ i ] ] ++ ; } set < int > possibleValues ; int FirstElement = B [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { int cur = A [ i ] ; possibleValues . insert ( cur > FirstElement ? m - cur + FirstElement : FirstElement - cur ) ; } int ans = INT_MAX ; for ( auto it : possibleValues ) { bool possible = true ; for ( auto it2 : mapA ) { if ( it2 . second != mapB [ ( it2 . first + it ) % m ] ) { possible = false ; break ; } } if ( possible ) { ans = min ( ans , it ) ; } } return ans ; }
int countCyclicShifts ( string & S , int n ) { int aux [ n ] = { 0 } ; for ( int i = 0 ; i < n ; ++ i ) { if ( S [ i ] == '(' ) aux [ i ] = 1 ; else aux [ i ] = -1 ; } int mn = aux [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { aux [ i ] += aux [ i - 1 ] ; mn = min ( mn , aux [ i ] ) ; } if ( aux [ n - 1 ] != 0 ) return 0 ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( aux [ i ] == mn ) count ++ ; } return count ; }
int count ( int k , string s ) { int ar [ s . length ( ) ] ; int end = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '1' ) { for ( int j = i ; j < s . length ( ) && j <= i + k ; j ++ ) { ar [ j ] = -1 ; end = j ; } i = end ; } } end = 0 ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) { for ( int j = i ; j >= 0 && j >= i - k ; j -- ) { ar [ j ] = -1 ; end = j ; } i = end ; } } int ans = 0 ; end = 0 ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( ar [ j ] == 0 ) { ans ++ ; for ( int g = j ; g <= j + k && g < s . length ( ) ; g ++ ) { ar [ g ] = -1 ; end = g ; } j = end - 1 ; } } return ans ; }
int find_set ( int a ) { if ( parent [ a ] == a ) return a ; return parent [ a ] = find_set ( parent [ a ] ) ; }
void union_set ( int a , int b ) { int x = find_set ( a ) , y = find_set ( b ) ; if ( x == y ) return ; if ( rnk [ x ] == rnk [ y ] ) rnk [ x ] ++ ; if ( rnk [ y ] > rnk [ x ] ) swap ( x , y ) ; parent [ y ] = x ; }
void dfsBridges ( int a , int par ) { vis [ a ] = 1 ; in [ a ] = low [ a ] = timer ++ ; for ( int i v [ a ] ) { if ( i == par ) continue ; if ( vis [ i ] ) low [ a ] = min ( low [ a ] , in [ i ] ) ; else { dfsBridges ( i , a )  ; low [ a ] = min ( low [ a ] , low [ i ] ) ; if ( in [ a ] < low [ i ] ) bridges . push_back ( make_pair ( i , a ) ) ; else union_set ( i , a ) ; } } } int dfsDiameter ( int a , int par , int & diameter ) { int x = 0 , y = 0 ; for ( int i g [ a ] ) { if ( i == par ) continue ; int mx = dfsDiameter ( i , a , diameter ) ; if ( mx > x ) { y = x ; x = mx ; } else if ( mx > y ) y = mx ; } diameter = max ( diameter , x + y ) ; return x + 1 ; } int findMaxBridges ( ) { for ( int i = 0 ; i <= n ; i ++ ) { parent [ i ] = i ; rnk [ i ] = 1 ; } dfsBridges ( 1 , 0 ) ; if ( bridges . empty ( ) ) return 0 ; int head = -1 ; for ( auto & i bridges ) { int a = find_set ( i . first ) ; int b = find_set ( i . second ) ; g [ a ] . push_back ( b ) ; g [ b ] . push_back ( a ) ; head = a ; } int diameter = 0 ; dfsDiameter ( head , 0 , diameter ) ; return diameter ; } int main ( ) { n = 6 , m = 6 ; v [ 1 ] . push_back ( 2 ) ; v [ 2 ] . push_back ( 1 ) ; v [ 2 ] . push_back ( 3 ) ; v [ 3 ] . push_back ( 2 ) ; v [ 2 ] . push_back ( 5 ) ; v [ 5 ] . push_back ( 2 ) ; v [ 5 ] . push_back ( 6 ) ; v [ 6 ] . push_back ( 5 ) ; v [ 6 ] . push_back ( 3 ) ; v [ 3 ] . push_back ( 6 ) ; v [ 3 ] . push_back ( 4 ) ; v [ 4 ] . push_back ( 4 ) ; int ans = findMaxBridges ( ) ; cout << ans << endl ; return 0 ; }
bool isPalindrome ( int l , int r , string & s ) { while ( l <= r ) { if ( s [ l ] != s [ r ] ) return false ; l ++ ; r -- ; } return true ; }
int numWays ( string & s ) { int n = s . length ( ) ; int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( isPalindrome ( 0 , i , s ) && isPalindrome ( i + 1 , n - 1 , s ) ) { ans ++ ; } } return ans ; }
int maxProfit ( int * prices , int n ) { int profit = 0 , currentDay = n - 1 ; while ( currentDay > 0 ) { int day = currentDay - 1 ; while ( day >= 0 && ( prices [ currentDay ] > prices [ day ] ) ) { profit += ( prices [ currentDay ] - prices [ day ] ) ; day -- ; } currentDay = day ; } return profit ; }
void numberofsubstrings ( string str , int k , char charArray [ ] ) { int N = str . length ( ) ; bool available [ 26 ] = { 0 } ; for ( int i = 0 ; i < k ; i ++ ) { available [ charArray [ i ] - 'a' ] = 1 ; } int lastPos = -1 ; int ans = ( N * ( N + 1 ) ) / 2 ; for ( int i = 0 ; i < N ; i ++ ) { if ( available [ str [ i ] - 'a' ] == 0 ) { ans -= ( ( i - lastPos ) * ( N - i ) ) ; lastPos = i ; } } cout << ans << endl ; }
bool isOddStringPalindrome ( string str , int n ) { int oddStringSize = n / 2 ; bool lengthOdd = ( ( oddStringSize % 2 == 1 ) ? true : false ) ; stack < char > s ; int i = 1 ; int c = 0 ; while ( i < n && c < oddStringSize / 2 ) { s . push ( str [ i ] ) ; i += 2 ; c ++ ; } if ( lengthOdd ) i = i + 2 ; while ( i < n && s . size ( ) > 0 ) { if ( s . top ( ) == str [ i ] ) s . pop ( ) ; else break ; i = i + 2 ; } if ( s . size ( ) == 0 ) return true ; return false ; }
bool isOddStringPalindrome ( string str , int n ) { int left , right ; if ( n % 2 == 0 ) { left = 1 ; right = n - 1 ; } else { left = 1 ; right = n - 2 ; } while ( left < n && right >= 0 && left < right ) { if ( str [ left ] != str [ right ] ) return false ; left += 2 ; right -= 2 ; } return true ; }
void min_remove ( string str ) { int N = str . length ( ) ; int prefix_a [ N + 1 ] ; int prefix_b [ N + 1 ] ; int prefix_c [ N + 1 ] ; prefix_a [ 0 ] = 0 ; prefix_b [ 0 ] = 0 ; prefix_c [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix_a [ i ] = prefix_a [ i - 1 ] + ( str [ i - 1 ] == 'a' ) ; prefix_b [ i ] = prefix_b [ i - 1 ] + ( str [ i - 1 ] == 'b' ) ; prefix_c [ i ] = prefix_c [ i - 1 ] + ( str [ i - 1 ] == 'c' ) ; } int maxi = INT_MIN ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = i ; j <= N ; j ++ ) { maxi = max ( maxi , ( prefix_a [ i ] + ( prefix_b [ j ] - prefix_b [ i ] ) + ( prefix_c [ N ] - prefix_c [ j ] ) ) ) ; } } cout << ( N - maxi ) << endl ; }
int maximum_partition ( string str ) { int i = 0 , j = 0 , k = 0 ; int c = 0 , r = 0 ; unordered_map m ; for ( i = str . length ( ) - 1 ; i >= 0 ; i -- ) { if ( m [ str [ i ] ] == 0 ) { m [ str [ i ] ] = i ; } } i = 0 ; k = m [ str [ i ] ] ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( i <= k ) { c = c + 1 ; k = max ( k , m [ str [ i ] ] ) ; } else { r = r + 1 ; c = 1 ; k = max ( k , m [ str [ i ] ] ) ; } } if ( c != 0 ) { r = r + 1 ; } return r ; }
int findAns ( vector < vector < int > > mat , int x , int y , int n , int m ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { ans += abs ( x - i ) + abs ( y - j ) ; } } } return ans ; }
void solve ( vector < int > & P , int n ) { vector < int > arr ; arr . push_back ( 0 ) ; for ( auto x : P ) arr . push_back ( x ) ; int cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == i ) { swap ( arr [ i ] , arr [ i + 1 ] ) ; cnt ++ ; } } if ( arr [ n ] == n ) { swap ( arr [ n - 1 ] , arr [ n ] ) ; cnt ++ ; } cout << cnt << endl ; }
int longestSequence ( int n , int arr [ ] ) { int l = 0 , r = n - 1 ; int prev = INT_MIN ; int ans = 0 ; while ( l <= r ) { if ( arr [ l ] > prev && arr [ r ] > prev ) { if ( arr [ l ] < arr [ r ] ) { ans += 1 ; prev = arr [ l ] ; l += 1 ; } else { ans += 1 ; prev = arr [ r ] ; r -= 1 ; } } else if ( arr [ l ] > prev ) { ans += 1 ; prev = arr [ l ] ; l += 1 ; } else if ( arr [ r ] > prev ) { ans += 1 ; prev = arr [ r ] ; r -= 1 ; } else { break ; } } return ans ; }
int solve ( int n , int m , int x , int y , int d ) { int top = min ( d , x - 1 ) ; int down = min ( d , n - x ) ; int left = min ( d , y - 1 ) ; int right = min ( d , m - y ) ; int quad1 = top * left ; int quad2 = left * down ; int quad3 = down * right ; int quad4 = right * top ; int totalsq = quad1 + quad2 + quad3 + quad4 ; int singleBlocks = top + down + left + right + 1 ; return totalsq + singleBlocks ; }
int minchanges ( int mat [ N ] [ M ] ) { int count = 0 ; int left = 0 , right = N + M - 2 ; while ( left < right ) { unordered_map < int , int > mp ; int totalsize = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( i + j == left ) { mp [ mat [ i ] [ j ] ] ++ ; totalsize ++ ; } else if ( i + j == right ) { mp [ mat [ i ] [ j ] ] ++ ; totalsize ++ ; } } } unordered_map < int , int > :: iterator itr = mp . begin ( ) ; int changes = 0 ; for ( ; itr != mp . end ( ) ; itr ++ ) changes = max ( changes , itr -> second ) ; count += totalsize - changes ; left ++ ; right -- ; } return count ; }
int CountLongestSubarrays ( int arr [ ] , int n , int k ) { int i , s = 0 ; for ( i = 0 ; i < n ; ++ i ) { s += arr [ i ] ; } if ( s % k ) { return 1 ; } else { int ini = 0 ; while ( ini < n && arr [ ini ] % k == 0 ) { ++ ini ; } int final = n - 1 ; while ( final >= 0 && arr [ final ] % k == 0 ) { -- final ; } int len , sum = 0 , count = 0 ; if ( ini == n ) { return -1 ; } else { len = max ( n - 1 - ini , final ) ; } for ( i = 0 ; i < len ; i ++ ) { sum += arr [ i ] ; } if ( sum % k != 0 ) { count ++ ; } for ( i = len ; i < n ; i ++ ) { sum = sum + arr [ i ] ; sum = sum - arr [ i - len ] ; if ( sum % k != 0 ) { count ++ ; } } return count ; } }
int nC3 ( int n ) { if ( n < 3 ) return 0 ; return ( n * ( n - 1 ) * ( n - 2 ) ) / 6 ; }
void count_triplet ( vector < int > arr , int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } for ( int i = 1 ; i <= 1000000 ; i ++ ) { for ( int j = i ; j <= 1000000 ; j += i ) { mul [ i ] += freq [ j ] ; } cnt [ i ] = nC3 ( mul [ i ] ) ; } for ( int i = 1000000 ; i >= 1 ; i -- ) { for ( int j = 2 * i ; j <= 1000000 ; j += i ) { cnt [ i ] -= cnt [ j ] ; } } cout << "Number of triplets " << "with GCD " << K ; cout << " are " << cnt [ K ] ; }
int getMinJumps ( string s ) { vector < int > ones ; int jumps = 0 , median = 0 , ind = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '1' ) ones . push_back ( i ) ; } if ( ones . size ( ) == 0 ) return jumps ; median = ones [ ones . size ( ) / 2 ] ; ind = median ; for ( int i = ind ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) { jumps += ind - i ; ind -- ; } } ind = median ; for ( int i = ind ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '1' ) { jumps += i - ind ; ind ++ ; } } return jumps ; }
void getSubsequence ( vector < int > ar ) { int N = ar . size ( ) ; vector < int > ans ; ans . push_back ( ar [ 0 ] ) ; for ( int i = 1 ; i < N - 1 ; i ++ ) { if ( ar [ i ] > ar [ i - 1 ] ) { if ( i < N - 1 && ar [ i ] <= ar [ i + 1 ] ) { continue ; } else { ans . push_back ( ar [ i ] ) ; } } else { if ( i < N - 1 && ar [ i + 1 ] < ar [ i ] ) { continue ; } else { ans . push_back ( ar [ i ] ) ; } } } ans . push_back ( ar [ N - 1 ] ) ; for ( auto & it : ans ) cout << it << ' ' ; }
bool isSubseqPossible ( int arr [ ] , int N , int K ) { int i ; int odd = 0 , even = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 || ( even == 0 && K % 2 == 0 ) ) return false ; return true ; }
void print_path ( int N , int jump , int coin ) { if ( jump > coin || jump * ( N - 1 ) < coin ) { cout << "-1" << endl ; } else { int pos = 1 ; while ( jump > 0 ) { int tmp = min ( N - 1 , coin - ( jump - 1 ) ) ; if ( pos + tmp <= N ) { pos += tmp ; } else { pos -= tmp ; } cout << pos << " " ; coin -= tmp ; jump -= 1 ; } } }
void countEvenOdd ( int arr [ ] , int n , int K ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ; y = __builtin_popcount ( K ) ; if ( y & 1 ) { cout << "Even = " << odd << ", Odd = " << even ; } else { cout << "Even = " << even << ", Odd = " << odd ; } }
void findMinHike ( vector < int > arr , int n ) { arr . insert ( arr . begin ( ) , INF ) ; arr . push_back ( INF ) ; vector < int > hike ( n + 2 , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] && arr [ i ] <= arr [ i + 1 ] ) { hike [ i ] = 1 ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] && arr [ i ] <= arr [ i + 1 ] ) { hike [ i ] = hike [ i - 1 ] + 1 ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] && arr [ i ] > arr [ i + 1 ] ) { hike [ i ] = hike [ i + 1 ] + 1 ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] && arr [ i ] > arr [ i + 1 ] ) { hike [ i ] = max ( hike [ i - 1 ] , hike [ i + 1 ] ) + 1 ; } } for ( int i = 1 ; i <= n ; i ++ ) { cout << hike [ i ] << " " ; } }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void preprocess ( ) { DFS ( 1 , -1 ) ; }
void maximumSumSubarray ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= 0 && mp . find ( arr [ i ] ) == mp . end ( ) ) mp [ arr [ i ] ] = 1 ; } int first = 0 ; int last = 0 ; int ans = 0 ; int INF = 1e6 ; for ( auto i : mp ) { int mx = i . first ; int curr = 0 ; int curr_start ; for ( int j = 0 ; j < n ; j ++ ) { if ( curr == 0 ) curr_start = j ; int val = arr [ j ] > mx ? - INF : arr [ j ] ; curr += val ; if ( curr < 0 ) curr = 0 ; if ( curr > ans ) { ans = curr ; first = curr_start ; last = j ; } } } cout << first + 1 << " " << last + 1 ; }
int make_xor_half ( vector < int > & arr ) { int sum = 0 , xr = 0 ; for ( int a : arr ) { sum += a ; xr ^= a ; } if ( 2 * xr == sum ) return -1 ; if ( xr == 0 ) { arr . push_back ( sum ) ; return 1 ; } arr . push_back ( xr ) ; arr . push_back ( sum + xr ) ; return 2 ; }
int makeZero ( int x , int y , int a , int b ) { if ( x > y ) x = y , y = x ; int tot_cost = ( y - x ) * a ; int cost1 = 2 * x * a ; int cost2 = x * b ; tot_cost += min ( cost1 , cost2 ) ; cout << tot_cost ; }
void splitFraction ( int n , int d ) { int ar [ n ] ; int first = d + n - 1 ; ar [ 0 ] = first ; for ( int i = 1 ; i < n ; i ++ ) { int temp = -- first ; first ++ ; ar [ i ] = first * temp ; -- first ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ar [ i ] % n == 0 ) { cout << "1/" << ar [ i ] / n << ", " ; } else { cout << n << "/" << ar [ i ] << ", " ; } } }
int numPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) ans ++ ; } } return ans ; }
int minOperations ( string s , int len ) { int operationCnt = 0 ; stack < char > st ; int cntClosing = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( s [ i ] == '{' ) { if ( cntClosing > 0 ) { operationCnt ++ ; st . pop ( ) ; } st . push ( s [ i ] ) ; cntClosing = 0 ; } else if ( st . empty ( ) ) { st . push ( '{' ) ; operationCnt ++ ; cntClosing = 1 ; } else { cntClosing = ( cntClosing + 1 ) % 2 ; if ( cntClosing == 0 ) { st . pop ( ) ; } } } operationCnt += st . size ( ) * 2 - cntClosing ; return operationCnt ; }
int longestSubsequence ( string s ) { int n = s . length ( ) ; int answer = 0 ; char prev = '-' ; for ( int i = 0 ; i < n ; i ++ ) { if ( prev != s [ i ] ) { prev = s [ i ] ; answer ++ ; } } return answer ; }
int calculate ( int pos , int prev , string & s ) { if ( pos == s . length ( ) ) { return 0 ; } if ( dp [ pos ] [ prev ] != -1 ) return dp [ pos ] [ prev ] ; int val = 0 ; if ( s [ pos ] - 'a' + 1 != prev ) { val = max ( val , 1 + calculate ( pos + 1 , s [ pos ] - 'a' + 1 , s ) ) ; } val = max ( val , calculate ( pos + 1 , prev , s ) ) ; return dp [ pos ] [ prev ] = val ; }
int longestSubsequence ( string s ) { int n = s . length ( ) ; memset ( dp , -1 , sizeof ( dp ) ) ; return calculate ( 0 , 0 , s ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void MinDiff ( int n ) { int val = pow ( 2 , n ) ; int sep = n / 2 ; int grp1 = 0 ; int grp2 = 0 ; grp1 = grp1 + val ; for ( int i = 1 ; i < sep ; i ++ ) grp1 = grp1 + pow ( 2 , i ) ; for ( int i = sep ; i < n ; i ++ ) grp2 = grp2 + pow ( 2 , i ) ; cout << ( abs ( grp1 - grp2 ) ) ; }
int minOccupiedPosition ( int A [ ] , int n ) { int minPos = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] > 0 ) { ++ minPos ; i += 2 ; } } return minPos ; }
int missingnumber ( int n , int arr [ ] ) { int mn = INT_MAX , mx = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 && arr [ i ] == -1 && arr [ i - 1 ] != -1 ) { mn = min ( mn , arr [ i - 1 ] ) ; mx = max ( mx , arr [ i - 1 ] ) ; } if ( i < ( n - 1 ) && arr [ i ] == -1 && arr [ i + 1 ] != -1 ) { mn = min ( mn , arr [ i + 1 ] ) ; mx = max ( mx , arr [ i + 1 ] ) ; } } long long int res = ( mx + mn ) / 2 ; return res ; }
int Minsteps ( int n ) { int ans = 0 ; while ( n > 1 ) { if ( n % 5 == 0 ) { ans ++ ; n = n / 5 ; continue ; } else if ( n % 4 == 0 ) { ans ++ ; n = n / 4 ; continue ; } else if ( n % 3 == 0 ) { ans ++ ; n = n / 3 ; continue ; } else if ( n % 2 == 0 ) { ans ++ ; n = n / 2 ; continue ; } return -1 ; } return ans ; }
void countDist ( int arr1 [ ] , int n , int arr2 [ ] , int m , int k ) { int count = 0 ; int smallest = arr2 [ 0 ] ; int largest = arr2 [ 0 ] ; for ( int i = 0 ; i < m ; i ++ ) { smallest = max ( smallest , arr2 [ i ] ) ; largest = min ( largest , arr1 [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( abs ( arr1 [ i ] - smallest ) > k || abs ( arr1 [ i ] - largest ) > k ) count ++ ; } cout << count ; }
int palindromeWinner ( string & S ) { int freq [ 26 ] ; memset ( freq , 0 , sizeof freq ) ; int count = 0 ; for ( int i = 0 ; i < ( int ) S . length ( ) ; ++ i ) { if ( freq [ S [ i ] - 'a' ] == 0 ) count ++ ; freq [ S [ i ] - 'a' ] ++ ; } int unique = 0 ; int duplicate = 0 ; for ( int i = 0 ; i < 26 ; ++ i ) { if ( freq [ i ] == 1 ) unique ++ ; else if ( freq [ i ] >= 2 ) duplicate ++ ; } if ( unique == 1 && ( unique + duplicate ) == count ) return 1 ; return 2 ; }
int findMinimumK ( int a [ ] , int n , int S ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return ceil ( ( ( S + 1 ) * 1.0 ) / ( sum * 1.0 ) ) ; }
int MinimumValue ( int a [ ] , int n ) { int answer = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { answer = min ( answer , ( ( a [ i ] & a [ j ] ) ^ ( a [ i ] a [ j ] ) ) ) ; } } return answer ; }
int MinimumValue ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int minXor = INT_MAX ; int val = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { val = arr [ i ] ^ arr [ i + 1 ] ; minXor = min ( minXor , val ) ; } return minXor ; }
int count_element ( int N , int K , int * arr ) { map < int , int > mp ; for ( int i = 0 ; i < N ; ++ i ) mp [ arr [ i ] ] ++ ; int answer = 0 ; for ( auto i : mp ) { if ( mp . find ( i . first + K ) != mp . end ( ) ) answer += i . second ; } return answer ; }
int largestNum ( int n ) { int num = 0 ; int max_setBits = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { int setBits = __builtin_popcount ( i ) ; if ( setBits >= max_setBits ) { num = i ; max_setBits = setBits ; } } return num ; }
int find_count ( int n ) { map < int , int > mpp ; for ( int i = 1 ; i <= n ; i ++ ) { mpp [ digit_xor ( i ) ] += 1 ; } int maxm = 0 ; for ( auto x : mpp ) { if ( x . second > maxm ) maxm = x . second ; } return maxm ; }
void findString ( int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { cout << char ( 'A' + i % K ) ; } }
int digit_prod ( int x ) { int prod = 1 ; while ( x ) { prod *= x % 10 ; x = x / 10 ; } return prod ; }
int find_count ( int n ) { map < int , int > mpp ; for ( int i = 1 ; i <= n ; i ++ ) { mpp [ digit_prod ( i ) ] += 1 ; } int ans = 1 ; int maxm = 0 ; for ( auto x : mpp ) { if ( x . second > maxm ) { maxm = x . second ; ans = 1 ; } else if ( x . second == maxm ) { ans ++ ; } } return ans ; }
bool isPrime ( int n ) { int i ; if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) { return false ; } for ( i = 5 ; i * i <= n ; i += 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
int findSubarraySum ( int arr [ ] , int n , int K ) { unordered_map < int , int > prevSum ; int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == K ) { res ++ ; } if ( prevSum . find ( currsum - K ) != prevSum . end ( ) ) res += ( prevSum [ currsum - K ] ) ; prevSum [ currsum ] ++ ; } return res ; }
void countSubarray ( int arr [ ] , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime ( arr [ i ] ) ) { arr [ i ] = 1 ; } else { arr [ i ] = 0 ; } } cout << findSubarraySum ( arr , n , K ) ; }
int find_maxm ( int arr [ ] , int n ) { map < int , int > mpp ; for ( int i = 0 ; i < n ; i ++ ) { mpp [ arr [ i ] ] += 1 ; } int ans = 0 ; for ( auto x : mpp ) { int value = x . first ; int freq = x . second ; if ( value == freq ) { ans ++ ; } } return ans ; }
int pow ( int x , int y ) { if ( y == 1 ) return x ; if ( y == 0 ) return 1 ; int temp = pow ( x , y / 2 ) ; temp *= temp ; if ( y & 1 ) temp *= x ; return temp ; }
int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = max ( max_sum , i + j ) ; } } return max_sum ; }
int getLargestSum ( int N ) { for ( int i = 1 ; i * i <= N ; i ++ ) { for ( int j = i + 1 ; j * j <= N ; j ++ ) { int k = N / j ; int a = k * i ; int b = k * j ; if ( a <= N && b <= N && a * b % ( a + b ) == 0 ) max_sum = max ( max_sum , a + b ) ; } } return max_sum ; }
int findSum ( int L , int R ) { vector < int > arr ; int i = 0 ; int x = 2 ; while ( i <= R ) { arr . push_back ( i + x ) ; if ( i + 1 <= R ) arr . push_back ( i + 1 + x ) ; x *= -1 ; i += 2 ; } int sum = 0 ; for ( int i = L ; i <= R ; ++ i ) sum += arr [ i ] ; return sum ; }
int GetMinSubarrayLength ( int a [ ] , int n ) { int ans = max ( a [ 0 ] , a [ n - 1 ] ) ; int lo = 0 , hi = n - 1 ; while ( lo < n and a [ lo ] % ans == 0 ) lo ++ ; while ( hi > lo and a [ hi ] % ans == 0 ) hi -- ; return ( hi - lo + 1 ) ; }
int count ( string s ) { int N , i , cnt = 0 , ans = 0 ; N = s . length ( ) ; for ( i = 0 ; i < N ; i ++ ) { if ( s [ i ] == 'R' ) cnt ++ ; if ( s [ i ] == 'L' ) ans += cnt ; } return ans ; }
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } return max_so_far ; }
int minimumValue ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int answer = 0 ; for ( int i = 0 ; i < k ; i ++ ) answer += arr [ i ] * arr [ i ] ; return answer * ( 2 * k - 2 ) ; }
int sumOfDigits ( int n ) { string s = to_string ( n ) ; int sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum += ( s [ i ] - '0' ) ; } return sum ; }
int height ( int s , vector < int > adj [ ] , int * visited ) { visited [ s ] = 1 ; int h = 0 ; for ( auto & child : adj [ s ] ) { if ( visited [ child ] == 0 ) { h = max ( h , 1 + height ( child , adj , visited ) ) ; } } return h ; }
int minimumGroups ( vector < int > adj [ ] , int N ) { int visited [ N + 1 ] = { 0 } ; int groups = INT_MIN ; for ( int i = 1 ; i <= N ; i ++ ) { if ( visited [ i ] == 0 ) { int comHeight ; comHeight = height ( i , adj , visited ) ; groups = max ( groups , comHeight ) ; } } return groups ; }
bool isPrime ( int n ) { int flag = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { flag = 0 ; break ; } } return ( flag == 1 ? true : false ) ; }
bool isPerfectSquare ( int x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; }
int countInterestingPrimes ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( isPrime ( i ) ) { for ( int j = 1 ; j * j * j * j <= i ; j ++ ) { if ( isPerfectSquare ( i - j * j * j * j ) ) { answer ++ ; break ; } } } } return answer ; }
int sumDivisibles ( int A , int B , int M ) { int sum = 0 ; for ( int i = A ; i <= B ; i ++ ) if ( i % M == 0 ) sum += i ; return sum ; }
int findSmallNum ( int N , int K ) { int rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
int findLargeNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }
int sumDivisibles ( int A , int B , int M ) { int sum = 0 ; int first = findSmallNum ( A , M ) ; int last = findLargeNum ( B , M ) ; if ( first < A ) first += M ; if ( last > B ) first -= M ; int n = ( B / M ) - ( A - 1 ) / M ; return n * ( first + last ) / 2 ; }
int check ( int A [ ] , int B [ ] , int N ) { priority_queue < int > pq1 , pq2 ; for ( int i = 0 ; i < N ; i ++ ) { pq1 . push ( A [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { pq2 . push ( B [ i ] ) ; } int c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( pq1 . top ( ) > pq2 . top ( ) ) { c ++ ; pq1 . pop ( ) ; pq2 . pop ( ) ; } else { if ( pq2 . size ( ) == 0 ) { break ; } pq2 . pop ( ) ; } } return ( c ) ; }
int calcSum ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i <= n - k ; i ++ ) { int sum = 0 ; for ( int j = i ; j < k + i ; j ++ ) sum += arr [ j ] ; cout << sum << " " ; } }
int calcSum ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += arr [ i ] ; cout << sum << " " ; for ( int i = k ; i < n ; i ++ ) { sum = ( sum - arr [ i - k ] ) + arr [ i ] ; cout << sum << " " ; } }
int getPairs ( vector < int > A , vector < int > B , int n ) { vector < int > D ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { D [ i ] = A [ i ] - B [ i ] ; } sort ( D . begin ( ) , D . end ( ) ) ; long long total = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( D [ i ] > 0 ) { total += n - i - 1 ; } else { int k = upper_bound ( D . begin ( ) , D . end ( ) , - D [ i ] ) - D . begin ( ) ; total += n - k ; } } return total ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; }
int countPairs ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( lcm ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) ) ans ++ ; return ans ; }
int countPairs ( int a [ ] , int n ) { unordered_map < int , int > frequency ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ a [ i ] ] ++ ; } int count = 0 ; for ( auto x : frequency ) { int f = x . second ; count += f * ( f - 1 ) / 2 ; } return count ; }
void preCompute ( int N ) { fact [ 0 ] = 1 ; for ( int i = 1 ; fact [ i - 1 ] <= N ; i ++ ) { fact [ i ] = ( fact [ i - 1 ] * i ) ; size ++ ; } }
int findLCS ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] ++ ; } return mp . size ( ) ; }
void segments ( int n ) { if ( n == 1 n == 0 ) { return ; } if ( n % 2 == 0 ) { cout << "1" ; segments ( n - 2 ) ; } else if ( n % 2 == 1 ) { cout << "7" ; segments ( n - 3 ) ; } }
int countOperations ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] & 1 ) { arr [ i ] ++ ; arr [ i + 1 ] ++ ; count += 2 ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) return -1 ; } return count ; }
int findMinimumSubsequences ( string A , string B ) { int numberOfSubsequences = 1 ; int sizeOfB = B . size ( ) ; int sizeOfA = A . size ( ) ; int inf = 1000000 ; int next [ 26 ] [ sizeOfB ] ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < sizeOfB ; j ++ ) { next [ i ] [ j ] = inf ; } } for ( int i = 0 ; i < sizeOfB ; i ++ ) { next [ B [ i ] - 'a' ] [ i ] = i ; } for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = sizeOfB - 2 ; j >= 0 ; j -- ) { if ( next [ i ] [ j ] == inf ) { next [ i ] [ j ] = next [ i ] [ j + 1 ] ; } } } int pos = 0 ; int i = 0 ; while ( i < sizeOfA ) { if ( pos == 0 && next [ A [ i ] - 'a' ] [ pos ] == inf ) { numberOfSubsequences = -1 ; break ; } else if ( pos < sizeOfB && next [ A [ i ] - 'a' ] [ pos ] < inf ) { int nextIndex = next [ A [ i ] - 'a' ] [ pos ] + 1 ; pos = nextIndex ; i ++ ; } else { numberOfSubsequences ++ ; pos = 0 ; } } return numberOfSubsequences ; }
void convolution ( int * x , int * h , int n , int m ) { int row_vec [ MAX_SIZE ] , col_vec [ MAX_SIZE ] ; int out [ MAX_SIZE ] = { 0 } ; int circular_shift_mat [ MAX_SIZE ] [ MAX_SIZE ] ; int maxSize = n > m ? n : m ; for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i >= n ) { row_vec [ i ] = 0 ; } else { row_vec [ i ] = x [ i ] ; } } for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i >= m ) { col_vec [ i ] = 0 ; } else { col_vec [ i ] = h [ i ] ; } } int k = 0 , d = 0 ; for ( int i = 0 ; i < maxSize ; i ++ ) { int curIndex = k - d ; for ( int j = 0 ; j < maxSize ; j ++ ) { circular_shift_mat [ j ] [ i ] = row_vec [ curIndex % maxSize ] ; curIndex ++ ; } k = maxSize ; d ++ ; } for ( int i = 0 ; i < maxSize ; i ++ ) { for ( int j = 0 ; j < maxSize ; j ++ ) { out [ i ] += circular_shift_mat [ i ] [ j ] * col_vec [ j ] ; } cout << out [ i ] << " " ; } }
int maxLength ( string str , int len ) { int res = 0 ; int lastPos [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { lastPos [ i ] = -1 ; } for ( int i = 0 ; i < len ; i ++ ) { int C = str [ i ] - 'a' ; if ( lastPos [ C ] != -1 ) { res = max ( len - ( i - lastPos [ C ] - 1 ) - 1 , res ) ; } lastPos [ C ] = i ; } return res ; }
int maxProfit ( int profitA [ ] , int profitB [ ] , int n ) { int preSum [ n ] ; preSum [ 0 ] = profitA [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { preSum [ i ] = preSum [ i - 1 ] + profitA [ i ] ; } int suffSum [ n ] ; suffSum [ n - 1 ] = profitB [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + profitB [ i ] ; } int res = preSum [ n - 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { res = max ( res , preSum [ i ] + suffSum [ i + 1 ] ) ; } res = max ( res , suffSum [ 0 ] ) ; return res ; }
int countPartitions ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int min_elem = * min_element ( A , A + N ) ; if ( min_elem == INT_MAX ) break ; count ++ ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % min_elem == 0 ) A [ i ] = INT_MAX ; } } return count ; }
int max_palindrome ( string s [ ] , int n ) { int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] . size ( ) % 2 != 0 ) { flag = 1 ; } } if ( flag == 1 ) { return n ; } int z = 0 , o = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < s [ i ] . size ( ) ; j ++ ) { if ( s [ i ] [ j ] == '0' ) z ++ ; else o ++ ; } } if ( o % 2 == 0 && z % 2 == 0 ) { return n ; } else { return n - 1 ; } }
int minChanges ( int arr [ ] , int n ) { unordered_map < int , int > umap ; for ( int i = 0 ; i < n ; i ++ ) { umap [ arr [ i ] ] ++ ; } int maxFreq = 0 ; for ( auto p : umap ) { maxFreq = max ( maxFreq , p . second ) ; } return n - maxFreq ; }
int minOperations ( int n , int m ) { int a = 0 , k = 1 ; int p = max ( n , m ) ; while ( n != m ) { float s = ( float ) ( p - n + p - m ) ; float q = ( -1 + sqrt ( 8 * s + 1 ) ) / 2 ; if ( q - floor ( q ) == 0 ) { a = q ; n = m ; } p = p + 1 ; } return a ; }
void decBinary ( int arr [ ] , int n ) { int k = log2 ( n ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } }
int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; }
int maxNum ( int n , int k ) { int l = log2 ( n ) + 1 ; int a [ l ] = { 0 } ; decBinary ( a , n ) ; int cn = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == 0 && cn < k ) { a [ i ] = 1 ; cn ++ ; } } return binaryDec ( a , l ) ; }
int minFlipsSub ( string mat [ ] , int i , int j ) { int cnt0 = 0 , cnt1 = 0 ; if ( mat [ i ] [ j ] == '1' ) cnt1 ++ ; else cnt0 ++ ; if ( mat [ i ] [ j + 1 ] == '1' ) cnt1 ++ ; else cnt0 ++ ; if ( mat [ i + 1 ] [ j ] == '1' ) cnt1 ++ ; else cnt0 ++ ; if ( mat [ i + 1 ] [ j + 1 ] == '1' ) cnt1 ++ ; else cnt0 ++ ; return min ( cnt0 , cnt1 ) ; }
int minFlips ( string mat [ ] , int r , int c ) { int res = INT_MAX ; for ( int i = 0 ; i < r - 1 ; i ++ ) { for ( int j = 0 ; j < c - 1 ; j ++ ) { res = min ( res , minFlipsSub ( mat , i , j ) ) ; } } return res ; }
void findSubSeq ( int arr [ ] , int n , int sum ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( sum < arr [ i ] ) arr [ i ] = -1 ; else sum -= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != -1 ) cout << arr [ i ] << " " ; } }
int k_sum ( int a [ ] , int n , int k ) { int r = 0 , sum = 0 ; int ans = 0 ; for ( int l = 0 ; l < n ; l ++ ) { while ( sum < k ) { if ( r == n ) break ; else { sum += a [ r ] ; r ++ ; } } if ( sum < k ) break ; ans += n - r + 1 ; sum -= a [ l ] ; } return ans ; }
void balBracketSequence ( string str ) { int n = str . size ( ) ; if ( str [ 0 ] == str [ n - 1 ] ) { cout << "No" << endl ; } else { int cntForOpen = 0 , cntForClose = 0 ; int check = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) cntForOpen ++ ; else if ( str [ i ] == str [ n - 1 ] ) cntForOpen -- ; else cntForOpen ++ ; if ( cntForOpen < 0 ) { check = 0 ; break ; } } if ( check && cntForOpen == 0 ) { cout << "Yes, " ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ n - 1 ] ) cout << ')' ; else cout << '(' ; } return ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) cntForClose ++ ; else cntForClose -- ; if ( cntForClose < 0 ) { check = 0 ; break ; } } if ( check && cntForClose == 0 ) { cout << "Yes, " ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == str [ 0 ] ) cout << '(' ; else cout << ')' ; } return ; } } cout << "No" ; } }
int countSetBits ( int n , int k ) { int kth = findK ( n , k ) ; return __builtin_popcount ( kth ) ; }
char maxAlpha ( string str , int len ) { int first [ MAX ] , last [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { first [ i ] = -1 ; last [ i ] = -1 ; } for ( int i = 0 ; i < len ; i ++ ) { int index = ( str [ i ] - 'a' ) ; if ( first [ index ] == -1 ) first [ index ] = i ; last [ index ] = i ; } int ans = -1 , maxVal = -1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] == -1 ) continue ; if ( ( last [ i ] - first [ i ] ) > maxVal ) { maxVal = last [ i ] - first [ i ] ; ans = i ; } } return ( char ) ( ans + 'a' ) ; }
int maxSum ( int arr1 [ ] , int arr2 [ ] , int n ) { int initialParity = 0 , finalParity = 0 ; int sum = 0 , minPositive = INT_MAX , maxNegative = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { initialParity += arr2 [ i ] ; if ( arr1 [ i ] >= 0 ) { finalParity += 1 ; sum += arr1 [ i ] ; minPositive = min ( minPositive , arr1 [ i ] ) ; } else { maxNegative = max ( maxNegative , arr1 [ i ] ) ; } } if ( initialParity % 2 == finalParity % 2 ) { return sum ; } else { if ( minPositive + maxNegative >= 0 ) { return sum + maxNegative ; } else { return sum - minPositive ; } } }
bool IsLarger ( int X [ ] , int Y [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( X [ i ] < Y [ i ] ) { return false ; } } return true ; }
int solve ( int X [ ] , int Y [ ] , int n ) { int ans = 0 ; if ( IsLarger ( X , Y , n ) ) { ans = 0 ; } else { int d = Y [ 0 ] - X [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { X [ i ] += d ; } if ( IsLarger ( X , Y , n ) ) { ans = d ; } else { ans = d + 1 ; } } return ans ; }
int valueofX ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ar [ i ] ; } if ( sum % n == 0 ) { return sum / n ; } else { int A = sum / n , B = sum / n + 1 ; int ValueA = 0 , ValueB = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) ; ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) ; } if ( ValueA < ValueB ) { return A ; } else { return B ; } } }
int minLength ( int n ) { int ans = n / 26 ; if ( n % 26 != 0 ) ans ++ ; return ans ; }
int minHalls ( int lectures [ ] [ 2 ] , int n ) { int prefix_sum [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { prefix_sum [ lectures [ i ] [ 0 ] ] ++ ; prefix_sum [ lectures [ i ] [ 1 ] + 1 ] -- ; } int ans = prefix_sum [ 0 ] ; for ( int i = 1 ; i < MAX ; i ++ ) { prefix_sum [ i ] += prefix_sum [ i - 1 ] ; ans = max ( ans , prefix_sum [ i ] ) ; } return ans ; }
int minCapacity ( int enter [ ] , int exit [ ] , int n ) { int minCap = 0 ; int currCap = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currCap = currCap + enter [ i ] - exit [ i ] ; minCap = max ( minCap , currCap ) ; } return minCap ; }
void generate ( ) { queue < string > q ; q . push ( "1" ) ; q . push ( "2" ) ; q . push ( "3" ) ; q . push ( "4" ) ; q . push ( "5" ) ; bool flag = true ; ans . push_back ( "0" ) ; while ( ! q . empty ( ) ) { string x = q . front ( ) ; q . pop ( ) ; if ( isValidNum ( x ) ) { ans . push_back ( x ) ; } if ( x . length ( ) == 6 ) continue ; for ( int i = 0 ; i <= 5 ; i ++ ) { string z = to_string ( i ) ; string temp = x + z ; q . push ( temp ) ; } } }
bool comp ( string a , string b ) { if ( a . size ( ) == b . size ( ) ) return a < b ; else return a . size ( ) < b . size ( ) ; }
int findcount ( string l , string r ) { generate ( ) ; int count = 0 ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { string a = ans [ i ] ; if ( comp ( l , a ) && comp ( a , r ) ) { count ++ ; } else if ( a == l a == r ) { count ++ ; } } return count ; }
vector < int > Findpermutation ( int n ) { vector < int > a ( n + 1 ) ; a [ 1 ] = n ; for ( int i = 2 ; i <= n ; i ++ ) a [ i ] = i - 1 ; return a ; }
int Balanced_Substring ( string str , int n ) { int ans = 0 ; vector < int > arr ( n / 2 + 1 , 0 ) ; int d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '(' ) d ++ ; else { if ( d == 1 ) { for ( int j = 2 ; j <= n / 2 + 1 && arr [ j ] != 0 ; j ++ ) arr [ j ] = 0 ; } ++ ans ; ans += arr [ d ] ; arr [ d ] ++ ; d -- ; } } return ans ; }
int power ( long long x , int y , int mod ) { long long res = 1 ; while ( y ) { if ( y & 1 ) res = ( res * x ) % mod ; x = ( x * x ) % mod ; y = ( y >> 1 ) ; } return ( int ) ( res % mod ) ; }
int NoOfChords ( int A ) { int mod = 1e9 + 7 ; long long ans = ncr ( 2 * A , A , mod ) ; int inv = power ( A + 1 , mod - 2 , mod ) ; ans = ( ans * inv ) % mod ; return ( int ) ( ans % mod ) ; }
int StrictlyPositiveXor ( int A [ ] , int N ) { int allxor = 0 ; bool checkallzero = true ; for ( int i = 0 ; i < N ; i += 1 ) { allxor ^= A [ i ] ; if ( A [ i ] > 0 ) checkallzero = false ; } if ( allxor != 0 ) return N ; if ( checkallzero ) return -1 ; int l = N , r = -1 ; for ( int i = 0 ; i < N ; i += 1 ) { if ( A [ i ] > 0 ) { l = i + 1 ; break ; } } for ( int i = N - 1 ; i >= 0 ; i -= 1 ) { if ( A [ i ] > 0 ) { r = i + 1 ; break ; } } return max ( N - l , r - 1 ) ; }
int FindMinOperation ( int a [ ] , int n , int k ) { priority_queue < int , vector < int > , greater < int > > Q ; for ( int i = 0 ; i < n ; i ++ ) Q . push ( a [ i ] ) ; int ans = 0 ; while ( 1 ) { if ( Q . top ( ) >= k ) break ; if ( Q . size ( ) < 2 ) return -1 ; int x = Q . top ( ) ; Q . pop ( ) ; int y = Q . top ( ) ; Q . pop ( ) ; int z = ( x * y ) / __gcd ( x , y ) ; Q . push ( z ) ; ans ++ ; } return ans ; }
void findWeights ( int X ) { int sum = 0 ; int power = 0 ; while ( sum < X ) { sum = pow ( 3 , power + 1 ) - 1 ; sum /= 2 ; power ++ ; } int ans = 1 ; for ( int i = 1 ; i <= power ; i ++ ) { cout << ans << " " ; ans = ans * 3 ; } }
int solve ( int Array [ ] , int N , int K ) { int count_Arr [ N + 1 ] = { 0 } ; int factor = 1 ; int size = N ; while ( size ) { int start = 1 ; int end = size ; count_Arr [ 1 ] += factor * N ; count_Arr [ end + 1 ] -= factor * N ; factor ++ ; size /= 2 ; } for ( int i = 2 ; i <= N ; i ++ ) count_Arr [ i ] += count_Arr [ i - 1 ] ; vector < pair < int , int > > element ; for ( int i = 0 ; i < N ; i ++ ) { element . push_back ( { Array [ i ] , count_Arr [ i + 1 ] } ) ; } sort ( element . begin ( ) , element . end ( ) ) ; int start = 1 ; for ( int i = 0 ; i < N ; i ++ ) { int end = start + element [ i ] . second - 1 ; if ( K >= start && K <= end ) { return element [ i ] . first ; } start += element [ i ] . second ; } return -1 ; }
void find_distinct ( int a [ ] , int n , int q , int queries [ ] ) { int check [ MAX ] = { 0 } ; int idx [ MAX ] ; int cnt = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( check [ a [ i ] ] == 0 ) { idx [ i ] = cnt ; check [ a [ i ] ] = 1 ; cnt ++ ; } else { idx [ i ] = cnt - 1 ; } } for ( int i = 0 ; i < q ; i ++ ) { int m = queries [ i ] ; cout << idx [ m ] << " " ; } }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int lcm ( int n , int m ) { return ( n * m ) / gcd ( n , m ) ; }
bool matrix_exist ( int row [ ] , int column [ ] , int r , int c ) { int row_sum = 0 ; int column_sum = 0 ; int row_max = -1 ; int column_max = -1 ; int row_non_zero = 0 ; int column_non_zero = 0 ; for ( int i = 0 ; i < r ; i ++ ) { row_sum += row [ i ] ; row_max = max ( row_max , row [ i ] ) ; if ( row [ i ] ) row_non_zero ++ ; } for ( int i = 0 ; i < c ; i ++ ) { column_sum += column [ i ] ; column_max = max ( column_max , column [ i ] ) ; if ( column [ i ] ) column_non_zero ++ ; } if ( ( row_sum != column_sum ) || ( row_max > column_non_zero ) || ( column_max > row_non_zero ) ) return false ; return true ; }
int longestSubarray ( int arr [ ] , int n ) { int maxMean = 0 ; for ( int i = 1 ; i < n ; i ++ ) maxMean = max ( maxMean , ( arr [ i ] + arr [ i - 1 ] ) / 2 ) ; int ans = 0 ; int subarrayLength = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= maxMean ) ans = max ( ans , ++ subarrayLength ) ; else subarrayLength = 0 ; return ans ; }
int maxDistance ( int arr [ ] , int n ) { if ( arr [ 0 ] != arr [ n - 1 ] ) return ( n - 1 ) ; int i = n - 1 ; while ( i > 0 ) { if ( arr [ i ] != arr [ 0 ] ) break ; i -- ; } int distFirst = ( i == 0 ) ? -1 : i ; i = 0 ; while ( i < n - 1 ) { if ( arr [ i ] != arr [ n - 1 ] ) break ; i ++ ; } int distLast = ( i == n - 1 ) ? -1 : ( n - 1 - i ) ; int maxDist = max ( distFirst , distLast ) ; return maxDist ; }
int SubarraySum ( int a [ ] , int n , int x ) { int ans = -10000 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int curans = 0 ; priority_queue < int , vector < int > > pq ; priority_queue < int , vector < int > , greater < int > > pq2 ; for ( int k = 0 ; k < n ; k ++ ) { if ( k >= i && k <= j ) { curans += a [ k ] ; pq2 . push ( a [ k ] ) ; } else pq . push ( a [ k ] ) ; } ans = max ( ans , curans ) ; for ( int k = 1 ; k <= x ; k ++ ) { if ( pq . empty ( ) || pq2 . empty ( ) || pq2 . top ( ) >= pq . top ( ) ) break ; curans -= pq2 . top ( ) ; pq2 . pop ( ) ; curans += pq . top ( ) ; pq . pop ( ) ; ans = max ( ans , curans ) ; } } } return ans ; }
void solve ( int n , int k ) { int mini = 0 ; int x1 = 1 ; int a [ k ] ; for ( int i = 1 ; i <= k ; i ++ ) { mini += x1 ; a [ i - 1 ] = x1 ; x1 += 1 ; } if ( n < mini ) { cout << "-1" ; return ; } int rem = n - mini ; int cnt = rem / k ; rem = rem % k ; for ( int i = 0 ; i < k ; i ++ ) a [ i ] += cnt ; for ( int i = k - 1 ; i > 0 && rem > 0 ; i -- ) { int xx = a [ i - 1 ] * 2 ; int left = xx - a [ i ] ; if ( rem >= left ) { a [ i ] = xx ; rem -= left ; } else { a [ i ] += rem ; rem = 0 ; } } int sum = a [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) { if ( a [ i ] > 2 * a [ i - 1 ] ) { cout << "-1" ; return ; } sum += a [ i ] ; } if ( sum != n ) { cout << "-1" ; return ; } for ( int i = 0 ; i < k ; i ++ ) cout << a [ i ] << " " ; }
void printMaxNumber ( int n ) { if ( n & 1 ) { cout << "7" ; for ( int i = 0 ; i < ( n - 3 ) / 2 ; i ++ ) cout << "1" ; } else { for ( int i = 0 ; i < n / 2 ; i ++ ) cout << "1" ; } }
int minOperations ( int * arr , int n ) { int maxi , result = 0 ; vector < int > freq ( 1000001 , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x ] ++ ; } maxi = * ( max_element ( arr , arr + n ) ) ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) { for ( int j = i * 2 ; j <= maxi ; j = j + i ) { freq [ j ] = 0 ; } result ++ ; } } return result ; }
int maxCoins ( int X , int Y ) { if ( X < Y ) swap ( X , Y ) ; int coins = X ; X -- ; coins += max ( X , Y ) ; return coins ; }
int findElementsCrossed ( int arr [ ] , int a , int b , int n ) { int aa = a ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a == 0 && b == 0 ) break ; else if ( a == 0 ) { if ( arr [ i ] == 1 ) { b -= 1 ; a = min ( aa , a + 1 ) ; } else b -= 1 ; } else if ( b == 0 ) a -- ; else if ( arr [ i ] == 1 && a < aa ) { b -= 1 ; a = min ( aa , a + 1 ) ; } else a -- ; ans ++ ; } return ans ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " " ; }
void pushBinaryToBorder ( int arr [ ] , int n ) { int count1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 1 ) arr [ count1 ++ ] = arr [ i ] ; while ( count1 < n ) arr [ count1 ++ ] = 1 ; int lastNonOne = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] == 1 ) continue ; if ( ! lastNonOne ) { lastNonOne = i ; } if ( arr [ i ] != 0 ) arr [ lastNonOne -- ] = arr [ i ] ; } while ( lastNonOne >= 0 ) arr [ lastNonOne -- ] = 0 ; }
int getMaxValue ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { return 0 ; } first = second = INT_MIN ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == INT_MIN ) return 0 ; else return second ; }
bool isVowel ( char ch ) { switch ( ch ) { case 'a' : case 'e' : case 'i' : case 'o' : case 'u' : return true ; default : return false ; } }
int vowelPairs ( string s , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( isVowel ( s [ i ] ) && isVowel ( s [ i + 1 ] ) ) cnt ++ ; } return cnt ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int solve ( int * health , int n ) { int currentgcd = gcd ( health [ 0 ] , health [ 1 ] ) ; for ( int i = 2 ; i < n ; ++ i ) { currentgcd = gcd ( currentgcd , health [ i ] ) ; } return currentgcd ; }
string smallestString ( int N , int A [ ] ) { char ch = 'a' ; string S = "" ; if ( N < 1 A [ 0 ] != 1  ) { S = "-1" ; return S ; } S += ch ; ch ++ ; for ( int i = 1 ; i < N ; i ++ ) { int diff = A [ i ] - A [ i - 1 ] ; if ( diff > 1 diff < 0 A [ i ] > 26 ) { S = "-1" ; return S ; } else if ( diff == 0 ) S += 'a' ; else { S += ch ; ch ++ ; } } return S ; }
int bankNotes ( int A , int B , int S , int N ) { int numerator = S - ( B * N ) ; int denominator = A - B ; if ( numerator % denominator == 0 ) return ( numerator / denominator ) ; return -1 ; }
int countSteps ( int n ) { int steps = 0 ; while ( n ) { int largest = sqrt ( n ) ; n -= ( largest * largest ) ; steps ++ ; } return steps ; }
int longestSubstring ( string s ) { int cnt = 1 ; int maxi = 1 ; int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] != s [ i - 1 ] ) cnt ++ ; else { maxi = max ( cnt , maxi ) ; cnt = 1 ; } } maxi = max ( cnt , maxi ) ; return maxi ; }
int Minimum_Operations ( int a [ ] , int n ) { int np [ n + 1 ] ; np [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { np [ i ] = np [ i + 1 ] ; if ( a [ i ] <= 0 ) np [ i ] ++ ; } int pos = 0 ; int ans = n ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] >= 0 ) pos ++ ; ans = min ( ans , pos + np [ i + 1 ] ) ; } return ans ; }
int findSumofEle ( int arr1 [ ] , int m , int arr2 [ ] , int n , int k ) { float arraySum = 0 ; for ( int i = 0 ; i < n ; i ++ ) arraySum += arr2 [ i ] ; float mean = arraySum / n ; int sumOfElements = 0 ; float difference ; for ( int i = 0 ; i < m ; i ++ ) { difference = arr1 [ i ] - mean ; if ( ( difference < 0 ) && ( k > ( -1 ) * difference ) ) { sumOfElements += arr1 [ i ] ; } if ( ( difference >= 0 ) && ( k > difference ) ) { sumOfElements += arr1 [ i ] ; } } return sumOfElements ; }
void findIntegers ( int n , int x , int y ) { vector < int > ans ; for ( int i = 0 ; i < n - 1 ; i ++ ) ans . push_back ( 1 ) ; if ( y - ( n - 1 ) <= 0 ) { cout << "-1" ; return ; } ans . push_back ( y - ( n - 1 ) ) ; int store = 0 ; for ( int i = 0 ; i < n ; i ++ ) store += ans [ i ] * ans [ i ] ; if ( store < x ) { cout << "-1" ; return ; } for ( int i = 0 ; i < n ; i ++ ) cout << ans [ i ] << " " ; }
int Minsteps ( int n , int m ) { int ans = 0 ; while ( m > n ) { if ( m & 1 ) { m ++ ; ans ++ ; } m /= 2 ; ans ++ ; } return ans + n - m ; }
int getsum ( int x ) { return ( x * ( x + 1 ) ) / 2 ; }
int maxCandies ( int arr [ ] , int n ) { int prevBought = arr [ n - 1 ] ; int candies = prevBought ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int x = min ( prevBought - 1 , arr [ i ] ) ; if ( x >= 0 ) { candies += x ; prevBought = x ; } } return candies ; }
int sumArr ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
int maxSum ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int i = 0 ; while ( i < n && k > 0 && arr [ i ] < 0 ) { arr [ i ] *= -1 ; k -- ; i ++ ; } if ( k % 2 == 1 ) { int min = 0 ; for ( i = 1 ; i < n ; i ++ ) if ( arr [ min ] > arr [ i ] ) min = i ; arr [ min ] *= -1 ; } return sumArr ( arr , n ) ; }
int Maxsum ( int c1 , int c2 , int c3 , int c4 ) { int sum = 0 ; int two34 = min ( c2 , min ( c3 , c4 ) ) ; sum = two34 * 234 ; c2 -= two34 ; sum += min ( c2 , c1 ) * 12 ; return sum ; }
void replacedArray ( int N , int arr [ ] ) { int pos_sum , neg_sum , i , j , diff ; for ( i = 0 ; i < N ; i ++ ) { pos_sum = 0 ; neg_sum = 0 ; for ( j = i + 1 ; j < N ; j ++ ) { if ( arr [ j ] > 0 ) pos_sum += arr [ j ] ; else neg_sum += arr [ j ] ; } diff = abs ( pos_sum ) - abs ( neg_sum ) ; arr [ i ] = abs ( diff ) ; } }
int maximumResult ( int a , int b , int c ) { int countOfNegative = 0 ; int sum = a + b + c ; int product = a * b * c ; int largest = max ( a , max ( b , c ) ) ; int smallest = min ( a , min ( b , c ) ) ; if ( a < 0 ) countOfNegative ++ ; if ( b < 0 ) countOfNegative ++ ; if ( c < 0 ) countOfNegative ++ ; switch ( countOfNegative ) { case 0 : return ( sum - largest ) * largest ; case 1 : return ( product / smallest ) + smallest ; case 2 : return ( product / largest ) + largest ; case 3 : return ( sum - smallest ) * smallest ; } }
bool isPalindrome ( string s ) { for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( s [ i ] != s [ s . length ( ) - i - 1 ] ) { return false ; } } return true ; }
bool ans ( string s ) { string s2 = s ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { s2 = s2 . back ( ) + s2 ; s2 . pop_back ( ) ; if ( s != s2 && isPalindrome ( s2 ) ) { return true ; } } return false ; }
int solve ( string s ) { if ( s . length ( ) <= 3 ) { return -1 ; } int cnt [ 25 ] = { } ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { cnt [ s [ i ] - 'a' ] ++ ; } if ( * max_element ( cnt , cnt + 25 ) >= ( s . length ( ) - 1 ) ) { return -1 ; } else { return ( ans ( s ) ? 1 : 2 ) ; } }
int solveEven ( string s ) { if ( s . length ( ) % 2 == 1 ) return 2 ; string ls = s . substr ( 0 , s . length ( ) / 2 ) ; string rs = s . substr ( s . length ( ) / 2 , s . length ( ) ) ; if ( ls != rs ) return 1 ; return solveEven ( ls ) ; }
int solveOdd ( string s ) { return 2 ; }
int solve ( string s ) { if ( s . length ( ) <= 3 ) { return -1 ; } int cnt [ 25 ] = { } ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { cnt [ s [ i ] - 'a' ] ++ ; } if ( * max_element ( cnt , cnt + 25 ) >= s . length ( ) - 1 ) { return -1 ; } if ( s . length ( ) % 2 == 0 ) return solveEven ( s ) ; if ( s . length ( ) % 2 == 1 ) return solveOdd ( s ) ; }
int minChanges ( string str , int n ) { int count = 0 , zeros = 0 , ones = 0 ; if ( str [ 0 ] != '1' ) { count ++ ; ones ++ ; } for ( int i = 1 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) zeros ++ ; else ones ++ ; if ( zeros > ones ) { zeros -- ; ones ++ ; count ++ ; } } return count ; }
int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; for ( int i = 1 ; i <= a ; i ++ ) { ans += b / n ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; }
int findCountOfPairs ( int a , int b , int n ) { if ( a > b ) { swap ( a , b ) ; } int temp = 1 , count = 0 ; for ( int i = n ; temp > 0 ; i += n ) { if ( a >= i ) { temp = i - 1 ; } else if ( b >= i ) { temp = a ; } else if ( i > b ) { temp = a - ( i - b ) + 1 ; } if ( temp > 0 ) { count += temp ; } } return count ; }
int minGCD ( int arr [ ] , int n ) { int minGCD = 0 ; for ( int i = 0 ; i < n ; i ++ ) minGCD = __gcd ( minGCD , arr [ i ] ) ; return minGCD ; }
int minLCM ( int arr [ ] , int n ) { int minLCM = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) minLCM = min ( minLCM , arr [ i ] ) ; return minLCM ; }
int countSteps ( int curx , int cury , int n , int m , vector < pair < int , int > > moves ) { int count = 0 ; int k = moves . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { int x = moves [ i ] . first ; int y = moves [ i ] . second ; int stepct = min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) ; count += stepct ; curx += stepct * x ; cury += stepct * y ; } return count ; }
int min_elimination ( int n , int arr [ ] ) { int count = 0 ; int prev_val = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int curr_val = arr [ i ] ; if ( curr_val % 2 == prev_val % 2 ) count ++ ; prev_val = curr_val ; } return count ; }
string getCount ( int N ) { if ( N % 2 == 1 ) return 0 ; string result = "9" ; for ( int i = 1 ; i <= N / 2 - 1 ; i ++ ) result += "0" ; return result ; }
int cmp ( int a , int b ) { return ( a > b ) - ( a < b ) ; }
int maxSubStrings ( string s , int k ) { int maxSubStr = 0 , n = s . size ( ) ; for ( int c = 0 ; c < 26 ; c ++ ) { char ch = 'a' + c ; int curr = 0 ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( s [ i ] != ch ) continue ; int cnt = 0 ; while ( i < n && s [ i ] == ch && cnt != k ) { i ++ ; cnt ++ ; } i -- ; if ( cnt == k ) curr ++ ; } maxSubStr = max ( maxSubStr , curr ) ; } return maxSubStr ; }
bool canFormTeam ( int n , int m ) { if ( n >= 1 && m >= 2 ) return true ; if ( m >= 1 && n >= 2 ) return true ; return false ; }
int maxTeams ( int n , int m ) { int count = 0 ; while ( canFormTeam ( n , m ) ) { if ( n > m ) { n -= 2 ; m -= 1 ; } else { m -= 2 ; n -= 1 ; } count ++ ; } return count ; }
bool canBePicked ( int digits [ ] , int num ) { int copyDigits [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) copyDigits [ i ] = digits [ i ] ; while ( num > 0 ) { int digit = num % 10 ; if ( copyDigits [ digit ] == 0 ) return false ; else copyDigits [ digit ] -= 1 ; num = floor ( num / 10 ) ; } return true ; }
long long int max ( long long a , long long b ) { if ( a > b ) return a ; else return b ; }
long long int smallestSide ( long long int a [ ] ) { sort ( a , a + 4 ) ; long long side1 , side2 , side3 , side4 , side11 , side12 , sideOfSquare ; side1 = a [ 0 ] + a [ 3 ] ; side2 = a [ 1 ] + a [ 2 ] ; side3 = a [ 0 ] + a [ 1 ] ; side4 = a [ 2 ] + a [ 3 ] ; side11 = max ( side1 , side2 ) ; side12 = max ( side3 , side4 ) ; sideOfSquare = max ( side11 , side12 ) ; return sideOfSquare ; }
void find_rectangle ( int area ) { for ( int i = ceil ( sqrt ( area ) ) ; i <= area ; i ++ ) { if ( area / i * i == area ) { printf ( "%d %d" , i , area / i ) ; return ; } } }
int sizeSubSet ( int a [ ] , int k , int n ) { sort ( a , a + n ) ; unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % k != 0 || s . count ( a [ i ] / k ) == 0 ) s . insert ( a [ i ] ) ; } return s . size ( ) ; }
int minimumSets ( string s , int y ) { int cnt = 0 ; int num = 0 ; int l = s . length ( ) ; int f = 0 ; for ( int i = 0 ; i < l ; i ++ ) { num = num * 10 + ( s [ i ] - '0' ) ; if ( num <= y ) f = 1 ; { if ( f ) cnt += 1 ; num = s [ i ] - '0' ; f = 0 ; if ( num <= y ) f = 1 ; else num = 0 ; } } if ( f ) cnt += 1 ; return cnt ; }
void ModifiedArray ( int a [ ] , int n ) { int l = 0 , r = INT_MAX ; int b [ n ] = { 0 } ; for ( int i = 0 ; i < n / 2 ; i ++ ) { b [ i ] = max ( l , a [ i ] - r ) ; b [ n - i - 1 ] = a [ i ] - b [ i ] ; l = b [ i ] ; r = b [ n - i - 1 ] ; } printArr ( b , n ) ; }
int greatestKBits ( int X , int K ) { int set_bit_count = __builtin_popcount ( X ) ; if ( set_bit_count <= K ) return X ; int diff = set_bit_count - K ; for ( int i = 0 ; i < diff ; i ++ ) X &= ( X - 1 ) ; return X ; }
int minItems ( int k , int r ) { for ( int i = 1 ; i < 10 ; i ++ ) if ( ( i * k - r ) % 10 == 0 || ( i * k ) % 10 == 0 ) return i ; return 10 ; }
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int maxSum ( int a [ ] , int n ) { int S = 0 ; int S1 = maxSubArraySum ( a , n ) ; for ( int i = 0 ; i < n ; i ++ ) S += a [ i ] ; return ( 2 * S1 - S ) ; }
void check_distribution ( int n , int k , int age [ ] , int candy [ ] ) { int mxage = * ( std :: max_element ( age , age + n ) ) + 1 ; int mxcandy = * ( std :: max_element ( candy , candy + k ) ) + 1 ; int fr1 [ mxage ] = { 0 } ; int fr2 [ mxcandy ] = { 0 } ; for ( int j = 0 ; j < n ; j ++ ) { fr1 [ age [ j ] ] += 1 ; } for ( int j = 0 ; j < k ; j ++ ) { fr2 [ candy [ j ] ] += 1 ; } k = 0 ; bool Tf = true ; for ( int j = 0 ; j < mxage ; j ++ ) { if ( fr1 [ j ] == 0 ) continue ; bool flag = false ; while ( k < mxcandy ) { if ( fr1 [ j ] <= fr2 [ k ] ) { flag = true ; break ; } k += 1 ; } k = k + 1 ; if ( flag == false ) { Tf = false ; break ; } } if ( Tf ) cout << "YES" << endl ; else cout << "NO" << endl ; }
int check ( int n , int marks [ ] ) { int * x = std :: max_element ( marks , marks + 5 ) ; int bonus = 100 - ( int ) ( * x ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( marks [ i ] + bonus >= 50 ) c += 1 ; } return c ; }
int find_sum ( int n , int k ) { int total_sum = ( n * ( n + 1 ) ) / 2 ; int power = k ; while ( power <= n ) { total_sum -= power ; power *= k ; } return total_sum ; }
void findTwoNumbers ( int sum , int gcd ) { if ( __gcd ( gcd , sum - gcd ) == gcd && sum != gcd ) cout << "a = " << min ( gcd , sum - gcd ) << ", b = " << sum - min ( gcd , sum - gcd ) << endl ; else cout << -1 << endl ; }
void maxLitres ( int budget , int plastic , int glass , int refund ) { if ( glass - refund < plastic ) { int ans = max ( ( budget - refund ) / ( glass - refund ) , 0 ) ; budget -= ans * ( glass - refund ) ; ans += budget / plastic ; cout << ans << endl ; } else cout << ( budget / plastic ) << endl ; }
string smallestPermute ( int n ) { char res [ n + 1 ] ; if ( n % 2 == 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = 48 + i + 2 ; else res [ i ] = 48 + i ; } } else { for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = 48 + i + 2 ; else res [ i ] = 48 + i ; } res [ n - 1 ] = 48 + n - 2 ; res [ n - 2 ] = 48 + n ; res [ n - 3 ] = 48 + n - 1 ; } res [ n ] = '\0' ; return res ; }
int leastValue ( int P , int A , int N , int a [ ] ) { int ans = -1 ; float tmp = ( float ) INFINITY ; for ( int i = 0 ; i < N ; i ++ ) { float t = P - a [ i ] * 0.006 ; if ( abs ( t - A ) < tmp ) { tmp = abs ( t - A ) ; ans = i ; } } return a [ ans ] ; }
int minOperations ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) hashTable [ arr [ i ] ] ++ ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hashTable [ arr [ i ] ] ) { for ( int j = i ; j < n ; j ++ ) if ( arr [ j ] % arr [ i ] == 0 ) hashTable [ arr [ j ] ] = 0 ; res ++ ; } } return res ; }
int minInsertions ( int H [ ] , int n , int K ) { int inser = 0 ; for ( int i = 1 ; i < n ; ++ i ) { float diff = abs ( H [ i ] - H [ i - 1 ] ) ; if ( diff <= K ) continue ; else inser += ceil ( diff / K ) - 1 ; } return inser ; }
int minCost ( int N , int P , int Q ) { int cost = 0 ; while ( N > 0 ) { if ( N & 1 ) { cost += P ; N -- ; } else { int temp = N / 2 ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N /= 2 ; } } return cost ; }
int count_minimum_operations ( long long n ) { int count = 0 ; while ( n > 1 ) { if ( n % 3 == 0 ) n /= 3 ; else if ( n % 3 == 1 ) n -- ; else { if ( n == 2 ) n -- ; else n ++ ; } count ++ ; } return count ; }
int count_minimum_operations ( long long n ) { if ( n == 2 ) { return 1 ; } else if ( n == 1 ) { return 0 ; } if ( n % 3 == 0 ) { return 1 + count_minimum_operations ( n / 3 ) ; } else if ( n % 3 == 1 ) { return 1 + count_minimum_operations ( n - 1 ) ; } else { return 1 + count_minimum_operations ( n + 1 ) ; } }
int findPermutation ( int n ) { int len = ceil ( log10 ( n ) ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( n % 2 != 0 ) { return n ; } else { n = ( n / 10 ) + ( n % 10 ) * pow ( 10 , len - i - 1 ) ; continue ; } } return -1 ; }
int maxMatrixScore ( int A [ n ] [ m ] , int K ) { map < int , int > update ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] [ 0 ] == 0 ) { int ans = 0 ; for ( int j = 1 ; j < m ; ++ j ) ans = ans + A [ i ] [ j ] * pow ( 2 , m - j - 1 ) ; update [ ans ] = i ; } } map < int , int > :: iterator it = update . begin ( ) ; while ( K > 0 && it != update . end ( ) ) { int idx = it -> second ; for ( int j = 0 ; j < m ; ++ j ) A [ idx ] [ j ] = ( A [ idx ] [ j ] + 1 ) % 2 ; it ++ ; K -- ; } int ans = 0 ; for ( int j = 0 ; j < m ; ++ j ) { int zero = 0 , one = 0 ; for ( int i = 0 ; i < n ; ++ i ) { A [ i ] [ j ] == 0 ? zero ++ : one ++ ; } if ( K > 0 && zero > one ) { ans += zero * pow ( 2 , m - j - 1 ) ; K -- ; } else ans += one * pow ( 2 , m - j - 1 ) ; } return ans ; }
bool isSellingPossible ( int n , int a [ ] ) { int i , c25 = 0 , c50 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 25 ) c25 ++ ; else if ( a [ i ] == 50 ) { c50 ++ ; if ( c25 == 0 ) break ; c25 -- ; } else { if ( c50 > 0 && c25 > 0 ) { c50 -- ; c25 -- ; } else if ( c25 >= 3 ) c25 -= 3 ; else break ; } } if ( i == n ) return true ; else return false ; }
long cal_minimum_time ( long X ) { long t = 0 ; long sum = 0 ; while ( sum < X ) { t ++ ; sum = sum + t ; } return t ; }
int countMinSwaps ( string s ) { int N = s . size ( ) ; int one = 0 ; int zero = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '1' ) one ++ ; else zero ++ ; } if ( one > zero + 1 zero > one + 1 ) return -1 ; if ( N % 2 ) { int num = ( N + 1 ) / 2 ; int one_even = 0 , zero_even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { if ( s [ i ] == '1' ) one_even ++ ; else zero_even ++ ; } } if ( one > zero ) return num - one_even ; else return num - zero_even ; } else { int one_odd = 0 , one_even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '1' ) { if ( i % 2 ) one_odd ++ ; else one_even ++ ; } } return min ( N / 2 - one_odd , N / 2 - one_even ) ; } }
int minDiff ( int n , int x , int A [ ] ) { int mn = A [ 0 ] , mx = A [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) { mn = min ( mn , A [ i ] ) ; mx = max ( mx , A [ i ] ) ; } return max ( 0 , mx - mn - 2 * x ) ; }
void LengthLCP ( string x , string y ) { int fr [ 26 ] = { 0 } ; for ( int i = 0 ; i < b ; i ++ ) { fr [ y [ i ] - 97 ] += 1 ; } int c = 0 ; for ( int i = 0 ; i < a ; i ++ ) { if ( fr [ x [ i ] - 97 ] > 0 ) { c += 1 ; fr [ x [ i ] - 97 ] -= 1 ; } else break ; } cout << ( c ) << endl ; }
bool checkIfOverlap ( string str ) { int len = str . length ( ) ; int visited [ len + 1 ] = { 0 } ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '.' ) continue ; for ( int j = max ( 0 , i - str [ i ] ) ; j <= min ( len , i + str [ i ] ) ; j ++ ) visited [ j ] ++ ; } for ( int i = 0 ; i < len ; i ++ ) { if ( visited [ i ] > 1 ) { return true ; } } return false ; }
bool isWaveArray ( int arr [ ] , int n ) { bool result = true ; if ( arr [ 1 ] > arr [ 0 ] && arr [ 1 ] > arr [ 2 ] ) { for ( int i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } } if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] <= arr [ n - 2 ] ) { result = false ; } } } else if ( arr [ 1 ] < arr [ 0 ] && arr [ 1 ] < arr [ 2 ] ) { for ( int i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } } if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] >= arr [ n - 2 ] ) { result = false ; } } } return result ; }
void printCoins ( int arr [ ] , int n ) { int oddSum = 0 ; for ( int i = 0 ; i < n ; i += 2 ) oddSum += arr [ i ] ; int evenSum = 0 ; for ( int i = 1 ; i < n ; i += 2 ) evenSum += arr [ i ] ; int start = ( ( oddSum > evenSum ) ? 0 : 1 ) ; for ( int i = start ; i < n ; i += 2 ) cout << arr [ i ] << " " ; }
void countSubstrings ( string s ) { int ans = 0 ; int subs = 1 ; char pre = '0' ; for ( auto & i : s ) { if ( pre == i ) { subs += 1 ; } else { subs = 1 ; } ans += subs ; pre = i ; } cout << ans << endl ; }
int find ( int i ) { while ( parent [ i ] != i ) i = parent [ i ] ; return i ; }
bool isValidEdge ( int u , int v , vector < bool > inMST ) { if ( u == v ) return false ; if ( inMST [ u ] == false && inMST [ v ] == false ) return false ; else if ( inMST [ u ] == true && inMST [ v ] == true ) return false ; return true ; }
int smallestSumSubarr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = - arr [ i ] ; int sum_here = arr [ 0 ] , max_sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum_here = max ( sum_here + arr [ i ] , arr [ i ] ) ; max_sum = max ( max_sum , sum_here ) ; } return ( -1 ) * max_sum ; }
vector < vector < int > > solve ( vector < vector < int > > arr , int n ) { vector < vector < int > > ans ( n , vector < int > ( n , 0 ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { ans [ i ] [ j ] = arr [ j ] [ ( i + j ) % n ] ; } } return ans ; }
vector < vector < int > > makeArray ( int n ) { vector < vector < int > > arr ( n , vector < int > ( n , 0 ) ) ; int c = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = c ; c ++ ; } } return arr ; }
void printLargest ( int a [ ] , int n ) { int max = -1 ; int ind = -1 ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; while ( num ) { int r = num % 10 ; num = num / 10 ; if ( num == 0 ) { if ( max < r ) { max = r ; ind = i ; } } } } for ( int i = ind ; i < n ; i ++ ) cout << a [ i ] ; for ( int i = 0 ; i < ind ; i ++ ) cout << a [ i ] ; }
int findMinimumAdjacentSwaps ( int arr [ ] , int N ) { bool visited [ N + 1 ] ; int minimumSwaps = 0 ; memset ( visited , false , sizeof ( visited ) ) ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ; int count = 0 ; for ( int j = i + 1 ; j < 2 * N ; j ++ ) { if ( visited [ arr [ j ] ] == false ) count ++ ; else if ( arr [ i ] == arr [ j ] ) minimumSwaps += count ; } } } return minimumSwaps ; }
int DecreasingArray ( int a [ ] , int n ) { int sum = 0 , dif = 0 ; priority_queue < int , vector < int > , greater < int > > pq ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! pq . empty ( ) && pq . top ( ) < a [ i ] ) { dif = a [ i ] - pq . top ( ) ; sum += dif ; pq . pop ( ) ; } pq . push ( a [ i ] ) ; } return sum ; }
bool ifPossible ( int arr [ ] , int n ) { int cp [ n ] ; copy ( arr , arr + n , cp ) ; sort ( cp , cp + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == cp [ i ] ) && ! ( arr [ n - 1 - i ] == cp [ i ] ) ) return false ; } return true ; }
int findMinRooms ( string slots [ ] , int n , int m ) { int counts [ m ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ; return * max_element ( counts , counts + m ) ; }
int MinOperation ( int a [ ] , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; }
int maxProductSubset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int max_neg = INT_MIN ; int count_neg = 0 , count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = max ( max_neg , a [ i ] ) ; } prod = prod * a [ i ] ; } if ( count_zero == n ) return 0 ; if ( count_neg & 1 ) { if ( count_neg == 1 && count_zero > 0 && count_zero + count_neg == n ) return 0 ; prod = prod / max_neg ; } return prod ; }
vector < string > preProcess ( long long int n ) { vector < string > preProcessedCubes ; for ( int i = 1 ; i * i * i <= n ; i ++ ) { long long int iThCube = i * i * i ; string cubeString = to_string ( iThCube ) ; preProcessedCubes . push_back ( cubeString ) ; } return preProcessedCubes ; }
int solve ( int a [ ] , int b [ ] , int n ) { int i ; long long int s = 0 ; for ( i = 0 ; i < n ; i ++ ) s += ( a [ i ] + b [ i ] ) ; if ( n == 1 ) return a [ 0 ] + b [ 0 ] ; if ( s % n != 0 ) return -1 ; int x = s / n ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) return -1 ; if ( i > 0 ) { a [ i ] += b [ i - 1 ] ; b [ i - 1 ] = 0 ; } if ( a [ i ] == x ) continue ; int y = a [ i ] + b [ i ] ; if ( i + 1 < n ) y += b [ i + 1 ] ; if ( y == x ) { a [ i ] = y ; b [ i ] = b [ i + 1 ] = 0 ; continue ; } if ( a [ i ] + b [ i ] == x ) { a [ i ] += b [ i ] ; b [ i ] = 0 ; continue ; } if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) { a [ i ] += b [ i + 1 ] ; b [ i + 1 ] = 0 ; continue ; } return -1 ; } for ( i = 0 ; i < n ; i ++ ) if ( b [ i ] != 0 ) return -1 ; return x ; }
void calcFiboTerms ( vector < int > & fiboTerms , int K ) { int i = 3 , nextTerm ; fiboTerms . push_back ( 0 ) ; fiboTerms . push_back ( 1 ) ; fiboTerms . push_back ( 1 ) ; while ( 1 ) { nextTerm = fiboTerms [ i - 1 ] + fiboTerms [ i - 2 ] ; if ( nextTerm > K ) return ; fiboTerms . push_back ( nextTerm ) ; i ++ ; } }
void survival ( int S , int N , int M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) M > N ) cout << "No\n" ; else { int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; cout << "Yes " << days << endl ; } }
void findTwoGroup ( int n ) { int sum = n * ( n + 1 ) / 2 ; int group1Sum = sum / 2 ; vector < int > group1 , group2 ; for ( int i = n ; i > 0 ; i -- ) { if ( group1Sum - i >= 0 ) { group1 . push_back ( i ) ; group1Sum -= i ; } else { group2 . push_back ( i ) ; } } printVector ( group1 ) ; printVector ( group2 ) ; }
int cost ( int a [ ] , int n ) { return ( n - 1 ) * ( * min_element ( a , a + n ) ) ; }
int winner ( int a [ ] , int n , int k ) { if ( k >= n - 1 ) return n ; int best = 0 , times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i )  } else if ( times >= k ) return best ; } return best ; }
int minproduct ( int a [ ] , int b [ ] , int n , int k ) { int diff = 0 , res = 0 ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; int d = abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }
int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ; while ( input unlock_code ) { input_digit = input % 10 ; code_digit = unlock_code % 10  ; rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) ; input /= 10 ; unlock_code /= 10 ; }
void findWaitingTime ( Process proc [ ] , int n , int wt [ ] ) { int rt [ n ] ; for ( int i = 0 ; i < n ; i ++ ) rt [ i ] = proc [ i ] . bt ; int complete = 0 , t = 0 , minm = INT_MAX ; int shortest = 0 , finish_time ; bool check = false ; while ( complete != n ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( proc [ j ] . art <= t ) && ( rt [ j ] < minm ) && rt [ j ] > 0 ) { minm = rt [ j ] ; shortest = j ; check = true ; } } if ( check == false ) { t ++ ; continue ; } rt [ shortest ] -- ; minm = rt [ shortest ] ; if ( minm == 0 ) minm = INT_MAX ; if ( rt [ shortest ] == 0 ) { complete ++ ; check = false ; finish_time = t + 1 ; wt [ shortest ] = finish_time - proc [ shortest ] . bt - proc [ shortest ] . art ; if ( wt [ shortest ] < 0 ) wt [ shortest ] = 0 ; } t ++ ; } }
void findTurnAroundTime ( Process proc [ ] , int n , int wt [ ] , int tat [ ] ) { for ( int i = 0 ; i < n ; i ++ ) tat [ i ] = proc [ i ] . bt + wt [ i ] ; }
int minCost ( int coin [ ] , int n , int k ) { sort ( coin , coin + n ) ; int coins_needed = ceil ( 1.0 * n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }
void preprocess ( int coin [ ] , int n ) { sort ( coin , coin + n ) ; for ( int i = 1 ; i <= n - 1 ; i ++ ) coin [ i ] += coin [ i - 1 ] ; }
int minCost ( int coin [ ] , int n , int k ) { int coins_needed = ceil ( 1.0 * n / ( k + 1 ) ) ; return coin [ coins_needed - 1 ] ; }
void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } for ( int j = pos ; j > i ; -- j ) swap ( arr [ j ] , arr [ j - 1 ] ) ; k -= pos - i ; } }
int minimumSquare ( int a , int b ) { long long result = 0 , rem = 0 ; if ( a < b ) swap ( a , b ) ; while ( b > 0 ) { result += a / b ; long long rem = a % b ; a = b ; b = rem ; } return result ; }
int minimumCostOfBreaking ( int X [ ] , int Y [ ] , int m , int n ) { int res = 0 ; sort ( X , X + m , greater < int > ( ) ) ; sort ( Y , Y + n , greater < int > ( ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; }
int maximumSum ( int arr [ ] , int n , int k ) { for ( int i = 1 ; i <= k ; i ++ ) { int min = INT_MAX ; int index = -1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
long long int maximizeSum ( long long int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int i = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( k && arr [ i ] < 0 ) { arr [ i ] *= -1 ; k -- ; continue ; } break ; } if ( i == n ) i -- ; if ( k == 0 k % 2 == 0 ) { return sumArray ( arr , n ) ; } if ( i != 0 && abs ( arr [ i ] ) >= abs ( arr [ i - 1 ] ) ) { i -- ; } arr [ i ] *= -1 ; return sumArray ( arr , n ) ; }
void findLargest ( int m , int s ) { if ( s == 0 ) { ( m == 1 ) ? cout << "Largest number is " << 0 : cout << "Not possible" ; return ; } if ( s > 9 * m ) { cout << "Not possible" ; return ; } int res [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { if ( s >= 9 ) { res [ i ] = 9 ; s -= 9 ; } else { res [ i ] = s ; s = 0 ; } } cout << "Largest number is " ; for ( int i = 0 ; i < m ; i ++ ) cout << res [ i ] ; }
int getMax ( int arr [ ] , int n ) { int result = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > result ) result = arr [ i ] ; return result ; }
bool isPossible ( int time , int K , int job [ ] , int n ) { int cnt = 1 ; for ( int i = 0 ; i < n ; ) { if ( curr_time + job [ i ] > time ) { curr_time = 0 ; cnt ++ ; } curr_time += job [ i ] ; i ++ ; } }
int findMinTime ( int K , int T , int job [ ] , int n ) { int end = 0 , start = 0 ; for ( int i = 0 ; i < n ; ++ i ) end += job [ i ] ; int job_max = getMax ( job , n ) ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( mid >= job_max && isPossible ( mid , K , job , n ) ) { end = mid - 1 ; } else start = mid + 1 ; } return ( ans * T ) ; }
void findMin ( int V ) { sort ( deno , deno + n ) ; vector < int > ans ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( V >= deno [ i ] ) { V -= deno [ i ] ; ans . push_back ( deno [ i ] ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) cout << ans [ i ] << " " ; }
int maxDiffSum ( int arr [ ] , int n ) { int dp [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int maxVal = arr [ i ] , minVal = arr [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { minVal = min ( minVal , arr [ j ] ) ; maxVal = max ( maxVal , arr [ j ] ) ; if ( j - 1 >= 0 ) dp [ i ] = max ( dp [ i ] , maxVal - minVal + dp [ j - 1 ] ) ; else dp [ i ] = max ( dp [ i ] , maxVal - minVal ) ; } } return dp [ n - 1 ] ; }
long modPow ( long x , long y ) { long r = 1 , a = x ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) { r = ( r * a ) % MOD ; } a = ( a * a ) % MOD ; y /= 2 ; } return r ; }
long modInverse ( long x ) { return modPow ( x , MOD - 2 ) ; }
long modDivision ( long p , long q ) { return ( p * modInverse ( q ) ) % MOD ; }
long C ( long n , int k ) { if ( k > n ) { return 0 ; } long p = 1 , q = 1 ; for ( int i = 1 ; i <= k ; i ++ ) { q = ( q * i ) % MOD ; p = ( p * ( n - i + 1 ) ) % MOD ; } return modDivision ( p , q ) ; }
int countArrays ( int N , int K ) { long res = 1 ; for ( int p = 2 ; p <= K / p ; p ++ ) { int c = 0 ; while ( K % p == 0 ) { K /= p ; c ++ ; } res = ( res * C ( N - 1 + c , c ) ) % MOD ; } if ( N > 1 ) { res = ( res * N ) % MOD ; } return res ; }
int minSessions ( vector < int > & codeTime , vector < vector < int > > & dp , int ones , int n , int mask , int currTime , int WorkingSessionTime ) { if ( currTime > WorkingSessionTime ) return INT_MAX ; if ( mask == ones ) return 1 ; if ( dp [ mask ] [ currTime ] != -1 ) return dp [ mask ] [ currTime ] ; int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( mask & ( 1 << i ) ) == 0 ) { int inc = minSessions ( codeTime , dp , ones , n , mask | ( 1 << i ) , currTime + codeTime [ i ] , WorkingSessionTime ) ; int inc_next = 1 + minSessions ( codeTime , dp , ones , n , mask | ( 1 << i ) , codeTime [ i ] , WorkingSessionTime ) ; ans = min ( { ans , inc , inc_next } ) ; } } return dp [ mask ] [ currTime ] = ans ; }
int solve ( vector < int > codeTime , int n , int WorkingSessionTime ) { vector < vector < int > > dp ( ( 1 << 14 ) , vector < int > ( 15 , -1 ) ) ; int ones = ( 1 << n ) - 1 ; int ans = minSessions ( codeTime , dp , ones , n , 0 , 0 , WorkingSessionTime ) ; if ( WorkingSessionTime < 6 ) { if ( ans % 2 == 0 ) ans = ans / 2 ; else ans = ( ans / 2 ) + 1 ; } return ans ; }
int solve ( int len , int gap ) { if ( dp [ len ] [ gap ] != -1 ) { return dp [ len ] [ gap ] ; } if ( len == 0 gap == 0 ) { return 1 ; } if ( gap < 0 ) { return 0 ; } int ans = 0 ; for ( int i = 0 ; i <= gap ; i ++ ) { ans += solve ( len - 1 , gap - i ) ; } return dp [ len ] [ gap ] = ans ; }
int countValidStrings ( string S ) { memset ( dp , -1 , sizeof ( dp ) ) ; int N = S . length ( ) ; int L = 1 , R = 9 ; int cnt = 0 ; int ans = 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] != '?' ) { R = S [ i ] - '0' ; ans *= solve ( cnt , R - L ) ; L = R ; R = 9 ; cnt = 0 ; } else { cnt ++ ; } } ans *= solve ( cnt , R - L ) ; return ans ; }
int recBananaCnt ( int A , int B , int C ) { if ( B <= A ) { return 0 ; } if ( B <= C ) { return B - A ; } if ( A == 0 ) { return B ; } if ( dp [ A ] [ B ] != -1 ) { return dp [ A ] [ B ] ; } int maxCount = INT_MIN ; int tripCount = B % C == 0 ? ( ( 2 * B ) / C ) - 1 : ( ( 2 * B ) / C ) + 1 ; for ( int i = 1 ; i <= A ; i ++ ) { int curCount = recBananaCnt ( A - i , B - tripCount * i , C ) ; if ( curCount > maxCount ) { maxCount = curCount ; dp [ A ] [ B ] = maxCount ; } } return maxCount ; }
int maxBananaCnt ( int A , int B , int C ) { memset ( dp , -1 , sizeof ( dp ) ) ; return recBananaCnt ( A , B , C ) ; }
int combinationsPossible ( int N , int idx , int prev , int val , int K , vector < vector < vector < int > > > & dp ) { if ( val > K ) { return 0 ; } if ( dp [ val ] [ idx ] [ prev ] != -1 ) { return dp [ val ] [ idx ] [ prev ] ; } if ( idx == N - 1 ) { if ( val == K ) { return 1 ; } return 0 ; } int ans = 0 ; if ( prev == 1 ) { ans += combinationsPossible ( N , idx + 1 , 1 , val + 1 , K , dp ) ; ans += combinationsPossible ( N , idx + 1 , 0 , val , K , dp ) ; } else { ans += combinationsPossible ( N , idx + 1 , 1 , val , K , dp ) ; ans += combinationsPossible ( N , idx + 1 , 0 , val , K , dp ) ; } return dp [ val ] [ idx ] [ prev ] = ans ; }
int countArray ( int arr [ ] , int N , int M ) { int dp [ N ] [ M + 2 ] ; memset ( dp , 0 , sizeof dp ) ; if ( arr [ 0 ] == -1 ) { for ( int j = 1 ; j <= M ; j ++ ) { dp [ 0 ] [ j ] = 1 ; } } else { dp [ 0 ] [ arr [ 0 ] ] = 1 ; } for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != -1 ) { int j = arr [ i ] ; dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j + 1 ] ; } if ( arr [ i ] == -1 ) { for ( int j = 1 ; j <= M ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j + 1 ] ; } } } int arrCount = 0 ; for ( int j = 1 ; j <= M ; j ++ ) { arrCount += dp [ N - 1 ] [ j ] ; } return arrCount ; }
int minChangeInLane ( int barrier [ ] , int n ) { int dp [ ] = { 1 , 0 , 1 } ; for ( int j = 0 ; j < n ; j ++ ) { int val = barrier [ j ] ; if ( val > 0 ) { dp [ val - 1 ] = 1e6 ; } for ( int i = 0 ; i < 3 ; i ++ ) { if ( val != i + 1 ) { dp [ i ] = min ( dp [ i ] , min ( dp [ ( i + 1 ) % 3 ] , dp [ ( i + 2 ) % 3 ] ) + 1 ) ; } } } return min ( dp [ 0 ] , min ( dp [ 1 ] , dp [ 2 ] ) ) ; }
int calculate ( int position , int used , int unused , int P , int M , vector < vector < vector < int > > > & dp ) { if ( position == P ) { return unused == 0 ? 1 : 0 ; } if ( dp [ position ] [ used ] [ unused ] != -1 ) return dp [ position ] [ used ] [ unused ] ; int result = 0 ; if ( unused > 0 ) { result += calculate ( position + 1 , used + 1 , unused - 1 , P , M , dp ) * unused ; } if ( used > M ) { result += calculate ( position + 1 , used , unused , P , M , dp ) * ( used - M ) ; } return dp [ position ] [ used ] [ unused ] = result ; }
int solve ( int N , int P , int M ) { vector < vector < vector < int > > > dp ( 101 , vector < vector < int > > ( 101 , vector < int > ( 101 , -1 ) ) ) ; return calculate ( 0 , 0 , N , P , M , dp ) ; }
int maxMergingScore ( int A [ ] , int N ) { for ( int len = 1 ; len < N ; ++ len ) { for ( int i = 0 ; i + len < N ; ++ i ) { int j = i + len ; dp [ i ] [ j ] = 0 ; for ( int k = i + 1 ; k < j ; ++ k ) { dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k ] [ j ] + A [ i ] * A [ j ] ) ; } } } return dp [ 0 ] [ N - 1 ] ; }
int getMin ( int x , int y , int z ) { return min ( min ( x , y ) , z ) ; }
int editDistance ( string str1 , string str2 , int m , int n ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else { dp [ i ] [ j ] = 1 + getMin ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } } } return dp [ m ] [ n ] ; }
void minimumSteps ( string & S , int N ) { int ans = INT_MAX ; for ( int i = 1 ; i < N ; i ++ ) { string S1 = S . substr ( 0 , i ) ; string S2 = S . substr ( i ) ; int count = editDistance ( S1 , S2 , S1 . length ( ) , S2 . length ( ) ) ; ans = min ( ans , count ) ; } cout << ans << '' ; }
int countOfWays ( int arr [ ] , int N ) { int pre [ N + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { pre [ i + 1 ] = pre [ i ] + arr [ i ] ; } int dp [ N + 1 ] [ N + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 1 ] [ 0 ] ++ ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N ; j >= 1 ; j -- ) { dp [ j + 1 ] [ pre [ i + 1 ] % ( j + 1 ) ] += dp [ j ] [ pre [ i + 1 ] % j ] ; if ( i == N - 1 ) { ans += dp [ j ] [ pre [ i + 1 ] % j ] ; } } } return ans ; }
void minimumDifference ( int arr [ ] , Query q [ ] , int N , int m ) { int diff [ N ] ; for ( int i = 0 ; i < N - 1 ; i ++ ) diff [ i ] = abs ( arr [ i ] - arr [ i + 1 ] ) ; minDifference ( diff , N - 1 , q , m ) ; }
int LongestOddEvenSubarray ( int A [ ] , int N ) { int dp [ N ] ; dp [ 0 ] = 1 ; int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 0 && A [ i - 1 ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ i - 1 ] % 2 != 0 ) ) { dp [ i ] = dp [ i - 1 ] + 1 ; } else dp [ i ] = 1 ; } for ( int i = 0 ; i < N ; i ++ ) ans = max ( ans , dp [ i ] ) ; return ans ; }
int minimumOperations ( int N ) { int dp [ N + 1 ] ; int i ; for ( int i = 0 ; i <= N ; i ++ ) { dp [ i ] = 1e9 ; } dp [ 2 ] = 0 ; for ( i = 2 ; i <= N ; i ++ ) { if ( dp [ i ] == 1e9 ) continue ; if ( i * 5 <= N ) { dp [ i * 5 ] = min ( dp [ i * 5 ] , dp [ i ] + 1 ) ; } if ( i + 3 <= N ) { dp [ i + 3 ] = min ( dp [ i + 3 ] , dp [ i ] + 1 ) ; } } if ( dp [ N ] == 1e9 ) return -1 ; return dp [ N ] ; }
int numTilings ( int N ) { if ( N < 3 ) { return N ; } vector < vector < long long > > dp ( N + 1 , vector < long long > ( 3 , 0 ) ) ; dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = dp [ 1 ] [ 2 ] = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 2 ] [ 0 ] + dp [ i - 2 ] [ 1 ] + dp [ i - 2 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 2 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) % MOD ; } return dp [ N ] [ 0 ] ; }
void SieveOfEratosthenes ( int n ) { prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } }
int countOfNumbers ( int index , int sum , int N ) { if ( index == N + 1 ) { if ( prime [ sum ] == true ) { return 1 ; } return 0 ; } int & val = dp [ index ] [ sum ] ; if ( val != -1 ) { return val ; } val = 0 ; if ( index == 1 ) { for ( int digit = ( N == 1 ? 0 : 1 ) ; digit <= 9 ; ++ digit ) { val += countOfNumbers ( index + 1 , sum + digit , N ) ; } } else { for ( int digit = 0 ; digit <= 9 ; ++ digit ) { val += countOfNumbers ( index + 1 , sum + digit , N ) ; } } return val ; }
int countStrings ( int N ) { if ( N == 1 ) return 0 ; if ( dp . find ( N ) != dp . end ( ) ) return dp [ N ] ; int ret = 0 ; for ( int div = 1 ; div <= sqrt ( N ) ; div ++ ) { if ( N % div == 0 ) { ret += ( 1 << div ) - countStrings ( div ) ; int div2 = N / div ; if ( div2 != div and div != 1 ) ret += ( 1 << div2 ) - countStrings ( div2 ) ; } } dp [ N ] = ret ; return ret ; }
void countOfNumbers ( int N ) { int ans = 1 ; for ( int index = 1 ; index <= N ; ++ index ) { int choices = 0 ; for ( int digit = 1 ; digit <= 9 ; ++ digit ) { if ( index % digit == 0 ) { ++ choices ; } } ans = ( ans * 1LL * choices ) % mod ; } cout << ans << endl ; }
int MaxProfit ( int arr [ ] , int n , int transactionFee ) { int buy = - arr [ 0 ] ; int sell = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int temp = buy ; buy = max ( buy , sell - arr [ i ] ) ; sell = max ( sell , temp + arr [ i ] - transactionFee ) ; } return max ( sell , buy ) ; }
int dfs ( int arr [ ] , int left , int K ) { int q = 0 ; if ( left == 0 ) { for ( int i = 1 ; i < K ; ++ i ) { if ( arr [ i ] > 0 ) { arr [ i ] -- ; q = max ( q , 1 + dfs ( arr , K - i , K ) ) ; arr [ i ] ++ ; } } } else { for ( int i = 1 ; i < K ; ++ i ) { if ( arr [ i ] > 0 ) { arr [ i ] -- ; int nleft = ( i <= left ? left - i : K + left - i ) ; q = max ( q , dfs ( arr , nleft , K ) ) ; arr [ i ] ++ ; } } } return q ; }
int dfs ( int V [ ] , int left , int K ) { int q = 0 ; string key = "" ; for ( int i = 0 ; i < K ; i ++ ) { key = key + to_string ( V [ i ] ) ; } key += to_string ( left ) ; if ( memo . find ( key ) != memo . end ( ) ) return memo [ key ] ; else if ( left == 0 ) { for ( int i = 1 ; i < K ; ++ i ) if ( V [ i ] > 0 ) { V [ i ] -- ; q = max ( q , 1 + dfs ( V , K - i , K ) ) ; V [ i ] ++ ; } } else { for ( int i = 1 ; i < K ; ++ i ) { if ( V [ i ] > 0 ) { V [ i ] -- ; int nleft = i <= left ? left - i : K + left - i ; q = max ( q , dfs ( V , nleft , K ) ) ; V [ i ] ++ ; } } } if ( memo . find ( key ) != memo . end ( ) ) memo [ key ] = q ; else memo [ key ] = q ; return q ; }
int maxGroups ( int K , int arr [ ] ) { int V [ K ] ; memset ( V , 0 , sizeof ( V ) ) ; for ( int i = 0 ; i < 6 ; i ++ ) V [ arr [ i ] % K ] ++ ; int ans = V [ 0 ] + dfs ( V , 0 , K ) ; return ans ; }
int countMinSteps ( string A , string B , int N ) { vector < int > dp ( N + 1 , 0 ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( A [ i - 1 ] == B [ i - 1 ] ) { dp [ i ] = dp [ i - 1 ] ; } else { dp [ i ] = dp [ i - 1 ] + 1 ; } if ( i >= 2 && A [ i - 2 ] == B [ i - 1 ] && A [ i - 1 ] == B [ i - 2 ] ) { dp [ i ] = min ( dp [ i ] , dp [ i - 2 ] + 1 ) ; } } return dp [ N ] ; }
void findMaxJumps ( int arr [ ] , int N ) { int dp [ N ] = { 0 } ; int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { dp [ i ] = arr [ i ] ; int j = i + arr [ i ] ; if ( j < N ) { dp [ i ] = dp [ i ] + dp [ j ] ; } ans = max ( ans , dp [ i ] ) ; } cout << ans ; }
void countNDigitNumber ( int N ) { memset ( dp , -1 , sizeof dp ) ; cout << countOfNumbers ( 1 , 0 , 0 , N ) ; }
string getMaximum ( string & S , string & T ) { if ( S . find ( "0" ) != string :: npos ) return T ; if ( T . find ( "0" ) != string :: npos ) return S ; return ( S . length ( ) > T . length ( ) ? S : T ) ; }
string recursion ( int arr [ ] , int idx , int N , int K , vector < vector < string > > & dp ) { if ( K == 0 ) { return "" ; } if ( K < 0 or idx == N ) { return "0" ; } if ( dp [ idx ] [ K ] != "-1" ) return dp [ idx ] [ K ] ; string include = to_string ( idx + 1 ) + recursion ( arr , 0 , N , K - arr [ idx ] , dp ) ; string exclude = recursion ( arr , idx + 1 , N , K , dp ) ; return dp [ idx ] [ K ] = getMaximum ( include , exclude ) ; }
void longestSubsequence ( int * arr , int N ) { int dp [ N ] [ N + 1 ] ; memset ( dp , -1 , sizeof dp ) ; for ( int i = 0 ; i < N ; ++ i ) { dp [ i ] [ 0 ] = 0 ; } dp [ 0 ] [ 1 ] = ( arr [ 0 ] >= 0 ? arr [ 0 ] : -1 ) ; for ( int i = 1 ; i < N ; ++ i ) { for ( int j = 1 ; j <= ( i + 1 ) ; ++ j ) { if ( dp [ i - 1 ] [ j ] != -1 ) { dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; } if ( dp [ i - 1 ] [ j - 1 ] >= 0 && dp [ i - 1 ] [ j - 1 ] + arr [ i ] >= 0 ) { dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] + arr [ i ] ) ; } } } int ans = 0 ; for ( int j = 0 ; j <= N ; ++ j ) { if ( dp [ N - 1 ] [ j ] >= 0 ) { ans = j ; } } cout << ans << endl ; }
int Count ( int N , int L , int R ) { vector < vector < int > > dp ( N , vector < int > ( R - L + 1 , 0 ) ) ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( int i = 1 ; i < dp [ 0 ] . size ( ) ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 1 ; } ans = dp [ 0 ] [ R - L ] ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < dp [ 0 ] . size ( ) ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; } ans += dp [ i ] [ R - L ] ; } return ans ; }
int largestCommonSubarray ( vector < vector < int > > arr , int n , int m ) { int dp [ n ] [ m + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { dp [ i ] [ arr [ i ] [ j ] ] = j ; } } int ans = 1 ; int len = 1 ; for ( int i = 1 ; i < m ; i ++ ) { bool check = true ; for ( int j = 1 ; j < n ; j ++ ) { if ( dp [ j ] [ arr [ 0 ] [ i - 1 ] ] + 1 != dp [ j ] [ arr [ 0 ] [ i ] ] ) { check = false ; break ; } } if ( check ) { len ++ ; ans = max ( ans , len ) ; } else { len = 1 ; } } return ans ; }
int countOfNumbers ( int digit , int prev1 , int prev2 , int n ) { if ( digit == n + 1 ) { return 1 ; } int & val = dp [ digit ] [ prev1 ] [ prev2 ] ; if ( val != -1 ) { return val ; } val = 0 ; if ( digit == 1 ) { for ( int i = ( n == 1 ? 0 : 1 ) ; i <= 9 ; ++ i ) { val += countOfNumbers ( digit + 1 , i , prev1 , n ) ; } } else if ( digit == 2 ) { for ( int i = 0 ; i <= 9 ; ++ i ) { val += countOfNumbers ( digit + 1 , i , prev1 , n ) ; } } else { int mean = prev1 ; int current = ( 2 * mean ) - prev2 ; if ( current >= 0 and current <= 9 ) val += countOfNumbers ( digit + 1 , current , prev1 , n ) ; if ( ( current + 1 ) >= 0 and ( current + 1 ) <= 9 ) val += countOfNumbers ( digit + 1 , current + 1 , prev1 , n ) ; } return val ; }
int countOfNumbers ( int digit , int prev , int n ) { if ( digit == n + 1 ) { return 1 ; } int & val = dp [ digit ] [ prev ] ; if ( val != -1 ) { return val ; } val = 0 ; if ( digit == 1 ) { for ( int i = ( n == 1 ? 0 : 1 ) ; i <= 9 ; ++ i ) { val += countOfNumbers ( digit + 1 , i , n ) ; } } else { for ( int i = 0 ; i <= 9 ; ++ i ) { if ( ( i & prev ) == 0 ) { val += countOfNumbers ( digit + 1 , i , n ) ; } } } return val ; }
int totalSubarrays ( int arr [ ] , int n , int k ) { int ans = 0 , i = 0 ; while ( i < n ) { if ( arr [ i ] > k ) { i ++ ; continue ; } int count = 0 ; while ( i < n && arr [ i ] <= k ) { i ++ ; count ++ ; } ans += ( ( count * ( count + 1 ) ) / 2 ) ; } return ans ; }
int countSubarrays ( int arr [ ] , int n , int k ) { int count1 = totalSubarrays ( arr , n , k - 1 ) ; int count2 = totalSubarrays ( arr , n , k ) ; int ans = count2 - count1 ; return ans ; }
int MaximumSum ( int a [ ] , int b [ ] , int n ) { int dp [ n ] [ 2 ] ; dp [ 0 ] [ 0 ] = a [ 0 ] ; dp [ 0 ] [ 1 ] = b [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i ] ; dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) ; if ( i - 2 >= 0 ) { dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , max ( dp [ i - 2 ] [ 0 ] , dp [ i - 2 ] [ 1 ] ) + b [ i ] ) ; } else { dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , b [ i ] ) ; } } return max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; }
int numberOfArrays ( int n , int l ) { int dp [ l + 1 ] [ n + 1 ] ; memset ( dp , 0 , sizeof dp ) ; dp [ 0 ] [ 1 ] = 1 ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { for ( int k = j ; k <= n ; k += j ) { dp [ i + 1 ] [ k ] += dp [ i ] [ j ] ; } } } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ans += dp [ l ] [ i ] ; } return ans ; }
int waysOfDecoding ( string s ) { vector < int > dp ( ( int ) s . size ( ) + 1 ) ; dp [ 0 ] = 1 ; dp [ 1 ] = s [ 0 ] == '*' ? 9 : s [ 0 ] == '0' ? 0 : 1 ; for ( int i = 1 ; i < ( int ) s . size ( ) ; i ++ ) { if ( s [ i ] == '*' ) { dp [ i + 1 ] = 9 * dp [ i ] ; if ( s [ i - 1 ] == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '2' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '*' ) dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M ; } else { dp [ i + 1 ] = s [ i ] != '0' ? dp [ i ] : 0 ; if ( s [ i - 1 ] == '1' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '2' && s [ i ] <= '6' ) dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M ; else if ( s [ i - 1 ] == '*' ) dp [ i + 1 ] = ( dp [ i + 1 ] + ( s [ i ] <= '6' ? 2 : 1 ) * dp [ i - 1 ] ) % M ; } } return dp [ ( int ) s . size ( ) ] ; }
int KvisibleFromLeft ( int N , int K ) { if ( dp [ N ] [ K ] != -1 ) return dp [ N ] [ K ] ; if ( N == K ) return dp [ N ] [ K ] = 1 ; if ( K == 1 ) { int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) ans *= i ; return dp [ N ] [ K ] = ans ; } return dp [ N ] [ K ] = KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) ; }
int minimumDeletions ( int A [ ] , int N ) { int ans = INT_MAX ; for ( int i = 1 ; i < ( 1 << N ) ; i ++ ) { vector < int > temp ; for ( int j = 0 ; j < N ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) { temp . push_back ( A [ j ] ) ; } } int flag = 0 ; for ( int j = 1 ; j < temp . size ( ) ; j ++ ) if ( temp [ j ] < temp [ j - 1 ] ) flag = 1 ; for ( int j = 1 ; j < temp . size ( ) - 1 ; j ++ ) if ( temp [ j ] - temp [ j - 1 ] > temp [ j + 1 ] - temp [ j ] ) flag = 1 ; if ( flag == 0 ) { ans = min ( ans , N - ( int ) temp . size ( ) ) ; } } return ans ; }
int kvowelwords ( int N , int K ) { long long int i , j ; long long int MOD = 1000000007 ; long long int dp [ N + 1 ] [ K + 1 ] = { 0 } ; long long int sum = 1 ; for ( i = 1 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = sum * 21 ; dp [ i ] [ 0 ] %= MOD ; sum = dp [ i ] [ 0 ] ; for ( j = 1 ; j <= K ; j ++ ) { if ( j > i ) dp [ i ] [ j ] = 0 ; else if ( j == i ) { dp [ i ] [ j ] = power ( 5ll , i , MOD ) ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] * 5 ; } dp [ i ] [ j ] %= MOD ; sum += dp [ i ] [ j ] ; sum %= MOD ; } } return sum ; }
int maximumSum ( vector < int > A , int N , int K , int D ) { int ans = 0 ; for ( int i = 0 ; i < ( 1 << N ) ; i ++ ) { int sum = 0 ; int c = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( i >> j & 1 ) { sum += A [ j ] ; c ++ ; } } if ( sum % D == 0 && c <= K ) ans = max ( ans , sum ) ; } return ans ; }
int maxSumWO3Consec ( int A [ ] , int N ) { if ( N == 1 ) return A [ 0 ] ; if ( N == 2 ) return A [ 0 ] + A [ 1 ] ; int third = A [ 0 ] ; int second = third + A [ 1 ] ; int first = max ( second , A [ 1 ] + A [ 2 ] ) ; int sum = max ( max ( third , second ) , first ) ; for ( int i = 3 ; i < N ; i ++ ) { sum = max ( max ( first , second + A [ i ] ) , third + A [ i ] + A [ i - 1 ] ) ; third = second ; second = first ; first = sum ; } return sum ; }
string longestSubsequence ( string X , string Y ) { int n = X . size ( ) ; int m = Y . size ( ) ; vector < vector < int > > mat ( n + 1 , vector < int > ( m + 1 ) ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < m + 1 ; j ++ ) { if ( i == 0 j == 0 ) mat [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < m + 1 ; j ++ ) { if ( X [ i - 1 ] == Y [ j - 1 ] ) { mat [ i ] [ j ] = 1 + mat [ i - 1 ] [ j - 1 ] ; } else { mat [ i ] [ j ] = mat [ i - 1 ] [ j ] ; } } } int len = 0 , col = 0 ; for ( int i = 0 ; i < m + 1 ; i ++ ) { if ( mat [ n ] [ i ] > len ) { len = mat [ n ] [ i ] ; col = i ; } } string res = "" ; int i = n ; int j = col ; while ( len > 0 ) { if ( X [ i - 1 ] == Y [ j - 1 ] ) { res = X [ i - 1 ] + res ; i -- ; j -- ; len -- ; } else { i -- ; } } return res ; }
void calculateStart ( int n , int m ) { for ( int i = 1 ; i < m ; ++ i ) { start [ 0 ] [ i ] += start [ 0 ] [ i - 1 ] ; } for ( int i = 1 ; i < n ; ++ i ) { start [ i ] [ 0 ] += start [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < n ; ++ i ) { for ( int j = 1 ; j < m ; ++ j ) { start [ i ] [ j ] += max ( start [ i - 1 ] [ j ] , start [ i ] [ j - 1 ] ) ; } } }
void calculateEnd ( int n , int m ) { for ( int i = n - 2 ; i >= 0 ; -- i ) { ending [ i ] [ m - 1 ] += ending [ i + 1 ] [ m - 1 ] ; } for ( int i = m - 2 ; i >= 0 ; -- i ) { ending [ n - 1 ] [ i ] += ending [ n - 1 ] [ i + 1 ] ; } for ( int i = n - 2 ; i >= 0 ; -- i ) { for ( int j = m - 2 ; j >= 0 ; -- j ) { ending [ i ] [ j ] += max ( ending [ i + 1 ] [ j ] , ending [ i ] [ j + 1 ] ) ; } } }
void maximumPathSum ( int mat [ ] [ 3 ] , int n , int m , int q , int coordinates [ ] [ 2 ] ) { for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { start [ i ] [ j ] = mat [ i ] [ j ] ; ending [ i ] [ j ] = mat [ i ] [ j ] ; } } calculateStart ( n , m ) ; calculateEnd ( n , m ) ; int ans = 0 ; for ( int i = 0 ; i < q ; ++ i ) { int X = coordinates [ i ] [ 0 ] - 1 ; int Y = coordinates [ i ] [ 1 ] - 1 ; ans = max ( ans , start [ X ] [ Y ] + ending [ X ] [ Y ] - mat [ X ] [ Y ] ) ; } cout << ans ; }
int countAlternatingSubstrings ( string S , int N ) { vector < vector < int > > dp ( 2 , vector < int > ( N , 0 ) ) ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 ) { if ( S [ i ] == '1' ) dp [ 1 ] [ i ] = 1 ; else dp [ 0 ] [ i ] = 1 ; } else { if ( S [ i ] == '0' ) dp [ 0 ] [ i ] = 1 + dp [ 1 ] [ i + 1 ] ; else dp [ 1 ] [ i ] = 1 + dp [ 0 ] [ i + 1 ] ; } } int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { ans += max ( dp [ 0 ] [ i ] , dp [ 1 ] [ i ] ) ; } return ans ; }
int countSubset ( int arr [ ] , int n , int diff ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum += diff ; sum = sum / 2 ; int t [ n + 1 ] [ sum + 1 ] ; for ( int j = 0 ; j <= sum ; j ++ ) t [ 0 ] [ j ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) t [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( arr [ i - 1 ] > j ) t [ i ] [ j ] = t [ i - 1 ] [ j ] ; else { t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } } return t [ n ] [ sum ] ; }
int maximizeAnd ( int i , int mask , int * A , int * B , int N , vector < vector < int > > & dp ) { if ( i == N ) return 0 ; if ( dp [ i ] [ mask ] != -1 ) return dp [ i ] [ mask ] ; for ( int j = 0 ; j < N ; ++ j ) { if ( ! ( mask & ( 1 << j ) ) ) { dp [ i ] [ mask ] = max ( dp [ i ] [ mask ] , ( A [ i ] & B [ j ] ) + maximizeAnd ( i + 1 , mask | ( 1 << j ) , A , B , N , dp ) ) ; } } return dp [ i ] [ mask ] ; }
int maximizeAndUtil ( int * A , int * B , int N ) { vector < vector < int > > dp ( N , vector < int > ( 1 << N + 1 , -1 ) ) ; return maximizeAnd ( 0 , 0 , A , B , N , dp ) ; }
long long countOfNumbers ( int digit , int prev1 , int prev2 , int N ) { if ( digit == N + 1 ) return 1 ; if ( dp [ digit ] [ prev1 ] [ prev2 ] != -1 ) return dp [ digit ] [ prev1 ] [ prev2 ] ; dp [ digit ] [ prev1 ] [ prev2 ] = 0 ; if ( digit == 1 ) { for ( int j = ( N == 1 ? 0 : 1 ) ; j <= 9 ; ++ j ) { dp [ digit ] [ prev1 ] [ prev2 ] += countOfNumbers ( digit + 1 , j , prev1 , N ) ; } } else if ( digit == 2 ) { for ( int j = 0 ; j <= 9 ; ++ j ) { dp [ digit ] [ prev1 ] [ prev2 ] += countOfNumbers ( digit + 1 , j , prev1 , N ) ; } } else { for ( int j = 0 ; j <= abs ( prev1 - prev2 ) ; ++ j ) { dp [ digit ] [ prev1 ] [ prev2 ] += countOfNumbers ( digit + 1 , j , prev1 , N ) ; } } return dp [ digit ] [ prev1 ] [ prev2 ] ; }
void findNthNum ( long long int N ) { long long int a , b , left ; long long int right , mid ; long long int t , last_num = 0 ; left = 1 , right = N ; while ( left <= right ) { mid = left + ( right - left ) / 2 ; t = ( mid * ( mid + 1 ) ) / 2 ; if ( t < N ) { left = mid + 1 ; } else if ( t == N ) { a = mid ; break ; } else { a = mid ; right = mid - 1 ; } } t = a - 1 ; b = N - ( t * ( t + 1 ) ) / 2 - 1 ; cout << ( 1 << a ) + ( 1 << b ) ; }
void longestSubWithMaxSum ( int arr [ ] , int N ) { int Max = * max_element ( arr , arr + N ) ; if ( Max < 0 ) { cout << Max ; return ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= 0 ) { cout << arr [ i ] << " " ; } } }
void maxSumUtil ( int arr [ ] , int n ) { memset ( dp , -1 , sizeof ( dp ) ) ; cout << maxSum ( arr , 0 , n , 2 , 0 ) ; }
void maximumSum ( int arr [ ] , int n ) { int preSum [ n ] ; int sum = 0 ; int maxSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = max ( arr [ i ] , sum + arr [ i ] ) ; maxSum = max ( maxSum , sum ) ; preSum [ i ] = maxSum ; } sum = 0 ; maxSum = 0 ; int postSum [ n + 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { sum = max ( arr [ i ] , sum + arr [ i ] ) ; maxSum = max ( maxSum , sum ) ; postSum [ i ] = maxSum ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = max ( ans , preSum [ i ] + postSum [ i ] ) ; } cout << ( ans ) ; }
int NumberOfways ( int N , int K ) { vector < int > dp ( N + 1 , 0 ) ; dp [ 0 ] = 1 ; for ( int row = 1 ; row < K + 1 ; row ++ ) { for ( int col = 1 ; col < N + 1 ; col ++ ) { if ( col >= row ) dp [ col ] = dp [ col ] + dp [ col - row ] ; } } return ( dp [ N ] ) ; }
void findAPSequence ( int arr [ ] , int N , int Q [ ] [ 2 ] , int M ) { int dp [ N + 5 ] = { 0 } ; for ( int i = 0 ; i + 1 < N ; ) { int j = i + 1 ; while ( j + 1 < N && arr [ j + 1 ] - arr [ j ] == arr [ i + 1 ] - arr [ i ] ) j ++ ; for ( int k = i ; k < j ; k ++ ) { dp [ k ] = j - k ; } i = j ; } for ( int i = 0 ; i < M ; i ++ ) { if ( dp [ Q [ i ] [ 0 ] ] >= Q [ i ] [ 1 ] - Q [ i ] [ 0 ] ) { cout << "Yes" << endl ; } else { cout << "No" << endl ; } } }
bool isUnique ( string s ) { set < char > Set ; for ( char c : s ) { Set . insert ( c ) ; } return Set . size ( ) == 1 ; }
int maxScore ( string s , int a [ ] ) { int n = s . length ( ) ; if ( n == 0 ) return 0 ; if ( n == 1 ) return a [ 0 ] ; int mx = -1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { string sub = s . substr ( i , j + 1 ) ; if ( isUnique ( sub ) ) mx = max ( mx , a [ sub . length ( ) - 1 ] + maxScore ( s . substr ( 0 , i ) + s . substr ( j + 1 ) , a ) ) ; } } return mx ; }
int numberOfUniqueOutcomes ( int N , int S ) { if ( S < N ) return 0 ; if ( N == 1 N == S ) return 1 ; return ( numberOfUniqueOutcomes ( N - 1 , S - 1 ) + numberOfUniqueOutcomes ( N - 1 , S - 2 ) ) ; }
int numberOfUniqueOutcomes ( int n , int s ) { if ( s < n ) ans [ n ] [ s ] = 0 ; else if ( n == 1 n == s ) ans [ n ] [ s ] = 1 ; else if ( ! ans [ n ] [ s ] ) { ans [ n ] [ s ] = numberOfUniqueOutcomes ( n - 1 , s - 1 ) + numberOfUniqueOutcomes ( n - 1 , s - 2 ) ; } return ans [ n ] [ s ] ; }
int MinimumLength ( int A [ ] , int N , int K ) { sort ( A , A + N ) ; int suffix [ N + 1 ] = { 0 } ; for ( int i = N - 1 ; i >= 0 ; i -- ) suffix [ i ] = suffix [ i + 1 ] + A [ i ] ; int dp [ N + 1 ] [ K + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= K ; j ++ ) dp [ i ] [ j ] = MAX ; dp [ N ] [ 0 ] = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = K ; j >= 0 ; j -- ) { if ( j <= A [ i ] ) { dp [ i ] [ j ] = A [ i ] ; continue ; } if ( dp [ i + 1 ] [ j - A [ i ] ] == MAX ) dp [ i ] [ j ] = MAX ; else dp [ i ] [ j ] = min ( dp [ i + 1 ] [ j ] , dp [ i + 1 ] [ j - A [ i ] ] + A [ i ] ) ; } } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( suffix [ i ] - dp [ i ] [ K ] >= K ) { return N - i ; } } return -1 ; }
void countXOR ( int arr [ ] , int comb [ ] , int start , int end , int index , int r ) { if ( index == r ) { int new_xor = 0 ; for ( int j = 0 ; j < r ; j ++ ) { new_xor ^= comb [ j ] ; } s . insert ( new_xor ) ; return ; } for ( int i = start ; i <= end && end - i + 1 >= r - index ; i ++ ) { comb [ index ] = arr [ i ] ; countXOR ( arr , comb , i + 1 , end , index + 1 , r ) ; } }
void maxSizeSet ( int arr [ ] , int N ) { for ( int r = 2 ; r <= N ; r ++ ) { int comb [ r + 1 ] ; countXOR ( arr , comb , 0 , N - 1 , 0 , r ) ; } cout << s . size ( ) << endl ; }
void maxSizeSet ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { insertVector ( arr [ i ] ) ; } cout << ( 1 << ans ) << endl ; }
void waysToPaint ( int n ) { int same = 6 ; int diff = 6 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long sameTmp = 3 * same + 2 * diff ; long diffTmp = 2 * same + 2 * diff ; same = sameTmp ; diff = diffTmp ; } cout << ( same + diff ) ; }
void printMinimumRemovals ( string str , string X ) { int N = str . size ( ) ; int M = X . size ( ) ; int dp [ N ] [ M ] = { } ; for ( int j = 0 ; j < M ; j ++ ) { if ( str [ 0 ] == X [ j ] ) { dp [ 0 ] [ j ] = 1 ; } } for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( str [ i ] == X [ j ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + 1 ; if ( j != 0 ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } } cout << dp [ N - 1 ] [ M - 1 ] ; }
int maxSubarraySum ( vector < int > & sum , int k , int row ) { int curSum = 0 , curMax = INT_MIN ; set < int > sumSet ; sumSet . insert ( 0 ) ; for ( int r = 0 ; r < row ; ++ r ) { curSum += sum [ r ] ; auto it = sumSet . lower_bound ( curSum - k ) ; if ( it != sumSet . end ( ) ) { curMax = max ( curMax , curSum - * it ) ; } sumSet . insert ( curSum ) ; } return curMax ; }
void maxSumSubmatrix ( vector < vector < int > > & matrix , int k ) { int row = matrix . size ( ) ; int col = matrix [ 0 ] . size ( ) ; int ret = INT_MIN ; for ( int i = 0 ; i < col ; ++ i ) { vector < int > sum ( row , 0 ) ; for ( int j = i ; j < col ; ++ j ) { for ( int r = 0 ; r < row ; ++ r ) { sum [ r ] += matrix [ r ] [ j ] ; } int curMax = maxSubarraySum ( sum , k , row ) ; ret = max ( ret , curMax ) ; } } cout << ret ; }
void minCost ( int arr [ ] , int n ) { if ( n < 3 ) { cout << arr [ 0 ] ; return ; } int * dp = new int [ n ] ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ; for ( int i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ; dp [ n - 1 ] = min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ; cout << dp [ n - 1 ] ; }
void maxSum ( int arr [ ] , int N , int K ) { int dp [ N + 2 ] = { 0 } ; int maxval = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( ( i + K * arr [ i ] ) >= N ) { dp [ i ] = arr [ i ] ; } else { dp [ i ] = dp [ i + K * arr [ i ] ] + arr [ i ] ; } maxval = max ( maxval , dp [ i ] ) ; } cout << maxval ; }
void maxSubmatrixSum ( vector < vector < int > > matrix ) { int r = matrix . size ( ) ; int c = matrix [ 0 ] . size ( ) ; int maxSubmatrix = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { for ( int k = i ; k < r ; k ++ ) { for ( int l = j ; l < c ; l ++ ) { int sumSubmatrix = 0 ; for ( int m = i ; m <= k ; m ++ ) { for ( int n = j ; n <= l ; n ++ ) { sumSubmatrix += matrix [ m ] [ n ] ; } } maxSubmatrix = max ( maxSubmatrix , sumSubmatrix ) ; } } } } cout << maxSubmatrix ; }
int kadane ( vector < int > v ) { int currSum = 0 ; int maxSum = INT_MIN ; for ( int i = 0 ; i < ( int ) v . size ( ) ; i ++ ) { currSum += v [ i ] ; if ( currSum > maxSum ) { maxSum = currSum ; } if ( currSum < 0 ) { currSum = 0 ; } } return maxSum ; }
int minCost ( vector < vector < int > > & costs , int N ) { if ( N == 0 ) return 0 ; vector < vector < int > > dp ( N , vector < int > ( 3 , 0 ) ) ; dp [ 0 ] [ 0 ] = costs [ 0 ] [ 0 ] ; dp [ 0 ] [ 1 ] = costs [ 0 ] [ 1 ] ; dp [ 0 ] [ 2 ] = costs [ 0 ] [ 2 ] ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 0 ] ; dp [ i ] [ 1 ] = min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 1 ] ; dp [ i ] [ 2 ] = min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + costs [ i ] [ 2 ] ; } cout << min ( dp [ N - 1 ] [ 0 ] , min ( dp [ N - 1 ] [ 1 ] , dp [ N - 1 ] [ 2 ] ) ) ; }
int findCnt ( int * arr , int i , int required_sum , int n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ required_sum + base ] ) return dp [ i ] [ required_sum + base ] ; v [ i ] [ required_sum + base ] = 1 ; dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + base ] ; }
void countSubsets ( int * arr , int K , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int S1 = ( sum + K ) / 2 ; cout << findCnt ( arr , 0 , S1 , n ) ; }
int solve ( vector < int > & A , int i , int sum , int N ) { int res = 2001 ; if ( sum < 0 or ( i == N and sum != 0 ) ) { return 2001 ; } if ( sum == 0 or i >= N ) { return dp [ i ] [ sum ] = 0 ; } if ( dp [ i ] [ sum ] != -1 ) { return dp [ i ] [ sum ] ; } res = min ( solve ( A , i + 1 , sum - A [ i ] , N ) + 1 , solve ( A , i + 1 , sum , N ) ) ; return dp [ i ] [ sum ] = res ; }
void daysToCure ( int arr [ ] , int N , int P ) { int risk = 0 ; int normal_risk = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= 60 arr [ i ] <= 10 ) { risk ++ ; } else { normal_risk ++ ; } } int days = ( risk / P ) + ( risk % P > 0 ) + ( normal_risk / P ) + ( normal_risk % P > 0 ) ; cout << days ; }
int countAverage ( int n , int K , int * arr ) { dp [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int s = 0 ; s <= 1000 ; s ++ ) { dp [ i + 1 ] [ k + 1 ] [ s + arr [ i ] ] += dp [ i ] [ k ] [ s ] ; dp [ i + 1 ] [ k ] [ s ] += dp [ i ] [ k ] [ s ] ; } } } int cnt = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { cnt += dp [ n ] [ j ] [ K * j ] ; } return cnt ; }
void maximumSubsetSum ( int arr1 [ ] , int arr2 [ ] , int length ) { int dp [ length + 1 ] ; if ( length == 1 ) { cout << ( max ( arr1 [ 0 ] , arr2 [ 0 ] ) ) ; return ; } if ( length == 2 ) { cout << ( max ( max ( arr1 [ 1 ] , arr2 [ 1 ] ) , max ( arr1 [ 0 ] , arr2 [ 0 ] ) ) ) ; return ; } else { dp [ 0 ] = max ( arr1 [ 0 ] , arr2 [ 0 ] ) ; dp [ 1 ] = max ( max ( arr1 [ 1 ] , arr2 [ 1 ] ) , max ( arr1 [ 0 ] , arr2 [ 0 ] ) ) ; int index = 2 ; while ( index < length ) { dp [ index ] = max ( max ( arr1 [ index ] , arr2 [ index ] ) , max ( max ( arr1 [ index ] + dp [ index - 2 ] , arr2 [ index ] + dp [ index - 2 ] ) , dp [ index - 1 ] ) ) ; ++ index ; } cout << ( dp [ length - 1 ] ) ; } }
int FindMaxS ( int X , int Y , int Z , int n , vector < int > & A , vector < int > & B , vector < int > & C ) { if ( X < 0 or Y < 0 or Z < 0 ) return INT_MIN ; if ( n < 0 ) return 0 ; if ( dp [ n ] [ X ] [ Y ] [ Z ] != -1 ) { return dp [ n ] [ X ] [ Y ] [ Z ] ; } int ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) ; int ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) ; int co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) ; int no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) ; int maximum = max ( ch , max ( ca , max ( co , no ) ) ) ; return dp [ n ] [ X ] [ Y ] [ Z ] = maximum ; }
void findCount ( int N , int maxDigit [ ] ) { int ans = findCountUtil ( N , maxDigit ) ; cout << ans ; }
long double find ( int N , int sum ) { if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } long double s = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; }
float find ( int N , int sum ) { if ( dp [ N ] [ sum ] ) return dp [ N ] [ sum ] ; if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } for ( int i = 1 ; i <= 6 ; i ++ ) dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N ] [ sum ] ; }
float find ( int N , int a , int b ) { float probability = 0.0 ; for ( int i = 1 ; i <= 6 ; i ++ ) dp [ 1 ] [ i ] = 1.0 / 6 ; for ( int i = 2 ; i <= N ; i ++ ) { for ( int j = i ; j <= 6 * i ; j ++ ) { for ( int k = 1 ; k <= 6 ; k ++ ) { dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - k ] / 6 ; } } } for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + dp [ N ] [ sum ] ; return probability ; }
void minAtEachIndex ( int n , int arr [ ] ) { int dp1 [ n ] ; int dp2 [ n ] ; int i ; dp1 [ 0 ] = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) dp1 [ i ] = min ( arr [ i ] , dp1 [ i - 1 ] + 1 ) ; dp2 [ n - 1 ] = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) dp2 [ i ] = min ( arr [ i ] , dp2 [ i + 1 ] + 1 ) ; vector < int > v ; for ( i = 0 ; i < n ; i ++ ) v . push_back ( min ( dp1 [ i ] , dp2 [ i ] ) ) ; for ( auto x : v ) cout << x << " " ; }
int totalArrays ( int N , int M ) { int end_with_one [ N + 1 ] ; int end_not_with_one [ N + 1 ] ; end_with_one [ 0 ] = 1 ; end_not_with_one [ 0 ] = 0 ; end_with_one [ 1 ] = 0 ; end_not_with_one [ 1 ] = M - 1 ; for ( int i = 2 ; i < N ; i ++ ) { end_with_one [ i ] = end_not_with_one [ i - 1 ] ; end_not_with_one [ i ] = end_with_one [ i - 1 ] * ( M - 1 ) + end_not_with_one [ i - 1 ] * ( M - 2 ) ; } return end_with_one [ N - 1 ] ; }
int prodOfDigit ( int N ) { int res = 1 ; while ( N ) { res = res * ( N % 10 ) ; N /= 10 ; } return res ; }
int cntNum ( string X , int i , int prod , int K , int st , int tight , int dp [ M ] [ M ] [ 2 ] [ 2 ] ) { if ( i >= X . length ( ) prod > K ) { return prod == K ; } if ( dp [ prod ] [ i ] [ tight ] [ st ] != -1 ) { return dp [ prod ] [ i ] [ tight ] [ st ] ; } int res = 0 ; int end = tight ? X [ i ] - '0' : 9 ; for ( int j = 0 ; j <= end ; j ++ ) { if ( j == 0 && ! st ) { res += cntNum ( X , i + 1 , prod , K , false , ( tight & ( j == end ) ) , dp ) ; } else { res += cntNum ( X , i + 1 , prod * j , K , true , ( tight & ( j == end ) ) , dp ) ; } return dp [ prod ] [ i ] [ tight ] [ st ] = res ; } int UtilCntNumRange ( int L , int R , int K ) { string str = to_string ( R ) ; int dp [ M ] [ M ] [ 2 ] [ 2 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; int cntR = cntNum ( str , 0 , 1 , K , false , true , dp ) ; str = to_string ( L - 1 ) ; memset ( dp , -1 , sizeof ( dp ) ) ; int cntL = cntNum ( str , 0 , 1 , K , false , true , dp ) ; return ( cntR - cntL ) ; } int main ( ) { int L = 20 , R = 10000 , K = 14 ; cout << UtilCntNumRange ( L , R , K ) ; }
long long power ( long long X , long long Y ) { long long res = 1 ; X = X % M ; if ( X == 0 ) return 0 ; while ( Y > 0 ) { if ( Y & 1 ) { res = ( res * X ) % M ; } Y = Y >> 1 ; X = ( X * X ) % M ; } return res ; }
int findValue ( long long int n ) { long long X = 0 ; long long pow_10 = 1 ; while ( n ) { if ( n & 1 ) { X += pow_10 ; } pow_10 *= 10 ; n /= 2 ; } X = ( X * 2 ) % M ; long long res = power ( 2 , X ) ; return res ; }
int mod_pow2 ( int n ) { while ( n >= MEM . size ( ) ) MEM . push_back ( ( MEM [ -1 ] * 2 ) % MOD ) ; return MEM [ n ] ; }
int inversions ( string bstr ) { int total = 0 , zeros = 0 , questions = 0 ; reverse ( bstr . begin ( ) , bstr . end ( ) ) ; for ( char x : bstr ) { int q ; if ( x == '1' ) { int z = zeros * mod_pow2 ( questions ) ; if ( questions == 0 ) q = 0 ; else q = questions * mod_pow2 ( questions - 1 ) ; total = ( total + z + q ) % MOD ; } else if ( x == '0' ) { zeros += 1 ; } else { total *= 2 ; int z = zeros * mod_pow2 ( questions ) ; if ( questions == 0 ) q = 0 ; else q = questions * mod_pow2 ( questions - 1 ) ; total = ( total + z + q ) % MOD ; questions += 1 ; } } return total ; }
double findMedXOR ( int mat [ ] [ 2 ] , int N , int M ) { int dp [ N ] [ M ] ; int med [ N * M ] ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; med [ 0 ] = dp [ 0 ] [ 0 ] ; int len = 1 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ^ mat [ i ] [ 0 ] ; med [ len ++ ] = dp [ i ] [ 0 ] ; } for ( int i = 1 ; i < M ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ^ mat [ 0 ] [ i ] ; med [ len ++ ] = dp [ 0 ] [ i ] ; } for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ^ dp [ i ] [ j - 1 ] ^ dp [ i - 1 ] [ j - 1 ] ^ mat [ i ] [ j ] ; med [ len ++ ] = dp [ i ] [ j ] ; } } sort ( med , med + len ) ; if ( len % 2 == 0 ) { return ( med [ ( len / 2 ) ] + med [ ( len / 2 ) - 1 ] ) / 2.0 ; } return med [ len / 2 ] ; }
int countTriplets ( vector < int > & A ) { int cnt = 0 ; unordered_map < int , int > tuples ; for ( auto a : A ) for ( auto b : A ) ++ tuples [ a & b ] ; for ( auto a : A ) for ( auto t : tuples ) if ( ( t . first & a ) == 0 ) cnt += t . second ; return cnt ; }
int countVowelPermutation ( int n ) { int MOD = ( int ) ( 1e9 + 7 ) ; long dp [ n + 1 ] [ 5 ] ; for ( int i = 0 ; i < 5 ; i ++ ) { dp [ 1 ] [ i ] = 1 ; } vector < vector < int > > relation = { { 1 } , { 0 , 2 } , { 0 , 1 , 3 , 4 } , { 2 , 4 } , { 0 } } ; for ( int i = 1 ; i < n ; i ++ ) { for ( int u = 0 ; u < 5 ; u ++ ) { dp [ i + 1 ] [ u ] = 0 ; for ( int v : relation [ u ] ) { dp [ i + 1 ] [ u ] += dp [ i ] [ v ] % MOD ; } } } long ans = 0 ; for ( int i = 0 ; i < 5 ; i ++ ) { ans = ( ans + dp [ n ] [ i ] ) % MOD ; } return ( int ) ans ; }
int MaximumSubarraySum ( int n , int * arr , int k ) { int dp [ M ] [ M ] ; memset ( dp , -1 , sizeof ( dp ) ) ; mxSubSum ( n - 1 , arr , k , dp ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= k ; j ++ ) { res = max ( res , dp [ i ] [ j ] ) ; } } if ( * max_element ( arr , arr + n ) < 0 ) { res = * max_element ( arr , arr + n ) ; } return res ; }
long countWaysToTileBoard ( long N ) { long dp [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) ; } cout << dp [ N ] ; }
void DFS ( int node , int parent , int Val [ ] ) { answer [ node ] = Val [ node ] ; for ( int child : adj [ node ] ) { if ( child == parent ) continue ; DFS ( child , node , Val ) ; answer [ node ] = ( answer [ node ] answer [ child ] ) ; } }
void preprocess ( int Val [ ] ) { DFS ( 1 , -1 , Val ) ; }
void findSubtreeOR ( int Queries [ ] , int Q , int Val [ ] ) { preprocess ( Val ) ; for ( int i = 0 ; i < Q ; i ++ ) { cout << answer [ Queries [ i ] ] << ' ' ; } }
void minCost ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int m = 2 * n ; int cost [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { cost [ i ] [ j ] = INF ; } } cost [ 0 ] [ 0 ] = 0 ; int prev = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { prev = cost [ i - 1 ] [ 0 ] ; for ( int j = 1 ; j <= m ; j ++ ) { cost [ i ] [ j ] = min ( cost [ i ] [ j ] , prev + abs ( j - arr [ i - 1 ] ) ) ; prev = min ( prev , cost [ i - 1 ] [ j ] ) ; } } int minCost = INF ; for ( int j = 1 ; j <= m ; j ++ ) { minCost = min ( minCost , cost [ n ] [ j ] ) ; } cout << minCost ; }
void FindSub ( string str , string res , int i ) { if ( i == str . length ( ) ) { if ( res . length ( ) > 0 ) { cout << res << " " ; } return ; } char ch = str [ i ] ; FindSub ( str , res , i + 1 ) ; FindSub ( str , res + ch , i + 1 ) ; FindSub ( str , res + to_string ( int ( ch ) ) , i + 1 ) ; }
int MinOp ( int N ) { if ( N <= 1 ) return N ; int bit = log2 ( N ) + 1 ; return ( ( 1 << bit ) - 1 ) - MinOp ( N - ( 1 << ( bit - 1 ) ) ) ; }
int max ( int a , int b ) { return a > b ? a : b ; }
int maximumsum ( int arr [ ] [ 4 ] , int K , int N , int M ) { int sum = 0 , maxSum ; int i , j , k ; int dp [ K + 1 ] [ N + 1 ] ; for ( i = 0 ; i <= N ; i ++ ) dp [ 0 ] [ i ] = 0 ; for ( i = 0 ; i <= K ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( i = 1 ; i <= K ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { sum = 0 ; maxSum = dp [ i ] [ j ] ; for ( k = 1 ; k <= M && k <= i ; k ++ ) { sum += arr [ j ] [ k - 1 ] ; maxSum = max ( maxSum , sum + dp [ i - k ] [ j ] ) ; } dp [ i ] [ j + 1 ] = maxSum ; } } return dp [ K ] [ N ] ; }
int check ( int memo [ ] [ N ] , int i , int j , int * A ) { if ( i == N - 1 ) return 1 ; if ( memo [ i ] [ j ] != -1 ) return memo [ i ] [ j ] ; int flag = 0 , k ; for ( k = i + 1 ; k < N ; k ++ ) { if ( A [ k ] - A [ i ] > j + 1 ) break ; if ( A [ k ] - A [ i ] >= j - 1 && A [ k ] - A [ i ] <= j + 1 ) flag = check ( memo , k , A [ k ] - A [ i ] , A ) ; if ( flag ) break ; } memo [ i ] [ j ] = flag ; return memo [ i ] [ j ] ; }
void checkEndReach ( int A [ ] , int K ) { int memo [ N ] [ N ] ; memset ( memo , -1 , sizeof ( memo ) ) ; int startIndex = 1 ; if ( check ( memo , startIndex , K , A ) ) cout << "Yes" ; else cout << "No" ; }
int maxProductPath ( vector < vector < int > > grid ) { int n = grid . size ( ) ; int m = grid [ 0 ] . size ( ) ; vector < vector < int > > maxPath ( n , vector < int > ( m , 0 ) ) ; vector < vector < int > > minPath ( n , vector < int > ( m , 0 ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int mn = INT_MAX ; int mx = INT_MIN ; if ( i == 0 and j == 0 ) { mx = grid [ i ] [ j ] ; mn = grid [ i ] [ j ] ; } if ( i > 0 ) { int tempmx = max ( ( maxPath [ i - 1 ] [ j ] * grid [ i ] [ j ] ) , ( minPath [ i - 1 ] [ j ] * grid [ i ] [ j ] ) ) ; mx = max ( mx , tempmx ) ; int tempmn = min ( ( maxPath [ i - 1 ] [ j ] * grid [ i ] [ j ] ) , ( minPath [ i - 1 ] [ j ] * grid [ i ] [ j ] ) ) ; mn = min ( mn , tempmn ) ; } if ( j > 0 ) { int tempmx = max ( ( maxPath [ i ] [ j - 1 ] * grid [ i ] [ j ] ) , ( minPath [ i ] [ j - 1 ] * grid [ i ] [ j ] ) ) ; mx = max ( mx , tempmx ) ; int tempmn = min ( ( maxPath [ i ] [ j - 1 ] * grid [ i ] [ j ] ) , ( minPath [ i ] [ j - 1 ] * grid [ i ] [ j ] ) ) ; mn = min ( mn , tempmn ) ; } maxPath [ i ] [ j ] = mx ; minPath [ i ] [ j ] = mn ; } } if ( maxPath [ n - 1 ] [ m - 1 ] < 0 ) return -1 ; else return ( maxPath [ n - 1 ] [ m - 1 ] ) ; }
void waysToArrangeKLengthStrings ( int N , int K ) { int column_sum [ N + 1 ] = { 0 } , i , j ; int dp [ K + 1 ] [ N + 1 ] = { 0 } ; for ( i = 0 ; i <= N ; i ++ ) { dp [ 0 ] [ i ] = 1 ; column_sum [ i ] = 1 ; } for ( i = 1 ; i <= K ; i ++ ) { for ( j = 1 ; j <= N ; j ++ ) { dp [ i ] [ j ] += column_sum [ j - 1 ] ; column_sum [ j ] += dp [ i ] [ j ] ; } } cout << dp [ K ] [ N ] ; }
int findNumberOfLIS ( vector < int > nums ) { if ( nums . size ( ) == 0 ) return 0 ; int n = nums . size ( ) ; vector < int > dp_l ( n , 1 ) ; vector < int > dp_c ( n , 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( nums [ i ] <= nums [ j ] ) continue ; if ( dp_l [ j ] + 1 > dp_l [ i ] ) { dp_l [ i ] = dp_l [ j ] + 1 ; dp_c [ i ] = dp_c [ j ] ; } else if ( dp_l [ j ] + 1 == dp_l [ i ] ) dp_c [ i ] += dp_c [ j ] ; } } int max_length = 0 ; for ( int i : dp_l ) max_length = max ( i , max_length ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp_l [ i ] == max_length ) count += dp_c [ i ] ; } return count ; }
int countPenality ( int arr [ ] , int N ) { int pos = 0 ; int turn = 0 ; return findMinimum ( arr , N , pos , turn ) ; }
void printAnswer ( int * arr , int N ) { int a = countPenality ( arr , N ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } cout << a ; }
int removeSmallestSubarray ( int arr [ ] , int S , int n , int k ) { int target_remainder = S % k ; unordered_map < int , int > map1 ; map1 [ 0 ] = -1 ; int curr_remainder = 0 ; int res = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { curr_remainder = ( curr_remainder + arr [ i ] + k ) % k ; map1 [ curr_remainder ] = i ; int mod = ( curr_remainder - target_remainder + k ) % k ; if ( map1 . find ( mod ) != map1 . end ( ) ) { res = min ( res , i - map1 [ mod ] ) ; } } if ( res == INT_MAX res == n ) { res = -1 ; } return res ; }
int smstSubmatDeleted ( vector < vector < int > > & mat , int N , int M , int K ) { int S = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) S += mat [ i ] [ j ] ; } int min_area = N * M ; int left = 0 ; int right = 0 ; int width ; int area ; int prefixRowSum [ N ] ; for ( left = 0 ; left < M ; left ++ ) { memset ( prefixRowSum , 0 , sizeof ( prefixRowSum ) ) ; for ( right = left ; right < M ; right ++ ) { for ( int i = 0 ; i < N ; i ++ ) { prefixRowSum [ i ] += mat [ i ] [ right ] ; } width = removeSmallestSubarray ( prefixRowSum , S , N , K ) ; if ( width != -1 ) { area = ( right - left + 1 ) * ( width ) ; if ( area < min_area ) { min_area = area ; } } } } return min_area ; }
int countstrings ( int n , int start ) { if ( n == 0 ) { return 1 ; } int cnt = 0 ; for ( int i = start ; i < 5 ; i ++ ) { cnt += countstrings ( n - 1 , i ) ; } return cnt ; }
int findNumberOfStrings ( int n ) { vector < vector < int > > DP ( n + 1 , vector < int > ( 6 ) ) ; DP [ 1 ] [ 1 ] = 1 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < 6 ; j ++ ) { if ( i == 1 ) { DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + 1 ; } else { DP [ i ] [ j ] = DP [ i ] [ j - 1 ] + DP [ i - 1 ] [ j ] ; } } } return DP [ n ] [ 5 ] ; }
int findNumberOfStrings ( int n ) { return ( n + 1 ) * ( n + 2 ) * ( n + 3 ) * ( n + 4 ) / 24 ; }
int check ( int sum , int x , int y ) { while ( sum > 0 ) { int ln = sum % 10 ; if ( ln != x && ln != y ) { return 0 ; } sum /= 10 ; } return 1 ; }
int countNumbers ( int n , int x , int y , int sum ) { memset ( dp , -1 , sizeof ( dp ) ) ; if ( n == 0 ) { return check ( sum , x , y ) ; } if ( dp [ n ] [ sum ] != -1 ) { return dp [ n ] [ sum ] % mod ; } int option1 = countNumbers ( n - 1 , x , y , sum + x ) % mod ; int option2 = countNumbers ( n - 1 , x , y , sum + y ) % mod ; return dp [ n ] [ sum ] = ( option1 + option2 ) % mod ; }
ll findTotalPath ( int X , int n , vector < int > & dp ) { if ( X == 0 ) { return 1 ; } ll ans = 0 ; if ( dp [ X ] != -1 ) { return dp [ X ] ; } for ( int i = 1 ; i <= min ( X , n ) ; ++ i ) { ans += findTotalPath ( X - i , n , dp ) % mod ; ans %= mod ; } return dp [ X ] = ans ; }
void printAnswer ( int n , int edges [ V ] [ M ] , int values [ ] ) { vector < int > adj [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int u = edges [ i ] [ 0 ] - 1 ; int v = edges [ i ] [ 1 ] - 1 ; adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } int ans [ n ] ; dfs ( 0 , -1 , adj , ans , values ) ; for ( auto x : ans ) { cout << x << " " ; } }
bool checkEvenOddLevel ( Node * root ) { if ( root == NULL ) return true ; queue < Node * > q ; q . push ( root ) ; int level = 0 ; while ( q . empty ( ) ) { vector < int > vec ; int size = q . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { Node * node = q . front ( ) ; vec . push_back ( node -> val ) ; if ( node -> left != NULL ) q . push ( node -> left ) ; if ( node -> right != NULL ) q . push ( node -> right ) ; } if ( level % 2 == 0 ) { for ( int i = 0 ; i < vec . size ( ) - 1 ; i ++ ) { if ( vec [ i + 1 ] > vec [ i ] ) continue ; return false ; } } else if ( level % 2 == 1 ) { for ( int i = 0 ; i < vec . size ( ) - 1 ; i ++ ) { if ( vec [ i + 1 ] < vec [ i ] ) continue ; return false ; } } level ++ ; } return true ; }
void build ( int dp [ ] , int arr [ ] , int N ) { dp [ 0 ] = 0 ; dp [ 1 ] = 0 ; vector < int > prime = SieveOfEratosthenes ( ) ; int pref [ N + 1 ] ; pref [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { pref [ i ] = pref [ i - 1 ] + arr [ i - 1 ] ; } for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; for ( int j = 0 ; j <= prime . size ( ) ; j ++ ) { int r = i - 1 ; int l = r - prime [ j ] + 1 ; if ( l < 0 ) break ; int temp = 0 ; temp = pref [ r + 1 ] - pref [ l ] ; if ( l - 2 >= 0 ) temp += dp [ l - 2 + 1 ] ; dp [ i ] = max ( dp [ i ] , temp ) ; } } }
void maxSumSubseq ( int arr [ ] , int N ) { int dp [ N + 1 ] ; build ( dp , arr , N ) ; cout << dp [ N ] ; }
int MinRunLengthEncoding ( string & s , int n , int k ) { memset ( dp , -1 , sizeof ( dp ) ) ; return solve ( s , n , 0 , k ) ; }
int minimumCost ( int * A , int * B , int M , int N , int C ) { int nums [ 1000000 ] ; int index [ 1000000 ] ; memset ( index , -1 , sizeof ( index ) ) ; for ( int i = 0 ; i < N ; i ++ ) { index [ B [ i ] ] = i ; } int k = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( index [ A [ i ] ] != -1 ) { nums [ k ++ ] = index [ A [ i ] ] ; } } int lcs_length = findLCS ( nums , k ) ; int elements_to_be_added = N - lcs_length ; int min_cost = elements_to_be_added * C ; cout << min_cost ; }
int numberOfPermWithKInversion ( int N , int K ) { int dp [ 2 ] [ K + 1 ] ; int mod = 1000000007 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= K ; j ++ ) { if ( i == 1 ) dp [ i % 2 ] [ j ] = ( j == 0 ) ; else if ( j == 0 ) dp [ i % 2 ] [ j ] = 1 ; else dp [ i % 2 ] [ j ] = ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( ( max ( j - ( i - 1 ) , 0 ) == 0 ) ? 0 : dp [ 1 - i % 2 ] [ max ( j - ( i - 1 ) , 0 ) - 1 ] ) + mod ) % mod ) % mod ; ; } } cout << dp [ N % 2 ] [ K ] ; }
int maxScore ( vector < int > & arr ) { int N = arr . size ( ) ; N ++ ; vector < vector < int > > dp ( N + 1 , vector < int > ( 2 * N , -100000 ) ) ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int s = 1 ; s <= 2 * ( N - 1 ) ; s ++ ) { for ( int j = 1 ; j <= N - 1 and j <= s ; j ++ ) { dp [ i ] [ s ] = max ( dp [ i ] [ s ] , arr [ j - 1 ] + dp [ i - 1 ] [ s - j ] ) ; } } } return dp [ N ] [ 2 * ( N - 1 ) ] ; }
void minimumCost ( int * cost , int n , int x ) { vector < int > dp ( n + 2 , 0 ) ; dp [ 0 ] = cost [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( i == 1 ) dp [ i ] = cost [ i ] + dp [ i - 1 ] ; if ( i == 2 ) dp [ i ] = cost [ i ] + min ( dp [ i - 1 ] , x + dp [ i - 2 ] ) ; if ( i >= 3 ) dp [ i ] = cost [ i ] + min ( dp [ i - 1 ] , min ( x + dp [ i - 2 ] , 2 * x + dp [ i - 3 ] ) ) ; } cout << dp [ n - 1 ] ; }
int maxSum ( int a [ ] , int n , int k ) { if ( n <= 0 ) return 0 ; int option = maxSum ( a , n - 1 , k ) ; if ( k >= a [ n - 1 ] ) option = max ( option , a [ n - 1 ] + maxSum ( a , n - 2 , k - a [ n - 1 ] ) ) ; return option ; }
bool checkStr ( string str , int P , int Q ) { int N = str . size ( ) ; char prev = str [ 0 ] ; int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == prev ) { cnt ++ ; } else { if ( prev == '1' && cnt >= Q ) { return false ; } if ( prev == '0' && cnt >= P ) { return false ; } cnt = 1 ; } prev = str [ i ] ; } if ( prev == '1' && cnt >= Q ) { return false ; } if ( prev == '0' && cnt >= P ) { return false ; } return true ; }
int cntBinStr ( string str , int N , int P , int Q ) { int len = str . size ( ) ; if ( len == N ) { if ( checkStr ( str , P , Q ) ) return 1 ; return 0 ; } int X = cntBinStr ( str + '0' , N , P , Q ) ; int Y = cntBinStr ( str + '1' , N , P , Q ) ; return X + Y ; }
int maxCount ( vector < int > arr , int m , int V ) { vector < int > table ( V + 1 ) ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = -1 ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ j ] <= i ) { int sub_res = table [ i - arr [ j ] ] ; if ( sub_res != -1 && sub_res + 1 > table [ i ] ) table [ i ] = sub_res + 1 ; } } } return table [ V ] ; }
int binCoff ( int N , int R ) { int res = 1 ; if ( R > ( N - R ) ) { R = ( N - R ) ; } for ( int i = 0 ; i < R ; i ++ ) { res *= ( N - i ) ; res /= ( i + 1 ) ; } return res ; }
int cntPermutation ( int N ) { int cntPerm ; int C_2N_N = binCoff ( 2 * N , N ) ; cntPerm = C_2N_N / ( N + 1 ) ; return cntPerm ; }
int solve ( vector < vector < int > > a , string s , int n , int prev , int mask , vector < vector < int > > dp ) { if ( mask == 0 ) return 0 ; if ( dp [ mask ] [ prev + 1 ] != -1 ) return dp [ mask ] [ prev + 1 ] ; int ans = 10000 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int id = s [ i ] - 'a' ; if ( check ( mask , id ) ) { if ( prev == -1 ) { ans = min ( ans , solve ( a , s , n , id , mask ^ ( 1 << id ) , dp ) ) ; } else { ans = min ( ans , a [ prev ] [ id ] + solve ( a , s , n , id , mask ^ ( 1 << id ) , dp ) ) ; } } } dp [ mask ] [ prev + 1 ] = ans ; return ans ; }
int longestPalSubstr ( string str ) { int n = str . size ( ) ; int maxLength = 1 , start = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { for ( int j = i ; j < str . length ( ) ; j ++ ) { int flag = 1 ; for ( int k = 0 ; k < ( j - i + 1 ) / 2 ; k ++ ) if ( str [ i + k ] != str [ j - k ] ) flag = 0 ; if ( flag && ( j - i + 1 ) > maxLength ) { start = i ; maxLength = j - i + 1 ; } } } return maxLength ; }
long mElementsWithMaxSum ( vector < vector < int > > matrix , int M , int block , vector < vector < int > > dp ) { if ( block == matrix . size ( ) ) return 0 ; if ( dp [ block ] [ M ] != -1 ) return dp [ block ] [ M ] ; long ans = mElementsWithMaxSum ( matrix , M , block + 1 , dp ) ; for ( int i = 0 ; i < matrix [ block ] . size ( ) ; i ++ ) { for ( int j = i ; j < matrix [ block ] . size ( ) ; j ++ ) { if ( j - i + 1 <= M ) { ans = max ( ans , matrix [ block ] [ j ] - ( ( i - 1 ) >= 0 ? matrix [ block ] [ i - 1 ] : 0 ) + mElementsWithMaxSum ( matrix , M - j + i - 1 , block + 1 , dp ) ) ; } } } return dp [ block ] [ M ] = ans ; }
void preComputing ( vector < vector < int > > matrix , int N ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < matrix [ i ] . size ( ) ; j ++ ) { matrix [ i ] [ j ] = ( j > 0 ? matrix [ i ] [ j - 1 ] : 0 ) + matrix [ i ] [ j ] ; } } }
void mElementsWithMaxSumUtil ( vector < vector < int > > matrix , int M , int N ) { preComputing ( matrix , N ) ; long sum = 10 ; vector < vector < int > > dp ; dp . resize ( N + 5 ) ; for ( int i = 0 ; i < N + 5 ; i ++ ) for ( int j = 0 ; j < M + 5 ; j ++ ) dp [ i ] . push_back ( -1 ) ; sum += mElementsWithMaxSum ( matrix , M , 0 , dp ) ; cout << sum ; }
int lastRemaining ( int n , map < int , int > & dp ) { if ( dp . find ( n ) != dp . end ( ) ) return dp [ n ] ; if ( n == 1 ) return 1 ; else dp [ n ] = 2 * ( 1 + n / 2 - lastRemaining ( n / 2 , dp ) ) ; return dp [ n ] ; }
int Max_Sum ( int arr [ ] , int K , int N ) { int dp [ N + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; int prefix [ N + 1 ] ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } dp [ 0 ] = 0 ; for ( int i = 1 ; i < K ; i ++ ) { dp [ i ] = prefix [ i ] ; } for ( int i = K ; i <= N ; ++ i ) { for ( int j = i ; j >= ( i - K + 1 ) ; j -- ) { dp [ i ] = max ( dp [ i ] , dp [ j - 1 ] + prefix [ i ] - prefix [ j ] ) ; } } return dp [ N ] ; }
int binomialCoeff ( int n , int k ) { int C [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
int waysToSplitN ( int k , int n , int P ) { int new_N = n - k * P ; return binomialCoeff ( new_N + k - 1 , new_N ) ; }
int maximumSumUtil ( int a [ ] , int index , int count , int n ) { if ( index > n count > n + 1 ) { return 0 ; } if ( dp [ index ] [ count ] != -1 ) return dp [ index ] [ count ] ; int ans1 = maximumSumUtil ( a , index + 1 , count + 1 , n ) + a [ index ] * count ; int ans2 = maximumSumUtil ( a , index + 1 , count , n ) ; return ( dp [ index ] [ count ] = max ( ans1 , ans2 ) ) ; }
int maximumSum ( int arr [ ] , int N ) { memset ( dp , -1 , sizeof ( dp ) ) ; cout << maximumSumUtil ( arr , 0 , 1 , N - 1 ) ; }
void Calculate_factorial ( ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i <= mx ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; fact [ i ] %= mod ; } }
int UniModal_per ( int a , int b ) { long long int res = 1 ; while ( b ) { if ( b % 2 ) res = res * a ; res %= mod ; a = a * a ; a %= mod ; b /= 2 ; } return res ; }
void countPermutations ( int n ) { Calculate_factorial ( ) ; int uni_modal = UniModal_per ( 2 , n - 1 ) ; int nonuni_modal = fact [ n ] - uni_modal ; cout << uni_modal << " " << nonuni_modal ; return ; }
void countMinCoinsUtil ( int X , int C [ ] , int N ) { memset ( dp , -1 , sizeof ( dp ) ) ; int isPossible = countMinCoins ( X , C , N ) ; if ( isPossible == INT_MAX ) { cout << "-1" ; } else { findSolution ( X , C , N ) ; } }
int helper ( int arr [ ] , int left , int right , int count , int m ) { if ( left > right ) return 0 ; if ( dp [ left ] [ right ] [ count ] != -1 ) { return dp [ left ] [ right ] [ count ] ; } int ans = ( count + 1 ) * m + helper ( arr , left + 1 , right , 0 , m ) ; for ( int i = left + 1 ; i <= right ; ++ i ) { if ( arr [ i ] == arr [ left ] ) { ans = max ( ans , helper ( arr , left + 1 , i - 1 , 0 , m ) + helper ( arr , i , right , count + 1 , m ) ) ; } } dp [ left ] [ right ] [ count ] = ans ; return ans ; }
int maxPoints ( int arr [ ] , int n , int m ) { int len = n ; memset ( dp , -1 , sizeof ( dp ) ) ; return helper ( arr , 0 , len - 1 , 0 , m ) ; }
int findWays ( int N ) { if ( N == 0 ) { return 1 ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i ) ; } } return cnt ; }
int findWays ( int N , int dp [ ] ) { if ( N == 0 ) { return 1 ; } if ( dp [ N ] != -1 ) { return dp [ N ] ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i , dp ) ; } } return dp [ N ] = cnt ; }
void findWays ( int N ) { int dp [ N + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } cout << dp [ N ] ; }
int findWays ( int n ) { n -- ; int a , b , ans ; a = binCoff ( 2 * n , n ) ; b = a / ( n + 1 ) ; ans = b ; return ans ; }
vector < int > find_sequence ( int n ) { if ( n == 1 ) return { 1 , -1 } ; auto arr = find_sequence ( n - 1 ) ; vector < int > ans = { arr [ 0 ] + 1 , n - 1 } ; if ( n % 2 == 0 ) { vector < int > div_by_2 = find_sequence ( n / 2 ) ; if ( div_by_2 [ 0 ] < ans [ 0 ] ) ans = { div_by_2 [ 0 ] + 1 , n / 2 } ; } if ( n % 3 == 0 ) { vector < int > div_by_3 = find_sequence ( n / 3 ) ; if ( div_by_3 [ 0 ] < ans [ 0 ] ) vector < int >  ans =  { div_by_3 [ 0 ] + 1 , n / 3 } ; } return ans ; }
int FindNoOfFullVessels ( int n , int t ) { double Matrix [ n ] [ n ] ; Matrix [ 0 ] [ 0 ] = t * 1.0 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { double exceededwater = Matrix [ i ] [ j ] - 1.0 ; if ( exceededwater < 0 ) continue ; ans ++ ; if ( i + 1 < n ) Matrix [ i + 1 ] [ j ] += exceededwater / 2 ; if ( i + 1 < n && j + 1 < n ) Matrix [ i + 1 ] [ j + 1 ] += exceededwater / 2 ; } } return ans ; }
int minCountOfNumbers ( int N ) { int k = N % 10 ; int z = N - ( 9 * ( 9 - k ) ) ; if ( z >= 9 && z % 10 == 9 ) { return 10 - k ; } else return -1 ; }
int checkEqualSumUtil ( int arr [ ] , int N , int sm1 , int sm2 , int sm3 , int j ) { if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } else { int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; return max ( max ( l , m ) , r ) ; } }
int checkEqualSumUtil ( int arr [ ] , int N , int sm1 , int sm2 , int sm3 , int j ) { string s = to_string ( sm1 ) + "_" + to_string ( sm2 ) + to_string ( j ) ; if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } if ( dp . find ( s ) != dp . end ( ) ) return dp [ s ] ; else { int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; return dp [ s ] = max ( max ( l , m ) , r ) ; } }
void checkEqualSum ( int arr [ ] , int N ) { int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { cout << "Yes" ; } else { cout << "No" ; } }
void manipulation ( vector < vector < int > > & matrix , vector < int > & q ) { int x1 = q [ 0 ] , y1 = q [ 1 ] , x2 = q [ 2 ] , y2 = q [ 3 ] ; for ( int i = x1 - 1 ; i < x2 ; i ++ ) { for ( int j = y1 - 1 ; j < y2 ; j ++ ) { if ( matrix [ i ] [ j ] == 1 ) matrix [ i ] [ j ] = 0 ; else matrix [ i ] [ j ] = 1 ; } } }
int solve ( string s , string t ) { int n = s . size ( ) ; int r = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; if ( i > 0 ) { dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j ] ) ; } if ( s [ i ] == t [ j ] ) { int ans = 1 ; if ( i > 0 && j > 0 ) { ans = 1 + dp [ i - 1 ] [ j - 1 ] ; } dp [ i ] [ j ] = max ( dp [ i ] [ j ] , ans ) ; r = max ( r , dp [ i ] [ j ] ) ; } } } return ( n - r ) ; }
int min_op ( int cur , int M ) { if ( cur > M ) return INF ; if ( cur == M ) return 0 ; int op = INF ; for ( int i = 2 ; i * i <= cur ; i ++ ) { if ( cur % i == 0 ) { if ( i % 2 == 0 ) { op = min ( op , 1 + min_op ( cur + i , M ) ) ; } if ( ( cur / i ) != i && ( cur / i ) % 2 == 0 ) { op = min ( op , 1 + min_op ( cur + ( cur / i ) , M ) ) ; } } } return op ; }
int min_op ( int cur , int M ) { if ( cur > M ) return INF ; if ( cur == M ) return 0 ; if ( dp [ cur ] != -1 ) return dp [ cur ] ; int op = INF ; for ( int i = 2 ; i * i <= cur ; i ++ ) { if ( cur % i == 0 ) { if ( i % 2 == 0 ) { op = min ( op , 1 + min_op ( cur + i , M ) ) ; } if ( ( cur / i ) != i && ( cur / i ) % 2 == 0 ) { op = min ( op , 1 + min_op ( cur + ( cur / i ) , M ) ) ; } } } return dp [ cur ] = op ; }
int min_operations ( int N , int M ) { for ( int i = N ; i <= M ; i ++ ) { dp [ i ] = -1 ; } return min_op ( N , M ) ; }
int solve ( vector < int > & a ) { int n = a . size ( ) ; vector < int > dp ( n + 1 , 0 ) , val ( n + 1 , 0 ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { long long sum = a [ i ] ; int j = i ; while ( j + 1 < n and sum < val [ j + 1 ] ) { j ++ ; sum += a [ j ] ; } dp [ i ] = ( j - i ) + dp [ j + 1 ] ; val [ i ] = sum ; } return dp [ 0 ] ; }
vector < int > findPrimeFactors ( int n ) { vector < int > primeFactors ( 9 , 0 ) ; int j = 0 ; if ( n % 2 == 0 ) { primeFactors [ j ++ ] = 2 ; while ( n % 2 == 0 ) n >>= 1 ; } for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) { primeFactors [ j ++ ] = i ; while ( n % i == 0 ) n /= i ; } } if ( n > 2 ) primeFactors [ j ++ ] = n ; vector < int > PrimeFactors ( j ) ; for ( int i = 0 ; i < j ; i ++ ) { PrimeFactors [ i ] = primeFactors [ i ] ; } return PrimeFactors ; }
void findShortestSubsequence ( vector < int > & dp , vector < int > a , int index , vector < int > primeFactors ) { int n = a . size ( ) ; for ( int j = index ; j < n ; j ++ ) { int bitmask = 0 ; for ( int p = 0 ; p < primeFactors . size ( ) ; p ++ ) { if ( ( a [ j ] % primeFactors [ p ] ) == 0 ) { bitmask ^= ( 1 << p ) ; } } for ( int i = 0 ; i < dp . size ( ) ; i ++ ) { if ( dp [ i ] == n + 1 ) continue ; dp [ bitmask & i ] = min ( dp [ bitmask & i ] , dp [ i ] + 1 ) ; } } }
int minDays ( int n ) { if ( n < 1 ) return n ; int cnt = 1 + min ( n % 2 + minDays ( n / 2 ) , n % 3 + minDays ( n / 3 ) ) ; return cnt ; }
int count ( int n ) { map < int , int > dp ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; if ( ( dp . find ( n ) == dp . end ( ) ) ) dp [ n ] = 1 + min ( n % 2 + count ( n / 2 ) , n % 3 + count ( n / 3 ) ) ; return dp [ n ] ; }
int findMaxTimes ( string S ) { long long int arr [ 26 ] ; long long int dp [ 26 ] [ 26 ] ; memset ( arr , 0 , sizeof ( arr ) ) ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < S . size ( ) ; i ++ ) { int now = S [ i ] - 'a' ; for ( int j = 0 ; j < 26 ; j ++ ) { dp [ j ] [ now ] += arr [ j ] ; } arr [ now ] ++ ; } long long int ans = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) ans = max ( ans , arr [ i ] ) ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { ans = max ( ans , dp [ i ] [ j ] ) ; } } return ans ; }
int xorSum ( int a [ ] , int n , int mask , int dp [ ] ) { if ( dp [ mask ] != -1 ) { return dp [ mask ] ; } int max_value = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( i != j && ( mask & ( 1 << i ) ) == 0 && ( mask & ( 1 << j ) ) == 0 ) { max_value = max ( max_value , ( a [ i ] ^ a [ j ] ) + xorSum ( a , n , ( mask | ( 1 << i ) | ( 1 << j ) ) , dp ) ) ; } } } return dp [ mask ] = max_value ; }
int maxValue ( int a [ ] , int n , int pos , int moves , int left , int dp [ ] [ k + 1 ] ) { if ( moves == 0 || ( pos > n - 1 pos < 0 ) ) return 0 ; if ( dp [ pos ] [ left ] != -1 ) return dp [ pos ] [ left ] ; int value = 0 ; if ( left > 0 && pos >= 1 ) value = max ( value , a [ pos ] + maxValue ( a , n , pos - 1 , moves - 1 , left - 1 , dp ) ) ; if ( pos <= n - 1 ) value = max ( value , a [ pos ] + maxValue ( a , n , pos + 1 , moves - 1 , left , dp ) ) ; return dp [ pos ] [ left ] = value ; }
int maximumSum ( int a [ ] , int count , int index , int n , int dp [ N ] [ N ] ) { if ( index == n ) return 0 ; if ( dp [ index ] [ count ] != -1 ) return dp [ index ] [ count ] ; int take_element = a [ index ] * count + maximumSum ( a , count + 1 , index + 1 , n , dp ) ; int dont_take = maximumSum ( a , count , index + 1 , n , dp ) ; return dp [ index ] [ count ] = max ( take_element , dont_take ) ; }
void fibonacci ( ) { fib [ 1 ] = 1 ; fib [ 2 ] = 2 ; for ( int i = 3 ; i <= 87 ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } }
int find ( int num ) { int cnt = 0 ; for ( int i = 87 ; i > 0 ; i -- ) { if ( num >= fib [ i ] ) { v [ cnt ++ ] = i ; num -= fib [ i ] ; } } reverse ( v , v + cnt ) ; dp1 [ 0 ] = 1 ; dp2 [ 0 ] = ( v [ 0 ] - 1 ) / 2 ; for ( int i = 1 ; i < cnt ; i ++ ) { dp1 [ i ] = dp1 [ i - 1 ] + dp2 [ i - 1 ] ; dp2 [ i ] = ( ( v [ i ] - v [ i - 1 ] ) / 2 ) * dp2 [ i - 1 ] + ( ( v [ i ] - v [ i - 1 ] - 1 ) / 2 ) * dp1 [ i - 1 ] ; } return ( dp1 [ cnt - 1 ] + dp2 [ cnt - 1 ] ) ; }
vector < int > preprocess ( vector < int > a , int n ) { vector < int > p ( n ) ; p [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { p [ i ] = p [ i - 1 ] + a [ i ] ; } return p ; }
int Combine ( vector < int > p , int i , int j ) { if ( i == 0 ) return p [ j ] ; else return p [ j ] - p [ i - 1 ] ; }
int minCost ( vector < int > a , int i , int j , int k , vector < int > prefix , vector < vector < int > > dp ) { if ( i >= j ) return 0 ; if ( dp [ i ] [ j ] != -1 ) return dp [ i ] [ j ] ; int best_cost = inf ; for ( int pos = i ; pos < j ; pos ++ ) { int left = minCost ( a , i , pos , k , prefix , dp ) ; int right = minCost ( a , pos + 1 , j , k , prefix , dp ) ; best_cost = min ( best_cost , left + right + ( k * Combine ( prefix , i , j ) ) ) ; } return dp [ i ] [ j ] = best_cost ; }
void countNums ( int N ) { int l = ( int ) pow ( 10 , N - 1 ) ; int r = ( int ) pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int xorr = 0 , temp = i ; while ( temp > 0 ) { xorr = xorr ^ ( temp % 10 ) ; temp /= 10 ; } if ( xorr <= 9 ) count ++ ; } cout << count ; }
int distinctSimilarSubstrings ( string str ) { int n = str . size ( ) ; if ( n <= 1 ) { return 0 ; } vector < vector < int > > dp ( n + 1 , vector < int > ( n + 1 , 0 ) ) ; unordered_set < string > substrings ; for ( int j = n - 1 ; j >= 0 ; j -- ) { for ( int i = j - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == str [ j ] ) { dp [ i ] [ j ] = dp [ i + 1 ] [ j + 1 ] + 1 ; } else { dp [ i ] [ j ] = 0 ; } if ( dp [ i ] [ j ] >= j - i ) { substrings . insert ( str . substr ( i , j - i ) ) ; } } } return substrings . size ( ) ; }
void SubarrayWithMaxSum ( vector < int > & nums ) { int endIndex , currMax = nums [ 0 ] ; int globalMax = nums [ 0 ] ; for ( int i = 1 ; i < nums . size ( ) ; ++ i ) { currMax = max ( nums [ i ] , nums [ i ] + currMax ) ; if ( currMax > globalMax ) { globalMax = currMax ; endIndex = i ; } } int startIndex = endIndex ; while ( startIndex >= 0 ) { globalMax -= nums [ startIndex ] ; if ( globalMax == 0 ) break ; startIndex -- ; } for ( int i = startIndex ; i <= endIndex ; ++ i ) { cout << nums [ i ] << " " ; } }
int count ( int a [ ] , int M , int N ) { int cnt = 0 ; for ( int i = 1 ; i <= M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i % a [ j ] == 0 ) { cnt ++ ; break ; } } } return cnt ; }
void sieve ( ) { bool mark [ M ] ; for ( int i = 0 ; i < M ; i ++ ) mark [ i ] = false ; for ( int i = 2 ; i < M ; i ++ ) mark [ i ] = true ; for ( int i = 2 ; i * i < M ; i ++ ) { if ( mark [ i ] ) { for ( int j = i * i ; j < M ; j += i ) mark [ j ] = false ; } } for ( int i = 2 ; i < M ; i ++ ) if ( mark [ i ] ) primes . push_back ( i ) ; }
void countPrimonacci ( int l , int r ) { vector < int > dp ; dp . push_back ( 1 ) ; dp . push_back ( 1 ) ; int i = 2 ; set < int > s ; while ( true ) { int x = 0 ; for ( int j = 0 ; j < primes . size ( ) ; j ++ ) { int p = primes [ j ] ; if ( p >= i ) break ; x += dp [ i - p ] ; } if ( x >= l && x <= r ) s . insert ( x ) ; if ( x > r ) break ; dp . push_back ( x ) ; i ++ ; } cout << s . size ( ) ; }
long minSum ( int n , int num [ ] , int price [ ] ) { long dp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = INT_MAX ; long ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( num [ j ] > num [ i ] ) { dp [ j ] = ( long ) min ( ( long ) dp [ j ] , ( long ) price [ i ] + ( long ) price [ j ] ) ; ans = min ( ans , ( long ) dp [ i ] + ( long ) price [ j ] ) ; } } } return ans != INT_MAX ? ans : -1 ; }
void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; }
int getSumUtil ( int * st , int ss , int se , int qs , int qe , int si ) { if ( qs <= ss && qe >= se ) return st [ si ] ; if ( se < qs ss > qe ) return 0 ; int mid = getMid ( ss , se )  ; return getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ; }
void updateValueUtil ( int * st , int ss , int se , int i , int diff , int si ) { if ( i < ss i > se ) return ; st [ si ] = st [ si ] + diff  ; if ( se != ss ) { int mid = getMid ( ss , se ) ; updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) ; updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) ; } }
void updateValue ( int arr [ ] , int * st , int n , int i , int new_val ) { if ( i < 0 i > n  - 1 ) { cout << "-1" ; return ; } int diff = new_val - arr [ i ] ; int prev_val = arr [ i ] ; arr [ i ] = new_val ; if ( prime [ new_val ] prime [ prev_val ] ) { if ( ! prime [ prev_val ] ) updateValueUtil ( st , 0 , n - 1 , i , new_val , 0 ) ; else if ( ! prime [ new_val ] ) updateValueUtil ( st , 0 , n - 1 , i , - prev_val , 0 ) ; else updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) ; } }
int getSum ( int * st , int n , int qs , int qe ) { if ( qs < 0 qe > n  - 1 qs > qe ) { cout << "-1" ; return -1 ; } return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) ; }
unsigned long int countStrings ( unsigned int N ) { if ( N % 2 == 1 ) return 0 ; else { N /= 2 ; unsigned long int c = binomialCoeff ( 2 * N , N ) ; return c / ( N + 1 ) ; } }
int solve ( int n , int k , int mod , int dp [ ] ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != -1 ) return dp [ n ] ; int cnt = 0 ; for ( int i = 2 ; i <= k ; i += 2 ) { cnt = ( cnt % mod + solve ( n - i , k , mod , dp ) % mod ) % mod ; } dp [ n ] = cnt ; return cnt ; }
void fact ( ) { f [ 0 ] = f [ 1 ] = 1 ; for ( int i = 2 ; i <= 10 ; i ++ ) f [ i ] = i * 1LL * f [ i - 1 ] ; }
void dfs2 ( int a , int par ) { for ( auto & i : v [ a ] ) { if ( i . first == par ) continue ; int leafOutside = leaves [ a ] - leaves [ i . first ] ; dp [ i . first ] += ( dp [ a ] - dp [ i . first ] ) ; dp [ i . first ] += i . second * ( leafOutside - leaves [ i . first ] ) ; leaves [ i . first ] += leafOutside ; dfs2 ( i . first , a ) ; } }
int countPairs ( struct Node * first , struct Node * second , int value ) { int count = 0 ; while ( first != NULL && second != NULL && first != second && second -> next != first ) { if ( ( first -> data + second -> data ) == value ) { count ++ ; first = first -> next ; second = second -> prev ; } else if ( ( first -> data + second -> data ) > value ) second = second -> prev ; else first = first -> next ; } return count ; }
int countTriplets ( struct Node * head , int x ) { if ( head == NULL ) return 0 ; struct Node * current , * first , * last ; int count = 0 ; last = head ; while ( last -> next != NULL ) last = last -> next ; for ( current = head ; current != NULL ; current = current -> next ) { first = current -> next ; count += countPairs ( first , last , x - current -> data ) ; } return count ; }
int countChanges ( int matrix [ ] [ N ] , int n , int m ) { int dist = n + m - 1 ; int Max_element = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { Max_element = max ( Max_element , matrix [ i ] [ j ] ) ; } } int freq [ dist ] [ Max_element + 1 ] ; for ( int i = 0 ; i < dist ; i ++ ) { for ( int j = 0 ; j < Max_element + 1 ; j ++ ) freq [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { freq [ i + j ] [ matrix [ i ] [ j ] ] ++ ; } } int min_changes_sum = 0 ; for ( int i = 0 ; i < dist / 2 ; i ++ ) { int maximum = 0 ; int total_values = 0 ; for ( int j = 0 ; j < Max_element + 1 ; j ++ ) { maximum = max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; total_values += freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ; } min_changes_sum += total_values - maximum ; } return min_changes_sum ; }
void maxLength ( int arr [ ] , int n ) { vector < int > dp ( n , 1 ) ; for ( int i = n - 1 ; i > 1 ; i -- ) { for ( int j = 1 ; j <= sqrt ( i ) ; j ++ ) { if ( i % j == 0 ) { int s = i / j ; if ( s == j ) { if ( arr [ i ] > arr [ s ] ) { dp [ s ] = max ( dp [ i ] + 1 , dp [ s ] ) ; } } else { if ( s != i && arr [ i ] > arr [ s ] ) dp [ s ] = max ( dp [ i ] + 1 , dp [ s ] ) ; if ( arr [ i ] > arr [ j ] ) { dp [ j ] = max ( dp [ i ] + 1 , dp [ j ] ) ; } } } } } int max = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( dp [ i ] > max ) max = dp [ i ] ; } cout << max << "\n" ; }
int maxProfit ( int price [ ] , int n ) { int buy1 , profit1 , buy2 , profit2 ; buy1 = buy2 = INT_MAX ; profit1 = profit2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { buy1 = min ( buy1 , price [ i ] ) ; profit1 = max ( profit1 , price [ i ] - buy1 ) ; buy2 = min ( buy2 , price [ i ] - profit1 ) ; profit2 = max ( profit2 , price [ i ] - buy2 ) ; } return profit2 ; }
int validsubsequences ( int arr [ ] , int n ) { long long int dp [ n + 1 ] [ 2 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] [ 0 ] = 0 ; dp [ i ] [ 1 ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 ) { dp [ i ] [ 1 ] += 1 ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 0 ] ; } else { dp [ i ] [ 0 ] += 1 ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 1 ] ; } } return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ; }
long long getCount ( int n , int k ) { if ( n == 1 ) return 10 ; long long dp [ n + 1 ] [ 11 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j < 11 ; j ++ ) dp [ i ] [ j ] = 0 ; } for ( int i = 1 ; i <= 9 ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { int l = max ( 0 , j - k ) ; int r = min ( 9 , j + k ) ; dp [ i ] [ l ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ r + 1 ] -= dp [ i - 1 ] [ j ] ; } for ( int j = 1 ; j <= 9 ; j ++ ) dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } long long count = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) count += dp [ n ] [ i ] ; return count ; }
bool existPath ( int V , int edges [ X ] [ Z ] , int u , int v ) { bool mat [ V ] [ V ] ; memset ( mat , false , sizeof ( mat ) ) ; for ( int i = 0 ; i < X ; i ++ ) mat [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = true ; for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { mat [ i ] [ j ] = mat [ i ] [ j ] || mat [ i ] [ k ] && mat [ k ] [ j ] ; } } } if ( u >= V v >= V ) { return false ; } if ( mat [ u ] [ v ] ) return true ; return false ; }
int calculate_maximum_splits ( int arr [ ] , int N ) { int pre [ ] = { 0 , -1 , -1 } ; int dp [ N ] ; memset ( dp , 0 , sizeof ( dp ) ) ; int C = 0 ; for ( int i = 0 ; i < N ; i ++ ) { C = C + arr [ i ] ; C = C % 3 ; if ( pre [ C ] == -1 ) { dp [ i ] = dp [ i - 1 ] ; } else { dp [ i ] = max ( dp [ i - 1 ] , dp [ pre [ C ] ] + 1 ) ; } pre [ C ] = i ; } return dp [ N - 1 ] ; }
int solve ( int n , int last , int k ) { if ( n == 1 ) { if ( last == k ) { return ( k - 1 ) ; } else { return 1 ; } } if ( dp [ n ] [ last ] ) return dp [ n ] [ last ] ; if ( last == k ) { return dp [ n ] [ last ] = ( k - 1 ) * solve ( n - 1 , k , k ) + ( k - 1 ) * solve ( n - 1 , 1 , k ) ; } else { return dp [ n ] [ last ] = solve ( n - 1 , k , k ) ; } }
int mergeTwoNumbers ( vector < int > & numbers ) { int len , i , j , k ; int n = numbers . size ( ) ; if ( numbers . size ( ) == 0 ) { return 0 ; } vector < int > prefixSum ( n + 1 , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) { prefixSum [ i ] = prefixSum [ i - 1 ] + numbers [ i - 1 ] ; } vector < vector < int > > dp ( n + 1 , vector < int > ( n + 1 ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ i ] = 0 ; } for ( len = 2 ; len <= n ; len ++ ) { for ( i = 1 ; i <= n - len + 1 ; i ++ ) { j = i + len - 1 ; int sum = prefixSum [ j ] - prefixSum [ i - 1 ] ; dp [ i ] [ j ] = INT_MAX ; for ( k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + sum ) ; } } } return dp [ 1 ] [ n ] ; }
void seiveOfEratosthenes ( ) { for ( int i = 2 ; i < 1000001 ; i ++ ) { prime [ i ] = 1 ; } for ( int i = 2 ; i * i < 1000001 ; i ++ ) { if ( prime [ i ] == 1 ) { for ( int j = i * i ; j < 1000001 ; j += i ) { prime [ j ] = 0 ; } } } }
vector < int > constructPath ( int u , int v ) { if ( Next [ u ] [ v ] == -1 ) return { } ; vector < int > path = { u } ; while ( u != v ) { u = Next [ u ] [ v ] ; path . push_back ( u ) ; } return path ; }
void floydWarshall ( int V ) { for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( dis [ i ] [ k ] == INF dis [ k ] [ j ] == INF ) continue ; if ( dis [ i ] [ j ] > dis [ i ] [ k ] + dis [ k ] [ j ] ) { dis [ i ] [ j ] = dis [ i ] [ k ] + dis [ k ] [ j ] ; Next [ i ] [ j ] = Next [ i ] [ k ] ; } } } } }
int maximumSum ( int A [ ] , int B [ ] , int length , int X , int Y ) { int l = length ; int l1 = min ( length , X ) ; int l2 = min ( length , Y ) ; int dp [ l1 + 1 ] [ l2 + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = 0 ; int max_sum = INT_MIN ; for ( int i = 1 ; i <= l1 ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + A [ i - 1 ] ; max_sum = max ( max_sum , dp [ i ] [ 0 ] ) ; } for ( int i = 1 ; i <= l2 ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + B [ i - 1 ] ; max_sum = max ( max_sum , dp [ 0 ] [ i ] ) ; } for ( int i = 1 ; i <= l1 ; i ++ ) { for ( int j = 1 ; j <= l2 ; j ++ ) { if ( i + j <= l ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] + A [ i + j - 1 ] , dp [ i ] [ j - 1 ] + B [ i + j - 1 ] ) ; max_sum = max ( dp [ i ] [ j ] , max_sum ) ; } } return max_sum ; }
void finding_factors ( ll int n ) { ll int i , a ; for ( i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i == n ) { vp [ n ] . push_back ( i ) ; } else { vp [ n ] . push_back ( i ) ; vp [ n ] . push_back ( n / i ) ; } } } }
ll int countSeq ( ll int N , ll int K ) { ll int i , j , k ; ll int dp [ 109 ] [ 109 ] = { 0 } ; for ( i = 1 ; i <= N ; i ++ ) { finding_factors ( i ) ; dp [ 0 ] [ i ] = 0 ; dp [ 1 ] [ i ] = 1 ; } for ( i = 2 ; i <= K ; i ++ ) { for ( j = 1 ; j <= N ; j ++ ) { ll int sum = 0 ; for ( k = 0 ; k < vp [ j ] . size ( ) ; k ++ ) { sum = ( sum + dp [ i - 1 ] [ vp [ j ] [ k ] ] ) ; } dp [ i ] [ j ] = sum ; } } ll int ans = 0 ; for ( j = 1 ; j <= N ; j ++ ) { ans = ( ans + dp [ K ] [ j ] ) ; } return ans ; }
int find_minimum_operations ( int n , int b [ ] , int k ) { int d [ n + 1 ] = { 0 } ; int operations = 0 , need ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 ) { d [ i ] += d [ i - 1 ] ; } if ( b [ i ] > d [ i ] ) { operations += b [ i ] - d [ i ] ; need = b [ i ] - d [ i ] ; d [ i ] += need ; if ( i + k <= n ) { d [ i + k ] -= need ; } } } cout << operations << endl ; }
void sieve ( ) { memset ( primes , true , sizeof ( primes ) ) ; primes [ 0 ] = primes [ 1 ] = 0 ; for ( int i = 2 ; i * i <= maxn ; i ++ ) { if ( primes [ i ] ) { for ( int j = i * i ; j <= maxn ; j += i ) primes [ j ] = false ; } } }
int printpentaRec ( int n ) { if ( n == 0 n == 1 n == 2 n == 3 n == 4 ) return 0 ; else if ( n == 5 ) return 1 ; else return ( printpentaRec ( n - 1 ) + printpentaRec ( n - 2 ) + printpentaRec ( n - 3 ) + printpentaRec ( n - 4 ) + printpentaRec ( n - 5 ) ) ; }
int possibleBinaries ( int pos , int ones , int sum , int k ) { if ( ones == k ) return 0 ; if ( pos == 0 ) return ( sum == 0 ) ? 1 : 0 ; if ( dp [ pos ] [ ones ] [ sum ] != -1 ) return dp [ pos ] [ ones ] [ sum ] ; int ret = possibleBinaries ( pos - 1 , ones + 1 , ( sum + 1 ) % 2 , k ) + possibleBinaries ( pos - 1 , 0 , sum , k ) ; dp [ pos ] [ ones ] [ sum ] = ret ; return dp [ pos ] [ ones ] [ sum ] ; }
int MAX_value ( vector < vector < int > > arr ) { int row = arr . size ( ) ; int col = arr [ 0 ] . size ( ) ; int dp [ row ] [ col ] ; memset ( dp , sizeof ( dp ) , 0 ) ; int i = 0 , j = 0 ; int c = arr [ 0 ] [ 0 ] , p = 0 ; int d = row ; for ( i = 0 ; i < d ; i ++ ) { for ( j = 0 ; j < d ; j ++ ) { if ( c < arr [ i ] [ j ] ) { c = arr [ i ] [ j ] ; } if ( i == 0 j == 0 ) { dp [ i ] [ j ] = 1 ; } else { if ( arr [ i - 1 ] [ j - 1 ] == arr [ i ] [ j ] && arr [ i - 1 ] [ j ] == arr [ i ] [ j ] && arr [ i ] [ j - 1 ] == arr [ i ] [ j ] ) { dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j - 1 ] , min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ) + 1 ; } else { dp [ i ] [ j ] = 1 ; } } } } for ( i = 0 ; i < d ; i ++ ) { for ( j = 0 ; j < d ; j ++ ) { if ( arr [ i ] [ j ] == c ) { if ( p < dp [ i ] [ j ] ) { p = dp [ i ] [ j ] ; } } } } return p * p ; }
void printList ( struct Node * head ) { if ( head == NULL ) cout << "Doubly Linked list empty" ; while ( head != NULL ) { cout << head -> data << " " ; head = head -> next ; } }
int countStableNum ( string str , int N ) { int count1 [ N ] [ 10 ] ; int count2 [ N ] [ 10 ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < 10 ; j ++ ) count1 [ i ] [ j ] = count2 [ i ] [ j ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i != 0 ) { for ( int j = 0 ; j < 10 ; j ++ ) { count1 [ i ] [ j ] += count1 [ i - 1 ] [ j ] ; } } count1 [ i ] [ str [ i ] - '0' ] ++ ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i != N - 1 ) { for ( int j = 0 ; j < 10 ; j ++ ) { count2 [ i ] [ j ] += count2 [ i + 1 ] [ j ] ; } } count2 [ i ] [ str [ i ] - '0' ] ++ ; } int ans = 0 ; for ( int i = 1 ; i < N - 1 ; i ++ ) { if ( str [ i ] == '9' ) continue ; int c1 = count1 [ i - 1 ] [ str [ i ] - '0' ] ; int c2 = count2 [ i + 1 ] [ str [ i ] - '0' + 1 ] ; if ( c2 == 0 ) continue ; ans = ( ans + ( c1 * ( ( c2 * ( c2 - 1 ) / 2 ) ) ) ) ; } return ans ; }
long long countWays ( string s , string t , int k ) { int n = s . size ( ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string p = s . substr ( i , n - i ) + s . substr ( 0 , i ) ; if ( p == t ) a ++ ; else b ++ ; } vector < long long > dp1 ( k + 1 ) , dp2 ( k + 1 ) ; if ( s == t ) { dp1 [ 0 ] = 1 ; dp2 [ 0 ] = 0 ; } else { dp1 [ 0 ] = 0 ; dp2 [ 0 ] = 1 ; } for ( int i = 1 ; i <= k ; i ++ ) { dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod ; dp2 [ i ] = ( ( dp1 [ i - 1 ] * ( b ) ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod ; } return dp1 [ k ] ; }
void dfs1 ( int u , int par , vector < int > g [ ] , int weight [ ] ) { dp1 [ u ] = weight [ u ] ; for ( auto c : g [ u ] ) { if ( c != par ) { dfs1 ( c , u , g , weight ) ; dp1 [ u ] += max ( 0 , dp1 ) ; } } }
void dfs2 ( int u , int par , vector < int > g [ ] , int weight [ ] ) { if ( par != 0 ) { int maxSumAncestors = dp2 [ par ] - max ( 0 , dp1 [ u ] ) ; dp2 [ u ] = dp1 [ u ] + max ( 0 , maxSumAncestors ) ; } for ( auto c : g [ u ] ) { if ( c != par ) { dfs2 ( c , u , g , weight ) ; } } }
void addEdge ( int u , int v , vector < int > g [ ] ) { g [ u ] . push_back ( v ) ; g [ v ] . push_back ( u ) ; }
void maxSumSegments ( vector < int > g [ ] , int weight [ ] , int n ) { dfs1 ( 1 , 0 , g , weight ) ; for ( int i = 1 ; i <= n ; i ++ ) { dp2 [ i ] = dp1 [ i ] ; } dfs2 ( 1 , 0 , g , weight ) ; }
void printAns ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { cout << dp2 [ i ] << " " ; } }
void countMaximum ( int * a , int n ) { sort ( a , a + n , cmp ) ; int count = 0 ; int mark = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ( a [ i ] + n >= mark ) ) { count += 1 ; } mark = max ( mark , a [ i ] + i + 1 ) ; } cout << count ; }
int CountWays ( int i , int j , int k ) { if ( i >= N i < 0 j > = M j < 0 k < 0 ) return 0 ; if ( i == 0 && j == 0 && k == 0 ) return 1 ; if ( dp [ i ] [ j ] [ k ] != -1 ) return dp [ i ] [ j ] [ k ] ; else dp [ i ] [ j ] [ k ] = ( CountWays ( i + 1 , j , k - 1 ) % MOD + CountWays ( i - 1 , j , k - 1 ) % MOD + CountWays ( i , j - 1 , k - 1 ) % MOD + CountWays ( i , j + 1 , k - 1 ) % MOD + CountWays ( i , j , k - 1 ) % MOD ) % MOD ; return dp [ i ] [ j ] [ k ] ; }
int smallestNum ( int n ) { int res = 1 ; for ( int i = 2 ; ; i *= 2 ) { int length = log10 ( i ) + 1 ; if ( length == n ) return log ( i ) / log ( 2 ) ; } }
int findResultUtil ( int arr [ ] , int L , int R ) { int result = 0 ; bool flag = false ; for ( int i = L ; i <= R ; i ++ ) { if ( flag == false ) { result = result + arr [ i ] ; flag = true ; } else { result = result - arr [ i ] ; flag = false ; } } return result ; }
bool isKPartitionPossible ( int arr [ ] , int N , int K ) { if ( K == 1 ) return true ; if ( N < K ) return false ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % K != 0 ) return false ; int target = sum / K ; int dp [ ( 1 << 15 ) ] ; for ( int i = 0 ; i < ( 1 << N ) ; i ++ ) dp [ i ] = -1 ; dp [ 0 ] = 0 ; for ( int mask = 0 ; mask < ( 1 << N ) ; mask ++ ) { if ( dp [ mask ] == -1 ) continue ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! ( mask & ( 1 << i ) ) && dp [ mask ] + arr [ i ] <= target ) { dp [ mask ( 1 << i ) ] = ( dp [ mask ] + arr [ i ] ) % target ; } } } if ( dp [ ( 1 << N ) - 1 ] == 0 ) return true ; else return false ; }
long long min_operation ( long long i , long long j , long long val , long long x ) { if ( i == n - 1 && j == m - 1 ) { if ( val > v [ i ] [ j ] ) { return dp [ i ] [ j ] = MAX ; } else { return dp [ i ] [ j ] = v [ i ] [ j ] - val ; } } if ( i == n j == m ) { return dp [ i ] [ j ] = MAX ; } if ( dp [ i ] [ j ] != -1 ) { return dp [ i ] [ j ] ; } if ( val > v [ i ] [ j ] ) { return dp [ i ] [ j ] = MAX ; } long long tmp = v [ i ] [ j ] - val ; tmp += min ( min_operation ( i + 1 , j , val + x , x ) , min_operation ( i , j + 1 , val + x , x ) ) ; return dp [ i ] [ j ] = tmp ; }
long long solve ( long long x ) { long long ans = INT64_MAX ; for ( long long i = 0 ; i < n ; i ++ ) { for ( long long j = 0 ; j < m ; j ++ ) { long long val = v [ i ] [ j ] - x * ( i + j ) ; memset ( dp , -1 , sizeof ( dp ) ) ; val = min_operation ( 0 , 0 , val , x ) ; ans = min ( ans , val ) ; } } return ans ; }
void printList ( struct Node * head ) { if ( head == NULL ) cout << "Doubly Linked list empty" ; while ( head != NULL ) { cout << head -> data << " " ; head = head -> next ; } }
int Count ( int S [ ] , int m , int n ) { vector < vector < int > > table ( m + 1 , vector < int > ( n + 1 , 0 ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { table [ 0 ] [ i ] = INT_MAX - 1 ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( S [ i - 1 ] > j ) { table [ i ] [ j ] = table [ i - 1 ] [ j ] ; } else { table [ i ] [ j ] = min ( table [ i - 1 ] [ j ] , table [ i ] [ j - S [ i - 1 ] ] + 1 ) ; } } } return table [ m ] [ n ] ; }
int maxProductUtil ( int X , int Y , int * A , int * B , vector < vector < int > > & dp ) { if ( X < 0 or Y < 0 ) return - INF ; if ( dp [ X ] [ Y ] != -1 ) return dp [ X ] [ Y ] ; dp [ X ] [ Y ] = maximum ( A [ X ] * B [ Y ] + maxProductUtil ( X - 1 , Y - 1 , A , B , dp ) , A [ X ] * B [ Y ] , maxProductUtil ( X - 1 , Y , A , B , dp ) , maxProductUtil ( X , Y - 1 , A , B , dp ) ) ; return dp [ X ] [ Y ] ; }
int maxProduct ( int A [ ] , int N , int B [ ] , int M ) { vector < vector < int > > dp ( N , vector < int > ( M , -1 ) ) ; return maxProductUtil ( N - 1 , M - 1 , A , B , dp ) ; }
int minOperation ( int k ) { vector < int > dp ( k + 1 , 0 ) ; for ( int i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ; if ( i % 2 == 0 ) { dp [ i ] = min ( dp [ i ] , dp [ i / 2 ] + 1 ) ; } } return dp [ k ] ; }
int maximumSum ( int S , int M , int N , vector < vector < int > > & stacks ) { int dp [ S + 1 ] [ N + 1 ] ; memset ( dp , INT_MIN , sizeof ( dp ) ) ; for ( int i = 0 ; i < S ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { for ( int k = 0 ; k <= min ( j , M ) ; k ++ ) { dp [ i + 1 ] [ j ] = max ( dp [ i + 1 ] [ j ] , stacks [ i ] [ k ] + dp [ i ] [ j - k ] ) ; } } } int result = INT_MIN ; for ( int i = 0 ; i <= N ; i ++ ) { result = max ( result , dp [ S ] [ i ] ) ; } return result ; }
int findSum ( int * arr , int n ) { int totalSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { totalSum += arr [ i ] ; } int dp [ 2 ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ 0 ] [ i ] = 1 ; dp [ 1 ] [ i ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { if ( dp [ 0 ] [ i ] < dp [ 0 ] [ j ] + 1 ) { dp [ 0 ] [ i ] = dp [ 0 ] [ j ] + 1 ; dp [ 1 ] [ i ] = dp [ 1 ] [ j ] + arr [ i ] ; } else if ( dp [ 0 ] [ i ] == dp [ 0 ] [ j ] + 1 ) { dp [ 1 ] [ i ] = min ( dp [ 1 ] [ i ] , dp [ 1 ] [ j ] + arr [ i ] ) ; } } } } int maxm = 0 ; int subtractSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ 0 ] [ i ] > maxm ) { maxm = dp [ 0 ] [ i ] ; subtractSum = dp [ 1 ] [ i ] ; } else if ( dp [ 0 ] [ i ] == maxm ) { subtractSum = min ( subtractSum , dp [ 1 ] [ i ] ) ; } } return totalSum - subtractSum ; }
int count ( int n ) { if ( n == 2 ) return 1 ; else if ( n == 4 ) return 2 ; else if ( n == 6 ) return 4 ; int table [ n + 1 ] , i ; for ( i = 0 ; i < n + 1 ; i ++ ) table [ i ] = 0 ; table [ 0 ] = 0 ; table [ 2 ] = 1 ; table [ 4 ] = 2 ; table [ 6 ] = 4 ; for ( i = 8 ; i <= n ; i = i + 2 ) { table [ i ] = table [ i - 2 ] + table [ i - 4 ] + table [ i - 6 ] ; } return table [ n ] ; }
bool isPrime ( string number ) { int num = stoi ( number ) ; for ( int i = 2 ; i * i <= num ; i ++ ) if ( ( num % i ) == 0 ) return false ; return num > 1 ? true : false ; }
int countPrimeStrings ( string & number , int i ) { if ( i == 0 ) return 1 ; int cnt = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 && number [ i - j ] != '0' && isPrime ( number . substr ( i - j , j ) ) ) { cnt += countPrimeStrings ( number , i - j ) ; cnt %= MOD ; } } return cnt ; }
void buildSieve ( ) { for ( auto & i : sieve ) i = true ; sieve [ 0 ] = false ; sieve [ 1 ] = false ; for ( int p = 2 ; p * p <= 1000000 ; p ++ ) { if ( sieve [ p ] == true ) { for ( int i = p * p ; i <= 1000000 ; i += p ) sieve [ i ] = false ; } } }
bool isPrime ( string number ) { int num = stoi ( number ) ; return sieve [ num ] ; }
int rec ( string & number , int i , vector < int > & dp ) { if ( dp [ i ] != -1 ) return dp [ i ] ; int cnt = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 && number [ i - j ] != '0' && isPrime ( number . substr ( i - j , j ) ) ) { cnt += rec ( number , i - j , dp ) ; cnt %= MOD ; } } return dp [ i ] = cnt ; }
int countPrimeStrings ( string & number ) { int n = number . length ( ) ; vector < int > dp ( n + 1 , -1 ) ; dp [ 0 ] = 1 ; return rec ( number , n , dp ) ; }
void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= 100000 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= 100000 ; i += p ) prime [ i ] = false ; } } }
int distinctPrimeSubSeq ( int a [ ] , int n , int k ) { SieveOfEratosthenes ( ) ; vector < int > primes ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ a [ i ] ] ) primes . push_back ( a [ i ] ) ; } int l = primes . size ( ) ; sort ( primes . begin ( ) , primes . end ( ) ) ; vector < int > b ; vector < int > dp ; int sum = 0 ; for ( int i = 0 ; i < l ; ) { int count = 1 , x = a [ i ] ; i ++ ; while ( i < l && a [ i ] == x ) { count ++ ; i ++ ; } b . push_back ( count ) ; dp . push_back ( count ) ; sum += count ; } int of_length = 2 ; int len = dp . size ( ) ; int ans = 0 ; while ( of_length <= k ) { int freq = 0 ; int prev = 0 ; for ( int i = 0 ; i < ( len - 1 ) ; i ++ ) { freq += dp [ i ] ; int j = sum - freq ; int subseq = b [ i ] * j ; ans += subseq ; dp [ i ] = subseq ; prev += dp [ i ] ; } len -- ; sum = prev ; of_length ++ ; } ans += ( l + 1 ) ; return ans ; }
int ways ( vector < vector < int > > & arr , int K ) { int R = arr . size ( ) ; int C = arr [ 0 ] . size ( ) ; int preSum [ R ] [ C ] ; for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { preSum [ r ] = arr [ r ] ; if ( r + 1 < R ) preSum [ r ] += preSum [ r + 1 ] ; if ( c + 1 < C ) preSum [ r ] += preSum [ r ] ; if ( r + 1 < R && c + 1 < C ) preSum [ r ] -= preSum [ r + 1 ] ; } } int dp [ K + 1 ] [ R ] [ C ] ; for ( int k = 1 ; k <= K ; k ++ ) { for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { if ( k == 1 ) { dp [ k ] [ r ] = ( preSum [ r ] > 0 ) ? 1 : 0 ; } else { dp [ k ] [ r ] = 0 ; for ( int r1 = r + 1 ; r1 < R ; r1 ++ ) { if ( preSum [ r ] - preSum [ r1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r1 ] ; } for ( int c1 = c + 1 ; c1 < C ; c1 ++ ) { if ( preSum [ r ] - preSum [ r ] [ c1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r ] [ c1 ] ; } } } } } return dp [ K ] [ 0 ] [ 0 ] ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int sumPathCost ( int grid [ ] [ Col ] , int m , int n ) { int sum = 0 , count ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { count = nCr ( i + j , i ) * nCr ( m + n - i - j , m - i ) ; sum += count * grid [ i ] [ j ] ; } } return sum ; }
void init ( ll x ) { memset ( dp , -1 , sizeof ( dp ) ) ; v . clear ( ) ; while ( x > 0 ) { v . push_back ( x % 10 ) ; x /= 10 ; } reverse ( v . begin ( ) , v . end ( ) ) ; N = v . size ( ) ; }
void findCount ( int L , int R , int K ) { init ( R ) ; ll r_ans = fun ( 0 , 0 , 0 , 0 , 0 ) ; init ( L - 1 ) ; ll l_ans = fun ( 0 , 0 , 0 , 0 , 0 ) ; cout << r_ans - l_ans ; }
void dfs_lca ( int a , int par , int lev ) { dp [ 0 ] [ a ] = par ; level [ a ] = lev ; for ( auto i : v [ a ] ) { if ( i . first == par ) continue ; mx [ 0 ] [ i . first ] = i . second ; dfs_lca ( i . first , a , lev + 1 ) ; } }
void find_ancestor ( ) { for ( int i = 1 ; i < LG ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ dp [ i - 1 ] [ j ] ] ; mx [ i ] [ j ] = max ( mx [ i - 1 ] [ j ] , mx [ i - 1 ] [ dp [ i - 1 ] [ j ] ] ) ; } } }
int getMax ( int a , int b ) { if ( level [ b ] < level [ a ] ) swap ( a , b ) ; int ans = 0 ; int diff = level [ b ] - level [ a ] ; while ( diff > 0 ) { int log = log2 ( diff ) ; ans = max ( ans , mx [ log ] [ b ] ) ; b = dp [ log ] [ b ] ; diff -= ( 1 << log ) ; } while ( a != b ) { int i = log2 ( level [ a ] ) ; while ( i > 0 && dp [ i ] [ a ] == dp [ i ] [ b ] ) i -- ; ans = max ( ans , mx [ i ] [ a ] ) ; ans = max ( ans , mx [ i ] [ b ] ) ; a = dp [ i ] [ a ] ; b = dp [ i ] [ b ] ; } return ans ; }
void compute_lca ( ) { dfs_lca ( 1 , 0 , 0 ) ; find_ancestor ( ) ; }
int dfs ( vector < int > adj [ ] , int * order , int * bridge_detect , bool * mark , int v , int l ) { mark [ v ] = 1 ; order [ v ] = order [ l ] + 1 ; bridge_detect [ v ] = order [ v ] ; for ( int i = 0 ; i < adj [ v ] . size ( ) ; i ++ ) { int u = adj [ v ] [ i ] ; if ( u == l ) { continue ; } if ( order [ v ] < order [ u ] ) { continue ; } if ( mark [ u ] ) { bridge_detect [ v ] = min ( order [ u ] , bridge_detect [ v ] ) ; } else { dfs ( adj , order , bridge_detect , mark , u , v ) ; } bridge_detect [ v ] = min ( bridge_detect [ u ] , bridge_detect [ v ] ) ; ans . push_back ( make_pair ( v , u ) ) ; } if ( bridge_detect [ v ] == order [ v ] && l != 0 ) { flag = 0 ; } return flag ; }
void createGraph ( int Edges [ ] [ 2 ] , vector < int > adj [ ] , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int u = Edges [ i ] [ 0 ] ; int v = Edges [ i ] [ 1 ] ; adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } }
void depthFirst ( int v , vector < int > graph [ ] , vector < bool > & visited , vector < int > & storeChain ) { visited [ v ] = true ; storeChain . push_back ( v ) ; for ( auto i : graph [ v ] ) { if ( visited [ i ] == false ) { depthFirst ( i , graph , visited , storeChain ) ; } } }
int subarraySum ( int arr [ ] , int n ) { int maxSubarraySum = arr [ 0 ] ; int currentMax = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { currentMax = max ( arr [ i ] , arr [ i ] + currentMax ) ; maxSubarraySum = max ( maxSubarraySum , currentMax ) ; } return maxSubarraySum ; }
int get_max_sum ( int arr [ ] , int n ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int dp [ 100001 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] = 0 ; dp [ 1 ] = freq [ 0 ] ; for ( int i = 2 ; i <= 100000 ; i ++ ) { dp [ i ] = max ( dp [ i - 1 ] , dp [ i - 2 ] + i * freq [ i ] ) ; } return dp [ 100000 ] ; }
int minFlip ( string a ) { int n = a . size ( ) ; vector < vector < int > > dp ( n + 1 , vector < int > ( 2 , 0 ) ) ; dp [ 0 ] [ 0 ] = ( a [ 0 ] == '1' ) ; dp [ 0 ] [ 1 ] = ( a [ 0 ] == '0' ) ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + ( a [ i ] == '1' ) ; dp [ i ] [ 1 ] = min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + ( a [ i ] == '0' ) ; } int answer = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { answer = min ( answer , dp [ i ] [ 1 ] + dp [ n - 1 ] [ 0 ] - dp [ i ] [ 0 ] ) ; } return min ( answer , dp [ n - 1 ] [ 0 ] ) ; }
int LIIDS ( int arr [ ] , int N ) { int dp [ N + 1 ] ; int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 1 ; } for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + i ; j <= N ; j += i ) { if ( arr [ j ] > arr [ i ] ) { dp [ j ] = max ( dp [ j ] , dp [ i ] + 1 ) ; } } ans = max ( ans , dp [ i ] ) ; } return ans ; }
bool isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; }
int findSubarraySum ( int arr [ ] , int n , int K ) { unordered_map < int , int > prevSum ; int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == K ) { res ++ ; } if ( prevSum . find ( currsum - K ) != prevSum . end ( ) ) res += ( prevSum [ currsum - K ] ) ; prevSum [ currsum ] ++ ; } return res ; }
void countSubarray ( int arr [ ] , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) { if ( isPerfectSquare ( arr [ i ] ) ) { arr [ i ] = 1 ; } else { arr [ i ] = 0 ; } } cout << findSubarraySum ( arr , n , K ) ; }
int calculate ( int pos , int left , int k , int L , int R ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; int answer = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( i > left ) break ; answer = ( answer + calculate ( pos + 1 , left - i , k , L , R ) ) % mod ; } return answer ; }
int countWaystoDivide ( int n , int k , int L , int R ) { return calculate ( 0 , n , k , L , R ) ; }
int calculate ( int pos , int left , int k , int L , int R ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; if ( dp [ pos ] [ left ] != -1 ) return dp [ pos ] [ left ] ; int answer = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( i > left ) break ; answer = ( answer + calculate ( pos + 1 , left - i , k , L , R ) ) % mod ; } return dp [ pos ] [ left ] = answer ; }
int countWaystoDivide ( int n , int k , int L , int R ) { memset ( dp , -1 , sizeof ( dp ) ) ; return calculate ( 0 , n , k , L , R ) ; }
void PossibleSum ( int n , int m , vector < vector < int > > v , int k ) { int dp [ n + 1 ] [ k + 1 ] = { 0 } ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= k ; j ++ ) { if ( dp [ i ] [ j ] == 1 ) { for ( int d = 0 ; d < m ; d ++ ) { if ( ( j + v [ i ] [ d ] ) <= k ) { dp [ i + 1 ] [ j + v [ i ] [ d ] ] = 1 ; } } } } } if ( dp [ n ] [ k ] == 1 ) cout << "YES\n" ; else cout << "NO\n" ; }
void printList ( Node * temp ) { while ( temp != NULL ) { cout << temp -> info << " " ; temp = temp -> next ; } }
int solve ( int arr [ ] , int curr , int mask , int n ) { if ( isprime ( curr ) ) { if ( mask == ( 1 << n ) - 1 ) { return true ; } curr = 0 ; } if ( mask == ( 1 << n ) - 1 ) { if ( ! isprime ( curr ) ) { return false ; } } if ( dp [ mask ] ) return dp [ mask ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( mask & 1 << i ) ) { if ( solve ( arr , curr + arr [ i ] , mask 1 << i , n ) ) { return true ; } } } return dp [ mask ] = false ; }
vector < int > minSqrNum ( int n ) { int arr [ n + 1 ] , k ; int sqrNum [ n + 1 ] ; vector < int > v ; arr [ 0 ] = 0 ; sqrNum [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { arr [ i ] = arr [ i - 1 ] + 1 ; sqrNum [ i ] = 1 ; k = 1 ; while ( k * k <= i ) { if ( arr [ i ] > arr [ i - k * k ] + 1 ) { arr [ i ] = arr [ i - k * k ] + 1 ; sqrNum [ i ] = k * k ; } k ++ ; } } while ( n > 0 ) { v . push_back ( sqrNum [ n ] ) ; n -= sqrNum [ n ] ; } return v ; }
long long int power ( long long int x , long long int y , long long int p ) { long long int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
void nCr ( long long int n , long long int p , int f [ ] [ 100 ] , int m ) { for ( long long int i = 0 ; i <= n ; i ++ ) { for ( long long int j = 0 ; j <= m ; j ++ ) { if ( j > i ) { f [ i ] [ j ] = 0 ; } else if ( j == 0 j == i ) { f [ i ] [ j ] = 1 ; } else { f [ i ] [ j ] = ( f [ i - 1 ] [ j ] + f [ i - 1 ] [ j - 1 ] ) % p ; } } } }
void sieve ( ) { memset ( isprime , true , sizeof ( isprime ) ) ; for ( int i = 2 ; i * i <= 1000 ; i ++ ) { if ( isprime [ i ] ) { for ( int j = i * i ; j <= 1000 ; j += i ) { isprime [ j ] = false ; } } } for ( int i = 2 ; i <= 1000 ; i ++ ) { if ( isprime [ i ] ) { prime . push_back ( i ) ; } } }
int CountWays ( int i , int j , int sum , int n , int k ) { if ( i > prime . size ( ) sum > n ) { return 0 ; } if ( sum == n ) { if ( j == k ) { return 1 ; } return 0 ; } if ( j == k ) return 0 ; if ( dp [ i ] [ j ] [ sum ] ) return dp [ i ] [ j ] [ sum ] ; int inc = 0 , exc = 0 ; inc = CountWays ( i + 1 , j + 1 , sum + prime [ i ] , n , k ) ; exc = CountWays ( i + 1 , j , sum , n , k ) ; return dp [ i ] [ j ] [ sum ] = inc + exc ; }
void createTable ( int mtrx [ ] [ dim ] , int k , int p , int dp [ ] [ dim ] ) { dp [ 0 ] [ 0 ] = mtrx [ 0 ] [ 0 ] ; for ( int j = 1 ; j < dim ; j ++ ) { dp [ 0 ] [ j ] = mtrx [ 0 ] [ j ] + dp [ 0 ] [ j - 1 ] ; } for ( int i = 1 ; i < dim ; i ++ ) { dp [ i ] [ 0 ] = mtrx [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < dim ; i ++ ) { for ( int j = 1 ; j < dim ; j ++ ) { dp [ i ] [ j ] = mtrx [ i ] [ j ] + dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; } } }
int countSubMatrixUtil ( int dp [ ] [ dim ] , int k , int p ) { int count = 0 ; int subMatSum = 0 ; for ( int i = k - 1 ; i < dim ; i ++ ) { for ( int j = k - 1 ; j < dim ; j ++ ) { if ( i == ( k - 1 ) || j == ( k - 1 ) ) { if ( i == ( k - 1 ) && j == ( k - 1 ) ) { subMatSum = dp [ i ] [ j ] ; } else if ( i == ( k - 1 ) ) { subMatSum = dp [ i ] [ j ] - dp [ i ] [ j - k ] ; } else { subMatSum = dp [ i ] [ j ] - dp [ i - k ] [ j ] ; } } else { subMatSum = dp [ i ] [ j ] - dp [ i - k ] [ j ] - dp [ i ] [ j - k ] + dp [ i - k ] [ j - k ] ; } if ( subMatSum >= p ) { count ++ ; } } } return count ; }
int solve ( int arr [ ] , int i , int len , int prev , int n , int k ) { if ( len == k ) return 0 ; if ( i == n ) return INT_MIN ; if ( dp [ i ] [ len ] [ prev ] ) return dp [ i ] [ len ] [ prev ] ; int inc = 0 , exc = 0 ; if ( len & 1 ) { inc = productDigitSum ( arr [ prev ] , arr [ i ] ) + solve ( arr , i + 1 , len + 1 , 0 , n , k ) ; } else { inc = solve ( arr , i + 1 , len + 1 , i , n , k ) ; } exc = solve ( arr , i + 1 , len , prev , n , k ) ; return dp [ i ] [ len ] [ prev ] = max ( inc , exc ) ; }
void precompute ( ) { for ( int i = 1 ; i <= 100000 ; i ++ ) { for ( int j = i ; j <= 100000 ; j += i ) { factors [ j ] . push_back ( i ) ; } } }
int solve ( int arr [ ] , int k , int n ) { if ( k == n - 1 ) { return 0 ; } if ( k >= n ) { return INT_MAX ; } if ( dp [ k ] ) { return dp [ k ] ; } int ans = INT_MAX ; for ( auto j : factors [ arr [ k ] ] ) { int res = solve ( arr , k + j , n ) ; if ( res != INT_MAX ) { ans = min ( ans , res + 1 ) ; } } return dp [ k ] = ans ; }
void precompute ( ) { for ( int i = 1 ; i <= 100000 ; i ++ ) { for ( int j = i ; j <= 100000 ; j += i ) factors [ j ] . push_back ( i ) ; } }
int solve ( int arr [ ] , int n ) { for ( int i = 0 ; i <= 100005 ; i ++ ) { dp [ i ] = INT_MAX ; } dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( auto j : factors [ arr [ i ] ] ) { if ( i + j < n ) dp [ i + j ] = min ( dp [ i + j ] , 1 + dp [ i ] ) ; } } return dp [ n - 1 ] ; }
long operation ( int n ) { dp . resize ( n + 1 , vector < int > ( n + 1 , -1 ) ) ; long ans = 0 , fac = 1 ; for ( int k = 1 ; k <= n ; k ++ ) { fac *= k ; ans = ( ans + ( fac * f ( n , k ) ) % mod ) % mod ; } return ans ; }
int countWays ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; } int sum ; for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { sum = 0 ; for ( int k = 0 ; k <= j ; k ++ ) { sum += dp [ i - 1 ] [ k ] ; } dp [ i ] [ j ] = sum ; } } return dp [ m ] [ n ] ; }
int countWays ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; if ( i != 0 ) { dp [ 1 ] [ i ] += dp [ 1 ] [ i - 1 ] ; } } for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; if ( i == m && j == n ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } } } }
void ConvertIntoDigit ( int n ) { while ( n ) { int dig = n % 10 ; digits . push_back ( dig ) ; n /= 10 ; } reverse ( digits . begin ( ) , digits . end ( ) ) ; }
int solve ( int idx , int k , int tight , int sum ) { if ( idx == digits . size ( ) && k == 0 && sum & 1 ) { if ( ! vis [ sum ] ) { vis [ sum ] = 1 ; return 1 ; } return 0 ; } if ( idx > digits . size ( ) ) { return 0 ; } if ( dp [ idx ] [ k ] [ tight ] [ sum ] ) { return dp [ idx ] [ k ] [ tight ] [ sum ] ; } int j ; if ( tight == 0 ) { j = digits [ idx ] ; } else { j = 9 ; } int cnt = 0 ; for ( int i = ( k ? 0 : 1 ) ; i <= j ; i ++ ) { int newtight = tight ; if ( i < j ) { newtight = 1 ; } if ( i == 0 ) cnt += solve ( idx + 1 , k - 1 , newtight , sum ) ; else cnt += solve ( idx + 1 , k , newtight , sum + i ) ; } return dp [ idx ] [ k ] [ tight ] [ sum ] = cnt ; }
int minDominatingSet ( Node * root , int covered , int compulsory ) { if ( ! root ) return 0 ; if ( ! root -> left and ! root -> right and ! covered ) compulsory = true ; if ( dp [ root -> data ] [ covered ] [ compulsory ] != -1 ) return dp [ root -> data ] [ covered ] [ compulsory ] ; if ( compulsory ) { return dp [ root -> data ] [ covered ] [ compulsory ] = 1 + minDominatingSet ( root -> left , 1 , 0 ) + minDominatingSet ( root -> right , 1 , 0 ) ; } if ( covered ) { return dp [ root -> data ] [ covered ] [ compulsory ] = min ( 1 + minDominatingSet ( root -> left , 1 , 0 ) + minDominatingSet ( root -> right , 1 , 0 ) , minDominatingSet ( root -> left , 0 , 0 ) + minDominatingSet ( root -> right , 0 , 0 ) ) ; } int ans = 1 + minDominatingSet ( root -> left , 1 , 0 ) + minDominatingSet ( root -> right , 1 , 0 ) ; if ( root -> left ) { ans = min ( ans , minDominatingSet ( root -> left , 0 , 1 ) + minDominatingSet ( root -> right , 0 , 0 ) ) ; } if ( root -> right ) { ans = min ( ans , minDominatingSet ( root -> left , 0 , 0 ) + minDominatingSet ( root -> right , 0 , 1 ) ) ; } return dp [ root -> data ] [ covered ] [ compulsory ] = ans ; }
int getmask ( int val ) { int mask = 0 ; int prime [ 15 ] = { 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 } ; for ( int i = 0 ; i < 15 ; i ++ ) { if ( val % prime [ i ] == 0 ) { mask = mask | ( 1 << i ) ; } } return mask ; }
int calculate ( int pos , int mask , int a [ ] , int n ) { if ( pos == n || mask == ( 1 << n - 1 ) ) return 0 ; if ( dp [ pos ] [ mask ] != -1 ) return dp [ pos ] [ mask ] ; int size = 0 ; size = max ( size , calculate ( pos + 1 , mask , a , n ) ) ; if ( ( getmask ( a [ pos ] ) & mask ) == 0 ) { int new_mask = ( mask | ( getmask ( a [ pos ] ) ) ) ; size = max ( size , 1 + calculate ( pos + 1 , new_mask , a , n ) ) ; } return dp [ pos ] [ mask ] = size ; }
int largestSubset ( int a [ ] , int n ) { memset ( dp , -1 , sizeof ( dp ) ) ; return calculate ( 0 , 0 , a , n ) ; }
int countSubsets ( int N ) { if ( N <= 2 ) return N ; if ( N == 3 ) return 2 ; int DP [ N + 1 ] = { 0 } ; DP [ 0 ] = 0 , DP [ 1 ] = 1 , DP [ 2 ] = 2 , DP [ 3 ] = 2 ; for ( int i = 4 ; i <= N ; i ++ ) { DP [ i ] = DP [ i - 2 ] + DP [ i - 3 ] ; } return DP [ N ] ; }
int CountSets ( int x , int pos ) { if ( x <= 0 ) { if ( pos == 0 ) return 1 ; else return 0 ; } if ( pos == 0 ) return 1 ; int answer = CountSets ( x - 1 , pos ) + CountSets ( x - 2 , pos - 1 ) ; return answer ; }
int CountOrderedSets ( int n ) { int factorial [ 10000 ] ; factorial [ 0 ] = 1 ; for ( int i = 1 ; i < 10000 ; i ++ ) factorial [ i ] = factorial [ i - 1 ] * i ; int answer = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int sets = CountSets ( n , i ) * factorial [ i ] ; answer = answer + sets ; } return answer ; }
int CountOrderedSets ( int n ) { int factorial [ 10000 ] ; factorial [ 0 ] = 1 ; for ( int i = 1 ; i < 10000 ; i ++ ) factorial [ i ] = factorial [ i - 1 ] * i ; int answer = 0 ; memset ( dp , -1 , sizeof ( dp ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { int sets = CountSets ( n , i ) * factorial [ i ] ; answer = answer + sets ; } return answer ; }
int numberOfArithmeticSequences ( int L [ ] , int N ) { if ( N <= 2 ) return 0 ; int count = 0 ; int res = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( L [ i ] - L [ i - 1 ] == L [ i - 1 ] - L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; }
long count_special ( long n ) { long fib [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod ; } return fib [ n ] ; }
int CountOfTriplets ( int a [ ] , int n ) { int answer = 0 ; int x = 0 ; int count [ 100005 ] = { 0 } ; int ways [ 100005 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { x ^= a [ i ] ; answer += count [ x ] * i - ways [ x ] ; count [ x ] ++ ; ways [ x ] += ( i + 1 ) ; } return answer ; }
int MaximumSum ( int a [ ] , int n ) { int dp [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) dp [ i ] [ j ] = INT_MIN ; } for ( int i = 0 ; i < n + 1 ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { int val = INT_MIN ; if ( ( i - 2 >= 0 && dp [ i - 2 ] [ j - 1 ] != INT_MIN ) i - 2 < 0 ) { val = a [ i - 1 ] + ( i - 2 >= 0 ? dp [ i - 2 ] [ j - 1 ] : 0 ) ; } if ( i - 1 >= j ) { val = max ( val , dp [ i - 1 ] [ j ] ) ; } dp [ i ] [ j ] = val ; } } return dp [ n ] [ n / 2 ] ; }
int MaximumSum ( int a [ ] , int n ) { int dp [ n + 1 ] [ 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 2 ] [ 1 ] = a [ 1 ] ; dp [ 2 ] [ 0 ] = a [ 0 ] ; for ( int i = 3 ; i < n + 1 ; i ++ ) { if ( i & 1 ) { int temp = max ( { dp [ i - 3 ] [ 1 ] , dp [ i - 3 ] [ 0 ] , dp [ i - 2 ] [ 1 ] , dp [ i - 2 ] [ 0 ] } ) ; dp [ i ] [ 1 ] = a [ i - 1 ] + temp ; dp [ i ] [ 0 ] = max ( { a [ i - 2 ] + dp [ i - 2 ] [ 0 ] , a [ i - 2 ] + dp [ i - 3 ] [ 1 ] , a [ i - 2 ] + dp [ i - 3 ] [ 0 ] , a [ i - 3 ] + dp [ i - 3 ] [ 0 ] } ) ; } else { dp [ i ] [ 1 ] = a [ i - 1 ] + max ( { dp [ i - 2 ] [ 1 ] , dp [ i - 2 ] [ 0 ] , dp [ i - 1 ] [ 0 ] } ) ; dp [ i ] [ 0 ] = a [ i - 2 ] + dp [ i - 2 ] [ 0 ] ; } } return max ( dp [ n ] [ 1 ] , dp [ n ] [ 0 ] ) ; }
int func ( int n ) { if ( n <= 0 ) return 0 ; if ( kPowKform . count ( n ) ) return 1 ; int answer = 0 ; int x = n ; while ( x > 0 ) { int d = x % 10 ; if ( d != 0 ) { if ( func ( n - d * d ) ) { answer = 1 ; break ; } } x /= 10 ; } return answer ; }
void canBeConverted ( int n ) { if ( func ( n ) ) cout << "Yes" ; else cout << "No" ; }
bool divisorGame ( int N , bool A , int dp [ ] [ 2 ] ) { if ( N == 1 or N == 3 ) return false ; if ( N == 2 ) return true ; if ( dp [ N ] [ A ] != -1 ) return dp [ N ] [ A ] ; int ans = ( A == 1 ) ? 0 : 1 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { if ( A ) ans |= divisorGame ( N - i , 0 , dp ) ; else ans &= divisorGame ( N - i , 1 , dp ) ; } } return dp [ N ] [ A ] = ans ; }
bool check ( vector < int > & v ) { set < int > digits ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { set < int > d ; while ( v [ i ] ) { d . insert ( v [ i ] % 10 ) ; v [ i ] /= 10 ; } for ( auto it : d ) { if ( digits . count ( it ) ) return false ; } for ( auto it : d ) digits . insert ( it ) ; } return true ; }
int numberOfSubarrays ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { vector < int > temp ; for ( int j = 0 ; j < n ; j ++ ) { if ( i & ( 1 << j ) ) temp . push_back ( a [ j ] ) ; } if ( check ( temp ) ) answer ++ ; } return answer ; }
int countWays ( int pos , int mask , int a [ ] , int n ) { if ( pos == n ) return ( mask > 0 ? 1 : 0 ) ; if ( dp [ pos ] [ mask ] != -1 ) return dp [ pos ] [ mask ] ; int count = 0 ; count = count + countWays ( pos + 1 , mask , a , n ) ; if ( ( getmask ( a [ pos ] ) & mask ) == 0 ) { int new_mask = ( mask | ( getmask ( a [ pos ] ) ) ) ; count = count + countWays ( pos + 1 , new_mask , a , n ) ; } return dp [ pos ] [ mask ] = count ; }
int numberOfSubarrays ( int a [ ] , int n ) { memset ( dp , -1 , sizeof ( dp ) ) ; return countWays ( 0 , 0 , a , n ) ; }
void change ( pair < int , int > & p , int x ) { if ( p . second > x ) p . second = x ; if ( p . first > p . second ) swap ( p . first , p . second ) ; }
int minNodetoRemove ( int n , vector < pair < int , int > > edges ) { for ( int i = 0 ; i < edges . size ( ) ; i ++ ) { adj [ edges [ i ] . first ] . push_back ( edges [ i ] . second ) ; adj [ edges [ i ] . second ] . push_back ( edges [ i ] . first ) ; } memset ( vis , 0 , sizeof ( vis ) ) ; totBackEdges = 0 ; for ( int v = 1 ; v <= n ; v ++ ) { if ( ! vis [ v ] ) dfs ( v ) ; } if ( totBackEdges == 0 ) return -1 ; int node = -1 ; for ( int v = 1 ; v <= n ; v ++ ) { if ( countAdj [ v ] + small [ v ] == totBackEdges && isPossible [ v ] ) { node = v ; } if ( node != -1 ) break ; } return node ; }
int height ( node * root ) { int ht = 0 ; if ( root == NULL ) return 0 ; return ( max ( height ( root -> left ) , height ( root -> right ) ) + 1 ) ; }
void FibonacciSeries ( int n ) { fib . push_back ( 0 ) ; fib . push_back ( 1 ) ; for ( int i = 2 ; i < n ; i ++ ) fib . push_back ( fib [ i - 1 ] + fib [ i - 2 ] ) ; }
int CountPathUtil ( node * root , int i , int count ) { if ( root == NULL || ! ( fib [ i ] == root -> data ) ) { return count ; } if ( ! root -> left && ! root -> right ) { count ++ ; } count = CountPathUtil ( root -> left , i + 1 , count ) ; return CountPathUtil ( root -> right , i + 1 , count ) ; }
void CountPath ( node * root ) { int ht = height ( root ) ; FibonacciSeries ( ht ) ; cout << CountPathUtil ( root , 0 , 0 ) ; }
void SieveOfEratosthenes ( ) { bool isPrime [ Large + 1 ] ; memset ( isPrime , true , sizeof ( isPrime ) ) ; for ( int p = 2 ; p * p <= Large ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= Large ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= Large ; p ++ ) if ( isPrime [ p ] ) prime . push_back ( p ) ; }
void Display ( int arr [ ] [ M ] , int row ) { for ( int i = 0 ; i < M ; i ++ ) cout << arr [ row ] [ i ] << " " ; }
void countDivisorsMult ( int arr [ ] [ M ] ) { unordered_map < int , int > mp ; int row_no = 0 ; long long max_factor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int no = arr [ i ] [ j ] ; for ( int k = 0 ; k < prime . size ( ) ; k ++ ) { while ( no > 1 && no % prime [ k ] == 0 ) { no /= prime [ k ] ; mp [ prime [ k ] ] ++ ; } if ( no == 1 ) break ; } } long long int res = 1 ; for ( auto it : mp ) { res *= ( it . second + 1L ) ; } if ( max_factor < res ) { row_no = i ; max_factor = res ; } mp . clear ( ) ; } Display ( arr , row_no ) ; }
int isSquare ( int n ) { int k = sqrt ( n ) ; return ( k * k == n ) ; }
int calculate ( int pos , int prev , int sum , vector < int > & v ) { if ( pos == v . size ( ) ) return isSquare ( sum ) ; for ( int i = prev ; i <= 9 ; i ++ ) { v [ pos ] = i ; sum += i * i ; if ( calculate ( pos + 1 , i , sum , v ) ) return 1 ; sum -= i * i ; } return 0 ; }
int countMountains ( int a [ ] [ MAX ] , int n ) { int A [ n + 2 ] [ n + 2 ] ; int count = 0 ; for ( int i = 0 ; i < n + 2 ; i ++ ) { for ( int j = 0 ; j < n + 2 ; j ++ ) { if ( ( i == 0 ) || ( j == 0 ) || ( i == n + 1 ) || ( j == n + 1 ) ) { A [ i ] [ j ] = INT_MIN ; } else { A [ i ] [ j ] = a [ i - 1 ] [ j - 1 ] ; } } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( ( A [ i ] [ j ] > A [ i - 1 ] [ j ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j ] ) && ( A [ i ] [ j ] > A [ i ] [ j - 1 ] ) && ( A [ i ] [ j ] > A [ i ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i - 1 ] [ j - 1 ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i - 1 ] [ j + 1 ] ) && ( A [ i ] [ j ] > A [ i + 1 ] [ j - 1 ] ) ) { count ++ ; } } } return count ; }
int calculate ( int pos , int g , int n , int k ) { if ( pos == n ) { return g ; } int answer = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { answer = ( answer % MOD + calculate ( pos + 1 , __gcd ( g , i ) , n , k ) % MOD ) ; answer %= MOD ; } return answer ; }
int sumofGCD ( int n , int k ) { return calculate ( 0 , 0 , n , k ) ; }
int fastexpo ( int a , int b ) { int res = 1 ; a %= MOD ; while ( b ) { if ( b & 1 ) res = ( res * a ) % MOD ; a *= a ; a %= MOD ; b >>= 1 ; } return res ; }
int sumofGCD ( int n , int k ) { int count [ k + 1 ] = { 0 } ; for ( int g = k ; g >= 1 ; g -- ) { int count_multiples = k / g ; int temp ; temp = fastexpo ( count_multiples , n ) ; temp %= MOD ; int extra = 0 ; for ( int j = g * 2 ; j <= k ; j += g ) { extra = ( extra + count [ j ] ) ; extra %= MOD ; } count [ g ] = ( temp - extra + MOD ) ; count [ g ] %= MOD ; } int sum = 0 ; int add ; for ( int i = 1 ; i <= k ; ++ i ) { add = ( count [ i ] % MOD * i % MOD ) ; add %= MOD ; sum += add ; sum %= MOD ; } return sum ; }
int findCost ( vector < vector < int > > cost_mat , int N , int M ) { vector < vector < int > > dp ( N , vector < int > ( M , 0 ) ) ; for ( int i = 0 ; i < M ; i ++ ) dp [ 0 ] [ i ] = cost_mat [ 0 ] [ i ] ; for ( int row = 1 ; row < N ; row ++ ) { for ( int curr_col = 0 ; curr_col < M ; curr_col ++ ) { int val = 999999999 ; for ( int prev_col = 0 ; prev_col < M ; prev_col ++ ) { if ( curr_col != prev_col ) val = min ( val , dp [ row - 1 ] [ prev_col ] ) ; } dp [ row ] [ curr_col ] = val + cost_mat [ row ] [ curr_col ] ; } } int ans = INT_MAX ; for ( int i = 0 ; i < M ; i ++ ) ans = min ( ans , dp [ N - 1 ] [ i ] ) ; return ans ; }
bool checkOdd ( string number ) { int n = number . length ( ) ; int num = number [ n - 1 ] - '0' ; return ( num & 1 ) ; }
void getPrimesFromSeive ( set < string > & primes ) { bool prime [ 1000001 ] ; memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int i = 2 ; i * i <= 1000000 ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = i * i ; j <= 1000000 ; j += i ) prime [ j ] = false ; } } for ( int i = 2 ; i <= 1000000 ; i ++ ) { if ( prime [ i ] == true ) primes . insert ( to_string ( i ) ) ; } }
int splitIntoPrimes ( string number ) { int numLen = number . length ( ) ; int splitDP [ numLen + 1 ] ; memset ( splitDP , -1 , sizeof ( splitDP ) ) ; set < string > primes ; getPrimesFromSeive ( primes ) ; for ( int i = 1 ; i <= numLen ; i ++ ) { if ( i <= 6 && ( primes . find ( number . substr ( 0 , i ) ) != primes . end ( ) ) ) splitDP [ i ] = 1 ; if ( splitDP [ i ] != -1 ) { for ( int j = 1 ; j <= 6 && i + j <= numLen ; j ++ ) { if ( primes . find ( number . substr ( i , j ) ) != primes . end ( ) ) { if ( splitDP [ i + j ] == -1 ) splitDP [ i + j ] = 1 + splitDP [ i ] ; else splitDP [ i + j ] = min ( splitDP [ i + j ] , 1 + splitDP [ i ] ) ; } } } } return splitDP [ numLen ] ; }
int k_nonzero_numbers ( string s , int n , int k ) { int dp [ n + 1 ] [ 2 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j < 2 ; j ++ ) for ( int x = 0 ; x <= k ; x ++ ) dp [ i ] [ j ] [ x ] = 0 ; dp [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < n ; ++ i ) { int sm = 0 ; while ( sm < 2 ) { for ( int j = 0 ; j < k + 1 ; ++ j ) { int x = 0 ; while ( x <= ( sm ? 9 : s [ i ] - '0' ) ) { dp [ i + 1 ] [ sm || x < ( s [ i ] - '0' ) ] [ j + ( x > 0 ) ] += dp [ i ] [ sm ] [ j ] ; ++ x ; } } ++ sm ; } } return dp [ n ] [ 0 ] [ k ] + dp [ n ] [ 1 ] [ k ] ; }
int maximumOccurrence ( string s ) { int n = s . length ( ) ; map < string , int > freq ; for ( int i = 0 ; i < n ; i ++ ) { string temp = "" ; temp += s [ i ] ; freq [ temp ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { string temp = "" ; temp += s [ i ] ; temp += s [ j ] ; freq [ temp ] ++ ; } } int answer = INT_MIN ; for ( auto it : freq ) answer = max ( answer , it . second ) ; return answer ; }
int maximumOccurrence ( string s ) { int n = s . length ( ) ; int freq [ 26 ] = { 0 } ; int dp [ 26 ] [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int c = ( s [ i ] - 'a' ) ; for ( int j = 0 ; j < 26 ; j ++ ) dp [ j ] += freq [ j ] ; freq ++ ; } int answer = INT_MIN ; for ( int i = 0 ; i < 26 ; i ++ ) answer = max ( answer , freq [ i ] ) ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { answer = max ( answer , dp [ i ] [ j ] ) ; } } return answer ; }
int calculate ( int pos , int rem , int z , int k , int n ) { if ( rem == 0 && z ) { if ( pos != n ) return ( powers [ n - pos - 1 ] * 9 ) % mod ; else return 1 ; } if ( pos == n ) return 0 ; if ( dp [ pos ] [ rem ] [ z ] != -1 ) return dp [ pos ] [ rem ] [ z ] ; int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( i == 0 ) count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , z , k , n ) ) ) % mod ; else count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , 1 , k , n ) ) ) % mod ; } return dp [ pos ] [ rem ] [ z ] = count ; }
int waysToSplit ( string s ) { int n = s . length ( ) ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { string left = s . substr ( 0 , i ) ; string right = s . substr ( i , n - i ) ; if ( distinctChars ( left ) == distinctChars ( right ) ) answer ++ ; } return answer ; }
int waysToSplit ( string s ) { int n = s . length ( ) ; int answer = 0 ; int prefix [ n ] = { 0 } ; int suffix [ n ] = { 0 } ; int seen [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int prev = ( i - 1 >= 0 ? prefix [ i - 1 ] : 0 ) ; if ( seen [ s [ i ] - 'a' ] == 0 ) { prefix [ i ] += ( prev + 1 ) ; } else prefix [ i ] = prev ; seen [ s [ i ] - 'a' ] = 1 ; } memset ( seen , 0 , sizeof ( seen ) ) ; suffix [ n - 1 ] = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int prev = suffix [ i ] ; if ( seen [ s [ i ] - 'a' ] == 0 ) { suffix [ i - 1 ] += ( prev + 1 ) ; } else suffix [ i - 1 ] = prev ; seen [ s [ i ] - 'a' ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( prefix [ i ] == suffix [ i ] ) answer ++ ; } return answer ; }
int calculate ( int pos , int tight , int D [ ] , int sz , string & num ) { if ( pos == num . length ( ) ) return 1 ; if ( dp [ pos ] [ tight ] != -1 ) return dp [ pos ] [ tight ] ; int val = 0 ; if ( tight == 0 ) { for ( int i = 0 ; i < sz ; i ++ ) { if ( D [ i ] < ( num [ pos ] - '0' ) ) { val += calculate ( pos + 1 , 1 , D , sz , num ) ; } else if ( D [ i ] == num [ pos ] - '0' ) val += calculate ( pos + 1 , tight , D , sz , num ) ; } } else { for ( int i = 0 ; i < sz ; i ++ ) { val += calculate ( pos + 1 , tight , D , sz , num ) ; } } return dp [ pos ] [ tight ] = val ; }
int countNumbers ( int D [ ] , int N , int sz ) { string num = convertToString ( N ) ; int len = num . length ( ) ; memset ( dp , -1 , sizeof ( dp ) ) ; int ans = calculate ( 0 , 0 , D , sz , num ) ; for ( int i = 1 ; i < len ; i ++ ) ans += calculate ( i , 1 , D , sz , num ) ; return ans ; }
void fibonacci ( ) { int i ; fib [ 0 ] = 0 ; fib [ 1 ] = 1 ; for ( i = 2 ; i <= MAX_SIZE ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } }
void printLevel ( int level ) { int left_index = pow ( 2 , level - 1 ) ; int right_index = pow ( 2 , level ) - 1 ; for ( int i = left_index ; i <= right_index ; i ++ ) { cout << fib [ i - 1 ] << " " ; } cout << endl ; }
int calculate ( int pos , int prev , int left , int k ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; int answer = 0 ; for ( int i = prev ; i <= left ; i ++ ) { answer += calculate ( pos + 1 , i , left - i , k ) ; } return answer ; }
int countWaystoDivide ( int n , int k ) { return calculate ( 0 , 1 , n , k ) ; }
int calculate ( int pos , int prev , int left , int k ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; if ( dp [ pos ] [ prev ] [ left ] != -1 ) return dp [ pos ] [ prev ] [ left ] ; int answer = 0 ; for ( int i = prev ; i <= left ; i ++ ) { answer += calculate ( pos + 1 , i , left - i , k ) ; } return dp [ pos ] [ prev ] [ left ] = answer ; }
int countWaystoDivide ( int n , int k ) { memset ( dp , -1 , sizeof ( dp ) ) ; return calculate ( 0 , 1 , n , k ) ; }
int countWays ( vector < string > & a , string s ) { int n = a . size ( ) ; vector < int > index [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < a [ i ] . length ( ) ; j ++ ) { index [ a [ i ] [ j ] - 'a' ] . push_back ( j + 1 ) ; } } memset ( dp , -1 , sizeof ( dp ) ) ; return calculate ( 0 , 0 , s , index ) ; }
int minimalLength ( int a [ ] , int n ) { int dp [ n + 1 ] [ n + 1 ] , dp1 [ n ] ; int i , j , k ; memset ( dp , -1 , sizeof ( dp ) ) ; for ( int size = 1 ; size <= n ; size ++ ) { for ( i = 0 ; i < n - size + 1 ; i ++ ) { j = i + size - 1 ; if ( i == j ) dp [ i ] [ j ] = a [ i ] ; else { for ( k = i ; k < j ; k ++ ) { if ( dp [ i ] [ k ] != -1 && dp [ i ] [ k ] == dp [ k + 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i ] [ k ] + 1 ; } } } } for ( i = 0 ; i < n ; i ++ ) dp1 [ i ] = 1e7 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( dp [ j ] [ i ] != -1 ) { if ( j == 0 ) dp1 [ i ] = 1 ; else dp1 [ i ] = min ( dp1 [ i ] , dp1 [ j - 1 ] + 1 ) ; } } } return dp1 [ n - 1 ] ; }
int maxScore ( int l , int r , int prefix_sum [ ] , int num ) { if ( l > r ) return 0 ; int current_sum = prefix_sum [ r ] - ( l - 1 >= 0 ? prefix_sum [ l - 1 ] : 0 ) ; if ( num % 2 == 0 ) current_sum *= -1 ; return current_sum + max ( maxScore ( l + 1 , r , prefix_sum , num + 1 ) , maxScore ( l , r - 1 , prefix_sum , num + 1 ) ) ; }
int findMaxScore ( int a [ ] , int n ) { int prefix_sum [ n ] = { 0 } ; prefix_sum [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix_sum [ i ] = prefix_sum [ i - 1 ] + a [ i ] ; } return maxScore ( 0 , n - 1 , prefix_sum , 1 ) ; }
int MaximumScoreDP ( int l , int r , int prefix_sum [ ] , int num ) { if ( l > r ) return 0 ; if ( dp [ l ] [ r ] [ num ] != -1 ) return dp [ l ] [ r ] [ num ] ; int current_sum = prefix_sum [ r ] - ( l - 1 >= 0 ? prefix_sum [ l - 1 ] : 0 ) ; if ( num % 2 == 0 ) current_sum *= -1 ; dp [ l ] [ r ] [ num ] = current_sum + max ( MaximumScoreDP ( l + 1 , r , prefix_sum , num + 1 ) , MaximumScoreDP ( l , r - 1 , prefix_sum , num + 1 ) ) ; return dp [ l ] [ r ] [ num ] ; }
int findMaxScore ( int a [ ] , int n ) { int prefix_sum [ n ] = { 0 } ; prefix_sum [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix_sum [ i ] = prefix_sum [ i - 1 ] + a [ i ] ; } memset ( dp , -1 , sizeof ( dp ) ) ; return MaximumScoreDP ( 0 , n - 1 , prefix_sum , 1 ) ; }
void computeFibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 1 ; for ( int i = 2 ; i < 100005 ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } }
int countString ( string str ) { int ans = 1 ; int cnt = 1 ; for ( int i = 1 ; str [ i ] ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) { cnt ++ ; } else { ans = ans * fib [ cnt ] ; cnt = 1 ; } } ans = ans * fib [ cnt ] ; return ans ; }
int find_max ( int i , int sum , vector < int > & v , int k ) { if ( i == v . size ( ) ) return 0 ; if ( dp [ i ] [ sum ] != -1 ) return dp [ i ] [ sum ] ; int ans = 0 ; if ( ( sum + find_max ( i + 1 , sum , v , k ) ) % k == 0 ) ans = find_max ( i + 1 , sum , v , k ) ; if ( ( sum + v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) % k == 0 ) ans = max ( ans , v [ i ] + find_max ( i + 1 , ( sum + v [ i ] ) % k , v , k ) ) ; return dp [ i ] [ sum ] = ans ; }
int maxLength ( int * a , int n ) { int maximum = 1 ; int left [ n ] ; int right [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = 1 ; right [ i ] = 1 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] > a [ i + 1 ] ) { right [ i ] = right [ i + 1 ] + 1 ; } maximum = max ( maximum , right [ i ] ) ; } for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] ) { left [ i ] = left [ i - 1 ] + 1 ; } } if ( n > 2 ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i - 1 ] > a [ i + 1 ] ) { maximum = max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) ; } } } return maximum ; }
void printGolombSequence ( int N ) { int arr [ MAX ] ; int cnt = 0 ; arr [ 0 ] = 0 ; arr [ 1 ] = 1 ; map < int , int > M ; M [ 2 ] = 2 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( cnt == 0 ) { arr [ i ] = 1 + arr [ i - 1 ] ; cnt = M [ arr [ i ] ] ; cnt -- ; } else { arr [ i ] = arr [ i - 1 ] ; cnt -- ; } M [ i ] = arr [ i ] ; } for ( int i = 1 ; i <= N ; i ++ ) { cout << arr [ i ] << ' ' ; } }
int number_of_ways ( int n ) { int includes_3 [ n + 1 ] = { } ; int not_includes_3 [ n + 1 ] = { } ; includes_3 [ 3 ] = 1 ; not_includes_3 [ 1 ] = 1 ; not_includes_3 [ 2 ] = 2 ; not_includes_3 [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { includes_3 [ i ] = includes_3 [ i - 1 ] + includes_3 [ i - 2 ] + not_includes_3 [ i - 3 ] ; not_includes_3 [ i ] = not_includes_3 [ i - 1 ] + not_includes_3 [ i - 2 ] ; } return includes_3 [ n ] ; }
int cntSubSeq ( int arr [ ] , int n ) { int pos_count = 0 ; int neg_count = 0 ; int result ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= pow ( 2 , neg_count - 1 ) ; else result = 0 ; return result ; }
int generateDivisors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { divisors [ i ] ++ ; } else { divisors [ i ] ++ ; divisors [ n / i ] ++ ; } } } }
int findMaxMultiples ( int * arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = max ( divisors [ arr [ i ] ] , ans ) ; generateDivisors ( arr [ i ] ) ; } return ans ; }
int max_sum ( int arr [ ] , int n , int k ) { int dp [ n ] ; dp [ 0 ] = maxi ( 0 , arr [ 0 ] ) ; int i = 1 ; while ( i < k ) { dp [ i ] = maxi ( dp [ i - 1 ] , arr [ i ] ) ; i ++ ; } i = k ; while ( i < n ) { dp [ i ] = maxi ( dp [ i - 1 ] , arr [ i ] + dp [ i - k ] ) ; i ++ ; } return dp [ n - 1 ] ; }
int maxIncSubarr ( int a [ ] , int n ) { int pre [ n ] = { 0 } ; int pos [ n ] = { 0 } ; pre [ 0 ] = 1 ; pos [ n - 1 ] = 1 ; int l = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] > a [ i - 1 ] ) pre [ i ] = pre [ i - 1 ] + 1 ; else pre [ i ] = 1 ; } l = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] < a [ i + 1 ] ) pos [ i ] = pos [ i + 1 ] + 1 ; else pos [ i ] = 1 ; } int ans = 0 ; l = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] > a [ i - 1 ] ) l ++ ; else l = 1 ; ans = max ( ans , l ) ; } for ( int i = 1 ; i <= n - 2 ; i ++ ) { if ( a [ i - 1 ] < a [ i + 1 ] ) ans = max ( pre [ i - 1 ] + pos [ i + 1 ] , ans ) ; } return ans ; }
int countWays ( int n ) { if ( n == 0 ) return 1 ; if ( n <= 2 ) return n ; int f0 = 1 , f1 = 1 , f2 = 2 , ans ; for ( int i = 3 ; i <= n ; i ++ ) { ans = f0 + f1 + f2 ; f0 = f1 ; f1 = f2 ; f2 = ans ; } return ans ; }
long countStr ( long N ) { long dp [ N + 1 ] [ 3 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; dp [ 1 ] [ 2 ] = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; } long ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; }
int update ( int in , int l , int r , int up_in , int val ) { if ( r < up_in l > up_in ) return seg [ in ] ; if ( l == up_in and r == up_in )  return seg [ in ] = val ; int m = ( l + r ) / 2 ; return seg [ in ] = update ( 2 * in + 1 , l , m , up_in , val ) + update ( 2 * in + 2 , m + 1 , r , up_in , val ) ; }
int maxLengthSquare ( int row , int column , int arr [ ] [ 4 ] , int k ) { int sum [ row + 1 ] [ column + 1 ] ; for ( int i = 1 ; i <= row ; i ++ ) for ( int j = 0 ; j <= column ; j ++ ) sum [ i ] [ j ] = 0 ; int cur_max = 1 ; int max = 0 ; for ( int i = 1 ; i <= row ; i ++ ) { for ( int j = 1 ; j <= column ; j ++ ) { sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] + arr [ i - 1 ] [ j - 1 ] - sum [ i - 1 ] [ j - 1 ] ; if ( i >= cur_max && j >= cur_max && sum [ i ] [ j ] - sum [ i - cur_max ] [ j ] - sum [ i ] [ j - cur_max ] + sum [ i - cur_max ] [ j - cur_max ] <= k ) { max = cur_max ++ ; } } } return max ; }
int getSum ( int x , int y , int z ) { int ans = 0 ; exactnum [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i <= x ; ++ i ) { for ( int j = 0 ; j <= y ; ++ j ) { for ( int k = 0 ; k <= z ; ++ k ) { if ( i > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] % mod ; } if ( j > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod ; } if ( k > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j ] [ k - 1 ] % mod ; } ans += exactsum [ i ] [ j ] [ k ] % mod ; ans %= mod ; } } } return ans ; }
int maximum_set ( int a [ ] , int n ) { int dp [ N ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) dp [ a [ i ] ] = 1 ; int ans = 1 ; for ( int i = N - 1 ; i >= 1 ; i -- ) { if ( dp [ i ] != 0 ) { for ( int j = 2 * i ; j < N ; j += i ) { dp [ i ] = max ( dp [ i ] , 1 + dp [ j ] ) ; ans = max ( ans , dp [ i ] ) ; } } } return ans ; }
int findMaxCount ( Node * root ) { int res = INT_MIN ; countUntil ( root , res ) ; return res ; }
int findLargestString ( string & s , int i , int r ) { if ( i == s . size ( ) ) { if ( r == 0 ) return 0 ; else return INT_MIN ; } if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = max ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( s [ i ] - '0' ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) ; return dp [ i ] [ r ] ; }
int findCnt ( string & s , int i , int r ) { if ( i == s . size ( ) ) { if ( r == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = findCnt ( s , i + 1 , ( r * 2 + ( s [ i ] - '0' ) ) % 3 ) + findCnt ( s , i + 1 , r ) ; return dp [ i ] [ r ] ; }
long long modInv ( long long a , long long p = MOD - 2 ) { long long s = 1 ; while ( p != 1 ) { if ( p % 2 ) s = ( s * a ) % MOD ; a = ( a * a ) % MOD ; p /= 2 ; } return ( a * s ) % MOD ; }
long long findCnt ( char x , string y ) { long long ans = 0 ; long long fact [ y . size ( ) + 1 ] = { 1 } ; for ( long long i = 1 ; i <= y . size ( ) ; i ++ ) fact [ i ] = ( fact [ i - 1 ] * i ) % MOD ; for ( long long i = 0 ; i < y . size ( ) ; i ++ ) { if ( y [ i ] == x ) { ans += ( modInv ( fact [ i ] ) * modInv ( fact [ y . size ( ) - i - 1 ] ) ) % MOD ; ans %= MOD ; } } ans *= fact [ ( y . size ( ) - 1 ) ] ; ans %= MOD ; return ans ; }
int minCount ( int * arr , int n , int k ) { int ans = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum -= k ; int l = 0 ; int r = 0 ; int tot = 0 ; while ( l < n ) { if ( tot <= sum ) { ans = max ( ans , r - l ) ; if ( r == n ) break ; tot += arr [ r ++ ] ; } else { tot -= arr [ l ++ ] ; } } return ( n - ans ) ; }
void findSubSeq ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int count [ n ] = { 1 } ; int prev [ n ] = { -1 } ; memset ( count , 1 , sizeof ( count ) ) ; memset ( prev , -1 , sizeof ( prev ) ) ; int max = 0 ; int maxprev = -1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] % arr [ j ] == 0 && count [ j ] + 1 > count [ i ] ) { count [ i ] = count [ j ] + 1 ; prev [ i ] = j ; } } if ( max < count [ i ] ) { max = count [ i ] ; maxprev = i ; } } int i = maxprev ; while ( i >= 0 ) { if ( arr [ i ] != -1 ) cout << arr [ i ] << " " ; i = prev [ i ] ; } }
ll solve ( int arr [ ] , int l , int r , int k ) { if ( r - l + 1 <= k ) return sum ( arr , l , r ) ; if ( dp [ l ] [ r ] [ k ] ) return dp [ l ] [ r ] [ k ] ; ll sum_ = sum ( arr , l , r ) ; ll len_r = ( r - l + 1 ) - k ; ll len = ( r - l + 1 ) ; ll ans = 0 ; for ( int i = 0 ; i < len - len_r + 1 ; i ++ ) { ll sum_sub = sum ( arr , i + l , i + l + len_r - 1 ) ; ans = max ( ans , ( sum_ - sum_sub ) + ( sum_sub - solve ( arr , i + l , i + l + len_r - 1 , k ) ) ) ; } dp [ l ] [ r ] [ k ] = ans ; return ans ; }
int minDifference ( int x , int y , int k , vector < vector < int > > b , vector < vector < int > > c ) { if ( x >= n or y >= m ) return INT_MAX ; if ( x == n - 1 and y == m - 1 ) { int diff = b [ x ] [ y ] - c [ x ] [ y ] ; return min ( abs ( k - diff ) , abs ( k + diff ) ) ; } int & ans = dp [ x ] [ y ] [ k ] ; if ( ans != -1 ) return ans ; ans = INT_MAX ; int diff = b [ x ] [ y ] - c [ x ] [ y ] ; ans = min ( ans , minDifference ( x + 1 , y , abs ( k + diff ) , b , c ) ) ; ans = min ( ans , minDifference ( x , y + 1 , abs ( k + diff ) , b , c ) ) ; ans = min ( ans , minDifference ( x + 1 , y , abs ( k - diff ) , b , c ) ) ; ans = min ( ans , minDifference ( x , y + 1 , abs ( k - diff ) , b , c ) ) ; return ans ; }
int countSubSeq ( string str , int len ) { int ans = 0 ; int mul = 1 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) ans += mul ; mul *= 2 ; } return ans ; }
int solveDp ( int r , int i , int * w , int * val , int n ) { if ( r <= 0 ) return 0 ; if ( i == n ) return W_MAX ; if ( v [ r ] [ i ] ) return dp [ r ] [ i ] ; v [ r ] [ i ] = 1 ; dp [ r ] [ i ] = min ( solveDp ( r , i + 1 , w , val , n ) , w [ i ] + solveDp ( r - val [ i ] , i + 1 , w , val , n ) ) ; return dp [ r ] [ i ] ; }
int maxWeight ( int * w , int * val , int n , int c ) { for ( int i = V_SUM_MAX ; i >= 0 ; i -- ) { if ( solveDp ( i , 0 , w , val , n ) <= c ) { return i ; } } return 0 ; }
int dfs ( int node ) { vis [ node ] = 1 ; subtree_size [ node ] = 1 ; for ( auto child : tree [ node ] ) { if ( ! vis [ child ] ) { subtree_size [ node ] += dfs ( child ) ; } } return subtree_size [ node ] ; }
void contribution ( int node , int & ans ) { vis [ node ] = true ; for ( int child : tree [ node ] ) { if ( ! vis [ child ] ) { ans += ( subtree_size [ child ] * ( n - subtree_size [ child ] ) ) ; contribution ( child , ans ) ; } } }
int getSum ( ) { memset ( vis , 0 , sizeof ( vis ) ) ; dfs ( 0 ) ; int ans = 0 ; memset ( vis , 0 , sizeof ( vis ) ) ; contribution ( 0 , ans ) ; return ans ; }
int longest_subseq ( int n , int k , string s ) { vector < int > dp ( n , 0 ) ; int max_length [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int curr = s [ i ] - 'a' ; int lower = max ( 0 , curr - k ) ; int upper = min ( 25 , curr + k ) ; for ( int j = lower ; j < upper + 1 ; j ++ ) { dp [ i ] = max ( dp [ i ] , max_length [ j ] + 1 ) ; } max_length [ curr ] = max ( dp [ i ] , max_length [ curr ] ) ; } int ans = 0 ; for ( int i : dp ) ans = max ( i , ans ) ; return ans ; }
int countNum ( int idx , int sum , int tight , vector < int > num , int len , int k ) { if ( len == idx ) { if ( sum == 0 ) return 1 ; else return 0 ; } if ( dp [ idx ] [ sum ] [ tight ] != -1 ) return dp [ idx ] [ sum ] [ tight ] ; int res = 0 , limit ; if ( tight == 0 ) { limit = num [ idx ] ; } else { limit = 9 ; } for ( int i = 0 ; i <= limit ; i ++ ) { int new_tight = tight ; if ( tight == 0 && i < limit ) new_tight = 1 ; res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len , k ) ; res %= MOD ; } if ( res < 0 ) res += MOD ; return dp [ idx ] [ sum ] [ tight ] = res ; }
vector < int > process ( string s ) { vector < int > num ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { num . push_back ( s [ i ] - '0' ) ; } return num ; }
void maxLengthOf1s ( vector < int > arr , int n ) { vector < int > prefix ( n , 0 ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i - 2 ] == 1 ) prefix [ i ] = prefix [ i - 1 ] + 1 ; else prefix [ i ] = 0 ; } vector < int > suffix ( n , 0 ) ; for ( int i = n - 3 ; i >= 0 ; i -- ) { if ( arr [ i + 2 ] == 1 ) suffix [ i ] = suffix [ i + 1 ] + 1 ; else suffix [ i ] = 0 ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans = max ( ans , prefix [ i + 1 ] + suffix [ i ] ) ; } cout << ans << "\n" ; }
int MaxGCD ( int a [ ] , int n ) { int Prefix [ n + 2 ] ; int Suffix [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = __gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = __gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = max ( ans , __gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; }
int max_sum ( int a [ ] , int n ) { vector < vector < int > > dp ( n + 1 , vector < int > ( 2 , 0 ) ) ; dp [ 0 ] [ 0 ] = 0 , dp [ 0 ] [ 1 ] = -999999 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] + a [ i ] , dp [ i ] [ 1 ] - a [ i ] ) ; dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] - a [ i ] , dp [ i ] [ 1 ] + a [ i ] ) ; } return dp [ n ] [ 0 ] ; }
int sumOfProduct ( int arr [ ] , int n , int k ) { int dp [ n + 1 ] [ n + 1 ] = { 0 } ; int cur_sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = arr [ i - 1 ] ; cur_sum += arr [ i - 1 ] ; } for ( int i = 2 ; i <= k ; i ++ ) { int temp_sum = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { cur_sum -= dp [ i - 1 ] [ j ] ; dp [ i ] [ j ] = arr [ j - 1 ] * cur_sum ; temp_sum += dp [ i ] [ j ] ; } cur_sum = temp_sum ; } return cur_sum ; }
int number_of_ways ( int arr [ ] , int n , int k ) { if ( k == 1 ) return 1 ; int dp [ k + 1 ] ; memset ( dp , -1 , sizeof dp ) ; for ( int i = 0 ; i < n ; i ++ ) dp [ arr [ i ] ] = 0 ; dp [ 0 ] = 1 ; dp [ 1 ] = ( dp [ 1 ] == -1 ) ? 1 : dp [ 1 ] ; for ( int i = 2 ; i <= k ; ++ i ) { if ( dp [ i ] == 0 ) continue ; dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; dp [ i ] %= MOD ; } return dp [ k ] ; }
int MinCost ( int arr [ ] , int n ) { int dp [ n + 5 ] [ n + 5 ] , sum [ n + 5 ] [ n + 5 ] ; memset ( sum , 0 , sizeof ( 0 ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int k = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { if ( i == j ) sum [ i ] [ j ] = k ; else { k += arr [ j ] ; sum [ i ] [ j ] = k ; } } } for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = i ; j < n ; j ++ ) { dp [ i ] [ j ] = INT_MAX ; if ( i == j ) dp [ i ] [ j ] = 0 ; else { for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + sum [ i ] [ j ] ) ; } } } } return dp [ 0 ] [ n - 1 ] ; }
int findCount ( int N ) { vector < int > list ; int sum = 0 ; int i ; for ( i = 0 ; i < 20 ; i ++ ) { sum += pow ( 2 , i ) ; list . push_back ( sum ) ; } for ( i = 0 ; i < 20 ; i ++ ) { if ( list [ i ] >= N ) { return ( index ( list , list [ i ] ) + 1 ) ; } } }
int findMax ( int arr [ ] , int n ) { int res = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( j = 0 ; j < i ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) count += 1 ; } res = max ( count , res ) ; } return res ; }
int findMax ( int arr [ ] , int n ) { bool divisible [ n ] = { false } ; int res = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( divisible [ i ] ) continue ; int cnt = 0 ; for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] % arr [ i ] ) == 0 ) { divisible [ j ] = true ; cnt ++ ; } } res = max ( res , cnt ) ; } return res ; }
void findSetBits ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) cout << __builtin_popcount ( i ) << " " ; }
void findSetBits ( int n ) { int dp [ n + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; cout << dp [ 0 ] << " " ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { dp [ i ] = dp [ i / 2 ] ; } else { dp [ i ] = dp [ i / 2 ] + 1 ; } cout << dp [ i ] << " " ; } }
int findLen ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( ! curr ) return 0 ; else return -1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != -1 ) dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
int findCnt ( int * arr , int i , int required_sum , int n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ required_sum + base ] ) return dp [ i ] [ required_sum + base ] ; v [ i ] [ required_sum + base ] = 1 ; dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + base ] ; }
int findCnt ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { return ( curr == m ) ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr arr [ i ] ) , n , m ) ; return dp [ i ] [ curr ] ; }
int findCnt ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { return ( curr == m ) ; } if ( v1 [ i ] [ curr ] ) return dp1 [ i ] [ curr ] ; v1 [ i ] [ curr ] = 1 ; dp1 [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr & arr [ i ] ) , n , m ) ; return dp1 [ i ] [ curr ] ; }
int modulo_13 ( string s , int n ) { long long dp [ n + 1 ] [ 13 ] = { { 0 } } ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { int nxt = s [ i ] - '0' ; if ( s [ i ] == '?' ) nxt = j ; for ( int k = 0 ; k < 13 ; k ++ ) { int rem = ( 10 * k + nxt ) % 13 ; dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] ; dp [ i + 1 ] [ rem ] %= MOD ; } if ( s [ i ] != '?' ) break ; } } return ( int ) dp [ n ] [ 5 ] ; }
int f ( int i , int state , int A [ ] , int dp [ ] [ 3 ] , int N ) { if ( i >= N ) return 0 ; else if ( dp [ i ] [ state ] != -1 ) { return dp [ i ] [ state ] ; } else { if ( i == N - 1 ) dp [ i ] [ state ] = 1 ; else if ( state == 1 && A [ i ] > A [ i + 1 ] ) dp [ i ] [ state ] = 1 ; else if ( state == 2 && A [ i ] < A [ i + 1 ] ) dp [ i ] [ state ] = 1 ; else if ( state == 1 && A [ i ] <= A [ i + 1 ] ) dp [ i ] [ state ] = 1 + f ( i + 1 , 2 , A , dp , N ) ; else if ( state == 2 && A [ i ] >= A [ i + 1 ] ) dp [ i ] [ state ] = 1 + f ( i + 1 , 1 , A , dp , N ) ; return dp [ i ] [ state ] ; } }
int maxLenSeq ( int A [ ] , int N ) { int i , tmp , y , ans ; int dp [ 1000 ] [ 3 ] ; memset ( dp , -1 , sizeof dp ) ; for ( i = 0 ; i < N ; i ++ ) { tmp = f ( i , 1 , A , dp , N ) ; tmp = f ( i , 2 , A , dp , N ) ; } ans = -1 ; for ( i = 0 ; i < N ; i ++ ) { y = dp [ i ] [ 1 ] ; if ( i + y >= N ) ans = max ( ans , dp [ i ] [ 1 ] + 1 ) ; else if ( y % 2 == 0 ) { ans = max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 2 ] ) ; } else if ( y % 2 == 1 ) { ans = max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 1 ] ) ; } } return ans ; }
int countWays ( int n ) { vector < int > a ; int i = 1 ; while ( i <= n ) a . push_back ( i ++ ) ; int ways = 0 ; do { bool flag = ( a [ 0 ] == 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( abs ( a [ i ] - a [ i - 1 ] ) > 2 ) flag = 0 ; } if ( flag ) ways ++ ; } while ( next_permutation ( a . begin ( ) , a . end ( ) ) ) ; return ways ; }
int LISusingLCS ( vector < int > & seq ) { int n = seq . size ( ) ; vector < vector < int > > L ( n + 1 , vector < int > ( n + 1 ) ) ; vector < int > sortedseq ( seq ) ; sort ( sortedseq . begin ( ) , sortedseq . end ( ) ) ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( seq [ i - 1 ] == sortedseq [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ n ] [ n ] ; }
int count_numbers ( int k , int n , bool flag ) { if ( n == 1 ) { if ( flag ) { return ( k - 1 ) ; } else { return 1 ; } } if ( flag ) return ( k - 1 ) * ( count_numbers ( k , n - 1 , 0 ) + count_numbers ( k , n - 1 , 1 ) ) ; else return count_numbers ( k , n - 1 , 1 ) ; }
int count_numbers ( int k , int n ) { int dp [ n + 1 ] [ 2 ] ; dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = k - 1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) ; } return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ; }
int divideArray ( int arr [ ] , int n , int k ) { int dp [ 500 ] [ 500 ] = { 0 } ; k -= 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= k ; j ++ ) { dp [ i ] [ j ] = INT_MAX ; int max_ = -1 , sum = 0 ; for ( int l = i ; l < n ; l ++ ) { max_ = max ( max_ , arr [ l ] ) ; sum += arr [ l ] ; int diff = ( l - i + 1 ) * max_ - sum ; if ( j > 0 ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , diff + dp [ l + 1 ] [ j - 1 ] ) ; else dp [ i ] [ j ] = diff ; } } } return dp [ 0 ] [ k ] ; }
int cntSubsets ( int * arr , int n ) { unsigned int max = pow ( 2 , n ) ; int result = 0 ; for ( int i = 0 ; i < max ; i ++ ) { int counter = i ; if ( counter & ( counter >> 1 ) ) continue ; result ++ ; } return result ; }
int cntSubsets ( int * arr , int n ) { int a [ n ] , b [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } int result = a [ n - 1 ] + b [ n - 1 ] ; return result ; }
void perfix_calculate ( vector < vector < int > > & A , vector < vector < int > > & row , vector < vector < int > > & col ) { int n = ( int ) A . size ( ) ; int m = ( int ) A [ 0 ] . size ( ) ; for ( int i = 0 ; i < n ; ++ i ) { row [ i ] [ 0 ] = A [ i ] [ 0 ] ; } for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 1 ; j < m ; ++ j ) { row [ i ] [ j ] = row [ i ] [ j - 1 ] + A [ i ] [ j ] ; } } for ( int i = 0 ; i < m ; ++ i ) { col [ 0 ] [ i ] = A [ 0 ] [ i ] ; } for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 1 ; j < n ; ++ j ) { col [ j ] [ i ] = A [ j ] [ i ] + col [ j - 1 ] [ i ] ; } } }
int perimeter ( int i , int j , int k , vector < vector < int > > & row , vector < vector < int > > & col , vector < vector < int > > & A ) { int row_s , col_s ; if ( j == 0 ) row_s = 0 ; else row_s = row [ i ] [ j - 1 ] ; if ( i == 0 ) col_s = 0 ; else col_s = col [ i - 1 ] [ j ] ; int upper_row = row [ i ] [ j + k ] - row_s ; int left_col = col [ i + k ] [ j ] - col_s ; if ( j == 0 ) row_s = 0 ; else row_s = row [ i + k ] [ j - 1 ] ; if ( i == 0 ) col_s = 0 ; else col_s = col [ i - 1 ] [ j + k ] ; int lower_row = row [ i + k ] [ j + k ] - row_s ; int right_col = col [ i + k ] [ j + k ] - col_s ; int sum = upper_row + lower_row + left_col + right_col ; sum -= ( A [ i ] [ j ] + A [ i + k ] [ j ] + A [ i ] [ j + k ] + A [ i + k ] [ j + k ] ) ; return sum ; }
int maxPerimeter ( vector < vector < int > > & A ) { int n = ( int ) A . size ( ) ; int m = ( int ) A [ 0 ] . size ( ) ; vector < vector < int > > row ( n , vector < int > ( m , 0 ) ) ; vector < vector < int > > col ( n , vector < int > ( m , 0 ) ) ; perfix_calculate ( A , row , col ) ; int maxPer = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { for ( int k = 0 ; k < min ( n - i , m - j ) ; ++ k ) { int perimtr = perimeter ( i , j , k , row , col , A ) ; maxPer = max ( maxPer , perimtr ) ; } } } return maxPer ; }
bool mazeProb ( vector < vector < int > > maze , int xpos , int ypos ) { bool key = true ; if ( findPath ( maze , xpos , ypos , key ) ) return true ; return false ; }
int ways ( int i , int arr [ ] , int n ) { if ( i == n - 1 ) return 1 ; int sum = 0 ; for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; }
int minJumps ( int arr [ ] , int N ) { int fib [ 30 ] ; fib [ 0 ] = 0 ; fib [ 1 ] = 1 ; for ( int i = 2 ; i < 30 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; int DP [ N + 2 ] ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= N + 1 ; i ++ ) DP [ i ] = MAX ; for ( int i = 1 ; i <= N + 1 ; i ++ ) { for ( int j = 1 ; j < 30 ; j ++ ) { if ( ( arr [ i - 1 ] == 1 i == N + 1 ) && i - fib [ j ] >= 0 ) DP [ i ] = min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) ; } } if ( DP [ N + 1 ] != MAX ) return DP [ N + 1 ] ; else return -1 ; }
int CountOfOddSum ( int a [ ] [ 2 ] , int n ) { int dp [ n ] [ 2 ] , cnt [ n ] [ 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { if ( a [ i ] [ j ] % 2 == 0 ) { cnt [ i ] [ 0 ] ++ ; } else { cnt [ i ] [ 1 ] ++ ; } } } dp [ 0 ] [ 0 ] = cnt [ 0 ] [ 0 ] , dp [ 0 ] [ 1 ] = cnt [ 0 ] [ 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] * cnt [ i ] [ 0 ] + dp [ i - 1 ] [ 1 ] * cnt [ i ] [ 1 ] ) ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] * cnt [ i ] [ 1 ] + dp [ i - 1 ] [ 1 ] * cnt [ i ] [ 0 ] ) ; } return dp [ n - 1 ] [ 1 ] ; }
int recur ( int ind , int cnt , int last , int a [ ] , int n , int k , int dp [ ] [ MAX ] ) { if ( cnt == k ) return 0 ; if ( ind == n ) return -1e9 ; if ( dp [ ind ] [ cnt ] != -1 ) return dp [ ind ] [ cnt ] ; int ans = 0 ; for ( int i = ind ; i < n ; i ++ ) { if ( cnt % 2 == 0 ) ans = max ( ans , recur ( i + 1 , cnt + 1 , i , a , n , k , dp ) ) ; else ans = max ( ans , __gcd ( a [ last ] , a [ i ] ) + recur ( i + 1 , cnt + 1 , 0 , a , n , k , dp ) ) ; } return dp [ ind ] [ cnt ] = ans ; }
int Max_Sum ( int arr1 [ ] , int arr2 [ ] , int n ) { int dp [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { dp [ i ] [ 0 ] = arr1 [ i ] ; dp [ i ] [ 1 ] = arr2 [ i ] ; continue ; } dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] + arr1 [ i ] ) ; dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] + arr2 [ i ] ) ; } return max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; }
int maximizeSum ( int a [ ] , int n , int ind , int k , int dp [ MAX ] [ MAX ] ) { if ( k == 0 ) { if ( ind == n ) return 0 ; else return -1e9 ; } else if ( ind == n ) return -1e9 ; else if ( dp [ ind ] [ k ] != -1 ) return dp [ ind ] [ k ] ; else { int ans = 0 ; int mini = a [ ind ] ; for ( int i = ind ; i < n ; i ++ ) { mini = min ( mini , a [ i ] ) ; ans = max ( ans , maximizeSum ( a , n , i + 1 , k - 1 , dp ) + mini ) ; } return dp [ ind ] [ k ] = ans ; } }
int Partition ( int arr [ ] , int n , int k ) { int prefix [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i ] ; } int LOGS = 20 ; int ans = 0 ; for ( int i = LOGS ; i >= 0 ; -- i ) { if ( checkpossible ( ans | ( 1 << i ) , arr , prefix , n , k ) ) { ans = ans | ( 1 << i ) ; } } return ans ; }
void SieveOfEratosthenes ( int MAX , vector < int > & primes ) { bool prime [ MAX + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( long long p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( long long i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } for ( long long i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] ) primes . push_back ( i ) ; } }
int findLongest ( int A [ ] , int n ) { unordered_map < int , int > mpp ; vector < int > primes ; SieveOfEratosthenes ( A [ n - 1 ] , primes ) ; int dp [ n ] ; memset ( dp , 0 , sizeof dp ) ; dp [ n - 1 ] = 1 ; mpp [ A [ n - 1 ] ] = n - 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int num = A [ i ] ; dp [ i ] = 1 ; int maxi = 0 ; for ( auto it : primes ) { int xx = num * it ; if ( xx > A [ n - 1 ] ) break ; else if ( mpp [ xx ] != 0 ) { dp [ i ] = max ( dp [ i ] , 1 + dp [ mpp [ xx ] ] ) ; } } mpp [ A [ i ] ] = i ; } int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { ans = max ( ans , dp [ i ] ) ; } return ans ; }
void initialize ( ) { for ( int i = 0 ; i <= N ; i += 1 ) { for ( int j = 1 ; j <= RODS ; j ++ ) { for ( int k = 1 ; k <= RODS ; k += 1 ) { dp [ i ] [ j ] [ k ] = INT_MAX ; } } } }
int mincost ( int idx , int src , int dest , int costs [ RODS ] [ RODS ] ) { if ( idx > N ) return 0 ; if ( dp [ idx ] [ src ] [ dest ] != INT_MAX ) return dp [ idx ] [ src ] [ dest ] ; int rem = 6 - ( src + dest ) ; int ans = INT_MAX ; int case1 = costs [ src - 1 ] [ dest - 1 ] + mincost ( idx + 1 , src , rem , costs ) + mincost ( idx + 1 , rem , dest , costs ) ; int case2 = costs [ src - 1 ] [ rem - 1 ] + mincost ( idx + 1 , src , dest , costs ) + mincost ( idx + 1 , dest , src , costs ) + costs [ rem - 1 ] [ dest - 1 ] + mincost ( idx + 1 , src , dest , costs ) ; ans = min ( case1 , case2 ) ; dp [ idx ] [ src ] [ dest ] = ans ; return ans ; }
int MaxGCD ( int a [ ] , int n ) { int Prefix [ n + 2 ] ; int Suffix [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = __gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = __gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = max ( ans , __gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; }
vector < int > numToVec ( int N ) { vector < int > digit ; while ( N != 0 ) { digit . push_back ( N % 10 ) ; N = N / 10 ; } if ( digit . size ( ) == 0 ) digit . push_back ( 0 ) ; reverse ( digit . begin ( ) , digit . end ( ) ) ; return digit ; }
int solve ( vector < int > & A , int B , int C ) { vector < int > digit ; int d , d2 ; digit = numToVec ( C ) ; d = A . size ( ) ; if ( B > digit . size ( ) d == 0 ) return 0 ; else if ( B < digit . size ( ) ) { if ( A [ 0 ] == 0 && B != 1 ) return ( d - 1 ) * pow ( d , B - 1 ) ; else return pow ( d , B ) ; } else { int dp [ B + 1 ] = { 0 } ; int lower [ MAX + 1 ] = { 0 } ; for ( int i = 0 ; i < d ; i ++ ) lower [ A [ i ] + 1 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) lower [ i ] = lower [ i - 1 ] + lower [ i ] ; bool flag = true ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= B ; i ++ ) { d2 = lower [ digit [ i - 1 ] ] ; dp [ i ] = dp [ i - 1 ] * d ; if ( i == 1 && A [ 0 ] == 0 && B != 1 ) d2 = d2 - 1 ; if ( flag ) dp [ i ] += d2 ; flag = ( flag & ( lower [ digit [ i - 1 ] + 1 ] == lower [ digit [ i - 1 ] ] + 1 ) ) ; } return dp [ B ] ; } }
int LongestConsSeq ( int arr [ ] , int N ) { int maxval = 1 ; for ( int i = 0 ; i < N ; i += 1 ) { maxval = max ( maxval , arr [ i ] ) ; } int dp [ maxval + 1 ] [ 2 ] = { 0 } ; int ans = 1 ; for ( int i = 0 ; i < N ; i += 1 ) { dp [ arr [ i ] ] [ 0 ] = ( 1 + dp [ arr [ i ] - 1 ] [ 0 ] ) ; if ( arr [ i ] >= 2 ) dp [ arr [ i ] ] [ 1 ] = max ( 1 + dp [ arr [ i ] - 1 ] [ 1 ] , 2 + dp [ arr [ i ] - 2 ] [ 0 ] ) ; else dp [ arr [ i ] ] [ 1 ] = 1 ; ans = max ( ans , dp [ arr [ i ] ] [ 1 ] ) ; } return ans ; }
int min ( int p , int q , int r , int s ) { int temp1 = p < q ? p : q ; int temp2 = r < s ? r : s ; if ( temp1 < temp2 ) return temp1 ; return temp2 ; }
int Distance ( int arr [ R ] [ C ] , int i , int j ) { if ( i >= R j >= C i < 0 j < 0  ) return INT_MAX ; else if ( arr [ i ] [ j ] == 0 ) { table [ i ] [ j ] = INT_MAX ; return INT_MAX ; } else if ( arr [ i ] [ j ] == 2 ) { table [ i ] [ j ] = 0 ; return 0 ; } else if ( visited [ i ] [ j ] ) { return INT_MAX ; } else { visited [ i ] [ j ] = 1 ; int temp1 = Distance ( arr , i + 1 , j ) ; int temp2 = Distance ( arr , i - 1 , j ) ; int temp3 = Distance ( arr , i , j + 1 ) ; int temp4 = Distance ( arr , i , j - 1 ) ; int min_value = 1 + min ( temp1 , temp2 , temp3 , temp4 ) ; if ( table [ i ] [ j ] > 0 && table [ i ] [ j ] < INT_MAX ) { if ( min_value < table [ i ] [ j ] ) table [ i ] [ j ] = min_value ; } else table [ i ] [ j ] = min_value ; visited [ i ] [ j ] = 0 ; return table [ i ] [ j ] ; } }
int minTime ( int arr [ ] [ C ] ) { int max = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( arr [ i ] [ j ] == 1 ) Distance ( arr , i , j ) ; } } for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( arr [ i ] [ j ] == 1 && table [ i ] [ j ] > max ) max = table [ i ] [ j ] ; } } if ( max < INT_MAX ) return max ; return -1 ; }
int findDepthRec ( char tree [ ] , int n , int & index ) { if ( index >= n tree [ index ] == 'l' ) return 0 ; index ++ ; int left = findDepthRec ( tree , n , index ) ; index ++ ; int right = findDepthRec ( tree , n , index ) ; return max ( left , right ) + 1 ; }
int findDepth ( char tree [ ] , int n ) { int index = 0 ; findDepthRec ( tree , n , index ) ; }
int solve ( string str , int K ) { int N = str . size ( ) ; dp . clear ( ) ; dp . resize ( N , vector < int > ( K , -1 ) ) ; int ans = solveUtil ( 0 , 0 , str , K ) ; return ans == INT_MAX ? -1 : ans ; }
int solve ( string str , int K ) { int n = str . length ( ) ; long long dp [ K ] [ n ] ; memset ( dp , 0 , sizeof dp ) ; if ( n < K ) return -1 ; else if ( n == K ) return 0 ; long long zeroes = 0 , ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) zeroes ++ ; else ones ++ ; dp [ 0 ] [ i ] = ones * zeroes ; } for ( int s = 1 ; s < K ; s ++ ) { for ( int i = 0 ; i < n ; i ++ ) { dp [ s ] [ i ] = INT_MAX ; ones = 0 ; zeroes = 0 ; for ( int k = i ; k >= 0 ; k -- ) { if ( str [ k ] == '0' ) zeroes ++ ; else ones ++ ; dp [ s ] [ i ] = min ( dp [ s ] [ i ] , + ( ( k - 1 >= 0 ) ? ones * zeroes + dp [ s - 1 ] [ k - 1 ] : INT_MAX ) ) ; } } } return ( dp [ K - 1 ] [ n - 1 ] == INT_MAX ) ? -1 : dp [ K - 1 ] [ n - 1 ] ; }
int max_sum ( int a [ ] , int n ) { int dp [ n ] ; if ( n == 1 ) { dp [ 0 ] = max ( 0 , a [ 0 ] ) ; } else if ( n == 2 ) { dp [ 0 ] = max ( 0 , a [ 0 ] ) ; dp [ 1 ] = max ( a [ 1 ] , dp [ 0 ] ) ; } else if ( n >= 3 ) { dp [ 0 ] = max ( 0 , a [ 0 ] ) ; dp [ 1 ] = max ( a [ 1 ] , max ( 0 , a [ 0 ] ) ) ; dp [ 2 ] = max ( a [ 2 ] , max ( a [ 1 ] , max ( 0 , a [ 0 ] ) ) ) ; int i = 3 ; while ( i < n ) { dp [ i ] = max ( dp [ i - 1 ] , a [ i ] + dp [ i - 3 ] ) ; i ++ ; } } return dp [ n - 1 ] ; }
int minCount ( int K ) { int memo [ 100 ] ; for ( int i = 0 ; i < 100 ; i ++ ) { memo [ i ] = INT_MAX ; } memo [ 0 ] = 0 ; for ( int i = 1 ; i < 100 ; i ++ ) { memo [ i ] = min ( memo [ i - 1 ] + 1 , memo [ i ] ) ; } for ( int i = 10 ; i < 100 ; i ++ ) { memo [ i ] = min ( memo [ i - 10 ] + 1 , memo [ i ] ) ; } for ( int i = 25 ; i < 100 ; i ++ ) { memo [ i ] = min ( memo [ i - 25 ] + 1 , memo [ i ] ) ; } long min_count = 0 ; while ( K > 0 ) { min_count += memo [ K % 100 ] ; K /= 100 ; } return min_count ; }
int NoofWays ( int face , int throws , int sum ) { if ( sum == 0 && throws == 0 ) return 1 ; if ( sum < 0 throws == 0  ) return 0 ; if ( dp [ throws ] [ sum ] != -1 ) return dp [ throws ] [ sum ] ; int ans = 0 ; for ( int i = 1 ; i <= face ; i ++ ) { ans += NoofWays ( face , throws - 1 , sum - i ) ; } return dp [ throws ] [ sum ] = ans ; }
void solve ( string & s ) { int n = s . length ( ) ; int dp [ n ] [ n ] ; memset ( dp , 0 , sizeof dp ) ; for ( int len = n - 1 ; len >= 0 ; -- len ) { for ( int i = 0 ; i + len < n ; ++ i ) { int j = i + len ; if ( i == 0 and j == n - 1 ) { if ( s [ i ] == s [ j ] ) dp [ i ] [ j ] = 2 ; else if ( s [ i ] != s [ j ] ) dp [ i ] [ j ] = 1 ; } else { if ( s [ i ] == s [ j ] ) { if ( i - 1 >= 0 ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } if ( j + 1 <= n - 1 ) { dp [ i ] [ j ] += dp [ i ] [ j + 1 ] ; } if ( i - 1 < 0 or j + 1 >= n ) { dp [ i ] [ j ] += 1 ; } } else if ( s [ i ] != s [ j ] ) { if ( i - 1 >= 0 ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } if ( j + 1 <= n - 1 ) { dp [ i ] [ j ] += dp [ i ] [ j + 1 ] ; } if ( i - 1 >= 0 and j + 1 <= n - 1 ) { dp [ i ] [ j ] -= dp [ i - 1 ] [ j + 1 ] ; } } } } } vector < int > ways ; for ( int i = 0 ; i < n ; ++ i ) { if ( i == 0 or i == n - 1 ) { ways . push_back ( 1 ) ; } else { int total = dp [ i - 1 ] [ i + 1 ] ; ways . push_back ( total ) ; } } for ( int i = 0 ; i < ways . size ( ) ; ++ i ) { cout << ways [ i ] << " " ; } }
int maxSum ( int arr [ ] , int i , int n , int k ) { if ( i >= n ) return 0 ; if ( visit [ i ] ) return dp [ i ] ; visit [ i ] = 1 ; int tot = 0 ; dp [ i ] = maxSum ( arr , i + 1 , n , k ) ; for ( int j = i ; j < i + k and j < n ; j ++ ) { tot += arr [ j ] ; dp [ i ] = max ( dp [ i ] , tot + maxSum ( arr , j + 2 , n , k ) ) ; } return dp [ i ] ; }
int get_binary ( int u ) { int ans = 0 ; while ( u ) { int rem = u % 10 ; ans |= ( 1 << rem ) ; u /= 10 ; } return ans ; }
int waysutil ( int index , int sum , int count , vector < int > & arr , int K ) { if ( index < 0 ) return 0 ; if ( index == 0 ) { if ( count == 0 ) return 0 ; int remainder = sum % count ; if ( remainder != 0 ) return 0 ; int average = sum / count ; if ( average == K ) return 1 ; } if ( dp [ index ] [ sum ] [ count ] != -1 ) return dp [ index ] [ sum ] [ count ] ; int dontpick = waysutil ( index - 1 , sum , count , arr , K ) ; int pick = waysutil ( index - 1 , sum + arr [ index ] , count + 1 , arr , K ) ; int total = pick + dontpick ; dp [ index ] [ sum ] [ count ] = total ; return total ; }
int ways ( int N , int K , int * arr ) { vector < int > Arr ; Arr . push_back ( -1 ) ; for ( int i = 0 ; i < N ; ++ i ) { Arr . push_back ( arr [ i ] ) ; } memset ( dp , -1 , sizeof dp ) ; int answer = waysutil ( N , 0 , 0 , Arr , K ) ; return answer ; }
int RetClose ( int a , int b , int s ) { if ( abs ( a - s ) < abs ( b - s ) ) return a ; else return b ; }
void FindClose ( int arr [ ] , int n ) { int ans = inf ; for ( int i = 1 ; i <= n ; i ++ ) ans = RetClose ( arr [ i - 1 ] + MinDiff ( i , arr [ i - 1 ] , arr , n ) , ans , 0 ) ; cout << ans << endl ; }
int FindMax ( int i , int r , int w [ ] , int n , int c , int k ) { if ( i >= n ) return 0 ; if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = FindMax ( i + 1 , r , w , n , c , k ) ; for ( int j = 0 ; j < k ; j ++ ) { int x = ( r / exp_c [ j ] ) % ( c + 1 ) ; if ( x - w [ i ] >= 0 ) dp [ i ] [ r ] = max ( dp [ i ] [ r ] , w [ i ] + FindMax ( i + 1 , r - w [ i ] * exp_c [ j ] , w , n , c , k ) ) ; } return dp [ i ] [ r ] ; }
int PreCompute ( int n , int c , int k ) { exp_c . resize ( k ) ; exp_c [ 0 ] = 1 ; for ( int i = 1 ; i < k ; i ++ ) { exp_c [ i ] = ( exp_c [ i - 1 ] * ( c + 1 ) ) ; } dp . resize ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] . resize ( exp_c [ k - 1 ] * ( c + 1 ) , 0 ) ; } v . resize ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { v [ i ] . resize ( exp_c [ k - 1 ] * ( c + 1 ) , 0 ) ; } int R = 0 ; for ( int i = 0 ; i < k ; i ++ ) { R += exp_c [ i ] * c ; } return R ; }
int findMax ( int i , int r , int w [ ] , int n ) { if ( r < 0 ) return INT_MIN ; if ( i == n ) return 0 ; if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = max ( w [ i ] + findMax ( i + 1 , r - w [ i ] , w , n ) , findMax ( i + 1 , r , w , n ) ) ; return dp [ i ] [ r ] ; }
void preCompute ( int w [ ] , int n ) { for ( int i = C_MAX ; i >= 0 ; i -- ) findMax ( 0 , i , w , n ) ; }
int ansQuery ( int w ) { return dp [ 0 ] [ w ] ; }
int minSum ( int A [ ] , int B [ ] , int C [ ] , int i , int n , int curr , int dp [ SIZE ] [ N ] ) { if ( n <= 0 ) return 0 ; if ( dp [ n ] [ curr ] != -1 ) return dp [ n ] [ curr ] ; if ( curr == 0 ) { return dp [ n ] [ curr ] = min ( B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; } if ( curr == 1 ) return dp [ n ] [ curr ] = min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; return dp [ n ] [ curr ] = min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) ) ; }
void findPrefixSum ( int arr [ ] , int n ) { prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = arr [ i ] + prefix_sum [ i - 1 ] ; }
int maxSum ( int arr [ ] , int i , int n , int k ) { if ( i + k > n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = 1 ; int x ; if ( i == 0 ) x = prefix_sum [ k - 1 ] ; else x = prefix_sum [ i + k - 1 ] - prefix_sum [ i - 1 ] ; dp [ i ] = max ( maxSum ( arr , i + 1 , n , k ) , x + maxSum ( arr , i + k + 1 , n , k ) ) ; return dp [ i ] ; }
ll getChicks ( int n ) { int size = max ( n , 7 ) ; ll dp [ size ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= 6 ; i ++ ) { dp [ i ] = dp [ i - 1 ] * 3 ; } dp [ 7 ] = 726 ; for ( int i = 8 ; i <= n ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] - ( 2 * dp [ i - 6 ] / 3 ) ) * 3 ; } return dp [ n ] ; }
ll getChicks ( int n ) { ll chicks = ( ll ) pow ( 3 , n - 1 ) ; return chicks ; }
int MaximumMarks ( int marksarr [ ] , int timearr [ ] , int h , int n , int p ) { int no_of_topics = n + 1 ; int total_time = h + 1 ; int T [ no_of_topics ] [ total_time ] ; for ( int i = 0 ; i < no_of_topics ; i ++ ) { T [ i ] [ 0 ] = 0 ; } for ( int j = 0 ; j < total_time ; j ++ ) { T [ 0 ] [ j ] = 0 ; } for ( int i = 1 ; i < no_of_topics ; i ++ ) { for ( int j = 1 ; j < total_time ; j ++ ) { if ( j < timearr [ i ] ) { T [ i ] [ j ] = T [ i - 1 ] [ j ] ; } else { T [ i ] [ j ] = max ( marksarr [ i ] + T [ i - 1 ] [ j - timearr [ i ] ] , T [ i - 1 ] [ j ] ) ; } } } int i = no_of_topics - 1 , j = total_time - 1 ; int sum = 0 ; while ( i > 0 && j > 0 ) { if ( T [ i ] [ j ] == T [ i - 1 ] [ j ] ) { i -- ; } else { sum += timearr [ i ] ; j -= timearr [ i ] ; i -- ; } } int marks = T [ no_of_topics - 1 ] [ total_time - 1 ] ; if ( marks < p ) return -1 ; return sum ; }
void findSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; }
int cntWays ( int arr [ ] , int i , int ck , int k , int n , int curr_sum ) { if ( sum % k != 0 ) return 0 ; if ( i != n and ck == k + 1 ) return 0 ; if ( i == n ) { if ( ck == k + 1 ) return 1 ; else return 0 ; } if ( v [ i ] [ ck ] ) return dp [ i ] [ ck ] ; curr_sum += arr [ i ] ; v [ i ] [ ck ] = 1 ; dp [ i ] [ ck ] = cntWays ( arr , i + 1 , ck , k , n , curr_sum ) ; if ( curr_sum == ( sum / k ) * ck ) dp [ i ] [ ck ] += cntWays ( arr , i + 1 , ck + 1 , k , n , curr_sum ) ; return dp [ i ] [ ck ] ; }
int SubsetCnt ( int i , int s , int arr [ ] , int n ) { if ( i == n ) { if ( s == 0 ) return 1 ; else return 0 ; } if ( visit [ i ] [ s + maxSum ] ) return dp [ i ] [ s + maxSum ] ; visit [ i ] [ s + maxSum ] = 1 ; dp [ i ] [ s + maxSum ] = SubsetCnt ( i + 1 , s + arr [ i ] , arr , n ) + SubsetCnt ( i + 1 , s , arr , n ) ; return dp [ i ] [ s + maxSum ] ; }
int sumMax ( int i , int arr [ ] , int n ) { if ( i >= n - 1 ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = true ; dp [ i ] = max ( arr [ i ] + arr [ i + 1 ] + sumMax ( i + 3 , arr , n ) , sumMax ( i + 1 , arr , n ) ) ; return dp [ i ] ; }
int MaxIncreasingSub ( int arr [ ] , int n , int k ) { int dp [ n ] [ k + 1 ] , ans = -1 ; memset ( dp , -1 , sizeof ( dp ) ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ 1 ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { for ( int l = 1 ; l <= k - 1 ; l ++ ) { if ( dp [ j ] [ l ] != -1 ) { dp [ i ] [ l + 1 ] = max ( dp [ i ] [ l + 1 ] , dp [ j ] [ l ] + arr [ i ] ) ; } } } } } for ( int i = 0 ; i < n ; i ++ ) { if ( ans < dp [ i ] [ k ] ) ans = dp [ i ] [ k ] ; } return ( ans == -1 ) ? 0 : ans ; }
void solve ( int remSum , int maxVal , int idx , int & count ) { if ( remSum == 0 ) { print ( idx ) ; count ++ ; return ; } for ( int i = maxVal ; i >= 1 ; i -- ) { if ( i > remSum ) { continue ; } else if ( i <= remSum ) { dp [ idx ] = i ; solve ( remSum - i , i , idx + 1 , count ) ; } } }
void findPrefixCount ( int arr [ ] [ n ] ) { for ( int i = 0 ; i < bitscount ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { prefix_count [ i ] [ j ] [ 0 ] = ( ( arr [ j ] [ 0 ] >> i ) & 1 ) ; for ( int k = 1 ; k < n ; k ++ ) { prefix_count [ i ] [ j ] [ k ] = ( ( arr [ j ] [ k ] >> i ) & 1 ) ; prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j ] [ k - 1 ] ; } } } for ( int i = 0 ; i < bitscount ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) for ( int k = 0 ; k < n ; k ++ ) prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j - 1 ] [ k ] ; }
int rangeOr ( int x1 , int y1 , int x2 , int y2 ) { int ans = 0 ; for ( int i = 0 ; i < bitscount ; i ++ ) { int p ; if ( x1 == 0 and y1 == 0 ) p = prefix_count [ i ] [ x2 ] [ y2 ] ; else if ( x1 == 0 ) p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x2 ] [ y1 - 1 ] ; else if ( y1 == 0 ) p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x1 - 1 ] [ y2 ] ; else p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x1 - 1 ] [ y2 ] - prefix_count [ i ] [ x2 ] [ y1 - 1 ] + prefix_count [ i ] [ x1 - 1 ] [ y1 - 1 ] ; if ( p != 0 ) ans = ( ans | ( 1 << i ) ) ; } return ans ; }
void findPrefixCount ( int arr [ ] [ n ] ) { for ( int i = 0 ; i < bitscount ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { prefix_count [ i ] [ j ] [ 0 ] = ( ( arr [ j ] [ 0 ] >> i ) & 1 ) ; for ( int k = 1 ; k < n ; k ++ ) { prefix_count [ i ] [ j ] [ k ] = ( ( arr [ j ] [ k ] >> i ) & 1 ) ; prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j ] [ k - 1 ] ; } } } for ( int i = 0 ; i < bitscount ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) for ( int k = 0 ; k < n ; k ++ ) prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j - 1 ] [ k ] ; }
void findPrefixCount ( int arr [ ] , int n ) { for ( int i = 0 ; i < bitscount ; i ++ ) { prefix_count [ i ] [ 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) ; for ( int j = 1 ; j < n ; j ++ ) { prefix_count [ i ] [ j ] = ( ( arr [ j ] >> i ) & 1 ) ; prefix_count [ i ] [ j ] += prefix_count [ i ] [ j - 1 ] ; } } }
int rangeOr ( int l , int r ) { int ans = 0 ; for ( int i = 0 ; i < bitscount ; i ++ ) { int x ; if ( l == 0 ) x = prefix_count [ i ] [ r ] ; else x = prefix_count [ i ] [ r ] - prefix_count [ i ] [ l - 1 ] ; if ( x != 0 ) ans = ( ans | ( 1 << i ) ) ; } return ans ; }
int palindromeSubStrs ( string s ) { int dp [ s . size ( ) ] [ s . size ( ) ] ; int st , end , i , j , len ; map < string , bool > m ; for ( i = 0 ; i < s . size ( ) ; i ++ ) { dp [ i ] [ i ] = 1 ; m [ string ( s . begin ( ) + i , s . begin ( ) + i + 1 ) ] = 1 ; } for ( i = 0 ; i < s . size ( ) - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { dp [ i ] [ i + 1 ] = 1 ; m [ string ( s . begin ( ) + i , s . begin ( ) + i + 2 ) ] = 1 ; } else { dp [ i ] [ i + 1 ] = 0 ; } } for ( len = 3 ; len <= s . size ( ) ; len ++ ) { for ( st = 0 ; st <= s . size ( ) - len ; st ++ ) { end = st + len - 1 ; if ( s [ st ] == s [ end ] && dp [ st + 1 ] [ end - 1 ] ) { dp [ st ] [ end ] = 1 ; m [ string ( s . begin ( ) + st , s . begin ( ) + end + 1 ) ] = 1 ; } else dp [ st ] [ end ] = 0 ; } } return m . size ( ) ; }
int maxSum ( int arr [ ] , int i , int n ) { if ( i >= n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = 1 ; dp [ i ] = max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) ; return dp [ i ] ; }
int countWays ( int i , int j , int x , int arr [ ] [ n ] ) { if ( i == n j == n ) return 0 ; x = ( x & arr [ i ] [ j ] ) ; if ( x == 0 ) return 0 ; if ( i == n - 1 && j == n - 1 ) return 1 ; if ( v [ i ] [ j ] [ x ] ) return dp [ i ] [ j ] [ x ] ; v [ i ] [ j ] [ x ] = 1 ; dp [ i ] [ j ] [ x ] = countWays ( i + 1 , j , x , arr ) + countWays ( i , j + 1 , x , arr ) ; return dp [ i ] [ j ] [ x ] ; }
int minSteps ( int i , int j , int arr [ ] [ n ] ) { if ( i == n - 1 and j == n - 1 ) return 0 ; if ( i > n - 1 j > n - 1 ) return 9999999 ; if ( v [ i ] [ j ] ) return dp [ i ] [ j ] ; v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 9999999 ; for ( int k = max ( 0 , arr [ i ] [ j ] + j - n + 1 ) ; k <= min ( n - i - 1 , arr [ i ] [ j ] ) ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , minSteps ( i + k , j + arr [ i ] [ j ] - k , arr ) ) ; } dp [ i ] [ j ] ++ ; return dp [ i ] [ j ] ; }
int minSteps ( int i , int j , int arr [ ] [ n ] ) { if ( i == n - 1 and j == n - 1 ) return 0 ; if ( i > n - 1 j > n - 1 ) return 9999999 ; if ( v [ i ] [ j ] ) return dp [ i ] [ j ] ; v [ i ] [ j ] = 1 ; dp [ i ] [ j ] = 1 + min ( minSteps ( i + arr [ i ] [ j ] , j , arr ) , minSteps ( i , j + arr [ i ] [ j ] , arr ) ) ; return dp [ i ] [ j ] ; }
int oSRec ( int arr [ ] , int i , int j , int sum ) { if ( j == i + 1 ) return max ( arr [ i ] , arr [ j ] ) ; return max ( ( sum - oSRec ( arr , i + 1 , j , sum - arr [ i ] ) ) , ( sum - oSRec ( arr , i , j - 1 , sum - arr [ j ] ) ) ) ; }
int optimalStrategyOfGame ( int * arr , int n ) { int sum = 0 ; sum = accumulate ( arr , arr + n , sum ) ; return oSRec ( arr , 0 , n - 1 , sum ) ; }
int oSRec ( int arr [ ] , int i , int j , int sum ) { if ( j == i + 1 ) return max ( arr [ i ] , arr [ j ] ) ; if ( memo [ i ] [ j ] != -1 ) return memo [ i ] [ j ] ; memo [ i ] [ j ] = max ( ( sum - oSRec ( arr , i + 1 , j , sum - arr [ i ] ) ) , ( sum - oSRec ( arr , i , j - 1 , sum - arr [ j ] ) ) ) ; return memo [ i ] [ j ] ; }
int optimalStrategyOfGame ( int * arr , int n ) { int sum = 0 ; sum = accumulate ( arr , arr + n , sum ) ; memset ( memo , -1 , sizeof ( memo ) ) ; return oSRec ( arr , 0 , n - 1 , sum ) ; }
ll number ( string s , int i , int j ) { ll ans = 0 ; for ( int x = i ; x < j ; x ++ ) { ans = ans * 2 + ( s [ x ] - '0' ) ; } return ans ; }
int minCuts ( string s , int n ) { int dp [ n + 1 ] ; memset ( dp , n + 1 , sizeof ( dp ) ) ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( s [ i - 1 ] == '0' ) continue ; for ( int j = 0 ; j < i ; j ++ ) { if ( s [ j ] == '0' ) continue ; ll num = number ( s , j , i ) ; if ( ! ispower ( num ) ) continue ; dp [ i ] = min ( dp [ i ] , dp [ j ] + 1 ) ; } } return ( ( dp [ n ] < n + 1 ) ? dp [ n ] : -1 ) ; }
int sum ( int i1 , int j1 , int i2 , int j2 ) { if ( i1 == i2 && j1 == j2 ) { return arr [ i1 ] [ j1 ] ; } return arr [ i1 ] [ j1 ] + arr [ i2 ] [ j2 ] ; }
int MinOfCubed ( int k ) { if ( k < 8 ) return k ; int res = k ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }
int MinOfCubedDP ( int k ) { int * DP = new int [ k + 1 ] , j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { DP [ i ] = INT_MAX ; while ( j <= i ) { if ( j == i ) DP [ i ] = 1 ; else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ; t ++ ; j = t * t * t ; } t = j = 1 ; } return DP [ k ] ; }
int getMaximumSum ( int a [ ] , int n , int x ) { int dp [ n ] [ 3 ] ; memset ( dp , -1 , sizeof dp ) ; int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) maxi = max ( maxi , func ( i , 0 , a , dp , n , x ) ) ; return maxi ; }
void pre_process ( bool dp [ N ] [ N ] , string s ) { int n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = false ; } for ( int j = 1 ; j <= n ; j ++ ) { for ( int i = 0 ; i <= n - j ; i ++ ) { if ( j <= 2 ) { if ( s [ i ] == s [ i + j - 1 ] ) dp [ i ] [ i + j - 1 ] = true ; } else if ( s [ i ] == s [ i + j - 1 ] ) dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] ; } } }
int countPairs ( string s ) { bool dp [ N ] [ N ] ; pre_process ( dp , s ) ; int n = s . length ( ) ; int left [ n ] ; memset ( left , 0 , sizeof left ) ; int right [ n ] ; memset ( right , 0 , sizeof right ) ; left [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( dp [ j ] [ i ] == 1 ) left [ i ] ++ ; } } right [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { right [ i ] = right [ i + 1 ] ; for ( int j = n - 1 ; j >= i ; j -- ) { if ( dp [ i ] [ j ] == 1 ) right [ i ] ++ ; } } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) ans += left [ i ] * right [ i + 1 ] ; return ans ; }
void answerQuery ( int l , int r , bool dp [ N ] [ N ] ) { if ( dp [ l ] [ r ] ) cout << "Yes\n" ; else cout << "No\n" ; }
int LIS ( int a [ ] , int n ) { int dp [ N ] , d [ N ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( int j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; }
bool check ( string & s ) { int n = s . length ( ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( s [ i ] == '1' && s [ i - 1 ] == '1' && s [ i - 2 ] == '1' ) return 1 ; } return 0 ; }
int solve ( int i , int x , int dp [ ] [ 4 ] ) { if ( i < 0 ) return x == 3 ; if ( dp [ i ] [ x ] != -1 ) return dp [ i ] [ x ] ; dp [ i ] [ x ] = solve ( i - 1 , 0 , dp ) ; dp [ i ] [ x ] += solve ( i - 1 , x + 1 , dp ) ; return dp [ i ] [ x ] ; }
void dfs ( int u , int p ) { for ( int i = 0 ; i < g [ u ] . size ( ) ; i ++ ) { int v = g [ u ] [ i ] ; if ( v != p ) { dfs ( v , u ) ; for ( int i = 0 ; i < 22 ; i ++ ) a [ u ] [ i ] += a [ v ] [ i ] ; } } int pp = 0 ; for ( int i = 0 ; i < 22 ; i ++ ) { if ( ! ( ( a [ u ] [ i ] > 0 && x [ i ] - a [ u ] [ i ] > 0 ) || ( a [ u ] [ i ] == 0 && x [ i ] == 0 ) ) ) { pp = 1 ; break ; } } if ( pp == 0 ) ans ++ ; }
int findCount ( int mat [ ] [ n ] , int i , int j , int m ) { if ( i == 0 && j == 0 ) { if ( m == mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; } if ( m < 0 ) return 0 ; if ( i < 0 j < 0  ) return 0 ; if ( v [ i ] [ j ] [ m ] ) return dp [ i ] [ j ] [ m ] ; v [ i ] [ j ] [ m ] = true ; dp [ i ] [ j ] [ m ] = findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ; return dp [ i ] [ j ] [ m ] ; }
int maxSum ( int * arr , int k , int n ) { if ( n == 0 ) return 0 ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return max ( arr [ 0 ] , arr [ 1 ] ) ; int dp [ n ] ; dp [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i <= k ; i ++ ) dp [ i ] = max ( arr [ i ] , dp [ i - 1 ] ) ; for ( int i = k + 1 ; i < n ; i ++ ) dp [ i ] = max ( arr [ i ] , dp [ i - ( k + 1 ) ] + arr [ i ] ) ; int max = * ( std :: max_element ( dp , dp + n ) ) ; return max ; }
vector < int > precompute ( ) { vector < int > dp ( maxn , -1 ) ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < maxn ; ++ i ) { for ( auto j : vector < int > { 4 , 6 , 9 } ) { if ( i >= j && dp [ i - j ] != -1 ) { dp [ i ] = max ( dp [ i ] , dp [ i - j ] + 1 ) ; } } } return dp ; }
int CountWays ( int r , int b , int l , int R , int B , int W , int dp [ RUNMAX ] [ BALLMAX ] [ WICKETMAX ] ) { if ( l > W ) return 0 ; if ( r > R ) return 0 ; if ( b == B && r == R ) return 1 ; if ( b == B ) return 0 ; if ( dp [ r ] [ b ] [ l ] != -1 ) return dp [ r ] [ b ] [ l ] ; int ans = 0 ; ans += CountWays ( r , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 1 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 2 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 3 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 4 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 6 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r , b + 1 , l + 1 , R , B , W , dp ) ; ans = ans % mod ; return dp [ r ] [ b ] [ l ] = ans ; }
int FindMinimumCost ( int ind , int a [ ] , int n , int k , int dp [ ] ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != -1 ) return dp [ ind ] ; else { int ans = INT_MAX ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } }
int minCostJumpsDP ( vector < int > & A , int k ) { int size = A . size ( ) ; vector < int > x ( size , INT_MAX ) ; x [ 0 ] = 0 ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = i + 1 ; j < i + k + 1 ; j ++ ) { x [ j ] = min ( x [ j ] , x [ i ] + abs ( A [ i ] - A [ j ] ) ) ; } } return x [ size - 1 ] ; }
int FindMaximumSum ( int ind , int kon , int a [ ] , int b [ ] , int c [ ] , int n , int dp [ ] [ N ] ) { if ( ind == n ) return 0 ; if ( dp [ ind ] [ kon ] != -1 ) return dp [ ind ] [ kon ] ; int ans = -1e9 + 5 ; if ( kon == 0 ) { ans = max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; } else if ( kon == 1 ) { ans = max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; ans = max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; } else if ( kon == 2 ) { ans = max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; } return dp [ ind ] [ kon ] = ans ; }
bool isVowel ( char x ) { return ( x == 'a' x == 'e' x == 'i' x == 'o' x == 'u' ) ; }
int findMinimumDeletion ( int l , int r , int dp [ N ] [ N ] , string s ) { if ( l > r ) return 0 ; if ( l == r ) return 1 ; if ( dp [ l ] [ r ] != -1 ) return dp [ l ] [ r ] ; int res = 1 + findMinimumDeletion ( l + 1 , r , dp , s ) ; for ( int i = l + 1 ; i <= r ; ++ i ) { if ( s [ l ] == s [ i ] ) res = min ( res , findMinimumDeletion ( l + 1 , i - 1 , dp , s ) + findMinimumDeletion ( i , r , dp , s ) ) ; } return dp [ l ] [ r ] = res ; }
int noOfBinaryStrings ( int N , int k ) { int dp [ 100002 ] ; for ( int i = 1 ; i <= k - 1 ; i ++ ) { dp [ i ] = 1 ; } dp [ k ] = 2 ; for ( int i = k + 1 ; i <= N ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; } return dp [ N ] ; }
long long answer ( int n ) { int dp [ 10 ] ; int prev [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { prev [ j ] = dp [ j ] ; } for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ j ] = prev [ j + 1 ] ; else if ( j == 9 ) dp [ j ] = prev [ j - 1 ] ; else dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ] ; } } long long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ j ] ; return sum ; }
int MinimumCost ( int a [ ] , int n , int x ) { for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = min ( a [ i ] , 2 * a [ i - 1 ] ) ; } int ind = 0 ; int sum = 0 ; while ( x ) { if ( x & 1 ) sum += a [ ind ] ; ind ++ ; x = x >> 1 ; } return sum ; }
void dfs ( int node , vector < int > adj [ ] , int dp [ ] , bool vis [ ] ) { vis [ node ] = true ; for ( int i = 0 ; i < adj [ node ] . size ( ) ; i ++ ) { if ( ! vis [ adj [ node ] [ i ] ] ) dfs ( adj [ node ] [ i ] , adj , dp , vis ) ; dp [ node ] = max ( dp [ node ] , 1 + dp [ adj [ node ] [ i ] ] ) ; } }
void sieve_modified ( ) { for ( int i = 2 ; i < MAX ; i += 2 ) { for ( int j = i ; j < MAX ; j += i ) prefix [ j ] += i ; } for ( int i = 1 ; i < MAX ; i ++ ) prefix [ i ] += prefix [ i - 1 ] ; }
void binomialCoeff ( int n ) { int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } }
int findSubarraySum ( int ind , int flips , int n , int a [ ] , int k ) { if ( flips > k ) return -1e9 ; if ( ind == n ) return 0 ; if ( dp [ ind ] [ flips ] != -1 ) return dp [ ind ] [ flips ] ; int ans = 0 ; ans = max ( 0 , a [ ind ] + findSubarraySum ( ind + 1 , flips , n , a , k ) ) ; ans = max ( ans , - a [ ind ] + findSubarraySum ( ind + 1 , flips + 1 , n , a , k ) ) ; return dp [ ind ] [ flips ] = ans ; }
void catalanDP ( ll n ) { catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } }
int CatalanSequence ( int arr [ ] , int n ) { catalanDP ( n ) ; unordered_multiset < int > s ; int a = 1 , b = 1 ; int c ; s . insert ( a ) ; if ( n >= 2 ) s . insert ( b ) ; for ( int i = 2 ; i < n ; i ++ ) { s . insert ( catalan [ i ] ) ; } unordered_multiset < int > :: iterator it ; for ( int i = 0 ; i < n ; i ++ ) { it = s . find ( arr [ i ] ) ; if ( it != s . end ( ) ) s . erase ( it ) ; } return s . size ( ) ; }
int findSubsequence ( int arr [ ] , int n ) { int len = 1 ; int tmp ; int i , j , d ; int dp [ n ] [ 10 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; int cnt [ 10 ] ; int locMax ; tmp = arr [ 0 ] ; while ( tmp > 0 ) { dp [ 0 ] [ tmp % 10 ] = 1 ; tmp /= 10 ; } for ( i = 1 ; i < n ; i ++ ) { tmp = arr [ i ] ; locMax = 1 ; memset ( cnt , 0 , sizeof ( cnt ) ) ; while ( tmp > 0 ) { cnt [ tmp % 10 ] = 1 ; tmp /= 10 ; } for ( d = 0 ; d <= 9 ; d ++ ) { if ( cnt [ d ] ) { dp [ i ] [ d ] = 1 ; for ( j = 0 ; j < i ; j ++ ) { dp [ i ] [ d ] = max ( dp [ i ] [ d ] , dp [ j ] [ d ] + 1 ) ; locMax = max ( dp [ i ] [ d ] , locMax ) ; } } } for ( d = 0 ; d <= 9 ; d ++ ) { if ( cnt [ d ] ) { dp [ i ] [ d ] = locMax ; } } len = max ( len , locMax ) ; } return len ; }
int solve ( int x ) { vector < int > num ; while ( x ) { num . push_back ( x % 10 ) ; x /= 10 ; } reverse ( num . begin ( ) , num . end ( ) ) ; memset ( dp , -1 , sizeof ( dp ) ) ; return count ( 0 , 0 , 0 , 0 , num ) ; }
void Add_edge ( int x , int y ) { gr [ x ] . push_back ( y ) ; gr [ y ] . push_back ( x ) ; }
void dfs ( int v , int par ) { d [ v ] [ 0 ] = 1 ; for ( auto i : gr [ v ] ) { if ( i != par ) { dfs ( i , v ) ; for ( int j = 1 ; j <= k ; j ++ ) ans += d [ i ] [ j - 1 ] * d [ v ] [ k - j ] ; for ( int j = 1 ; j <= k ; j ++ ) d [ v ] [ j ] += d [ i ] [ j - 1 ] ; } } }
int count ( int pos , int sum , int rem , int tight , int nonz , vector < int > num ) { if ( pos == num . size ( ) ) { if ( rem == 0 && sum == n ) return 1 ; return 0 ; } if ( dp [ pos ] [ sum ] [ rem ] [ tight ] != -1 ) return dp [ pos ] [ sum ] [ rem ] [ tight ] ; int ans = 0 ; int limit = ( tight ? 9 : num [ pos ] ) ; for ( int d = 0 ; d <= limit ; d ++ ) { if ( d == 0 && nonz ) continue ; int currSum = sum + d ; int currRem = ( rem * 10 + d ) % m ; int currF = tight || ( d < num [ pos ] ) ; ans += count ( pos + 1 , currSum , currRem , currF , nonz d , num ) ; } return dp [ pos ] [ sum ] [ rem ] [ tight ] = ans ; }
int findXorSum ( int arr [ ] , int n ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { int c_odd = 0 ; bool odd = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) odd = ( ! odd ) ; if ( odd ) c_odd ++ ; } for ( int j = 0 ; j < n ; j ++ ) { sum += ( mul * c_odd ) ; if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) c_odd = ( n - j - c_odd ) ; } mul *= 2 ; } return sum ; }
void preCompute ( ) { memset ( lpd , 0 , sizeof ( lpd ) ) ; lpd [ 0 ] = lpd [ 1 ] = 1 ; for ( int i = 2 ; i * i < MAX ; i ++ ) { for ( int j = i * 2 ; j < MAX ; j += i ) { if ( lpd [ j ] == 0 ) { lpd [ j ] = i ; } } } for ( int i = 2 ; i < MAX ; i ++ ) { if ( lpd [ i ] == 0 ) { lpd [ i ] = i ; } } }
int maxLengthSubsequence ( int arr [ ] , int n ) { int dp [ N ] ; unordered_map < int , int > pos ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { while ( arr [ i ] > 1 ) { int p = lpd [ arr [ i ] ] ; if ( pos [ p ] ) { dp [ i ] = max ( dp [ i ] , 1 + dp [ pos [ p ] ] ) ; } pos [ p ] = i ; while ( arr [ i ] % p == 0 ) arr [ i ] /= p ; } } int ans = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { ans = max ( ans , dp [ i ] ) ; } return ans ; }
int charVal ( string s , int i ) { if ( s [ i ] == '0' ) return 0 ; else if ( s [ i ] == '1' ) return 1 ; else return 2 ; }
int getSum ( int r1 , int r2 , int c1 , int c2 , int dp [ N + 1 ] [ N + 1 ] ) { return dp [ r2 ] [ c2 ] - dp [ r2 ] [ c1 ] - dp [ r1 ] [ c2 ] + dp [ r1 ] [ c1 ] ; }
bool sumFound ( int K , int S , int grid [ N ] [ N ] ) { int dp [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) dp [ i + 1 ] [ j + 1 ] = dp [ i + 1 ] [ j ] + dp [ i ] [ j + 1 ] - dp [ i ] [ j ] + grid [ i ] [ j ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) { int sum = getSum ( i , i + K , j , j + K , dp ) ; if ( sum == S ) return true ; } return false ; }
int totalSubSets ( ll n , ll l , ll r ) { ll zero = floor ( ( double ) r / 3 ) - ceil ( ( double ) l / 3 ) + 1 ; ll one = floor ( ( double ) ( r - 1 ) / 3 ) - ceil ( ( double ) ( l - 1 ) / 3 ) + 1 ; ll two = floor ( ( double ) ( r - 2 ) / 3 ) - ceil ( ( double ) ( l - 2 ) / 3 ) + 1 ; ll dp [ n ] [ 3 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = zero ; dp [ 0 ] [ 1 ] = one ; dp [ 0 ] [ 2 ] = two ; for ( ll i = 1 ; i < n ; ++ i ) { dp [ i ] [ 0 ] = ( ( dp [ i - 1 ] [ 0 ] * zero ) + ( dp [ i - 1 ] [ 1 ] * two ) + ( dp [ i - 1 ] [ 2 ] * one ) ) % MOD ; dp [ i ] [ 1 ] = ( ( dp [ i - 1 ] [ 0 ] * one ) + ( dp [ i - 1 ] [ 1 ] * zero ) + ( dp [ i - 1 ] [ 2 ] * two ) ) % MOD ; dp [ i ] [ 2 ] = ( ( dp [ i - 1 ] [ 0 ] * two ) + ( dp [ i - 1 ] [ 1 ] * one ) + ( dp [ i - 1 ] [ 2 ] * zero ) ) % MOD ; } return dp [ n - 1 ] [ 0 ] ; }
int solve ( int idx , int diff , int N , int M , int K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx ] [ diff ] != -1 ) return dp [ idx ] [ diff ] ; int ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; return dp [ idx ] [ diff ] = ans % MOD ; }
int maxPathSum ( int tri [ ] [ N ] ) { int ans = 0 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < N - i ; j ++ ) { if ( j - 1 >= 0 ) tri [ i ] [ j ] += max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; ans = max ( ans , tri [ i ] [ j ] ) ; } } return ans ; }
int subsetXOR ( int arr [ ] , int n , int K ) { int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; int m = ( 1 << ( int ) ( log2 ( max_ele ) + 1 ) ) - 1 ; int dp [ n + 1 ] [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) for ( int k = 0 ; k <= n ; k ++ ) dp [ i ] [ j ] [ k ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { for ( int k = 0 ; k <= n ; k ++ ) { dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] ; if ( k != 0 ) { dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] ; } } } } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ans += dp [ n ] [ K ] [ i ] ; } return ans ; }
float calcProbability ( int M [ ] [ m ] , int k ) { float dp [ m ] [ n ] , sum [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { dp [ 0 ] [ j ] = M [ 0 ] [ j ] ; sum [ 0 ] += dp [ 0 ] [ j ] ; } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] / sum [ i - 1 ] + M [ i ] [ j ] ; sum [ i ] += dp [ i ] [ j ] ; } } return dp [ n - 1 ] [ k - 1 ] / sum [ n - 1 ] ; }
int MaximumNumbers ( string s ) { int n = s . length ( ) ; vector < int > remIndex ( 3 , -1 ) ; remIndex [ 0 ] = 0 ; vector < int > res ( n + 1 ) ; int r = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { r = ( r + s [ i - 1 ] - '0' ) % 3 ; res [ i ] = res [ i - 1 ] ; if ( remIndex [ r ] != -1 ) res [ i ] = max ( res [ i ] , res [ remIndex [ r ] ] + 1 ) ; remIndex [ r ] = i + 1 ; } return res [ n ] ; }
int get_max_splits ( string num_string ) { int count = 0 , current_num ; int running_sum = 0 ; for ( int i = 0 ; i < num_string . length ( ) ; i ++ ) { current_num = num_string [ i ] - '0' ; running_sum += current_num ; if ( current_num % 3 == 0 || ( running_sum != 0 && running_sum % 3 == 0 ) ) { count += 1 ; running_sum = 0 ; } } return count ; }
int findMinimumSteps ( int mat [ size ] [ size ] , int x , int y , int n ) { int dist [ n ] [ n ] , i , j , k ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 0 ) dist [ i ] [ j ] = INF ; else dist [ i ] [ j ] = 1 ; if ( i == j ) dist [ i ] [ j ] = 1 ; } } for ( k = 0 ; k < n ; k ++ ) { for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; } } } if ( dist [ x ] [ y ] < INF ) return dist [ x ] [ y ] ; else return -1 ; }
bool findmatch ( char mat [ r ] , string pat , int x , int y , int nrow , int ncol , int level ) { int l = pat . length ( ) ; if ( level == l ) return true ; if ( x < 0 y < 0 x > = nrow y > = ncol ) return false ; if ( mat [ x ] [ y ] == pat [ level ] ) { char temp = mat [ x ] [ y ] ; mat [ x ] [ y ] = '#' ; bool res = findmatch ( mat , pat , x - 1 , y , nrow , ncol , level + 1 ) | findmatch ( mat , pat , x + 1 , y , nrow , ncol , level + 1 ) | findmatch ( mat , pat , x , y - 1 , nrow , ncol , level + 1 ) | findmatch ( mat , pat , x , y + 1 , nrow , ncol , level + 1 ) ; mat [ x ] [ y ] = temp ; return res ; } return false ; }
bool checkMatch ( char mat [ r ] , string pat , int nrow , int ncol ) { int l = pat . length ( ) ; if ( l > nrow * ncol ) return false ; for ( int i = 0 ; i < nrow ; i ++ ) { for ( int j = 0 ; j < ncol ; j ++ ) { if ( mat [ i ] [ j ] == pat [ 0 ] ) if ( findmatch ( mat , pat , i , j , nrow , ncol , 0 ) ) return true ; } } return false ; }
int countPaths ( int sum , int get , int m , int n , int dp [ ] ) { if ( sum < 0 ) return 0 ; if ( sum == 0 ) return get ; if ( dp [ sum ] [ get ] != -1 ) return dp [ sum ] [ get ] ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == m ) res += countPaths ( sum - i , 1 , m , n , dp ) ; res += countPaths ( sum - i , get , m , n , dp ) ; } dp [ sum ] [ get ] = res ; return dp [ sum ] [ get ] ; }
int countInRange ( int x ) { vector < int > num ; while ( x ) { num . push_back ( x % 10 ) ; x /= 10 ; } reverse ( num . begin ( ) , num . end ( ) ) ; memset ( dp , -1 , sizeof ( dp ) ) ; return countInRangeUtil ( 0 , 0 , 0 , num ) ; }
int solve ( int x ) { vector < int > num ; while ( x ) { num . push_back ( x % 10 ) ; x /= 10 ; } reverse ( num . begin ( ) , num . end ( ) ) ; memset ( dp , -1 , sizeof ( dp ) ) ; return count ( 0 , 0 , 0 , 0 , num ) ; }
long long unsigned int bin ( int a , int b ) { long long unsigned int ans = ( ( fac [ a ] ) / ( fac [ a - b ] * fac [ b ] ) ) ; return ans ; }
long int sumofn ( int n , int k ) { int p = 0 ; long long unsigned int num1 , temp , arr [ 1000 ] ; for ( int j = 1 ; j <= k ; j ++ ) { if ( j == 1 ) { num1 = ( n * ( n + 1 ) ) / 2 ; arr [ p ++ ] = num1 ; temp = num1 ; } else { temp = ( pow ( n + 1 , j + 1 ) - 1 - n ) ; for ( int s = 1 ; s < j ; s ++ ) { temp = temp - ( arr [ j - s - 1 ] * bin ( j + 1 , s + 1 ) ) ; } temp = temp / ( j + 1 ) ; arr [ p ++ ] = temp ; } } temp = arr [ p - 1 ] ; return temp ; }
int findMinOperations ( string S ) { reverse ( S . begin ( ) , S . end ( ) ) ; int n = S . length ( ) ; int dp [ n + 1 ] [ 2 ] ; if ( S [ 0 ] == '0' ) { dp [ 0 ] [ 0 ] = 0 ; } else { dp [ 0 ] [ 0 ] = 1 ; } dp [ 0 ] [ 1 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( S [ i ] == '0' ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] = 1 + min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] ) ; } else { dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 0 ] = 1 + min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) ; } } return dp [ n - 1 ] [ 0 ] ; }
int solve ( int x ) { int ans = 0 , first , last , temp = x ; if ( x < 10 ) return x ; last = x % 10 ; while ( x ) { first = x % 10 ; x /= 10 ; } if ( first <= last ) ans = 9 + temp / 10 ; else ans = 8 + temp / 10 ; return ans ; }
int findMinimumCost ( int n , int x , int y ) { int * dp = new int [ n + 1 ] ; dp [ 1 ] = x ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i & 1 ) { dp [ i ] = min ( dp [ i - 1 ] + x , dp [ ( i + 1 ) / 2 ] + y + x ) ; } else { dp [ i ] = min ( dp [ i - 1 ] + x , dp [ i / 2 ] + y ) ; } } return dp [ n ] ; }
int countWays ( int index , int cnt , int dp [ ] [ max ] , int n , int m , int k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index ] [ cnt ] != -1 ) return dp [ index ] [ cnt ] ; int ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index ] [ cnt ] = ans ; }
int findMinSteps ( int mat [ r ] [ col ] , int n , int m , int dp [ r ] [ col ] , bool vis [ r ] [ col ] ) { if ( n == 0 || m == 0 || n == ( r - 1 ) || m == ( col - 1 ) ) { return 0 ; } if ( dp [ n ] [ m ] != -1 ) return dp [ n ] [ m ] ; vis [ n ] [ m ] = true ; int ans1 , ans2 , ans3 , ans4 ; ans1 = ans2 = ans3 = ans4 = 1e9 ; if ( mat [ n - 1 ] [ m ] == 0 ) { if ( ! vis [ n - 1 ] [ m ] ) ans1 = 1 + findMinSteps ( mat , n - 1 , m , dp , vis ) ; } if ( mat [ n ] [ m + 1 ] == 0 ) { if ( ! vis [ n ] [ m + 1 ] ) ans2 = 1 + findMinSteps ( mat , n , m + 1 , dp , vis ) ; } if ( mat [ n ] [ m - 1 ] == 0 ) { if ( ! vis [ n ] [ m - 1 ] ) ans3 = 1 + findMinSteps ( mat , n , m - 1 , dp , vis ) ; } if ( mat [ n + 1 ] [ m ] == 0 ) { if ( ! vis [ n + 1 ] [ m ] ) ans4 = 1 + findMinSteps ( mat , n + 1 , m , dp , vis ) ; } dp [ n ] [ m ] = min ( ans1 , min ( ans2 , min ( ans3 , ans4 ) ) ) ; return dp [ n ] [ m ] ; }
int minimumSteps ( int mat [ r ] [ col ] , int n , int m ) { int twox = -1 ; int twoy = -1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 2 ) { twox = i ; twoy = j ; break ; } } if ( twox != -1 ) break ; } int dp [ r ] [ col ] ; memset ( dp , -1 , sizeof dp ) ; bool vis [ r ] [ col ] ; memset ( vis , false , sizeof vis ) ; int res = findMinSteps ( mat , twox , twoy , dp , vis ) ; if ( res >= 1e9 ) return -1 ; else return res ; }
int nCr ( int n , int r ) { int ans = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; i ++ ) { ans *= ( n - i ) ; ans /= ( i + 1 ) ; } return ans ; }
int countDerangements ( int n ) { int der [ n + 1 ] ; der [ 0 ] = 1 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
ll countPermutations ( int n , int k ) { ll ans = 0 ; for ( int i = n - k ; i <= n ; i ++ ) { int ways = nCr ( n , i ) ; ans += ways * countDerangements ( n - i ) ; } return ans ; }
int solve ( int dp [ ] [ 2 ] , int wt , int K , int M , int used ) { if ( wt < 0 ) return 0 ; if ( wt == 0 ) { if ( used ) return 1 ; return 0 ; } if ( dp [ wt ] [ used ] != -1 ) return dp [ wt ] [ used ] ; int ans = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( i >= M ) ans += solve ( dp , wt - i , K , M , used 1 ) ; else ans += solve ( dp , wt - i , K , M , used ) ; } return dp [ wt ] [ used ] = ans ; }
int squares ( int i ) { if ( ( i & 1 ) == 1 ) return i / 4 * 2 + 1 ; else return ( i - 1 ) / 4 * 2 + 2 ; }
long bishop_placements ( int n , int k ) { if ( k > 2 * n - 1 ) return 0 ; long dp [ n * 2 ] [ k + 1 ] ; for ( int i = 0 ; i < n * 2 ; i ++ ) { for ( int j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < n * 2 ; i ++ ) dp [ i ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; for ( int i = 2 ; i < n * 2 ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { dp [ i ] [ j ] = dp [ i - 2 ] [ j ] + dp [ i - 2 ] [ j - 1 ] * ( squares ( i ) - j + 1 ) ; } } long ans = 0 ; for ( int i = 0 ; i <= k ; i ++ ) { ans += dp [ n * 2 - 1 ] [ i ] * dp [ n * 2 - 2 ] [ k - i ] ; } return ans ; }
long long sumOddFibonacci ( int n ) { long long Sum [ n + 1 ] ; Sum [ 0 ] = 0 ; Sum [ 1 ] = 1 ; Sum [ 2 ] = 2 ; Sum [ 3 ] = 5 ; Sum [ 4 ] = 10 ; Sum [ 5 ] = 23 ; for ( int i = 6 ; i <= n ; i ++ ) { Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; } return Sum [ n ] ; }
int noOfAssignments ( string & S , int & n , int i , int c_x , int c_y ) { if ( F [ i ] [ c_x ] [ c_y ] != -1 ) return F [ i ] [ c_x ] [ c_y ] ; if ( i == n ) { F [ i ] [ c_x ] [ c_y ] = ! c_x && ! c_y ; return F [ i ] [ c_x ] [ c_y ] ; } if ( S [ i ] == '(' ) { F [ i ] [ c_x ] [ c_y ] = noOfAssignments ( S , n , i + 1 , c_x + 1 , c_y ) + noOfAssignments ( S , n , i + 1 , c_x , c_y + 1 ) ; return F [ i ] [ c_x ] [ c_y ] ; } F [ i ] [ c_x ] [ c_y ] = 0 ; if ( c_x ) F [ i ] [ c_x ] [ c_y ] += noOfAssignments ( S , n , i + 1 , c_x - 1 , c_y ) ; if ( c_y ) F [ i ] [ c_x ] [ c_y ] += noOfAssignments ( S , n , i + 1 , c_x , c_y - 1 ) ; return F [ i ] [ c_x ] [ c_y ] ; }
int noOfAssignments ( string & S , int & n , int i , int c_x ) { if ( F [ i ] [ c_x ] != -1 ) return F [ i ] [ c_x ] ; if ( i == n ) { F [ i ] [ c_x ] = ! c_x ; return F [ i ] [ c_x ] ; } int c_y = C [ i ] - c_x ; if ( S [ i ] == '(' ) { F [ i ] [ c_x ] = noOfAssignments ( S , n , i + 1 , c_x + 1 ) + noOfAssignments ( S , n , i + 1 , c_x ) ; return F [ i ] [ c_x ] ; } F [ i ] [ c_x ] = 0 ; if ( c_x ) F [ i ] [ c_x ] += noOfAssignments ( S , n , i + 1 , c_x - 1 ) ; if ( c_y ) F [ i ] [ c_x ] += noOfAssignments ( S , n , i + 1 , c_x ) ; return F [ i ] [ c_x ] ; }
int MaxProfit ( int treasure [ ] , int color [ ] , int n , int k , int col , int A , int B ) { int sum = 0 ; if ( k == n ) return 0 ; if ( col == color [ k ] ) sum += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; else sum += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) ; return sum ; }
int calculateEvenSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ 2 * n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; int sum = 0 ; for ( int i = 2 ; i <= 2 * n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum += fibo [ i ] ; } return sum ; }
int fib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return ( f [ n ] = 1 ) ; if ( f [ n ] ) return f [ n ] ; int k = ( n & 1 ) ? ( n + 1 ) / 2 : n / 2 ; f [ n ] = ( n & 1 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; }
int calculateEvenSum ( int n ) { return ( fib ( 2 * n + 1 ) - 1 ) ; }
int find ( int index , int openbrk , int n , int adj [ ] [ 2 ] ) { if ( openbrk < 0 ) return MAX_VAL ; if ( index == n ) { if ( openbrk == 0 ) { return 0 ; } return MAX_VAL ; } if ( dp [ index ] [ openbrk ] != -1 ) return dp [ index ] [ openbrk ] ; dp [ index ] [ openbrk ] = min ( adj [ index ] [ 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index ] [ 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) ; return dp [ index ] [ openbrk ] ; }
void gouldSequence ( int n ) { for ( int row_num = 1 ; row_num <= n ; row_num ++ ) { int count = 1 ; int c = 1 ; for ( int i = 1 ; i <= row_num ; i ++ ) { c = c * ( row_num - i ) / i ; if ( c % 2 == 1 ) count ++ ; } cout << count << " " ; } }
int gouldSequence ( ) { arr [ 0 ] = 1 ; int i = 1 ; int p = 1 ; while ( i <= MAX ) { int j = 0 ; while ( j < i ) { arr [ i + j ] = 2 * arr [ j ] ; j ++ ; } i = ( 1 << p ) ; p ++ ; } }
void printSequence ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { cout << arr [ i ] << " " ; } }
int minFallingPathSum ( int ( & A ) [ n ] [ n ] ) { for ( int R = n - 2 ; R >= 0 ; -- R ) { for ( int C = 0 ; C < n ; ++ C ) { int best = A [ R + 1 ] [ C ] ; if ( C > 0 ) best = min ( best , A [ R + 1 ] [ C - 1 ] ) ; if ( C + 1 < n ) best = min ( best , A [ R + 1 ] [ C + 1 ] ) ; A [ R ] [ C ] = A [ R ] [ C ] + best ; } } int ans = INT_MAX ; for ( int i = 0 ; i < n ; ++ i ) ans = min ( ans , A [ 0 ] [ i ] ) ; return ans ; }
int maxPlus ( int ( & arr ) [ n ] [ m ] ) { int ans = INT_MIN ; int left [ N ] [ N ] , right [ N ] [ N ] , up [ N ] [ N ] , down [ N ] [ N ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { left [ i ] [ j ] = max ( 0LL , ( j ? left [ i ] [ j - 1 ] : 0LL ) ) + arr [ i ] [ j ] ; up [ i ] [ j ] = max ( 0LL , ( i ? up [ i - 1 ] [ j ] : 0LL ) ) + arr [ i ] [ j ] ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { right [ i ] [ j ] = max ( 0LL , ( j + 1 == m ? 0LL : right [ i ] [ j + 1 ] ) ) + arr [ i ] [ j ] ; down [ i ] [ j ] = max ( 0LL , ( i + 1 == n ? 0LL : down [ i + 1 ] [ j ] ) ) + arr [ i ] [ j ] ; } } for ( int i = 1 ; i < n - 1 ; ++ i ) for ( int j = 1 ; j < m - 1 ; ++ j ) ans = max ( ans , up [ i - 1 ] [ j ] + down [ i + 1 ] [ j ] + left [ i ] [ j - 1 ] + right [ i ] [ j + 1 ] + arr [ i ] [ j ] ) ; return ans ; }
long long fun ( int marks [ ] , int n ) { long long dp [ n ] , temp ; fill ( dp , dp + n , 1 ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } } else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; }
long getNumberOfWays ( long N , vector < long > Coins ) { vector < long > ways ( N + 1 ) ; ways [ 0 ] = 1 ; for ( int i = 0 ; i < Coins . size ( ) ; i ++ ) { for ( int j = 0 ; j < ways . size ( ) ; j ++ ) { if ( Coins [ i ] <= j ) { ways [ j ] += ways [ ( j - Coins [ i ] ) ] ; } } } return ways [ N ] ; }
int countStaircases ( int N ) { int memo [ N + 5 ] [ N + 5 ] ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { memo [ i ] [ j ] = 0 ; } } memo [ 3 ] [ 2 ] = memo [ 4 ] [ 2 ] = 1 ; for ( int i = 5 ; i <= N ; i ++ ) { for ( int j = 2 ; j <= i ; j ++ ) { if ( j == 2 ) { memo [ i ] [ j ] = memo [ i - j ] [ j ] + 1 ; } else { memo [ i ] [ j ] = memo [ i - j ] [ j ] + memo [ i - j ] [ j - 1 ] ; } } } int answer = 0 ; for ( int i = 1 ; i <= N ; i ++ ) answer = answer + memo [ N ] [ i ] ; return answer ; }
long long partitions ( int n ) { vector < long long > p ( n + 1 , 0 ) ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 ? 1 : -1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) k *= -1 ; else k = 1 - k ; } } return p [ n ] ; }
int find ( int m , int n , int adj [ ] ) { int sweet [ n + 1 ] ; int dp [ n + 1 ] [ n + 1 ] [ n + 1 ] ; sweet [ 0 ] = 0 ; for ( int i = 1 ; i <= m ; ++ i ) sweet [ i ] = adj [ i - 1 ] ; for ( int i = 0 ; i <= m ; ++ i ) { for ( int k = 0 ; k <= n ; ++ k ) dp [ i ] [ 0 ] [ k ] = 0 ; for ( int k = 1 ; k <= n ; ++ k ) dp [ i ] [ k ] [ 0 ] = -1 ; } for ( int i = 0 ; i <= m ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { for ( int k = 1 ; k <= n ; ++ k ) { dp [ i ] [ j ] [ k ] = -1 ; if ( i > 0 && j >= k && sweet [ k ] > 0 && dp [ i - 1 ] [ j - k ] [ k ] != -1 ) dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j - k ] [ k ] + sweet [ k ] ; if ( dp [ i ] [ j ] [ k ] == -1 || ( dp [ i ] [ j ] [ k - 1 ] != -1 && dp [ i ] [ j ] [ k ] > dp [ i ] [ j ] [ k - 1 ] ) ) dp [ i ] [ j ] [ k ] = dp [ i ] [ j ] [ k - 1 ] ; } } } if ( dp [ m ] [ n ] [ n ] == -1 ) return 0 ; else return dp [ m ] [ n ] [ n ] ; }
int find_min_odd_cost ( int given [ M ] [ N ] , int m , int n ) { int floor [ M ] [ N ] = { { 0 } , { 0 } } ; int min_odd_cost = 0 ; int i , j , temp ; for ( j = 0 ; j < n ; j ++ ) floor [ 0 ] [ j ] = given [ 0 ] [ j ] ; for ( i = 1 ; i < m ; i ++ ) for ( j = 0 ; j < n ; j ++ ) { if ( j == 0 ) { floor [ i ] [ j ] = given [ i ] [ j ] ; floor [ i ] [ j ] += min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j + 1 ] ) ; } else if ( j == n - 1 ) { floor [ i ] [ j ] = given [ i ] [ j ] ; floor [ i ] [ j ] += min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j - 1 ] ) ; } else { temp = min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j - 1 ] ) ; temp = min ( temp , floor [ i - 1 ] [ j + 1 ] ) ; floor [ i ] [ j ] = given [ i ] [ j ] + temp ; } } min_odd_cost = INT_MAX ; for ( j = 0 ; j < n ; j ++ ) { if ( floor [ n - 1 ] [ j ] % 2 == 1 ) { if ( min_odd_cost > floor [ n - 1 ] [ j ] ) min_odd_cost = floor [ n - 1 ] [ j ] ; } } if ( min_odd_cost == INT_MIN ) return -1 ; return min_odd_cost ; }
int countPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; }
int countPaths ( int m , int n ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i == 1 j == 1 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; }
int factorial ( int n ) { int res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
int countWays ( int m , int n ) { m = m - 1 ; n = n - 1 ; return factorial ( m + n ) / ( factorial ( m ) * factorial ( n ) ) ; }
int MatrixChainOrder ( int p [ ] , int n ) { int dp [ n ] [ n ] ; for ( int i = 1 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ; for ( int L = 1 ; L < n - 1 ; L ++ ) for ( int i = 1 ; i < n - L ; i ++ ) dp [ i ] [ i + L ] = min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 ] [ n - 1 ] ; }
int createPalindrome ( int input , bool isOdd ) { int n = input ; int palin = input ; if ( isOdd ) n /= 10 ; while ( n > 0 ) { palin = palin * 10 + ( n % 10 ) ; n /= 10 ; } return palin ; }
vector < int > generatePalindromes ( int N ) { vector < int > palindromes ; int number ; for ( int j = 0 ; j < 2 ; j ++ ) { int i = 1 ; while ( ( number = createPalindrome ( i ++ , j ) ) <= N ) palindromes . push_back ( number ) ; } return palindromes ; }
int minimumNoOfPalindromes ( int N ) { string a , b = a = to_string ( N ) ; reverse ( b . begin ( ) , b . end ( ) ) ; if ( a == b ) return 1 ; vector < int > palindromes = generatePalindromes ( N ) ; sort ( palindromes . begin ( ) , palindromes . end ( ) ) ; int l = 0 , r = palindromes . size ( ) - 1 ; while ( l < r ) { if ( palindromes [ l ] + palindromes [ r ] == N ) return 2 ; else if ( palindromes [ l ] + palindromes [ r ] < N ) ++ l ; else -- r ; } return 3 ; }
int costOfString ( string str ) { int cost = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) cost += int ( str [ i ] - 48 ) ; return cost ; }
int lds ( int arr [ ] , int n ) { int lds [ n ] ; lds [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { lds [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) if ( lds [ j ] != 0 && arr [ i ] % arr [ j ] == 0 ) lds [ i ] = max ( lds [ i ] , lds [ j ] + 1 ) ; } return * max_element ( lds , lds + n ) ; }
int find ( int start , string adj , int n , int dp [ ] ) { if ( start == n ) return 0 ; if ( dp [ start ] != -1 ) return dp [ start ] ; dp [ start ] = 0 ; int one = 0 , zero = 0 , k ; for ( k = start ; k < n ; k ++ ) { if ( adj [ k ] == '1' ) one ++ ; else zero ++ ; if ( one > zero ) dp [ start ] = max ( dp [ start ] , find ( k + 1 , adj , n , dp ) + k - start + 1 ) ; else dp [ start ] = max ( dp [ start ] , find ( k + 1 , adj , n , dp ) ) ; } return dp [ start ] ; }
bool isVowel ( char ch ) { if ( ch == 'a' ch == 'e' ch == 'i' ch == 'o' ch == 'u' ) return true ; return false ; }
int lcs ( char * X , char * Y , int m , int n ) { int L [ m + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( ( X [ i - 1 ] == Y [ j - 1 ] ) && isVowel ( X [ i - 1 ] ) ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; }
unsigned long int catalan ( unsigned int n ) { unsigned long int c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
int makePairs ( vector < int > & pairs , int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { int sumOfDigits = 0 , k = i ; while ( k > 0 ) { sumOfDigits += k % 10 ; k /= 10 ; } if ( sumOfDigits <= 162 ) pairs . push_back ( sumOfDigits ) ; } }
int countCoPrime ( int a , int b ) { vector < int > pairs ; makePairs ( pairs , a , b ) ; int count = 0 ; for ( int i = 0 ; i < pairs . size ( ) ; i ++ ) for ( int j = i + 1 ; j < pairs . size ( ) ; j ++ ) if ( __gcd ( pairs [ i ] , pairs [ j ] ) == 1 ) count ++ ; return count ; }
ll recursive ( ll idx , ll sum , ll tight , string st , ll dp [ 20 ] [ 2 ] [ 166 ] , ll num ) { if ( idx == num ) return sum == 0 ; if ( dp [ idx ] [ tight ] [ sum ] != -1 ) return dp [ idx ] [ tight ] [ sum ] ; bool newTight ; ll ans = 0 ; ll d ; for ( d = 0 ; d < 10 ; ++ d ) { newTight = false ; if ( tight && st [ idx ] - '0' < d ) continue ; if ( tight && st [ idx ] - '0' == d ) newTight = true ; if ( sum >= d ) ans += recursive ( idx + 1 , sum - d , newTight , st , dp , num ) ; } return dp [ idx ] [ tight ] [ sum ] = ans ; }
vector < ll > formArray ( ll N ) { ll dp [ 20 ] [ 2 ] [ 166 ] ; memset ( dp , -1 , sizeof dp ) ; ostringstream x ; x << N ; string st = x . str ( ) ; ll num = st . size ( ) ; vector < ll > arr ; for ( int i = 1 ; i <= 162 ; ++ i ) { arr . push_back ( recursive ( 0 , i , 1 , st , dp , num ) ) ; } return arr ; }
ll findPair ( ll a , ll b ) { vector < ll > arr_smaller = formArray ( a - 1 ) ; vector < ll > arr_greater = formArray ( b ) ; for ( int i = 0 ; i < arr_greater . size ( ) ; ++ i ) arr_greater [ i ] -= arr_smaller [ i ] ; int ans = 0 ; for ( int i = 1 ; i <= 162 ; ++ i ) { for ( int j = i + 1 ; j <= 162 ; ++ j ) { if ( __gcd ( i , j ) == 1 ) ans = ( ans + arr_greater [ i - 1 ] * arr_greater [ j - 1 ] ) ; } } return ans ; }
int printTetraRec ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return 1 ; if ( n == 3 ) return 2 ; else return printTetraRec ( n - 1 ) + printTetraRec ( n - 2 ) + printTetraRec ( n - 3 ) + printTetraRec ( n - 4 ) ; }
int printTetra ( int n ) { int dp [ n + 5 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = dp [ 2 ] = 1 ; dp [ 3 ] = 2 ; for ( int i = 4 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ; cout << dp [ n ] ; }
void printTetra ( int n ) { if ( n < 0 ) return ; int first = 0 , second = 1 ; int third = 1 , fourth = 2 ; int curr ; if ( n == 0 ) cout << first ; else if ( n == 1 n == 2 ) cout << second ; else if ( n == 3 ) cout << fourth ; else { for ( int i = 4 ; i <= n ; i ++ ) { curr = first + second + third + fourth ; first = second ; second = third ; third = fourth ; fourth = curr ; } cout << curr ; } }
bool check ( int n ) { vector < int > v ; v = factors ( n ) ; sort ( v . begin ( ) , v . end ( ) ) ; int r = v . size ( ) ; bool subset [ r + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= r ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= r ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j < v [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; else { subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - v [ i - 1 ] ] ; } } } if ( ( subset [ r ] [ n ] ) == 0 ) return false ; else return true ; }
int maxSum1 ( int arr [ ] , int n ) { int dp [ n ] ; int maxi = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { dp [ i ] = arr [ i ] ; if ( maxi < arr [ i ] ) maxi = arr [ i ] ; } for ( int i = 2 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < i - 1 ; j ++ ) { if ( dp [ i ] < dp [ j ] + arr [ i ] ) { dp [ i ] = dp [ j ] + arr [ i ] ; if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } } return maxi ; }
int maxSum2 ( int arr [ ] , int n ) { int dp [ n ] ; int maxi = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; if ( maxi < arr [ i ] ) maxi = arr [ i ] ; } for ( int i = 3 ; i < n ; i ++ ) { for ( int j = 1 ; j < i - 1 ; j ++ ) { if ( dp [ i ] < arr [ i ] + dp [ j ] ) { dp [ i ] = arr [ i ] + dp [ j ] ; if ( maxi < dp [ i ] ) maxi = dp [ i ] ; } } } return maxi ; }
int findMaxSum ( int arr [ ] , int n ) { return max ( maxSum1 ( arr , n ) , maxSum2 ( arr , n ) ) ; }
int solve ( int N , int K ) { int combo [ N + 1 ] = { 0 } ; combo [ 0 ] = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { if ( j >= i ) { combo [ j ] += combo [ j - i ] ; } } } return combo [ N ] ; }
void fibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i < 43 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; }
int rec ( int x , int y , int last ) { if ( y == 0 ) { if ( x == 0 ) return 1 ; return 0 ; } int sum = 0 ; for ( int i = last ; i >= 0 and fib [ i ] * y >= x ; i -- ) { if ( fib [ i ] > x ) continue ; sum += rec ( x - fib [ i ] , y - 1 , i ) ; } return sum ; }
int MinimumPrimes ( int n ) { int dp [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] = 1e9 ; dp [ 0 ] = dp [ 2 ] = dp [ 3 ] = dp [ 5 ] = dp [ 7 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( check ( i , 2 ) ) dp [ i ] = min ( dp [ i ] , 1 + dp [ i - 2 ] ) ; if ( check ( i , 3 ) ) dp [ i ] = min ( dp [ i ] , 1 + dp [ i - 3 ] ) ; if ( check ( i , 5 ) ) dp [ i ] = min ( dp [ i ] , 1 + dp [ i - 5 ] ) ; if ( check ( i , 7 ) ) dp [ i ] = min ( dp [ i ] , 1 + dp [ i - 7 ] ) ; } if ( dp [ n ] == ( 1e9 ) ) return -1 ; else return dp [ n ] ; }
int minimumCost ( int cost [ ] , int n ) { int dp [ n ] ; if ( n == 1 ) return cost [ 0 ] ; dp [ 0 ] = cost [ 0 ] ; dp [ 1 ] = cost [ 1 ] ; for ( int i = 2 ; i < n ; i ++ ) { dp [ i ] = min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] ; } return min ( dp [ n - 2 ] , dp [ n - 1 ] ) ; }
int minimumCost ( int cost [ ] , int n ) { int dp1 = 0 , dp2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dp0 = cost [ i ] + min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return min ( dp1 , dp2 ) ; }
void subsetSum ( int arr [ ] , int n , int maxSum ) { bool dp [ maxSum + 1 ] ; memset ( dp , false , sizeof dp ) ; dp [ arr [ 0 ] ] = true ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = maxSum + 1 ; j >= 1 ; j -- ) { if ( arr [ i ] <= j ) { if ( arr [ i ] == j || dp [ j ] || dp [ ( j - arr [ i ] ) ] ) dp [ j ] = true ; else dp [ j ] = false ; } } } cout << 0 << " " ; for ( int j = 0 ; j <= maxSum + 1 ; j ++ ) { if ( dp [ j ] == true ) cout << j << " " ; } }
void printDistinct ( int a [ ] , int n ) { int maxSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxSum += a [ i ] ; } subsetSum ( a , n , maxSum ) ; }
int maxCost ( int a [ ] [ size ] , int m , int n , int dp [ ] [ size ] ) { if ( n < 0 m < 0  ) return -1e9 ; else if ( m == 0 && n == 0 ) return 0 ; else if ( dp [ m ] [ n ] != -1 ) return dp [ m ] [ n ] ; else { int num = m + n ; if ( ( num & ( num - 1 ) ) == 0 ) return dp [ m ] [ n ] = a [ m ] [ n ] + maxCost ( a , m - 1 , n - 1 , dp ) ; else return dp [ m ] [ n ] = ( a [ m ] [ n ] + max ( maxCost ( a , m - 1 , n , dp ) , maxCost ( a , m , n - 1 , dp ) ) ) ; } }
int answer ( int a [ ] [ size ] , int n ) { int dp [ size ] [ size ] ; memset ( dp , -1 , sizeof dp ) ; return maxCost ( a , n - 1 , n - 1 , dp ) ; }
int editDistanceWith2Ops ( string & X , string & Y ) { int m = X . length ( ) , n = Y . length ( ) ; int L [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } int lcs = L [ m ] [ n ] ; return ( m - lcs ) + ( n - lcs ) ; }
int lcs ( string X , string Y , int m , int n ) { if ( m == 0 n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; }
int lcs ( string X , string Y , int m , int n , int dp [ ] [ maximum ] ) { if ( m == 0 n == 0 ) return 0 ; if ( dp [ m - 1 ] [ n - 1 ] != -1 ) return dp [ m - 1 ] [ n - 1 ] ; if ( X [ m - 1 ] == Y [ n - 1 ] ) { dp [ m - 1 ] [ n - 1 ] = 1 + lcs ( X , Y , m - 1 , n - 1 , dp ) ; return dp [ m - 1 ] [ n - 1 ] ; } else { dp [ m - 1 ] [ n - 1 ] = max ( lcs ( X , Y , m , n - 1 , dp ) , lcs ( X , Y , m - 1 , n , dp ) ) ; return dp [ m - 1 ] [ n - 1 ] ; } }
int countPaths ( int n ) { int zB = 1 ; int zADC = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int nzB = zADC * 3 ; int nzADC = ( zADC * 2 + zB ) ; zB = nzB ; zADC = nzADC ; } return zB ; }
int sumSubSequence ( vector < int > arr , int len , int m ) { int sum = 0 ; for ( auto x : arr ) sum += x ; vector < vector < int > > dp ( len + 1 , vector < int > ( sum + 1 , 0 ) ) ; for ( int i = 0 ; i <= len ; i ++ ) dp [ i ] [ 0 ] ++ ; for ( int i = 1 ; i <= len ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] ++ ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] > 0 ) { dp [ i ] [ j ] ++ ; dp [ i ] [ j + arr [ i - 1 ] ] ++ ; } } } int count = 0 ; for ( int j = 1 ; j <= sum ; j ++ ) if ( dp [ len ] [ j ] > 0 ) if ( j % m == 0 ) count += dp [ len ] [ j ] ; return count ; }
int totalWays ( int N , int M , int X ) { int dp [ N + 1 ] [ 2 ] ; if ( X == 1 ) { dp [ 0 ] [ 0 ] = 1 ; } else { dp [ 0 ] [ 1 ] = 0 ; } if ( X == 1 ) { dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = M - 1 ; } else { dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = ( M - 2 ) ; } for ( int i = 2 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) ; } return dp [ N - 1 ] [ 0 ] ; }
int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
int fib ( int n ) { if ( n <= 1 ) return n ; if ( term [ n ] != 0 ) return term [ n ] ; else { term [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ; return term [ n ] ; } }
int lcs ( char * X , char * Y , int m , int n ) { if ( m == 0 n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; }
int lcs ( char * X , char * Y , int m , int n ) { if ( m == 0 n == 0 ) return 0 ; if ( arr [ m - 1 ] [ n - 1 ] != -1 ) return arr [ m - 1 ] [ n - 1 ] ; if ( X [ m - 1 ] == Y [ n - 1 ] ) { arr [ m - 1 ] [ n - 1 ] = 1 + lcs ( X , Y , m - 1 , n - 1 ) ; return arr [ m - 1 ] [ n - 1 ] ; } else { arr [ m - 1 ] [ n - 1 ] = max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; return arr [ m - 1 ] [ n - 1 ] ; } }
int lcs ( char * X , char * Y , char * Z , int m , int n , int o ) { if ( m == 0 n == 0 o == 0 ) return 0 ; if ( arr [ m - 1 ] [ n - 1 ] [ o - 1 ] != -1 ) return arr [ m - 1 ] [ n - 1 ] [ o - 1 ] ; if ( X [ m - 1 ] == Y [ n - 1 ] and Y [ n - 1 ] == Z [ o - 1 ] ) { arr [ m - 1 ] [ n - 1 ] [ o - 1 ] = 1 + lcs ( X , Y , Z , m - 1 , n - 1 , o - 1 ) ; return arr [ m - 1 ] [ n - 1 ] [ o - 1 ] ; } else { arr [ m - 1 ] [ n - 1 ] [ o - 1 ] = max ( lcs ( X , Y , Z , m , n - 1 , o ) , max ( lcs ( X , Y , Z , m - 1 , n , o ) , lcs ( X , Y , Z , m , n , o - 1 ) ) ) ; return arr [ m - 1 ] [ n - 1 ] [ o - 1 ] ; } }
int minStepsNeeded ( int k , int d1 , int d2 , int x ) { int gcd = __gcd ( d1 , d2 ) ; if ( ( k - x ) % gcd != 0 ) return -1 ; queue < pair < int , int > > q ; unordered_set < int > visited ; q . push ( { k , 0 } ) ; visited . insert ( k ) ; while ( ! q . empty ( ) ) { int s = q . front ( ) . first ; int stp = q . front ( ) . second ; if ( s == x ) return stp ; q . pop ( ) ; if ( visited . find ( s + d1 ) == visited . end ( ) ) { q . push ( { s + d1 , stp + 1 } ) ; visited . insert ( s + d1 ) ; } if ( visited . find ( s + d2 ) == visited . end ( ) ) { q . push ( { s + d2 , stp + 1 } ) ; visited . insert ( s + d2 ) ; } if ( visited . find ( s - d1 ) == visited . end ( ) ) { q . push ( { s - d1 , stp + 1 } ) ; visited . insert ( s - d1 ) ; } if ( visited . find ( s - d2 ) == visited . end ( ) ) { q . push ( { s - d2 , stp + 1 } ) ; visited . insert ( s - d2 ) ; } } }
int lds ( int arr [ ] , int n ) { int lds [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] < arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lds [ i ] ) max = lds [ i ] ; return max ; }
int minimumNumberOfDigits ( int a , int b ) { if ( a > b a < 0 b < 0 a > 900 b > 8100 ) return -1 ; if ( a == 0 && b == 0 ) return 0 ; if ( dp [ a ] [ b ] != -1 ) return dp [ a ] [ b ] ; int ans = 101 ; for ( int i = 9 ; i >= 1 ; i -- ) { int k = minimumNumberOfDigits ( a - i , b - ( i * i ) ) ; if ( k != -1 ) ans = min ( ans , k + 1 ) ; } return dp [ a ] [ b ] = ans ; }
void printSmallestNumber ( int a , int b ) { memset ( dp , -1 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = 0 ; int k = minimumNumberOfDigits ( a , b ) ; if ( k == -1 k > 100 ) cout << "-1" ; else { while ( a > 0 && b > 0 ) { for ( int i = 1 ; i <= 9 ; i ++ ) { if ( a >= i && b >= i * i && 1 + dp [ a - i ] [ b - i * i ] == dp [ a ] [ b ] ) { cout << i ; a -= i ; b -= i * i ; break ; } } } } }
void binomialCoeff ( int C [ ] , int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , n ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } }
int sumOfproduct ( int n ) { int sum = 0 ; int C [ MAX ] = { 0 } ; binomialCoeff ( C , n ) ; for ( int i = 0 ; i <= n ; i ++ ) sum += C [ i ] * C [ i + 1 ] ; return sum ; }
int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
int sumOfproduct ( int n ) { return binomialCoeff ( 2 * n , n - 1 ) ; }
int check ( int i , int sum , int n , int k , int a [ ] , int dp [ MAX ] [ MAX ] ) { if ( sum <= 0 ) return false ; if ( i >= n ) { if ( sum == k ) return true ; return false ; } if ( dp [ i ] [ sum ] != -1 ) return dp [ i ] [ sum ] ; dp [ i ] [ sum ] = check ( i + 1 , sum - 2 * a [ i ] , n , k , a , dp ) || check ( i + 1 , sum , n , k , a , dp ) ; dp [ i ] [ sum ] = check ( i + 1 , sum - ( i + 1 ) , n , k , a , dp ) || dp [ i ] [ sum ] ; dp [ i ] [ sum ] = check ( i + 1 , sum + i + 1 , n , k , a , dp ) || dp [ i ] [ sum ] ; return dp [ i ] [ sum ] ; }
bool wrapper ( int n , int k , int a [ ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int dp [ MAX ] [ MAX ] ; memset ( dp , -1 , sizeof ( dp ) ) ; return check ( 0 , sum , n , k , a , dp ) ; }
bool isPowerOf ( long val , int base ) { while ( val > 1 ) { if ( val % base != 0 ) val /= base ; } return true ; }
int numberOfPartitions ( string binaryNo ) { int i , j , n = binaryNo . length ( ) ; long val ; int dp [ n ] ; dp [ n - 1 ] = ( ( binaryNo [ n - 1 ] - '0' ) == 0 ) ? -1 : 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) { val = 0 ; if ( ( binaryNo [ i ] - '0' ) == 0 ) { dp [ i ] = -1 ; continue ; } dp [ i ] = INT_MAX ; for ( j = i ; j < n ; j ++ ) { val = ( val * 2 ) + ( long ) ( binaryNo [ j ] - '0' ) ; if ( isPowerOf ( val , 4 ) || isPowerOf ( val , 6 ) ) { if ( j == n - 1 ) { dp [ i ] = 1 ; } else { if ( dp [ j + 1 ] != -1 ) dp [ i ] = min ( dp [ i ] , dp [ j + 1 ] + 1 ) ; } } } if ( dp [ i ] == INT_MAX ) dp [ i ] = -1 ; } return dp [ 0 ] ; }
void binomialCoeff ( int n , int C [ ] ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , n ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } }
int summation ( int n ) { int C [ MAX ] ; memset ( C , 0 , sizeof ( C ) ) ; binomialCoeff ( n , C ) ; int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += ( i * C [ i ] ) ; return sum ; }
int summation ( int n ) { return n << ( n - 1 ) ; }
int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
int countArray ( int N , int K ) { return binomialCoeff ( K - 1 , N - 1 ) ; }
int count ( int n , int c , int a [ ] , int b [ ] ) { int need [ N ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i + n ] = a [ i ] ; b [ i + n ] = b [ i ] ; } int s = 0 ; int tank = 0 ; for ( int i = 0 ; i < 2 * n ; i ++ ) { tank += a [ i ] ; tank = min ( tank , c ) ; tank -= b [ i ] ; if ( tank < 0 ) { tank = 0 ; s = i + 1 ; } } if ( s >= n ) return 0 ; int ans = 1 ; need [ s + n ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int id = s + n - i ; need [ id ] = max ( 0 , need [ id + 1 ] + b [ id ] - min ( a [ id ] , c ) ) ; if ( need [ id ] == 0 ) ans ++ ; } return ans ; }
void fib ( int n ) { int a = 0 , b = 1 , c ; if ( n >= 0 ) cout << a << " " ; if ( n >= 1 ) cout << b << " " ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; cout << c << " " ; a = b ; b = c ; } }
int countDigits ( int n ) { int count = 0 ; while ( n > 0 ) { count += 1 ; n /= 10 ; } return count ; }
int findCount ( int L , int R ) { int count = 0 ; int countDigitsL = countDigits ( L ) ; int countDigitsR = countDigits ( R ) ; int firstDigitL = ( L / pow ( 10 , countDigitsL - 1 ) ) ; int firstDigitR = ( R / pow ( 10 , countDigitsR - 1 ) ) ; if ( countDigitsL < countDigitsR ) { count += ( 9 * ( countDigitsR - countDigitsL - 1 ) ) ; if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) count += ( 9 - firstDigitL + 1 ) ; else count += ( 9 - firstDigitL ) ; if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) count += firstDigitR ; else count += ( firstDigitR - 1 ) ; } else { if ( getDistinct ( firstDigitL , countDigitsL ) >= L ) count += ( 9 - firstDigitL + 1 ) ; else count += ( 9 - firstDigitL ) ; if ( getDistinct ( firstDigitR , countDigitsR ) <= R ) count -= ( 9 - firstDigitR ) ; else count -= ( 9 - firstDigitR + 1 ) ; } return count ; }
double score ( int n , vector < int > & A , int k ) { if ( memo [ n ] [ k ] > 0 ) return memo [ n ] [ k ] ; double sum = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { sum += A [ i ] ; memo [ n ] [ k ] = max ( memo [ n ] [ k ] , score ( i , A , k - 1 ) + sum / ( n - i ) ) ; } return memo [ n ] [ k ] ; }
ll pre_compute ( ll a [ ] , ll n , ll index , ll k ) { ll dp [ n ] [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ; else dp [ 0 ] [ i ] = a [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) { if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } return dp [ index ] [ k ] ; }
int gen ( int n ) { int S [ n + 1 ] ; S [ 0 ] = 0 ; S [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) S [ i ] = 4 * S [ i / 2 ] ; else S [ i ] = 4 * S [ i / 2 ] + 1 ; } return S [ n ] ; }
void moserDeBruijn ( int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << gen ( i ) << " " ; cout << "\n" ; }
int LCSubStr ( string X , string Y ) { int m = X . length ( ) ; int n = Y . length ( ) ; int result = 0 ; int len [ 2 ] [ n ] ; int currRow = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) { len [ currRow ] [ j ] = 0 ; } else if ( X [ i - 1 ] == Y [ j - 1 ] ) { len [ currRow ] [ j ] = len [ 1 - currRow ] [ j - 1 ] + 1 ; result = max ( result , len [ currRow ] [ j ] ) ; } else { len [ currRow ] [ j ] = 0 ; } } currRow = 1 - currRow ; } return result ; }
bool isPartitionPoss ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; vector < int > set1 , set2 ; return findSets ( arr , n , set1 , set2 , 0 , 0 , 0 ) ; }
void func ( int n , int m , int A [ ] ) { vector < int > ModArray ( n ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ModArray [ i ] = A [ i ] % m ; sum += ModArray [ i ] ; } sum = sum % m ; if ( sum % m == 0 ) { cout << "True" ; return ; } if ( sum % 2 != 0 ) { cout << "False" ; } else { ModArray . erase ( ModArray . begin ( ) ) ; int i = 0 ; int j = ModArray . size ( ) - 1 ; sort ( ModArray . begin ( ) , ModArray . end ( ) ) ; sum = sum / 2 ; int i1 , i2 ; while ( i <= j ) { int s = ModArray [ i ] + ModArray [ j ] ; if ( s == sum ) { i1 = i ; i2 = j ; cout << "True" ; break ; } else if ( s > sum ) j -- ; else i ++ ; } } }
void dfs1 ( vector < int > v [ ] , int u , int parent ) { in [ u ] = 0 ; for ( int child : v [ u ] ) { if ( child == parent ) continue ; dfs1 ( v , child , u ) ; in [ u ] = max ( in [ u ] , 1 + in [ child ] ) ; } }
void dfs2 ( vector < int > v [ ] , int u , int parent ) { int mx1 = -1 , mx2 = -1 ; for ( int child : v [ u ] ) { if ( child == parent ) continue ; if ( in [ child ] >= mx1 ) { mx2 = mx1 ; mx1 = in [ child ] ; } else if ( in [ child ] > mx2 ) mx2 = in [ child ] ; } for ( int child : v [ u ] ) { if ( child == parent ) continue ; int longest = mx1 ; if ( mx1 == in [ child ] ) longest = mx2 ; out [ child ] = 1 + max ( out [ u ] , 1 + longest ) ; dfs2 ( v , child , u ) ; } }
void printGolomb ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) cout << findGolomb ( i ) << " " ; }
void dfs ( int a [ ] , vector < int > v [ ] , int u , int parent ) { dp [ u ] = a [ u - 1 ] ; int maximum = 0 ; for ( int child : v [ u ] ) { if ( child == parent ) continue ; dfs ( a , v , child , u ) ; maximum = max ( maximum , dp [ child ] ) ; } dp [ u ] += maximum ; }
int maximumValue ( int a [ ] , vector < int > v [ ] ) { dfs ( a , v , 1 , 0 ) ; return dp [ 1 ] ; }
int countRemovals ( int a [ ] , int i , int j , int k ) { if ( i >= j ) return 0 ; else if ( ( a [ j ] - a [ i ] ) <= k ) return 0 ; else if ( dp [ i ] [ j ] != -1 ) return dp [ i ] [ j ] ; else if ( ( a [ j ] - a [ i ] ) > k ) { dp [ i ] [ j ] = 1 + min ( countRemovals ( a , i + 1 , j , k ) , countRemovals ( a , i , j - 1 , k ) ) ; } return dp [ i ] [ j ] ; }
int removals ( int a [ ] , int n , int k ) { sort ( a , a + n ) ; memset ( dp , -1 , sizeof ( dp ) ) ; if ( n == 1 ) return 0 ; else return countRemovals ( a , 0 , n - 1 , k ) ; }
int removals ( int arr [ ] , int n , int k ) { int i , j , ans = n - 1 ; sort ( arr , arr + n ) ; for ( i = 0 ; i < n ; i ++ ) { j = findInd ( arr [ i ] , i , n , k , arr ) ; if ( j != -1 ) { ans = min ( ans , n - ( j - i + 1 ) ) ; } } return ans ; }
int removals ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int dp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = -1 ; int ans = n - 1 ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] = i ; int j = dp [ i - 1 ] ; while ( j != i && arr [ i ] - arr [ j ] > k ) { j ++ ; } dp [ i ] = min ( dp [ i ] , j ) ; ans = min ( ans , ( n - ( i - j + 1 ) ) ) ; } return ans ; }
int maximumSegments ( int n , int a , int b , int c ) { int dp [ n + 1 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != -1 ) { dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) ; dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) ; dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }
void postfix ( int a [ ] , int n ) { for ( int i = n - 1 ; i > 0 ; i -- ) a [ i - 1 ] = a [ i - 1 ] + a [ i ] ; }
void modify ( int a [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) a [ i - 1 ] = i * a [ i ] ; }
void sequence ( int n ) { int f [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; cout << f [ 1 ] << " " << f [ 2 ] << " " ; for ( int i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; cout << f [ i ] << " " ; } }
long long sum ( int a [ ] , int i , int j ) { long long ans = 0 ; for ( int m = i ; m <= j ; m ++ ) ans = ( ans + a [ m ] ) % 100 ; return ans ; }
long long solve ( int a [ ] , int i , int j ) { if ( i == j ) return 0 ; if ( dp [ i ] [ j ] != -1 ) return dp [ i ] [ j ] ; dp [ i ] [ j ] = INT_MAX ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , ( solve ( a , i , k ) + solve ( a , k + 1 , j ) + ( sum ( a , i , k ) * sum ( a , k + 1 , j ) ) ) ) ; } return dp [ i ] [ j ] ; }
void initialize ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = -1 ; }
void reverseFibonacci ( int n ) { int a [ n ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { cout << a [ i ] << " " ; } }
int longestSubsequenceCommonSegment ( int k , string s1 , string s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; int lcs [ n + 1 ] [ m + 1 ] ; int cnt [ n + 1 ] [ m + 1 ] ; memset ( lcs , 0 , sizeof ( lcs ) ) ; memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1 ] ) ; if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ; if ( cnt [ i ] [ j ] >= k ) { for ( int a = k ; a <= cnt [ i ] [ j ] ; a ++ ) lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - a ] [ j - a ] + a ) ; } } } return lcs [ n ] [ m ] ; }
long long arrangeBraces ( int n , int pos [ ] , int k ) { bool h [ N ] ; int dp [ N ] [ N ] ; memset ( h , 0 , sizeof h ) ; memset ( dp , 0 , sizeof dp ) ; for ( int i = 0 ; i < k ; i ++ ) h [ pos [ i ] ] = 1 ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { for ( int j = 0 ; j <= 2 * n ; j ++ ) { if ( h [ i ] ) { if ( j != 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 0 ; } else { if ( j != 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } } } return dp [ 2 * n ] [ 0 ] ; }
bool check ( string s1 , string s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; bool dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = false ; } } dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { for ( int j = 0 ; j <= s2 . length ( ) ; j ++ ) { if ( dp [ i ] [ j ] ) { if ( j < s2 . length ( ) && ( toupper ( s1 [ i ] ) == s2 [ j ] ) ) dp [ i + 1 ] [ j + 1 ] = true ; if ( ! isupper ( s1 [ i ] ) ) dp [ i + 1 ] [ j ] = true ; } } } return ( dp [ n ] [ m ] ) ; }
int findLength ( string str , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_sum += ( str [ i ] == '0' ? 1 : -1 ) ; if ( current_sum < 0 ) current_sum = 0 ; max_sum = max ( current_sum , max_sum ) ; } return max_sum == 0 ? -1 : max_sum ; }
float find_prob ( int N , float P ) { double dp [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return dp [ N ] ; }
int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int chordCnt ( int A ) { int n = 2 * A ; int dpArray [ n + 1 ] = { 0 } ; dpArray [ 0 ] = 1 ; dpArray [ 2 ] = 1 ; for ( int i = 4 ; i <= n ; i += 2 ) { for ( int j = 0 ; j < i - 1 ; j += 2 ) { dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) ; } } return dpArray [ n ] ; }
int maximumSumSubarray ( int arr [ ] , int n ) { int min_prefix_sum = 0 ; int res = numeric_limits < int > :: min ( ) ; int prefix_sum [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { res = max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; }
bool isPath ( int arr [ row ] [ col ] ) { int dir [ 4 ] [ 2 ] = { { 0 , 1 } , { 0 , -1 } , { 1 , 0 } , { -1 , 0 } } ; queue < pair < int , int > > q ; q . push ( make_pair ( 0 , 0 ) ) ; while ( q . size ( ) > 0 ) { pair < int , int > p = q . front ( ) ; q . pop ( ) ; arr [ p . first ] [ p . second ] = -1 ; if ( p == make_pair ( row - 1 , col - 1 ) ) return true ; for ( int i = 0 ; i < 4 ; i ++ ) { int a = p . first + dir [ i ] [ 0 ] ; int b = p . second + dir [ i ] [ 1 ] ; if ( arr [ a ] [ b ] != -1 && a >= 0 && b >= 0 && a < row && b < col ) { q . push ( make_pair ( a , b ) ) ; } } } return false ; }
bool isPath ( int arr [ row ] [ col ] ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < row ; i ++ ) if ( arr [ i ] [ 0 ] != -1 ) arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] ; for ( int j = 1 ; j < col ; j ++ ) if ( arr [ 0 ] [ j ] != -1 ) arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] ; for ( int i = 1 ; i < row ; i ++ ) for ( int j = 1 ; j < col ; j ++ ) if ( arr [ i ] [ j ] != -1 ) arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ row - 1 ] [ col - 1 ] == 1 ) ; }
int Jacobsthal ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + 2 * dp [ i - 2 ] ; return dp [ n ] ; }
int Jacobsthal_Lucas ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = 2 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + 2 * dp [ i - 2 ] ; return dp [ n ] ; }
int findStep ( int n ) { if ( n == 1 n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; }
int countWays ( int n ) { int res [ n + 1 ] ; res [ 0 ] = 1 ; res [ 1 ] = 1 ; res [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] ; return res [ n ] ; }
int countWays ( int n ) { int a = 1 , b = 2 , c = 4 ; int d = 0 ; if ( n == 0 n == 1 n == 2 ) return n ; if ( n == 3 ) return c ; for ( int i = 4 ; i <= n ; i ++ ) { d = c + b + a ; a = b ; b = c ; c = d ; } return d ; }
int sequence ( int n ) { if ( n == 1 n == 2 ) return 1 ; else return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ; }
int sequence ( int n ) { int f [ n + 1 ] ; int i ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; return f [ n ] ; }
int choose ( int n , int k ) { if ( k > n ) return 0 ; if ( n <= 1 ) return 1 ; if ( k == 0 ) return 1 ; if ( nck [ n ] [ k ] != -1 ) return nck [ n ] [ k ] ; int answer = choose ( n - 1 , k - 1 ) + choose ( n - 1 , k ) ; nck [ n ] [ k ] = answer ; return answer ; }
int getLeft ( int n ) { if ( n == 1 ) return 0 ; int h = log2 [ n ] ; int last = n - ( ( 1 << h ) - 1 ) ; if ( last >= ( numh / 2 ) ) else return ( 1 << h ) - 1 - ( ( numh / 2 ) - last ) ; }
int numberOfHeaps ( int n ) { if ( n <= 1 ) return 1 ; if ( dp [ n ] != -1 ) return dp [ n ] ; int left = getLeft ( n ) ; int ans = ( choose ( n - 1 , left ) * numberOfHeaps ( left ) ) * ( numberOfHeaps ( n - 1 - left ) ) ; dp [ n ] = ans ; return ans ; }
int Hosoya ( int n , int m ) { if ( ( n == 0 && m == 0 ) || ( n == 1 && m == 0 ) || ( n == 1 && m == 1 ) || ( n == 2 && m == 1 ) ) return 1 ; if ( n > m ) return Hosoya ( n - 1 , m ) + Hosoya ( n - 2 , m ) ; else if ( m == n ) return Hosoya ( n - 1 , m - 1 ) + Hosoya ( n - 2 , m - 2 ) ; else return 0 ; }
int numberofways ( int n , int m ) { int dp [ n + 2 ] [ n + 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
int zigzag ( int n , int k ) { int dp [ n + 1 ] [ k + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; return dp [ n ] [ k ] ; } int main ( ) { int n = 4 , k = 3 ; cout << zigzag ( n , k ) << endl ; return 0 ; }
int eulerian ( int n , int m ) { if ( m >= n n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }
int eulerian ( int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }
int nswp ( int n ) { if ( n == 0 n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }
int binomialCoeff ( int n , int k ) { int C [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
int longOddEvenIncSeq ( int arr [ ] , int n ) { int lioes [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; }
int dealnnoy ( int n , int m ) { if ( m == 0 n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; }
int dealnnoy ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }
void longestAlternating ( int arr [ ] , int n ) { int count [ n ] ; count [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) cout << count [ i ] << " " ; }
int maxDP ( int n ) { int res [ n + 1 ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res [ i ] = max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) ; return res [ n ] ; }
int findlength ( int arr [ ] , string s , int n , int ind , int st , int dp [ ] [ 3 ] ) { if ( ind >= n ) return 0 ; if ( dp [ ind ] [ st ] != -1 ) return dp [ ind ] [ st ] ; if ( st == 0 ) return dp [ ind ] [ st ] = max ( arr [ ind ] + findlength ( arr , s , n , ind + 1 , 1 , dp ) , findlength ( arr , s , n , ind + 1 , 0 , dp ) ) ; else return dp [ ind ] [ st ] = max ( arr [ ind ] + findlength ( arr , s , n , ind + 1 , 1 , dp ) , 0 ) ; }
int maxLen ( string s , int n ) { if ( allones ( s , n ) ) return -1 ; int arr [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = ( s [ i ] == '0' ? 1 : -1 ) ; int dp [ MAX ] [ 3 ] ; memset ( dp , -1 , sizeof dp ) ; return findlength ( arr , s , n , 0 , 0 , dp ) ; }
int countarray ( int n , int k , int x ) { int dp [ MAXN ] = { 0 } ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; }
int countPalindromes ( int k , int n , int l [ ] [ MAX ] , int r [ ] [ MAX ] ) { int ans = 0 ; if ( k == 1 ) { for ( int i = 0 ; i < MAX_CHAR ; i ++ ) ans += l [ i ] [ n - 1 ] ; return ans ; } if ( k == 2 ) { for ( int i = 0 ; i < MAX_CHAR ; i ++ ) ans += ( ( l [ i ] [ n - 1 ] * ( l [ i ] [ n - 1 ] - 1 ) ) / 2 ) ; return ans ; } for ( int i = 1 ; i < n - 1 ; i ++ ) for ( int j = 0 ; j < MAX_CHAR ; j ++ ) ans += l [ j ] [ i - 1 ] * r [ j ] [ i + 1 ] ; return ans ; }
int lcs ( char * X , char * Y , int m , int n ) { int L [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; ++ i ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 2 * ( X [ i - 1 ] - '0' ) ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; }
int findMinCost ( char X [ ] , char Y [ ] ) { int m = strlen ( X ) , n = strlen ( Y ) ; int cost = 0 ; for ( int i = 0 ; i < m ; ++ i ) cost += X [ i ] - '0' ; for ( int i = 0 ; i < n ; ++ i ) cost += Y [ i ] - '0' ; return cost - lcs ( X , Y , m , n ) ; }
int isSubsetSum ( int set [ ] , int n , int sum ) { bool subset [ sum + 1 ] [ n + 1 ] ; int count [ sum + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { subset [ 0 ] [ i ] = true ; count [ 0 ] [ i ] = 0 ; } for ( int i = 1 ; i <= sum ; i ++ ) { subset [ i ] [ 0 ] = false ; count [ i ] [ 0 ] = -1 ; } for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; count [ i ] [ j ] = count [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) { subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; if ( subset [ i ] [ j ] ) count [ i ] [ j ] = max ( count [ i ] [ j - 1 ] , count [ i - set [ j - 1 ] ] [ j - 1 ] + 1 ) ; } } } return count [ sum ] [ n ] ; }
long long answer ( int n ) { int dp [ n + 1 ] [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } long long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; }
bool isSubSeqDivisible ( string str ) { int l = str . length ( ) ; int arr [ l ] ; for ( int i = 0 ; i < l ; i ++ ) arr [ i ] = str [ i ] - '0' ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = i ; j < l ; j ++ ) { for ( int k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; }
int maxLength ( char s [ ] , int n ) { int dp [ n ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( s [ i ] == '(' && s [ i + 1 ] == ')' ) dp [ i ] [ i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s [ i ] == '(' && s [ j ] == ')' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( int k = i ; k < j ; k ++ ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; }
int maxLength ( char s [ ] , int n ) { int invalidOpenBraces = 0 ; int invalidCloseBraces = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '(' ) { invalidOpenBraces ++ ; } else { if ( invalidOpenBraces == 0 ) { invalidCloseBraces ++ ; } else { invalidOpenBraces -- ; } } } return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; }
int numberOfWays ( int x ) { int dp [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
void dfs ( int node , int parent , vector < int > tree [ ] , int colour [ ] , int answer [ ] ) { answer [ node ] = colour [ node ] ; for ( auto u : tree [ node ] ) { if ( u == parent ) continue ; dfs ( u , node , tree , colour , answer ) ; answer [ node ] += max ( answer [ u ] , 0 ) ; } }
int maxDiff ( vector < int > tree [ ] , int colour [ ] , int N ) { int answer [ N + 1 ] ; memset ( answer , 0 , sizeof ( answer ) ) ; dfs ( 1 , 0 , tree , colour , answer ) ; int high = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { high = max ( high , answer [ i ] ) ; answer [ i ] = 0 ; } for ( int i = 1 ; i <= N ; i ++ ) { if ( colour [ i ] == -1 ) colour [ i ] = 1 ; else colour [ i ] = -1 ; } dfs ( 1 , 0 , tree , colour , answer ) ; for ( int i = 1 ; i < N ; i ++ ) high = max ( high , answer [ i ] ) ; return high ; }
void alternateSubarray ( bool arr [ ] , int n ) { int len [ n ] ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == 1 ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; ++ i ) cout << len [ i ] << " " ; }
void alternateSubarray ( bool arr [ ] , int n ) { int count = 1 ; int prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { if ( ( arr [ i ] ^ prev ) == 0 ) { while ( count ) cout << count -- << " " ; } ++ count ; prev = arr [ i ] ; } while ( count ) cout << count -- << " " ; }
int lcs ( int dp [ MAX ] [ MAX ] [ MAX ] , int arr1 [ ] , int n , int arr2 [ ] , int m , int k ) { if ( k < 0 ) return -1e7 ; if ( n < 0 m < 0  ) return 0 ; int & ans = dp [ n ] [ m ] [ k ] ; if ( ans != -1 ) return ans ; ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; return ans ; }
int productSubSeqCount ( vector < int > & arr , int k ) { int n = arr . size ( ) ; int dp [ k + 1 ] [ n + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; if ( arr [ j - 1 ] <= i ) dp [ i ] [ j ] += dp [ i / arr [ j - 1 ] ] [ j - 1 ] + 1 ; } } return dp [ k ] [ n ] ; }
int waysToArrange ( int N , int K , int k [ ] ) { int C [ N + 1 ] [ N + 1 ] ; int i , j ; for ( i = 0 ; i <= N ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } int dp [ K ] ; int count = 0 ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < K ; i ++ ) { dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) ; count += k [ i ] ; } return dp [ K ] ; }
int LIP ( int dp [ ] [ MAX ] , int mat [ ] [ MAX ] , int n , int m , int x , int y ) { if ( dp [ x ] [ y ] < 0 ) { int result = 0 ; if ( x == n - 1 && y == m - 1 ) return dp [ x ] [ y ] = 1 ; if ( x == n - 1 y == m - 1 ) result = 1 ; if ( mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) ; if ( mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) result = max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) ; dp [ x ] [ y ] = result ; } return dp [ x ] [ y ] ; }
int wrapper ( int mat [ ] [ MAX ] , int n , int m ) { int dp [ MAX ] [ MAX ] ; memset ( dp , -1 , sizeof dp ) ; return LIP ( dp , mat , n , m , 0 , 0 ) ; }
int minCells ( int mat [ SIZE ] [ SIZE ] , int m , int n ) { int dp [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = INT_MAX ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != INT_MAX && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != INT_MAX && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m - 1 ] [ n - 1 ] != INT_MAX ) return dp [ m - 1 ] [ n - 1 ] ; return -1 ; }
int GetCeilIndex ( int arr [ ] , vector < int > & T , int l , int r , int key ) { while ( r - l > 1 ) { int m = l + ( r - l ) / 2 ; if ( arr [ T [ m ] ] >= key ) r = m ; else l = m ; } return r ; }
void LIS ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ tailIndices [ 0 ] ] ) tailIndices [ 0 ] = i ; else if ( arr [ i ] > arr [ tailIndices [ len - 1 ] ] ) { prevIndices [ i ] = tailIndices [ len - 1 ] ; tailIndices [ len ++ ] = i ; } else { int pos = GetCeilIndex ( arr , tailIndices , -1 , len - 1 , arr [ i ] ) ; prevIndices [ i ] = tailIndices [ pos - 1 ] ; tailIndices [ pos ] = i ; } } for ( int i = tailIndices [ len - 1 ] ; i >= 0 ; i = prevIndices [ i ] ) res . push_back ( arr [ i ] ) ; }
void longestBitonic ( int arr1 [ ] , int n1 , int arr2 [ ] , int n2 ) { LIS ( arr1 , n1 ) ; reverse ( res . begin ( ) , res . end ( ) ) ; reverse ( arr2 , arr2 + n2 ) ; LIS ( arr2 , n2 ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << " " ; }
bool ElementsCalculationFunc ( int pre [ ] , int maxx [ ] , int x , int k , int n ) { for ( int i = 0 , j = x ; j <= n ; j ++ , i ++ ) { if ( x * maxx [ j ] - ( pre [ j ] - pre [ i ] ) <= k ) return true ; } return false ; }
int solve ( int dp [ ] [ MAX ] , int a [ ] , int low , int high , int turn ) { if ( low == high ) return a [ low ] * turn ; if ( dp [ low ] [ high ] != 0 ) return dp [ low ] [ high ] ; dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; return dp [ low ] [ high ] ; }
int cal ( int ones [ R + 1 ] [ C + 1 ] , int x , int y , int k ) { return ones [ x + k - 1 ] [ y + k - 1 ] - ones [ x - 1 ] [ y + k - 1 ] - ones [ x + k - 1 ] [ y - 1 ] + ones [ x - 1 ] [ y - 1 ] ; }
int sol ( int mat [ R ] [ C ] ) { int ans = 0 ; int ones [ R + 1 ] [ C + 1 ] = { 0 } ; for ( int i = 1 ; i <= R ; i ++ ) for ( int j = 1 ; j <= C ; j ++ ) ones [ i ] [ j ] = ones [ i - 1 ] [ j ] + ones [ i ] [ j - 1 ] - ones [ i - 1 ] [ j - 1 ] + ( mat [ i - 1 ] [ j - 1 ] == 1 ) ; for ( int k = 1 ; k <= min ( R , C ) ; k ++ ) for ( int i = 1 ; i + k - 1 <= R ; i ++ ) for ( int j = 1 ; j + k - 1 <= C ; j ++ ) ans = max ( ans , ( ones [ R ] [ C ] + k * k - 2 * cal ( ones , i , j , k ) ) ) ; return ans ; }
int maxSumBitonicSubArr ( int arr [ ] , int n ) { int msis [ n ] , msds [ n ] ; int max_sum = INT_MIN ; msis [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ; msds [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ; return max_sum ; }
int maxSumBitonicSubArr ( int arr [ ] , int n ) { int max_sum = INT_MIN ; int i = 0 ; while ( i < n ) { int j = i ; while ( j + 1 < n && arr [ j ] < arr [ j + 1 ] ) j ++ ; while ( i < j && arr [ i ] <= 0 ) i ++ ; int k = j ; while ( k + 1 < n && arr [ k ] > arr [ k + 1 ] ) k ++ ; int last = k ; while ( k > j && arr [ k ] <= 0 ) k -- ; int sum_inc = accumulate ( arr + i , arr + j + 1 , 0 ) ; int sum_dec = accumulate ( arr + j , arr + k + 1 , 0 ) ; int sum_all = sum_inc + sum_dec - arr [ j ] ; max_sum = max ( { max_sum , sum_inc , sum_dec , sum_all } ) ; i = max ( last , i + 1 ) ; } return max_sum ; }
long countWays ( int n ) { long dp [ 2 ] [ n + 1 ] ; dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }
int countways ( long long n ) { long long A [ n + 1 ] ; A [ 0 ] = 1 ; A [ 1 ] = 3 ; A [ 2 ] = 7 ; for ( int i = 2 ; i <= n ; i ++ ) { A [ i ] = 2 * A [ i - 1 ] + A [ i - 2 ] ; } return A [ n ] ; }
bool findWinner ( int x , int y , int n ) { int dp [ n + 1 ] ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 and ! dp [ i - 1 ] ) dp [ i ] = true ; else if ( i - x >= 0 and ! dp [ i - x ] ) dp [ i ] = true ; else if ( i - y >= 0 and ! dp [ i - y ] ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; }
void printSuperSeq ( string & a , string & b ) { int m = a . length ( ) , n = b . length ( ) ; int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( ! i ) dp [ i ] [ j ] = j ; else if ( ! j ) dp [ i ] [ j ] = i ; else if ( a [ i - 1 ] == b [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } int index = dp [ m ] [ n ] ; string res ( index + 1 , '\0' ) ; int i = m , j = n ; while ( i > 0 && j > 0 ) { if ( a [ i - 1 ] == b [ j - 1 ] ) { res [ index - 1 ] = a [ i - 1 ] ; i -- ; j -- ; index -- ; } else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) { res [ index - 1 ] = a [ i - 1 ] ; i -- ; index -- ; } else { res [ index - 1 ] = b [ j - 1 ] ; j -- ; index -- ; } } while ( i > 0 ) { res [ index - 1 ] = a [ i - 1 ] ; i -- ; index -- ; } while ( j > 0 ) { res [ index - 1 ] = b [ j - 1 ] ; j -- ; index -- ; } cout << res ; }
int maxGameByWinner ( int N ) { int dp [ N ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; int i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; }
bool isSubsetSum ( int arr [ ] , int n , int sum ) { bool subset [ 2 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) subset [ i % 2 ] [ j ] = true ; else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ; else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] || subset [ ( i + 1 ) % 2 ] [ j ] ; else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] ; } } return subset [ n % 2 ] [ sum ] ; }
int countTransformation ( string a , string b ) { int n = a . size ( ) , m = b . size ( ) ; if ( m == 0 ) return 1 ; int dp [ m ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( i == 0 ) { if ( j == 0 ) dp [ i ] [ j ] = ( a [ j ] == b [ i ] ) ? 1 : 0 ; else if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } else { if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } } return dp [ m - 1 ] [ n - 1 ] ; }
int getSpecialNumber ( int N ) { return ans ( -- N ) ; }
int minimumSquare ( int m , int n ) { int vertical_min = INT_MAX ; int horizontal_min = INT_MAX ; if ( n == 13 && m == 11 ) return 6 ; if ( m == 13 && n == 11 ) return 6 ; if ( m == n ) return 1 ; if ( dp [ m ] [ n ] ) return dp [ m ] [ n ] ; for ( int i = 1 ; i <= m / 2 ; i ++ ) { horizontal_min = min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontal_min ) ; } for ( int j = 1 ; j <= n / 2 ; j ++ ) { vertical_min = min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , vertical_min ) ; } dp [ m ] [ n ] = min ( vertical_min , horizontal_min ) ; return dp [ m ] [ n ] ; }
long long int fact ( int n ) { long long int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
long long int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
long countWays ( int n , int k ) { long total = k ; int mod = 1000000007 ; int same = 0 , diff = k ; for ( int i = 2 ; i <= n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; }
int computeLIS ( int circBuff [ ] , int start , int end , int n ) { int LIS [ end - start ] ; for ( int i = start ; i < end ; i ++ ) LIS [ i ] = 1 ; for ( int i = start + 1 ; i < end ; i ++ ) for ( int j = start ; j < i ; j ++ ) if ( circBuff [ i ] > circBuff [ j ] && LIS [ i ] < LIS [ j ] + 1 ) LIS [ i ] = LIS [ j ] + 1 ; int res = INT_MIN ; for ( int i = start ; i < end ; i ++ ) res = max ( res , LIS [ i ] ) ; return res ; }
int LICS ( int arr [ ] , int n ) { int circBuff [ 2 * n ] ; for ( int i = 0 ; i < n ; i ++ ) circBuff [ i ] = arr [ i ] ; for ( int i = n ; i < 2 * n ; i ++ ) circBuff [ i ] = arr [ i - n ] ; int res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) res = max ( computeLIS ( circBuff , i , i + n , n ) , res ) ; return res ; }
long long int countBT ( int h ) { long long int dp [ h + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % mod + dp [ i - 1 ] ) % mod ) % mod ; } return dp [ h ] ; }
int minTimeForWritingChars ( int N , int insert , int remove , int copy ) { if ( N == 0 ) return 0 ; if ( N == 1 ) return insert ; int dp [ N + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 1 ] = insert ; for ( int i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + copy ) ; else dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) / 2 ] + copy + remove ) ; } return dp [ N ] ; }
int countPaths ( int n , int m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; }
int countPaths ( int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; }
int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
int sumOfSubstrings ( string num ) { long long int mf = 1 ; for ( int i = num . size ( ) - 1 ; i >= 0 ; i -- ) { sum += ( num [ i ] - '0' ) * ( i + 1 ) * mf ; mf = mf * 10 + 1 ; } return sum ; }
int countWays ( int n , int m ) { int count [ n + 1 ] ; count [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m i == 1  ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; }
int maxSum ( int grid [ 2 ] [ MAX ] , int n ) { int incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; int excl = 0 , excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = max ( excl , incl ) ; incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; excl = excl_new ; } return max ( excl , incl ) ; }
int maxSumWithK ( int a [ ] , int n , int k ) { int maxSum [ n ] ; maxSum [ 0 ] = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { curr_max = max ( a [ i ] , curr_max + a [ i ] ) ; maxSum [ i ] = curr_max ; } int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += a [ i ] ; int result = sum ; for ( int i = k ; i < n ; i ++ ) { sum = sum + a [ i ] - a [ i - k ] ; result = max ( result , sum ) ; result = max ( result , sum + maxSum [ i - k ] ) ; } return result ; }
int getTotalNumberOfSequences ( int m , int n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }
int getTotalNumberOfSequences ( int m , int n ) { int T [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] ; } } return T [ m ] [ n ] ; }
int minInsertionStepToSortArray ( int arr [ ] , int N ) { int lis [ N ] ; for ( int i = 0 ; i < N ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int max = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return ( N - max ) ; }
void printDistinct ( char * str ) { int count [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; * ( str + i ) ; i ++ ) if ( * ( str + i ) != ' ' ) count [ * ( str + i ) ] ++ ; int n = i ; for ( i = 0 ; i < n ; i ++ ) if ( count [ * ( str + i ) ] == 1 ) cout << str [ i ] ; }
int lcs ( string str1 , string str2 , int m , int n ) { int L [ m + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( str1 . at ( i - 1 ) == str2 . at ( j - 1 ) ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; }
void countWaysToJump ( int arr [ ] , int n ) { int count_jump [ n ] ; memset ( count_jump , 0 , sizeof ( count_jump ) ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != -1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = -1 ; } for ( int i = 0 ; i < n ; i ++ ) cout << count_jump [ i ] << " " ; }
int lis ( int arr [ ] , int n ) { int result = 0 ; int lis [ n ] ; for ( int i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < lis [ i ] ) result = lis [ i ] ; return result ; }
int minStepToDeleteString ( string str ) { int N = str . length ( ) ; int dp [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= N ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int len = 1 ; len <= N ; len ++ ) { for ( int i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) { if ( len == 1 ) dp [ i ] [ j ] = 1 ; else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( str [ i ] == str [ i + 1 ] ) dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; for ( int K = i + 2 ; K <= j ; K ++ ) if ( str [ i ] == str [ K ] ) dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } return dp [ 0 ] [ N - 1 ] ; }
void solve ( int i , int par , int a [ ] , int n , int k , int current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = min ( ans , current_ans ) ; return ; } for ( int j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }
int minCost ( int a [ ] , int n , int k ) { int dp [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= k ; j ++ ) dp [ i ] [ j ] = inf ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) for ( int m = i - 1 ; m >= 0 ; m -- ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; return dp [ n ] [ k ] ; }
int getMinSteps ( int n ) { int table [ n + 1 ] ; table [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! ( i % 2 ) && ( i % 3 ) ) table [ i ] = 1 + min ( table [ i - 1 ] , table [ i / 2 ] ) ; else if ( ! ( i % 3 ) && ( i % 2 ) ) table [ i ] = 1 + min ( table [ i - 1 ] , table [ i / 3 ] ) ; else if ( ! ( i % 2 ) && ! ( i % 3 ) ) table [ i ] = 1 + min ( table [ i - 1 ] , min ( table [ i / 2 ] , table [ i / 3 ] ) ) ; else table [ i ] = 1 + table [ i - 1 ] ; } return table [ n ] ; }
int minimumNumberOfDeletions ( string str ) { int n = str . size ( ) ; int len = lps ( str ) ; return ( n - len ) ; }
int utility_fun_for_del ( string str , int i , int j ) { if ( i >= j ) return 0 ; if ( str [ i ] == str [ j ] ) { return utility_fun_for_del ( str , i + 1 , j - 1 ) ; } return 1 + min ( utility_fun_for_del ( str , i + 1 , j ) , utility_fun_for_del ( str , i , j - 1 ) ) ; }
int min_ele_del ( string str ) { return utility_fun_for_del ( str , 0 , str . length ( ) - 1 ) ; }
int numofArray ( int n , int m ) { int dp [ MAX ] [ MAX ] ; vector < int > di [ MAX ] ; vector < int > mu [ MAX ] ; memset ( dp , 0 , sizeof dp ) ; memset ( di , 0 , sizeof di ) ; memset ( mu , 0 , sizeof mu ) ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 2 * i ; j <= m ; j += i ) { di [ j ] . push_back ( i ) ; mu [ i ] . push_back ( j ) ; } di [ i ] . push_back ( i ) ; } for ( int i = 1 ; i <= m ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; for ( auto x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; for ( auto x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { ans += dp [ n ] [ i ] ; di [ i ] . clear ( ) ; mu [ i ] . clear ( ) ; } return ans ; }
int offeringNumber ( int n , int templeHeight [ ] ) { for ( int i = 0 ; i < n ; ++ i ) { int left = 0 , right = 0 ; for ( int j = i - 1 ; j >= 0 ; -- j ) { if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ left ; else break ; } for ( int j = i + 1 ; j < n ; ++ j ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ right ; else break ; } sum += max ( right , left ) + 1 ; } return sum ; }
int stringReduction ( string str ) { int n = str . length ( ) ; int count [ 3 ] = { 0 } ; for ( int i = 0 ; i < n ; ++ i ) count [ str [ i ] - 'a' ] ++ ; if ( count [ 0 ] == n count [ 1 ] == n count [ 2 ] == n ) return n ; if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) return 2 ; return 1 ; }
bool modularSum ( int arr [ ] , int n , int m ) { if ( n > m ) return true ; bool DP [ m ] ; memset ( DP , false , m ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; bool temp [ m ] ; memset ( temp , false , m ) ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }
int maxSum ( int tri [ ] [ 3 ] , int n ) { if ( n > 1 ) tri [ 1 ] [ 1 ] = tri [ 1 ] [ 1 ] + tri [ 0 ] [ 0 ] ; tri [ 1 ] [ 0 ] = tri [ 1 ] [ 0 ] + tri [ 0 ] [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { tri [ i ] [ 0 ] = tri [ i ] [ 0 ] + tri [ i - 1 ] [ 0 ] ; tri [ i ] [ i ] = tri [ i ] [ i ] + tri [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j < i ; j ++ ) { if ( tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] >= tri [ i ] [ j ] + tri [ i - 1 ] [ j ] ) tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] ; else tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j ] ; } } int max = tri [ n - 1 ] [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( max < tri [ n - 1 ] [ i ] ) max = tri [ n - 1 ] [ i ] ; } return max ; }
int largestZigZagSumRec ( int mat [ ] [ MAX ] , int i , int j , int n ) { if ( dp [ i ] [ j ] != -1 ) return dp [ i ] [ j ] ; if ( i == n - 1 ) return ( dp [ i ] [ j ] = mat [ i ] [ j ] ) ; int zzs = 0 ; for ( int k = 0 ; k < n ; k ++ ) if ( k != j ) zzs = max ( zzs , largestZigZagSumRec ( mat , i + 1 , k , n ) ) ; return ( dp [ i ] [ j ] = ( zzs + mat [ i ] [ j ] ) ) ; }
int largestZigZag ( int mat [ ] [ MAX ] , int n ) { memset ( dp , -1 , sizeof ( dp ) ) ; int res = 0 ; for ( int j = 0 ; j < n ; j ++ ) res = max ( res , largestZigZagSumRec ( mat , 0 , j , n ) ) ; return res ; }
int countEndless ( bool input [ ] [ MAX ] , int n ) { bool row [ n ] [ n ] , col [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { bool isEndless = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( input [ i ] [ j ] == 0 ) isEndless = 0 ; col [ i ] [ j ] = isEndless ; } } for ( int i = 0 ; i < n ; i ++ ) { bool isEndless = 1 ; for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( input [ i ] [ j ] == 0 ) isEndless = 0 ; row [ i ] [ j ] = isEndless ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ; return ans ; }
int countSubsequences ( string s ) { int aCount = 0 ; int bCount = 0 ; int cCount = 0 ; for ( unsigned int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == 'a' ) aCount = ( 1 + 2 * aCount ) ; else if ( s [ i ] == 'b' ) bCount = ( aCount + 2 * bCount ) ; else if ( s [ i ] == 'c' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }
int maximumDifferenceSum ( int arr [ ] , int N ) { int dp [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }
int countStr ( int n , int bCount , int cCount ) { if ( bCount < 0 cCount < 0  ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; int res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }
int maxRevenue ( int m , int x [ ] , int revenue [ ] , int n , int t ) { int maxRev [ m + 1 ] ; memset ( maxRev , 0 , sizeof ( maxRev ) ) ; int nxtbb = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; }
int getMaxGold ( int gold [ ] [ MAX ] , int m , int n ) { int goldTable [ m ] [ n ] ; memset ( goldTable , 0 , sizeof ( goldTable ) ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , max ( right_up , right_down ) ) ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = max ( res , goldTable [ i ] [ 0 ] ) ; return res ; }
int largestKSubmatrix ( int a [ ] [ Col ] ) { int dp [ Row ] [ Col ] ; memset ( dp , sizeof ( dp ) , 0 ) ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 ; else dp [ i ] [ j ] = 1 ; } result = max ( result , dp [ i ] [ j ] ) ; } } return result ; }
int countDivisibleSubseq ( string str , int n ) { int len = str . length ( ) ; int dp [ len ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ ( str [ 0 ] - '0' ) % n ] ++ ; for ( int i = 1 ; i < len ; i ++ ) { dp [ i ] [ ( str [ i ] - '0' ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( str [ i ] - '0' ) ) % n ] += dp [ i - 1 ] [ j ] ; } } return dp [ len - 1 ] [ 0 ] ; }
int MaximumPath ( int Mat [ ] [ N ] ) { int result = 0 ; int dp [ N ] [ N + 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < N ; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) result = max ( result , dp [ N - 1 ] [ i ] ) ; return result ; }
double probability ( int k , int n ) { double ans = 0 ; for ( int i = k ; i <= n ; ++ i ) ans += fact [ n ] / ( fact [ i ] * fact [ n - i ] ) ; ans = ans / ( 1LL << n ) ; return ans ; }
void precompute ( ) { fact [ 0 ] = fact [ 1 ] = 1 ; for ( int i = 2 ; i < 20 ; ++ i ) fact [ i ] = fact [ i - 1 ] * i ; }
double probability ( int k , int n ) { double ans = 0 ; for ( int i = k ; i <= n ; ++ i ) { double res = dp [ n ] - dp [ i ] - dp [ n - i ] - n ; ans += pow ( 2.0 , res ) ; } return ans ; }
void precompute ( ) { for ( int i = 2 ; i < MAX ; ++ i ) dp [ i ] = log2 ( i ) + dp [ i - 1 ] ; }
int countStrings ( int n , int k ) { int dp [ n + 1 ] [ k + 1 ] [ 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 1 ] [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= k ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }
bool canVote ( int a [ ] , int n , int x ) { int dp [ n + 1 ] [ x + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += a [ i ] ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= x ; j ++ ) if ( a [ i ] <= j ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , a [ i ] + dp [ i - 1 ] [ j - a [ i ] ] ) ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; return ( sum - dp [ n ] [ x ] <= x ) ; }
int countFriendsPairings ( int n ) { int dp [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }
int countFriendsPairings ( int n ) { if ( dp [ n ] != -1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else return dp [ n ] = n ; }
int countFriendsPairings ( int n ) { int a = 1 , b = 2 , c = 0 ; if ( n <= 2 ) { return n ; } for ( int i = 3 ; i <= n ; i ++ ) { c = b + ( i - 1 ) * a ; a = b ; b = c ; } return c ; }
int maxPathSum ( int tri [ ] [ N ] , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; }
int findMaxPoints ( int A [ ] [ M ] ) { int P1S [ M + 1 ] [ N + 1 ] , P1E [ M + 1 ] [ N + 1 ] ; memset ( P1S , 0 , sizeof ( P1S ) ) ; memset ( P1E , 0 , sizeof ( P1E ) ) ; int P2S [ M + 1 ] [ N + 1 ] , P2E [ M + 1 ] [ N + 1 ] ; memset ( P2S , 0 , sizeof ( P2S ) ) ; memset ( P2E , 0 , sizeof ( P2E ) ) ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 1 ; j <= M ; j ++ ) P1S [ i ] [ j ] = max ( P1S [ i - 1 ] [ j ] , P1S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = M ; j >= 1 ; j -- ) P1E [ i ] [ j ] = max ( P1E [ i + 1 ] [ j ] , P1E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = N ; i >= 1 ; i -- ) for ( int j = 1 ; j <= M ; j ++ ) P2S [ i ] [ j ] = max ( P2S [ i + 1 ] [ j ] , P2S [ i ] [ j - 1 ] ) + A [ i - 1 ] [ j - 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = M ; j >= 1 ; j -- ) P2E [ i ] [ j ] = max ( P2E [ i - 1 ] [ j ] , P2E [ i ] [ j + 1 ] ) + A [ i - 1 ] [ j - 1 ] ; int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { for ( int j = 2 ; j < M ; j ++ ) { int op1 = P1S [ i ] [ j - 1 ] + P1E [ i ] [ j + 1 ] + P2S [ i + 1 ] [ j ] + P2E [ i - 1 ] [ j ] ; int op2 = P1S [ i - 1 ] [ j ] + P1E [ i + 1 ] [ j ] + P2S [ i ] [ j - 1 ] + P2E [ i ] [ j + 1 ] ; ans = max ( ans , max ( op1 , op2 ) ) ; } } return ans ; }
bool inside ( int x , int y ) { return ( x >= 0 and x < N and y > = 0 and y < N ) ; }
double findProb ( int start_x , int start_y , int steps ) { double dp1 [ N ] [ N ] [ steps + 1 ] ; for ( int i = 0 ; i < N ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) dp1 [ i ] [ j ] [ 0 ] = 1 ; for ( int s = 1 ; s <= steps ; ++ s ) { for ( int x = 0 ; x < N ; ++ x ) { for ( int y = 0 ; y < N ; ++ y ) { double prob = 0.0 ; for ( int i = 0 ; i < 8 ; ++ i ) { int nx = x + dx [ i ] ; int ny = y + dy [ i ] ; if ( inside ( nx , ny ) ) prob += dp1 [ nx ] [ ny ] [ s - 1 ] / 8.0 ; } dp1 [ x ] [ y ] [ s ] = prob ; } } } return dp1 [ start_x ] [ start_y ] [ steps ] ; }
int lcsOf3 ( string X , string Y , string Z , int m , int n , int o ) { int L [ m + 1 ] [ n + 1 ] [ o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 j == 0 k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; }
int lcsOf3 ( int i , int j , int k ) { if ( i == -1 j == -1 k == -1 ) return 0 ; if ( dp [ i ] [ j ] [ k ] != -1 ) return dp [ i ] [ j ] [ k ] ; if ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ; else return dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) ; }
void distSumRec ( int arr [ ] , int n , int sum , int currindex , unordered_set < int > & s ) { if ( currindex > n ) return ; if ( currindex == n ) { s . insert ( sum ) ; return ; } distSumRec ( arr , n , sum + arr [ currindex ] , currindex + 1 , s ) ; distSumRec ( arr , n , sum , currindex + 1 , s ) ; }
void printDistSum ( int arr [ ] , int n ) { unordered_set < int > s ; distSumRec ( arr , n , 0 , 0 , s ) ; for ( auto i = s . begin ( ) ; i != s . end ( ) ; i ++ ) cout << * i << " " ; }
void printDistSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; bool dp [ n + 1 ] [ sum + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( int j = 0 ; j <= sum ; j ++ ) if ( dp [ n ] [ j ] == true ) cout << j << " " ; }
void printMaxSum ( int arr [ ] , int n ) { int dp [ n ] ; memset ( dp , 0 , sizeof dp ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; int maxi = 0 ; for ( int j = 1 ; j <= sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += maxi ; } for ( int i = 0 ; i < n ; i ++ ) cout << dp [ i ] << " " ; }
int countPaths ( int maze [ ] [ C ] ) { if ( maze [ 0 ] [ 0 ] == -1 ) return 0 ; for ( int i = 0 ; i < R ; i ++ ) { if ( maze [ i ] [ 0 ] == 0 ) maze [ i ] [ 0 ] = 1 ; else break ; } for ( int i = 1 ; i < C ; i ++ ) { if ( maze [ 0 ] [ i ] == 0 ) maze [ 0 ] [ i ] = 1 ; else break ; } for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) { if ( maze [ i ] [ j ] == -1 ) continue ; if ( maze [ i - 1 ] [ j ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) ; if ( maze [ i ] [ j - 1 ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; } } return ( maze [ R - 1 ] [ C - 1 ] > 0 ) ? maze [ R - 1 ] [ C - 1 ] : 0 ; }
int minSum ( int arr [ ] , int n ) { int dp [ n ] ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return min ( arr [ 0 ] , arr [ 1 ] ) ; if ( n == 3 ) return min ( arr [ 0 ] , min ( arr [ 1 ] , arr [ 2 ] ) ) ; if ( n == 4 ) return min ( min ( arr [ 0 ] , arr [ 1 ] ) , min ( arr [ 2 ] , arr [ 3 ] ) ) ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = arr [ 1 ] ; dp [ 2 ] = arr [ 2 ] ; dp [ 3 ] = arr [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp [ i - 2 ] ) , min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ; return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ; }
int minSum ( int ar [ ] , int n ) { if ( n <= 4 ) return * min_element ( ar , ar + n ) ; int sum [ n ] ; sum [ 0 ] = ar [ 0 ] ; sum [ 1 ] = ar [ 1 ] ; sum [ 2 ] = ar [ 2 ] ; sum [ 3 ] = ar [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) sum [ i ] = ar [ i ] + ( * min_element ( sum + i - 4 , sum + i ) ) ; return * min_element ( sum + n - 4 , sum + n ) ; }
void printMinAndMaxValueOfExp ( string exp ) { vector < int > num ; vector < char > opr ; string tmp = "" ; for ( int i = 0 ; i < exp . length ( ) ; i ++ ) { if ( isOperator ( exp [ i ] ) ) { opr . push_back ( exp [ i ] ) ; num . push_back ( atoi ( tmp . c_str ( ) ) ) ; tmp = "" ; } else { tmp += exp [ i ] ; } } num . push_back ( atoi ( tmp . c_str ( ) ) ) ; int len = num . size ( ) ; int minVal [ len ] [ len ] ; int maxVal [ len ] [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = 0 ; j < len ; j ++ ) { minVal [ i ] [ j ] = INT_MAX ; maxVal [ i ] [ j ] = 0 ; if ( i == j ) minVal [ i ] [ j ] = maxVal [ i ] [ j ] = num [ i ] ; } } for ( int L = 2 ; L <= len ; L ++ ) { for ( int i = 0 ; i < len - L + 1 ; i ++ ) { int j = i + L - 1 ; for ( int k = i ; k < j ; k ++ ) { int minTmp = 0 , maxTmp = 0 ; if ( opr [ k ] == '+' ) { minTmp = minVal [ i ] [ k ] + minVal [ k + 1 ] [ j ] ; maxTmp = maxVal [ i ] [ k ] + maxVal [ k + 1 ] [ j ] ; } else if ( opr [ k ] == '*' ) { minTmp = minVal [ i ] [ k ] * minVal [ k + 1 ] [ j ] ; maxTmp = maxVal [ i ] [ k ] * maxVal [ k + 1 ] [ j ] ; } if ( minTmp < minVal [ i ] [ j ] ) minVal [ i ] [ j ] = minTmp ; if ( maxTmp > maxVal [ i ] [ j ] ) maxVal [ i ] [ j ] = maxTmp ; } } } cout << "Minimum value : " << minVal [ 0 ] [ len - 1 ] << ", Maximum value : " << maxVal [ 0 ] [ len - 1 ] ; }
long long int maxDecimalValue ( int mat [ ] [ N ] , int i , int j , int p ) { if ( i >= N j >= N ) return 0 ; int result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) ; if ( mat [ i ] [ j ] == 1 ) return pow ( 2 , p ) + result ; else return result ; }
long long int MaximumDecimalValue ( int mat [ ] [ N ] , int n ) { int dp [ n ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; if ( mat [ 0 ] [ 0 ] == 1 ) for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ 0 ] [ i ] == 1 ) dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + pow ( 2 , i ) ; else dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ; } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ i ] [ 0 ] == 1 ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + pow ( 2 , i ) ; else dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + pow ( 2 , i + j ) ; else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n - 1 ] [ n - 1 ] ; }
int longestSubseqWithDiffOne ( int arr [ ] , int n ) { int dp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) ; } } int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }
int nCr ( int n , int k ) { int C [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
double resultOfAllSubsets ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; for ( int n = 1 ; n <= N ; n ++ ) result += ( double ) ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n ; return result ; }
int maxSumWO3Consec ( int arr [ ] , int n ) { int sum [ n ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }
int maxSumWO3Consec ( int n ) { if ( sum [ n ] != -1 ) return sum [ n ] ; if ( n == 0 ) return sum [ n ] = 0 ; if ( n == 1 ) return sum [ n ] = arr [ 0 ] ; if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; return sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; }
int maxAlternateSum ( int arr [ ] , int n ) { if ( n == 1 ) return arr [ 0 ] ; int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( min > arr [ i ] ) min = arr [ i ] ; } if ( min == arr [ 0 ] ) { return arr [ 0 ] ; } int dec [ n ] ; memset ( dec , 0 , sizeof ( dec ) ) ; int inc [ n ] ; memset ( inc , 0 , sizeof ( inc ) ) ; dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ; int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] ) ; } } int result = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( result < inc [ i ] ) result = inc [ i ] ; if ( result < dec [ i ] ) result = dec [ i ] ; } return result ; }
int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int dp [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; }
void printInorder ( TreeNode * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; cout << node -> val << " " ; printInorder ( node -> right ) ; }
int lucas ( int n ) { int a = 2 , b = 1 , c , i ; if ( n == 0 ) return a ; for ( i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return b ; }
double maxAverageOfPath ( int cost [ M ] [ M ] , int N ) { int dp [ N + 1 ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( int j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
int breakSum ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = 0 , dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ; return dp [ n ] ; }
int countPS ( string str ) { int N = str . length ( ) ; int cps [ N + 1 ] [ N + 1 ] ; memset ( cps , 0 , sizeof ( cps ) ) ; for ( int i = 0 ; i < N ; i ++ ) cps [ i ] [ i ] = 1 ; for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i <= N - L ; i ++ ) { int k = L + i - 1 ; if ( str [ i ] == str [ k ] ) cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ; else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ; } } return cps [ 0 ] [ N - 1 ] ; }
int countPS ( int i , int j ) { if ( i > j ) return 0 ; if ( dp [ i ] [ j ] != -1 ) return dp [ i ] [ j ] ; if ( i == j ) return dp [ i ] [ j ] = 1 ; else if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; }
int lcs ( string str1 , string str2 , int len1 , int len2 , int i , int j ) { int & ret = dp [ i ] [ j ] ; if ( i == len1 j == len2 ) return ret = 0 ; if ( ret != -1 ) return ret ; ret = 0 ; if ( str1 [ i ] == str2 [ j ] ) ret = 1 + lcs ( str1 , str2 , len1 , len2 , i + 1 , j + 1 ) ; else ret = max ( lcs ( str1 , str2 , len1 , len2 , i + 1 , j ) , lcs ( str1 , str2 , len1 , len2 , i , j + 1 ) ) ; return ret ; }
void prinlAllLCSSorted ( string str1 , string str2 ) { int len1 = str1 . length ( ) , len2 = str2 . length ( ) ; memset ( dp , -1 , sizeof ( dp ) ) ; lcslen = lcs ( str1 , str2 , len1 , len2 , 0 , 0 ) ; char data [ MAX ] ; printAll ( str1 , str2 , len1 , len2 , data , 0 , 0 , 0 ) ; }
int maxCost ( int mat [ ] [ MAX ] , int N ) { int dp [ N ] [ N ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; }
int numberOfPermWithKInversion ( int N , int K ) { if ( N == 0 ) return 0 ; if ( K == 0 ) return 1 ; if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ; int sum = 0 ; for ( int i = 0 ; i <= K ; i ++ ) { if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 1 , K - i ) ; } memo [ N ] [ K ] = sum ; return sum ; }
int countSub ( int arr [ ] , int n ) { int count [ 10 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - 1 ; j >= 0 ; j -- ) count [ arr [ i ] ] += count [ j ] ; count [ arr [ i ] ] ++ ; } int result = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) result += count [ i ] ; return result ; }
int minimum ( int a , int b , int c ) { return min ( min ( a , b ) , c ) ; }
int countSub ( string s ) { map < char , int > Map ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { Map [ s [ i ] ] = -1 ; } int allCount = 0 ; int levelCount = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s [ i ] ; if ( i == 0 ) { allCount = 1 ; Map = 1 ; levelCount = 1 ; continue ; } levelCount = allCount + 1 ; if ( Map < 0 ) { allCount = allCount + levelCount ; } else { allCount = allCount + levelCount - Map ; } Map = levelCount ; } return allCount ; }
unsigned long int catalanDP ( unsigned int n ) { unsigned long int catalan [ n + 1 ] ; catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } return catalan [ n ] ; }
unsigned long int countWays ( unsigned long int n ) { if ( n & 1 ) { cout << "Invalid" ; return 0 ; } return catalanDP ( n / 2 ) ; }
int countGroups ( int position , int previous_sum , int length , char * num ) { if ( position == length ) return 1 ; if ( dp [ position ] [ previous_sum ] != -1 ) return dp [ position ] [ previous_sum ] ; dp [ position ] [ previous_sum ] = 0 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position ] [ previous_sum ] = res ; return res ; }
int MinimumCost ( int cost [ ] , int n , int W ) { vector < int > val , wt ; int size = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( cost [ i ] != -1 ) { val . push_back ( cost [ i ] ) ; wt . push_back ( i + 1 ) ; size ++ ; } } n = size ; int min_cost [ n + 1 ] [ W + 1 ] ; for ( int i = 0 ; i <= W ; i ++ ) min_cost [ 0 ] [ i ] = INF ; for ( int i = 1 ; i <= n ; i ++ ) min_cost [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= W ; j ++ ) { if ( wt [ i - 1 ] > j ) min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] ; else min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) ; } } return ( min_cost [ n ] [ W ] == INF ) ? -1 : min_cost [ n ] [ W ] ; }
int minCost ( int cost [ ] , int n ) { int dp [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int min_cost = INT_MAX ; for ( int j = 0 ; j < i ; j ++ ) if ( j < n && cost [ j ] != -1 ) min_cost = min ( min_cost , cost [ j ] + dp [ i - j - 1 ] ) ; dp [ i ] = min_cost ; } return dp [ n ] ; }
int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int dp [ W + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; }
int count ( string a , string b , int m , int n ) { if ( ( m == 0 && n == 0 ) n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; }
int count ( string a , string b ) { int m = a . length ( ) ; int n = b . length ( ) ; int lookup [ m + 1 ] [ n + 1 ] = { { 0 } } ; for ( int i = 0 ; i <= n ; ++ i ) lookup [ 0 ] [ i ] = 0 ; for ( int i = 0 ; i <= m ; ++ i ) lookup [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ; else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ; } } return lookup [ m ] [ n ] ; }
int lcs ( char * X , char * Y , int m , int n ) { int L [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; }
int findMinCost ( char X [ ] , char Y [ ] , int costX , int costY ) { int m = strlen ( X ) , n = strlen ( Y ) ; int len_LCS = lcs ( X , Y , m , n ) ; return costX * ( m - len_LCS ) + costY * ( n - len_LCS ) ; }
int findSum ( vector < int > arr ) { int sum = 0 ; for ( int i : arr ) sum += i ; return sum ; }
int maxTasks ( int high [ ] , int low [ ] , int n ) { if ( n <= 0 ) return 0 ; return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; }
int maxTasks ( int high [ ] , int low [ ] , int n ) { int task_dp [ n + 1 ] ; task_dp [ 0 ] = 0 ; task_dp [ 1 ] = high [ 0 ] ; for ( int i = 2 ; i <= n ; i ++ ) task_dp [ i ] = max ( high [ i - 1 ] + task_dp [ i - 2 ] , low [ i - 1 ] + task_dp [ i - 1 ] ) ; return task_dp [ n ] ; }
set < string > findLCS ( string X , string Y , int m , int n ) { set < string > s ; if ( m == 0 n == 0 ) { s . insert ( "" ) ; return s ; } if ( X [ m - 1 ] == Y [ n - 1 ] ) { set < string > tmp = findLCS ( X , Y , m - 1 , n - 1 ) ; for ( string str : tmp ) s . insert ( str + X [ m - 1 ] ) ; } else { if ( L [ m - 1 ] [ n ] >= L [ m ] [ n - 1 ] ) s = findLCS ( X , Y , m - 1 , n ) ; if ( L [ m ] [ n - 1 ] >= L [ m - 1 ] [ n ] ) { set < string > tmp = findLCS ( X , Y , m , n - 1 ) ; s . insert ( tmp . begin ( ) , tmp . end ( ) ) ; } } return s ; }
int LCS ( string X , string Y , int m , int n ) { for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; }
int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n - i ; j ++ ) for ( int k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }
int countIntegralSolutions ( int n ) { return ( ( n + 1 ) * ( n + 2 ) ) / 2 ; }
int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int table [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; }
int minTime ( int arr [ ] , int n ) { if ( n <= 0 ) return 0 ; int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int incl_new = arr [ i ] + min ( excl , incl ) ; int excl_new = incl ; incl = incl_new ; excl = excl_new ; } return min ( incl , excl ) ; }
int lcs ( string & X , string & Y ) { int m = X . length ( ) , n = Y . length ( ) ; int L [ 2 ] [ n + 1 ] ; bool bi ; for ( int i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; }
int countUtil ( int p , int q , int r ) { }
int countWays ( int p , int q , int r , int last ) { if ( p < 0 q < 0 r < 0  ) return 0 ; if ( p == 1 && q == 0 && r == 0 && last == 0 ) return 1 ; if ( p == 0 && q == 1 && r == 0 && last == 1 ) return 1 ; if ( p == 0 && q == 0 && r == 1 && last == 2 ) return 1 ; if ( dp [ p ] [ q ] [ r ] [ last ] != -1 ) return dp [ p ] [ q ] [ r ] [ last ] ; if ( last == 0 ) dp [ p ] [ q ] [ r ] [ last ] = countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ; else if ( last == 1 ) dp [ p ] [ q ] [ r ] [ last ] = countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ; dp [ p ] [ q ] [ r ] [ last ] = countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ; return dp [ p ] [ q ] [ r ] [ last ] ; }
int countUtil ( int p , int q , int r ) { memset ( dp , -1 , sizeof ( dp ) ) ; }
void multiply ( int a [ 3 ] [ 3 ] , int b [ 3 ] [ 3 ] ) { int mul [ 3 ] [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { mul [ i ] [ j ] = 0 ; for ( int k = 0 ; k < 3 ; k ++ ) mul [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; } } for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) a [ i ] [ j ] = mul [ i ] [ j ] ; }
int power ( int F [ 3 ] [ 3 ] , int n ) { int M [ 3 ] [ 3 ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; if ( n == 1 ) return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ; power ( F , n / 2 ) ; multiply ( F , F ) ; if ( n % 2 != 0 ) multiply ( F , M ) ; return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ; }
int findNthTerm ( int n ) { int F [ 3 ] [ 3 ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return 1 ; return power ( F , n - 2 ) ; }
int count ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } return dp [ n ] ; }
int KSmallestUsingMorris ( Node * root , int k ) { int count = 0 ; int ksmall = INT_MIN ; Node * curr = root ; while ( curr != NULL ) { if ( curr -> left == NULL ) { count ++ ; if ( count == k ) ksmall = curr -> key ; curr = curr -> right ; } else { Node * pre = curr -> left ; while ( pre -> right != NULL && pre -> right != curr ) pre = pre -> right ; if ( pre -> right == NULL ) { pre -> right = curr ; curr = curr -> left ; } else { pre -> right = NULL ; count ++ ; if ( count == k ) ksmall = curr -> key ; curr = curr -> right ; } } } return ksmall ; }
int subsetXOR ( int arr [ ] , int n , int k ) { int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; int m = ( 1 << ( int ) ( log2 ( max_ele ) + 1 ) ) - 1 ; if ( k > m ) return 0 ; int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = 0 ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ; return dp [ n ] [ k ] ; }
int permutationCoeff ( int n , int k ) { int fact [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; return fact [ n ] / fact [ n - k ] ; }
int findMin ( int arr [ ] , int n ) { int sumTotal = 0 ; for ( int i = 0 ; i < n ; i ++ ) sumTotal += arr [ i ] ; return findMinRec ( arr , n , 0 , sumTotal ) ; }
int countDer ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }
int countDer ( int n ) { int der [ n + 1 ] = { 0 } ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
int countDer ( int n ) { if ( n == 1 or n == 2 ) { return n - 1 ; } int a = 0 ; int b = 1 ; for ( int i = 3 ; i <= n ; ++ i ) { int cur = ( i - 1 ) * ( a + b ) ; a = b ; b = cur ; } return b ; }
int bellNumber ( int n ) { int bell [ n + 1 ] [ n + 1 ] ; bell [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] ; for ( int j = 1 ; j <= i ; j ++ ) bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ; } return bell [ n ] [ 0 ] ; }
int minSizeRec ( int arr [ ] , int low , int high , int k ) { if ( dp [ low ] [ high ] != -1 ) return dp [ low ] [ high ] ; if ( ( high - low + 1 ) < 3 ) return high - low + 1 ; int res = 1 + minSizeRec ( arr , low + 1 , high , k ) ; for ( int i = low + 1 ; i <= high - 1 ; i ++ ) { for ( int j = i + 1 ; j <= high ; j ++ ) { if ( arr [ i ] == ( arr [ low ] + k ) && arr [ j ] == ( arr [ low ] + 2 * k ) && minSizeRec ( arr , low + 1 , i - 1 , k ) == 0 && minSizeRec ( arr , i + 1 , j - 1 , k ) == 0 ) { res = min ( res , minSizeRec ( arr , j + 1 , high , k ) ) ; } } } return ( dp [ low ] [ high ] = res ) ; }
int countSol ( int coeff [ ] , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }
int countSol ( int coeff [ ] , int n , int rhs ) { int dp [ rhs + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }
int printCountRec ( int dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }
int printCountDP ( int dist ) { int count [ dist + 1 ] ; count [ 0 ] = 1 ; if ( dist >= 1 ) count [ 1 ] = 1 ; if ( dist >= 2 ) count [ 2 ] = 2 ; for ( int i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }
int countSeq ( int n ) { int nCr = 1 , res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }
int findLongestRepeatingSubSeq ( string str ) { int n = str . length ( ) ; int dp [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; }
bool isInorder ( int arr [ ] , int n ) { if ( n == 0 n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; }
int getMaxRec ( string & str , int i , int n , int lookup [ ] ) { if ( i >= n ) return 0 ; if ( lookup [ i ] != -1 ) return lookup [ i ] ; int ans = 1 + getMaxRec ( str , i + 1 , n , lookup ) ; if ( i + 1 < n ) { if ( str [ i ] != str [ i + 1 ] ) ans = max ( 4 + getMaxRec ( str , i + 2 , n , lookup ) , ans ) ; else ans = max ( 3 + getMaxRec ( str , i + 2 , n , lookup ) , ans ) ; } return lookup [ i ] = ans ; }
int getMaxWeight ( string str ) { int n = str . length ( ) ; int lookup [ n ] ; memset ( lookup , -1 , sizeof lookup ) ; return getMaxRec ( str , 0 , str . length ( ) , lookup ) ; }
unsigned long long int countRec ( int digits , int esum , int osum , bool isOdd , int n ) { if ( digits == n ) return ( esum - osum == 1 ) ; if ( lookup [ digits ] [ esum ] [ osum ] [ isOdd ] != -1 ) return lookup [ digits ] [ esum ] [ osum ] [ isOdd ] ; unsigned long long int ans = 0 ; if ( isOdd ) for ( int i = 0 ; i <= 9 ; i ++ ) ans += countRec ( digits + 1 , esum , osum + i , false , n ) ; for ( int i = 0 ; i <= 9 ; i ++ ) ans += countRec ( digits + 1 , esum + i , osum , true , n ) ; return lookup [ digits ] [ esum ] [ osum ] [ isOdd ] = ans ; }
unsigned long long int finalCount ( int n ) { int digits = 0 ; memset ( lookup , -1 , sizeof lookup ) ; unsigned long long int ans = 0 ; int esum = 0 , osum = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) ans += countRec ( digits + 1 , esum + i , osum , true , n ) ; return ans ; }
int steps ( int source , int step , int dest ) { if ( abs ( source ) > ( dest ) ) return INT_MAX ; if ( source == dest ) return step ; int pos = steps ( source + step + 1 , step + 1 , dest ) ; int neg = steps ( source - step - 1 , step + 1 , dest ) ; return min ( pos , neg ) ; }
int countNumbersWith4 ( int n ) { for ( int x = 1 ; x <= n ; x ++ ) result += has4 ( x ) ? 1 : 0 ; return result ; }
int countNumbersWith4 ( int n ) { if ( n < 4 ) return 0 ; int d = log10 ( n ) ; int * a = new int [ d + 1 ] ; a [ 0 ] = 0 , a [ 1 ] = 1 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + ceil ( pow ( 10 , i - 1 ) ) ; int p = ceil ( pow ( 10 , d ) ) ; int msd = n / p ; if ( msd == 4 ) return ( msd ) * a [ d ] + ( n % p ) + 1 ; if ( msd > 4 ) return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ; return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; }
int max ( int arr [ ] , int l , int h ) { int mx = arr [ l ] ; for ( int i = l + 1 ; i <= h ; i ++ ) if ( mx < arr [ i ] ) mx = arr [ i ] ; return mx ; }
int minRemovalsDP ( int arr [ ] , int n ) { int table [ n ] [ n ] , gap , i , j , mn , mx ; for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { mn = min ( arr , i , j ) ; mx = max ( arr , i , j ) ; table [ i ] [ j ] = ( 2 * mn > mx ) ? 0 : min ( table [ i ] [ j - 1 ] + 1 , table [ i + 1 ] [ j ] + 1 ) ; } } return table [ 0 ] [ n - 1 ] ; }
int minRemovalsDP ( int arr [ ] , int n ) { int longest_start = -1 , longest_end = 0 ; for ( int start = 0 ; start < n ; start ++ ) { int min = INT_MAX , max = INT_MIN ; for ( int end = start ; end < n ; end ++ ) { int val = arr [ end ] ; if ( val < min ) min = val ; if ( val > max ) max = val ; if ( 2 * min <= max ) break ; if ( end - start > longest_end - longest_start  longest_start == -1 ) { longest_start = start ; longest_end = end ; } } } if ( longest_start == -1 ) return n ; return ( n - ( longest_end - longest_start + 1 ) ) ; }
int numberOfPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; }
int numberOfPaths ( int m , int n ) { int count [ m ] [ n ] ; for ( int i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ )  } return count [ m - 1 ] [ n - 1 ] ; }
int numberOfPaths ( int m , int n ) { int dp [ n ] = { 1 } ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] += dp [ j - 1 ] ; } } return dp [ n - 1 ] ; }
int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; }
bool checkBSTs ( Node * root1 , Node * root2 ) { if ( ! root1 && ! root2 ) return true ; if ( ( root1 && ! root2 ) || ( ! root1 && root2 ) ) return false ; vector < int > v1 , v2 ; storeInorder ( root1 , v1 ) ; storeInorder ( root2 , v2 ) ; return ( v1 == v2 ) ; }
int lenghtOfLongestAP ( int set [ ] , int n ) { if ( n <= 2 ) return n ; int L [ n ] [ n ] ; int llap = 2 ; for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ n - 1 ] = 2 ; for ( int j = n - 2 ; j >= 1 ; j -- ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ; else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) { L [ i ] [ j ] = 2 , i -- ; } else { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; llap = max ( llap , L [ i ] [ j ] ) ; i -- ; k ++ ; } } while ( i >= 0 ) { L [ i ] [ j ] = 2 ; i -- ; } } return llap ; }
int carAssembly ( int a [ ] [ NUM_STATION ] , int t [ ] [ NUM_STATION ] , int * e , int * x ) { int T1 [ NUM_STATION ] , T2 [ NUM_STATION ] , i ; T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ; T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ; for ( i = 1 ; i < NUM_STATION ; ++ i ) { T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) ; T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ; } return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ; }
int findWays ( int m , int n , int x ) { int table [ n + 1 ] [ x + 1 ] ; for ( int j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) for ( int j = 1 ; j <= x ; j ++ ) for ( int k = 1 ; k <= m && k < j ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; return table [ n ] [ x ] ; }
long findWays ( int f , int d , int s ) { long mem [ d + 1 ] [ s + 1 ] ; memset ( mem , 0 , sizeof mem ) ; mem [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= d ; i ++ ) { for ( int j = i ; j <= s ; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ; if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ; } } return mem [ d ] [ s ] ; }
int LCSubStr ( char * X , char * Y , int m , int n ) { int LCSuff [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCSuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; result = max ( result , LCSuff [ i ] [ j ] ) ; } else LCSuff [ i ] [ j ] = 0 ; } } return result ; }
int LCSubStr ( string s , string t , int n , int m ) { int dp [ 2 ] [ m + 1 ] ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( s [ i - 1 ] == t [ j - 1 ] ) { dp [ i % 2 ] [ j ] = dp [ ( i - 1 ) % 2 ] [ j - 1 ] + 1 ; if ( dp [ i % 2 ] [ j ] > res ) res = dp [ i % 2 ] [ j ] ; } else dp [ i % 2 ] [ j ] = 0 ; } } return res ; }
int lcs ( int i , int j , int count ) { if ( i == 0 j == 0 ) return count ; if ( X [ i - 1 ] == Y [ j - 1 ] ) { count = lcs ( i - 1 , j - 1 , count + 1 ) ; } count = max ( count , max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) ; return count ; }
int findMinInsertions ( char str [ ] , int l , int h ) { if ( l > h ) return INT_MAX ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }
int maxCrossingSum ( int arr [ ] , int l , int m , int h ) { int sum = 0 ; int left_sum = INT_MIN ; for ( int i = m ; i >= l ; i -- ) { sum = sum + arr [ i ] ; if ( sum > left_sum ) left_sum = sum ; } sum = 0 ; int right_sum = INT_MIN ; for ( int i = m + 1 ; i <= h ; i ++ ) { sum = sum + arr [ i ] ; if ( sum > right_sum ) right_sum = sum ; } return max ( left_sum + right_sum , left_sum , right_sum ) ; }
int maxSubArraySum ( int arr [ ] , int l , int h ) { if ( l == h ) return arr [ l ] ; int m = ( l + h ) / 2 ; return max ( maxSubArraySum ( arr , l , m ) , maxSubArraySum ( arr , m + 1 , h ) , maxCrossingSum ( arr , l , m , h ) ) ; }
bool isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; }
int subsetSum ( int a [ ] , int n , int sum ) { if ( sum == 0 ) return 1 ; if ( n <= 0 ) return 0 ; if ( tab [ n - 1 ] [ sum ] != -1 ) return tab [ n - 1 ] [ sum ] ; if ( a [ n - 1 ] > sum ) return tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) ; else { return tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) || subsetSum ( a , n - 1 , sum - a [ n - 1 ] ) ; } }
float findWater ( int i , int j , float X ) { if ( j > i ) { printf ( "Incorrect Inputn" ) ; exit ( 0 ) ; } float glass [ i * ( i + 1 ) / 2 ] ; memset ( glass , 0 , sizeof ( glass ) ) ; int index = 0 ; glass [ index ] = X ; for ( int row = 1 ; row <= i ; ++ row ) { for ( int col = 1 ; col <= row ; ++ col , ++ index ) { X = glass [ index ] ; glass [ index ] = ( X >= 1.0f ) ? 1.0f : X ; X = ( X >= 1.0f ) ? ( X - 1 ) : 0.0f ; glass [ index + row ] += X / 2 ; glass [ index + row + 1 ] += X / 2 ; } } return glass [ i * ( i - 1 ) / 2 + j - 1 ] ; }
int maxChainLength ( Pair arr [ ] , int n ) { int i , j , max = 0 ; int * mcl = new int [ sizeof ( int ) * n ] ; for ( i = 0 ; i < n ; i ++ ) mcl [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] . a > arr [ j ] . b && mcl [ i ] < mcl [ j ] + 1 ) mcl [ i ] = mcl [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < mcl [ i ] ) max = mcl [ i ] ; return max ; }
void solveWordWrap ( int l [ ] , int n , int M ) { int extras [ n + 1 ] [ n + 1 ] ; int lc [ n + 1 ] [ n + 1 ] ; int c [ n + 1 ] ; int p [ n + 1 ] ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { extras [ i ] [ i ] = M - l [ i - 1 ] ; for ( j = i + 1 ; j <= n ; j ++ ) extras [ i ] [ j ] = extras [ i ] [ j - 1 ] - l [ j - 1 ] - 1 ; } for ( i = 1 ; i <= n ; i ++ ) { for ( j = i ; j <= n ; j ++ ) { if ( extras [ i ] [ j ] < 0 ) lc [ i ] [ j ] = INF ; else if ( j == n && extras [ i ] [ j ] >= 0 ) lc [ i ] [ j ] = 0 ; else lc [ i ] [ j ] = extras [ i ] [ j ] * extras [ i ] [ j ] ; } } c [ 0 ] = 0 ; for ( j = 1 ; j <= n ; j ++ ) { c [ j ] = INF ; for ( i = 1 ; i <= j ; i ++ ) { if ( c [ i - 1 ] != INF && lc [ i ] [ j ] != INF && ( c [ i - 1 ] + lc [ i ] [ j ] < c [ j ] ) ) { c [ j ] = c [ i - 1 ] + lc [ i ] [ j ] ; p [ j ] = i ; } } } printSolution ( p , n ) ; }
int distanceFromRoot ( struct Node * root , int x ) { if ( root -> key == x ) return 0 ; else if ( root -> key > x ) return 1 + distanceFromRoot ( root -> left , x ) ; return 1 + distanceFromRoot ( root -> right , x ) ; }
int findDistWrapper ( Node * root , int a , int b ) { if ( a > b ) swap ( a , b ) ; return distanceBetween2 ( root , a , b ) ; }
bool isSubsetSum ( int arr [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( arr [ n - 1 ] > sum ) return isSubsetSum ( arr , n - 1 , sum ) ; return isSubsetSum ( arr , n - 1 , sum ) || isSubsetSum ( arr , n - 1 , sum - arr [ n - 1 ] ) ; }
bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool part [ sum / 2 + 1 ] ; for ( i = 0 ; i <= sum / 2 ; i ++ ) { part [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = sum / 2 ; j >= arr [ i ] ; if ( part [ j - arr [ i ] ] == 1 j == arr [ i ] ) part [ j ] = 1 ; } } return part [ sum / 2 ] ; } int main ( ) { int arr [  ] =  { 1 , 3 , 3 , 2 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( findPartiion ( arr , n ) == true ) cout << "Can be divided into two subsets of equal " "sum" ; else cout << "Can not be divided into" << " two subsets of equal sum" ; return 0 ; }
int minPalPartion ( string String , int i , int j ) { if ( i >= j || isPalindrome ( String , i , j ) ) return 0 ; int ans = INT_MAX , count ; for ( int k = i ; k < j ; k ++ ) { count = minPalPartion ( String , i , k ) + minPalPartion ( String , k + 1 , j ) + 1 ; ans = min ( ans , count ) ; } return ans ; }
int minCut ( string a ) { int cut [ a . length ( ) ] ; bool palindrome [ a . length ( ) ] [ a . length ( ) ] ; memset ( palindrome , false , sizeof ( palindrome ) ) ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) { int minCut = i ; for ( int j = 0 ; j <= i ; j ++ ) { if ( a [ i ] == a [ j ] && ( i - j < 2 palindrome [ j + 1 ] [ i - 1 ]  ) ) { palindrome [ j ] [ i ] = true ; minCut = min ( minCut , j == 0 ? 0 : ( cut [ j - 1 ] + 1 ) ) ; } } cut [ i ] = minCut ; } return cut [ a . length ( ) - 1 ] ; }
int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }
int cutRod ( int price [ ] , int n ) { int val [ n + 1 ] ; val [ 0 ] = 0 ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { int max_val = INT_MIN ; for ( j = 0 ; j < i ; j ++ ) max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; }
int max ( int x , int y ) { return ( x > y ) ? x : y ; }
int binomialCoeff ( int n , int r ) { if ( r > n ) return 0 ; long long int m = 1000000007 ; long long int inv [ r + 1 ] = { 0 } ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - ( m / i ) * inv [ m % i ] % m ; } int ans = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { ans = ( ( ans % m ) * ( inv [ i ] % m ) ) % m ; } for ( int i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( ( ans % m ) * ( i % m ) ) % m ; } return ans ; }
int matrixChainMemoised ( int * p , int i , int j ) { if ( i == j ) { return 0 ; } if ( dp [ i ] [ j ] != -1 ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] = INT_MAX ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i ] [ j ] ; }
int MatrixChainOrder ( int * p , int n ) { int i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; }
int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; }
unsigned long int factorial ( unsigned int n ) { unsigned long int res = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { res *= i ; } return res ; }
unsigned long int catalan ( unsigned int n ) { unsigned long int c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; }
unsigned long int countBST ( unsigned int n ) { unsigned long int count = catalan ( n ) ; return count ; }
unsigned long int countBT ( unsigned int n ) { unsigned long int count = catalan ( n ) ; return count * factorial ( n ) ; }
int checkArray ( int arr [ ] , int N , int k ) { if ( N < 3 ) return -1 ; int i , Sum = 0 , temp = 0 ; for ( i = 0 ; i < N ; i ++ ) Sum += arr [ i ] ; int R = ( k * k + k + 1 ) ; if ( Sum % R != 0 ) return 0 ; int Mid = k * ( Sum / R ) ; for ( i = 1 ; i < N - 1 ; i ++ ) { temp += arr [ i - 1 ] ; if ( arr [ i ] == Mid ) { if ( temp == Mid / k ) return i + 1 ; else return 0 ; } } return 0 ; }
void encodeString ( string str ) { string res = "" ; int small [ 26 ] = { 0 } , capital [ 26 ] = { 0 } , num [ 10 ] = { 0 } ; int n = str . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] >= '0' && str [ i ] <= '9' ) { num [ str [ i ] - 48 ] = i ; } else if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) { small [ str [ i ] - 97 ] = i ; } else if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { capital [ str [ i ] - 65 ] = i ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ( str [ i ] >= 'a' && str [ i ] <= 'z' ) && small [ str [ i ] - 97 ] == i ) { int occ = str [ i ] - 96 ; while ( occ -- ) { res += str [ i ] ; } } else if ( ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) && capital [ str [ i ] - 65 ] == i ) { int occ = str [ i ] - 64 ; while ( occ -- ) { res += str [ i ] ; } } else if ( ( str [ i ] >= '0' && str [ i ] <= '9' ) && num [ str [ i ] - 48 ] == i ) { int occ = str [ i ] - 48 ; while ( occ -- ) { res += str [ i ] ; } } else { res += str [ i ] ; } } cout << res ; }
void possibleEqualArray ( int A [ ] , int N ) { vector < int > pref ( N ) ; pref [ 0 ] = A [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { pref [ i ] = pref [ i - 1 ] ^ A [ i ] ; } if ( pref [ N - 1 ] == 0 ) { cout << "YES" ; return ; } int cur_xor = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { cur_xor ^= A [ i ] ; for ( int j = 0 ; j < i ; j ++ ) { if ( j ) { int middle_xor = pref [ j - 1 ] ^ pref [ i - 1 ] ; int left_xor = pref [ j - 1 ] ; int right_xor = cur_xor ; if ( left_xor == middle_xor && middle_xor == right_xor ) { cout << "YES" ; return ; } } } } cout << "NO" ; }
void RangeTraversal ( node * root , int n1 , int n2 ) { if ( ! root ) return ; node * curr = root ; while ( curr ) { if ( curr -> left == NULL ) { if ( curr -> data <= n2 && curr -> data >= n1 ) { cout << curr -> data << " " ; } curr = curr -> right ; } else { node * pre = curr -> left ; while ( pre -> right != NULL && pre -> right != curr ) pre = pre -> right ; if ( pre -> right == NULL ) { pre -> right = curr ; curr = curr -> left ; } else { pre -> right = NULL ; if ( curr -> data <= n2 && curr -> data >= n1 ) { cout << curr -> data << " " ; } curr = curr -> right ; } } } }
void possibleEqualArray ( int A [ ] , int N ) { int tot_XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { tot_XOR ^= A [ i ] ; } if ( tot_XOR == 0 ) { cout << "YES" ; return ; } int cur_XOR = 0 ; int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { cur_XOR ^= A [ i ] ; if ( cur_XOR == tot_XOR ) { cnt ++ ; cur_XOR = 0 ; } } if ( cnt > 2 ) { cout << "YES" ; } else { cout << "NO" ; } }
void GenerateArray ( int N , int X ) { int prev_xor = X ; for ( int i = 1 ; i <= N ; i ++ ) { cout << ( i ^ prev_xor ) ; if ( i != N ) { cout << " " ; } prev_xor = i ; } }
void createGrid ( char grid [ ] [ 1001 ] , bool is1 , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( is1 ) { grid [ i ] [ j ] = '0' ; is1 = false ; } else { grid [ i ] [ j ] = '1' ; is1 = true ; } } if ( M % 2 == 0 ) is1 = ! is1 ; } }
bool testGrid ( char testGrid [ ] [ 1001 ] , char Grid [ ] [ 1001 ] , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( Grid [ i ] [ j ] != '*' ) { if ( Grid [ i ] [ j ] != testGrid [ i ] [ j ] ) { return false ; } } } } return true ; }
void findPossibleGrid ( int N , int M , char grid [ ] [ 1001 ] ) { char gridTest1 [ N ] [ 1001 ] , gridTest2 [ N ] [ 1001 ] ; createGrid ( gridTest1 , true , N , M ) ; createGrid ( gridTest2 , false , N , M ) ; if ( testGrid ( gridTest1 , grid , N , M ) ) { cout << "Yes\n" ; printGrid ( gridTest1 , N , M ) ; } else if ( testGrid ( gridTest2 , grid , N , M ) ) { cout << "Yes\n" ; printGrid ( gridTest2 , N , M ) ; } else { cout << "No\n" ; } }
void brute ( int ind , long long l , long long r ) { if ( ind == n / 2 ) { for ( int i = 0 ; i < int ( n ) ; i ++ ) printf ( "%lld " , brr [ i ] ) ; puts ( "" ) ; exit ( 0 ) ; } for ( long long i = l ; i <= arr [ ind ] / 2 ; ++ i ) if ( arr [ ind ] - i <= r ) { brr [ ind ] = i ; brr [ n - ind - 1 ] = arr [ ind ] - i ; brute ( ind + 1 , i , arr [ ind ] - i ) ; } }
int minCount ( int N , int K ) { int SmallestNumber [ 10 ] ; int MinimumSteps [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) { SmallestNumber [ i ] = INT_MAX ; MinimumSteps [ i ] = INT_MAX ; } for ( int i = 1 ; i <= 10 ; i ++ ) { int num = K * i ; SmallestNumber [ num % 10 ] = min ( SmallestNumber [ num % 10 ] , num ) ; MinimumSteps [ num % 10 ] = min ( MinimumSteps [ num % 10 ] , i ) ; } if ( N < SmallestNumber [ N % 10 ] ) { return -1 ; } else { return MinimumSteps [ N % 10 ] ; } }
bool inRange ( node * root , int low , int high ) { return root -> data >= low && root -> data <= high ; }
int countMinSteps ( int arr [ ] , int N ) { int val = 0 ; int mx = INT_MIN ; for ( int i = 0 ; i < N ; i ++ ) { int curr = arr [ i ] ; mx = max ( mx , curr ) ; val = max ( val , mx - curr ) ; } long long res = 0 ; while ( ( 1LL << res ) - 1 < val ) { ++ res ; } return res ; }
int func2 ( int L , int R , int K ) { if ( R - L >= 2 ) return 1 ; return min ( L , L ^ R ) ; }
int func3 ( int L , int R , int K ) { if ( ( R ^ L ) > L && ( R ^ L ) < R ) return 0 ; return func2 ( L , R , K ) ; }
int func4 ( int L , int R , int K ) { if ( R - L >= 4 ) return 0 ; int minval = L ^ ( L + 1 ) ^ ( L + 2 ) ^ ( L + 3 ) ; return min ( minval , func3 ( L , R , K ) ) ; }
int minimumXor ( int L , int R , int K ) { if ( K > 4 ) return 0 ; else if ( K == 4 ) return func4 ( L , R , K ) ; else if ( K == 3 ) return func3 ( L , R , K ) ; else if ( K == 2 ) return func2 ( L , R , K ) ; else return L ; }
int setBits ( long n ) { int count = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; count ++ ; } return count ; }
void findNthTerm ( int N ) { int x = setBits ( N ^ ( N - 1 ) ) ; cout << x ; }
void findEquation ( int A , int B , int C ) { cout << "(" << C << ")" << "x^2 +(" << B << ")x + (" << A << ") = 0" ; }
int findMinMoves ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % N != 0 ) return -1 ; int avg = sum / N ; int total = 0 ; int needCount = 0 ; for ( int i = 0 ; i < N ; i ++ ) { needCount += ( arr [ i ] - avg ) ; total = max ( max ( abs ( needCount ) , arr [ i ] - avg ) , total ) ; } return total ; }
string checkPro ( int n , int k ) { double exp = 1.0 / k ; int KthRoot = ( int ) pow ( n , exp ) ; int product = 1 ; for ( int i = 1 ; i < k + 1 ; i ++ ) { product = product * i ; } if ( product == n ) return "Yes" ; else { for ( int j = 2 ; j < KthRoot + 1 ; j ++ ) { product = product * ( j + k - 1 ) ; product = product / ( j - 1 ) ; if ( product == n ) return "Yes" ; } } return "No" ; }
int totalCombination ( int L , int R ) { int count = 0 ; int K = R - L ; if ( K < L ) return 0 ; int ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ; return count ; }
void inorder ( struct Node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; cout << root -> data << " " ; inorder ( root -> right ) ; } }
void getZarr ( string str , int Z [ ] ) { int n = str . length ( ) ; int k ; int L = 0 ; int R = 0 ; for ( int i = 1 ; i < n ; ++ i ) { if ( i > R ) { L = R = i ; while ( R < n && str [ R - L ] == str [ R ] ) { R ++ ; } Z [ i ] = R - L ; R -- ; } else { k = i - L ; if ( Z [ k ] < R - i + 1 ) { Z [ i ] = Z [ k ] ; } else { L = i ; while ( R < n && str [ R - L ] == str [ R ] ) { R ++ ; } Z [ i ] = R - L ; R -- ; } } } }
string goodStr ( string str , string word ) { string concat = word + "$" + str ; int l = concat . length ( ) ; int Z [ l ] ; getZarr ( concat , Z ) ; string res ; int pSize = word . size ( ) ; for ( int i = 0 ; i < l ; ++ i ) { if ( i + pSize < l - 1 && Z [ i + pSize + 1 ] == pSize ) { i += pSize - 1 ; } else if ( i < str . length ( ) ) { res += str [ i ] ; } } return res ; }
int findCount0th ( vector < int > & arr , int N , int K ) { int oddsum = 0 , evensum = 0 ; for ( int i = 1 ; i < N ; i += 2 ) { oddsum += arr [ i ] ; } for ( int i = 2 ; i < N ; i += 2 ) { evensum += arr [ i ] ; } if ( abs ( oddsum - evensum ) == K ) return 1 ; else return 0 ; }
int findCount1st ( vector < int > & arr , int N , int K ) { int evensum = arr [ 0 ] , oddsum = 0 ; for ( int i = 3 ; i < N ; i += 2 ) { evensum += arr [ i ] ; } for ( int i = 2 ; i < N ; i += 2 ) { oddsum += arr [ i ] ; } if ( abs ( oddsum - evensum ) == K ) return 1 ; else return 0 ; }
void printDiagonalTraversal ( vector < vector < int > > & nums ) { int max_size = nums . size ( ) ; for ( int i = 0 ; i < nums . size ( ) ; i ++ ) { if ( max_size < nums [ i ] . size ( ) ) { max_size = nums [ i ] . size ( ) ; } } vector < vector < int > > v ( 2 * max_size - 1 ) ; for ( int i = 0 ; i < nums . size ( ) ; i ++ ) { for ( int j = 0 ; j < nums [ i ] . size ( ) ; j ++ ) { v [ i + j ] . push_back ( nums [ i ] [ j ] ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { reverse ( v [ i ] . begin ( ) , v [ i ] . end ( ) ) ; for ( int j = 0 ; j < v [ i ] . size ( ) ; j ++ ) cout << v [ i ] [ j ] << " " ; } }
void printDiagonalTraversal ( vector < vector < int > > & nums ) { int m = nums . size ( ) ; queue < pair < int , int > > q ; q . push ( { 0 , 0 } ) ; while ( ! q . empty ( ) ) { pair < int , int > p = q . front ( ) ; q . pop ( ) ; cout << nums [ p . first ] [ p . second ] << " " ; if ( p . second == 0 && p . first + 1 < m ) { q . push ( { p . first + 1 , p . second } ) ; } if ( p . second + 1 < nums [ p . first ] . size ( ) ) q . push ( { p . first , p . second + 1 } ) ; } }
void flipBitsOfAandB ( int A , int B ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( A & ( 1 << i ) ) && ( B & ( 1 << i ) ) ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } cout << A << " " << B ; }
void flipBitsOfAandB ( int A , int B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; cout << A << " " << B ; }
void isValid ( string s ) { int n = sqrt ( s . length ( ) ) ; char check = s [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = i , y = i ; while ( x >= 0 && y < n ) { if ( s [ ( n * x ) + y ] != check || s [ ( n * y ) + x ] != check ) { cout << "No" << endl ; return ; } x -- ; y ++ ; } } cout << "Yes" << endl ; }
int minimumOperations ( string orig_str , int m , int n ) { string orig = orig_str ; int turn = 1 ; int j = 1 ; for ( auto i : orig_str ) { string m_cut = orig_str . substr ( orig_str . length ( ) - m ) ; orig_str . erase ( orig_str . length ( ) - m ) ; orig_str = m_cut + orig_str ; j = j + 1 ; if ( orig != orig_str ) { turn = turn + 1 ; string n_cut = orig_str . substr ( orig_str . length ( ) - n ) ; orig_str . erase ( orig_str . length ( ) - n ) ; orig_str = n_cut + orig_str ; j = j + 1 ; } if ( orig == orig_str ) { break ; } turn = turn + 1 ; } cout << turn ; }
int gcd ( int a , int b ) { if ( a < b ) { int t = a ; a = b ; b = t ; } if ( a % b == 0 ) return b ; return gcd ( b , a % b ) ; }
void printAnswer ( int x , int y ) { int val = gcd ( x , y ) ; if ( ( val & ( val - 1 ) ) == 0 ) cout << "Yes" ; else cout << "No" ; }
int toDigit ( char ch ) { return ( ch - '0' ) ; }
void powerOf10 ( ) { power [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) power [ i ] = power [ i - 1 ] * 10 ; }
void precomputePrefix ( string str , int n ) { pref [ 0 ] = str [ 0 ] - '0' ; for ( int i = 1 ; i < n ; i ++ ) pref [ i ] = pref [ i - 1 ] + toDigit ( str [ i ] ) ; }
int triangularNumber ( int i ) { int res = i * ( i + 1 ) / 2 ; return res ; }
void sumOfSubarrayProd ( int arr [ ] , int n ) { int ans = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int incr = arr [ i ] * ( 1 + res ) ; ans += incr ; res = incr ; } cout << ( ans ) ; }
int OddLengthSum ( vector < int > & arr ) { int sum = 0 ; int l = arr . size ( ) ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = i ; j < l ; j += 2 ) { for ( int k = i ; k <= j ; k ++ ) { sum += arr [ k ] ; } } } return sum ; }
int phi ( int n ) { int result = 1 ; for ( int p = 2 ; p < n ; p ++ ) { if ( __gcd ( p , n ) == 1 ) { result ++ ; } } return result ; }
bool sameEulerTotient ( int n ) { return phi ( n ) == phi ( 2 * n ) ; }
bool sameEulerTotient ( int N ) { return ( N & 1 ) ; }
vector < int > restore ( int arr [ ] , int N ) { vector < int > result ; map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp [ arr [ i ] ] == 0 ) { result . push_back ( arr [ i ] ) ; mp [ arr [ i ] ] ++ ; } } return result ; }
void print_result ( vector < int > result ) { for ( int i = 0 ; i < result . size ( ) ; i ++ ) cout << result [ i ] << " " ; }
vector < int > restore ( int arr [ ] , int N ) { vector < int > result ; int count1 = 1 ; set < int > s ; for ( int i = 0 ; i < N ; i ++ ) { s . insert ( arr [ i ] ) ; if ( s . size ( ) == count1 ) { result . push_back ( arr [ i ] ) ; count1 ++ ; } } return result ; }
void print_result ( vector < int > result ) { for ( int i = 0 ; i < result . size ( ) ; i ++ ) cout << result [ i ] << " " ; }
bool checkReverseBitonic ( int arr [ ] , int n ) { int i , j , f = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) continue ; if ( arr [ i ] == arr [ i - 1 ] ) return false ; else { f = 1 ; break ; } } if ( i == n ) return true ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j - 1 ] ) continue ; if ( arr [ i ] == arr [ i - 1 ] ) return false ; else { if ( f == 1 ) return false ; } } return true ; }
int sum ( int n ) { return n * ( n - 1 ) / 2 ; }
int getFirstSetBitPos ( int n ) { return log2 ( n & - n ) + 1 ; }
int oddFirst ( int a , int b ) { int steps_a = getFirstSetBitPos ( a ) ; int steps_b = getFirstSetBitPos ( b ) ; if ( steps_a == steps_b ) { return -1 ; } if ( steps_a > steps_b ) { return b ; } if ( steps_a < steps_b ) { return a ; } }
int nCycle ( int N ) { return ( N ) * ( N - 1 ) + 1 ; }
int checkReverseBitonic ( string s ) { int i , j ; for ( i = 1 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] < s [ i - 1 ] ) continue ; if ( s [ i ] >= s [ i - 1 ] ) break ; } if ( i == s . size ( ) - 1 ) return 1 ; for ( j = i + 1 ; j < s . size ( ) ; j ++ ) { if ( s [ j ] > s [ j - 1 ] ) continue ; if ( s [ j ] <= s [ j - 1 ] ) break ; } i = j ; if ( i != s . size ( ) ) return 0 ; return 1 ; }
void solve ( long long n ) { long long s = 0 ; for ( int l = 1 ; l <= n ; ) { int r = n / floor ( n / l ) ; int x = ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ; int y = ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ; int p = ( ( n / l ) % m ) ; s = ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ; s %= m ; l = r + 1 ; } cout << ( s + m ) % m ; }
long long solve ( long long n ) { long long i , sum = 0 ; while ( n > 0 ) { i = log2 ( n ) ; n = n - pow ( 2 , i ) ; sum = sum + ( i + 1 ) + Count ( i - 1 ) ; } return sum ; }
int smallestNum ( int N ) { float x = pow ( 10.0 , ( N - 1 ) / 2.0 ) ; return ceil ( x ) ; }
int checkBitonic ( string s ) { int i , j ; for ( i = 1 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] > s [ i - 1 ] ) continue ; if ( s [ i ] <= s [ i - 1 ] ) break ; } if ( i == s . size ( ) - 1 ) return 1 ; for ( j = i + 1 ; j < s . size ( ) ; j ++ ) { if ( s [ j ] < s [ j - 1 ] ) continue ; if ( s [ j ] >= s [ j - 1 ] ) break ; } i = j ; if ( i != s . size ( ) ) return 0 ; return 1 ; }
void findArray ( int * a , int n , int P ) { int mi = * min_element ( a , a + n ) ; int ctr = 0 ; mi = max ( 0 , mi - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] -= mi ; ctr += mi ; } int i = P - 1 ; int start = -1 ; while ( 1 ) { if ( a [ i ] == 0 ) { start = i ; break ; } a [ i ] -= 1 ; ctr += 1 ; i = ( i - 1 + n ) % n ; } a [ start ] = ctr ; for ( int i = 0 ; i < n ; i ++ ) { cout << a [ i ] << ", " ; } }
void checkstateA ( string n ) { if ( n [ 0 ] == '0' ) stateB ( n . substr ( 1 ) ) ; else stateD ( n . substr ( 1 ) ) ; }
void stateB ( string n ) { if ( n . length ( ) == 0 ) cout << "string not accepted" ; else { if ( n [ 0 ] == '1' ) stateC ( n . substr ( 1 ) ) ; else stateD ( n . substr ( 1 ) ) ; } }
void stateD ( string n ) { if ( n . length ( ) == 0 ) cout << "string not accepted" ; else { if ( n [ 0 ] == '1' ) stateD ( n . substr ( 1 ) ) ; else stateE ( n . substr ( 1 ) ) ; } }
void stateE ( string n ) { if ( n . length ( ) == 0 ) cout << "string not accepted" ; else { if ( n [ 0 ] == '0' ) stateE ( n . substr ( 1 ) ) ; else stateF ( n . substr ( 1 ) ) ; } }
void stateF ( string n ) { if ( n . length ( ) == 0 ) cout << "string accepred" ; else { if ( n [ 0 ] == '1' ) stateD ( n . substr ( 1 ) ) ; else stateE ( n . substr ( 1 ) ) ; } }
int HogbenNumber ( int a ) { int p = ( pow ( a , 2 ) - a + 1 ) ; return p ; }
int countKCountdown ( int arr [ ] , int N , int K ) { int flag = -1 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) flag = K ; if ( arr [ i ] == flag ) flag -- ; else flag = -1 ; if ( flag == 0 ) count ++ ; } return count ; }
int findDistinctSums ( int N ) { return ( 2 * N - 1 ) ; }
pair < int , int > count_ht ( char s , int N ) { pair < int , int > p ; if ( s == 'H' ) { p . first = floor ( N / 2.0 ) ; p . second = ceil ( N / 2.0 ) ; } else if ( s == 'T' ) { p . first = ceil ( N / 2.0 ) ; p . second = floor ( N / 2.0 ) ; } return p ; }
int getProduct ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; }
int productinRange ( int l , int r ) { if ( r - l > 9 ) return 0 ; else { int p = 1 ; for ( int i = l ; i <= r ; i ++ ) p *= getProduct ( i ) ; return p ; } }
int checkQwertyRow ( char x ) { set < char > first_row = { '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '0' , '-' , '=' } ; set < char > second_row = { 'Q' , 'W' , 'E' , 'R' , 'T' , 'Y' , 'U' , 'I' , 'O' , 'P' , '[' , ']' , 'q' , 'w' , 'e' , 'r' , 't' , 'y' , 'u' , 'i' , 'o' , 'p' } ; set < char > third_row = { 'A' , 'S' , 'D' , 'F' , 'G' , 'H' , 'J' , 'K' , 'L' , ';' , ':' , 'a' , 's' , 'd' , 'f' , 'g' , 'h' , 'j' , 'k' , 'l' } ; set < char > fourth_row = { 'Z' , 'X' , 'C' , 'V' , 'B' , 'N' , 'M' , ',' , '.' , '/' , 'z' , 'x' , 'c' , 'v' , 'b' , 'n' , 'm' } ; if ( first_row . count ( x ) > 0 ) { return 1 ; } else if ( second_row . count ( x ) > 0 ) { return 2 ; } else if ( third_row . count ( x ) > 0 ) { return 3 ; } else if ( fourth_row . count ( x ) > 0 ) { return 4 ; } return 0 ; }
bool checkValidity ( string str ) { char x = str [ 0 ] ; int row = checkQwertyRow ( x ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { x = str [ i ] ; if ( row != checkQwertyRow ( x ) ) { return false ; } } return true ; }
long long fib ( long long n ) { long long f0 = 0 ; long long f1 = 1 ; if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; else { long long rem = n % 60 ; if ( rem == 0 ) return 0 ; for ( long long i = 2 ; i < rem + 3 ; i ++ ) { long long f = ( f0 + f1 ) % 60 ; f0 = f1 ; f1 = f ; } long long s = f1 - 1 ; return s ; } }
void sumBetweenZero ( int arr [ ] , int N ) { int i = 0 ; vector < int > A ; int sum = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { i ++ ; break ; } } for ( ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { A . push_back ( sum ) ; sum = 0 ; } else { sum += arr [ i ] ; } } for ( int i = 0 ; i < A . size ( ) ; i ++ ) { cout << A [ i ] << ' ' ; } if ( A . size ( ) == 0 ) cout << "-1" ; }
int nthTerm ( int N ) { if ( N == 1 ) { return 2 ; } return ( ( N - 1 ) * 13 ) + nthTerm ( N - 1 ) ; }
int maximumSubsequence ( int arr [ ] , int N ) { unordered_map < int , int > M ; for ( int i = 0 ; i < N ; i ++ ) { M [ arr [ i ] ] ++ ; } int distinct_size = M . size ( ) ; int maxFreq = 1 ; for ( auto & it : M ) { maxFreq = max ( maxFreq , it . second ) ; } cout << max ( min ( distinct_size , maxFreq - 1 ) , min ( distinct_size - 1 , maxFreq ) ) ; }
string decToHexa ( int n ) { char hexaDeciNum [ 2 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = temp + 48 ; i ++ ; } else { hexaDeciNum [ i ] = temp + 55 ; i ++ ; } n = n / 16 ; } string hexCode = "" ; if ( i == 2 ) { hexCode . push_back ( hexaDeciNum [ 0 ] ) ; hexCode . push_back ( hexaDeciNum [ 1 ] ) ; } else if ( i == 1 ) { hexCode = "0" ; hexCode . push_back ( hexaDeciNum [ 0 ] ) ; } else if ( i == 0 ) hexCode = "00" ; return hexCode ; }
string convertRGBtoHex ( int R , int G , int B ) { if ( ( R >= 0 && R <= 255 ) && ( G >= 0 && G <= 255 ) && ( B >= 0 && B <= 255 ) ) { string hexCode = "#" ; hexCode += decToHexa ( R ) ; hexCode += decToHexa ( G ) ; hexCode += decToHexa ( B ) ; return hexCode ; } else return "-1" ; }
bool isKAlternating ( string s , int k ) { if ( s . length ( ) < k ) return false ; int checker = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int bitAtIndex = s [ i ] - 'a' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } for ( int i = k ; i < s . length ( ) ; i ++ ) if ( s [ i - k ] != s [ i ] ) return false ; return true ; }
void findFactors ( int N ) { int temp = sqrt ( N ) ; int factor [ MAX ] = { 1 } ; int i , j , k ; int len1 = 1 ; while ( temp % 2 == 0 ) { factor [ len1 ++ ] = 2 ; factor [ len1 ++ ] = 2 ; temp /= 2 ; } for ( j = 3 ; j < sqrt ( temp ) ; j += 2 ) { while ( temp % j == 0 ) { factor [ len1 ++ ] = j ; factor [ len1 ++ ] = j ; temp /= j ; } } if ( temp > 2 ) { factor [ len1 ++ ] = temp ; factor [ len1 ++ ] = temp ; } int M [ len1 ] [ MAX ] = { 0 } ; int tpc = 0 , tpr = 0 ; M [ 0 ] [ 0 ] = 1 ; j = 1 ; while ( j < len1 ) { if ( factor [ j ] != factor [ j - 1 ] ) { tpr ++ ; M [ tpr ] [ 0 ] = factor [ j ] ; j ++ ; tpc = 1 ; } else { M [ tpr ] [ tpc ] = M [ tpr ] [ tpc - 1 ] * factor [ j ] ; j ++ ; tpc ++ ; } } int arr1 [ MAX ] , arr2 [ MAX ] ; int l1 , l2 ; l1 = l2 = 1 ; arr1 [ 0 ] = arr2 [ 0 ] = 1 ; for ( i = 1 ; i < tpr + 1 ; i ++ ) { for ( j = 0 ; M [ i ] [ j ] != 0 ; j ++ ) { for ( k = 0 ; k < l1 ; k ++ ) { arr2 [ l2 ++ ] = arr1 [ k ] * M [ i ] [ j ] ; } } for ( j = l1 ; j < l2 ; j ++ ) { arr1 [ j ] = arr2 [ j ] ; } l1 = l2 ; } for ( i = 0 ; i < l2 ; i ++ ) { cout << arr2 [ i ] << ' ' ; } }
int countSubstring ( string & S , int & n ) { int ans = 0 ; int i = 0 ; while ( i < n ) { int cnt0 = 0 , cnt1 = 0 ; if ( S [ i ] == '0' ) { while ( i < n && S [ i ] == '0' ) { cnt0 ++ ; i ++ ; } int j = i ; while ( j < n && S [ j ] == '1' ) { cnt1 ++ ; j ++ ; } } else { while ( i < n && S [ i ] == '1' ) { cnt1 ++ ; i ++ ; } int j = i ; while ( j < n && S [ j ] == '0' ) { cnt0 ++ ; j ++ ; } } ans += min ( cnt0 , cnt1 ) ; } return ans ; }
void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) { cout << ( 3 * i * ( i - 1 ) + 1 ) << " " ; i ++ ; } }
vector < int > zArray ( vector < int > arr ) { int n = arr . size ( ) ; vector < int > z ( n ) ; int r = 0 , l = 0 ; for ( int k = 1 ; k < n ; k ++ ) { if ( k > r ) { r = l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } else { int k1 = k - l ; if ( z [ k1 ] < r - k + 1 ) z [ k ] = z [ k1 ] ; else { l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } } } return z ; }
vector < int > mergeArray ( vector < int > A , vector < int > B ) { int n = A . size ( ) ; int m = B . size ( ) ; vector < int > z ; vector < int > c ( n + m + 1 ) ; for ( int i = 0 ; i < m ; i ++ ) c [ i ] = B [ i ] ; c [ m ] = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) c [ m + i + 1 ] = A [ i ] ; z = zArray ( c ) ; return z ; }
void findZArray ( vector < int > A , vector < int > B , int n ) { int flag = 0 ; vector < int > z ; z = mergeArray ( A , B ) ; for ( int i = 0 ; i < z . size ( ) ; i ++ ) { if ( z [ i ] == n ) { cout << ( i - n - 1 ) << " " ; flag = 1 ; } } if ( flag == 0 ) { cout << ( "Not Found" ) ; } }
void insertNode ( struct Node * root , int x ) { Node * p = root , * q = NULL ; while ( p != NULL ) { q = p ; if ( p -> data < x ) p = p -> right ; else p = p -> left ; } if ( q == NULL ) p = createNode ( x ) ; else { if ( q -> data < x ) q -> right = createNode ( x ) ; else q -> left = createNode ( x ) ; } }
int maxelpath ( Node * q , int x ) { Node * p = q ; int mx = INT_MIN ; while ( p -> data != x ) { if ( p -> data > x ) { mx = max ( mx , p -> data ) ; p = p -> left ; } else { mx = max ( mx , p -> data ) ; p = p -> right ; } } return max ( mx , x ) ; }
int maximumElement ( struct Node * root , int x , int y ) { Node * p = root ; while ( ( x < p -> data && y < p -> data ) || ( x > p -> data && y > p -> data ) ) { if ( x < p -> data && y < p -> data ) p = p -> left ; else if ( x > p -> data && y > p -> data ) p = p -> right ; } return max ( maxelpath ( p , x ) , maxelpath ( p , y ) ) ; }
void q1 ( string s , int i ) { if ( i == s . length ( ) ) { cout << "Yes \n" ; return ; } if ( s [ i ] == 'a' ) q1 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; }
void q2 ( string s , int i ) { if ( i == s . length ( ) ) { cout << "No \n" ; return ; } if ( s [ i ] == 'a' ) q1 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; }
void q4 ( string s , int i ) { if ( i == s . length ( ) ) { cout << "No \n" ; return ; } if ( s [ i ] == 'a' ) q4 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; }
void q0 ( string s , int i ) { if ( i == s . length ( ) ) { cout << "No \n" ; return ; } if ( s [ i ] == 'a' ) q1 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; }
int nthTerm ( int N ) { int nth = 0 , first_term = 4 ; int pi = 1 , po = 1 ; int n = N ; while ( n > 1 ) { pi *= n - 1 ; n -- ; po *= 2 ; } nth = ( first_term * pi ) / po ; return nth ; }
void q1 ( string s , int i ) { cout << "q1->" ; if ( i == s . length ( ) ) { cout << "NO \n" ; return ; } if ( s [ i ] == '0' ) q1 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; }
void q2 ( string s , int i ) { cout << "q2->" ; if ( i == s . length ( ) ) { cout << "NO \n" ; return ; } if ( s [ i ] == '0' ) q4 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; }
void q3 ( string s , int i ) { cout << "q3->" ; if ( i == s . length ( ) ) { cout << "YES \n" ; return ; } if ( s [ i ] == '0' ) q4 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; }
void q4 ( string s , int i ) { cout << "q4->" ; if ( i == s . length ( ) ) { cout << "YES \n" ; return ; } if ( s [ i ] == '0' ) q1 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; }
void q0 ( string s , int i ) { cout << "q0->" ; if ( i == s . length ( ) ) { cout << "NO \n" ; return ; } if ( s [ i ] == '0' ) q1 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; }
int findSum ( int * arr , int n , int k ) { if ( k <= n - 2 ) return ( arr [ n - 1 ] - arr [ 0 ] ) ; return 0 ; }
int finalNum ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { result = __gcd ( result , arr [ i ] ) ; } return result ; }
int maxSubStr ( string str , int n ) { int count0 = 0 , count1 = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) { count0 ++ ; } else { count1 ++ ; } if ( count0 == count1 ) { cnt ++ ; } } if ( cnt == 0 ) { return -1 ; } return cnt ; }
bool isSatisfied ( string str , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( ! isVowel ( str [ i ] ) && ! isVowel ( str [ i - 1 ] ) ) { return false ; } } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( isVowel ( str [ i ] ) && ! isVowel ( str [ i - 1 ] ) && ! isVowel ( str [ i + 1 ] ) ) { return false ; } } return true ; }
lli squareDigitSum ( string s ) { lli lengthN = s . length ( ) ; lli result = ( lengthN / 9 ) * 81 + pow ( ( lengthN % 9 ) , 2 ) ; return result ; }
int getElement ( int N , int r , int c ) { if ( r > c ) return 0 ; if ( r == 1 ) { return c ; } int a = ( r + 1 ) * pow ( 2 , r - 2 ) ; int d = pow ( 2 , r - 1 ) ; c = c - r ; int element = a + d * c ; return element ; }
void computeLPSArray ( char * pat , int M , int * lps ) { int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < M ) { if ( pat [ i ] == pat [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } }
int CntSubstr ( string s , int l ) { int hash = 0 ; for ( int i = 0 ; i < l ; i ++ ) { hash = ( hash * x + ( s [ i ] - 97 ) ) % mod ; } int pow_l = 1 ; for ( int i = 0 ; i < l - 1 ; i ++ ) pow_l = ( pow_l * x ) % mod ; unordered_set < int > result ; result . insert ( hash ) ; for ( int i = l ; i < s . size ( ) ; i ++ ) { hash = ( ( hash - pow_l * ( s [ i - l ] - 97 ) + 2 * mod ) * x + ( s [ i ] - 97 ) ) % mod ; result . insert ( hash ) ; } cout << result . size ( ) << endl ; }
int LengthlongestPrefixSuffix ( string s ) { int n = s . length ( ) ; int lps [ n ] ; lps [ 0 ] = 0 ; int len = 0 ; int i = 1 ; while ( i < n ) { if ( s [ i ] == s [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } int res = lps [ n - 1 ] ; return ( res > n / 2 ) ? n / 2 : res ; }
int no_of_characters ( int M ) { int k = 1 ; while ( true ) { if ( pow ( 2 , k + 1 ) - 2 < M ) k ++ ; else break ; } return k ; }
string updateString ( string S , string A , string B ) { int l = A . length ( ) ; for ( int i = 0 ; i + l <= S . length ( ) ; i ++ ) { string curr = S . substr ( i , i + l ) ; if ( curr == A ) { string new_string = "" ; new_string += S . substr ( 0 , i ) + B + S . substr ( i + l , S . length ( ) ) ; S = new_string ; i += l - 1 ; } else { string new_string = "" ; new_string += S . substr ( 0 , i ) + A + S . substr ( i + l , S . length ( ) ) ; S = new_string ; i += l - 1 ; } } return S ; }
int findCount ( string str1 , string str2 ) { int len = str1 . size ( ) ; int len2 = str2 . size ( ) ; int ans = INT_MAX ; int hash1 [ 26 ] = { 0 } , hash2 [ 26 ] = { 0 } ; for ( int i = 0 ; i < len ; i ++ ) hash1 [ str1 [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < len2 ; i ++ ) hash2 [ str2 [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( hash2 [ i ] ) ans = min ( ans , hash1 [ i ] / hash2 [ i ] ) ; return ans ; }
int getEndingIndex ( string str , int n , int i ) { i ++ ; while ( i < n ) { char curr = str [ i ] ; char prev = str [ i - 1 ] ; if ( ( curr == 'a' && prev == 'z' ) || ( curr - prev == 1 ) ) i ++ ; else break ; } return i - 1 ; }
void printPattern ( int n , int m ) { if ( m > 2 * ( n + 1 ) m < n - 1 ) { cout << "-1" ; } else if ( abs ( n - m ) <= 1 ) { while ( n > 0 && m > 0 ) { cout << "01" ; n -- ; m -- ; } if ( n != 0 ) { cout << "0" ; } if ( m != 0 ) { cout << "1" ; } } else { while ( m - n > 1 && n > 0 ) { cout << "110" ; m = m - 2 ; n = n - 1 ; } while ( n > 0 ) { cout << "10" ; n -- ; m -- ; } while ( m > 0 ) { cout << "1" ; m -- ; } } }
void printPermutation ( int N , int K ) { vector < int > res ; int l = 1 , r = N , flag = 0 ; for ( int i = 0 ; i < K ; i ++ ) { if ( ! flag ) { res . push_back ( l ) ; l ++ ; } else { res . push_back ( r ) ; r -- ; } flag ^= 1 ; } if ( ! flag ) { for ( int i = r ; i >= l ; i -- ) res . push_back ( i ) ; } else { for ( int i = l ; i <= r ; i ++ ) res . push_back ( i ) ; } for ( auto i : res ) cout << i << " " ; }
bool hasDigit ( map < int , int > * hashMap , int digit ) { if ( ( * hashMap ) [ digit ] ) { ( * hashMap ) [ digit ] -- ; return true ; } return false ; }
void compute_z ( string s , int z [ ] ) { int l = 0 , r = 0 ; int n = s . length ( ) ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { if ( i > r ) { l = i , r = i ; while ( r < n && s [ r - l ] == s [ r ] ) r ++ ; z [ i ] = r - l ; r -- ; } else { int k = i - l ; if ( z [ k ] < r - i + 1 ) { z [ i ] = z [ k ] ; } else { l = i ; while ( r < n && s [ r - l ] == s [ r ] ) r ++ ; z [ i ] = r - l ; r -- ; } } } }
int countPermutation ( string a , string b ) { b = b + b ; b = b . substr ( 0 , b . size ( ) - 1 ) ; int ans = 0 ; string s = a + "$" + b ; int n = s . length ( ) ; int z [ n ] ; compute_z ( s , z ) ; for ( int i = 1 ; i <= n - 1 ; i ++ ) { if ( z [ i ] == a . length ( ) ) ans ++ ; } return ans ; }
int countDecreasing ( int A [ ] , int n ) { int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( A [ i + 1 ] < A [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
bool doMatch ( string A , string B ) { for ( int i = 0 ; i < A . length ( ) ; i ++ ) if ( A [ i ] != '*' && B [ i ] != '*' ) if ( A [ i ] != B [ i ] ) return false ; return true ; }
bool printRLE ( string str , string typed ) { int n = str . length ( ) , m = typed . length ( ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] != typed [ j ] ) return false ; if ( isVowel ( str [ i ] ) == false ) { j ++ ; continue ; } int count1 = 1 ; while ( i < n - 1 && str [ i ] == str [ i + 1 ] ) { count1 ++ ; i ++ ; } int count2 = 1 ; while ( j < m - 1 && typed [ j ] == str [ i ] ) { count2 ++ ; j ++ ; } if ( count1 > count2 ) return false ; } return true ; }
int minimumChar ( string S1 , string S2 ) { int n = S1 . size ( ) , m = S2 . size ( ) ; int ans = INT_MAX ; for ( int i = 0 ; i < m - n + 1 ; i ++ ) { int minRemovedChar = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( S1 [ j ] != S2 [ i + j ] ) { minRemovedChar ++ ; } } ans = min ( minRemovedChar , ans ) ; } return ans ; }
int fact ( int N ) { int i , product = 1 ; for ( i = 1 ; i <= N ; i ++ ) product = product * i ; return product ; }
int nthTerm ( int N ) { return ( N * N ) * fact ( N ) ; }
int factorial ( int N ) { int fact = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fact = fact * i ; return fact ; }
int nthTerm ( int N ) { return ( factorial ( N ) * ( N + 2 ) / 2 ) ; }
int factorial ( int N ) { if ( N == 0 N == 1 ) return 1 ; return N * factorial ( N - 1 ) ; }
int nthTerm ( int N ) { return ( factorial ( N ) * ( N + 2 ) / 2 ) ; }
bool check ( string S1 , string S2 ) { int n1 = S1 . size ( ) ; int n2 = S2 . size ( ) ; unordered_map < int , int > mp ; for ( int i = 0 ; i < n1 ; i ++ ) { mp [ S1 [ i ] ] ++ ; } for ( int i = 0 ; i < n2 ; i ++ ) { if ( mp [ S2 [ i ] ] ) { mp [ S2 [ i ] ] -- ; } else if ( mp [ S2 [ i ] - 1 ] && mp [ S2 [ i ] - 2 ] ) { mp [ S2 [ i ] - 1 ] -- ; mp [ S2 [ i ] - 2 ] -- ; } else { return false ; } } return true ; }
void state1 ( char c ) { if ( c == 't' c == 'T' ) dfa = 1 ; else if ( c == 'h' c == 'H' ) dfa = 2 ; else dfa = 0 ; }
void state2 ( char c ) { if ( c == 'e' c == 'E' ) dfa = 3 ; else if ( c == 't' c == 'T' ) dfa = 1 ; else dfa = 0 ; }
void state3 ( char c ) { if ( c == 't' c == 'T' ) dfa = 1 ; else dfa = 0 ; }
bool isAccepted ( string str ) { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( dfa == 0 ) start ( str [ i ] ) ; else if ( dfa == 1 ) state1 ( str [ i ] ) ; else if ( dfa == 2 ) state2 ( str [ i ] ) ; else state3 ( str [ i ] ) ; } return ( dfa != 3 ) ; }
int isSubstring ( string s1 , string s2 ) { int M = s1 . length ( ) ; int N = s2 . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 [ i + j ] != s1 [ j ] ) break ; if ( j == M ) return i ; } return -1 ; }
int countFreq ( string & pat , string & txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int res = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { res ++ ; j = 0 ; } } return res ; }
int countPattern ( string str ) { int len = str . size ( ) ; bool oneSeen = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '1' && oneSeen == 1 ) if ( str [ i - 1 ] == '0' ) count ++ ; if ( str [ i ] == '1' && oneSeen == 0 ) { oneSeen = 1 ; continue ; } if ( str [ i ] != '0' && str [ i ] != '1' ) oneSeen = 0 ; } return count ; }
int patternCount ( string str ) { char last = str [ 0 ] ; int i = 1 , counter = 0 ; while ( i < str . size ( ) ) { if ( str [ i ] == '0' && last == '1' ) { while ( str [ i ] == '0' ) i ++ ; if ( str [ i ] == '1' ) counter ++ ; } last = str [ i ] ; i ++ ; } return counter ; }
int maxPrefix ( char s [ ] , char t [ ] ) { int count = 0 ; for ( int i = 0 ; i < strlen ( t ) ; i ++ ) { if ( count == strlen ( s ) ) break ; if ( t [ i ] == s [ count ] ) count ++ ; } return count ; }
void translate ( char * str ) { if ( str [ 0 ] == '' ) return ; for ( int i = 1 ; str [ i ] != '' ; i ++ ) { if ( str [ i - 1 ] == 'A' && str [ i ] == 'B' ) { str [ i - 1 ] = 'C' ; for ( int j = i ; str [ j ] != '' ; j ++ ) str [ j ] = str [ j + 1 ] ; } } return ; }
bool isvalid ( int row , int col , int prevRow , int prevCol ) { return ( row >= 0 ) && ( row < ROW ) && ( col >= 0 ) && ( col < COL ) && ! ( row == prevRow && col == prevCol ) ; }
int getNextState ( string pat , int M , int state , int x ) { if ( state < M && x == pat [ state ] ) return state + 1 ; int ns , i ; for ( ns = state ; ns > 0 ; ns -- ) { if ( pat [ ns - 1 ] == x ) { for ( i = 0 ; i < ns - 1 ; i ++ ) if ( pat [ i ] != pat [ state - ns + 1 + i ] ) break ; if ( i == ns - 1 ) return ns ; } } return 0 ; }
void calculate ( string ans ) { int dp [ 26 ] = { 0 } ; for ( int i = 0 ; i < ans . length ( ) ; ++ i ) { dp [ ans [ i ] - 'A' ] ++ ; } for ( int i = 0 ; i < 26 ; ++ i ) { if ( dp [ i ] % 2 == 1 ) { return ; } } if ( maxi < ans . length ( ) ) { maxi = ans . length ( ) ; ans1 = ans ; } }
void longestString ( vector < string > arr , int index , string str ) { if ( index == arr . size ( ) ) { return ; } longestString ( arr , index + 1 , str ) ; str += arr [ index ] ; calculate ( str ) ; longestString ( arr , index + 1 , str ) ; }
int countSubstrings ( string & str ) { int freq [ 3 ] = { 0 } ; int count = 0 ; int i = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { freq [ str [ j ] - '0' ] ++ ; while ( freq [ 0 ] > 0 && freq [ 1 ] > 0 && freq [ 2 ] > 0 ) { freq [ str [ i ++ ] - '0' ] -- ; } count += i ; } return count ; }
int minSwaps ( string s ) { int ones = 0 , zeros = 0 ; int N = s . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '1' ) ones ++ ; else zeros ++ ; } if ( ( N % 2 == 0 && ones != zeros ) || ( N % 2 == 1 && abs ( ones - zeros ) != 1 ) ) { return -1 ; } int ans_1 = 0 ; int j = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '1' ) { ans_1 += abs ( j - i ) ; j += 2 ; } } int ans_0 = 0 ; int k = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '0' ) { ans_0 += abs ( k - i ) ; k += 2 ; } } if ( N % 2 == 0 ) return min ( ans_1 , ans_0 ) ; else { if ( ones > zeros ) return ans_1 ; else return ans_0 ; } }
void isOnesGreater ( string S , int N ) { int cnt0 = 0 ; int cnt1 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '1' ) cnt1 ++ ; else cnt0 ++ ; } for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '1' ) { if ( i > 0 && S [ i - 1 ] == '0' ) { S [ i - 1 ] = '_' ; cnt0 -- ; } else if ( i < N && S [ i + 1 ] == '0' ) { S [ i + 1 ] = '_' ; cnt0 -- ; } } } if ( cnt1 > cnt0 ) { cout << "Yes" ; } else { cout << "No" ; } }
string findString ( vector < string > & arr , int N ) { string ans = "" ; for ( int i = 0 ; i < N ; i ++ ) { ans += arr [ i ] [ i ] == '0' ? '1' : '0' ; } return ans ; }
int waysToClearString ( string S ) { memset ( dp , -1 , sizeof ( dp ) ) ; int n = S . length ( ) ; choose [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n / 2 ; ++ i ) { choose [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j <= i ; ++ j ) { choose [ i ] [ j ] = ( choose [ i - 1 ] [ j ] + choose [ i - 1 ] [ j - 1 ] ) ; } } return calc ( 0 , n - 1 , S ) ; }
int minFlips ( string str ) { int count = 0 ; if ( str . size ( ) <= 2 ) { return 0 ; } for ( int i = 0 ; i < str . size ( ) - 2 ; ) { if ( str [ i ] == str [ i + 1 ] && str [ i + 2 ] == str [ i + 1 ] ) { i = i + 3 ; count ++ ; } else { i ++ ; } } return count ; }
int findMissingDigit ( string a , string b , string c ) { int w = 1 ; int a_mod_11 = 0 ; for ( int i = a . size ( ) - 1 ; i >= 0 ; i -- ) { a_mod_11 = ( a_mod_11 + w * ( a [ i ] - '0' ) ) % 11 ; w = w * -1 ; } int b_mod_11 = 0 ; w = 1 ; for ( int i = b . size ( ) - 1 ; i >= 0 ; i -- ) { b_mod_11 = ( b_mod_11 + w * ( b [ i ] - '0' ) ) % 11 ; w = w * -1 ; } int c_mod_11 = 0 ; bool xSignIsPositive = true ; w = 1 ; for ( int i = c . size ( ) - 1 ; i >= 0 ; i -- ) { if ( c [ i ] == 'x' ) { xSignIsPositive = ( w == 1 ) ; } else { c_mod_11 = ( c_mod_11 + w * ( c [ i ] - '0' ) ) % 11 ; } w = w * -1 ; } int x = ( ( a_mod_11 * b_mod_11 ) - c_mod_11 ) % 11 ; if ( ! xSignIsPositive ) { x = - x ; } return ( x % 11 + 11 ) % 11 ; }
bool validInsertionstring ( string S1 , string S2 ) { int N = S1 . length ( ) ; int M = S2 . length ( ) ; stack < char > st ; for ( int i = 0 ; i < N ; i ++ ) { st . push ( S1 [ i ] ) ; if ( S1 [ i ] == S2 [ M - 1 ] ) { int idx = M - 1 ; while ( idx >= 0 ) { if ( st . empty ( ) ) { return false ; } char c = st . top ( ) ; st . pop ( ) ; if ( c != S2 [ idx ] ) { return false ; } idx -- ; } } } if ( ! st . empty ( ) ) { return false ; } else { return true ; } }
int lengthNPalindrome ( int N , int K ) { int half = N / 2 ; if ( N & 1 ) { half += 1 ; } int ans = 1 ; for ( int i = 1 ; i <= half ; i ++ ) { ans *= K ; K -- ; } return ans ; }
int palindromicStrings ( int N , int K ) { if ( N == 1 ) { return K ; } if ( N == 2 ) { return 2 * K ; } int ans = 0 ; ans += ( 2 * K ) ; for ( int i = 3 ; i <= N ; i ++ ) { ans += lengthNPalindrome ( i , K ) ; } return ans ; }
int LCS ( string & S , int N , string & T , int M , vector < vector < int > > & dp ) { if ( N == 0 or M == 0 ) return 0 ; if ( dp [ N ] [ M ] != -1 ) return dp [ N ] [ M ] ; if ( S [ N - 1 ] == T [ M - 1 ] ) { return dp [ N ] [ M ] = 1 + LCS ( S , N - 1 , T , M - 1 , dp ) ; } return dp [ N ] [ M ] = max ( LCS ( S , N - 1 , T , M , dp ) , LCS ( S , N , T , M - 1 , dp ) ) ; }
int maxlength ( string s ) { int n = s . length ( ) , i , j ; int ans = 0 ; for ( i = 0 ; i <= n - 1 ; i ++ ) { if ( s [ i ] == '1' ) { int count = 1 ; for ( j = i + 1 ; j <= n - 1 && s [ j ] == '1' ; j ++ ) count ++ ; ans = max ( ans , count ) ; } } return ans ; }
int maximumK ( string & S ) { int N = S . length ( ) ; int ans = N ; int flag = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( S [ i ] != S [ i + 1 ] ) { flag = 1 ; ans = min ( ans , max ( i + 1 , N - i - 1 ) ) ; } } if ( flag == 0 ) return 0 ; return ans ; }
void findIfPossible ( int N , string str ) { int countG = 0 , countF = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == 'G' ) countG ++ ; else countF ++ ; } if ( 2 * countF != countG ) { cout << "NO\n" ; } else { int id = 0 ; bool flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == 'G' ) { countG -- ; id ++ ; } else { countF -- ; id -- ; } if ( id < 0 ) { flag = false ; break ; } if ( countG < countF ) { flag = false ; break ; } } if ( flag ) { cout << "YES\n" ; } else { cout << "NO\n" ; } } }
int findComb ( int N , int M ) { int x = fact ( N + 1 ) ; int y = fact ( M ) ; return ( x * y ) ; }
void isPossible ( string str1 , string str2 ) { int arr [ 256 ] = { 0 } ; int l1 = str1 . size ( ) ; int l2 = str2 . size ( ) ; int i , j ; bool possible = true ; for ( i = 0 ; i < l1 ; i ++ ) { arr [ str1 [ i ] ] = 1 ; } for ( i = 0 ; i < l2 ; i ++ ) { if ( str2 [ i ] != ' ' ) { if ( arr [ str2 [ i ] ] == 1 ) continue ; else { possible = false ; break ; } } } if ( possible ) { cout << "Yes" << endl ; } else { cout << "No" << endl ; } }
bool check ( string & S ) { for ( int i = 1 ; i < S . length ( ) ; i ++ ) { if ( S [ i - 1 ] == S [ i ] ) { return false ; } } return true ; }
void findMinimumSwaps ( string & S ) { int ansSwaps = INT_MAX ; minimumSwaps ( S , ansSwaps ) ; if ( ansSwaps == INT_MAX ) cout << "-1" ; else cout << ansSwaps ; }
char FindKthChar ( string str , long long K , int X ) { char ans ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int digit = str [ i ] - '0' ; int range = pow ( digit , X ) ; sum += range ; if ( K <= sum ) { ans = str [ i ] ; break ; } } return ans ; }
string convertToHex ( int num ) { string temp = "" ; while ( num != 0 ) { int rem = num % 16 ; char c ; if ( rem < 10 ) { c = rem + 48 ; } else { c = rem + 87 ; } temp += c ; num = num / 16 ; } return temp ; }
int minimumHammingDistance ( string S , int K ) { int n = S . size ( ) ; int pref [ n ] ; pref [ 0 ] = S [ 0 ] - '0' ; for ( int i = 1 ; i < n ; i ++ ) pref [ i ] = pref [ i - 1 ] + ( S [ i ] - '0' ) ; int cnt = pref [ n - 1 ] ; int ans = cnt ; for ( int i = 0 ; i < n - K ; i ++ ) { int value = pref [ i + K - 1 ] - ( i - 1 >= 0 ? pref [ i - 1 ] : 0 ) ; ans = min ( ans , cnt - value + ( K - value ) ) ; } return ans ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; else if ( n == 2 ) return true ; else if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { if ( n % i == 0 ) return false ; } return true ; }
void checkPermutation ( string s1 , string s2 ) { int freq [ 26 ] = { 0 } ; for ( char ch : s1 ) { freq [ ch - 'a' ] -- ; } for ( char ch : s2 ) { freq [ ch - 'a' ] ++ ; } bool isAllChangesPrime = true ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == 0 ) { continue ; } else if ( ! isPrime ( abs ( freq [ i ] ) ) ) { isAllChangesPrime = false ; break ; } } if ( isAllChangesPrime ) { cout << "Yes" ; } else { cout << "No" ; } }
void minimumOperations ( string S , int N ) { int ans = 0 ; int cntOne = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( S [ i ] == '0' ) { ans += cntOne ; cntOne *= 2 ; } else cntOne ++ ; } cout << ans ; }
void differentBitwiseOR ( string s1 , string s2 ) { int n = s1 . size ( ) ; int t00 = 0 , t10 = 0 , t01 = 0 , t11 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == '0' && s2 [ i ] == '0' ) { t00 ++ ; } if ( s1 [ i ] == '1' && s2 [ i ] == '0' ) { t10 ++ ; } if ( s1 [ i ] == '1' && s2 [ i ] == '1' ) { t11 ++ ; } if ( s1 [ i ] == '0' && s2 [ i ] == '1' ) { t01 ++ ; } } int ans = t00 * t10 + t01 * t10 + t00 * t11 ; cout << ans ; }
void RemoveCharacters ( string s ) { string ans = "" ; bool c [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) c [ i ] = 0 ; int pos = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( c [ s [ i ] - 'a' ] == 0 ) { c [ s [ i ] - 'a' ] = 1 ; pos = i ; ans += s [ i ] ; } } for ( int i = pos + 1 ; i < ( int ) s . size ( ) ; i ++ ) { if ( s [ i ] == s [ 0 ] ) { ans += s [ i ] ; break ; } } cout << ans ; }
void changeCharacters ( string S , int N , int K ) { int flag = 1 ; int count = 0 ; stack < char > st ; for ( int i = 0 ; i < N ; i ++ ) { if ( st . empty ( ) ) { if ( S [ i ] == '0' ) { flag = 0 ; break ; } count = 0 ; st . push ( S [ i ] ) ; } else { if ( S [ i ] == '0' ) { count ++ ; if ( count == K ) { st . pop ( ) ; count = 0 ; } } else { count = 0 ; } } } if ( flag ) cout << "YES" << endl ; else cout << "NO" << endl ; }
int findSubsequence ( string S , char ch ) { int N = S . length ( ) ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == ch ) { ans ++ ; ch ++ ; } } return ans ; }
int findMaxSubsequence ( string S ) { int ans = 0 ; for ( char ch = 'a' ; ch <= 'z' ; ch ++ ) { ans = max ( ans , findSubsequence ( S , ch ) ) ; } return ans ; }
int minOpsToEmptyString ( string s ) { int ans = INT_MIN ; int cn0 = 0 ; int cn1 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '0' ) { if ( cn1 > 0 ) cn1 -- ; cn0 ++ ; } else { if ( cn0 > 0 ) cn0 -- ; cn1 ++ ; } ans = max ( { ans , cn0 , cn1 } ) ; } cout << ans ; }
bool prefixDivisble ( int n ) { int i = 1 ; while ( n > 0 ) { if ( n % i != 0 ) return false ; n = n / 10 ; i ++ ; } return true ; }
bool isPrime ( int num ) { bool flag = false ; if ( num > 1 ) { for ( int i = 2 ; i < num ; i ++ ) { if ( ( num % i ) == 0 ) { flag = true ; break ; } } } if ( flag ) return false ; else return true ; }
int order ( int x ) { int n = 0 ; while ( x != 0 ) { n = n + 1 ; x = x / 10 ; } return n ; }
bool isArmstrong ( int x ) { int n = order ( x ) ; int temp = x ; int sum1 = 0 ; while ( temp != 0 ) { int r = temp % 10 ; sum1 = sum1 + pow ( r , n ) ; temp = temp / 10 ; } return ( sum1 == x ) ; }
int count_armstrong ( vector < string > li ) { int c = 0 ; for ( string ele : li ) { int val = 0 ; for ( char che : ele ) val += che ; if ( isArmstrong ( val ) ) c += 1 ; } return c ; }
int count_prime ( vector < string > li ) { int c = 0 ; for ( string ele : li ) { int val = 0 ; for ( char che : ele ) val += che ; if ( isPrime ( val ) ) c += 1 ; } return c ; }
void findMinimumCost ( string s , int N ) { int count_1 = 0 , count_0 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '1' ) count_1 ++ ; else count_0 ++ ; } int k = abs ( count_0 - count_1 ) ; if ( count_1 == N count_0 == N ) cout << -1 << endl ; else cout << k / 2 << endl ; }
void countOccurrences ( string S , string X , string Y ) { int count = 0 ; int N = S . length ( ) , A = X . length ( ) ; int B = Y . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . substr ( i , B ) == Y ) count ++ ; if ( S . substr ( i , A ) == X ) cout << count << " " ; } }
int findLength ( string str , int n ) { int pre [ n ] , post [ n ] ; memset ( pre , 0 , sizeof ( pre ) ) ; memset ( post , 0 , sizeof ( post ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != 0 ) { pre [ i ] += pre [ i - 1 ] ; } if ( str [ i ] == '1' ) { pre [ i ] += 1 ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i != n - 1 ) post [ i ] += post [ i + 1 ] ; if ( str [ i ] == '0' ) post [ i ] += 1 ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = max ( ans , pre [ i ] + post [ i ] ) ; } return ans ; }
int countSubstring ( string & S , int N ) { unordered_map < int , int > prevSum ; int res = 0 ; int currentSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] >= 'A' and S [ i ] <= 'Z' ) { currentSum ++ ; } else currentSum -- ; if ( currentSum == 0 ) res ++ ; if ( prevSum . find ( currentSum ) != prevSum . end ( ) ) { res += ( prevSum [ currentSum ] ) ; } prevSum [ currentSum ] ++ ; } return res ; }
void checkforSubsequence ( string S , string target ) { stack < char > s ; for ( int i = 0 ; i < target . size ( ) ; i ++ ) { s . push ( target [ i ] ) ; } for ( int i = ( int ) S . size ( ) - 1 ; i >= 0 ; i -- ) { if ( s . empty ( ) ) { cout << "Yes" << endl ; return ; } if ( S [ i ] == s . top ( ) ) { s . pop ( ) ; } } if ( s . empty ( ) ) cout << "Yes" << endl ; else cout << "No" << endl ; }
void makeDFA ( ) { dfa [ 0 ] [ 0 ] = 1 ; dfa [ 1 ] [ 0 ] = 1 ; dfa [ 1 ] [ 2 ] = 3 ; dfa [ 1 ] [ 3 ] = 2 ; dfa [ 1 ] [ 4 ] = 6 ; dfa [ 3 ] [ 0 ] = 4 ; dfa [ 4 ] [ 0 ] = 4 ; dfa [ 4 ] [ 3 ] = 5 ; dfa [ 4 ] [ 4 ] = 6 ; dfa [ 6 ] [ 0 ] = 8 ; dfa [ 6 ] [ 1 ] = 7 ; dfa [ 7 ] [ 0 ] = 8 ; dfa [ 8 ] [ 0 ] = 8 ; dfa [ 8 ] [ 3 ] = 9 ; }
void buildDFA ( ) { for ( int i = 0 ; i < 11 ; i ++ ) for ( int j = 0 ; j < 5 ; j ++ ) dfa [ i ] [ j ] = 10 ; makeDFA ( ) ; }
void checkDFA ( string s ) { buildDFA ( ) ; int currentstate = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( digits . find ( s [ i ] ) != digits . npos ) currentstate = dfa [ currentstate ] [ 0 ] ; else if ( sign . find ( s [ i ] ) != sign . npos ) currentstate = dfa [ currentstate ] [ 1 ] ; else if ( dot . find ( s [ i ] ) != dot . npos ) currentstate = dfa [ currentstate ] [ 2 ] ; else if ( ex . find ( s [ i ] ) != ex . npos ) currentstate = dfa [ currentstate ] [ 4 ] ; else currentstate = dfa [ currentstate ] [ 3 ] ; } if ( currentstate == 1 currentstate == 4 currentstate == 8 ) { cout << "Unsigned integer" ; } else { cout << "Not an unsigned integer" ; } }
string getString ( int N ) { string ans = "" ; while ( N >= 26 ) { ans += 'z' ; N -= 26 ; } ans += char ( N + 'a' - 1 ) ; return ans ; }
int subString ( string s , int n ) { map < int , int > hash ; hash [ 0 ] = 1 ; int pre = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { pre ^= ( 1 << int ( s [ i ] ) - 97 ) ; count += hash [ pre ] ; hash [ pre ] = hash [ pre ] + 1 ; } return count ; }
void countSamePrefixSuffix ( string s , int n ) { string prefix = "" ; for ( int i = 0 ; i < n - 1 ; i ++ ) { prefix += s [ i ] ; string suffix = s . substr ( n - 1 - i , n - 1 ) ; if ( prefix == suffix ) { cout << prefix . size ( ) << " " ; } } }
void atleastkDistinctChars ( string s , int k ) { int n = s . size ( ) ; unordered_map < char , int > mp ; int begin = 0 , end = 0 ; int ans = 0 ; while ( end < n ) { char c = s [ end ] ; mp ++ ; end ++ ; while ( mp . size ( ) >= k ) { char pre = s [ begin ] ; mp [ pre ] -- ; if ( mp [ pre ] == 0 ) { mp . erase ( pre ) ; } ans += s . length ( ) - end + 1 ; begin ++ ; } } cout << ans ; }
void minimumMoves ( string s , int n , int k ) { if ( n & 1 ) { cout << "No" ; return ; } int countOpen = count ( s . begin ( ) , s . end ( ) , '(' ) ; int countClose = count ( s . begin ( ) , s . end ( ) , ')' ) ; if ( countOpen != countClose ) { cout << "No" ; return ; } int ans = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( s [ i ] == '(' ) ++ cnt ; else { -- cnt ; if ( cnt < 0 ) { cnt = 0 ; ++ ans ; } } } if ( ans <= k ) cout << "Yes" ; else cout << "No" ; }
void inOrder ( Node * root ) { if ( root == NULL ) return ; Node * cur = leftMost ( root ) ; while ( cur != NULL ) { cout << cur -> key << " " ; if ( cur -> isThreaded ) cur = cur -> right ; else cur = leftMost ( cur -> right ) ; } }
void countFrequency ( string S , int N ) { int freq [ 26 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { freq [ S [ i ] - 'a' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == 0 ) continue ; int lg = log2 ( freq [ i ] ) ; int a = pow ( 2 , lg ) ; if ( a == freq [ i ] ) { while ( freq [ i ] -- ) cout << ( char ) ( i + 'a' ) ; } } }
void buildTree ( string s , treeNode * tree , int start , int end , int treeNode ) { if ( start == end ) { tree [ treeNode ] . square_sum = pow ( s [ start ] - 'a' + 1 , 2 ) ; return ; } int mid = start + ( ( end - start ) / 2 ) ; buildTree ( s , tree , start , mid , 2 * treeNode ) ; buildTree ( s , tree , mid + 1 , end , 1 + 2 * treeNode ) ; tree [ treeNode ] . square_sum = tree [ ( 2 * treeNode ) ] . square_sum + tree [ ( 2 * treeNode ) + 1 ] . square_sum ; }
int querySquareSum ( treeNode * tree , int start , int end , int treeNode , int l , int r ) { if ( ( l > end ) || ( r < start ) ) { return 0 ; } if ( ( l <= start ) && ( r >= end ) ) { return tree [ treeNode ] . square_sum ; } int mid = start + ( ( end - start ) / 2 ) ; int X = querySquareSum ( tree , start , mid , 2 * treeNode , l , r ) ; int Y = + querySquareSum ( tree , mid + 1 , end , 1 + 2 * treeNode , l , r ) ; return X + Y ; }
void canSplit ( string & S ) { vector < int > frequency ( 26 , 0 ) ; int cnt_singles = 0 ; int k = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) frequency [ S [ i ] - 'a' ] ++ ; int odd = 0 , eve = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( frequency [ i ] ) { odd += ( frequency [ i ] & 1 ) ; eve += frequency [ i ] / 2 ; } } if ( eve >= odd ) cout << "Yes" ; else cout << "No" ; }
string isPossible ( string S , int R , int N ) { int cntl = 0 , cntr = 0 ; int cntu = 0 , cntd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == 'L' ) cntl ++ ; else if ( S [ i ] == 'R' ) cntr ++ ; else if ( S [ i ] == 'U' ) cntu ++ ; else cntd ++ ; } if ( max ( max ( cntl , cntr ) , max ( cntu , cntd ) ) >= R ) return "Yes" ; unordered_map < int , int > mp ; int r_square = R * R ; for ( int i = 1 ; i * i <= r_square ; i ++ ) { mp [ i * i ] = i ; if ( mp . find ( r_square - i * i ) != mp . end ( ) ) { if ( max ( cntl , cntr ) >= mp [ r_square - i * i ] && max ( cntu , cntd ) >= i ) return "Yes" ; if ( max ( cntl , cntr ) >= i && max ( cntu , cntd ) >= mp [ r_square - i * i ] ) return "Yes" ; } } return "No" ; }
void inorder ( Node * root ) { bool leftdone = false ; while ( root ) { if ( ! leftdone ) { while ( root -> left ) root = root -> left ; } printf ( "%d " , root -> key ) ; leftdone = true ; if ( root -> right ) { leftdone = false ; root = root -> right ; } else if ( root -> parent ) { while ( root -> parent && root == root -> parent -> right ) root = root -> parent ; if ( ! root -> parent ) break ; root = root -> parent ; } else break ; } }
int findDuplicate ( int arr [ ] , int n , int k ) { int freq [ MAX ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 1 && arr [ i ] > MAX ) { cout << "Out of range" ; return -1 ; } freq [ arr [ i ] ] += 1 ; } for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == k ) return i ; } return -1 ; }
void nearestPowerOfTwo ( string & S ) { int N = S . size ( ) ; unordered_map < char , int > freq ; for ( int i = 0 ; i < N ; i ++ ) { freq [ S [ i ] ] ++ ; } nearestPowerOfTwoUtil ( freq ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int lcm ( int a , int b ) { return ( a / gcd ( a , b ) ) * b ; }
int canMakeSame ( string s1 , string s2 ) { int ans = 0 ; if ( s1 . size ( ) != s2 . size ( ) ) { return -1 ; } int N = s1 . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( s1 [ i ] != s2 [ i ] ) { while ( i < s1 . length ( ) && s1 [ i ] != s2 [ i ] ) { i ++ ; } ans ++ ; } } return ans ; }
void printSorted ( int arr [ ] , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; cout << arr [ start ] << " " ; printSorted ( arr , start * 2 + 2 , end ) ; }
int minDeletions ( string str ) { int fre [ 26 ] ; memset ( fre , 0 , sizeof ( fre ) ) ; int n = str . size ( ) ; cout << n ; for ( int i = 0 ; i < n ; i ++ ) { fre [ str [ i ] - 'a' ] += 1 ; } for ( int i = 0 ; i < n ; i ++ ) { cout << fre [ i ] ; } int count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( fre [ i ] % 2 ) { count += 1 ; } } if ( count == 0 count == 1 ) { return 0 ; } else { return count - 1 ; } }
void countTotalFrequencies ( string S1 , string S2 ) { set < char > bset ; for ( auto x : S1 ) bset . insert ( x ) ; int count = 0 ; for ( auto x : S2 ) { if ( bset . find ( x ) != bset . end ( ) ) count += 1 ; } cout << count << endl ; }
int min_length ( string str ) { int n = str . length ( ) ; int total_zeros = 0 ; int total_ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) total_zeros ++ ; else total_ones ++ ; } int ans = min ( total_zeros , total_ones ) ; int cur_zeros = 0 , cur_ones = 0 ; for ( char x : str ) { if ( x == '0' ) cur_zeros ++ ; else cur_ones ++ ; ans = min ( ans , cur_ones + ( total_zeros - cur_zeros ) ) ; } cout << ans ; }
void findWinner ( string a , int n ) { vector < int > v ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == '0' ) { c ++ ; } else { if ( c != 0 ) v . push_back ( c ) ; c = 0 ; } } if ( c != 0 ) v . push_back ( c ) ; if ( v . size ( ) == 0 ) { cout << "Player B" ; return ; } if ( v . size ( ) == 1 ) { if ( v [ 0 ] & 1 ) cout << "Player A" ; else cout << "Player B" ; return ; } int first = INT_MIN ; int second = INT_MIN ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( a [ i ] > first ) { second = first ; first = a [ i ] ; } else if ( a [ i ] > second && a [ i ] != first ) second = a [ i ] ; } if ( ( first & 1 ) && ( first + 1 ) / 2 > second ) cout << "Player A" ; else cout << "Player B" ; }
int minimumSwaps ( string s , int l , int r , int k ) { int n = s . length ( ) ; int tot_ones = 0 , tot_zeros = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '1' ) tot_ones ++ ; else tot_zeros ++ ; } int ones = 0 , zeros = 0 , sum = 0 ; for ( int i = l - 1 ; i < r ; i ++ ) { if ( s [ i ] == '1' ) { ones ++ ; sum ++ ; } else zeros ++ ; } int rem_ones = tot_ones - ones ; int rem_zeros = tot_zeros - zeros ; if ( k >= sum ) { int rem = k - sum ; if ( zeros >= rem && rem_ones >= rem ) return rem ; } else if ( k < sum ) { int rem = sum - k ; if ( ones >= rem && rem_zeros >= rem ) return rem ; } return -1 ; }
bool longHelper ( int freq1 [ ] , int freq2 [ ] ) { for ( int i = 0 ; i < SIZE ; ++ i ) { if ( freq1 [ i ] != freq2 [ i ] ) { return false ; } } return true ; }
int longCommomPrefixAnagram ( string s1 , string s2 , int n1 , int n2 ) { int freq1 [ 26 ] = { 0 } ; int freq2 [ 26 ] = { 0 } ; int ans = 0 ; int mini_len = min ( n1 , n2 ) ; for ( int i = 0 ; i < mini_len ; ++ i ) { freq1 [ s1 [ i ] - 'a' ] ++ ; freq2 [ s2 [ i ] - 'a' ] ++ ; if ( longHelper ( freq1 , freq2 ) ) { ans = i + 1 ; } } cout << ans ; }
void getMin ( vector < int > arr ) { int minSum = INT_MAX ; for ( int i = 0 ; i < 10 ; i ++ ) { int curSum = 0 ; for ( int num : arr ) curSum += remove ( num , i ) ; minSum = min ( minSum , curSum ) ; } cout << minSum ; }
bool isReducible ( string str ) { int N = str . size ( ) ; stack < char > s ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == '1' ) s . push ( str [ i ] ) ; else if ( ! s . empty ( ) ) s . pop ( ) ; else return false ; } return s . empty ( ) ; }
bool checkPalindrome ( string s ) { int low = 0 , high = ( int ) s . size ( ) - 1 ; while ( low < high ) { if ( s [ low ] != s [ high ] ) return false ; low ++ ; high -- ; } return true ; }
void populateNumber ( ) { Ans . push_back ( 2 ) ; Ans . push_back ( 5 ) ; long long int x = 5 ; while ( x < 1000000000001 ) { x *= 2 ; Ans . push_back ( x ) ; x = x * 2 + 1 ; Ans . push_back ( x ) ; } }
string checkString ( long long int N ) { populateNumber ( ) ; for ( auto & it : Ans ) { if ( it == N ) { return "Yes" ; } } return "No" ; }
void DFA ( string str , int N ) { if ( N <= 1 ) { cout << "No" ; return ; } int count = 0 ; if ( str [ 0 ] == 'C' ) { count ++ ; for ( int i = 1 ; i < N ; i ++ ) { if ( str [ i ] == 'A' str [ i ] == 'B' ) count ++ ; else break ; } } else { cout << "No" ; return ; } if ( count == N ) cout << "Yes" ; else cout << "No" ; }
bool balanced ( int small [ ] , int caps [ ] ) { for ( int i = 0 ; i < 26 ; i ++ ) { if ( small [ i ] != 0 && ( caps [ i ] == 0 ) ) return 0 ; else if ( ( small [ i ] == 0 ) && ( caps [ i ] != 0 ) ) return 0 ; } return 1 ; }
int GCD ( int lena , int lenb ) { if ( lena == 0 ) return lenb ; if ( lenb == 0 ) return lena ; if ( lena == lenb ) return lena ; if ( lena > lenb ) return GCD ( lena - lenb , lenb ) ; return GCD ( lena , lenb - lena ) ; }
void cntBalancedParenthesis ( string s , int N ) { int cntPairs = 0 ; int cntCurly = 0 ; int cntSml = 0 ; int cntSqr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '{' ) { cntCurly ++ ; } else if ( s [ i ] == '(' ) { cntSml ++ ; } else if ( s [ i ] == '[' ) { cntSqr ++ ; } else if ( s [ i ] == '}' && cntCurly > 0 ) { cntCurly -- ; cntPairs ++ ; } else if ( s [ i ] == ')' && cntSml > 0 ) { cntSml -- ; cntPairs ++ ; } else if ( s [ i ] == ']' && cntSqr > 0 ) { cntSqr -- ; cntPairs ++ ; } } cout << cntPairs ; }
bool canBeBalanced ( string sequence ) { if ( sequence . size ( ) % 2 ) return false ; stack < char > stack_ , stack2_ ; int countOpen = 0 , countClosed = 0 ; int countSymbol = 0 ; for ( int i = 0 ; i < sequence . size ( ) ; i ++ ) { if ( sequence [ i ] == ')' ) { countClosed ++ ; if ( stack_ . empty ( ) ) { return false ; } else { stack_ . pop ( ) ; } } else { if ( sequence [ i ] == '$' ) { countSymbol ++ ; } else { countOpen ++ ; } stack_ . push ( sequence [ i ] ) ; } } for ( int i = sequence . size ( ) - 1 ; i >= 0 ; i -- ) { if ( sequence [ i ] == '(' ) { if ( stack2_ . empty ( ) ) { return false ; } else { stack2_ . pop ( ) ; } } else { stack2_ . push ( sequence [ i ] ) ; } } int extra = abs ( countClosed - countOpen ) ; if ( countSymbol < extra ) { return false ; } else { countSymbol -= extra ; if ( countSymbol % 2 == 0 ) { return true ; } } return false ; }
void maximum_pallindromic ( int arr [ ] ) { int res = 0 ; int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { res += arr [ i ] / 3 ; arr [ i ] = arr [ i ] % 3 ; if ( arr [ i ] == 1 ) c1 ++ ; else if ( arr [ i ] == 2 ) c2 ++ ; } res += min ( c1 , c2 ) ; int t = min ( c1 , c2 ) ; c1 -= t ; c2 -= t ; res += 2 * ( c2 / 3 ) ; c2 %= 3 ; res += c2 / 2 ; cout << res ; }
void inorder ( struct node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; cout << root -> key << "(" << root -> count << ") " ; inorder ( root -> right ) ; } }
int query ( int BIT [ 26 ] [ 10005 ] , int idx , int i ) { int ans = 0 ; while ( i > 0 ) { ans += BIT [ idx ] [ i ] ; i = i - ( i & ( - i ) ) ; } return ans ; }
int minOperation ( string arr [ ] , int N ) { int cntMinOP = 0 ; int M = arr [ 0 ] . length ( ) ; int hash [ 256 ] [ M ] ; memset ( hash , 0 , sizeof ( hash ) ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { hash [ arr [ i ] [ j ] ] [ j ] ++ ; } } for ( int i = 0 ; i < M ; i ++ ) { int Sum = 0 ; int Max = 0 ; for ( int j = 0 ; j < 256 ; j ++ ) { Sum += hash [ j ] [ i ] ; Max = max ( Max , hash [ j ] [ i ] ) ; } cntMinOP += ( Sum - Max ) ; } return cntMinOP ; }
void find_Winner ( vector < string > & arr , int N ) { vector < queue < char > > Q ( N ) ; int M = arr . size ( ) ; for ( int i = 0 ; i < M ; i ++ ) { int len = arr [ i ] . length ( ) ; for ( int j = 0 ; j < len ; j ++ ) { Q [ i ] . push ( arr [ i ] [ j ] - 1 ) ; } } int player = 0 ; while ( Q [ player ] . size ( ) > 0 ) { int nextPlayer = Q [ player ] . front ( ) - '0' ; Q [ player ] . pop ( ) ; player = nextPlayer ; } cout << "Player " << ( player + 1 ) ; }
int longestSubstring ( string s ) { int dp [ 1024 ] ; fill ( dp , dp + 1024 , s . size ( ) ) ; int res = 0 , mask = 0 ; dp [ 0 ] = -1 ; for ( int i = 0 ; i < s . size ( ) ; ++ i ) { mask ^= 1 << ( s [ i ] - 48 ) ; res = max ( res , i - dp [ mask ] ) ; for ( int j = 0 ; j <= 9 ; ++ j ) res = max ( res , i - dp [ mask ^ ( 1 << j ) ] ) ; dp [ mask ] = min ( dp [ mask ] , i ) ; } return res ; }
int countStrings ( string S , vector < string > & list ) { unordered_set < char > valid ; for ( auto x : S ) { valid . insert ( x ) ; } int cnt = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { int j = 0 ; for ( j = 0 ; j < list [ i ] . size ( ) ; j ++ ) { if ( valid . count ( list [ i ] [ j ] ) ) continue ; else break ; } if ( j == list [ i ] . size ( ) ) cnt ++ ; } return cnt ; }
void inorder ( node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; cout << root -> key << " " ; inorder ( root -> right ) ; } }
void countStrings ( string s , int k ) { int ans = 1 ; int len = s . size ( ) ; int flag = 0 ; int start_ind ; for ( int i = 0 ; i < len - 1 ; i ++ ) { if ( s [ i ] - '0' + s [ i + 1 ] - '0' == k && flag == 0 ) { flag = 1 ; start_ind = i ; } if ( flag == 1 && s [ i ] - '0' + s [ i + 1 ] - '0' != k ) { flag = 0 ; if ( ( i - start_ind + 1 ) % 2 != 0 ) ans *= ( i - start_ind + 1 - 1 ) / 2 + 1 ; } } if ( flag == 1 && ( len - start_ind ) % 2 != 0 ) ans *= ( len - start_ind ) / 2 + 1 ; cout << ans ; }
int minLength ( string str , int N , string K , int M ) { stack < char > stackOfChar ; for ( int i = 0 ; i < N ; i ++ ) { stackOfChar . push ( str [ i ] ) ; if ( stackOfChar . size ( ) >= M ) { string l = "" ; for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( K [ j ] != stackOfChar . top ( ) ) { int f = 0 ; while ( f != l . size ( ) ) { stackOfChar . push ( l [ f ] ) ; f ++ ; } break ; } else { l = stackOfChar . top ( ) + l ; stackOfChar . pop ( ) ; } } } } return stackOfChar . size ( ) ; }
void printSequences ( set < string > combinations ) { for ( string s : combinations ) { cout << s << ' ' ; } }
void generateCombinations ( string & s , int n ) { for ( int i = 0 ; i < s . size ( ) ; i ++ ) { combination . push_back ( s [ i ] ) ; long x = stol ( combination ) ; if ( x <= n ) { combinations . insert ( combination ) ; generateCombinations ( s , n ) ; } combination . pop_back ( ) ; } }
long long compute_hash ( string str ) { int p = 31 ; int MOD = 1e9 + 7 ; long long hash_val = 0 ; long long mul = 1 ; for ( char ch : str ) { hash_val = ( hash_val + ( ch - 'a' + 1 ) * mul ) % MOD ; mul = ( mul * p ) % MOD ; } return hash_val ; }
int distinct_str ( vector < string > & arr , int n ) { vector < long long > hash ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { hash [ i ] = compute_hash ( arr [ i ] ) ; } sort ( hash . begin ( ) , hash . end ( ) ) ; int cntElem = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( hash [ i ] != hash [ i - 1 ] ) { cntElem ++ ; } } return cntElem ; }
bool isEqualStrings ( string arr [ ] , int N ) { int M = arr [ 0 ] . length ( ) ; int cntFreq [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { cntFreq [ arr [ i ] [ j ] - 'a' ] ++ ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( cntFreq [ i ] % N != 0 ) { return false ; } } return true ; }
int minimumOperations ( string s , int n ) { unordered_map < char , vector < int > > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ s [ i ] ] . push_back ( i ) ; } int ans = INT_MAX ; for ( auto x : mp ) { int curr = 0 ; int prev = 0 ; bool first = true ; for ( int index : ( x . second ) ) { if ( first ) { if ( index > 0 ) { curr ++ ; } prev = index ; first = false ; } else { if ( index != prev + 1 ) { curr ++ ; } prev = index ; } } if ( prev != n - 1 ) { curr ++ ; } ans = min ( ans , curr ) ; } cout << ans ; }
void PrintStack ( stack < char > s ) { if ( s . empty ( ) ) return ; char x = s . top ( ) ; s . pop ( ) ; PrintStack ( s ) ; cout << x ; s . push ( x ) ; }
void minString ( string s ) { stack < char > Stack ; Stack . push ( s [ 0 ] ) ; for ( int i = 1 ; i < s . size ( ) ; i ++ ) { if ( Stack . empty ( ) ) { Stack . push ( s [ i ] ) ; } else { if ( Stack . top ( ) == s [ i ] ) { Stack . pop ( ) ; } else { Stack . push ( s [ i ] ) ; } } } PrintStack ( Stack ) ; }
void SieveOfEratosthenes ( bool * prime , int n ) { for ( int i = 0 ; i <= n ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = prime [ 1 ] = false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = 2 ; i * j <= n ; j ++ ) { prime [ i * j ] = false ; } } } }
void removePrimeFrequencies ( string s ) { int n = s . length ( ) ; bool prime [ n + 1 ] ; SieveOfEratosthenes ( prime , n ) ; unordered_map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { m [ s [ i ] ] ++ ; } string new_string = "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( prime [ m [ s [ i ] ] ] ) continue ; new_string += s [ i ] ; } cout << new_string ; }
void minMaxDigits ( string str , int N ) { int arr [ N ] ; for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = ( str [ i ] - '0' ) % 3 ; int zero = 0 , one = 0 , two = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero ++ ; if ( arr [ i ] == 1 ) one ++ ; if ( arr [ i ] == 2 ) two ++ ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum = ( sum + arr [ i ] ) % 3 ; } if ( sum == 0 ) { cout << 0 << ' ' ; } if ( sum == 1 ) { if ( one && N > 1 ) cout << 1 << ' ' ; else if ( two > 1 && N > 2 ) cout << 2 << ' ' ; else cout << -1 << ' ' ; } if ( sum == 2 ) { if ( two && N > 1 ) cout << 1 << ' ' ; else if ( one > 1 && N > 2 ) cout << 2 << ' ' ; else cout << -1 << ' ' ; } if ( zero > 0 ) cout << N - 1 << ' ' ; else if ( one > 0 && two > 0 ) cout << N - 2 << ' ' ; else if ( one > 2 two > 2 ) cout << N - 3 << ' ' ; else cout << -1 << ' ' ; }
void findDisStr ( vector < string > & arr , int N ) { unordered_set < string > DistString ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! DistString . count ( arr [ i ] ) ) { DistString . insert ( arr [ i ] ) ; } } for ( auto String : DistString ) { cout << String << " " ; } }
double count_of_accident ( string a , string b ) { int n = a . size ( ) , m = b . size ( ) ; if ( n > m ) return ( m * ( m + 1 ) ) / 2 ; else return ( n * ( n + 1 ) ) / 2 + ( m - n ) * n ; }
double count_of_collision ( string a , string b ) { int n = a . size ( ) , m = b . size ( ) ; int answer = 0 ; int count_of_truck_in_lane_b = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( b [ i ] == 'T' ) count_of_truck_in_lane_b ++ ; for ( int i = 0 ; i < n && i < m ; i ++ ) { if ( a [ i ] == 'T' ) answer += count_of_truck_in_lane_b ; if ( b [ i ] == 'T' ) count_of_truck_in_lane_b -- ; } return answer ; }
int arcIntersection ( string S , int len ) { stack < char > stk ; for ( int i = 0 ; i < len ; i ++ ) { stk . push ( S [ i ] ) ; if ( stk . size ( ) >= 2 ) { char temp = stk . top ( ) ; stk . pop ( ) ; if ( stk . top ( ) == temp ) { stk . pop ( ) ; } else { stk . push ( temp ) ; } } } if ( stk . empty ( ) ) return 1 ; return 0 ; }
int findMinimumChanges ( int N , int K , string S ) { int ans = 0 ; for ( int i = 0 ; i < ( K + 1 ) / 2 ; i ++ ) { map < char , int > mp ; for ( int j = i ; j < N ; j += K ) { mp [ S [ j ] ] ++ ; } for ( int j = N - i - 1 ; j >= 0 ; j -= K ) { if ( K & 1 and i == K / 2 ) break ; mp [ S [ j ] ] ++ ; } int curr_max = INT_MIN ; for ( auto p : mp ) curr_max = max ( curr_max , p . second ) ; if ( K & 1 and i == K / 2 ) ans += ( N / K - curr_max ) ; else ans += ( N / K * 2 - curr_max ) ; } return ans ; }
int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
void checkValidDFA ( string s ) { int initial_state = 0 ; int final_state ; int previous_state = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( s [ i ] == '0' && previous_state == 0 ) || ( s [ i ] == '1' && previous_state == 3 ) ) { final_state = 1 ; } else if ( ( s [ i ] == '0' && previous_state == 3 ) || ( s [ i ] == '1' && previous_state == 0 ) ) { final_state = 2 ; } else if ( ( s [ i ] == '0' && previous_state == 1 ) || ( s [ i ] == '1' && previous_state == 2 ) ) { final_state = 0 ; } else if ( ( s [ i ] == '0' && previous_state == 2 ) || ( s [ i ] == '1' && previous_state == 1 ) ) { final_state = 3 ; } previous_state = final_state ; } if ( final_state == 3 ) { cout << "Accepted" << endl ; } else { cout << "Not Accepted" << endl ; } }
void findFraction ( string s ) { string be_deci = "" , af_deci = "" , reccu = "" ; bool x = true , y = false , z = false ; for ( int i = 0 ; i < s . size ( ) ; ++ i ) { if ( s [ i ] == '.' ) { x = false ; y = true ; continue ; } if ( s [ i ] == '(' ) { z = true ; y = false ; continue ; } if ( x ) be_deci += s [ i ] ; if ( y ) af_deci += s [ i ] ; if ( z ) { for ( ; i < s . size ( ) && s [ i ] != ')'  ; ++ i ) reccu += s [ i ] ; break ; } } int num_be_deci = stoi ( be_deci ) ; int num_af_deci = 0 ; if ( af_deci . size ( ) != 0 ) num_af_deci = stoi ( af_deci ) ; int numr = num_be_deci * pow ( 10 , af_deci . size ( ) ) + num_af_deci ; int deno = pow ( 10 , af_deci . size ( ) ) ; if ( reccu . size ( ) == 0 ) { int gd = __gcd ( numr , deno ) ; cout << numr / gd << " / " << deno / gd ; } else { int reccu_num = stoi ( reccu ) ; int numr1 = numr * pow ( 10 , reccu . size ( ) ) + reccu_num ; int deno1 = deno * pow ( 10 , reccu . size ( ) ) ; int res_numr = numr1 - numr , res_deno = deno1 - deno ; int gd = __gcd ( res_numr , res_deno ) ; cout << res_numr / gd << " / " << res_deno / gd ; } }
int minCost ( string s , int n ) { int minValue = 100000000 ; for ( int i = 0 ; i <= 25 ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < n ; j ++ ) { cnt += min ( abs ( i - ( s [ j ] - 'a' ) ) , 26 - abs ( i - ( s [ j ] - 'a' ) ) ) ; } minValue = min ( minValue , cnt ) ; } return minValue ; }
int longComPre ( string arr [ ] , int N ) { int freq [ N ] [ 256 ] ; for ( let String of DistString ) { for ( int i = 0 ; i < N ; i ++ ) { int M = arr [ i ] . length ( ) ; for ( int j = 0 ; j < M ; j ++ ) { freq [ i ] [ arr [ i ] [ j ] ] ++ ; } } int maxLen = 0 ; for ( int j = 0 ; j < 256 ; j ++ ) { int minRowVal = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { minRowVal = min ( minRowVal , freq [ i ] [ j ] ) ; } maxLen += minRowVal ; } return maxLen ; }
int fact ( int n ) { int res = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { res = res * i ; } return res ; }
int distinctWays ( string str1 , string str2 ) { int n = str1 . length ( ) ; int m = str2 . length ( ) ; if ( n == m ) { return 2 * fact ( n ) * fact ( m ) ; } return fact ( n ) * fact ( m ) ; }
void printResult ( vector < int > result ) { reverse ( result . begin ( ) , result . end ( ) ) ; int i = 0 ; while ( i < result . size ( ) ) { cout << result [ i ] ; i ++ ; } }
void sumOfLargeNumbers ( string v [ ] , int k , int N ) { vector < vector < int > > x ( 1000 ) ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { x [ i ] . push_back ( v [ i ] [ j ] - '0' ) ; } } int carry = 0 ; vector < int > result ; for ( int i = N - 1 ; i >= 0 ; i -- ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += x [ j ] [ i ] ; sum += carry ; int temp = sum ; int count = 0 ; while ( temp > 9 ) { temp = temp % 10 ; count ++ ; } long long int l = pow ( 10 , count ) ; if ( l != 1 ) carry = ( double ) sum / l ; sum = sum % 10 ; result . push_back ( sum ) ; } while ( carry != 0 ) { int a = carry % 10 ; result . push_back ( a ) ; carry = carry / 10 ; } printResult ( result ) ; }
void printRev ( string str ) { stack < string > st ; stringstream ss ( str ) ; string temp ; while ( getline ( ss , temp , ' ' ) ) { st . push ( temp ) ; } while ( ! st . empty ( ) ) { cout << st . top ( ) << " " ; st . pop ( ) ; } }
void printLeaves ( int preorder [ ] , int n ) { int i = 0 ; isLeaf ( preorder , i , n , INT_MIN , INT_MAX ) ; }
int min_cost ( string S ) { int cost = 0 ; int F = 0 ; int B = 0 ; int count = 0 ; for ( char c : S ) if ( c == ' ' ) count ++ ; int n = S . size ( ) - count ; if ( n == 1 ) return cost ; for ( char in : S ) { if ( in != ' ' ) { if ( B != 0 ) { cost += min ( n - F , F ) * B ; B = 0 ; } F += 1 ; } else { B += 1 ; } } return cost ; }
int findPermutations ( int n ) { int sum = 0 , P ; for ( int r = 1 ; r <= n ; r ++ ) { P = permute ( n , r ) ; sum = sum + P ; } return sum ; }
unsigned long int countOfString ( int N ) { unsigned long int Stotal = pow ( 2 , N ) ; unsigned long int Sequal = 0 ; if ( N % 2 == 0 ) Sequal = binomialCoeff ( N , N / 2 ) ; unsigned long int S1 = ( Stotal - Sequal ) / 2 ; return S1 ; }
bool check ( string s ) { set < char > a ; for ( auto i : s ) { if ( a . count ( i ) ) return false ; a . insert ( i ) ; } return true ; }
int binExp ( int base , int power ) { int x = 1 ; while ( power ) { if ( power % 2 == 1 ) x = ( ( x % mod ) * ( base % mod ) ) % mod ; base = ( ( base % mod ) * ( base % mod ) ) % mod ; power = power / 2 ; } return x ; }
int fact ( int num ) { int result = 1 ; for ( int i = 1 ; i <= num ; ++ i ) { result = ( ( result % mod ) * ( i % mod ) ) % mod ; } return result ; }
int calculate_nCi ( int N , int i ) { int nfact = fact ( N ) ; int ifact = fact ( i ) ; int dfact = fact ( N - i ) ; int inv_ifact = binExp ( ifact , mod - 2 ) ; int inv_dfact = binExp ( dfact , mod - 2 ) ; int denm = ( ( inv_ifact % mod ) * ( inv_dfact % mod ) ) % mod ; int answer = ( ( nfact % mod ) * ( denm % mod ) ) % mod ; return answer ; }
void countSubstring ( int N , int s , int k ) { int allWays = binExp ( 26 , N ) ; int noWays = 0 ; for ( int i = 0 ; i < s ; ++ i ) { int nCi = calculate_nCi ( N , i ) ; int remaining = binExp ( 25 , N - i ) ; int multiply = ( ( nCi % mod ) * ( remaining % mod ) ) % mod ; noWays = ( ( noWays % mod ) + ( multiply % mod ) ) % mod ; } int answer = ( ( allWays % mod ) - ( noWays % mod ) ) % mod ; if ( answer < 0 ) answer += mod ; cout << answer ; }
int is_rtol ( string s ) { int tmp = sqrt ( s . length ( ) ) - 1 ; char first = s [ tmp ] ; for ( int pos = tmp ; pos < s . length ( ) - 1 ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } } return true ; }
bool isSpecial ( char c , vector < char > & special ) { for ( auto & i : special ) if ( i == c ) return true ; return false ; }
double countRatio ( string & s , vector < char > & special ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { prefix [ i ] = int ( isSpecial ( s [ i ] , special ) ) ; if ( i > 0 ) prefix [ i ] += prefix [ i - 1 ] ; } for ( int i = 0 ; i < n ; i ++ ) { sum [ i ] = prefix [ i ] ; if ( i > 0 ) sum [ i ] += sum [ i - 1 ] ; } double ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int count = sum [ n - 1 ] - ( i > 1 ? sum [ i - 2 ] : 0 ) ; count -= ( i < n ? sum [ n - i - 1 ] : 0 ) ; ans += double ( count ) / double ( i ) ; } return ans ; }
bool isVowel ( char ch ) { if ( ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u' ) return true ; else return false ; }
int minCost ( string S ) { int cA = 0 ; int cE = 0 ; int cI = 0 ; int cO = 0 ; int cU = 0 ; for ( int i = 0 ; i < S . size ( ) ; i ++ ) { if ( isVowel ( S [ i ] ) ) { cA += abs ( S [ i ] - 'a' ) ; cE += abs ( S [ i ] - 'e' ) ; cI += abs ( S [ i ] - 'i' ) ; cO += abs ( S [ i ] - 'o' ) ; cU += abs ( S [ i ] - 'u' ) ; } } return min ( min ( min ( min ( cA , cE ) , cI ) , cO ) , cU ) ; }
bool isPalindrome ( string str ) { int l = 0 ; int h = str . size ( ) - 1 ; while ( h > l ) { if ( str [ l ++ ] != str [ h -- ] ) { return false ; } } return true ; }
string makeOddString ( string str ) { string odd = "" ; for ( int i = 1 ; i < str . size ( ) ; i += 2 ) { odd += str [ i ] ; } return odd ; }
string makeevenString ( string str ) { string even = "" ; for ( int i = 0 ; i < str . size ( ) ; i += 2 ) { even += str [ i ] ; } return even ; }
void checkevenOddPalindrome ( string str ) { string odd = makeOddString ( str ) ; string even = makeevenString ( str ) ; if ( isPalindrome ( odd ) && isPalindrome ( even ) ) cout << "Yes" << endl ; else cout << "No" << endl ; }
bool inRange ( int hh , int mm , int L , int R ) { int a = abs ( hh - mm ) ; if ( a < L a > R ) return false ; return true ; } void displayTime ( int hh , int mm ) { if ( hh > 10 ) cout << hh << ":" ; else if ( hh < 10 ) cout << "0" << hh << ":" ; if ( mm > 10 ) cout << mm << endl ; else if ( mm < 10 ) cout << "0" << mm << endl ; } void maximumTimeWithDifferenceInRange ( string str , int L , int R ) { int i , j ; int h1 , h2 , m1 , m2 ; for ( i = 23 ; i >= 0 ; i -- ) { h1 = i % 10 ; h2 = i / 10 ; if ( ! isValid ( h1 + '0' , h2 + '0' , str , 1 ) ) { continue ; } for ( j = 59 ; j >= 0 ; j -- ) { m1 = j % 10 ; m2 = j / 10 ; if ( ! isValid ( m1 + '0' , m2 + '0' , str , 0 ) ) { continue ; } if ( inRange ( i , j , L , R ) ) { displayTime ( i , j ) ; return ; } } } if ( inRange ( i , j , L , R ) ) displayTime ( i , j ) ; else cout << "-1" << endl ; } int main ( ) { string timeValue = "??:??"  ; int L = 20 , R = 39 ; maximumTimeWithDifferenceInRange ( timeValue , L , R ) ; return 0 ; }
void firstNonRepElement ( string str ) { map < char , int > mpp ; for ( auto i : str ) { mpp [ i ] ++ ; } for ( auto i : str ) { if ( mpp [ i ] == 1 ) { cout << i << endl ; return ; } } return ; }
string makeOddString ( string str ) { string odd = "" ; for ( int i = 1 ; i < str . size ( ) ; i += 2 ) { odd += str [ i ] ; } return odd ; }
void checkOddlyPalindrome ( string str ) { string odd = makeOddString ( str ) ; if ( isPalindrome ( odd ) ) cout << "Yes" << endl ; else cout << "No" << endl ; }
void decrypt ( string Str , int Start , int End ) { if ( Start > End ) { return ; } int mid = ( Start + End ) >> 1 ; cout << Str [ mid ] ; decrypt ( Str , mid + 1 , End ) ; decrypt ( Str , Start , mid - 1 ) ; }
bool isSuffix ( string s1 , string s2 ) { int n1 = s1 . length ( ) ; int n2 = s2 . length ( ) ; if ( n1 > n2 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; }
bool CheckBinaryEquivalent ( int N , string str ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; int c = pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } string bin = to_string ( B_Number ) ; return isSuffix ( str , bin ) ; }
void decode_String ( string str , int K ) { string ans = "" ; for ( int i = 0 ; i < str . size ( ) ; i += K ) ans += str [ i ] ; for ( int i = str . size ( ) - ( K - 1 ) ; i < str . size ( ) ; i ++ ) ans += str [ i ] ; cout << ans << endl ; }
bool check ( string str , int K ) { if ( str . size ( ) % K == 0 ) { int sum = 0 , i ; for ( i = 0 ; i < K ; i ++ ) { sum += str [ i ] ; } for ( int j = i ; j < str . size ( ) ; j += K ) { int s_comp = 0 ; for ( int p = j ; p < j + K ; p ++ ) s_comp += str [ p ] ; if ( s_comp != sum ) return false ; } return true ; } return false ; }
bool check ( string s , int n ) { stack < char > st ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! st . empty ( ) && st . top ( ) == s [ i ] ) st . pop ( ) ; else st . push ( s [ i ] ) ; } if ( st . empty ( ) ) { return true ; } else { return false ; } }
bool isPalindrome ( string str ) { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] != str [ len - i - 1 ] ) return false ; } return true ; }
bool isCompressablePalindrome ( string str ) { int len = str . length ( ) ; string compressed = "" ; compressed . push_back ( str [ 0 ] ) ; for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] != str [ i - 1 ] ) compressed . push_back ( str [ i ] ) ; } return isPalindrome ( compressed ) ; }
int CountTotal ( string & s ) { int ans = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { string temp = "" ; for ( int j = i ; j < n ; j ++ ) { temp += s [ j ] ; if ( isvalid ( temp ) ) ans += 1 ; } } return ans ; }
bool isvowel ( char ch ) { return ( ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u' ) ; }
void getTotCount ( int num ) { totCount = 1 ; firstCount = 1 ; int temp = 1 ; while ( ( num & temp ) == 0 ) { temp = temp << 1 ; totCount += 1 ; } firstCount = totCount ; temp = num >> totCount ; while ( temp != 0 ) { totCount += 1 ; temp = temp >> 1 ; } }
int flipBitsFromRightMostSetBit ( int num ) { getTotCount ( num ) ; int num1 = num ^ ( ( 1 << totCount ) - 1 ) ; num1 = num1 ^ ( ( 1 << firstCount ) - 1 ) ; return num1 ; }
bool isVowel ( char c ) { return ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) ; }
bool isValid ( string & s ) { int n = s . size ( ) ; if ( n == 1 ) return ( isVowel ( s [ 0 ] ) ) ; if ( isVowel ( s [ 0 ] ) == false ) return false ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] || ! isVowel ( s [ i ] ) ) return false ; } return true ; }
int findMaxLen ( string & s ) { int maxLen = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { string temp = "" ; for ( int j = i ; j < n ; j ++ ) { temp = temp + s [ j ] ; if ( isValid ( temp ) ) maxLen = max ( maxLen , ( j - i + 1 ) ) ; } } return maxLen ; }
int findMaxLen ( string & s ) { int maxLen = 0 ; int cur = 0 ; if ( isvowel ( s [ 0 ] ) ) cur = maxLen = 1 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( isvowel ( s [ i ] ) ) { if ( s [ i ] != s [ i - 1 ] ) cur += 1 ; else cur = 1 ; } else { cur = 0 ; } maxLen = max ( cur , maxLen ) ; } return maxLen ; }
unsigned long long power ( unsigned long long base , unsigned long long pow ) { unsigned long long res = 1 ; while ( pow > 0 ) { if ( pow & 1 ) res = ( res * base ) ; base = ( base * base ) ; pow >>= 1 ; } return res ; }
unsigned long long countNonPalindromicString ( unsigned long long n , unsigned long long m ) { unsigned long long total = power ( n , m ) ; unsigned long long palindrome = power ( n , m / 2 + m % 2 ) ; unsigned long long count = total - palindrome ; return count ; }
void BalancedNumber ( string s ) { int Leftsum = 0 ; int Rightsum = 0 ; for ( int i = 0 ; i < s . size ( ) / 2 ; i ++ ) { Leftsum += int ( s [ i ] - '0' ) ; Rightsum += int ( s [ s . size ( ) - 1 - i ] - '0' ) ; } if ( Leftsum == Rightsum ) cout << "Balanced" << endl ; else cout << "Not Balanced" << endl ; }
unsigned long long expo ( unsigned long long base , unsigned long long exponent ) { unsigned long long ans = 1 ; while ( exponent != 0 ) { if ( ( exponent & 1 ) == 1 ) { ans = ans * base ; ans = ans % mod ; } base = base * base ; base %= mod ; exponent >>= 1 ; } return ans % mod ; }
unsigned long long findCount ( unsigned long long N ) { unsigned long long ans = ( expo ( 26 , N ) - expo ( 5 , N ) - expo ( 21 , N ) ) % mod ; ans += mod ; ans %= mod ; return ans ; }
int countPalindromePermutation ( string s , int k ) { for ( int i = 0 ; i < k ; i ++ ) { freq [ s [ i ] - 97 ] ++ ; } int ans = 0 ; if ( checkPalindrome ( ) ) { ans ++ ; } int i = 0 , j = k ; while ( j < s . size ( ) ) { freq [ s [ i ++ ] - 97 ] -- ; freq [ s [ j ++ ] - 97 ] ++ ; if ( checkPalindrome ( ) ) { ans ++ ; } } return ans ; }
int minFlips ( string target ) { char curr = '1' ; int count = 0 ; for ( int i = 0 ; i < target . length ( ) ; i ++ ) { if ( target [ i ] == curr ) { count ++ ; curr = ( char ) ( 48 + ( curr + 1 ) % 2 ) ; } } return count ; }
int decompose ( vector < int > S ) { stack < int > s ; int N = S . size ( ) ; int ans = 0 ; int nix = INT_MAX ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( s . empty ( ) ) { s . push ( S [ i ] ) ; nix = S [ i ] ; } else { if ( S [ i ] < s . top ( ) ) { s . push ( S [ i ] ) ; nix = min ( nix , S [ i ] ) ; } else { int val = S [ i ] ; while ( ! s . empty ( ) && val >= s . top ( ) ) { s . pop ( ) ; } nix = min ( nix , S [ i ] ) ; s . push ( nix ) ; } } ans += s . size ( ) ; } return ans ; }
int maxSetBitCount ( string s , int k ) { int maxCount = 0 , n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( s [ i ] == '1' ) count ++ ; } maxCount = count ; for ( int i = k ; i < n ; i ++ ) { if ( s [ i - k ] == '1' ) count -- ; if ( s [ i ] == '1' ) count ++ ; maxCount = max ( maxCount , count ) ; } return maxCount ; }
string maxVowelSubString ( string str , int K ) { int N = str . length ( ) ; int pref [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == 'a' or str [ i ] == 'e' or str [ i ] == 'i' or str [ i ] == 'o' or str [ i ] == 'u' ) pref [ i ] = 1 ; else pref [ i ] = 0 ; if ( i ) pref [ i ] += pref [ i - 1 ] ; } int maxCount = pref [ K - 1 ] ; string res = str . substr ( 0 , K ) ; for ( int i = K ; i < N ; i ++ ) { int currCount = pref [ i ] - pref [ i - K ] ; if ( currCount > maxCount ) { maxCount = currCount ; res = str . substr ( i - K + 1 , K ) ; } else if ( currCount == maxCount ) { string temp = str . substr ( i - K + 1 , K ) ; if ( temp < res ) res = temp ; } } return res ; }
void miniOperToMakeAllEleEqual ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } if ( sum % n ) { cout << -1 ; return ; } int valueAfterDivision = sum / n ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( abs ( valueAfterDivision - arr [ i ] ) % k != 0 ) { cout << -1 ; return ; } count += abs ( valueAfterDivision - arr [ i ] ) / k ; } cout << count / 2 << endl ; }
void minOperations ( vector < int > a ) { int res = INT_MAX ; int N = a . size ( ) ; for ( int r = 0 ; r < 2 ; r ++ ) { int sum = 0 , ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( ( i + r ) % 2 ) { if ( sum <= 0 ) { ans += - sum + 1 ; sum = 1 ; } } else { if ( sum >= 0 ) { ans += sum + 1 ; sum = -1 ; } } } res = min ( res , ans ) ; } cout << res ; }
bool checkWord ( vector < vector < char > > & board , string & word , int index , int row , int col ) { if ( row < 0 || col < 0 || row >= board . size ( ) || col >= board [ 0 ] . size ( ) ) return false ; if ( board [ row ] [ col ] != word [ index ] ) return false ; else if ( index == word . size ( ) - 1 ) return true ; char temp = board [ row ] [ col ] ; board [ row ] [ col ] = '*' ; if ( checkWord ( board , word , index + 1 , row + 1 , col ) || checkWord ( board , word , index + 1 , row - 1 , col ) || checkWord ( board , word , index + 1 , row , col + 1 ) || checkWord ( board , word , index + 1 , row , col - 1 ) ) { board [ row ] [ col ] = temp ; return true ; } board [ row ] [ col ] = temp ; return false ; }
int count ( string N , int X , string subStr , int index , int n ) { if ( index == n ) return 0 ; string a = subStr + N [ index ] ; int b = 0 ; if ( stoll ( a ) % X == 0 ) b = 1 ; int m1 = count ( N , X , a , index + 1 , n ) ; int m2 = b + count ( N , X , "" , index + 1 , n ) ; return max ( m1 , m2 ) ; }
bool checkSuffix ( int A , int B ) { string s1 = to_string ( A ) ; string s2 = to_string ( B ) ; int n1 = s1 . length ( ) ; int n2 = s2 . length ( ) ; if ( n1 < n2 ) { return false ; } for ( int i = 0 ; i < n2 ; i ++ ) { if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) { return false ; } } return true ; }
void checkSuffix ( int A , int B ) { string s1 = to_string ( A ) ; string s2 = to_string ( B ) ; bool result ; result = boost :: algorithm :: ends_with ( s1 , s2 ) ; if ( result ) { cout << "Yes" ; } else { cout << "No" ; } }
bool checkSuffix ( int A , int B ) { int digit_B = log10 ( B ) + 1 ; A -= B ; return ( A % int ( pow ( 10 , digit_B ) ) ) ; }
bool check ( string s ) { bool ok = true ; for ( int i = 0 ; i + 1 < s . size ( ) ; ++ i ) ok &= ( abs ( s [ i ] - s [ i + 1 ] ) != 1 ) ; return ok ; }
int findMinLength ( string s ) { int n = s . size ( ) ; map < char , int > counts ; vector < int > indices ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == 'a' s [ i ] == 'e' s [ i ] == 'o' s [ i ] == 'i' s [ i ] == 'u' ) { counts [ s [ i ] ] ++ ; indices . push_back ( i ) ; } } if ( counts . size ( ) < 5 ) return -1 ; int flag1 = 0 , flag2 = 0 ; int i = 0 ; int j = indices . size ( ) - 1 ; while ( ( j - i ) >= 4 ) { if ( ! flag1 && counts [ s [ indices [ i ] ] ] > 1 ) { counts [ s [ indices [ i ] ] ] -- ; i ++ ; } else flag1 = 1 ; if ( ! flag2 && counts [ s [ indices [ j ] ] ] > 1 ) { counts [ s [ indices [ j ] ] ] -- ; j -- ; } else flag2 = 1 ; if ( flag1 && flag2 ) break ; } return ( indices [ j ] - indices [ i ] + 1 ) ; }
int get_index ( char ch ) { if ( ch == 'a' ) return 0 ; else if ( ch == 'e' ) return 1 ; else if ( ch == 'i' ) return 2 ; else if ( ch == 'o' ) return 3 ; else if ( ch == 'u' ) return 4 ; else return -1 ; }
int findMinLength ( string s ) { int n = s . size ( ) ; int ans = n + 1 ; int start = 0 ; int count [ 5 ] = { 0 } ; for ( int x = 0 ; x < n ; x ++ ) { int idx = get_index ( s [ x ] ) ; if ( idx != -1 ) { count [ idx ] ++ ; } int idx_start = get_index ( s [ start ] ) ; while ( idx_start == -1 count [ idx_start ] > 1 ) { if ( idx_start != -1 ) { count [ idx_start ] -- ; } start ++ ; if ( start < n ) idx_start = get_index ( s [ start ] ) ; } if ( count [ 0 ] > 0 && count [ 1 ] > 0 && count [ 2 ] > 0 && count [ 3 ] > 0 && count [ 4 ] > 0 ) { ans = min ( ans , x - start + 1 ) ; } } if ( ans == n + 1 ) return -1 ; return ans ; }
int count_min_length ( string s ) { int hash [ 26 ] ; int ans = INT_MAX ; for ( int i = 0 ; i < 26 ; i ++ ) hash [ i ] = -1 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( hash [ s [ i ] - 'a' ] == -1 ) hash [ s [ i ] - 'a' ] = i ; else { if ( hash [ s [ i ] - 'a' ] == i - 1 hash [ s [ i ] - 'a' ] == i - 2 ) return 0 ; ans = min ( ans , i - hash [ s [ i ] - 'a' ] - 1 ) ; hash [ s [ i ] - 'a' ] = i ; } } if ( ans == INT_MAX ) return -1 ; return ans ; }
int countStrings ( string s ) { int cnt = 0 ; for ( int i = 1 ; s [ i ] ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { cnt ++ ; } } return cnt ; }
void RemoveHTMLTags ( string s ) { const regex pattern ( "\\<.*?\\>" ) ; s = regex_replace ( s , pattern , "" ) ; cout << s ; return ; }
bool checkValidString ( string str ) { int freq [ 26 ] = { 0 } ; for ( int i = 0 ; str [ i ] ; i ++ ) { freq [ str [ i ] - 'a' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] != 0 ) { if ( freq [ i ] != i + 1 ) { return false ; } } } return true ; }
bool checkSemiprime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i , ++ cnt ; } } if ( num > 1 ) { ++ cnt ; } return cnt == 2 ; }
void makeCypherString ( int N ) { string semiPrime = "" ; string sumOfPrime = "" ; string str = to_string ( N ) ; if ( checkSemiprime ( N ) ) { for ( int i = 0 ; str [ i ] ; i ++ ) { if ( i & 1 ) { semiPrime += str [ i ] ; } else { semiPrime += char ( str [ i ] - '0' + 65 ) ; } } } if ( isPossibleSum ( N ) ) { for ( int i = 0 ; str [ i ] ; i ++ ) { if ( i & 1 ) { sumOfPrime += char ( str [ i ] - '0' + 65 ) ; } else { sumOfPrime += str [ i ] ; } } } if ( semiPrime + sumOfPrime == "" ) { cout << "-1" ; } else { cout << semiPrime + sumOfPrime ; } }
int modulo_by_26 ( string num ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num [ i ] - '0' ) % MOD ; return res ; }
string longestConsonantsSubsequence ( string str ) { string answer = "" ; int n = str . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( isConsonants ( str [ i ] ) ) { answer += str [ i ] ; } } return answer ; }
string generateTheString ( int n ) { string ans = "" ; if ( n % 2 ) { for ( int i = 0 ; i < min ( n , 24 ) ; i ++ ) { ans += ( char ) ( 'b' + i ) ; } if ( n > 24 ) { for ( int i = 0 ; i < ( n - 24 ) ; i ++ ) ans += 'a' ; } } else { for ( int i = 0 ; i < min ( n , 25 ) ; i ++ ) { ans += ( char ) ( 'b' + i ) ; } if ( n > 25 ) { for ( int i = 0 ; i < ( n - 25 ) ; i ++ ) ans += 'a' ; } } return ans ; }
void finalCoordinates ( int SX , int SY , string D ) { for ( int i = 0 ; i < D . length ( ) ; i ++ ) { if ( D [ i ] == 'N' ) SY += 1 ; else if ( D [ i ] == 'S' ) SY -= 1 ; else if ( D [ i ] == 'E' ) SX += 1 ; else SX -= 1 ; } string ans = '(' + to_string ( SX ) + ',' + to_string ( SY ) + ')' ; cout << ans << endl ; }
void shortestPalindrome ( string s ) { int abcd [ 26 ] = { 0 } ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) abcd [ s [ i ] - 97 ] = 1 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( abcd [ i ] == 1 ) cout << char ( i + 97 ) << " " ; } }
void contain ( int L , int U , int M ) { int count = 0 ; for ( int j = L ; j < U ; j ++ ) { set < string > num ; string str = to_string ( j ) ; num . insert ( str ) ; if ( j % M == 0 and num . find ( to_string ( M ) ) == num . end ( ) ) { count += 1 ; } } cout << count - 2 ; }
int MaxLength ( vector < string > v , int i , int m ) { if ( i >= m ) { return m - 1 ; } for ( int k = 0 ; k < 26 ; k ++ ) { char c = 'a' + k ; vector < string > v1 ; for ( int j = 0 ; j < v . size ( ) ; j ++ ) { if ( v [ j ] [ i ] == c ) { v1 . push_back ( v [ j ] ) ; } } if ( v1 . size ( ) >= 2 ) { max1 = max ( max1 , MaxLength ( v1 , i + 1 , m ) ) ; } else { max1 = max ( max1 , i - 1 ) ; } } return max1 ; }
void group_formed ( string S ) { int count = 1 ; for ( int i = 0 ; i < S . size ( ) - 1 ; i ++ ) { if ( S [ i ] != S [ i + 1 ] ) count += 1 ; } cout << ( count ) ; }
int value ( char x ) { return ( int ) ( x - 'a' ) ; }
void finalString ( string str ) { int x = 0 , y = 0 ; int left ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) x ++ ; else y ++ ; } if ( x > y ) left = 1 ; else left = 0 ; int length = n - 2 * min ( x , y ) ; for ( int i = 0 ; i < length ; i ++ ) { cout << left ; } }
int noOfDeletions ( string str , char k ) { int ans = 0 , cnt = 0 , pos = 0 ; while ( pos < str . length ( ) && str [ pos ] != k ) { pos ++ ; } int i = pos ; while ( i < str . length ( ) ) { while ( i < str . length ( ) && str [ i ] == k ) { i = i + 1 ; } ans = ans + cnt ; cnt = 0 ; while ( i < str . length ( ) && str [ i ] != k ) { i = i + 1 ; cnt = cnt + 1 ; } } return ans ; }
int GetDigitalRoot ( string str ) { if ( str . length ( ) == 1 ) { return str [ 0 ] - '0' ; } str = GetIndividulaDigitSum ( str , str . length ( ) ) ; return GetDigitalRoot ( str ) ; }
int val ( char c ) { if ( c >= '0' && c <= '9' ) return ( int ) c - '0' ; else return ( int ) c - 'A' + 10 ; }
int toDeci ( string str , int base ) { int len = str . size ( ) ; int power = 1 ; int num = 0 ; int i ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str [ i ] ) >= base ) { return -1 ; } num += val ( str [ i ] ) * power ; power = power * base ; } return num ; }
bool repeatingString ( string s , int n , int k ) { if ( n % k != 0 ) { return false ; } int frequency [ 123 ] ; for ( int i = 0 ; i < 123 ; i ++ ) { frequency [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { frequency [ s [ i ] ] ++ ; } int repeat = n / k ; for ( int i = 0 ; i < 123 ; i ++ ) { if ( frequency [ i ] % repeat != 0 ) { return false ; } } return true ; }
int longestPalindromic ( string str , int i , int j , int count ) { if ( i > j ) return count ; if ( i == j ) return ( count + 1 ) ; if ( str [ i ] == str [ j ] ) { count = longestPalindromic ( str , i + 1 , j - 1 , count + 2 ) ; return max ( count , max ( longestPalindromic ( str , i + 1 , j , 0 ) , longestPalindromic ( str , i , j - 1 , 0 ) ) ) ; } return max ( longestPalindromic ( str , i + 1 , j , 0 ) , longestPalindromic ( str , i , j - 1 , 0 ) ) ; }
int longest_palindromic_substr ( string str ) { return longestPalindromic ( str , 0 , str . length ( ) - 1 , 0 ) ; }
string removeOddFrequencyCharacters ( string s ) { unordered_map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { m [ s [ i ] ] ++ ; } string new_string = "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m [ s [ i ] ] & 1 ) continue ; new_string += s [ i ] ; } return new_string ; }
int LexicoLesserStrings ( string s ) { int count = 0 ; int len ; len = s . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) { count += ( s [ i ] - 'a' ) * pow ( 26 , len - i - 1 ) ; } return count ; }
int countString ( string S1 , string S2 ) { int countS1 , countS2 , totalString ; countS1 = LexicoLesserStrings ( S1 ) ; countS2 = LexicoLesserStrings ( S2 ) ; totalString = countS2 - countS1 - 1 ; return ( totalString < 0 ? 0 : totalString ) ; }
bool isVowel ( char x ) { x = tolower ( x ) ; return ( x == 'a' x == 'e' x == 'i' x == 'o' x == 'u' ) ; }
void MaxPrefix ( string s ) { map < char , int > Dict ; for ( char i : s ) { Dict [ i ] ++ ; } int minfrequency = INT_MAX ; for ( auto x : Dict ) { minfrequency = min ( minfrequency , x . second ) ; } int countminFrequency = 0 ; for ( auto x : Dict ) { if ( x . second == minfrequency ) countminFrequency += 1 ; } map < char , int > mapper ; int indi = 0 ; for ( char i : s ) { mapper [ i ] += 1 ; if ( mapper [ i ] > countminFrequency ) break ; indi += 1 ; } cout << ( s . substr ( 0 , indi ) ) ; }
unsigned long long countSubstr ( string & s , int k ) { int n = s . length ( ) ; int l = n - 1 ; int r = n - 1 ; int arr [ n ] ; int last_indexof1 = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) { arr [ i ] = i ; last_indexof1 = i ; } else { arr [ i ] = last_indexof1 ; } } unsigned long long no_of_substr = 0 ; for ( r = n - 1 ; r >= 0 ; r -- ) { l = r ; while ( l >= 0 && ( r - l + 1 ) <= 64 && stoull ( s . substr ( l , r - l + 1 ) , 0 , 2 ) < k ) { l -- ; } if ( r - l + 1 <= 64 ) no_of_substr += l + 1 ; else { no_of_substr += arr [ l + 1 ] + 1 ; } } return no_of_substr ; }
bool isPerfectCubeString ( string str ) { int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) sum += ( int ) str [ i ] ; long double cr = round ( cbrt ( sum ) ) ; return ( cr * cr * cr == sum ) ; }
int XorAscii ( string str , int len ) { int ans = int ( str [ 0 ] ) ; for ( int i = 1 ; i < len ; i ++ ) { ans = ( ans ^ ( int ( str [ i ] ) ) ) ; } return ans ; }
int countSticks ( string str ) { int cnt = 0 ; for ( int i = 0 ; str [ i ] ; i ++ ) { char ch = str [ i ] ; if ( ch >= 'A' && ch <= 'Z' ) { cnt += sticks [ ch - 'A' ] ; } else { cnt += number [ ch - '0' ] ; } } return cnt ; }
void count ( string str1 , string str2 ) { int c = 0 , j = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { if ( str2 . find ( str1 [ i ] ) >= 0 and j == str1 . find ( str1 [ i ] ) ) c += 1 ; j += 1 ; } cout << "No. of matching characters are: " << c / 2 ; }
int checkIfStartsWithCapital ( string str ) { if ( str [ 0 ] >= 'A' && str [ 0 ] <= 'Z' ) return 1 ; else return 0 ; }
int checkIfAllVowels ( string str ) { int hash [ 5 ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == 'A' str [ i ] == 'a' ) hash [ 0 ] = 1 ; else if ( str [ i ] == 'E' str [ i ] == 'e' ) hash [ 1 ] = 1 ; else if ( str [ i ] == 'I' str [ i ] == 'i' ) hash [ 2 ] = 1 ; else if ( str [ i ] == 'O' str [ i ] == 'o' ) hash [ 3 ] = 1 ; else if ( str [ i ] == 'U' str [ i ] == 'u' ) hash [ 4 ] = 1 ; } for ( int i = 0 ; i < 5 ; i ++ ) { if ( hash [ i ] == 0 ) { return 1 ; } } return 0 ; }
int countOfLetters ( string str ) { int letter = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) || ( str [ i ] >= 'a' && str [ i ] <= 'z' ) ) letter ++ ; } return letter ; }
int countOfNumbers ( string str ) { int number = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] >= '0' && str [ i ] <= '9' ) number ++ ; } return number ; }
int findNthOccur ( string str , char ch , int N ) { int occur = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ch ) { occur += 1 ; } if ( occur == N ) return i ; } return -1 ; }
void countSmaller ( string str ) { int n = str . length ( ) ; int arr [ 26 ] = { 0 } ; int ans [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { arr [ str [ i ] - 'a' ] ++ ; int ct = 0 ; for ( int j = 0 ; j < str [ i ] - 'a'  ; j ++ ) { ct += arr [ j ] ; } ans [ i ] = ct ; } for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << " " ; } }
void printValue ( char digit ) { switch ( digit ) { case '0' : cout << "Zero " ; break ; case '1' : cout << "One " ; break ; case '2' : cout << "Two " ; break ; case '3' : cout << "Three " ; break ; case '4' : cout << "Four " ; break ; case '5' : cout << "Five " ; break ; case '6' : cout << "Six " ; break ; case '7' : cout << "Seven " ; break ; case '8' : cout << "Eight " ; break ; case '9' : cout << "Nine " ; break ; } }
void printWord ( string N ) { int i , length = N . length ( ) ; for ( i = 0 ; i < length ; i ++ ) { printValue ( N [ i ] ) ; } }
int solve ( string X , string Y , int N , int K ) { int count [ N + 1 ] = { 0 } ; int sol = 0 ; count [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { count [ i ] = count [ i - 1 ] + abs ( X [ i - 1 ] - Y [ i - 1 ] ) ; } int j = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { while ( ( count [ i ] - count [ j ] ) > K ) { j ++ ; } sol = max ( sol , i - j ) ; } return sol ; }
int find ( int x ) { if ( x != parent [ x ] ) return parent [ x ] = find ( parent [ x ] ) ; return x ; }
void join ( int x , int y ) { int px = find ( x ) ; int pz = find ( y ) ; if ( px != pz ) { parent [ pz ] = px ; } }
bool convertible ( string s1 , string s2 ) { map < int , int > mp ; for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) { if ( mp . find ( s1 [ i ] - 'a' ) == mp . end ( ) ) { mp [ s1 [ i ] - 'a' ] = s2 [ i ] - 'a' ; } else { if ( mp [ s1 [ i ] - 'a' ] != s2 [ i ] - 'a' ) return false ; } } for ( auto it : mp ) { if ( it . first == it . second ) continue ; else { if ( find ( it . first ) == find ( it . second ) ) return false ; else join ( it . first , it . second ) ; } } return true ; }
void initialize ( ) { for ( int i = 0 ; i < 26 ; i ++ ) { parent [ i ] = i ; } }
double jaro_distance ( string s1 , string s2 ) { if ( s1 == s2 ) return 1.0 ; int len1 = s1 . length ( ) , len2 = s2 . length ( ) ; int max_dist = floor ( max ( len1 , len2 ) / 2 ) - 1 ; int match = 0 ; int hash_s1 [ s1 . length ( ) ] = { 0 } , hash_s2 [ s2 . length ( ) ] = { 0 } ; for ( int i = 0 ; i < len1 ; i ++ ) { for ( int j = max ( 0 , i - max_dist ) ; j < min ( len2 , i + max_dist + 1 ) ; j ++ ) if ( s1 [ i ] == s2 [ j ] && hash_s2 [ j ] == 0 ) { hash_s1 [ i ] = 1 ; hash_s2 [ j ] = 1 ; match ++ ; break ; } } if ( match == 0 ) return 0.0 ; double t = 0 ; int point = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) if ( hash_s1 [ i ] ) { while ( hash_s2 [ point ] == 0 ) point ++ ; if ( s1 [ i ] != s2 [ point ++ ] ) t ++ ; } t /= 2 ; return ( ( ( double ) match ) / ( ( double ) len1 ) + ( ( double ) match ) / ( ( double ) len2 ) + ( ( double ) match - t ) / ( ( double ) match ) ) / 3.0 ; }
double jaro_distance ( string s1 , string s2 ) { if ( s1 == s2 ) return 1.0 ; int len1 = s1 . length ( ) , len2 = s2 . length ( ) ; if ( len1 == 0 len2 == 0 ) return 0.0 ; int max_dist = floor ( max ( len1 , len2 ) / 2 ) - 1 ; int match = 0 ; int hash_s1 [ s1 . length ( ) ] = { 0 } , hash_s2 [ s2 . length ( ) ] = { 0 } ; for ( int i = 0 ; i < len1 ; i ++ ) { for ( int j = max ( 0 , i - max_dist ) ; j < min ( len2 , i + max_dist + 1 ) ; j ++ ) if ( s1 [ i ] == s2 [ j ] && hash_s2 [ j ] == 0 ) { hash_s1 [ i ] = 1 ; hash_s2 [ j ] = 1 ; match ++ ; break ; } } if ( match == 0 ) return 0.0 ; double t = 0 ; int point = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) if ( hash_s1 [ i ] ) { while ( hash_s2 [ point ] == 0 ) point ++ ; if ( s1 [ i ] != s2 [ point ++ ] ) t ++ ; } t /= 2 ; return ( ( ( double ) match ) / ( ( double ) len1 ) + ( ( double ) match ) / ( ( double ) len2 ) + ( ( double ) match - t ) / ( ( double ) match ) ) / 3.0 ; }
double jaro_Winkler ( string s1 , string s2 ) { double jaro_dist = jaro_distance ( s1 , s2 ) ; if ( jaro_dist > 0.7 ) { int prefix = 0 ; for ( int i = 0 ; i < min ( s1 . length ( ) , s2 . length ( ) ) ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) prefix ++ ; else break ; } prefix = min ( 4 , prefix ) ; jaro_dist += 0.1 * prefix * ( 1 - jaro_dist ) ; } return jaro_dist ; }
bool isWordPresent ( string sentence , string word ) { stringstream s ( sentence ) ; string temp ; while ( s >> temp ) { if ( temp . compare ( word ) == 0 ) { return true ; } } return false ; }
string canMake ( string & s ) { int o = 0 , z = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] - '0' == 1 ) o ++ ; else z ++ ; } if ( o % 2 == 1 && z % 2 == 1 ) return "NO" ; else return "YES" ; }
int countChars ( string str , int n ) { int i = 0 , cnt = 0 ; while ( i < n ) { if ( str [ i ] == '0' ) i ++ ; else i += 2 ; cnt ++ ; } return cnt ; }
int findMinSwaps ( string s , int k ) { int ans = 0 ; int c_one = 0 , c_zero = 0 ; for ( int i = s . size ( ) - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) c_one ++ ; if ( s [ i ] == '0' ) c_zero ++ , ans += c_one ; if ( c_zero == k ) break ; } if ( c_zero < k ) return -1 ; return ans ; }
bool checkvowel ( char ch ) { ch = tolower ( ch ) ; if ( ch == 'a' ch == 'e' ch == 'i' ch == 'o' ch == 'u' ) { return true ; } else { return false ; } }
void decBinary ( int arr [ ] , int n ) { int k = log2 ( n ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } }
int concat ( int m , int n ) { int k = log2 ( m ) + 1 ; int l = log2 ( n ) + 1 ; int a [ k ] = { 0 } , b [ l ] = { 0 } ; int c [ k + l ] = { 0 } ; decBinary ( a , m ) ; decBinary ( b , n ) ; int in = 0 ; for ( int i = 0 ; i < k ; i ++ ) c [ in ++ ] = a [ i ] ; for ( int i = 0 ; i < l ; i ++ ) c [ in ++ ] = b [ i ] ; return ( binaryDec ( c , k + l ) ) ; }
int getBinaryLength ( int n ) { int length = 0 ; while ( n > 0 ) { length += 1 ; n /= 2 ; } return length ; }
int concat ( int m , int n ) { int length = getBinaryLength ( n ) ; return ( m << length ) + n ; }
int countSubStr ( string str , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) ans += ( i + 1 ) ; } return ans ; }
string largestSubStr ( string s ) { while ( s . size ( ) and s [ s . size ( ) - 1 ] == '1' ) s . pop_back ( ) ; if ( s . size ( ) == 0 ) return "-1" ; else return s ; }
bool areEqual ( int * a , int * b ) { for ( int i = 0 ; i < MAX ; i ++ ) if ( a [ i ] != b [ i ] ) return false ; return true ; }
string reverseParentheses ( string str , int len ) { stack < int > st ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '(' ) { st . push ( i ) ; } else if ( str [ i ] == ')' ) { reverse ( str . begin ( ) + st . top ( ) + 1 , str . begin ( ) + i ) ; st . pop ( ) ; } } string res = "" ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] != ')' && str [ i ] != '(' ) res += ( str [ i ] ) ; } return res ; }
int maxCount ( string str , string patt ) { int strFreq [ MAX ] = { 0 } ; updateFreq ( str , strFreq ) ; int pattFreq [ MAX ] = { 0 } ; updateFreq ( patt , pattFreq ) ; int ans = INT_MAX ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( pattFreq [ i ] == 0 ) continue ; ans = min ( ans , strFreq [ i ] / pattFreq [ i ] ) ; } return ans ; }
int minNum ( string str , int len ) { int res = INT_MAX ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '4' str [ i ] == '8' ) { res = min ( res , str [ i ] - '0' ) ; } } for ( int i = 0 ; i < len - 1 ; i ++ ) { for ( int j = i + 1 ; j < len ; j ++ ) { int num = ( str [ i ] - '0' ) * TEN + ( str [ j ] - '0' ) ; if ( num % 4 == 0 ) { res = min ( res , num ) ; } } } return ( ( res == INT_MAX ) ? -1 : res ) ; }
int minOperation ( string str , int len ) { int first [ MAX ] , last [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { first [ i ] = -1 ; last [ i ] = -1 ; } for ( int i = 0 ; i < len ; i ++ ) { int index = ( str [ i ] - 'a' ) ; if ( first [ index ] == -1 ) first [ index ] = i ; last [ index ] = i ; } int minOp = -1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] == -1 first [ i ] == last [ i ] ) continue ; int cnt = len - ( last [ i ] - first [ i ] + 1 ) ; if ( minOp == -1 cnt < minOp ) minOp = cnt ; } return minOp ; }
void findMidAlphabet ( string s1 , string s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int mid = ( s1 [ i ] + s2 [ i ] ) / 2 ; cout << ( char ) mid ; } }
int countVowels ( string str , int l , int r ) { int cnt = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( isVowel ( str [ i ] ) ) cnt ++ ; } return cnt ; }
int sumDigits ( int n ) { int sum = 0 ; while ( n > 0 ) { int digit = n % 10 ; sum += digit ; n /= 10 ; } return sum ; }
bool isDivBySix ( string str , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ( int ) ( str [ i ] - 'a' + 1 ) ; } if ( sum % 3 != 0 ) return false ; int lastDigit = ( ( int ) ( str [ n - 1 ] - 'a' + 1 ) ) % 10 ; if ( lastDigit % 2 != 0 ) return false ; return true ; }
int minLength ( string str , int len ) { stack < char > s ; for ( int i = 0 ; i < len ; i ++ ) { if ( s . empty ( ) ) { s . push ( str [ i ] ) ; } else { char c = s . top ( ) ; if ( c != str [ i ] && toupper ( c ) == toupper ( str [ i ] ) ) { s . pop ( ) ; } else { s . push ( str [ i ] ) ; } } } return s . size ( ) ; }
int cntSplits ( string s ) { if ( s [ s . size ( ) - 1 ] == '1' ) return 0 ; int c_zero = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) c_zero += ( s [ i ] == '0' ) ; return ( int ) pow ( 2 , c_zero - 1 ) ; }
bool isDivisible ( string s , int m ) { unordered_map < char , int > mp ; for ( int i = 0 ; i < DIGITS ; i ++ ) { mp [ CHARS [ i ] ] = i ; } int r = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { r = ( r * 16 + mp [ s [ i ] ] ) % m ; } if ( ! r ) return true ; return false ; }
bool isPalindrome ( float num ) { stringstream ss ; ss << num ; string s ; ss >> s ; int low = 0 ; int high = s . size ( ) - 1 ; while ( low < high ) { if ( s [ low ] != s [ high ] ) return false ; low ++ ; high -- ; } return true ; }
int maxSubStr ( string str1 , int len1 , string str2 , int len2 ) { if ( len1 > len2 ) return 0 ; int freq1 [ MAX ] = { 0 } ; for ( int i = 0 ; i < len1 ; i ++ ) freq1 [ str1 [ i ] - 'a' ] ++ ; int freq2 [ MAX ] = { 0 } ; for ( int i = 0 ; i < len2 ; i ++ ) freq2 [ str2 [ i ] - 'a' ] ++ ; int minPoss = INT_MAX ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq1 [ i ] == 0 ) continue ; if ( freq1 [ i ] > freq2 [ i ] ) return 0 ; minPoss = min ( minPoss , freq2 [ i ] / freq1 [ i ] ) ; } return minPoss ; }
int Count ( string s , int pos ) { int c = s [ pos - 1 ] ; int counter = 0 ; for ( int i = 0 ; i < pos - 1 ; i ++ ) { if ( s [ i ] == c ) counter = counter + 1 ; } return counter ; }
void findSubStr ( string str , int cnt , int start ) { if ( start == str . length ( ) ) { minCnt = min ( cnt , minCnt ) ; } for ( int len = 1 ; len <= ( str . length ( ) - start ) ; len ++ ) { string subStr = str . substr ( start , len ) ; if ( uSet . find ( subStr ) != uSet . end ( ) ) { findSubStr ( str , cnt + 1 , start + len ) ; } } }
int getMod ( string str , int n , int k ) { int pwrTwo [ n ] ; pwrTwo [ 0 ] = 1 % k ; for ( int i = 1 ; i < n ; i ++ ) { pwrTwo [ i ] = pwrTwo [ i - 1 ] * ( 2 % k ) ; pwrTwo [ i ] %= k ; } int res = 0 ; int i = 0 , j = n - 1 ; while ( i < n ) { if ( str [ j ] == '1' ) { res += ( pwrTwo [ i ] ) ; res %= k ; } i ++ ; j -- ; } return res ; }
long countStrings ( long N ) { long dp [ N + 1 ] [ 3 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; dp [ 1 ] [ 2 ] = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; } long ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; }
int getCount ( string str , int n ) { int cnt = 0 ; int i = 0 ; while ( i < n - 2 ) { if ( str [ i ] == str [ i + 1 ] && str [ i ] == str [ i + 2 ] ) { cnt ++ ; i = i + 2 ; } else i ++ ; } return cnt ; }
string maxNumber ( string str , int n ) { int freq [ 2 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == 'z' ) { freq [ 0 ] ++ ; } else if ( str [ i ] == 'n' ) { freq [ 1 ] ++ ; } } string num = "" ; for ( int i = 0 ; i < freq [ 1 ] ; i ++ ) num += '1' ; for ( int i = 0 ; i < freq [ 0 ] ; i ++ ) num += '0' ; return num ; }
int fact ( int n ) { int fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact *= i ; return fact ; }
int countStrings ( string str , int n ) { set < char > distinct_char ; for ( int i = 0 ; i < n ; i ++ ) { distinct_char . insert ( str [ i ] ) ; } return fact ( distinct_char . size ( ) ) ; }
char getChar ( string str ) { int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { sum += ( str [ i ] - 'a' + 1 ) ; } if ( sum % 26 == 0 ) return 'z' ; else { sum = sum % 26 ; return ( char ) ( 'a' + sum - 1 ) ; } }
int countFreq ( string & pat , string & txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int res = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { res ++ ; j = 0 ; } } return res ; }
void findOccurrence ( int arr [ ] , int n , string pattern ) { for ( int i = 0 ; i < n ; i ++ ) { string binary = decToBinary ( arr [ i ] ) ; cout << countFreq ( pattern , binary ) << " " ; } }
void findNumbers ( string s ) { if ( s . empty ( ) ) return 0 ; int n = s . size ( ) ; int count = 1 ; int result = 0 ; int left = 0 ; int right = 1 ; while ( right < n ) { if ( s [ left ] == s [ right ] ) { count ++ ; } else { result += count * ( count + 1 ) / 2 ; left = right ; count = 1 ; } right ++ ; } result += count * ( count + 1 ) / 2 ; cout << result << endl ; }
void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
bool canBeBalanced ( string s , int n ) { if ( n % 2 == 1 ) return false ; string k = "(" ; k += s + ")" ; vector < string > d ; int cnt = 0 ; for ( int i = 0 ; i < k . length ( ) ; i ++ ) { if ( k [ i ] == '(' ) d . push_back ( "(" ) ; else { if ( d . size ( ) != 0 ) d . pop_back ( ) ; else return false ; } } if ( d . empty ( ) ) return true ; return false ; }
int maxLenSubStr ( string & s ) { if ( s . length ( ) < 3 ) return s . length ( ) ; int temp = 2 ; int ans = 2 ; for ( int i = 2 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != s [ i - 1 ] s [ i ] != s [ i - 2 ] ) temp ++ ; else { ans = max ( temp , ans ) ; temp = 2 ; } } ans = max ( temp , ans ) ; return ans ; }
bool CompareAlphanumeric ( string & str1 , string & str2 ) { int i , j ; i = 0 ; j = 0 ; int len1 = str1 . size ( ) ; int len2 = str2 . size ( ) ; while ( i <= len1 && j <= len2 ) { while ( i < len1 && ( ! ( ( str1 [ i ] >= 'a' && str1 [ i ] <= 'z' ) || ( str1 [ i ] >= 'A' && str1 [ i ] <= 'Z' ) || ( str1 [ i ] >= '0' && str1 [ i ] <= '9' ) ) ) ) { i ++ ; } while ( j < len2 && ( ! ( ( str2 [ j ] >= 'a' && str2 [ j ] <= 'z' ) || ( str2 [ j ] >= 'A' && str2 [ j ] <= 'Z' ) || ( str2 [ j ] >= '0' && str2 [ j ] <= '9' ) ) ) ) { j ++ ; } if ( i == len1 && j == len2 ) return true ; else if ( str1 [ i ] != str2 [ j ] ) return false ; else { i ++ ; j ++ ; } } return false ; }
void expandString ( string strin ) { string temp = "" ; int j ; for ( int i = 0 ; i < strin . length ( ) ; i ++ ) { if ( strin [ i ] >= 0 ) { int num = strin [ i ] - '0' ; if ( strin [ i + 1 ] == '(' ) { for ( j = i + 1 ; strin [ j ] != ')' ; j ++ ) { if ( ( strin [ j ] >= 'a' && strin [ j ] <= 'z' ) || ( strin [ j ] >= 'A' && strin [ j ] <= 'Z' ) ) { temp += strin [ j ] ; } } for ( int k = 1 ; k <= num ; k ++ ) { cout << ( temp ) ; } num = 0 ; temp = "" ; if ( j < strin . length ( ) ) { i = j ; } } } } }
int countSubStr ( string s , int n ) { int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . substr ( i , 5 ) == "geeks" ) c1 ++ ; if ( s . substr ( i , 3 ) == "for" ) c2 = c2 + c1 ; } return c2 ; }
bool isVowel ( char ch ) { ch = toupper ( ch ) ; return ( ch == 'A' ch == 'E' ch == 'I' ch == 'O' ch == 'U' ) ; }
string balancedBrackets ( string str ) { int dep = 0 ; int minDep = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == '(' ) dep ++ ; else dep -- ; if ( minDep > dep ) minDep = dep ; } if ( minDep < 0 ) { for ( int i = 0 ; i < abs ( minDep ) ; i ++ ) str = '(' + str ; } dep = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == '(' ) dep ++ ; else dep -- ; } if ( dep != 0 ) { for ( int i = 0 ; i < dep ; i ++ ) str = str + ')' ; } return str ; }
int minOperations ( string str , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] != str [ i + 1 ] ) count ++ ; } return ( count + 1 ) / 2 ; }
int stringToInt ( string str ) { if ( str . length ( ) == 1 ) return ( str [ 0 ] - '0' ) ; double y = stringToInt ( str . substr ( 1 ) ) ; double x = str [ 0 ] - '0' ; x = x * pow ( 10 , str . length ( ) - 1 ) + y ; return int ( x ) ; }
int largestSubSeq ( string arr [ ] , int n ) { int count [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { string str = arr [ i ] ; bool hash [ MAX ] = { 0 } ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { hash [ str [ j ] - 'a' ] = true ; } for ( int j = 0 ; j < MAX ; j ++ ) { if ( hash [ j ] ) count [ j ] ++ ; } } return * ( max_element ( count , count + MAX ) ) ; }
int longest_substring ( string s , int k ) { int n = s . size ( ) ; if ( k > 1 ) { s += s ; n *= 2 ; } int ans = 0 ; int i = 0 ; while ( i < n ) { int x = 0 ; while ( s [ i ] == '0' && i < n ) x ++ , i ++ ; ans = max ( ans , x ) ; i ++ ; } if ( k == 1 or ans != n ) return ans ; else return ( ans / 2 ) * k ; }
int Occurrence ( string s , int position ) { int count = 0 ; for ( int i = 0 ; i < position - 1 ; i ++ ) if ( s [ i ] == s [ position - 1 ] ) count ++ ; return count ; }
int countOccurrence ( string s , int position ) { int alpha [ 26 ] = { 0 } , b [ s . size ( ) ] = { 0 } ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { b [ i ] = alpha [ ( int ) s [ i ] - 97 ] ; alpha [ ( int ) s [ i ] - 97 ] ++ ; } return b [ position - 1 ] ; }
void find_permutation ( string & str1 , string & str2 , int len1 , int len2 , int i , int j , string res ) { if ( res . length ( ) == len1 + len2 ) { stringSet . insert ( res ) ; return ; } if ( i < len1 ) find_permutation ( str1 , str2 , len1 , len2 , i + 1 , j , res + str1 [ i ] ) ; if ( j < len2 ) find_permutation ( str1 , str2 , len1 , len2 , i , j + 1 , res + str2 [ j ] ) ; }
bool canConvert ( string str1 , string str2 ) { int i = 0 , j = 0 ; while ( i < str1 . size ( ) && j < str2 . size ( ) ) { if ( str1 [ i ] != str2 [ j ] ) { if ( str1 [ i ] == '0' && str2 [ j ] == '1' && i + 1 < str1 . size ( ) && str1 [ i + 1 ] == '0' ) { i += 2 ; j ++ ; } else { return false ; } } else { i ++ ; j ++ ; } } if ( i == str1 . size ( ) && j == str2 . size ( ) ) return true ; return false ; }
void reverse ( string s ) { stack < string > stc ; string temp = "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ' ) { stc . push ( temp ) ; temp = "" ; } else { temp = temp + s [ i ] ; } } stc . push ( temp ) ; while ( ! stc . empty ( ) ) { temp = stc . top ( ) ; cout << temp << " " ; stc . pop ( ) ; } cout << endl ; }
int countPairs ( string str , int k ) { int n = str . size ( ) ; int freq [ MAX ] ; memset ( freq , 0 , sizeof freq ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - 'a' ] ++ ; int cnt = 0 ; if ( k == 0 ) { for ( int i = 0 ; i < MAX ; i ++ ) if ( freq [ i ] > 1 ) cnt += ( ( freq [ i ] * ( freq [ i ] - 1 ) ) / 2 ) ; } else { for ( int i = 0 ; i < MAX ; i ++ ) if ( freq [ i ] > 0 && i + k < MAX && freq [ i + k ] > 0 ) cnt += ( freq [ i ] * freq [ i + k ] ) ; ; } return cnt ; }
void printUncommon ( string str1 , string str2 ) { int a1 = 0 , a2 = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { int ch = int ( str1 [ i ] ) - 'a' ; a1 = a1 | ( 1 << ch ) ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { int ch = int ( str2 [ i ] ) - 'a' ; a2 = a2 | ( 1 << ch ) ; } int ans = a1 ^ a2 ; int i = 0 ; while ( i < 26 ) { if ( ans % 2 == 1 ) { cout << char ( 'a' + i ) ; } ans = ans / 2 ; i ++ ; } }
bool isPalin ( int i , int j , int k , int l , int p , int q , string s ) { int start = i , end = q ; while ( start < end ) { if ( s [ start ] != s [ end ] ) return false ; start ++ ; if ( start == j + 1 ) start = k ; end -- ; if ( end == p - 1 ) end = l ; } return true ; }
int countSubStr ( string s ) { int count = 0 ; int n = s . size ( ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k ; l < n - 1 ; l ++ ) { for ( int p = l + 1 ; p < n ; p ++ ) { for ( int q = p ; q < n ; q ++ ) { if ( isPalin ( i , j , k , l , p , q , s ) ) { count ++ ; } } } } } } } return count ; }
bool isPrime ( int n ) { if ( n == 0 n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int sumAscii ( string str , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime ( i + 1 ) ) sum += ( int ) ( str [ i ] ) ; } return sum ; }
bool Pangram ( string x ) { map < char , int > mp ; int n = x . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) mp [ x [ i ] ] ++ ; if ( mp . size ( ) == 26 ) return true ; else return false ; }
int countTotalPangram ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( Pangram ( weight [ i ] ) ) cnt ++ ; return cnt ; }
void dfs ( int node , int parent ) { for ( int to : graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; weight [ node ] += weight [ to ] ; } }
bool uniqueChars ( string x ) { map < char , int > mp ; int n = x . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) mp [ x [ i ] ] ++ ; if ( mp . size ( ) == x . size ( ) ) return true ; else return false ; }
void dfs ( int node , int parent ) { if ( uniqueChars ( weight [ node ] ) ) cnt += 1 ; for ( int to : graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; } }
void preCalculate ( string str , int n ) { freq [ ( int ) str [ 0 ] ] [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { char ch = str [ i ] ; for ( int j = 0 ; j < MAX ; j ++ ) { char charToUpdate = ( char ) j ; if ( charToUpdate == ch ) freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 ; else freq [ j ] [ i ] = freq [ j ] [ i - 1 ] ; } } }
int getFrequency ( char ch , int l , int r ) { if ( l == 0 ) return freq [ ( int ) ch ] [ r ] ; else return ( freq [ ( int ) ch ] [ r ] - freq [ ( int ) ch ] [ l - 1 ] ) ; }
bool isValid ( char s [ ] ) { char * p ; if ( ( p = strstr ( s , "geek" ) ) && ( strstr ( p + 4 , "keeg" ) ) ) return true ; return false ; }
bool isTwoAlter ( string s ) { for ( int i = 0 ; i < s . length ( ) - 2 ; i ++ ) { if ( s [ i ] != s [ i + 2 ] ) { return false ; } } if ( s [ 0 ] == s [ 1 ] ) return false ; return true ; }
int findCount ( string s , int n , int a , int b ) { int res = 0 ; for ( int i = 0 ; i < b ; i ++ ) { if ( i == a ) res += ( s [ n - i - 1 ] != '1' ) ; else res += ( s [ n - i - 1 ] != '0' ) ; } return res ; }
int lenoflongestnonpalindrome ( string s ) { int max1 = 1 , len = 0 ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) len = 0 ; else if ( s [ i + 1 ] == s [ i - 1 ] && i > 0 ) len = 1 ; len ++ ; } if ( max1 == 1 ) return 0 ; else return max1 ; }
int calcScore ( string str ) { int score = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; ) { int chunkSize = 1 ; char currentChar = str [ i ++ ] ; while ( i < len && str [ i ] == currentChar ) { chunkSize ++ ; i ++ ; } if ( currentChar == '1' ) score += pow ( chunkSize , 2 ) ; else score -= pow ( chunkSize , 2 ) ; } return score ; }
void pre_process ( vector < string > & substrings , string s ) { int n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { string dup = "" ; for ( int j = i ; j < n ; j ++ ) { dup += s [ j ] ; substrings . push_back ( dup ) ; } } sort ( substrings . begin ( ) , substrings . end ( ) ) ; }
bool check ( string s ) { int n = s . size ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) return true ; } return false ; }
int countSubString ( string s , char c , int k ) { int leftCount = 0 , rightCount = 0 ; int left = 0 , right = 0 ; int freq = 0 ; int result = 0 , len = s . length ( ) ; while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } right = left + 1 ; while ( freq != ( k - 1 ) && ( right - 1 ) < len ) { if ( s [ right ] == c ) freq ++ ; right ++ ; } while ( left < len && ( right - 1 ) < len ) { while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } while ( right < len && s [ right ] != c ) { if ( s [ right ] == c ) freq ++ ; right ++ ; rightCount ++ ; } result = result + ( leftCount + 1 ) * ( rightCount + 1 ) ; freq = k - 1 ; leftCount = 0 ; rightCount = 0 ; left ++ ; right ++ ; } return result ; }
int performQueries ( int l , int r , int prefix [ N ] [ 26 ] ) { l -- ; r -- ; bool flag = false ; int count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { int cnt = prefix [ r ] [ i ] ; if ( l > 0 ) cnt -= prefix [ l - 1 ] [ i ] ; if ( cnt % 2 == 1 ) { flag = true ; count += cnt - 1 ; } else count += cnt ; } if ( flag ) count += 1 ; return count ; }
void printSmallSub ( int arr [ ] , int N ) { int gcdArr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { gcdArr = __gcd ( gcdArr , arr [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == gcdArr ) { cout << arr [ i ] << " " ; return ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( __gcd ( arr [ i ] , arr [ j ] ) == gcdArr ) { cout << arr [ i ] << " " << arr [ j ] ; return ; } } } }
int countSubStr ( string str , int n , char x ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) { res += ( ( count + 1 ) * ( n - i ) ) ; count = 0 ; } else count ++ ; } return res ; }
bool isValid ( string str , int n ) { if ( ! ( ( str [ 0 ] >= 'a' && str [ 0 ] <= 'z' ) || ( str [ 0 ] >= 'A' && str [ 0 ] <= 'Z' ) str [ 0 ] == '_' ) ) return false ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( ! ( ( str [ i ] >= 'a' && str [ i ] <= 'z' ) || ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) || ( str [ i ] >= '0' && str [ i ] <= '9' ) str [ i ] == '_' ) ) return false ; } return true ; }
int countSubStr ( string str , int n ) { int len = str . length ( ) ; return ( len - n + 1 ) ; }
int countSubstrings ( string s , char c ) { int n = s . length ( ) ; int cnt = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != c ) cnt ++ ; else { sum += ( cnt * ( cnt + 1 ) ) / 2 ; cnt = 0 ; } } sum += ( cnt * ( cnt + 1 ) ) / 2 ; return sum ; }
bool equalIgnoreCase ( string str1 , string str2 ) { int i = 0 ; transform ( str1 . begin ( ) , str1 . end ( ) , str1 . begin ( ) , :: toupper ) ; transform ( str2 . begin ( ) , str2 . end ( ) , str2 . begin ( ) , :: toupper ) ; int x = str1 . compare ( str2 ) ; if ( x != 0 ) return false ; else return true ; }
void equalIgnoreCaseUtil ( string str1 , string str2 ) { bool res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) cout << "Same" << endl ; else cout << "Not Same" << endl ; }
bool equalIgnoreCase ( string str1 , string str2 ) { int i = 0 ; transform ( str1 . begin ( ) , str1 . end ( ) , str1 . begin ( ) , :: tolower ) ; transform ( str2 . begin ( ) , str2 . end ( ) , str2 . begin ( ) , :: tolower ) ; int x = str1 . compare ( str2 ) ; if ( x != 0 ) return false ; else return true ; }
void equalIgnoreCaseUtil ( string str1 , string str2 ) { bool res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) cout << "Same" << endl ; else cout << "Not Same" << endl ; }
int findM ( string s , int x ) { int cnt = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] - '0' != x ) cnt ++ ; } return cnt ; }
void FirstAndLast ( string str ) { int i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( i == 0 ) cout << str [ i ] ; if ( i == str . length ( ) - 1 ) cout << str [ i ] ; if ( str [ i ] == ' ' ) { cout << str [ i - 1 ] << " " << str [ i + 1 ] ; } } }
void Longestsubstring ( string s ) { vector < int > lps = compute_lps ( s ) ; int n = s . size ( ) ; if ( lps [ n - 1 ] == 0 ) { cout << -1 ; return ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( lps [ i ] == lps [ n - 1 ] ) { cout << s . substr ( 0 , lps [ i ] ) ; return ; } } if ( lps [ lps [ n - 1 ] - 1 ] == 0 ) cout << -1 ; else cout << s . substr ( 0 , lps [ lps [ n - 1 ] - 1 ] ) ; }
int getBitmask ( string s ) { int temp = 0 ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s [ j ] == 's' ) { temp = temp | ( 1 ) ; } else if ( s [ j ] == 't' ) { temp = temp | ( 2 ) ; } else if ( s [ j ] == 'r' ) { temp = temp | ( 4 ) ; } else if ( s [ j ] == 'i' ) { temp = temp | ( 8 ) ; } else if ( s [ j ] == 'n' ) { temp = temp | ( 16 ) ; } else if ( s [ j ] == 'g' ) { temp = temp | ( 32 ) ; } } return temp ; }
int calculateWays ( string s , int n , int l , int r ) { int freq [ 26 ] ; memset ( freq , 0 , sizeof freq ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < l i > r ) freq [ s [ i ] - 'a' ] ++ ; } int ways = 1  ; for ( int i = l ; i <= r ; i ++ ) { if ( freq [ s [ i ] - 'a' ] ) { ways = ways * freq [ s [ i ] - 'a' ] ; freq [ s [ i ] - 'a' ] -- ; } else { ways = 0 ; break ; } } return ways ; } int main ( ) { string s = "cabcaab" ; int n = s . length ( ) ; int l = 1 , r = 3 ; cout << calculateWays ( s , n , l , r ) ; return 0 ; }
void asciiToSentence ( string str , int len ) { int num = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = num * 10 + ( str [ i ] - '0' ) ; if ( num >= 32 && num <= 122 ) { char ch = ( char ) num ; cout << ch ; num = 0 ; } } }
int countDistinctCode ( string str ) { set < string > codes ; for ( int i = 0 ; i < str . length ( ) - 1 ; i ++ ) codes . insert ( str . substr ( i , 2 ) ) ; return codes . size ( ) ; }
bool isReverseEqual ( string s1 , string s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) return false ; int len = s1 . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) if ( s1 [ i ] != s2 [ len - i - 1 ] ) return false ; return true ; }
bool isPrefix ( string str , int len , int i , int k ) { if ( i + k > len ) return false ; for ( int j = 0 ; j < k ; j ++ ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; } return true ; }
bool isKPeriodic ( string str , int len , int k ) { for ( int i = k ; i < len ; i += k ) if ( ! isPrefix ( str , len , i , k ) ) return false ; return true ; }
bool isFrequencyEqual ( string str , int len ) { if ( len % 2 == 1 ) return false ; int i , freq [ 26 ] = { 0 } ; for ( i = 0 ; i < len ; i ++ ) freq [ str [ i ] - 'a' ] ++ ; for ( i = 0 ; i < 26 ; i ++ ) if ( freq [ i ] == len / 2 ) return true ; return false ; }
int minLettersNeeded ( int n ) { if ( n % 26 == 0 ) return ( n / 26 ) ; else return ( ( n / 26 ) + 1 ) ; }
int countMinReversals ( string expr ) { int len = expr . length ( ) ; if ( len % 2 ) return -1 ; int ans = 0 ; int i ; int open = 0 ; int close = 0 ; for ( i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == '{' ) open ++ ; else { if ( ! open ) close ++ ; else open -- ; } } ans = ( close / 2 ) + ( open / 2 ) ; close %= 2 ; open %= 2 ; if ( close ) ans += 2 ; return ans ; }
int minReplacement ( string s , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( i % 2 == 0 && s [ i ] == '1' ) ans ++ ; if ( i % 2 == 1 && s [ i ] == '0' ) ans ++ ; } return min ( ans , len - ans ) ; }
int maxBalancedStr ( string s ) { int open1 = 0 , close1 = 0 ; int open2 = 0 , close2 = 0 ; int open3 = 0 , close3 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { switch ( s [ i ] ) { case '(' : open1 ++ ; break ; case ')' : close1 ++ ; break ; case '{' : open2 ++ ; break ; case '}' : close2 ++ ; break ; case '[' : open3 ++ ; break ; case ']' : close3 ++ ; break ; } } int maxLen = 2 * min ( open1 , close1 ) + 2 * min ( open2 , close2 ) + 2 * min ( open3 , close3 ) ; return maxLen ; }
int totalPairs ( string s1 , string s2 ) { int count = 0 ; int arr1 [ 7 ] , arr2 [ 7 ] ; for ( int i = 1 ; i <= 6 ; i ++ ) { arr1 [ i ] = 0 ; arr2 [ i ] = 0 ; } for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { int set_bits = __builtin_popcount ( ( int ) s1 [ i ] ) ; arr1 [ set_bits ] ++ ; } for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { int set_bits = __builtin_popcount ( ( int ) s2 [ i ] ) ; arr2 [ set_bits ] ++ ; } for ( int i = 1 ; i <= 6 ; i ++ ) count += ( arr1 [ i ] * arr2 [ i ] ) ; return count ; }
int findCost ( string s1 , string s2 , int a , int b , int c , int d , int n ) { int cost = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) continue ; else { if ( ( s1 [ i ] == '1' && s2 [ i ] == '2' ) || ( s2 [ i ] == '1' && s1 [ i ] == '2' ) ) cost += min ( d , min ( a , b + c ) ) ; else if ( ( s1 [ i ] == '2' && s2 [ i ] == '3' ) || ( s2 [ i ] == '2' && s1 [ i ] == '3' ) ) cost += min ( d , min ( b , a + c ) ) ; else if ( ( s1 [ i ] == '1' && s2 [ i ] == '3' ) || ( s2 [ i ] == '1' && s1 [ i ] == '3' ) ) cost += min ( d , min ( c , a + b ) ) ; } } return cost ; }
int totalPairs ( string s1 , string s2 ) { int a1 = 0 , b1 = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( int ( s1 [ i ] ) % 2 != 0 ) a1 ++ ; else b1 ++ ; } int a2 = 0 , b2 = 0 ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( int ( s2 [ i ] ) % 2 != 0 ) a2 ++ ; else b2 ++ ; } return ( ( a1 * a2 ) + ( b1 * b2 ) ) ; }
string replaceConsonants ( string str ) { string res = "" ; int i = 0 , count = 0 ; while ( i < str . length ( ) ) { if ( str [ i ] != 'a' && str [ i ] != 'e' && str [ i ] != 'i' && str [ i ] != 'o' && str [ i ] != 'u' ) { i ++ ; count ++ ; } else { if ( count > 0 ) res += to_string ( count ) ; res += str [ i ] ; i ++ ; count = 0 ; } } if ( count > 0 ) res += to_string ( count ) ; return res ; }
int prefixOccurrences ( string str ) { char c = str [ 0 ] ; int countc = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == c ) countc ++ ; } return countc ; }
int Preprocess ( string A , string B ) { int n = A . size ( ) ; int ans = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { map < char , int > mp ; mp [ A [ i ] ] ++ ; mp [ A [ n - i - 1 ] ] ++ ; mp [ B [ i ] ] ++ ; mp [ B [ n - i - 1 ] ] ++ ; int sz = mp . size ( ) ; if ( sz == 4 ) ans += 2 ; else if ( sz == 3 ) ans += 1 + ( A [ i ] == A [ n - i - 1 ] ) ; else if ( sz == 2 ) ans += mp [ A [ i ] ] != 2 ; } if ( n % 2 == 1 && A [ n / 2 ] != B [ n / 2 ] ) ans ++ ; return ans ; }
bool isPalindrome ( string s ) { int i = 0 ; int j = s . length ( ) - 1 ; while ( i < j ) { if ( s [ i ] != s [ j ] ) return false ; i ++ ; j -- ; } return true ; }
int getIndex ( string S1 , string S2 , int n ) { string S = "" ; for ( int i = 0 ; i < n ; i ++ ) { S = S + S1 [ i ] ; string Temp = "" ; for ( int j = i + 1 ; j < n ; j ++ ) Temp += S2 [ j ] ; if ( isPalindrome ( S + Temp ) ) { return i ; } } return -1 ; }
bool isPalindrome ( string s , int i , int j ) { while ( i < j ) { if ( s [ i ] != s [ j ] ) return false ; i ++ ; j -- ; } return true ; }
bool isVowel ( char c ) { if ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) return true ; return false ; }
bool checkPossibility ( string s1 , string s2 ) { int l1 = s1 . length ( ) ; int l2 = s2 . length ( ) ; if ( l1 != l2 ) return false ; for ( int i = 0 ; i < l1 ; i ++ ) { if ( isVowel ( s1 [ i ] ) && isVowel ( s2 [ i ] ) ) continue ; else if ( ! ( isVowel ( s1 [ i ] ) ) && ! ( isVowel ( s2 [ i ] ) ) ) continue ; else return false ; } return true ; }
void generateString ( int A , int B ) { string rt ; while ( 0 < A 0 < B ) { if ( A < B ) { if ( 0 < B -- ) rt . push_back ( 'b' ) ; if ( 0 < B -- ) rt . push_back ( 'b' ) ; if ( 0 < A -- ) rt . push_back ( 'a' ) ; } else if ( B < A ) { if ( 0 < A -- ) rt . push_back ( 'a' ) ; if ( 0 < A -- ) rt . push_back ( 'a' ) ; if ( 0 < B -- ) rt . push_back ( 'b' ) ; } else { if ( 0 < A -- ) rt . push_back ( 'a' ) ; if ( 0 < B -- ) rt . push_back ( 'b' ) ; } } cout << rt ; }
int countStrings ( int n , int m , string s [ ] ) { unordered_set < int > ind ; for ( int j = 0 ; j < m ; j ++ ) { int mx = 0 ; for ( int i = 0 ; i < n ; i ++ ) mx = max ( mx , ( int ) s [ i ] [ j ] - '0' ) ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] [ j ] - '0' == mx ) ind . insert ( i ) ; } return ind . size ( ) ; }
int minOperations ( string s , string t , int n ) { int ct0 = 0 , ct1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == t [ i ] ) continue ; if ( s [ i ] == '0' ) ct0 ++ ; else ct1 ++ ; } return max ( ct0 , ct1 ) ; }
int count_acronym ( int n , string arr [ ] ) { int freq [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] [ 0 ] - 'a' ] ++ ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string st = arr [ i ] ; int num [ 26 ] = { 0 } ; for ( int j = 0 ; j < st . length ( ) ; j ++ ) num [ st [ j ] - 'a' ] ++ ; bool flag = true ; for ( int j = 1 ; j < 26 ; j ++ ) { if ( num [ j ] > freq [ j ] ) { flag = false ; break ; } } int x = st [ 0 ] - 'a' ; if ( freq [ x ] - 1 < num [ x ] ) flag = false ; if ( flag ) cnt ++ ; } return cnt ; }
int minOperations ( string str , int n ) { int i , lastUpper = -1 , firstLower = -1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( isupper ( str [ i ] ) ) { lastUpper = i ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( islower ( str [ i ] ) ) { firstLower = i ; break ; } } if ( lastUpper == -1 firstLower == -1 ) return 0 ; int countUpper = 0 ; for ( i = firstLower ; i < n ; i ++ ) { if ( isupper ( str [ i ] ) ) { countUpper ++ ; } } int countLower = 0 ; for ( i = 0 ; i < lastUpper ; i ++ ) { if ( islower ( str [ i ] ) ) { countLower ++ ; } } return min ( countLower , countUpper ) ; }
int check ( string s , int k ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s [ i ] != s [ i % k ] ) return false ; return true ; }
int countCommonDivisors ( string a , string b ) { int ct = 0 ; int n = a . size ( ) , m = b . size ( ) ; for ( int i = 1 ; i <= min ( n , m ) ; i ++ ) { if ( n % i == 0 && m % i == 0 ) if ( a . substr ( 0 , i ) == b . substr ( 0 , i ) ) if ( check ( a , i ) && check ( b , i ) ) ct ++ ; } return ct ; }
bool valid ( int cnt [ ] ) { for ( int i = 0 ; i < 26 ; i ++ ) { if ( cnt [ i ] >= 2 ) return false ; } return true ; }
bool isVowel ( char c ) { c = tolower ( c ) ; if ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) return true ; return false ; }
string largestPalinSub ( string s ) { string res ; char mx = s [ 0 ] ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) mx = max ( mx , s [ i ] ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s [ i ] == mx ) res += s [ i ] ; return res ; }
bool isValid ( string str , int len ) { for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) return false ; } return true ; }
string decryptString ( string str , int n ) { int i = 0 , jump = 1 ; string decryptedStr = "" ; while ( i < n ) { decryptedStr += str [ i ] ; i += jump ; jump ++ ; } return decryptedStr ; }
int countSubStr ( string str , int len , int k ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int n = 0 ; for ( int j = i ; j < len ; j ++ ) { n = n * 10 + ( str [ j ] - '0' ) ; if ( n % k == 0 ) count ++ ; } } return count ; }
int nextZero ( int i , int occurrences [ ] ) { while ( i < 26 ) { if ( occurrences [ i ] == 0 ) return i ; i ++ ; } return -1 ; }
int findPermutation ( string str , int k ) { bool has [ 26 ] = { false } ; int cnt = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ! has [ str [ i ] - 'a' ] ) { cnt ++ ; has [ str [ i ] - 'a' ] = true ; } } long long int ans = 1 ; for ( int i = 2 ; i <= cnt ; i ++ ) ans *= i ; for ( int i = cnt - k ; i > 1 ; i -- ) ans /= i ; return ans ; }
int countPairs ( string bracks [ ] , int num ) { unordered_map < int , int > open , close ; int cnt = 0 ; for ( int i = 0 ; i < num ; i ++ ) { string s = bracks [ i ] ; int l = s . length ( ) ; int op = 0 , cl = 0 ; for ( int j = 0 ; j < l ; j ++ ) { if ( s [ j ] == '(' ) op ++ ; { if ( op ) op -- ; cl ++ ; } } if ( op && ! cl ) open [ op ] ++ ; if ( cl && ! op ) close [ cl ] ++ ; if ( ! op && ! cl ) cnt ++ ; } cnt = cnt / 2 ; for ( auto it : open ) cnt += min ( it . second , close [ it . first ] ) ; return cnt ; }
int no_of_ways ( string s ) { int n = s . length ( ) ; int count_left = 0 , count_right = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( s [ i ] == s [ 0 ] ) { ++ count_left ; } else break ; } for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == s [ n - 1 ] ) { ++ count_right ; } else break ; } if ( s [ 0 ] == s [ n - 1 ] ) return ( ( count_left + 1 ) * ( count_right + 1 ) ) ; else return ( count_left + count_right + 1 ) ; }
bool isPalindrome ( string str ) { int len = str . length ( ) ; for ( int i = 0 ; i < len / 2 ; i ++ ) { if ( str [ i ] != str [ len - 1 - i ] ) return false ; } return true ; }
bool createStringAndCheckPalindrome ( int N ) { ostringstream out ; out << N ; string result = out . str ( ) ; string sub = "" + result , res_str = "" ; int sum = 0 ; while ( N > 0 ) { int digit = N % 10 ; sum += digit ; N = N / 10 ; } while ( res_str . length ( ) < sum ) res_str += sub ; if ( res_str . length ( ) > sum ) res_str = res_str . substr ( 0 , sum ) ; if ( isPalindrome ( res_str ) ) return true ; return false ; }
int product ( int x ) { int prod = 1 ; while ( x ) { prod *= ( x % 10 ) ; x /= 10 ; } return prod ; }
string removeChars ( string s ) { string modifiedStr = "" ; modifiedStr += s [ 0 ] ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( isupper ( s [ i ] ) && islower ( s [ i - 1 ] ) || islower ( s [ i ] ) && isupper ( s [ i - 1 ] ) ) modifiedStr += s [ i ] ; } return modifiedStr ; }
int pangramCost ( int arr [ ] , string str ) { int cost = 0 ; bool occurred [ 26 ] = { false } ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) occurred [ str [ i ] - 'a' ] = true ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( ! occurred [ i ] ) cost += arr [ i ] ; } return cost ; }
void pairStar ( string & input , string & output , int i = 0 ) { output = output + input [ i ] ; if ( i == input . length ( ) - 1 ) return ; if ( input [ i ] == input [ i + 1 ] ) output = output + '*' ; pairStar ( input , output , i + 1 ) ; }
int countMinParts ( string str ) { int n = str . length ( ) ; int * freq = getFrequencies ( str ) ; vector < int > oddFreq , evenFreq ; int i , sumEven = 0 ; for ( i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == 0 ) continue ; if ( freq [ i ] % 2 == 0 ) evenFreq . push_back ( freq [ i ] ) ; else oddFreq . push_back ( freq [ i ] ) ; } for ( i = 0 ; i < evenFreq . size ( ) ; i ++ ) { sumEven += evenFreq [ i ] ; } if ( oddFreq . size ( ) == 0 ) return 1 ; if ( sumEven == 0 ) { if ( oddFreq . size ( ) == 1 ) return 1 ; return 0 ; } i = 0 ; while ( i < oddFreq . size ( ) ) { if ( ( sumEven / 2 ) % oddFreq . size ( ) == 0 ) return oddFreq . size ( ) ; if ( oddFreq [ i ] == 1 ) { i ++ ; continue ; } sumEven += 2 ; oddFreq [ i ] = oddFreq [ i ] - 2 ; } return n ; }
int check ( string s , int K ) { for ( int ch = 0 ; ch < 26 ; ch ++ ) { char c = 'a' + ch ; int last = -1 ; bool found = true ; for ( int i = 0 ; i < K ; i ++ ) if ( s [ i ] == c ) last = i ; if ( last == -1 ) continue ; for ( int i = K ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == c ) last = i ; if ( last <= ( i - K ) ) { found = false ; break ; } } if ( found ) return 1 ; } return 0 ; }
int binarySearch ( string s ) { int low = 1 , high = ( int ) s . size ( ) ; int ans ; while ( low <= high ) { int mid = ( high + low ) >> 1 ; if ( check ( s , mid ) ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; }
int subStringsStartingHere ( string str , int n , int startIndex ) { int count = 0 , i = 1 ; while ( i <= n ) { if ( str . substr ( 0 , i ) == str . substr ( startIndex , i ) ) { count ++ ; } else break ; i ++ ; } return count ; }
void printExpansion ( string str ) { int size = 0 ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { string subStr = str . substr ( i , ++ size ) ; cout << subStr ; } }
void printExpansion ( string str ) { string suff = "" ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { suff = suff + str [ i ] ; cout << suff ; } }
bool search ( string pat , string txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int i ; char countP [ ALL_CHARS ] = { 0 } ; char countTW [ ALL_CHARS ] = { 0 } ; for ( i = 0 ; i < M ; i ++ ) { ( countP [ pat [ i ] ] ) ++ ; ( countTW [ txt [ i ] ] ) ++ ; } for ( i = M ; i < N ; i ++ ) { if ( compare ( countP , countTW ) ) { return true ; } ( countTW [ txt [ i ] ] ) ++ ; countTW [ txt [ i - M ] ] -- ; } if ( compare ( countP , countTW ) ) return true ; return false ; }
char logicalExpressionEvaluation ( string str ) { stack < char > arr ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '[' ) { vector < char > s ; while ( arr . top ( ) != ']' ) { s . push_back ( arr . top ( ) ) ; arr . pop ( ) ; } arr . pop ( ) ; if ( s . size ( ) == 3 ) { s [ 2 ] == '1' ? arr . push ( '0' ) : arr . push ( '1' ) ; } else if ( s . size ( ) == 5 ) { int a = s [ 0 ] - 48 , b = s [ 4 ] - 48 , c ; s [ 2 ] == '&' ? c = a && b : c = a || b ; arr . push ( ( char ) c + 48 ) ; } } else { arr . push ( str [ i ] ) ; } } return arr . top ( ) ; }
int count ( string s , int k ) { int n = s . length ( ) ; int d = 0 , i ; int count = 0 ; for ( i = 0 ; i < n ; i ++ ) d += s [ i ] ; if ( d % k == 0 ) count += 1 ; for ( i = k ; i < n ; i ++ ) { int prev = s [ i - k ] ; d -= prev ; d += s [ i ] ; if ( d % k == 0 ) count += 1 ; } return count ; }
string MaxFreq ( string str ) { int n = str . size ( ) ; unordered_map < string , int > m ; for ( int i = 0 ; i < n ; i ++ ) { string s = "" ; for ( int j = i ; j < n ; j ++ ) { s += str [ j ] ; m [ s ] ++ ; } } int maxi = 0 ; string s ; for ( auto i = m . begin ( ) ; i != m . end ( ) ; i ++ ) { if ( i -> second > maxi ) { maxi = i -> second ; s = i -> first ; } else if ( i -> second == maxi ) { string ss = i -> first ; if ( ss . size ( ) > s . size ( ) ) s = ss ; } } return s ; }
void preCompute ( int n , string s , int pref [ ] ) { pref [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { pref [ i ] = pref [ i - 1 ] ; if ( s [ i - 1 ] == s [ i ] ) pref [ i ] ++ ; } }
int query ( int pref [ ] , int l , int r ) { return pref [ r ] - pref [ l ] ; }
int countWays ( string s1 , string s2 , int n ) { int a , b , c , d ; a = b = c = d = 0 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s2 [ i ] == '0' ) { if ( s1 [ i ] == '0' ) { c ++ ; } else { d ++ ; } } else { if ( s1 [ i ] == '0' ) { a ++ ; } else { b ++ ; } } } result = a * d + b * c + c * d ; return result ; }
bool isPrime ( int n ) { int i ; if ( n == 1 ) return false ; for ( i = 2 ; i <= sqrt ( n ) ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
bool check_frequency ( string s ) { map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) m [ s [ i ] ] ++ ; for ( char ch = 'a' ; ch <= 'z' ; ch ++ ) if ( m [ ch ] > 0 && ! isPrime ( m [ ch ] ) ) return false ; return true ; }
int returnWinner ( string s , int l ) { int freq [ 26 ] ; memset ( freq , 0 , sizeof freq ) ; for ( int i = 0 ; i < l ; i ++ ) { freq [ s [ i ] - 'a' ] ++ ; } int cnt = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] & 1 ) cnt ++ ; } if ( cnt == 0 cnt & 1 ) return 1 ; else return 2 ; }
int check ( string s ) { int i , j ; int fr [ 26 ] = { 0 } ; int n = s . size ( ) ; for ( i = 0 ; i < n ; i ++ ) { char x = s [ i ] ; fr [ x - 'a' ] += 1 ; } int minimum = INT_MAX ; for ( i = 0 ; i < 26 ; i ++ ) { for ( j = i + 1 ; j < 26 ; j ++ ) { int z = fr [ i ] + fr [ j ] ; minimum = min ( minimum , n - z ) ; } } return minimum ; }
int findSubstringCount ( string str ) { int result = 0 ; int n = str . size ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] + 1 == str [ i + 1 ] ) { result ++ ; while ( str [ i ] + 1 == str [ i + 1 ] ) { i ++ ; } } } return result ; }
int CountCharacters ( string str , int l , int r ) { int cnt = 0 ; unordered_map < char , int > m ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ! ( l <= str [ i ] and str [ i ] <= r ) ) { cnt ++ ; if ( m [ str [ i ] ] != 1 ) { cout << str [ i ] << " " ; m [ str [ i ] ] ++ ; } } } return cnt ; }
int strScore ( string str [ ] , string s , int n ) { int score = 0 , index ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) score += s [ j ] - 'a' + 1 ; index = i + 1 ; break ; } } score = score * index ; return score ; }
int countChar ( string str , char x ) { int count = 0 , n = 10 ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) if ( str [ i ] == x ) count ++ ; int repetitions = n / str . size ( ) ; count = count * repetitions ; for ( int i = 0 ; i < n % str . size ( ) ; i ++ ) { if ( str [ i ] == x ) count ++ ; } return count ; }
int countConsecutive ( string s ) { int count = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) i ++ ; else count ++ ; } return count ; }
int check_digits ( int n ) { while ( n ) { return 0 ; n /= 10 ; } return 1 ; }
int smallest_number ( int n ) { for ( int i = n ; ; i ++ ) if ( check_digits ( i ) ) return i ; }
int minSteps ( string str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) - 2 ; i ++ ) { if ( str [ i ] == '0' ) { if ( str [ i + 1 ] == '1' ) { if ( str [ i + 2 ] == '0' ) { count ++ ; i += 2 ; } } } } return count ; }
void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
int xorOfPrime ( string s ) { bool prime [ 100005 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , 10005 ) ; int i , j ; map < char , int > m ; for ( i = 0 ; i < s . length ( ) ; i ++ ) m [ s [ i ] ] ++ ; int result = 0 ; int flag = 0 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( prime [ it -> second ] ) { result ^= it -> second ; flag = 1 ; } } if ( ! flag ) return -1 ; return result ; }
int CountCharacters ( string str , int k ) { int cnt = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] < k ) cnt ++ ; } return cnt ; }
void dfs ( string node , int & k , string & A ) { for ( int i = 0 ; i < k ; ++ i ) { string str = node + A [ i ] ; if ( seen . find ( str ) == seen . end ( ) ) { seen . insert ( str ) ; dfs ( str . substr ( 1 ) , k , A ) ; edges . push_back ( i ) ; } } }
int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { f = f * i ; } return f ; }
int npr ( int n , int r ) { return fact ( n ) / fact ( n - r ) ; }
bool checkIfUnequal ( int n , int q ) { string s1 = to_string ( n ) ; int a [ 26 ] = { 0 } ; for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) a [ s1 [ i ] - '0' ] ++ ; int prod = n * q ; string s2 = to_string ( prod ) ; for ( int i = 0 ; i < s2 . size ( ) ; i ++ ) { if ( a [ s2 [ i ] - '0' ] ) return false ; } return true ; }
int countInRange ( int l , int r , int q ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( checkIfUnequal ( i , q ) ) count ++ ; } return count ; }
int search ( int arr [ ] , int strt , int end , int value ) { int i ; for ( i = strt ; i <= end ; i ++ ) { if ( arr [ i ] == value ) break ; } return i ; }
void preOrder ( Node * node ) { if ( node == NULL ) return ; printf ( "%d " , node -> data ) ; preOrder ( node -> left ) ; preOrder ( node -> right ) ; }
int countOnOff ( string n ) { int Led [ ] = { 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 5 } ; int len = n . length ( ) ; int sum = Led [ n [ 0 ] - '0' ] ; for ( int i = 1 ; i < len ; i ++ ) { sum = sum + abs ( Led [ n [ i ] - '0' ] - Led [ n [ i - 1 ] - '0' ] ) ; } return sum ; }
bool checkMarkov ( double m [ ] [ n ] ) { for ( int i = 0 ; i < n ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }
bool isBinary ( int n ) { while ( n != 0 ) { int temp = n % 10 ; if ( temp != 0 && temp != 1 ) { return false ; } n = n / 10 ; } return true ; }
bool checkPalindrome ( string s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != s [ s . length ( ) - i - 1 ] ) return false ; } return true ; }
bool CheckOdd ( string s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { string x = "" ; for ( int j = i ; j < n ; j ++ ) { x += s [ j ] ; if ( x . length ( ) % 2 == 0 && checkPalindrome ( x ) == true ) return false ; } } return true ; }
bool areVowelsInOrder ( string s ) { int n = s . length ( ) ; char c = ( char ) 64 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == 'a' s [ i ] == 'e' s [ i ] == 'i' s [ i ] == 'o' s [ i ] == 'u' ) { if ( s [ i ] < c ) return false ; else { c = s [ i ] ; } } } return true ; }
void solve ( string s , int k ) { int count = 0 , length = 0 , pos = 0 ; map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { m [ s [ i ] ] ++ ; length ++ ; if ( length > k ) { m [ s [ pos ++ ] ] -- ; length -- ; } if ( length == k && m [ s [ i ] ] == length ) count ++ ; } cout << count << endl ; }
void solve ( string s ) { unordered_map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { m [ s [ i ] ] ++ ; } string new_string = "" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m [ s [ i ] ] % 2 == 0 ) continue ; new_string += s [ i ] ; } cout << new_string << endl ; }
bool isDiagonalMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; return true ; }
int minParentheses ( string p ) { int bal = 0 ; int ans = 0 ; for ( int i = 0 ; i < p . length ( ) ; ++ i ) { bal += p [ i ] == '(' ? 1 : -1 ; if ( bal == -1 ) { ans += 1 ; bal += 1 ; } } return bal + ans ; }
long long int fact ( int n ) { long long result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result *= i ; return result ; }
int getResult ( string str , char ch ) { int has [ 26 ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) has [ str [ i ] - 'A' ] ++ ; int particular = has [ ch - 'A' ] ; if ( particular == 0 ) return 0 ; has [ ch - 'A' ] = 0 ; int total = str . length ( ) ; total = total - particular + 1 ; long long int result = fact ( total ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( has [ i ] > 1 ) { result = result / fact ( has [ i ] ) ; } } return result ; }
bool isAnyNotPalindrome ( string s ) { set < char > unique ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) unique . insert ( s [ i ] ) ; if ( unique . size ( ) > 1 ) return true ; else return false ; }
ll factorial ( ll n ) { ll res = 1 ; for ( int i = 1 ; i <= n ; i ++ ) res = res * i ; return res ; }
bool isScalarMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( int i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; return true ; }
int Remainder ( string str , int R ) { int len = str . length ( ) ; int Num , Rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str [ i ] - '0' ) ; Rem = Num % R ; } return Rem ; }
void Solve ( int N , int M ) { int temp = ( N - 1 ) * ( M - 1 ) ; int ans = pow ( 2 , temp ) ; if ( ( N + M ) % 2 != 0 ) cout << ans ; else cout << 2 * ans ; cout << endl ; }
void countWays ( int a [ ] , int n ) { int i , j ; long suff [ n ] ; if ( a [ n - 1 ] == 2 ) suff [ n - 1 ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] == 2 ) suff [ i ] = suff [ i + 1 ] + 1 ; else suff [ i ] = suff [ i + 1 ] ; } long ss = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ss += suff [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] == 1 && a [ j ] == 1 && suff [ j ] >= 2 ) { ss += ( suff [ j ] ) * ( suff [ j ] - 1 ) / 2 ; } } } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] == 1 && a [ j ] == 1 && ( suff [ i ] - suff [ j ] ) >= 1 && suff [ j ] >= 1 ) { ss += ( suff [ i ] - suff [ j ] ) * suff [ j ] ; } } } cout << ( ss ) ; }
long long productAscii ( string str ) { long long prod = 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { prod *= ( int ) str [ i ] ; } return prod ; }
void sortByRow ( int mat [ MAX_SIZE ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) sort ( mat [ i ] , mat [ i ] + n ) ; }
void transpose ( int mat [ MAX_SIZE ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) swap ( mat [ i ] [ j ] , mat [ j ] [ i ] ) ; }
void sortMatRowAndColWise ( int mat [ MAX_SIZE ] [ MAX_SIZE ] , int n ) { sortByRow ( mat , n ) ; transpose ( mat , n ) ; sortByRow ( mat , n ) ; transpose ( mat , n ) ; }
int minimumLength ( string s ) { int maxOcc = 0 , n = s . length ( ) ; int arr [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) arr [ s [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ; return ( n - maxOcc ) ; }
void balancedString ( string str ) { int count = 0 , i ; int n = str . length ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '(' ) { cout << str [ i ] ; count ++ ; } else if ( str [ i ] == ')' && count != 0 ) { cout << str [ i ] ; count -- ; } else if ( str [ i ] != ')' ) cout << str [ i ] ; } if ( count != 0 ) for ( i = 0 ; i < count ; i ++ ) cout << ")" ; }
int minOperation ( string & s , int i , int j , int count ) { if ( ( i >= s . size ( ) && j < 0 ) || ( i == j ) ) return MAX ; if ( s [ i ] == s [ j ] ) return count ; if ( i >= s . size ( ) ) return minOperation ( s , i , j - 1 , count + 1 ) ; else if ( j < 0 ) return minOperation ( s , i + 1 , j , count + 1 ) ; else return min ( minOperation ( s , i , j - 1 , count + 1 ) , minOperation ( s , i + 1 , j , count + 1 ) ) ; }
int minOperation ( string & s , int i , int j , int count ) { if ( ( i >= s . size ( ) && j < 0 ) || ( i == j ) ) return MAX ; if ( s [ i ] == s [ j ] || ( count >= Min ) ) return count ; string str = to_string ( i ) + "|" + to_string ( j ) ; if ( m . find ( str ) == m . end ( ) ) { if ( i >= s . size ( ) ) m [ str ] = minOperation ( s , i , j - 1 , count + 1 ) ; else if ( j < 0 ) m [ str ] = minOperation ( s , i + 1 , j , count + 1 ) ; else m [ str ] = min ( minOperation ( s , i , j - 1 , count + 1 ) , minOperation ( s , i + 1 , j , count + 1 ) ) ; } if ( m [ str ] < Min ) Min = m [ str ] ; return m [ str ] ; }
int countStrings ( string s ) { long sum = 1 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( i % 2 == 0 && s [ i ] == '$' ) sum *= 21 ; else if ( s [ i ] == '$' ) sum *= 5 ; } return sum ; }
int firstPos ( string str , int start , int end ) { int firstChar = -1 ; for ( int i = start ; i <= end ; i ++ ) { if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) { firstChar = i ; break ; } } return firstChar ; }
int lastPos ( string str , int start , int end ) { int lastChar = -1 ; for ( int i = start ; i >= end ; i -- ) { if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) { lastChar = i ; break ; } } return lastChar ; }
bool isInGivenBase ( string str , int base ) { if ( base > 16 ) return false ; else if ( base <= 10 ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ! ( str [ i ] >= '0' and str [ i ] < ( '0' + base ) ) ) return false ; } else { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ! ( ( str [ i ] >= '0' && str [ i ] < ( '0' + base ) ) || ( str [ i ] >= 'A' && str [ i ] < ( 'A' + base - 10 ) ) ) ) return false ; } return true ; }
void frequency ( int fre [ ] [ MAX_CHAR ] , string s [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { string str = s [ i ] ; for ( int j = 0 ; j < str . size ( ) ; j ++ ) fre [ i ] [ str [ j ] - 'a' ] ++ ; } }
void printIndex ( string str , string s ) { bool flag = false ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . substr ( i , s . length ( ) ) == s ) { cout << i << " " ; flag = true ; } } if ( flag == false ) cout << "NONE" ; }
int powerOfJump ( string s ) { int count = 1 ; int max_so_far = INT_MIN ; char ch = s [ s . length ( ) - 1 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ch ) { if ( count > max_so_far ) { max_so_far = count ; } count = 1 ; } else count ++ ; } return max_so_far ; }
int findLongestSub ( string bin ) { int n = bin . length ( ) , i ; int sum = 0 ; unordered_map < int , int > prevSum ; int maxlen = 0 ; int currlen ; for ( i = 0 ; i < n ; i ++ ) { if ( bin [ i ] == '1' ) sum ++ ; else sum -- ; if ( sum > 0 ) { maxlen = i + 1 ; } else if ( sum <= 0 ) { if ( prevSum . find ( sum - 1 ) != prevSum . end ( ) ) { currlen = i - prevSum [ sum - 1 ] ; maxlen = max ( maxlen , currlen ) ; } } if ( prevSum . find ( sum ) == prevSum . end ( ) ) prevSum [ sum ] = i ; } return maxlen ; }
void countEvenOdd ( int arr [ ] , int n , int K ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ; y = __builtin_popcount ( K ) ; if ( y & 1 ) { cout << "Even = " << odd << ", Odd = " << even ; } else { cout << "Even = " << even << ", Odd = " << odd ; } }
int averageValue ( string s ) { int sum_char = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum_char += ( int ) s [ i ] ; } return sum_char / s . length ( ) ; }
int findNumberOfTimes ( string str1 , string str2 ) { int freq [ 26 ] = { 0 } ; int freq2 [ 26 ] = { 0 } ; int l1 = str1 . length ( ) ; int l2 = str2 . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) freq [ str1 [ i ] - 'a' ] += 1 ; for ( int i = 0 ; i < l2 ; i ++ ) freq2 [ str2 [ i ] - 'a' ] += 1 ; int count = INT_MAX ; for ( int i = 0 ; i < l2 ; i ++ ) { if ( freq2 [ str2 [ i ] - 'a' ] != 0 ) count = min ( count , freq [ str2 [ i ] - 'a' ] / freq2 [ str2 [ i ] - 'a' ] ) ; } return count ; }
bool solve ( string s1 , string s2 ) { bool flag1 = 0 , flag2 = 0 ; if ( s1 . length ( ) != s2 . length ( ) ) return false ; int l = s1 . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s1 [ i ] == '1' ) flag1 = 1 ; if ( s2 [ i ] == '1' ) flag2 = 1 ; if ( flag1 && flag2 ) return true ; } if ( ! flag1 && ! flag2 ) return true ; return false ; }
bool check ( string s , int l ) { int freq [ 26 ] = { 0 } ; for ( int i = 0 ; i < l ; i ++ ) { } for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] >= 2 ) return true ; } return false ; }
bool isPalindrome ( string str , int l , int r ) { while ( l < r ) { if ( str [ l ] != str [ r ] ) return false ; l ++ ; r -- ; } return true ; }
int CyclicShifts ( string str ) { int n = str . length ( ) ; int left = 0 ; int right = n - 1 ; str = str + str ; int cnt = 0 ; while ( right < 2 * n - 1 ) { if ( isPalindrome ( str , left , right ) ) break ; cnt ++ ; left ++ ; right ++ ; } return cnt ; }
void printNum ( string s ) { int i = 0 , j = 0 , val = 0 ; map < int , int > mp ; val = ( s [ 0 ] - '0' ) * 100 + ( s [ 1 ] - '0' ) * 10 + ( s [ 2 ] - '0' ) ; mp [ val ] = 1 ; for ( i = 3 ; i < s . length ( ) ; i ++ ) { val = ( val % 100 ) * 10 + s [ i ] - '0' ; if ( mp . find ( val ) != mp . end ( ) ) { mp [ val ] = mp [ val ] + 1 ; } else { mp [ val ] = 1 ; } } for ( auto m : mp ) { int key = m . first ; int value = m . second ; if ( value > 1 ) cout << key << " - " << value << " times" << endl ; } }
int countSubstrig ( string str1 , string str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; if ( n1 == 0 n1 < n2 ) return 0 ; if ( str1 . substr ( 0 , n2 ) . compare ( str2 ) == 0 ) return countSubstrig ( str1 . substr ( n2 - 1 ) , str2 ) + 1 ; return countSubstrig ( str1 . substr ( n2 - 1 ) , str2 ) ; }
bool check ( string s , int m ) { int l = s . length ( ) ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; }
char nextGreatestAlphabet ( vector < char > & alphabets , char K ) { int n = alphabets . size ( ) ; if ( K >= alphabets [ n - 1 ] ) return alphabets [ 0 ] ; int l = 0 , r = alphabets . size ( ) - 1 ; int ans = -1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( alphabets [ mid ] > K ) { r = mid - 1 ; ans = mid ; } else l = mid + 1 ; } return alphabets [ ans ] ; }
void reverse ( char str [ ] , int start , int end ) { char temp ; while ( start <= end ) { temp = str [ start ] ; str [ start ] = str [ end ] ; str [ end ] = temp ; start ++ ; end -- ; } }
void reverseletter ( char str [ ] , int start , int end ) { int wstart , wend ; for ( wstart = wend = start ; wend < end ; wend ++ ) { if ( str [ wend ] == ' ' ) continue ; while ( str [ wend ] != ' ' && wend <= end ) wend ++ ; wend -- ; reverse ( str , wstart , wend ) ; } }
int subCount ( int arr [ ] , int n , int k ) { int mod [ k ] ; memset ( mod , 0 , sizeof ( mod ) ) ; int cumSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumSum += arr [ i ] ; mod [ ( ( cumSum % k ) + k ) % k ] ++ ; } int result = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( mod [ i ] > 1 ) result += ( mod [ i ] * ( mod [ i ] - 1 ) ) / 2 ; result += mod [ 0 ] ; return result ; }
int countSubmatrix ( int mat [ SIZE ] [ SIZE ] , int n , int k ) { int tot_count = 0 ; int left , right , i ; int temp [ n ] ; for ( left = 0 ; left < n ; left ++ ) { memset ( temp , 0 , sizeof ( temp ) ) ; for ( right = left ; right < n ; right ++ ) { for ( i = 0 ; i < n ; ++ i ) temp [ i ] += mat [ i ] [ right ] ; tot_count += subCount ( temp , n , k ) ; } } return tot_count ; }
int matchClosing ( char X [ ] , int start , int end , char open , char close ) { int c = 1 ; int i = start + 1 ; while ( i <= end ) { if ( X [ i ] == open ) c ++ ; else if ( X [ i ] == close ) c -- ; if ( c == 0 ) return i ; i ++ ; } return i ; }
int matchingOpening ( char X [ ] , int start , int end , char open , char close ) { int c = -1 ; int i = end - 1 ; while ( i >= start ) { if ( X [ i ] == open ) c ++ ; else if ( X [ i ] == close ) c -- ; if ( c == 0 ) return i ; i -- ; } return -1 ; }
bool isBalanced ( char X [ ] , int n ) { int i , j , k , x , start , end ; for ( i = 0 ; i < n ; i ++ ) { if ( X [ i ] == '(' ) j = matchClosing ( X , i , n - 1 , '(' , ')' ) ; else if ( X [ i ] == '{' ) j = matchClosing ( X , i , n - 1 , '{' , '}' ) ; else if ( X [ i ] == '[' ) j = matchClosing ( X , i , n - 1 , '[' , ']' ) ; else { if ( X [ i ] == ')' ) j = matchingOpening ( X , 0 , i , '(' , ')' ) ; else if ( X [ i ] == '}' ) j = matchingOpening ( X , 0 , i , '{' , '}' ) ; else if ( X [ i ] == ']' ) j = matchingOpening ( X , 0 , i , '[' , ']' ) ; if ( j < 0 j > = i ) return false ; continue  ; } if ( j >= n j < 0 ) return false ; start = i ; end = j ; for ( k = start + 1 ; k < end ; k ++ ) { if ( X [ k ] == '(' ) { x = matchClosing ( X , k , end , '(' , ')' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ')' ) { x = matchingOpening ( X , start , k , '(' , ')' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == '{' ) { x = matchClosing ( X , k , end , '{' , '}' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == '}' ) { x = matchingOpening ( X , start , k , '{' , '}' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == '[' ) { x = matchClosing ( X , k , end , '[' , ']' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ']' ) { x = matchingOpening ( X , start , k , '[' , ']' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } } } return true ; }
string possibleToSort ( int * arr , int n , string str ) { int max_element = -1 ; for ( long i = 0 ; i < str . size ( ) ; i ++ ) { max_element = max ( max_element , arr [ i ] ) ; if ( str [ i ] == '0' ) { if ( max_element > i + 1 ) return "No" ; } } return "Yes" ; }
int largestNum ( int n ) { int num = 0 ; int max_setBits = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { int setBits = __builtin_popcount ( i ) ; if ( setBits >= max_setBits ) { num = i ; max_setBits = setBits ; } } return num ; }
int findMinOpeartion ( int matrix [ ] [ 2 ] , int n ) { int sumRow [ n ] , sumCol [ n ] ; memset ( sumRow , 0 , sizeof ( sumRow ) ) ; memset ( sumCol , 0 , sizeof ( sumCol ) ) ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { sumRow [ i ] += matrix [ i ] [ j ] ; sumCol [ j ] += matrix [ i ] [ j ] ; } int maxSum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { maxSum = max ( maxSum , sumRow [ i ] ) ; maxSum = max ( maxSum , sumCol [ i ] ) ; } int count = 0 ; for ( int i = 0 , j = 0 ; i < n && j < n ; ) { int diff = min ( maxSum - sumRow [ i ] , maxSum - sumCol [ j ] ) ; matrix [ i ] [ j ] += diff ; sumRow [ i ] += diff ; sumCol [ j ] += diff ; count += diff ; if ( sumRow [ i ] == maxSum ) ++ i ; if ( sumCol [ j ] == maxSum ) ++ j ; } return count ; }
int countPair ( char str [ N ] [ N ] , int n ) { int cnt [ 1 << 10 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int mask = 0 ; for ( int j = 0 ; str [ i ] [ j ] != '\0' ; ++ j ) mask |= ( 1 << ( str [ i ] [ j ] - '0' ) ) ; cnt [ mask ] ++ ; } int ans = 0 ; for ( int m1 = 0 ; m1 <= 1023 ; m1 ++ ) for ( int m2 = 0 ; m2 <= 1023 ; m2 ++ ) if ( ( m1 m2 ) == 1023 ) { ans += ( ( m1 == m2 ) ? ( cnt [ m1 ] * ( cnt [ m1 ] - 1 ) ) : ( cnt [ m1 ] * cnt [ m2 ] ) ) ; } return ans / 2 ; }
long long int computeStringCount ( int N ) { int n = N / 2 ; long long int ans = 0 ; for ( int i = 2 ; i <= n ; i += 2 ) ans = ( ans + ( ( nCr [ n ] [ i ] * nCr [ n ] [ i / 2 ] ) % mod ) ) % mod ; return ans ; }
void countSubsequence ( char s [ ] , int n ) { int cntG = 0 , cntF = 0 , result = 0 , C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { switch ( s [ i ] ) { case 'G' : cntG ++ ; result += C ; break ; case 'F' : cntF ++ ; C += cntG ; break ; default : continue ; } } cout << result << endl ; }
int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
string LexicographicalMaxString ( string str ) { char maxchar = 'a' ; vector < int > index ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] >= maxchar ) { maxchar = str [ i ] ; index . push_back ( i ) ; } } string maxstring = "" ; for ( int i = 0 ; i < index . size ( ) ; i ++ ) { if ( str . substr ( index [ i ] , str . length ( ) ) > maxstring ) { maxstring = str . substr ( index [ i ] , str . length ( ) ) ; } } return maxstring ; }
bool isDivisible ( char str [ ] , int k ) { int n = strlen ( str ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == '0' ) c ++ ; return ( c == k ) ; }
string longestPalin ( string str ) { str = str + " " ; string longestword = "" , word = "" ; int length , length1 = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str [ i ] ; if ( ch != ' ' ) word = word + ch ; else { length = word . length ( ) ; if ( checkPalin ( word ) && length > length1 ) { length1 = length ; longestword = word ; } word = "" ; } } return longestword ; }
bool isCommonBase ( string base , string s1 , string s2 ) { for ( int j = 0 ; j < s1 . length ( ) ; ++ j ) if ( base [ j % base . length ( ) ] != s1 [ j ] ) return false ; for ( int j = 0 ; j < s2 . length ( ) ; ++ j ) if ( base [ j % base . length ( ) ] != s2 [ j ] ) return false ; return true ; }
int countCommonBases ( string s1 , string s2 ) { int n1 = s1 . length ( ) , n2 = s2 . length ( ) ; int count = 0 ; for ( int i = 1 ; i <= min ( n1 , n2 ) ; i ++ ) { string base = s1 . substr ( 0 , i ) ; if ( isCommonBase ( base , s1 , s2 ) ) count ++ ; } return count ; }
bool isPrimeString ( string str ) { int len = str . length ( ) , n = 0 ; for ( int i = 0 ; i < len ; i ++ ) n += ( int ) str [ i ] ; if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int countPalin ( string str ) { str = str + " " ; string word = "" ; int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . at ( i ) ; if ( ch != ' ' ) word = word + ch ; else { if ( checkPalin ( word ) ) count ++ ; word = "" ; } } return count ; }
bool targetstring ( string str1 , string str2 ) { int l1 = str1 . length ( ) ; int l2 = str2 . length ( ) ; if ( l1 != l2 ) return false ; int map [ MAX ] = { 0 } ; for ( int i = 0 ; i < l1 ; i ++ ) map [ str1 [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) { map [ str2 [ i ] - 'a' ] -- ; if ( map [ str2 [ i ] - 'a' ] < 0 ) return false ; } return true ; }
bool isDigitPresent ( int x , int d ) { while ( x > 0 ) { if ( x % 10 == d ) break ; x = x / 10 ; } return ( x > 0 ) ; }
void printNumbers ( int n , int d ) { for ( int i = 0 ; i <= n ; i ++ ) if ( i == d || isDigitPresent ( i , d ) ) cout << i << " " ; }
void printNumbers ( int n , int d ) { string st = "" ; st += to_string ( d ) ; char ch = st [ 0 ] ; string p = "" ; p += ch ; for ( int i = 0 ; i <= n ; i ++ ) { st = "" ; st = st + to_string ( i ) ; int idx = st . find ( p ) ; if ( i == d idx != -1 ) cout << ( i ) << " " ; } }
char findExtraCharcter ( string strA , string strB ) { int res = 0 , i ; for ( i = 0 ; i < strA . length ( ) ; i ++ ) { res ^= strA [ i ] ; } for ( i = 0 ; i < strB . length ( ) ; i ++ ) { res ^= strB [ i ] ; } return ( ( char ) ( res ) ) ; }
char findExtraCharacter ( string s1 , string s2 ) { string smallStr ; string largeStr ; if ( s1 . size ( ) > s2 . size ( ) ) { smallStr = s2 ; largeStr = s1 ; } else { smallStr = s1 ; largeStr = s2 ; } int smallStrCodeTotal = 0 ; int largeStrCodeTotal = 0 ; int i = 0 ; for ( ; i < smallStr . size ( ) ; i ++ ) { smallStrCodeTotal += smallStr [ i ] ; largeStrCodeTotal += largeStr [ i ] ; } largeStrCodeTotal += largeStr [ i ] ; int intChar = largeStrCodeTotal - smallStrCodeTotal ; return ( char ) intChar ; }
long long int fact ( int n ) { long long int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int countPalinPermutations ( string & str ) { int n = str . length ( ) ; int freq [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] ] ++ ; long long int res = fact ( n / 2 ) ; bool oddFreq = false ; for ( int i = 0 ; i < MAX ; i ++ ) { int half = freq [ i ] / 2 ; if ( freq [ i ] % 2 != 0 ) { if ( oddFreq == true ) return 0 ; oddFreq = true ; } res = res / fact ( half ) ; } return res ; }
int minChanges ( string & str ) { int n = str . length ( ) ; if ( n > MAX_CHAR ) return -1 ; int dist_count = 0 ; int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ str [ i ] - 'a' ] == 0 ) dist_count ++ ; count [ ( str [ i ] - 'a' ) ] ++ ; } return ( n - dist_count ) ; }
void printList ( struct Node * head ) { while ( head != NULL ) { cout << head -> c << " " ; head = head -> next ; } }
void strToBinary ( string s ) { int n = s . length ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { int val = int ( s [ i ] ) ; string bin = "" ; while ( val > 0 ) { ( val % 2 ) ? bin . push_back ( '1' ) : bin . push_back ( '0' ) ; val /= 2 ; } reverse ( bin . begin ( ) , bin . end ( ) ) ; cout << bin << " " ; } }
int numofstring ( int n , int m ) { if ( n == 1 ) return m ; if ( n == 2 ) return m * ( m - 1 ) ; return m * ( m - 1 ) * pow ( m - 2 , n - 2 ) ; }
int calculateSum ( string arr [ ] , int n ) { if ( n == 0 ) return 0 ; string s = arr [ 0 ] ; int value = stoi ( s ) ; int sum = value ; for ( int i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; int value = stoi ( s ) ; char operation = arr [ i - 1 ] [ 0 ] ; if ( operation == '+' ) sum += value ; else sum -= value ; } return sum ; }
int FindMaxProduct ( int arr [ ] [ n ] , int n ) { int max = 0 , result ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 1 ) <= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] ; if ( max < result ) max = result ; } } } return max ; }
int CountSpecialPalindrome ( string str ) { int n = str . length ( ) ; int result = 0 ; int sameChar [ n ] = { 0 } ; int i = 0 ; while ( i < n ) { int sameCharCount = 1 ; int j = i + 1 ; while ( str [ i ] == str [ j ] && j < n ) sameCharCount ++ , j ++ ; result += ( sameCharCount * ( sameCharCount + 1 ) / 2 ) ; sameChar [ i ] = sameCharCount ; i = j ; } for ( int j = 1 ; j < n ; j ++ ) { if ( str [ j ] == str [ j - 1 ] ) sameChar [ j ] = sameChar [ j - 1 ] ; if ( j > 0 && j < ( n - 1 ) && ( str [ j - 1 ] == str [ j + 1 ] && str [ j ] != str [ j - 1 ] ) ) result += min ( sameChar [ j - 1 ] , sameChar [ j + 1 ] ) ; } return result - n ; }
int productAtKthLevel ( string tree , int k ) { int level = -1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == '(' ) level ++ ; else if ( tree [ i ] == ')' ) level -- ; else { if ( level == k ) product *= ( tree [ i ] - '0' ) ; } } return product ; }
bool isCornerPresent ( string str , string corner ) { int n = str . length ( ) ; int cl = corner . length ( ) ; if ( n < cl ) return false ; return ( str . substr ( 0 , cl ) . compare ( corner ) == 0 && str . substr ( n - cl , cl ) . compare ( corner ) == 0 ) ; }
int factorial ( int n ) { int f = 1 ; for ( int i = 1 ; i <= n ; i ++ ) f = f * i ; return f ; }
int calculateTotal ( string temp , int n ) { int f = factorial ( n ) ; map < char , int > hm ; for ( int i = 0 ; i < temp . length ( ) ; i ++ ) { hm [ temp [ i ] ] ++ ; } for ( auto e : hm ) { int x = e . second ; if ( x > 1 ) { int temp5 = factorial ( x ) ; f /= temp5 ; } return f ; } }
static void nextPermutation ( string & temp ) { int i ; for ( i = temp . length ( ) - 1 ; i > 0 ; i -- ) if ( temp [ i ] > temp [ i - 1 ] ) break ; int min = i ; int j , x = temp [ i - 1 ] ; for ( j = i + 1 ; j < temp . length ( ) ; j ++ ) if ( ( temp [ j ] < temp [ min ] ) and ( temp [ j ] > x ) ) min = j ; swap ( temp [ i - 1 ] , temp [ min ] ) ; sort ( temp . begin ( ) + i , temp . end ( ) ) ; cout << temp << endl ; }
int countSpecial ( string & str ) { int len = str . length ( ) ; if ( len == 0 ) return 0 ; int co [ len + 1 ] ; int vo [ len + 1 ] ; memset ( co , 0 , sizeof ( co ) ) ; memset ( vo , 0 , sizeof ( vo ) ) ; if ( isCons ( str [ len - 1 ] ) == 1 ) co [ len - 1 ] = 1 ; else vo [ len - 1 ] = 1 ; for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( isCons ( str [ i ] ) == 1 ) { co [ i ] = co [ i + 1 ] + 1 ; vo [ i ] = vo [ i + 1 ] ; } else { co [ i ] = co [ i + 1 ] ; vo [ i ] = vo [ i + 1 ] + 1 ; } } long long ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( isVowel ( str [ i ] ) ) ans = ans + co [ i + 1 ] ; else ans = ans + vo [ i + 1 ] ; } return ans ; }
int findSubSequence ( string s , int num ) { int res = 0 ; int i = 0 ; while ( num ) { if ( num & 1 ) res += s [ i ] - '0' ; i ++ ; num = num >> 1 ; } return res ; }
void findSubsequence ( string str , int k ) { int a [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) a [ str [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < l ; i ++ ) if ( a [ str [ i ] - 'a' ] >= k ) cout << str [ i ] ; }
bool isConvertible ( string str1 , string str2 , int k ) { if ( ( str1 . length ( ) + str2 . length ( ) ) < k ) return true ; int commonLength = 0 ; for ( int i = 0 ; i < min ( str1 . length ( ) , str2 . length ( ) ) ; i ++ ) { if ( str1 [ i ] == str2 [ i ] ) commonLength ++ ; else break ; } if ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) return true ; return false ; }
int maxLower ( string str ) { int n = str . length ( ) ; int i = 0 ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { i ++ ; break ; } } int maxCount = 0 ; int count [ MAX_CHAR ] = { 0 } ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { int currCount = 0 ; for ( int j = 0 ; j < MAX_CHAR ; j ++ ) if ( count [ j ] > 0 ) currCount ++ ; maxCount = max ( maxCount , currCount ) ; memset ( count , 0 , sizeof ( count ) ) ; } if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) count [ str [ i ] - 'a' ] ++ ; } return maxCount ; }
int maxLower ( string str ) { int n = str . length ( ) ; int i = 0 ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { i ++ ; break ; } } int maxCount = 0 ; unordered_set < int > s ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) { maxCount = max ( maxCount , ( int ) s . size ( ) ) ; s . clear ( ) ; } if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) s . insert ( str [ i ] ) ; } return maxCount ; }
bool checkPalindrome ( string str ) { int n = str . length ( ) ; int count = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) if ( str [ i ] != str [ n - i - 1 ] ) ++ count ; return ( count <= 1 ) ; }
int minimumflip ( int mat [ ] [ N ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }
int findLUSlength ( string a , string b ) { unordered_map < string , int > map ; vector < string > strArr ; strArr . push_back ( a ) ; strArr . push_back ( b ) ; for ( string s : strArr ) { for ( int i = 0 ; i < ( 1 << s . length ( ) ) ; i ++ ) { string t = "" ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( ( ( i >> j ) & 1 ) != 0 ) t += s [ j ] ; } if ( map . count ( t ) ) map [ t ] ++ ; else map [ t ] = 1 ; } } int res = 0 ; for ( auto a : map ) { if ( a . second == 1 ) res = max ( res , ( int ) a . first . length ( ) ) ; } return res ; }
int findLUSlength ( string a , string b ) { if ( ! a . compare ( b ) ) return 0 ; return max ( a . length ( ) , b . length ( ) ) ; }
string convert ( string str ) { string w = "" , z = "" ; transform ( str . begin ( ) , str . end ( ) , str . begin ( ) , :: toupper ) ; str += " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str [ i ] ; if ( ch != ' ' ) { w = w + ch ; } else { z = z + char ( tolower ( w [ 0 ] ) ) + w . substr ( 1 ) + " " ; w = "" ; } } return z ; }
char first ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( isupper ( str [ i ] ) ) return str [ i ] ; return 0 ; }
int fact ( int n ) { int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ans * i ; return ( ans ) ; }
int evenDecimalValue ( string str , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int decimalValue = 0 ; int powerOf2 = 1 ; for ( int k = i ; k <= j ; k ++ ) { decimalValue += ( ( str [ k ] - '0' ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; }
void solve ( string s ) { int l = s . length ( ) ; int x = l / 2 ; int y = l ; string p = "" ; while ( x > 0 && y > l / 2 ) { p += s [ x - 1 ] ; x -- ; p += s [ y - 1 ] ; y -- ; } if ( y > l / 2 ) { p += s [ y - 1 ] ; y -- ; } cout << p ; }
bool isConsonant ( char ch ) { ch = toupper ( ch ) ; return ! ( ch == 'A' ch == 'E' ch == 'I' ch == 'O' ch == 'U' ) && ch >= 65 && ch <= 90 ; }
int totalConsonants ( string str , int n ) { if ( n == 1 ) return isConsonant ( str [ 0 ] ) ; return totalConsonants ( str , n - 1 ) + isConsonant ( str [ n - 1 ] ) ; }
int countSubstr ( string s ) { int n = s . length ( ) ; int auxArr [ n ] = { 0 } ; if ( s [ 0 ] == '1' ) auxArr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) auxArr [ i ] = auxArr [ i - 1 ] + 1 ; else auxArr [ i ] = auxArr [ i - 1 ] ; } int count = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) if ( s [ i ] == '1' ) count += auxArr [ i ] ; return count ; }
int calSumUtil ( int a [ ] , int b [ ] , int n , int m ) { int sum [ n ] ; int i = n - 1 , j = m - 1 , k = n - 1 ; int carry = 0 , s = 0 ; while ( j >= 0 ) { s = a [ i ] + b [ j ] + carry ; sum [ k ] = ( s % 10 ) ; carry = s / 10 ; k -- ; i -- ; j -- ; } while ( i >= 0 ) { s = a [ i ] + carry ; sum [ k ] = ( s % 10 ) ; carry = s / 10 ; i -- ; k -- ; } int ans = 0 ; if ( carry ) ans = 10 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { ans += sum [ i ] ; ans *= 10 ; } return ans / 10 ; }
int calSum ( int a [ ] , int b [ ] , int n , int m ) { if ( n >= m ) return calSumUtil ( a , b , n , m ) ; else return calSumUtil ( b , a , m , n ) ; }
int longCommomAnagramSubseq ( char str1 [ ] , char str2 [ ] , int n1 , int n2 ) { int freq1 [ SIZE ] , freq2 [ SIZE ] ; memset ( freq1 , 0 , sizeof ( freq1 ) ) ; memset ( freq2 , 0 , sizeof ( freq2 ) ) ; int len = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) freq1 [ str1 [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < SIZE ; i ++ ) len += min ( freq1 [ i ] , freq2 [ i ] ) ; return len ; }
bool isPanalphabeticWindow ( char s [ ] , int n ) { char ch = 'a' ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch ) ch ++ ; if ( ch == 'z' + 1 ) return true ; } return false ; }
int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; }
bool HalfDiagonalSums ( int mat [ ] [ MAX ] , int n ) { int diag1_left = 0 , diag1_right = 0 ; int diag2_left = 0 , diag2_right = 0 ; for ( int i = 0 , j = n - 1 ; i < n ; i ++ , j -- ) { if ( i < n / 2 ) { diag1_left += mat [ i ] [ i ] ; diag2_left += mat [ j ] [ i ] ; } else if ( i > n / 2 ) { diag1_right += mat [ i ] [ i ] ; diag2_right += mat [ j ] [ i ] ; } } return ( diag1_left == diag2_right && diag2_right == diag2_left && diag1_right == diag2_left && diag2_right == mat [ n / 2 ] [ n / 2 ] ) ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
void prime_index ( string input ) { int n = input . length ( ) ; for ( int i = 2 ; i <= n ; i ++ ) if ( isPrime ( i ) ) cout << input [ i - 1 ] ; }
bool isHeterogram ( char s [ ] , int n ) { int hash [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != ' ' ) { if ( hash [ s [ i ] - 'a' ] == 0 ) hash [ s [ i ] - 'a' ] = 1 ; else return false ; } } return true ; }
void ASCIISentence ( std :: string str ) { int l = str . length ( ) ; int convert ; for ( int i = 0 ; i < l ; i ++ ) { convert = str [ i ] - NULL ; cout << convert ; } }
void preProcess ( string a , string b ) { int n = a . size ( ) ; fwd = new int [ n ] ( ) ; bwd = new int [ n ] ( ) ; int j = 0 ; for ( int i = 1 ; i <= a . size ( ) ; i ++ ) { if ( j < b . size ( ) && a [ i - 1 ] == b [ j ] ) j ++ ; fwd [ i ] = j ; } j = 0 ; for ( int i = a . size ( ) ; i >= 1 ; i -- ) { if ( j < b . size ( ) && a [ i - 1 ] == b [ b . size ( ) - j - 1 ] ) j ++ ; bwd [ i ] = j ; } }
int findOccurrences ( string str , string substr ) { int counter = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == substr [ 0 ] ) { for ( int j = i + 1 ; j < str . length ( ) ; j ++ ) { if ( str [ j ] == substr [ 1 ] ) { for ( int k = j + 1 ; k < str . length ( ) ; k ++ ) { if ( str [ k ] == substr [ 2 ] ) counter ++ ; } } } } } return counter ; }
int findOccurrences ( string str , string substr ) { int n = str . length ( ) ; int preLeft [ n ] = { 0 } ; int preRight [ n ] = { 0 } ; if ( str [ 0 ] == substr [ 0 ] ) preLeft [ 0 ] ++ ; for ( int i = 1 ; i < n ; i ++ ) { if ( str [ i ] == substr [ 0 ] ) preLeft [ i ] = preLeft [ i - 1 ] + 1 ; else preLeft [ i ] = preLeft [ i - 1 ] ; } if ( str [ n - 1 ] == substr [ 2 ] ) preRight [ n - 1 ] ++ ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( str [ i ] == substr [ 2 ] ) preRight [ i ] = preRight [ i + 1 ] + 1 ; else preRight [ i ] = preRight [ i + 1 ] ; } int counter = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( str [ i ] == str [ 1 ] ) { int total = preLeft [ i - 1 ] * preRight [ i + 1 ] ; counter += total ; } } return counter ; }
bool canMakeStr2 ( string str1 , string str2 ) { int count [ MAX ] = { 0 } ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) count [ str1 [ i ] ] ++ ; for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { if ( count [ str2 [ i ] ] == 0 ) return false ; count [ str2 [ i ] ] -- ; } return true ; }
bool isVowel ( char c ) { return ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) ; }
bool isVowel ( char c ) { return ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) ; }
void finalPosition ( string move ) { int l = move . size ( ) ; int countUp = 0 , countDown = 0 ; int countLeft = 0 , countRight = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( move [ i ] == 'U' ) countUp ++ ; else if ( move [ i ] == 'D' ) countDown ++ ; else if ( move [ i ] == 'L' ) countLeft ++ ; else if ( move [ i ] == 'R' ) countRight ++ ; } cout << "Final Position: (" << ( countRight - countLeft ) << ", " << ( countUp - countDown ) << ")" << endl ; }
bool isIdentity ( int mat [ ] [ MAX ] , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }
int maxbalancedprefix ( char str [ ] , int n ) { int sum = 0 ; int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '(' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; }
int countOccurrences ( char * str , string word ) { char * p ; vector < string > a ; p = strtok ( str , " " ) ; while ( p != NULL ) { a . push_back ( p ) ; p = strtok ( NULL , " " ) ; } int c = 0 ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) if ( word == a [ i ] ) c ++ ; return c ; }
int minCost ( string & s ) { bool alphabets [ 26 ] = { false } ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) alphabets [ s [ i ] - 97 ] = true ; int count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) if ( alphabets [ i ] ) count ++ ; return count ; }
int numberOfDifferentSubstrings ( string s , string a , string b ) { int ans = 0 ; int ls = s . size ( ) , la = a . size ( ) , lb = b . size ( ) ; int x [ ls ] = { 0 } , y [ ls ] = { 0 } ; for ( int i = 0 ; i < ls ; i ++ ) { if ( s . substr ( i , la ) == a ) x [ i ] = 1 ; if ( s . substr ( i , lb ) == b ) y [ i ] = 1 ; } unordered_set < string > hash ; string curr_substr = "" ; for ( int i = 0 ; i < ls ; i ++ ) { if ( x [ i ] ) { for ( int j = i ; j < ls ; j ++ ) { if ( ! y [ j ] ) curr_substr += s [ j ] ; if ( y [ j ] ) { curr_substr += s . substr ( j , lb ) ; if ( hash . find ( curr_substr ) == hash . end ( ) ) ans ++ ; hash . insert ( curr_substr ) ; } } curr_substr = "" ; } } return ans ; }
long countWays ( int n , int m , int k ) { if ( k == -1 && ( n + m ) % 2 == 1 ) return 0 ; if ( n == 1 m == 1 ) return 1 ; return ( modPower ( modPower ( ( long long ) 2 , n - 1 ) , m - 1 ) % mod ) ; }
int cost ( string str ) { int len = str . length ( ) ; int res = 0 ; for ( int i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) if ( str [ i ] != str [ j ] ) res += min ( str [ i ] , str [ j ] ) - 'a' + 1 ; return res ; }
string pigLatin ( string s ) { int len = s . length ( ) ; int index = -1 ; for ( int i = 0 ; i < len ; i ++ ) { if ( isVowel ( s [ i ] ) ) { index = i ; break ; } } if ( index == -1 ) return "-1" ; return s . substr ( index ) + s . substr ( 0 , index ) + "ay" ; }
bool isValidISBN ( string & isbn ) { int n = isbn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn [ i ] - '0' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn [ 9 ] ; if ( last != 'X' && ( last < '0' last > '9' ) ) return false ; sum += ( ( last == 'X' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; }
int remainder ( string str ) { int len = str . length ( ) ; int num , rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str [ i ] - '0' ) ; rem = num % 11 ; } return rem ; }
int longestSubseq ( string s ) { int n = s . length ( ) ; int pre_count_0 [ n + 2 ] ; int pre_count_1 [ n + 1 ] ; int post_count_0 [ n + 1 ] ; pre_count_0 [ 0 ] = 0 ; post_count_0 [ n + 1 ] = 0 ; pre_count_1 [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { pre_count_0 [ j ] = pre_count_0 [ j - 1 ] ; pre_count_1 [ j ] = pre_count_1 [ j - 1 ] ; post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] ; if ( s [ j - 1 ] == '0' ) pre_count_0 [ j ] ++ ; else pre_count_1 [ j ] ++ ; if ( s [ n - j ] == '0' ) post_count_0 [ n - j + 1 ] ++ ; } if ( pre_count_0 [ n ] == n pre_count_0 [ n ] == 0 ) return n ; int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) ans = max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) ; return ans ; }
void removeSpecialCharacter ( string s ) { for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] < 'A' s [ i ] > 'Z' && s [ i ] < 'a' s [ i ] > 'z' ) { s . erase ( i , 1 ) ; i -- ; } } cout << s ; }
void imageSwap ( int mat [ ] [ MAX ] , int n ) { int row = 0 ; for ( int j = 0 ; j < n ; j ++ ) { stack < int > s ; int i = row , k = j ; while ( i < n && k >= 0 ) s . push ( mat [ i ++ ] [ k -- ] ) ; i = row , k = j ; while ( i < n && k >= 0 ) { mat [ i ++ ] [ k -- ] = s . top ( ) ; s . pop ( ) ; } } int column = n - 1 ; for ( int j = 1 ; j < n ; j ++ ) { stack < int > s ; int i = j , k = column ; while ( i < n && k >= 0 ) s . push ( mat [ i ++ ] [ k -- ] ) ; i = j ; k = column ; while ( i < n && k >= 0 ) { mat [ i ++ ] [ k -- ] = s . top ( ) ; s . pop ( ) ; } } }
bool shouldSwap ( char str [ ] , int start , int curr ) { for ( int i = start ; i < curr ; i ++ ) if ( str [ i ] == str [ curr ] ) return 0 ; return 1 ; }
string decodeMedianString ( string s ) { int l = s . length ( ) ; string s1 = "" ; bool isEven = ( l % 2 == 0 ) ? true : false ; for ( int i = 0 ; i < l ; i += 2 ) { if ( isEven ) { s1 = s [ i ] + s1 ; s1 += s [ i + 1 ] ; } else { if ( l - i > 1 ) { s1 += s [ i ] ; s1 = s [ i + 1 ] + s1 ; } else { s1 += s [ i ] ; } } } return s1 ; }
int maximumChars ( string & str ) { int n = str . length ( ) ; int res = -1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( str [ i ] == str [ j ] ) res = max ( res , abs ( j - i - 1 ) ) ; return res ; }
int maximumChars ( string & str ) { int n = str . length ( ) ; int res = -1 ; int firstInd [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) firstInd [ i ] = -1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_ind = firstInd [ str [ i ] ] ; if ( first_ind == -1 ) firstInd [ str [ i ] ] = i ; else res = max ( res , abs ( i - first_ind - 1 ) ) ; } return res ; }
bool isUnique ( int a [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum += n - 1 ; return ( sum == k ) ; }
void imageSwap ( int mat [ ] [ MAX ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j <= i ; j ++ ) mat [ i ] [ j ] = mat [ i ] [ j ] + mat [ j ] [ i ] - ( mat [ j ] [ i ] = mat [ i ] [ j ] ) ; }
bool isPresent ( string s , string q ) { int freq [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) freq [ s [ i ] ] ++ ; for ( int i = 0 ; i < q . length ( ) ; i ++ ) { freq [ q [ i ] ] -- ; if ( freq [ q [ i ] ] < 0 ) return false ; } return true ; }
string findString ( int n , int k ) { string res = "" ; for ( int i = 0 ; i < k ; i ++ ) res = res + ( char ) ( 'a' + i ) ; int count = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { res = res + ( char ) ( 'a' + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; }
bool isValid ( string p ) { int n = p . length ( ) ; int c1 = 0 , c0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] == '0' ) c0 ++ ; if ( p [ i ] == '1' ) c1 ++ ; } return ( c0 == c1 ) ? true : false ; }
int longestSub ( string s ) { int max_len = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( isValid ( s . substr ( i , j - i + 1 ) ) && max_len < j - i + 1 ) max_len = j - i + 1 ; } } return max_len ; }
bool isPalindrome ( string & s , int i , int j ) { int p = j ; for ( int k = i ; k <= p ; k ++ ) { if ( s [ k ] != s [ p ] ) return false ; p -- ; } return true ; }
int countWays ( string & s ) { int n = s . length ( ) ; int count = 0 ; if ( isPalindrome ( s , 0 , n - 1 ) ) { for ( int i = n / 2 ; i < n ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) count ++ ; else break ; } { count ++ ; } else  } else { for ( int i = 0 ; i < n / 2 ; i ++ ) { if ( s [ i ] != s [ n - 1 - i ] ) { int j = n - 1 - i ; if ( isPalindrome ( s , i , n - 2 - i ) ) { for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( s [ k ] != s [ j ] ) break ; count ++ ; } count ++ ; } if ( isPalindrome ( s , i + 1 , n - 1 - i ) ) { for ( int k = n - i ; k < n ; k ++ ) { if ( s [ k ] != s [ i ] ) break ; count ++ ; } count ++ ; } break ; } } } return count ; }
bool makeAndCheckString ( vector < string > words , string str ) { int n = words . size ( ) ; bool first = false , second = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( words [ i ] == str ) return true ; if ( str [ 0 ] == words [ i ] [ 1 ] ) first = true ; if ( str [ 1 ] == words [ i ] [ 0 ] ) second = true ; if ( first && second ) return true ; } return false ; }
int countOfSubstringWithKOnes ( string s , int K ) { int N = s . length ( ) ; int res = 0 ; int countOfOne = 0 ; int freq [ N + 1 ] = { 0 } ; freq [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { countOfOne += ( s [ i ] - '0' ) ; if ( countOfOne >= K ) { res += freq [ countOfOne - K ] ; } freq [ countOfOne ] ++ ; } return res ; }
void printRec ( string number , int extraOnes , int remainingPlaces ) { if ( 0 == remainingPlaces ) { cout << number << " " ; return ; } printRec ( number + "1" , extraOnes + 1 , remainingPlaces - 1 ) ; if ( 0 < extraOnes ) printRec ( number + "0" , extraOnes - 1 , remainingPlaces - 1 ) ; }
void printNums ( int n ) { string str = "" ; printRec ( str , 0 , n ) ; }
string getBinaryRep ( int N , int num_of_bits ) { string r = "" ; num_of_bits -- ; while ( num_of_bits >= 0 ) { if ( N & ( 1 << num_of_bits ) ) r . append ( "1" ) ; else r . append ( "0" ) ; num_of_bits -- ; } return r ; }
vector < string > NBitBinary ( int N ) { vector < string > r ; int first = 1 << ( N - 1 ) ; int last = first * 2 ; for ( int i = last - 1 ; i >= first ; -- i ) { int zero_cnt = 0 ; int one_cnt = 0 ; int t = i ; int num_of_bits = 0 ; while ( t ) { if ( t & 1 ) one_cnt ++ ; else zero_cnt ++ ; num_of_bits ++ ; t = t >> 1 ; } if ( one_cnt >= zero_cnt ) { bool all_prefix_match = true ; int msk = ( 1 << num_of_bits ) - 2 ; int prefix_shift = 1 ; while ( msk ) { int prefix = ( msk & i ) >> prefix_shift ; int prefix_one_cnt = 0 ; int prefix_zero_cnt = 0 ; while ( prefix ) { if ( prefix & 1 ) prefix_one_cnt ++ ; else prefix_zero_cnt ++ ; prefix = prefix >> 1 ; } if ( prefix_zero_cnt > prefix_one_cnt ) { all_prefix_match = false ; break ; } prefix_shift ++ ; msk = msk & ( msk << 1 ) ; } if ( all_prefix_match ) { r . push_back ( getBinaryRep ( i , num_of_bits ) ) ; } } } return r ; }
bool isPossible ( string & s1 , string & s2 ) { int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) count [ s2 [ i ] ] ++ ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( count [ s1 [ i ] ] == 0 ) return false ; count [ s1 [ i ] ] -- ; } return true ; }
bool checkLuhn ( const string & cardNo ) { int nDigits = cardNo . length ( ) ; int nSum = 0 , isSecond = false ; for ( int i = nDigits - 1 ; i >= 0 ; i -- ) { int d = cardNo [ i ] - '0' ; if ( isSecond == true ) d = d * 2 ; nSum += d / 10 ; nSum += d % 10 ; isSecond = ! isSecond ; } return ( nSum % 10 == 0 ) ; }
bool isVowel ( char ch ) { if ( ch == 'a' ch == 'e' ch == 'i' ch == 'o' ch == 'u' ) return true ; return false ; }
int findRepeatFirstN2 ( char * s ) { int p = -1 , i , j ; for ( i = 0 ; i < strlen ( s ) ; i ++ ) { for ( j = i + 1 ; j < strlen ( s ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != -1 ) break ; } return p ; }
bool isVowel ( char c ) { return ( c == 'a' c == 'e' c == 'i' c == 'o' c == 'u' ) ; }
bool isVowel ( char x ) { return ( x == 'a' x == 'e' x == 'i' x == 'o' x == 'u' ) ; }
bool isVowel ( char x ) { return ( x == 'a' x == 'e' x == 'i' x == 'o' x == 'u' ) ; }
int substrings ( string s , int k ) { for ( int i = 0 ; s [ i ] ; i ++ ) { int freq [ MAX_CHAR ] = { 0 } ; for ( int j = i ; s [ j ] ; j ++ ) { int index = s [ j ] - 'a' ; freq [ index ] ++ ; if ( freq [ index ] > k ) break ; else if ( freq [ index ] == k && check ( freq , k ) == true ) res ++ ; } } return res ; }
void longestSubseqWithK ( string str , int k ) { int n = str . size ( ) ; int freq [ MAX_CHARS ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) if ( freq [ str [ i ] - 'a' ] >= k ) cout << str [ i ] ; }
bool canFormPalindrome ( string str ) { int count [ NO_OF_CHARS ] = { 0 } ; for ( int i = 0 ; str [ i ] ; i ++ ) count [ str [ i ] ] ++ ; int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] & 1 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; }
void generate ( set < string > & st , string s ) { if ( s . size ( ) == 0 ) return ; if ( st . find ( s ) == st . end ( ) ) { st . insert ( s ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { string t = s ; t . erase ( i , 1 ) ; generate ( st , t ) ; } } return ; }
int countSubstrs ( string str , int i , int j , int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str [ i ] == str [ j ] ) res ++ ; return res ; }
int countManipulations ( string s1 , string s2 ) { int count = 0 ; int char_count [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { char_count [ i ] = 0 ; } for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) char_count [ s1 [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { char_count [ s2 [ i ] - 'a' ] -- ; } for ( int i = 0 ; i < 26 ; ++ i ) { if ( char_count [ i ] != 0 ) { count += abs ( char_count [ i ] ) ; } } return count / 2 ; }
char stringPalindrome ( string A , string B ) { int countA [ MAX_CHAR ] = { 0 } ; int countB [ MAX_CHAR ] = { 0 } ; int l1 = A . length ( ) , l2 = B . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) countA [ A [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) countB [ B [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( ( countA [ i ] > 1 && countB [ i ] == 0 ) ) return 'A' ; return 'B' ; }
bool check ( vector < string > list , string s ) { int n = ( int ) list . size ( ) ; if ( n == 0 ) return false ; for ( int i = 0 ; i < n ; i ++ ) { if ( list [ i ] . size ( ) != s . size ( ) ) continue ; bool diff = false ; for ( int j = 0 ; j < ( int ) list [ i ] . size ( ) ; j ++ ) { if ( list [ i ] [ j ] != s [ j ] ) { if ( ! diff ) diff = true ; else { diff = false ; break ; } } } if ( diff ) return true ; } return false ; }
int FirstRepeated ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str [ i ] - 'a' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return -1 ; }
int search ( int mat [ 4 ] [ 4 ] , int n , int x ) { if ( n == 0 ) return -1 ; int smallest = mat [ 0 ] [ 0 ] , largest = mat [ n - 1 ] [ n - 1 ] ; if ( x < smallest x > largest ) return -1 ; int i = 0 , j = n - 1  ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { cout << "n Found at " << i << ", " << j ; return 1 ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } cout << "n Element not found" ; return 0 ; }
void nPermute ( char str [ ] , int n ) { precomputeFactorials ( ) ; int len = strlen ( str ) ; int freq [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < len ; i ++ ) freq [ str [ i ] - 'a' ] ++ ; char out [ MAX_CHAR ] ; int sum = 0 ; int k = 0 ; while ( sum != n ) { sum = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( freq [ i ] == 0 ) continue ; freq [ i ] -- ; int xsum = fact [ len - 1 - k ] ; for ( int j = 0 ; j < MAX_CHAR ; j ++ ) xsum /= fact [ freq [ j ] ] ; sum += xsum ; if ( sum >= n ) { out [ k ++ ] = i + 'a' ; n -= ( sum - xsum ) ; break ; } if ( sum < n ) freq [ i ] ++ ; } } for ( int i = MAX_CHAR - 1 ; k < len && i >= 0 ; i -- ) if ( freq [ i ] ) { out [ k ++ ] = i + 'a' ; freq [ i ++ ] -- ; } out [ k ] = '\0' ; cout << out ; }
bool sentencePalindrome ( string str ) { int l = 0 , h = str . length ( ) - 1 ; for ( int i = 0 ; i <= h ; i ++ ) str [ i ] = tolower ( str [ i ] ) ; while ( l <= h ) { if ( ! ( str [ l ] >= 'a' && str [ l ] <= 'z' ) ) l ++ ; else if ( ! ( str [ h ] >= 'a' && str [ h ] <= 'z' ) ) h -- ; else if ( str [ l ] == str [ h ] ) l ++ , h -- ; else return false ; } return true ; }
int substringConversions ( string str , int k , int b ) { for ( int i = 0 ; i + k <= str . size ( ) ; i ++ ) { string sub = str . substr ( i , k ) ; int sum = 0 , counter = 0 ; for ( int i = sub . size ( ) - 1 ; i >= 0 ; i -- ) { sum = sum + ( ( sub . at ( i ) - '0' ) * pow ( b , counter ) ) ; counter ++ ; } cout << sum << " " ; } }
int countBalance ( char * str ) { int leftVisited [ MAX_CHAR ] = { 0 } ; int rightVisited [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) rightVisited [ str [ i ] ] ++ ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { leftVisited [ str [ i ] ] ++ ; rightVisited [ str [ i ] ] -- ; int j ; for ( j = 0 ; j < MAX_CHAR ; j ++ ) { if ( ( leftVisited [ j ] == 0 && rightVisited [ j ] != 0 ) || ( leftVisited [ j ] != 0 && rightVisited [ j ] == 0 ) ) break ; } if ( j == MAX_CHAR ) res ++ ; } return res ; }
int countWords ( string str [ ] , int n ) { unordered_map < string , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ str [ i ] ] += 1 ; int res = 0 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) if ( ( it -> second == 2 ) ) res ++ ; return res ; }
int findFlips ( char str [ ] , int n ) { char last = ' ' ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( last != str [ i ] ) res ++ ; last = str [ i ] ; } return res / 2 ; }
int findLen ( string & A , int n , int k , char ch ) { int maxlen = 1 ; int cnt = 0 ; int l = 0 , r = 0 ; while ( r < n ) { if ( A [ r ] != ch ) ++ cnt ; while ( cnt > k ) { if ( A [ l ] != ch ) -- cnt ; ++ l ; } maxlen = max ( maxlen , r - l + 1 ) ; ++ r ; } return maxlen ; }
int answer ( string & A , int n , int k ) { int maxlen = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) { maxlen = max ( maxlen , findLen ( A , n , k , i + 'A' ) ) ; maxlen = max ( maxlen , findLen ( A , n , k , i + 'a' ) ) ; } return maxlen ; }
void printString ( string str , char ch , int count ) { int occ = 0 , i ; if ( count == 0 ) { cout << str ; return ; } for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ch ) occ ++ ; if ( occ == count ) break ; } if ( i < str . length ( ) - 1 ) cout << str . substr ( i + 1 , str . length ( ) - ( i + 1 ) ) ; else cout << "Empty string" ; }
bool checkCorrectOrNot ( string s ) { int count1 [ MAX_CHAR ] = { 0 } ; int count2 [ MAX_CHAR ] = { 0 } ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count1 [ s [ i ] - 'a' ] ++ ; count2 [ s [ j ] - 'a' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; }
bool checkCorrectOrNot ( string s ) { int count [ MAX_CHAR ] = { 0 } ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count [ s [ i ] - 'a' ] ++ ; count [ s [ j ] - 'a' ] -- ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count [ i ] != 0 ) return false ; return true ; }
int possibleStrings ( int n , int r , int b , int g ) { int fact [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; }
bool checkString ( string s ) { int len = s . length ( ) ; int first = s . size ( ) + 1 ; for ( int i = 0 ; i < len ; i ++ ) { if ( s [ i ] == '1' ) { first = i ; break ; } } int last = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) { last = i ; break ; } } for ( int i = first ; i <= last ; i ++ ) if ( s [ i ] == '0' ) return false ; return true ; }
bool isVowel ( char c ) { return ( c == 'a' c == 'A' c == 'e' c == 'E' c == 'i' c == 'I' c == 'o' c == 'O' c == 'u' c == 'U' ) ; }
bool isUnique ( int mat [ ] [ MAX ] , int i , int j , int n , int m ) { int sumrow = 0 ; for ( int k = 0 ; k < m ; k ++ ) { sumrow += mat [ i ] [ k ] ; if ( sumrow > 1 ) return false ; } int sumcol = 0 ; for ( int k = 0 ; k < n ; k ++ ) { sumcol += mat [ k ] [ j ] ; if ( sumcol > 1 ) return false ; } return true ; }
void findAndPrintUncommonChars ( string str1 , string str2 ) { int present [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) present [ i ] = 0 ; int l1 = str1 . size ( ) ; int l2 = str2 . size ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) present [ str1 [ i ] - 'a' ] = 1 ; for ( int i = 0 ; i < l2 ; i ++ ) { if ( present [ str2 [ i ] - 'a' ] == 1 present [ str2 [ i ] - 'a' ] == -1 ) present [ str2 [ i ] - 'a' ] = -1 ; else present [ str2 [ i ] - 'a' ] = 2 ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( present [ i ] == 1 present [ i ] == 2 ) cout << ( char ( i + 'a' ) ) << " " ; }
int countUnique ( int mat [ ] [ MAX ] , int n , int m ) { int rowsum [ n ] , colsum [ m ] ; memset ( colsum , 0 , sizeof ( colsum ) ) ; memset ( rowsum , 0 , sizeof ( rowsum ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] ) { rowsum [ i ] ++ ; colsum [ j ] ++ ; } int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ; return uniquecount ; }
int lengthOfLastWord ( string a ) { int len = 0 ; string str ( a ) ; boost :: trim_right ( str ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . at ( i ) == ' ' ) len = 0 ; else len ++ ; } return len ; }
bool isVowel ( char ch ) { ch = toupper ( ch ) ; return ( ch == 'A' ch == 'E' ch == 'I' ch == 'O' ch == 'U' ) ; }
int countVowels ( string str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) ++ count ; return count ; }
int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; }
int countDistinctPermutations ( string str ) { int length = str . length ( ) ; int freq [ MAX_CHAR ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < length ; i ++ ) if ( str [ i ] >= 'a' ) freq [ str [ i ] - 'a' ] ++ ; int fact = 1 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) fact = fact * factorial ( freq [ i ] ) ; return factorial ( length ) / fact ; }
bool uniqueCharacters ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int bitAtIndex = str [ i ] - 'a' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } return true ; }
int solve ( int i , int X , int Y , int a [ ] , int b [ ] , int n ) { if ( i == n ) return 0 ; if ( X <= 0 ) return b [ i ] + solve ( i + 1 , X , Y - 1 , a , b , n ) ; if ( Y <= 0 ) return a [ i ] + solve ( i + 1 , X - 1 , Y , a , b , n ) ; else return max ( a [ i ] + solve ( i + 1 , X - 1 , Y , a , b , n ) , b [ i ] + solve ( i + 1 , X , Y - 1 , a , b , n ) ) ; }
char smallest_alphabet ( char a [ ] , int n ) { char min = 'z' ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( a [ i ] < min ) min = a [ i ] ; return min ; }
bool isPalindrome ( string str ) { int n = str . size ( ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) if ( str . at ( i ) != str . at ( n - i - 1 ) ) return false ; return true ; }
void moveSpaceInFront ( char str [ ] ) { int i = strlen ( str ) - 1 ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ' ) swap ( str [ i -- ] , str [ j ] ) ; }
int countCommon ( int mat [ ] [ MAX ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }
void moveSpaceInFront ( char str [ ] ) { int i = strlen ( str ) ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ' ) str [ i -- ] = str [ j ] ; while ( i >= 0 ) str [ i -- ] = ' ' ; }
int titleToNumber ( string s ) { int result = 0 ; for ( const auto & c : s ) { result *= 26 ; result += c - 'A' + 1 ; } return result ; }
void isKthBitSet ( int n , int k ) { if ( n & ( 1 << ( k - 1 ) ) ) cout << "SET" ; else cout << "NOT SET" ; }
void isKthBitSet ( int n , int k ) { if ( ( n >> ( k - 1 ) ) & 1 ) cout << "SET" ; else cout << "NOT SET" ; }
bool isPalindrome ( char str [ ] ) { int n = strlen ( str ) ; if ( n == 0 ) return true ; return isPalRec ( str , 0 , n - 1 ) ; }
bool areSumSame ( int a [ ] [ MAX ] , int n , int m ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 = 0 , sum2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return true ; } return false ; }
int getIdx ( char ch ) { return ( ch - 'a' ) ; }
bool allSame ( int freq [ ] , int N ) { int same ; int i ; for ( i = 0 ; i < N ; i ++ ) { if ( freq [ i ] > 0 ) { same = freq [ i ] ; break ; } } for ( int j = i + 1 ; j < N ; j ++ ) if ( freq [ j ] > 0 && freq [ j ] != same ) return false ; return true ; }
bool possibleSameCharFreqByOneRemoval ( string str ) { int l = str . length ( ) ; int freq [ M ] = { 0 } ; for ( int i = 0 ; i < l ; i ++ ) freq [ getIdx ( str [ i ] ) ] ++ ; if ( allSame ( freq , M ) ) return true ; for ( char c = 'a' ; c <= 'z' ; c ++ ) { int i = getIdx ( c ) ; if ( freq [ i ] > 0 ) { freq [ i ] -- ; if ( allSame ( freq , M ) ) return true ; freq [ i ] ++ ; } } return false ; }
int findIndex ( string str ) { int len = str . length ( ) ; int open [ len + 1 ] , close [ len + 1 ] ; int index = -1 ; memset ( open , 0 , sizeof ( open ) ) ; memset ( close , 0 , sizeof ( close ) ) ; open [ 0 ] = 0 ; close [ len ] = 0 ; if ( str [ 0 ] == '(' ) open [ 1 ] = 1 ; if ( str [ len - 1 ] == ')' ) close [ len - 1 ] = 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] == '(' ) open [ i + 1 ] = open [ i ] + 1 ; else open [ i + 1 ] = open [ i ] ; } for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] == ')' ) close [ i ] = close [ i + 1 ] + 1 ; else close [ i ] = close [ i + 1 ] ; } if ( open [ len ] == 0 ) return len ; if ( close [ 0 ] == 0 ) return 0 ; for ( int i = 0 ; i <= len ; i ++ ) if ( open [ i ] == close [ i ] ) index = i ; return index ; }
int checkEquality ( string s ) { return ( s [ 0 ] == s [ s . size ( ) - 1 ] ) ; }
int countSubstringWithEqualEnds ( string s ) { int result = 0 ; int n = s . length ( ) ; int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ s [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }
int getValue ( const string & str , int i , int m ) { if ( i + m > str . length ( ) ) return -1 ; int value = 0 ; for ( int j = 0 ; j < m ; j ++ ) { int c = str [ i + j ] - '0' ; if ( c < 0 c > 9 ) return -1 ; value = value * 10 + c ; } return value ; }
int findMissingNumber ( const string & str ) { for ( int m = 1 ; m <= MAX_DIGITS ; ++ m ) { int n = getValue ( str , 0 , m ) ; if ( n == -1 ) break ; int missingNo = -1 ; bool fail = false ; for ( int i = m ; i != str . length ( ) ; i += 1 + log10l ( n ) ) { if ( ( missingNo == -1 ) && ( getValue ( str , i , 1 + log10l ( n + 2 ) ) == n + 2 ) ) { missingNo = n + 1 ; n += 2 ; } else if ( getValue ( str , i , 1 + log10l ( n + 1 ) ) == n + 1 ) n ++ ; else { fail = true ; break ; } } if ( ! fail ) return missingNo ; } }
bool isSmaller ( string str1 , string str2 ) { int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; if ( n1 < n2 ) return true ; if ( n2 < n1 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( str1 [ i ] < str2 [ i ] ) return true ; else if ( str1 [ i ] > str2 [ i ] ) return false ; } return false ; }
char maxRepeating ( string str ) { int len = str . length ( ) ; int count = 0 ; char res = str [ 0 ] ; for ( int i = 0 ; i < len ; i ++ ) { int cur_count = 1 ; for ( int j = i + 1 ; j < len ; j ++ ) { if ( str [ i ] != str [ j ] ) break ; cur_count ++ ; } if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } } return res ; }
bool isSymmetric ( int mat [ ] [ MAX ] , int N ) { int tr [ N ] [ MAX ] ; transpose ( mat , tr , N ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != tr [ i ] [ j ] ) return false ; return true ; }
char maxRepeating ( string str ) { int n = str . length ( ) ; int count = 0 ; char res = str [ 0 ] ; int cur_count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } cur_count = 1 ; } } return res ; }
int check ( string str ) { int n = str . length ( ) ; int oddDigSum = 0 , evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str [ i ] - '0' ) ; else evenDigSum += ( str [ i ] - '0' ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }
bool isSubSequence ( string str1 , string str2 ) { int m = str1 . length ( ) , n = str2 . length ( ) ; for ( int i = 0 ; i < n && j < m ; i ++ ) if ( str1 [ j ] == str2 [ i ] ) j ++ ; return ( j == m ) ; }
bool isSymmetric ( int mat [ ] [ MAX ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; }
int countWords ( char str [ ] , int len ) { int count = 1 ; if ( len == 1 ) return count ; if ( str [ 0 ] == str [ 1 ] ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < len - 1 ; j ++ ) { if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1 ; else if ( str [ j ] == str [ j - 1 ] str [ j ] == str [ j + 1 ] str [ j - 1 ] == str [ j + 1 ] ) count *= 2 ; else count *= 3 ; } if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1 ; else count *= 2 ; return count ; }
int hammingDist ( char * str1 , char * str2 ) { int i = 0 , count = 0 ; while ( str1 [ i ] != '\0' ) { if ( str1 [ i ] != str2 [ i ] ) count ++ ; i ++ ; } return count ; }
int replaceDig ( int x , int from , int to ) { int result = 0 ; int multiply = 1 ; while ( x > 0 ) { int reminder = x % 10 ; if ( reminder == from ) result = result + to * multiply ; else result = result + reminder * multiply ; multiply *= 10 ; x = x / 10 ; } return result ; }
void calculateMinMaxSum ( int x1 , int x2 ) { int minSum = replaceDig ( x1 , 6 , 5 ) + replaceDig ( x2 , 6 , 5 ) ; int maxSum = replaceDig ( x1 , 5 , 6 ) + replaceDig ( x2 , 5 , 6 ) ; cout << "Minimum sum = " << minSum ; cout << "nMaximum sum = " << maxSum ; }
void qType2 ( int l , int r , char str [ ] ) { int freq [ 27 ] = { 0 } ; for ( int i = l - 1 ; i <= r - 1 ; i ++ ) freq [ str [ i ] - 'a' ] ++ ; int count = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) if ( freq [ j ] % 2 ) count ++ ; ( count <= 1 ) ? ( cout << "Yes" << endl ) : ( cout << "No" << endl ) ; }
void update ( int tree [ max ] [ 27 ] , int idx , int val , int i ) { while ( idx <= max ) { tree [ idx ] [ i ] += val ; idx += ( idx & - idx ) ; } }
void buildBIT ( int tree [ max ] [ 27 ] , char str [ ] , int n ) { memset ( tree , 0 , sizeof ( tree ) ) ; for ( int i = 0 ; i < n ; i ++ ) update ( tree , i + 1 , 1 , str [ i ] - 97 + 1 ) ; }
void precompute ( int mat [ MAX ] [ CHAR_SIZE ] , char str [ ] , int len ) { for ( int i = 0 ; i < CHAR_SIZE ; ++ i ) mat [ len ] [ i ] = len ; for ( int i = len - 1 ; i >= 0 ; -- i ) { for ( int j = 0 ; j < CHAR_SIZE ; ++ j ) mat [ i ] [ j ] = mat [ i + 1 ] [ j ] ; mat [ i ] [ str [ i ] - 'a' ] = i ; } }
bool query ( int mat [ MAX ] [ CHAR_SIZE ] , const char * str , int len ) { int pos = 0 ; for ( int i = 0 ; i < strlen ( str ) ; ++ i ) { if ( mat [ pos ] [ str [ i ] - 'a' ] >= len ) return false ; else pos = mat [ pos ] [ str [ i ] - 'a' ] + 1 ; } return true ; }
string findTwoscomplement ( string str ) { int n = str . length ( ) ; int i ; for ( i = n - 1 ; i >= 0 ; i -- ) if ( str [ i ] == '1' ) break ; if ( i == -1 ) return '1' + str ; for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( str [ k ] == '1' ) str [ k ] = '0' ; else str [ k ] = '1' ; } return str ; ; }
bool isequal ( string str ) { int n = str . length ( ) ; int num = 0 , x = 1 , i = n - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( '0' <= str [ i ] && str [ i ] <= '9' ) { num = ( str [ i ] - '0' ) * x + num ; x = x * 10 ; if ( num >= n ) return false ; } else break ; } return num == i + 1 ; }
bool arekAnagrams ( string str1 , string str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int count1 [ MAX_CHAR ] = { 0 } ; int count2 [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count1 [ str1 [ i ] - 'a' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) count2 [ str2 [ i ] - 'a' ] ++ ; int count = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + abs ( count1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; }
bool areKAnagrams ( string str1 , string str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int hash_str1 [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) hash_str1 [ str1 [ i ] - 'a' ] ++ ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash_str1 [ str2 [ i ] - 'a' ] > 0 ) hash_str1 [ str2 [ i ] - 'a' ] -- ; else count ++ ; if ( count > k ) return false ; } return true ; }
void countToMake0lternate ( const string & s ) { int result = 0 ; for ( int i = 0 ; i < ( s . length ( ) - 1 ) ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return result ; }
char getDigit ( int N , int d ) { string str ; stringstream ss ; ss << N ; ss >> str ; return str [ d - 1 ] ; }
char getNthChar ( int N ) { int sum = 0 , nine = 9 ; int dist = 0 , len ; for ( len = 1 ; ; len ++ ) { sum += nine * len ; dist += nine ; if ( sum >= N ) { sum -= nine * len ; dist -= nine ; N -= sum ; break ; } nine *= 10 ; } int diff = ceil ( ( double ) N / len ) ; int d = N % len ; if ( d == 0 ) d = len ; return getDigit ( dist + diff , d ) ; }
bool ispalindrome ( string s ) { int l = s . length ( ) ; int j ; for ( int i = 0 , j = l - 1 ; i <= j ; i ++ , j -- ) { if ( s [ i ] != s [ j ] ) return false ; } return true ; }
int findCount ( string str ) { int result = 0 ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) if ( i == ( str [ i ] - 'a' ) || i == ( str [ i ] - 'A' ) ) result ++ ; return result ; }
void sortByPattern ( string & str , string pat ) { int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str [ i ] - 'a' ] ++ ; int index = 0 ; for ( int i = 0 ; i < pat . length ( ) ; i ++ ) for ( int j = 0 ; j < count [ pat [ i ] - 'a' ] ; j ++ ) str [ index ++ ] = pat [ i ] ; }
char flip ( char ch ) { return ( ch == '0' ) ? '1' : '0' ; }
int getFlipWithStartingCharcter ( string str , char expected ) { int flipCount = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] != expected ) flipCount ++ ; expected = flip ( expected ) ; } return flipCount ; }
int minFlipToMakeStringAlternate ( string str ) { return min ( getFlipWithStartingCharcter ( str , '0' ) , getFlipWithStartingCharcter ( str , '1' ) ) ; }
int remAnagram ( string str1 , string str2 ) { int count1 [ CHARS ] = { 0 } , count2 [ CHARS ] = { 0 } ; for ( int i = 0 ; str1 [ i ] != '\0' ; i ++ ) count1 [ str1 [ i ] - 'a' ] ++ ; for ( int i = 0 ; str2 [ i ] != '\0' ; i ++ ) count2 [ str2 [ i ] - 'a' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += abs ( count1 [ i ] - count2 [ i ] ) ; return result ; }
bool isPalin ( string str ) { int len = str . length ( ) / 2 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] != str [ str . length ( ) - i - 1 ] ) return false ; } return true ; }
int remainderWith7 ( string num ) { int series [ ] = { 1 , 3 , 2 , -1 , -3 , -2 } ; int series_index = 0 ; for ( int i = num . size ( ) - 1 ; i >= 0 ; i -- ) { int digit = num [ i ] - '0' ; result += digit * series [ series_index ] ; series_index = ( series_index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; }
bool checkForVariation ( string str ) { if ( str . empty ( ) || str . length ( ) != 0 ) { return true ; } map < char , int > mapp ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { mapp [ str [ i ] ] ++ ; } bool first = true , second = true ; int val1 = 0 , val2 = 0 ; int countOfVal1 = 0 , countOfVal2 = 0 ; map < char , int > :: iterator itr ; for ( itr = mapp . begin ( ) ; itr != mapp . end ( ) ; ++ itr ) { int i = itr -> first ; if ( first ) { val1 = i ; first = false ; countOfVal1 ++ ; continue ; } if ( i == val1 ) { countOfVal1 ++ ; continue ; } if ( second ) { val2 = i ; countOfVal2 ++ ; second = false ; continue ; } if ( i == val2 ) { countOfVal2 ++ ; continue ; } return false ; } if ( countOfVal1 > 1 && countOfVal2 > 1 ) { return false ; } else { return true ; } }
void waysToPaint ( int n ) { int same = 6 ; int diff = 6 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long sameTmp = 3 * same + 2 * diff ; long diffTmp = 2 * same + 2 * diff ; same = sameTmp ; diff = diffTmp ; } cout << ( same + diff ) ; }
bool isReversible ( string str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; }
int findPossibleMoves ( int mat [ n ] [ m ] , int p , int q ) { int X [ 8 ] = { 2 , 1 , -1 , -2 , -2 , -1 , 1 , 2 } ; int Y [ 8 ] = { 1 , 2 , 2 , 1 , -1 , -2 , -2 , -1 } ; int count = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int x = p + X [ i ] ; int y = q + Y [ i ] ; if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) count ++ ; } return count ; }
int countCompletePairs ( string set1 [ ] , string set2 [ ] , int n , int m ) { int result = 0 ; int con_s1 [ n ] , con_s2 [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { con_s1 [ i ] = 0 ; for ( int j = 0 ; j < set1 [ i ] . length ( ) ; j ++ ) { con_s1 [ i ] = con_s1 [ i ] | ( 1 << ( set1 [ i ] [ j ] - 'a' ) ) ; } } for ( int i = 0 ; i < m ; i ++ ) { con_s2 [ i ] = 0 ; for ( int j = 0 ; j < set2 [ i ] . length ( ) ; j ++ ) { con_s2 [ i ] = con_s2 [ i ] | ( 1 << ( set2 [ i ] [ j ] - 'a' ) ) ; } } long long complete = ( 1 << 26 ) - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( con_s1 [ i ] con_s2 [ j ] ) == complete ) result ++ ; } } return result ; }
bool checkPattern ( string str , string pat ) { vector < int > label ( CHAR_SIZE , -1 ) ; int order = 1 ; for ( int i = 0 ; i < pat . length ( ) ; i ++ ) { label [ pat [ i ] ] = order ; order ++ ; } int last_order = -1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( label [ str [ i ] ] != -1 ) { if ( label [ str [ i ] ] < last_order ) return false ; last_order = label [ str [ i ] ] ; } } return true ; }
char encodedChar ( string str , int k ) { string expand = "" ; for ( int i = 0 ; str [ i ] != '\0' ; ) { while ( str [ i ] >= 'a' && str [ i ] <= 'z' ) { temp . push_back ( str [ i ] ) ; i ++ ; } while ( str [ i ] >= '1' && str [ i ] <= '9' ) { freq = freq * 10 + str [ i ] - '0' ; i ++ ; } for ( int j = 1 ; j <= freq ; j ++ ) expand . append ( temp ) ; } if ( freq == 0 ) expand . append ( temp ) ; return expand [ k - 1 ] ; }
void findMatchedWords ( unordered_set < string > dict , string pattern ) { int len = pattern . length ( ) ; string hash = encodeString ( pattern ) ; for ( string word : dict ) { if ( word . length ( ) == len && encodeString ( word ) == hash ) cout << word << " " ; } }
bool check ( string pattern , string word ) { if ( pattern . length ( ) != word . length ( ) ) return false ; char ch [ 128 ] = { 0 } ; int len = word . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ch [ pattern [ i ] ] == 0 ) ch [ pattern [ i ] ] = word [ i ] ; else if ( ch [ pattern [ i ] ] != word [ i ] ) return false ; } return true ; }
int findSum ( string str ) { string temp = "" ; int sum = 0 ; for ( char ch : str ) { if ( isdigit ( ch ) ) temp += ch ; else { sum += atoi ( temp . c_str ( ) ) ; temp = "" ; } } return sum + atoi ( temp . c_str ( ) ) ; }
int countkDist ( string str , int k ) { int n = str . length ( ) ; int res = 0 ; int cnt [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int dist_count = 0 ; memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int j = i ; j < n ; j ++ ) { if ( cnt [ str [ j ] - 'a' ] == 0 ) dist_count ++ ; cnt [ str [ j ] - 'a' ] ++ ; if ( dist_count == k ) res ++ ; if ( dist_count > k ) break ; } } return res ; }
string commonPrefixUtil ( string str1 , string str2 ) { string result ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; for ( int i = 0 , j = 0 ; i <= n1 - 1 && j <= n2 - 1 ; i ++ , j ++ ) { if ( str1 [ i ] != str2 [ j ] ) break ; result . push_back ( str1 [ i ] ) ; } return ( result ) ; }
string commonPrefix ( string arr [ ] , int low , int high ) { if ( low == high ) return ( arr [ low ] ) ; if ( high > low ) { int mid = low + ( high - low ) / 2 ; string str1 = commonPrefix ( arr , low , mid ) ; string str2 = commonPrefix ( arr , mid + 1 , high ) ; return ( commonPrefixUtil ( str1 , str2 ) ) ; } }
int countTriplets ( vector < int > & A ) { int cnt = 0 ; unordered_map < int , int > tuples ; for ( auto a : A ) for ( auto b : A ) ++ tuples [ a & b ] ; for ( auto a : A ) for ( auto t : tuples ) if ( ( t . first & a ) == 0 ) cnt += t . second ; return cnt ; }
bool isPalindrome ( const char * str ) { int l = 0 ; int h = strlen ( str ) - 1 ; while ( h > l ) if ( str [ l ++ ] != str [ h -- ] ) return false ; return true ; }
char flip ( char c ) { return ( c == '0' ) ? '1' : '0' ; }
string zigZagConcat ( string s , int n ) { if ( n <= 1 ) { return s ; } string result = "" ; for ( int rowNum = 0 ; rowNum < n ; rowNum ++ ) { int i = rowNum ; bool up = true ; while ( i < s . length ( ) ) { result += s [ i ] ; if ( rowNum == 0 rowNum == n - 1 ) { i += ( 2 * n - 2 ) ; } else { if ( up ) { i += ( 2 * ( n - rowNum ) - 2 ) ; } else { i += rowNum * 2 ; } up ^= true ; } } } return result ; }
bool isEditDistanceOne ( string s1 , string s2 ) { int m = s1 . length ( ) , n = s2 . length ( ) ; if ( abs ( m - n ) > 1 ) return false ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( s1 [ i ] != s2 [ j ] ) { if ( count == 1 ) return false ; if ( m > n ) i ++ ; else if ( m < n ) j ++ ; { i ++ ; j ++ ; } count ++ ; } { i ++ ; j ++ ; } } if ( i < m j < n ) count ++ ; return count == 1 ; }
int countOccurrences ( long int x , int d ) { while ( x ) { if ( x % 10 == d ) count ++ ; x = x / 10 ; } return count ; }
int maxOccurring ( long int x ) { if ( x < 0 ) x = - x ; for ( int d = 0 ; d <= 9 ; d ++ ) { int count = countOccurrences ( x , d ) ; if ( count >= max_count ) { max_count = count ; result = d ; } } return result ; }
int maxSubarrayXOR ( int arr [ ] , int n ) { int ans = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = max ( ans , curr_xor ) ; } } return ans ; }
int cntNum ( string X , int i , int sum , int tight , int dp [ M ] [ M ] [ 2 ] ) { if ( i >= X . length ( ) sum < 0 ) { if ( sum == 0 ) { return 1 ; } return 0 ; } if ( dp [ sum ] [ i ] [ tight ] != -1 ) { return dp [ sum ] [ i ] [ tight ] ; } int res = 0 ; int end = tight ? X [ i ] - '0' : 9 ; for ( int j = 0 ; j <= end ; j ++ ) { res += cntNum ( X , i + 1 , sum - j , ( tight & ( j == end ) ) , dp ) ; } return dp [ sum ] [ i ] [ tight ] = res ; }
int UtilCntNumRange ( int L , int R , int Y ) { if ( R == 0 && Y == 0 ) { return 1 ; } string str = to_string ( R ) ; int dp [ M ] [ M ] [ 2 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; int cntR = cntNum ( str , 0 , Y , true , dp ) ; str = to_string ( L - 1 ) ; memset ( dp , -1 , sizeof ( dp ) ) ; int cntL = cntNum ( str , 0 , Y , true , dp ) ; return ( cntR - cntL ) ; }
bool areIsomorphic ( string str1 , string str2 ) { int m = str1 . length ( ) , n = str2 . length ( ) ; if ( m != n ) return false ; bool marked [ MAX_CHARS ] = { false } ; int map [ MAX_CHARS ] ; memset ( map , -1 , sizeof ( map ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( map [ str1 [ i ] ] == -1 ) { if ( marked [ str2 [ i ] ] == true ) return false ; marked [ str2 [ i ] ] = true ; map [ str1 [ i ] ] = str2 [ i ] ; } else if ( map [ str1 [ i ] ] != str2 [ i ] ) return false ; } return true ; }
bool isPalin ( char str [ ] , int st , int end ) { while ( st < end ) { if ( str [ st ] != str [ end ] ) return false ; st ++ ; end -- ; } return true ; }
int findMinInsert ( char str [ ] , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( isPalin ( str , 0 , i ) ) return ( n - i - 1 ) ; } }
long int removeRecur ( long int n ) { int prev_digit = n % 10 ; long int pow = 10 ; long int res = prev_digit ; while ( n ) { int curr_digit = n % 10 ; if ( curr_digit != prev_digit ) { res += curr_digit * pow ; prev_digit = curr_digit ; pow *= 10 ; } n = n / 10 ; } return res ; }
void removeSpaces ( char * str ) { int count = 0 ; for ( int i = 0 ; str [ i ] ; i ++ ) if ( str [ i ] != ' ' ) str [ count ] = '\0' ; }
bool isValid ( int count [ ] , int k ) { int val = 0 ; for ( int i = 0 ; i < MAX_CHARS ; i ++ ) if ( count [ i ] > 0 ) val ++ ; return ( k >= val ) ; }
void kUniques ( string s , int k ) { int count [ MAX_CHARS ] ; memset ( count , 0 , sizeof ( count ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ s [ i ] - 'a' ] == 0 ) u ++ ; count [ s [ i ] - 'a' ] ++ ; } if ( u < k ) { cout << "Not enough unique characters" ; return ; } int curr_start = 0 , curr_end = 0 ; int max_window_size = 1 , max_window_start = 0 ; memset ( count , 0 , sizeof ( count ) ) ; count [ s [ 0 ] - 'a' ] ++ ; for ( int i = 1 ; i < n ; i ++ ) { count [ s [ i ] - 'a' ] ++ ; curr_end ++ ; while ( ! isValid ( count , k ) ) { count [ s [ curr_start ] - 'a' ] -- ; curr_start ++ ; } if ( curr_end - curr_start + 1 > max_window_size ) { max_window_size = curr_end - curr_start + 1 ; max_window_start = curr_start ; } } cout << "Max substring is : " << s . substr ( max_window_start , max_window_size ) << " with length " << max_window_size << endl ; }
bool canFormPalindrome ( string str ) { int count [ NO_OF_CHARS ] = { 0 } ; for ( int i = 0 ; str [ i ] ; i ++ ) count [ str [ i ] ] ++ ; int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] & 1 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; }
int count9s ( char number [ ] ) { int n = strlen ( number ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( number [ i ] == '9' ) count ++ ; for ( int j = i + 1 ; j < n ; j ++ ) { sum = ( sum + number [ j ] - '0' ) % 9 ; if ( sum == 0 ) count ++ ; } } return count ; }
int difference ( int arr [ ] [ MAX ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return abs ( d1 - d2 ) ; }
vector < string > generateGray ( int n ) { if ( n <= 0 ) return { "0" } ; if ( n == 1 ) { return { "0" , "1" } ; } vector < string > recAns = generateGray ( n - 1 ) ; vector < string > mainAns ; for ( int i = 0 ; i < recAns . size ( ) ; i ++ ) { string s = recAns [ i ] ; mainAns . push_back ( "0" + s ) ; } for ( int i = recAns . size ( ) - 1 ; i >= 0 ; i -- ) { string s = recAns [ i ] ; mainAns . push_back ( "1" + s ) ; } return mainAns ; }
bool areAnagram ( char * str1 , char * str2 ) { int count1 [ NO_OF_CHARS ] = { 0 } ; int count2 [ NO_OF_CHARS ] = { 0 } ; int i ; for ( i = 0 ; str1 [ i ] && str2 [ i ] ; i ++ ) { count1 [ str1 [ i ] ] ++ ; count2 [ str2 [ i ] ] ++ ; } if ( str1 [ i ] str2 [ i ] ) return false ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; }
bool areAnagram ( char * str1 , char * str2 ) { int count [ NO_OF_CHARS ] = { 0 } ; int i ; for ( i = 0 ; str1 [ i ] && str2 [ i ] ; i ++ ) { count [ str1 [ i ] ] ++ ; count [ str2 [ i ] ] -- ; } if ( str1 [ i ] str2 [ i ] ) return false ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count [ i ] ) return false ; return true ; }
int longestUniqueSubsttr ( string str ) { int n = str . size ( ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( areDistinct ( str , i , j ) ) res = max ( res , j - i + 1 ) ; return res ; }
int longestUniqueSubsttr ( string str ) { int n = str . size ( ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { vector < bool > visited ( 256 ) ; for ( int j = i ; j < n ; j ++ ) { if ( visited [ str [ j ] ] == true ) break ; else { res = max ( res , j - i + 1 ) ; visited [ str [ j ] ] = true ; } } visited [ str [ i ] ] = false ; } return res ; }
void spiralFill ( int m , int n , int a [ ] [ MAX ] ) { int val = 1 ; int k = 0 , l = 0 ; while ( k < m && l < n ) { for ( int i = l ; i < n ; ++ i ) a [ k ] [ i ] = val ++ ; k ++ ; for ( int i = k ; i < m ; ++ i ) a [ i ] [ n - 1 ] = val ++ ; n -- ; if ( k < m ) { for ( int i = n - 1 ; i >= l ; -- i ) a [ m - 1 ] [ i ] = val ++ ; m -- ; } if ( l < n ) { for ( int i = m - 1 ; i >= k ; -- i ) a [ i ] [ l ] = val ++ ; l ++ ; } } }
bool isValid ( vector < vector < int > > & board , int i , int j , int K ) { if ( board [ i ] [ j ] <= K ) { return true ; } return false ; }
bool findPath ( vector < vector < int > > & board , int X , int Y , int M , int N , int K ) { if ( X < 0 X == M Y < 0 Y == N  ) { return true ; } if ( isValid ( board , X , Y , K ) ) { int board_XY = board [ X ] [ Y ] ; board [ X ] [ Y ] = INT_MAX ; if ( findPath ( board , X + 1 , Y , M , N , K - board_XY ) || findPath ( board , X - 1 , Y , M , N , K - board_XY ) || findPath ( board , X , Y + 1 , M , N , K - board_XY ) || findPath ( board , X , Y - 1 , M , N , K - board_XY ) ) { return true ; } board [ X ] [ Y ] = board_XY ; } return false ; }
void pathMoves ( char mat [ ] [ COL ] , Point src , Point dest ) { int d [ ROW ] [ COL ] ; memset ( d , -1 , sizeof d ) ; d [ src . x ] [ src . y ] = 0 ; bool visited [ ROW ] [ COL ] ; memset ( visited , false , sizeof visited ) ; visited [ src . x ] [ src . y ] = true ; queue < Node > q ; Node s = { src , 0 } ; q . push ( s ) ; bool ok = false ; while ( ! q . empty ( ) ) { Node curr = q . front ( ) ; Point pt = curr . pt ; if ( pt . x == dest . x && pt . y == dest . y ) { int xx = pt . x , yy = pt . y ; int dist = curr . dist ; d [ pt . x ] [ pt . y ] = dist ; string pathmoves = "" ; while ( xx != src . x yy != src . y ) { if ( xx > 0 && d [ xx - 1 ] [ yy ] == dist - 1 ) { pathmoves += 'D' ; xx -- ; } if ( xx < ROW - 1 && d [ xx + 1 ] [ yy ] == dist - 1 ) { pathmoves += 'U' ; xx ++ ; } if ( yy > 0 && d [ xx ] [ yy - 1 ] == dist - 1 ) { pathmoves += 'R' ; yy -- ; } if ( yy < COL - 1 && d [ xx ] [ yy + 1 ] == dist - 1 ) { pathmoves += 'L' ; yy ++ ; } dist -- ; } reverse ( pathmoves . begin ( ) , pathmoves . end ( ) ) ; cout << pathmoves ; ok = true ; break ; } q . pop ( ) ; for ( int i = 0 ; i < 4 ; i ++ ) { int row = pt . x + dRow [ i ] ; int col = pt . y + dCol [ i ] ; if ( isValid ( row , col ) && ( mat [ row ] [ col ] == '1' mat [ row ] [ col ] == 's' mat [ row ] [ col ] == 'd' ) && ! visited [ row ] [ col ] ) { visited [ row ] [ col ] = true ; Node adjCell = { { row , col } , curr . dist + 1 } ; q . push ( adjCell ) ; d [ row ] [ col ] = curr . dist + 1 ; } } } if ( ! ok ) cout << -1 ; }
int isPerfect ( int x ) { int sum_div = 1 ; for ( int i = 2 ; i <= x / 2 ; ++ i ) { if ( x % i == 0 ) { sum_div += i ; } } if ( sum_div == x ) { return 1 ; } else return 0 ; }
int isPerfect ( int x ) { int sum_div = 1 ; for ( int i = 2 ; i <= x / 2 ; ++ i ) { if ( x % i == 0 ) { sum_div += i ; } } if ( sum_div == x ) { return 1 ; } else return 0 ; }
void subsetSum ( int arr [ ] , int n ) { long long total = 1 << n ; for ( long long i = 0 ; i < total ; i ++ ) { long long sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( i & ( 1 << j ) ) sum += arr [ j ] ; if ( isPerfect ( sum ) ) { cout << sum << " " ; } } }
void factorial ( int N ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; }
void printLevelOrder ( node * root ) { if ( ! root ) return ; queue < node * > q ; q . push ( root ) ; while ( ! q . empty ( ) ) { node * temp = q . front ( ) ; cout << temp -> data << " " ; q . pop ( ) ; if ( temp -> left != NULL ) { q . push ( temp -> left ) ; } else if ( temp -> right != NULL ) { cout << "NULL " ; } if ( temp -> right != NULL ) { q . push ( temp -> right ) ; } else if ( temp -> left != NULL ) { cout << "NULL " ; } } }
void PenGame ( int N ) { int P1 = 0 ; int P2 = 0 ; int X = 0 ; bool Move = 0 ; bool QuitP1 = 0 ; bool QuitP2 = 0 ; solve ( N , P1 , P2 , X , Move , QuitP1 , QuitP2 ) ; }
int findTrace ( int mat [ ] [ MAX ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += mat [ i ] [ i ] ; return sum ; }
void checkUntil ( int num , int K , int N , vector < int > & ans ) { if ( N == 1 ) { ans . push_back ( num ) ; return ; } if ( ( num % 10 + K ) <= 9 ) checkUntil ( 10 * num + ( num % 10 + K ) , K , N - 1 , ans ) ; if ( K ) { if ( ( num % 10 - K ) >= 0 ) checkUntil ( 10 * num + num % 10 - K , K , N - 1 , ans ) ; } }
void check ( int K , int N , vector < int > & ans ) { for ( int i = 1 ; i <= 9 ; i ++ ) { checkUntil ( i , K , N , ans ) ; } }
void comb ( int * arr , int len , int r , int ipos , int * op , int opos , int sum ) { if ( opos == r ) { int sum2 = 0 ; for ( int i = 0 ; i < opos ; i ++ ) { sum2 = sum2 + op [ i ] ; } if ( sum == sum2 ) { for ( int i = 0 ; i < opos ; i ++ ) cout << op [ i ] << ", " ; cout << endl ; } return ; } if ( ipos < len ) { comb ( arr , len , r , ipos + 1 , op , opos , sum ) ; op [ opos ] = arr [ ipos ] ; comb ( arr , len , r , ipos + 1 , op , opos + 1 , sum ) ; } }
void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
void primeCliques ( int i , int l , bool prime [ ] ) { for ( int j = i + 1 ; j <= n ; j ++ ) { store [ l ] = j ; if ( is_clique ( l + 1 ) ) { if ( prime [ l ] ) ans ++ ; primeCliques ( j , l + 1 , prime ) ; } } }
int countWays ( int mtrx [ ] [ 11 ] , int vrtx , int i , int dest , bool visited [ ] ) { if ( i == dest ) { return 1 ; } int total = 0 ; for ( int j = 0 ; j < vrtx ; j ++ ) { if ( mtrx [ i ] [ j ] == 1 && ! visited [ j ] ) { visited [ j ] = true ; total += countWays ( mtrx , vrtx , j , dest , visited ) ; visited [ j ] = false ; } } return total ; }
int totalWays ( int mtrx [ ] [ 11 ] , int vrtx , int src , int dest ) { bool visited [ vrtx ] ; for ( int i = 0 ; i < vrtx ; i ++ ) { visited [ i ] = false ; } visited [ src ] = true ; return countWays ( mtrx , vrtx , src , dest , visited ) ; }
int minOperation ( bool arr [ N ] [ M ] ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == 0 ) { ans ++ ; for ( int k = 0 ; k <= i ; k ++ ) { for ( int h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == 1 ) arr [ k ] [ h ] = 0 ; else arr [ k ] [ h ] = 1 ; } } } } } return ans ; }
int find_x ( int n ) { if ( n == 1 ) return 1 ; double num , den , p ; num = log10 ( n ) ; int x , no ; for ( int i = 2 ; i <= n ; i ++ ) { den = log10 ( i ) ; p = num / den ; no = ( int ) ( pow ( i , int ( p ) ) ) ; if ( abs ( no - n ) < 1e-6 ) { x = i ; break ; } } return x ; }
bool is_key ( int n , int x ) { double p ; p = log10 ( n ) / log10 ( x ) ; int no = ( int ) ( pow ( x , int ( p ) ) ) ; if ( n == no ) return true ; return false ; }
int evenPaths ( struct Node * node , int count , int x ) { if ( node == NULL || ! is_key ( node -> key , x ) ) { return count ; } if ( ! node -> left && ! node -> right ) { count ++ ; } count = evenPaths ( node -> left , count , x ) ; return evenPaths ( node -> right , count , x ) ; }
void dfs ( int a , int b , vector < int > v [ ] , int vis [ ] ) { vis [ a ] = 1 ; c ++ ; for ( auto i : v [ a ] ) { if ( ! vis [ i ] && i != b ) dfs ( i , b , v , vis ) ; } }
void printExistPath ( stack < int > sx , stack < int > sy , int last ) { if ( sx . empty ( ) || sy . empty ( ) ) { return ; } int x = sx . top ( ) ; int y = sy . top ( ) ; sx . pop ( ) ; sy . pop ( ) ; printExistPath ( sx , sy , last ) ; if ( sx . size ( ) == last - 1 ) { cout << "(" << x << ", " << y << ")" ; } else { cout << "(" << x << ", " << y << ") -> " ; } }
bool storePath ( int srcX , int srcY , int destX , int destY , stack < int > & sx , stack < int > & sy ) { if ( srcX > destX srcY > destY ) { return false ; } sx . push ( srcX ) ; sy . push ( srcY ) ; if ( srcX == destX && srcY == destY ) { printExistPath ( sx , sy , sx . size ( ) ) ; return true ; } if ( storePath ( ( 2 * srcX ) + srcY , srcY , destX , destY , sx , sy ) ) { return true ; } if ( storePath ( srcX , ( 2 * srcY ) + srcX , destX , destY , sx , sy ) ) { return true ; } sx . pop ( ) ; sy . pop ( ) ; return false ; }
bool isPathExist ( int srcX , int srcY , int destX , int destY ) { stack < int > sx ; stack < int > sy ; return storePath ( srcX , srcY , destX , destY , sx , sy ) ; }
void printPath ( int srcX , int srcY , int destX , int destY ) { if ( ! isPathExist ( srcX , srcY , destX , destY ) ) { cout << "-1" ; } }
void dfs ( int v ) { col [ v ] = 1 ; for ( auto p : g [ v ] ) { int to = p . first , id = p . second ; if ( col [ to ] == 0 ) { dfs ( to ) ; res [ id ] = 1 ; } else if ( col [ to ] == 2 ) { res [ id ] = 1 ; } else { res [ id ] = 2 ; cyc = true ; } } col [ v ] = 2 ; }
void sumSubsets ( vector < int > set , int n , int target ) { int x [ set . size ( ) ] ; int j = set . size ( ) - 1 ; while ( n > 0 ) { x [ j ] = n % 2 ; n = n / 2 ; j -- ; } int sum = 0 ; for ( int i = 0 ; i < set . size ( ) ; i ++ ) if ( x [ i ] == 1 ) sum = sum + set [ i ] ; if ( sum == target ) { cout << ( "{" ) ; for ( int i = 0 ; i < set . size ( ) ; i ++ ) if ( x [ i ] == 1 ) cout << set [ i ] << ", " ; cout << ( "}, " ) ; } }
void findSubsets ( vector < int > arr , int K ) { int x = pow ( 2 , arr . size ( ) ) ; for ( int i = 1 ; i < x ; i ++ ) sumSubsets ( arr , i , K ) ; }
int ncr ( int n , int r ) { return ( fact [ n ] / fact [ r ] ) / fact [ n - r ] ; }
int findSum ( int * arr , int n ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; int mul = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) mul += ( int ) pow ( 2 , i ) * ncr ( n - 1 , i ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += mul * arr [ i ] ; return ans ; }
int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; }
int solve ( int maze [ ] [ C ] ) { int ans = numberOfPaths ( R , C ) - countPaths ( maze ) ; return ans ; }
void dfs1 ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent [ u ] . size ( ) ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] ) { temp ++ ; parent [ adjacent [ u ] [ i ] ] = u ; dfs1 ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; endnode = u ; } } }
void dfs2 ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent [ u ] . size ( ) ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] && ! vis [ adjacent [ u ] [ i ] ] ) { temp ++ ; dfs2 ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; thirdnode = u ; } } }
void findNodes ( ) { dfs ( 1 , 0 ) ; for ( int i = 0 ; i <= N ; i ++ ) visited [ i ] = false ; maxi = -1 ; dfs1 ( startnode , 0 ) ; for ( int i = 0 ; i <= N ; i ++ ) visited [ i ] = false ; int x = endnode ; vis [ startnode ] = true ; while ( x != startnode ) { vis [ x ] = true ; x = parent [ x ] ; } maxi = -1 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( vis [ i ] ) dfs2 ( i , 0 ) ; } }
void dfsUtil ( int u , int node , bool visited [ ] , vector < pair < int , int > > road_used , int parent , int it ) { int c = 0 ; for ( int i = 0 ; i < node ; i ++ ) if ( visited [ i ] ) c ++ ; if ( c == node ) return ; visited [ u ] = true ; road_used . push_back ( { parent , u } ) ; cout << u << " " ; for ( int x : adj [ u ] ) { if ( ! visited [ x ] ) dfsUtil ( x , node , visited , road_used , u , it + 1 ) ; } for ( auto y : road_used ) if ( y . second == u ) dfsUtil ( y . first , node , visited , road_used , u , it + 1 ) ; }
void dfs ( int node ) { bool visited [ node ] ; vector < pair < int , int > > road_used ; for ( int i = 0 ; i < node ; i ++ ) visited [ i ] = false ; dfsUtil ( 0 , node , visited , road_used , -1 , 0 ) ; }
void primeSum ( int total , int N , int S , int index ) { if ( total == S && set . size ( ) == N ) { display ( ) ; return ; } if ( total > S || index == prime . size ( ) ) return ; set . push_back ( prime [ index ] ) ; primeSum ( total + prime [ index ] , N , S , index + 1 ) ; set . pop_back ( ) ; primeSum ( total , N , S , index + 1 ) ; }
void allPrime ( int N , int S , int P ) { for ( int i = P + 1 ; i <= S ; i ++ ) { if ( isPrime ( i ) ) prime . push_back ( i ) ; } if ( prime . size ( ) < N ) return ; primeSum ( 0 , N , S , 0 ) ; }
vector < int > grayCodes ( int n ) { vector < int > res ; int num = 0 ; grayCodeUtil ( res , n , num ) ; return res ; }
bool isParenthesis ( char c ) { return ( ( c == '(' ) || ( c == ')' ) ) ; }
bool isValidString ( string str ) { int cnt = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == '(' ) cnt ++ ; else if ( str [ i ] == ')' ) cnt -- ; if ( cnt < 0 ) return false ; } return ( cnt == 0 ) ; }
int findSum ( int n ) { int ans = 0 , temp = 0 , num ; for ( int i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; }
bool isSafe ( int grid [ N ] [ N ] , int row , int col , int num ) { for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ row ] [ x ] == num ) return false ; for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ x ] [ col ] == num ) return false ; int startRow = row - row % 3 , startCol = col - col % 3 ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) if ( grid [ i + startRow ] [ j + startCol ] == num ) return false ; return true ; }
bool solveSuduko ( int grid [ N ] [ N ] , int row , int col ) { if ( row == N - 1 && col == N ) return true ; if ( col == N ) { row ++ ; col = 0 ; } if ( grid [ row ] [ col ] > 0 ) return solveSuduko ( grid , row , col + 1 ) ; for ( int num = 1 ; num <= N ; num ++ ) { if ( isSafe ( grid , row , col , num ) ) { grid [ row ] [ col ] = num ; if ( solveSuduko ( grid , row , col + 1 ) ) return true ; } grid [ row ] [ col ] = 0 ; } return false ; }
long long int fact ( long long int n ) { long long int ans = 1 ; for ( long long int i = 2 ; i <= n ; i ++ ) ans *= i ; return ans ; }
long long int remainder ( long long int n , long long int a , long long int p ) { long long int len = fact ( n ) ; long long int ans = 1 ; for ( long long int i = 1 ; i <= len ; i ++ ) ans = ( ans * a ) % p ; return ans ; }
long long int power ( long long x , long long int y , long long int p ) { long long int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
long long int remainder ( long long int n , long long int a , long long int p ) { long long int ans = a % p ; for ( long long int i = 1 ; i <= n ; i ++ ) ans = power ( ans , i , p ) ; return ans ; }
bool check ( int n , int w ) { vector < int > a ( 105 ) ; int p = 0 ; while ( n > 0 ) { a [ p ++ ] = n % w ; n /= w ; } bool flag = true ; for ( int i = 0 ; i <= 100 ; i ++ ) { if ( a [ i ] == 0 a [ i ] == 1 ) continue ; else if ( a [ i ] == w a [ i ] == w - 1 ) a [ i + 1 ] ++ ; else flag = false ; } return flag ; }
int numPairs ( int a [ ] , int n ) { int ans , i , index ; ans = 0 ; for ( i = 0 ; i < n ; i ++ ) a [ i ] = abs ( a [ i ] ) ; sort ( a , a + n ) ; for ( i = 0 ; i < n ; i ++ ) { index = upper_bound ( a , a + n , 2 * a [ i ] ) - a ; ans += index - i - 1 ; } return ans ; }
int exponentMod ( int A , int B ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; long long y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 ) ; y = ( y * y ) % mod ; } else { y = A % mod ; y = ( y * exponentMod ( A , B - 1 ) % mod ) % mod ; } return ( int ) ( ( y + mod ) % mod ) ; }
void countWays ( int N ) { long long select = exponentMod ( 2 , N - 1 ) ; long long ways = ( ( N % mod ) * ( select % mod ) ) ; ways %= mod ; cout << ways ; }
int findSum ( int n ) { int arr [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = abs ( i - j ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }
int MaxUtil ( int * st , int ss , int se , int l , int r , int node ) { if ( l <= ss && r >= se ) return st [ node ] ; if ( se < l ss > r ) return -1 ; int mid = getMid ( ss , se )  ; return max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) ; }
int count ( int arr [ ] , int low , int high , int x ) { if ( ( low > high ) || ( low == high && arr [ low ] != x ) ) return 0 ; if ( low == high && arr [ low ] == x ) return 1 ; return count ( arr , low , ( low + high ) / 2 , x ) + count ( arr , 1 + ( low + high ) / 2 , high , x ) ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
vector < vector < double > > matrix_product ( vector < vector < double > > a , vector < vector < double > > b ) { vector < vector < double > > c ( 7 ) ; for ( int i = 0 ; i < 7 ; i ++ ) c [ i ] . resize ( 7 , 0 ) ; for ( int i = 0 ; i < 7 ; i ++ ) for ( int j = 0 ; j < 7 ; j ++ ) for ( int k = 0 ; k < 7 ; k ++ ) c [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; return c ; }
vector < vector < double > > mul_expo ( vector < vector < double > > mul , int p ) { vector < vector < double > > s = { { 1 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 1 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 1 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 1 } } ; while ( p != 1 ) { if ( p % 2 == 1 ) s = matrix_product ( s , mul ) ; mul = matrix_product ( mul , mul ) ; p /= 2 ; } return matrix_product ( mul , s ) ; }
double expectedSteps ( int x ) { if ( x == 0 ) return 0 ; if ( x <= 6 ) return 6 ; vector < vector < double > > mul = { { ( double ) 7 / 6 , 1 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 1 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 1 } , { ( double ) -1 / 6 , 0 , 0 , 0 , 0 , 0 , 0 } } ; mul = mul_expo ( mul , x - 6 ) ; return ( mul [ 0 ] [ 0 ] + mul [ 1 ] [ 0 ] + mul [ 2 ] [ 0 ] + mul [ 3 ] [ 0 ] + mul [ 4 ] [ 0 ] + mul [ 5 ] [ 0 ] ) * 6 ; }
int maxDistance ( int cell [ ] , int n , int p ) { sort ( cell , cell + n ) ; int start = 0 ; int end = cell [ n - 1 ] - cell [ 0 ] ; int ans = 0 ; while ( start <= end ) { int mid = start + ( ( end - start ) / 2 ) ; if ( canPlace ( cell , n , p , mid ) ) { ans = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } return ans ; }
pair < int , int > solve ( int n ) { int low = 1 , high = 1e4 , x = n , p = 0 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = ( mid * ( mid + 1 ) ) / 2 ; if ( x - sum >= 1 ) { p = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } int start = 1 , end = 1e4 , y = 1 , q = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int sum = ( mid * ( mid + 1 ) ) / 2 ; if ( y + sum <= n ) { q = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } x = x - ( p * ( p + 1 ) ) / 2 ; y = y + ( q * ( q + 1 ) ) / 2 ; int r = x ; int c = q + 1 - n + y ; pair < int , int > ans = { r , c } ; return ans ; }
int build ( int l , int r , int in , int * arr ) { if ( l == r ) return seg [ in ] = arr [ l ] ; int mid = ( l + r ) / 2 ; return seg [ in ] = __gcd ( build ( l , mid , 2 * in + 1 , arr ) , build ( mid + 1 , r , 2 * in + 2 , arr ) ) ; }
int query ( int l , int r , int l1 , int r1 , int in ) { if ( l1 <= l and r <= r1 ) return seg [ in ] ; if ( l > r1 or r < l1 ) return 0 ; int mid = ( l + r ) / 2 ; return __gcd ( query ( l , mid , l1 , r1 , 2 * in + 1 ) , query ( mid + 1 , r , l1 , r1 , 2 * in + 2 ) ) ; }
int findLen ( int * arr , int n ) { build ( 0 , n - 1 , 0 , arr ) ; int i = 0 , j = 0 ; int ans = INT_MAX ; while ( i < n ) { while ( j < n and query ( 0 , n - 1 , i , j , 0 ) != 1 ) j ++ ; if ( j == n ) break ; ans = min ( ( j - i + 1 ) , ans ) ; i ++ ; j = max ( j , i ) ; } if ( ans == INT_MAX ) return -1 ; else return ans ; }
int mergeSort ( int arr [ ] , int array_size ) { int temp [ array_size ] ; return _mergeSort ( arr , temp , 0 , array_size - 1 ) ; }
int merge ( int arr [ ] , int temp [ ] , int left , int mid , int right ) { int i , j , k ; int inv_count = 0 ; i = left ; j = mid ; k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] > 2 * arr [ j ] ) { inv_count += ( mid - i ) ; j ++ ; } else { i ++ ; } } i = left ; j = mid ; k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) { temp [ k ++ ] = arr [ i ++ ] ; } else { temp [ k ++ ] = arr [ j ++ ] ; } } while ( i <= mid - 1 ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= right ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = left ; i <= right ; i ++ ) arr [ i ] = temp [ i ] ; return inv_count ; }
void findGrid ( int n ) { int arr [ n ] [ n ] ; int x = 0 ; for ( int i = 0 ; i < n / 4 ; i ++ ) { for ( int j = 0 ; j < n / 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { for ( int l = 0 ; l < 4 ; l ++ ) { arr [ i * 4 + k ] [ j * 4 + l ] = x ; x ++ ; } } } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << arr [ i ] [ j ] << " " ; } cout << "\n" ; } }
int buildTree ( int l , int r , int i , int * arr ) { if ( l == r ) { segtree [ i ] = l ; return l ; } int l1 = buildTree ( l , ( l + r ) / 2 , 2 * i + 1 , arr ) ; int r1 = buildTree ( ( l + r ) / 2 + 1 , r , 2 * i + 2 , arr ) ; if ( arr [ l1 ] > arr [ r1 ] ) segtree [ i ] = l1 ; else segtree [ i ] = r1 ; return segtree [ i ] ; }
int rangeMax ( int l , int r , int rl , int rr , int i , int * arr ) { if ( r < rl l > rr ) return -1 ; if ( l >= rl and r <= rr )  return segtree [ i ] ; int l1 = rangeMax ( l , ( l + r ) / 2 , rl , rr , 2 * i + 1 , arr ) ; int r1 = rangeMax ( ( l + r ) / 2 + 1 , r , rl , rr , 2 * i + 2 , arr ) ; if ( l1 == -1 ) return r1 ; if ( r1 == -1 ) return l1 ; if ( arr [ l1 ] > arr [ r1 ] ) return l1 ; else return r1 ; }
void inorder ( node * curr ) { if ( curr == NULL ) return ; inorder ( curr -> left ) ; cout << curr -> data << " " ; inorder ( curr -> right ) ; }
int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
int kthSmallest ( int * arr , int k , int n ) { int low = * min_element ( arr , arr + n ) ; int high = * max_element ( arr , arr + n ) ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; int countless = 0 , countequal = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] < mid ) ++ countless ; else if ( arr [ i ] == mid ) ++ countequal ; } if ( countless < k && ( countless + countequal ) >= k ) { return mid ; } else if ( countless >= k ) { high = mid - 1 ; } else if ( countless < k && countless + countequal < k ) { low = mid + 1 ; } } }
void update ( int x , int y , int value , int id , int l , int r ) { if ( x >= r or l >= y ) return ; if ( x <= l && r <= y ) { lazy [ id ] = value ; return ; } int mid = ( l + r ) / 2 ; if ( lazy [ id ] ) lazy [ 2 * id ] = lazy [ 2 * id + 1 ] = lazy [ id ] ; lazy [ id ] = 0 ; update ( x , y , value , 2 * id , l , mid ) ; update ( x , y , value , 2 * id + 1 , mid , r ) ; }
void query ( int id , int l , int r ) { if ( lazy [ id ] ) { se . insert ( lazy [ id ] ) ; return ; } if ( r - l < 2 ) return ; int mid = ( l + r ) / 2 ; query ( 2 * id , l , mid ) ; query ( 2 * id + 1 , mid , r ) ; }
void updateRangeUtil ( int si , int ss , int se , int us , int ue , int diff ) { if ( lazy [ si ] != 0 ) { tree [ si ] += lazy [ si ] ; if ( ss != se ) { lazy [ si * 2 + 1 ] += lazy [ si ] ; lazy [ si * 2 + 2 ] += lazy [ si ] ; } lazy [ si ] = 0 ; } if ( ss > se ss > ue se < us ) return ; if ( ss >= us && se <= ue ) { tree [ si ] += diff ; if ( ss != se ) { lazy [ si * 2 + 1 ] += diff ; lazy [ si * 2 + 2 ] += diff ; } return ; } int mid = ( ss + se ) / 2 ; updateRangeUtil ( si * 2 + 1 , ss , mid , us , ue , diff ) ; updateRangeUtil ( si * 2 + 2 , mid + 1 , se , us , ue , diff ) ; tree [ si ] = max ( tree [ si * 2 + 1 ] , tree [ si * 2 + 2 ] ) ; }
void updateRange ( int n , int us , int ue , int diff ) { updateRangeUtil ( 0 , 0 , n - 1 , us , ue , diff ) ; }
void constructSTUtil ( int arr [ ] , int ss , int se , int si ) { if ( ss > se ) return ; if ( ss == se ) { tree [ si ] = arr [ ss ] ; return ; } int mid = ( ss + se ) / 2 ; constructSTUtil ( arr , ss , mid , si * 2 + 1 ) ; constructSTUtil ( arr , mid + 1 , se , si * 2 + 2 ) ; tree [ si ] = max ( tree [ si * 2 + 1 ] , tree [ si * 2 + 2 ] ) ; }
void constructST ( int arr [ ] , int n ) { constructSTUtil ( arr , 0 , n - 1 , 0 ) ; }
int getCount ( int n ) { int count = 1 ; while ( n != 0 ) { int leadDigit = firstDigit ( n ) ; n -= leadDigit ; count ++ ; } return count ; }
int getLargestNumber ( int k ) { int left = k ; int right = k * 10 ; int mid = ( left + right ) / 2 ; int len = getCount ( mid ) ; while ( len != k ) { mid = ( left + right ) / 2 ; len = getCount ( mid ) ; if ( len > k ) { right = mid ; } else { left = mid ; } } while ( len == k ) { if ( len != getCount ( mid + 1 ) ) { break ; } mid ++ ; } return ( mid ) ; }
ll F ( ll A , ll B ) { if ( A == 1 ) return ( 4 % B ) ; else { ll temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } }
int power ( int x , unsigned int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
void checkHV ( int arr [ ] [ MAX ] , int N , int M ) { bool horizontal = true , vertical = true ; for ( int i = 0 , k = N - 1 ; i < N / 2 ; i ++ , k -- ) { for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { horizontal = false ; break ; } } } for ( int i = 0 , k = M - 1 ; i < M / 2 ; i ++ , k -- ) { for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { vertical = false ; break ; } } } if ( ! horizontal && ! vertical ) cout << "NO\n" ; else if ( horizontal && ! vertical ) cout << "HORIZONTAL\n" ; else if ( vertical && ! horizontal ) cout << "VERTICAL\n" ; else cout << "BOTH\n" ; }
int rangeSum ( int l , int r ) { int a = 1 , b = 9 , res = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int L = max ( l , a ) ; int R = min ( r , b ) ; if ( L <= R ) { int sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( i * i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
int getSetBitsFromOneToN ( int N ) { int two = 2 , ans = 0 ; int n = N ; while ( n ) { ans += ( N / two ) * ( two >> 1 ) ; if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 ; two <<= 1 ; n >>= 1 ; } return ans ; }
int findMinimum ( int x ) { int low = 0 , high = 100000 ; int ans = high ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( getSetBitsFromOneToN ( mid ) >= x ) { ans = min ( ans , mid ) ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; }
int exponentMod ( int A , int B , int C ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; long y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; } else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return ( int ) ( ( y + C ) % C ) ; }
int trailingZeroes ( int n ) { int cnt = 0 ; while ( n > 0 ) { n /= 5 ; cnt += n ; } return cnt ; }
void binarySearch ( int n ) { int low = 0 ; while ( low < high ) { int mid = ( low + high ) / 2 ; int count = trailingZeroes ( mid ) ; if ( count < n ) low = mid + 1 ; else high = mid ; } vector < int > result ; while ( trailingZeroes ( low ) == n ) { result . push_back ( low ) ; low ++ ; } for ( int i = 0 ; i < result . size ( ) ; i ++ ) cout << result [ i ] << " " ; }
int maxDet ( int n ) { return ( 2 * n * n * n ) ; }
void resMatrix ( int n ) { for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { if ( i == 0 && j == 2 ) cout << "0 " ; else if ( i == 1 && j == 0 ) cout << "0 " ; else if ( i == 2 && j == 1 ) cout << "0 " ; else cout << n << " " ; } cout << "\n" ; } }
int getCumulateSum ( int n ) { return ( n * ( n + 1 ) ) / 2 ; }
int minDaysToEmpty ( int C , int l ) { if ( C <= l ) return C ; int lo = 0 ; int hi = 1e4 ; int mid ; while ( lo < hi ) { mid = ( lo + hi ) / 2 ; if ( getCumulateSum ( mid ) >= ( C - l ) ) hi = mid ; else lo = mid + 1 ; } return ( l + lo ) ; }
int minDaysToEmpty ( int C , int l ) { if ( l >= C ) return C ; double eq_root = ( std :: sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return std :: ceil ( eq_root ) + l ; }
void shuffleArray ( int a [ ] , int n ) { for ( int i = 0 , q = 1 , k = n ; i < n ; i ++ , k ++ , q ++ ) for ( int j = k ; j > i + q ; j -- ) swap ( a [ j - 1 ] , a [ j ] ) ; }
int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) { int sorted1 [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; }
int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }
void binarySearch ( int mat [ ] [ MAX ] , int i , int j_low , int j_high , int x ) { while ( j_low <= j_high ) { int j_mid = ( j_low + j_high ) / 2 ; if ( mat [ i ] [ j_mid ] == x ) { cout << "Found at (" << i << ", " << j_mid << ")" ; return ; } else if ( mat [ i ] [ j_mid ] > x ) j_high = j_mid - 1 ; else j_low = j_mid + 1 ; } cout << "Element no found" ; }
void sortedMatrixSearch ( int mat [ ] [ MAX ] , int n , int m , int x ) { if ( n == 1 ) { binarySearch ( mat , 0 , 0 , m - 1 , x ) ; return ; } int i_low = 0 ; int i_high = n - 1 ; int j_mid = m / 2 ; while ( ( i_low + 1 ) < i_high ) { int i_mid = ( i_low + i_high ) / 2 ; if ( mat [ i_mid ] [ j_mid ] == x ) { cout << "Found at (" << i_mid << ", " << j_mid << ")" ; return ; } else if ( mat [ i_mid ] [ j_mid ] > x ) i_high = i_mid ; else i_low = i_mid ; } if ( mat [ i_low ] [ j_mid ] == x ) cout << "Found at (" << i_low << "," << j_mid << ")" ; else if ( mat [ i_low + 1 ] [ j_mid ] == x ) cout << "Found at (" << ( i_low + 1 ) << ", " << j_mid << ")" ; else if ( x <= mat [ i_low ] [ j_mid - 1 ] ) binarySearch ( mat , i_low , 0 , j_mid - 1 , x ) ; else if ( x >= mat [ i_low ] [ j_mid + 1 ] && x <= mat [ i_low ] [ m - 1 ] ) binarySearch ( mat , i_low , j_mid + 1 , m - 1 , x ) ; else if ( x <= mat [ i_low + 1 ] [ j_mid - 1 ] ) binarySearch ( mat , i_low + 1 , 0 , j_mid - 1 , x ) ; else binarySearch ( mat , i_low + 1 , j_mid + 1 , m - 1 , x ) ; }
bool isFeasible ( int mid , int arr [ ] , int n , int k ) { int pos = arr [ 0 ] ; int elements = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - pos >= mid ) { pos = arr [ i ] ; elements ++ ; if ( elements == k ) return true ; } } return 0 ; }
int largestMinDist ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int res = -1 ; int left = 1 , right = arr [ n - 1 ] ; while ( left < right ) { int mid = ( left + right ) / 2 ; if ( isFeasible ( mid , arr , n , k ) ) { res = max ( res , mid ) ; left = mid + 1 ; } else right = mid ; } return res ; }
int bsearch ( int low , int high , int n , int arr [ ] ) { int mid = ( low + high ) / 2 ; if ( low <= high ) { if ( arr [ mid ] < n ) return bsearch ( mid + 1 , high , n , arr ) ; return bsearch ( low , mid - 1 , n , arr ) ; } return low ; }
int mindiff ( int arr [ R ] [ C ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) sort ( arr [ i ] , arr [ i ] + m ) ; int ans = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int p = bsearch ( 0 , m - 1 , arr [ i ] [ j ] , arr [ i + 1 ] ) ; ans = min ( ans , abs ( arr [ i + 1 ] [ p ] - arr [ i ] [ j ] ) ) ; if ( p - 1 >= 0 ) ans = min ( ans , abs ( arr [ i + 1 ] [ p - 1 ] - arr [ i ] [ j ] ) ) ; } } return ans ; }
int binarySearch ( int arr [ ] , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return -1 ; }
int findRepeatingElement ( int arr [ ] , int low , int high ) { if ( low > high ) return -1 ; int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; }
double diff ( double n , double mid ) { if ( n > ( mid * mid * mid ) ) return ( n - ( mid * mid * mid ) ) ; else return ( ( mid * mid * mid ) - n ) ; }
double cubicRoot ( double n ) { double start = 0 , end = n ; double e = 0.0000001 ; while ( true ) { double mid = ( start + end ) / 2 ; double error = diff ( n , mid ) ; if ( error <= e ) return mid ; if ( ( mid * mid * mid ) > n ) end = mid ; else start = mid ; } }
void findFrequencyUtil ( int arr [ ] , int low , int high , vector < int > & freq ) { if ( arr [ low ] == arr [ high ] ) { freq [ arr [ low ] ] += high - low + 1 ; } else { int mid = ( low + high ) / 2 ; findFrequencyUtil ( arr , low , mid , freq ) ; findFrequencyUtil ( arr , mid + 1 , high , freq ) ; } }
void findFrequency ( int arr [ ] , int n ) { vector < int > freq ( arr [ n - 1 ] + 1 , 0 ) ; findFrequencyUtil ( arr , 0 , n - 1 , freq ) ; for ( int i = 0 ; i <= arr [ n - 1 ] ; i ++ ) if ( freq [ i ] != 0 ) cout << "Element " << i << " occurs " << freq [ i ] << " times" << endl ; }
int floorSqrt ( int x ) { if ( x == 0 x == 1 ) return x ; int i = 1 , result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; }
int countDirectPath ( int N ) { return N + ( N * ( N - 3 ) ) / 2 ; }
int isPossibleToReach ( int A [ ] , int N , int X , int Y ) { double distance = sqrt ( double ( X * X + Y * Y ) ) ; double mx = 0 ; for ( int i = 0 ; i < N ; i ++ ) { mx += double ( A [ i ] ) ; } if ( mx < distance ) { cout << "NO" ; return 0 ; } if ( ( mx - distance ) < 0.000001 ) { cout << "YES" ; return 0 ; } for ( int i = 0 ; i < N ; i ++ ) { if ( distance + mx < double ( 2 ) * double ( A [ i ] ) ) { cout << "No" ; return 0 ; } } cout << "Yes" ; return 0 ; }
bool canReach ( int X , int Y ) { int steps = 0 ; while ( X Y ) { int pos1 = X % 3 ; int pos2 = Y % 3  ; if ( pos1 == 2 pos2 == 2 ) { return false ; } if ( pos1 == 1 && pos2 == 1 ) { return false ; } if ( pos1 == 0 && pos2 == 0 ) { return false ; } X /= 3 ; Y /= 3 ; steps ++ ; }
int numofneighbour ( int mat [ ] [ C ] , int i , int j ) { int count = 0 ; if ( i > 0 && mat [ i - 1 ] [ j ] ) count ++ ; if ( j > 0 && mat [ i ] [ j - 1 ] ) count ++ ; if ( i < R - 1 && mat [ i + 1 ] [ j ] ) count ++ ; if ( j < C - 1 && mat [ i ] [ j + 1 ] ) count ++ ; return count ; }
int findperimeter ( int mat [ R ] [ C ] ) { int perimeter = 0 ; for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) if ( mat [ i ] [ j ] ) perimeter += ( 4 - numofneighbour ( mat , i , j ) ) ; return perimeter ; }
double findRadius ( double r1 , double r2 , double r3 ) { double r4 = ( r1 * r2 * r3 ) / ( r1 * r2 + r2 * r3 + r1 * r3 + 2.0 * sqrt ( r1 * r2 * r3 * ( r1 + r2 + r3 ) ) ) ; return r4 ; }
void findSides ( double A , double C , double c ) { double B = 180 - ( A + C ) ; A = A * ( 3.14159 / 180 ) ; C = C * ( 3.14159 / 180 ) ; B = B * ( 3.14159 / 180 ) ; double a = ( c / sin ( C ) ) * sin ( A ) ; double b = ( c / sin ( C ) ) * sin ( B ) ; cout << fixed << setprecision ( 2 ) ; cout << a << endl ; cout << b << endl ; }
void closestsAngle ( int N , int A ) { double mi = INT_MAX ; int ans = 0 ; for ( int i = 1 ; i < N - 1 ; i ++ ) { double angle = 180.0 * i / N ; if ( fabs ( angle - A ) < fabs ( mi - A ) ) { mi = angle ; ans = i ; } } cout << 2 << ' ' << 1 << ' ' << 2 + ans ; }
double lengthOfLatusRectum ( double A , double B ) { double major = 2.0 * A ; double minor = 2.0 * B ; double latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }
double radius ( int a , int b , int c ) { int g = a / 2 ; int f = b / 2 ; if ( g * g + f * f - c < 0 ) return ( -1 ) ; return ( sqrt ( g * g + f * f - c ) ) ; }
double centerDistanceFromLine ( int a , int b , int i , int j , int k ) { int g = a / 2 ; int f = b / 2 ; double distance = fabs ( i * g + j * f + k ) / ( sqrt ( i * i + j * j ) ) ; if ( distance < 0 ) return ( -1 ) ; return distance ; }
void check_position ( int a , int b , int c , int d , int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { int value_1 = a * x1 + b * y1 + c * z1 + d ; int value_2 = a * x2 + b * y2 + c * z2 + d ; if ( ( value_1 > 0 && value_2 > 0 ) || ( value_1 < 0 && value_2 < 0 ) ) cout << "On same side" ; if ( ( value_1 > 0 && value_2 < 0 ) || ( value_1 < 0 && value_2 > 0 ) ) cout << "On different sides" ; if ( value_1 == 0 && value_2 == 0 ) cout << "Both on the plane" ; if ( value_1 == 0 && value_2 != 0 ) cout << "Point 1 on the plane" ; if ( value_1 != 0 && value_2 == 0 ) cout << "Point 2 on the plane" ; }
void normal_equation ( double a , double b , double x1 , double y1 ) { double slope = normal_slope ( a , b , x1 , y1 ) ; if ( slope == -1 ) { cout << "x = " << x1 ; } if ( slope == -2 ) { cout << "y = " << y1 ; } if ( slope != -1 && slope != -2 ) { x1 *= - slope ; x1 += y1 ; if ( x1 > 0 ) cout << "y = " << slope << "x + " << x1 ; else cout << "y = " << slope << "x " << x1 ; } }
double point_distance ( int x1 , int y1 , int x2 , int y2 ) { int p = ( x2 - x1 ) ; int q = ( y2 - y1 ) ; double distance = sqrt ( p * p + q * q ) ; return distance ; }
bool check ( circle C [ ] ) { double C1C2 = sqrt ( ( C [ 1 ] . x - C [ 0 ] . x ) * ( C [ 1 ] . x - C [ 0 ] . x ) + ( C [ 1 ] . y - C [ 0 ] . y ) * ( C [ 1 ] . y - C [ 0 ] . y ) ) ; bool flag = 0 ; if ( C1C2 < ( C [ 0 ] . r + C [ 1 ] . r ) ) { if ( ( C [ 0 ] . x + C [ 1 ] . x ) == 2 * C [ 2 ] . x && ( C [ 0 ] . y + C [ 1 ] . y ) == 2 * C [ 2 ] . y ) { flag = 1 ; } } return flag ; }
bool IsFairTriplet ( circle c [ ] ) { bool f = false ; f |= check ( c ) ; for ( int i = 0 ; i < 2 ; i ++ ) { swap ( c [ 0 ] , c [ 2 ] ) ; f |= check ( c ) ; } return f ; }
double eccHyperbola ( double A , double B ) { double r = ( double ) B * B / A * A ; r += 1 ; return sqrt ( r ) ; }
double findInteriorAngle ( int n ) { return ( n - 2 ) * PI / n ; }
void findAngle ( double M1 , double M2 ) { double angle = abs ( ( M2 - M1 ) / ( 1 + M1 * M2 ) ) ; double ret = atan ( angle ) ; double val = ( ret * 180 ) / PI ; cout << val ; }
float calculateArea ( float A , float B , float C , float D ) { float S = ( A + B + C + D ) / 2 ; float area = sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) ; return area ; }
float angle ( float R1 , float R2 , float D ) { float ans = ( R1 * R1 + R2 * R2 - D * D ) / ( 2 * R1 * R2 ) ; return ans ; }
void triangleArea ( int a , int b ) { double ratio = ( double ) b / a ; cout << ratio ; }
int countInscribed ( int R1 , int R2 ) { if ( R2 > R1 ) return 0 ; double angle ; double ratio ; int number_of_circles = 0 ; ratio = R2 / ( double ) ( R1 - R2 ) ; if ( R1 < 2 * R2 ) { number_of_circles = 1 ; } else { angle = abs ( asin ( ratio ) * 180 ) / 3.14159265 ; number_of_circles = 360 / ( 2 * floor ( angle ) ) ; } return number_of_circles ; }
float distance ( int m , int n , int p , int q ) { return sqrt ( pow ( n - m , 2 ) + pow ( q - p , 2 ) * 1.0 ) ; }
double magnitude ( double arr [ ] , int N ) { double magnitude = 0 ; for ( int i = 0 ; i < N ; i ++ ) magnitude += arr [ i ] * arr [ i ] ; return sqrt ( magnitude ) ; }
double dotProduct ( double arr [ ] , double brr [ ] , int N ) { double product = 0 ; for ( int i = 0 ; i < N ; i ++ ) product = product + arr [ i ] * brr [ i ] ; return product ; }
void angleBetweenVectors ( double arr [ ] , double brr [ ] , int N ) { double dotProductOfVectors = dotProduct ( arr , brr , N ) ; double magnitudeOfA = magnitude ( arr , N ) ; double magnitudeOfB = magnitude ( brr , N ) ; double angle = dotProductOfVectors / ( magnitudeOfA * magnitudeOfB ) ; cout << angle ; }
double lengthOfLatusRectum ( double A , double B ) { double major = 2.0 * A ; double minor = 2.0 * B ; double latus_rectum = ( minor * minor ) / major ; return latus_rectum ; }
int totalCircles ( int L , int B ) { if ( L > B ) { int temp = L ; L = B ; B = temp ; } return B / L ; }
void findSquareSum ( int Coordinates [ ] [ 2 ] , int N ) { long long xq = 0 , yq = 0 ; long long xs = 0 , ys = 0 ; long long res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int a , b ; a = Coordinates [ i ] [ 0 ] ; b = Coordinates [ i ] [ 1 ] ; res += xq ; res -= 2 * xs * a ; res += i * ( long long ) ( a * a ) ; xq += a * a ; xs += a ; res += yq ; res -= 2 * ys * b ; res += i * ( long long ) b * b ; yq += b * b ; ys += b ; } cout << res ; }
double findDiagonal ( double s ) { return sqrt ( 2 ) * s ; }
void triangleArea ( float a , float b ) { if ( a < 0 b < 0  ) { cout << -1 ; return ; } float area = ( 3 * sqrt ( 3 ) * a * b ) / ( 4 ) ; cout << area ; }
int maxRowDiff ( int mat [ ] [ MAX ] , int m , int n ) { int rowSum [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] ; rowSum [ i ] = sum ; } int max_diff = rowSum [ 1 ] - rowSum [ 0 ] ; int min_element = rowSum [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) { if ( rowSum [ i ] - min_element > max_diff ) max_diff = rowSum [ i ] - min_element ; if ( rowSum [ i ] < min_element ) min_element = rowSum [ i ] ; } return max_diff ; }
float distance ( float x1 , float y1 , float x2 , float y2 ) { return sqrt ( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ) ; }
float lengthOfLatusRectum ( float a , float b , float c ) { pair < float , float > vertex = { ( - b / ( 2 * a ) ) , ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) } ; pair < float , float > focus = { ( - b / ( 2 * a ) ) , ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) } ; cout << 4 * distance ( focus . first , focus . second , vertex . first , vertex . second ) ; }
bool doIntersect ( vector < int > X , vector < int > Y ) { if ( X [ 0 ] > X [ 3 ] X [ 2 ] > X [ 1 ] ) return false ; if ( Y [ 0 ] > Y [ 3 ] Y [ 2 ] > Y [ 1 ] ) return false ; return true ; }
int getUnionPerimeter ( vector < int > X , vector < int > Y ) { int perimeter = 0 ; if ( ! doIntersect ( X , Y ) ) { perimeter += 2 * ( abs ( X [ 1 ] - X [ 0 ] ) + abs ( Y [ 1 ] - Y [ 0 ] ) ) ; perimeter += 2 * ( abs ( X [ 3 ] - X [ 2 ] ) + abs ( Y [ 3 ] - Y [ 2 ] ) ) ; } else { int w = * max_element ( X . begin ( ) , X . end ( ) ) - * min_element ( X . begin ( ) , X . end ( ) ) ; int l = * max_element ( Y . begin ( ) , Y . end ( ) ) - * min_element ( Y . begin ( ) , Y . end ( ) ) ; perimeter = 2 * ( l + w ) ; } return perimeter ; }
int getPointsIns ( int x1 , int y1 , int radius , int x2 , int y2 , vector < pair < int , int > > points ) { int ans = 0 ; for ( int i = 0 ; i < points . size ( ) ; i ++ ) { bool condOne = false , condTwo = false ; if ( ( points [ i ] . second - y2 ) * ( x2 - x1 ) - ( y2 - y1 ) * ( points [ i ] . first - x2 ) >= 0 ) { condOne = true ; } if ( radius >= ( int ) sqrt ( pow ( ( y1 - points [ i ] . second ) , 2 ) + pow ( x1 - points [ i ] . first , 2 ) ) ) { condTwo = true ; } if ( condOne && condTwo ) { ans += 1 ; } } return ans ; }
double Convert ( double degree ) { double pi = 3.14159265359 ; return ( degree * ( pi / 180 ) ) ; }
double findRadius ( double r1 , double r2 ) { double a1 , a2 , a3 , r3 ; a1 = 3.14 * r1 * r1 ; a2 = 3.14 * r2 * r2 ; a3 = a1 + a2 ; r3 = sqrt ( a3 / 3.14 ) ; return r3 ; }
int find_lcm ( int a , int b , int c ) { int g = __gcd ( a , b ) ; int LCM1 = ( a * b ) / g ; g = __gcd ( LCM1 , c ) ; int LCM = ( LCM1 * c ) / g ; return LCM ; }
void minimumCuboids ( int L , int B , int H ) { int lcm = find_lcm ( L , B , H ) ; int volume_cube = lcm * lcm * lcm ; int volume_cuboid = L * B * H ; cout << ( volume_cube / volume_cuboid ) ; }
double distance ( pair < double , double > p1 , pair < double , double > p2 ) { double x1 = p1 . first , x2 = p2 . first ; double y1 = p1 . second , y2 = p2 . second ; return sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) * 1.0 ) ; }
int CrossProduct ( vector < vector < int > > & A ) { int X1 = ( A [ 1 ] [ 0 ] - A [ 0 ] [ 0 ] ) ; int Y1 = ( A [ 1 ] [ 1 ] - A [ 0 ] [ 1 ] ) ; int X2 = ( A [ 2 ] [ 0 ] - A [ 0 ] [ 0 ] ) ; int Y2 = ( A [ 2 ] [ 1 ] - A [ 0 ] [ 1 ] ) ; return ( X1 * Y2 - Y1 * X2 ) ; }
bool isConvex ( vector < vector < int > > & points ) { int N = points . size ( ) ; int prev = 0 ; int curr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { vector < vector < int > > temp = { points [ i ] , points [ ( i + 1 ) % N ] , points [ ( i + 2 ) % N ] } ; curr = CrossProduct ( temp ) ; if ( curr != 0 ) { if ( curr * prev < 0 ) { return false ; } else { prev = curr ; } } } return true ; }
int cntRect ( int points [ ] [ 2 ] , int N , int rectangle [ ] [ 2 ] ) { unordered_set < int > cntHor ; unordered_set < int > cntVer ; cntHor . insert ( 0 ) ; cntVer . insert ( 0 ) ; cntHor . insert ( rectangle [ 3 ] [ 0 ] ) ; cntVer . insert ( rectangle [ 3 ] [ 1 ] ) ; for ( int i = 0 ; i < N ; i ++ ) { cntHor . insert ( points [ i ] [ 0 ] ) ; cntVer . insert ( points [ i ] [ 1 ] ) ; } return ( cntHor . size ( ) - 1 ) * ( cntVer . size ( ) - 1 ) ; }
int numberOfSquares ( int X [ ] , int Y [ ] , int N , int M ) { unordered_map < int , int > m1 , m2 ; int i , j , ans = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { int dist = abs ( X [ i ] - X [ j ] ) ; m1 [ dist ] ++ ; } } for ( i = 0 ; i < M ; i ++ ) { for ( j = i + 1 ; j < M ; j ++ ) { int dist = abs ( Y [ i ] - Y [ j ] ) ; m2 [ dist ] ++ ; } } for ( auto i = m1 . begin ( ) ; i != m1 . end ( ) ; i ++ ) { if ( m2 . find ( i -> first ) != m2 . end ( ) ) { ans += ( i -> second * m2 [ i -> first ] ) ; } } return ans ; }
double Area_Parallelogram1 ( int a , int b , int theta ) { double area = ( abs ( tan ( toRadians ( theta ) ) ) / 2 ) * abs ( a * a - b * b ) ; return area ; }
static double Area_Parallelogram3 ( int d1 , int d2 , int theta ) { double area = ( abs ( sin ( toRadians ( theta ) ) ) / 2 ) * abs ( d1 * d2 ) ; return area ; }
int noOfTriangles ( int n ) { return floor ( n * ( n + 2 ) * ( 2 * n + 1 ) / 8 ) ; }
int No_of_squares ( int N , int K ) { int no_of_squares = 0 ; no_of_squares = ( N - K + 1 ) * ( N - K + 1 ) ; return no_of_squares ; }
void checkTriangle ( int x , int y , int z ) { if ( x == y && y == z ) cout << "Equilateral Triangle" ; else if ( x == y y == z z == x ) cout << "Isosceles Triangle" ; else cout << "Scalene Triangle" ; }
int getTotalCoverageOfMatrix ( int mat [ R ] [ C ] ) { int res = 0 ; for ( int i = 0 ; i < R ; i ++ ) { bool isOne = false ; for ( int j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } isOne = false ; for ( int j = C - 1 ; j >= 0 ; j -- ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } } for ( int j = 0 ; j < C ; j ++ ) { bool isOne = false ; for ( int i = 0 ; i < R ; i ++ ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } isOne = false ; for ( int i = R - 1 ; i >= 0 ; i -- ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } } return res ; }
double Circumradius ( int a , int b , int c , int d ) { double s = ( a + b + c + d ) / 2.0 ; double radius = sqrt ( ( ( a * b ) + ( c * d ) ) * ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( s - a ) * ( s - b ) * ( s - c ) * ( s - d ) ) ) ; return radius / 4 ; }
int calculateTriangles ( int sides [ ] ) { double count = pow ( sides [ 0 ] + sides [ 1 ] + sides [ 2 ] , 2 ) ; count -= pow ( sides [ 0 ] , 2 ) ; count -= pow ( sides [ 2 ] , 2 ) ; count -= pow ( sides [ 4 ] , 2 ) ; return ( int ) ( count ) ; }
double Length_Diagonal ( int a , int b , double theta ) { double diagonal = sqrt ( ( pow ( a , 2 ) + pow ( b , 2 ) ) - 2 * a * b * cos ( theta * ( PI / 180 ) ) ) ; return diagonal ; }
void maximumTiles ( int n , int m ) { cout << ( m * n ) / 2 << endl ; }
float Length_Diagonal ( int a , int b , int d ) { float diagonal = sqrt ( 2 * ( ( a * a ) + ( b * b ) ) - ( d * d ) ) ; return diagonal ; }
vector < float > Diagonals ( int a , int b , int c , int d ) { vector < float > ans ; ans . push_back ( sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( a * b ) + ( c * d ) ) ) ) ; ans . push_back ( sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * b ) + ( c * d ) ) / ( ( a * d ) + ( b * c ) ) ) ) ; return ans ; }
double find ( double x , double y , vector < vector < int > > & p ) { double mind = 0 ; for ( int i = 0 ; i < p . size ( ) ; i ++ ) { double a = p [ i ] [ 0 ] , b = p [ i ] [ 1 ] ; mind += sqrt ( ( x - a ) * ( x - a ) + ( y - b ) * ( y - b ) ) ; } return mind ; }
double getMinDistSum ( vector < vector < int > > & p ) { double x = 0 , y = 0 ; for ( int i = 0 ; i < p . size ( ) ; i ++ ) { x += p [ i ] [ 0 ] ; y += p [ i ] [ 1 ] ; } x = x / p . size ( ) ; y = y / p . size ( ) ; double mind = find ( x , y , p ) ; return mind ; }
int det ( int d [ ] [ 3 ] ) { int Sum = d [ 0 ] [ 0 ] * ( ( d [ 1 ] [ 1 ] * d [ 2 ] [ 2 ] ) - ( d [ 2 ] [ 1 ] * d [ 1 ] [ 2 ] ) ) ; Sum -= d [ 0 ] [ 1 ] * ( ( d [ 1 ] [ 0 ] * d [ 2 ] [ 2 ] ) - ( d [ 1 ] [ 2 ] * d [ 2 ] [ 0 ] ) ) ; Sum += d [ 0 ] [ 2 ] * ( ( d [ 0 ] [ 1 ] * d [ 1 ] [ 2 ] ) - ( d [ 0 ] [ 2 ] * d [ 1 ] [ 1 ] ) ) ; return Sum ; }
double distance ( int r , int R ) { double d = sqrt ( pow ( R , 2 ) - ( 2 * r * R ) ) ; return d ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void replacematrix ( int mat [ R ] [ C ] , int n , int m ) { int rgcd [ R ] = { 0 } , cgcd [ C ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { rgcd [ i ] = gcd ( rgcd [ i ] , mat [ i ] [ j ] ) ; cgcd [ j ] = gcd ( cgcd [ j ] , mat [ i ] [ j ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) mat [ i ] [ j ] = max ( rgcd [ i ] , cgcd [ j ] ) ; }
int areaOfSquare ( int S ) { int area = S * S ; return area ; }
int isAllKs ( int n , int b , int k ) { int len = findNumberOfDigits ( n , b ) ; int sum = k * ( 1 - pow ( b , len ) ) / ( 1 - b ) ; if ( sum == n ) { return ( sum ) ; } }
void checkRightAngled ( int X1 , int Y1 , int X2 , int Y2 , int X3 , int Y3 ) { int A = ( int ) pow ( ( X2 - X1 ) , 2 ) + ( int ) pow ( ( Y2 - Y1 ) , 2 ) ; int B = ( int ) pow ( ( X3 - X2 ) , 2 ) + ( int ) pow ( ( Y3 - Y2 ) , 2 ) ; int C = ( int ) pow ( ( X3 - X1 ) , 2 ) + ( int ) pow ( ( Y3 - Y1 ) , 2 ) ; if ( ( A > 0 and B > 0 and C > 0 ) and ( A == ( B + C ) or B == ( A + C ) or C == ( A + B ) ) ) cout << "Yes" ; else cout << "No" ; }
void checkValidPolygon ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum == 180 * ( N - 2 ) ) cout << "Yes" ; else cout << "No" ; }
double minAnglRot ( int N ) { double res ; res = 360 / ( double ) N ; return res ; }
int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; }
int sortedCount ( int mat [ ] [ MAX ] , int r , int c ) { int result = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = 0 ; j < c - 1 ; j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ; if ( j == c - 1 ) result ++ ; } for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = c - 1 ; j > 0 ; j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ; if ( c > 1 && j == 0 ) result ++ ; } return result ; }
double Area_of_Triangle ( int a , int b , int c ) { int s = ( a + b + c ) / 2 ; int x = s * ( s - a ) ; x = x * ( s - b ) ; x = x * ( s - c ) ; double area = ( 4 / ( double ) 3 ) * sqrt ( x ) ; return area ; }
float Area_of_Triangle ( int a , int b , int k ) { float area = ( float ) ( ( 1 / 2.0 ) * a * b * ( sin ( k ) ) ) ; return area ; }
int findAreaCovered ( ) { int area = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { if ( arr [ i ] [ j ] == true ) { area ++ ; } } } return area ; }
void findEquation ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int d , int e , int f ) { double a = x2 - x1 ; double b = y2 - y1 ; double c = z2 - z1 ; int A = ( b * f - c * e ) ; int B = ( a * f - c * d ) ; int C = ( a * e - b * d ) ; int D = - ( A * d - B * e + C * f ) ; cout << A << "x + " << B << "y + " << C << "z + " << D << "= 0" ; }
void createPrefixArray ( int n , int arr [ ] , int prefSize , int pref [ ] ) { for ( int i = 0 ; i < prefSize ; i ++ ) { pref [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] + 1000000 ; pref [ x ] ++ ; } for ( int i = 1 ; i < prefSize ; i ++ ) { pref [ i ] += pref [ i - 1 ] ; } }
int count_rectangles ( int N , int M ) { int p_x = ( N * ( N - 1 ) ) / 2 ; int p_y = ( M * ( M - 1 ) ) / 2 ; return p_x * p_y ; }
float median ( int a , int b , int c ) { float n = sqrt ( 2 * b * b + 2 * c * c - a * a ) / 2 ; return n ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i < n + 1 ; i ++ ) res = res * i ; return res ; }
void circleArea ( double r ) { cout << ( pi * r * r ) ; }
void findCircleAreaByMedian ( double m ) { double r = 2 * m / 3 ; circleArea ( r ) ; }
int areaSquare ( int L , int B ) { int large = max ( L , B ) ; int small = min ( L , B ) ; if ( large >= 2 * small ) return large * large ; else return ( 2 * small ) * ( 2 * small ) ; }
double nGon ( int N ) { double proAngleVar ; if ( N % 4 == 0 ) { proAngleVar = pi * ( 180.0 / N ) / 180 ; } else { proAngleVar = pi * ( 180.0 / ( 2 * N ) ) / 180 ; } double negX = 1.0e+99 , posX = -1.0e+99 , negY = 1.0e+99 , posY = -1.0e+99 ; for ( int j = 0 ; j < N ; ++ j ) { double px = cos ( 2 * pi * j / N + proAngleVar ) ; double py = sin ( 2 * pi * j / N + proAngleVar ) ; negX = min ( negX , px ) ; posX = max ( posX , px ) ; negY = min ( negY , py ) ; posY = max ( posY , py ) ; } double opt2 = max ( posX - negX , posY - negY ) ; return ( double ) opt2 / sin ( pi / N ) / 2 ; }
float cal_cos ( float n ) { float accuracy = 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= fabs ( cosval - cosx ) ) ; return cosx ; }
int triacontagonalNum ( int n ) { return ( 28 * n * n - 26 * n ) / 2 ; }
int hexacontagonNum ( int n ) { return ( 58 * n * n - 56 * n ) / 2 ; }
bool isicositetragonal ( int N ) { float n = ( 10 + sqrt ( 44 * N + 100 ) ) / 22 ; return ( n - ( int ) n ) == 0 ; }
int enneacontagonNum ( int n ) { return ( 88 * n * n - 86 * n ) / 2 ; }
int triacontakaidigonNum ( int n ) { return ( 30 * n * n - 28 * n ) / 2 ; }
int maxXOR ( int mat [ ] [ MAX ] , int N ) { int r_xor , c_xor ; int max_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { r_xor = 0 , c_xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < max ( r_xor , c_xor ) ) max_xor = max ( r_xor , c_xor ) ; } return max_xor ; }
bool isTridecagon ( int N ) { float n = ( 9 + sqrt ( 88 * N + 81 ) ) / 22 ; return ( n - ( int ) n ) == 0 ; }
bool isicosihenagonal ( int N ) { float n = ( 17 + sqrt ( 152 * N + 289 ) ) / 38 ; return ( n - ( int ) n ) == 0 ; }
bool isicositrigonal ( int N ) { float n = ( 19 + sqrt ( 168 * N + 361 ) ) / 42 ; return ( n - ( int ) n ) == 0 ; }
int IcosihexagonalNum ( int n ) { return ( 24 * n * n - 22 * n ) / 2 ; }
int icosikaioctagonalNum ( int n ) { return ( 26 * n * n - 24 * n ) / 2 ; }
int hectagonNum ( int n ) { return ( 98 * n * n - 96 * n ) / 2 ; }
int tetracontagonNum ( int n ) { return ( 38 * n * n - 36 * n ) / 2 ; }
int Tridecagonal_num ( int n ) { return ( 11 * n * n - 9 * n ) / 2 ; }
int Octadecagonal_num ( int n ) { return ( 16 * n * n - 14 * n ) / 2 ; }
int Icositetragonal_num ( int n ) { return ( 22 * n * n - 20 * n ) / 2 ; }
int Icosihenagonal_num ( int n ) { return ( 19 * n * n - 17 * n ) / 2 ; }
void checkTriangle ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int a = x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ; if ( a == 0 ) cout << "No" ; else cout << "Yes" ; }
int numTrip ( vector < pair < int , int > > & points ) { int res = 0 ; for ( int i = 0 ; i < points . size ( ) ; ++ i ) { unordered_map < long , int > map ( points . size ( ) ) ; for ( int j = 0 ; j < points . size ( ) ; ++ j ) { if ( j == i ) continue ; int dy = points [ i ] . second - points [ j ] . second ; int dx = points [ i ] . first - points [ j ] . first ; int key = dy * dy ; key += dx * dx ; map [ key ] ++ ; } for ( auto & p : map ) res += p . second * ( p . second - 1 ) ; } return res ; }
bool checkOverlap ( int R , int Xc , int Yc , int X1 , int Y1 , int X2 , int Y2 ) { int Xn = max ( X1 , min ( Xc , X2 ) ) ; int Yn = max ( Y1 , min ( Yc , Y2 ) ) ; int Dx = Xn - Xc ; int Dy = Yn - Yc ; return ( Dx * Dx + Dy * Dy ) <= R * R ; }
double area_of_circle ( int m , int n ) { int square_of_radius = ( m * n ) / 4 ; double area = ( 3.141 * square_of_radius ) ; return area ; }
void direction ( ll R , ll C ) { if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) { cout << "Left" << endl ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) { cout << "Up" << endl ; return ; } if ( R == C && R % 2 != 0 && C % 2 != 0 ) { cout << "Right" << endl ; return ; } if ( R == C && R % 2 == 0 && C % 2 == 0 ) { cout << "Left" << endl ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { cout << "Right" << endl ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) { cout << "Down" << endl ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) { cout << "Left" << endl ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) { cout << "Up" << endl ; return ; } if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) { cout << "Down" << endl ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) { cout << "Right" << endl ; return ; } }
int checkIntersection ( pair < int , int > p1 , pair < int , int > p2 , pair < int , int > p ) { int val ; if ( p1 . second == p2 . second && p1 . second == p . second ) { if ( p . first <= max ( p1 . first , p2 . first ) && ( p . first >= min ( p1 . first , p2 . first ) ) ) return 1 ; } if ( p1 . first == p2 . first && p1 . first == p . first ) { if ( p . second <= max ( p1 . second , p2 . second ) && ( p . second >= min ( p1 . second , p2 . second ) ) ) return 1 ; } else { val = ( p . second - p1 . second ) * ( p2 . first - p1 . first ) - ( p . first - p1 . first ) * ( p2 . second - p1 . second ) ; if ( val == 0 ) if ( ( p . first <= max ( p1 . first , p2 . first ) && ( p . first >= min ( p1 . first , p2 . first ) ) ) && ( p . second <= max ( p1 . second , p2 . second ) && ( p . second >= min ( p1 . second , p2 . second ) ) ) ) return 1 ; } return 0 ; }
void towerOfSight ( pair < int , int > a , pair < int , int > b , pair < int , int > c , pair < int , int > d ) { int flag = 0 ; if ( checkIntersection ( a , c , b ) ) flag = 1 ; else if ( checkIntersection ( a , c , d ) ) flag = 1 ; else if ( checkIntersection ( b , d , a ) ) flag = 1 ; else if ( checkIntersection ( b , d , c ) ) flag = 1 ; flag ? cout << "Yes\n" : cout << "No\n" ; }
int NotParallel ( int p [ ] [ 2 ] , int n ) { map < int , int > x_axis , y_axis ; for ( int i = 0 ; i < n ; i ++ ) { x_axis [ p [ i ] [ 0 ] ] ++ ; y_axis [ p [ i ] [ 1 ] ] ++ ; } int total = ( n * ( n - 1 ) ) / 2 ; for ( auto i : x_axis ) { int c = i . second ; total -= ( c * ( c - 1 ) ) / 2 ; } for ( auto i : y_axis ) { int c = i . second ; total -= ( c * ( c - 1 ) ) / 2 ; } return total ; }
void checkTypeOfTriangle ( int a , int b , int c ) { int sqa = pow ( a , 2 ) ; int sqb = pow ( b , 2 ) ; int sqc = pow ( c , 2 ) ; if ( sqa == sqb + sqc sqb == sqc + sqa sqc == sqa + sqb ) { cout << "Right-angled Triangle" ; } else if ( sqa > sqc + sqb sqb > sqa + sqc sqc > sqa + sqb ) { cout << "Obtuse-angled Triangle" ; } else { cout << "Acute-angled Triangle" ; } }
void lineFromPoints ( point P , point Q , double & a , double & b , double & c ) { a = Q . y - P . y ; b = P . x - Q . x ; c = a * ( P . x ) + b * ( P . y ) ; }
double LineInterX ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { double determ = a1 * b2 - a2 * b1 ; double x = ( b2 * c1 - b1 * c2 ) ; x /= determ ; return x ; }
double LineInterY ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { double determ = a1 * b2 - a2 * b1 ; double y = ( a1 * c2 - a2 * c1 ) ; y /= determ ; return y ; }
void findPosition ( point P , point Q , point R , point D ) { point r ; double a , b , c ; lineFromPoints ( P , Q , a , b , c ) ; double e , f , g ; lineFromPoints ( Q , R , e , f , g ) ; perpenBisectorFromLine ( P , Q , a , b , c ) ; perpenBisectorFromLine ( Q , R , e , f , g ) ; r . x = LineInterX ( a , b , c , e , f , g ) ; r . y = LineInterY ( a , b , c , e , f , g ) ; double q = ( r . x - P . x ) * ( r . x - P . x ) + ( r . y - P . y ) * ( r . y - P . y ) ; double dis = ( r . x - D . x ) * ( r . x - D . x ) + ( r . y - D . y ) * ( r . y - D . y ) ; if ( dis < q ) { cout << "Point (" << D . x << ", " << D . y << ") is inside " << "the circumcircle" ; } else if ( dis == q ) { cout << "Point (" << D . x << ", " << D . y << ") lies on the " << "circumcircle" ; } else { cout << "Point (" << D . x << ", " << D . y << ") lies outside" << " the circumcircle" ; } }
void disp ( int row_no , int block ) { cout << row_no * block ; }
int row ( int ht , int h ) { return ht / h ; }
void calculate ( int l , int w , int h , int a , int ht ) { int no_block = ( 4 * a ) / l ; int row_no ; if ( h < w ) row_no = row ( ht , w ) ; else row_no = row ( ht , h ) ; disp ( row_no , no_block ) ; }
double solve ( int s ) { double area = ( 1.732 * pow ( s , 2 ) ) / 8 ; return area ; }
double area ( int R ) { double base = 1.732 * R ; double height = ( 1.5 ) * R ; double area = 0.5 * base * height ; return area ; }
void spiralPrint ( int m , int n , int a [ R ] [ C ] , int c ) { int i , k = 0 , l = 0 ; int count = 0 ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) { count ++ ; if ( count == c ) cout << a [ k ] [ i ] << " " ; } k ++ ; for ( i = k ; i < m ; ++ i ) { count ++ ; if ( count == c ) cout << a [ i ] [ n - 1 ] << " " ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { count ++ ; if ( count == c ) cout << a [ m - 1 ] [ i ] << " " ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { count ++ ; if ( count == c ) cout << a [ i ] [ l ] << " " ; } l ++ ; } } }
float find_Area ( float a ) { float R = a * ( 2.0 - sqrt ( 2 ) ) ; float area = 3.14 * R * R / 2.0 ; return area ; }
int times ( int steps [ ] , int n ) { int current_level = 0 ; int previous_level = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { previous_level = current_level ; current_level = current_level + steps [ i ] ; if ( ( previous_level < 0 && current_level >= 0 ) || ( previous_level > 0 && current_level <= 0 ) ) { count ++ ; } } return count ; }
int solve ( int n , int m , int obstacles , double range [ ] ) { double val = min ( n , m ) ; sort ( range , range + obstacles ) ; int c = 1 ; for ( int i = obstacles - 1 ; i >= 0 ; i -- ) { range [ i ] = 2 * range [ i ] ; val -= range [ i ] ; if ( val <= 0 ) { return c ; } else { c ++ ; } } if ( val > 0 ) { return -1 ; } }
void equation_plane ( int p [ ] , int q [ ] , int r [ ] ) { int x1 = p [ 0 ] ; int y1 = p [ 1 ] ; int z1 = p [ 2 ] ; int x2 = q [ 0 ] ; int y2 = q [ 1 ] ; int z2 = q [ 2 ] ; int x3 = r [ 0 ] ; int y3 = r [ 1 ] ; int z3 = r [ 2 ] ; int a1 = x2 - x1 ; int b1 = y2 - y1 ; int c1 = z2 - z1 ; int a2 = x3 - x1 ; int b2 = y3 - y1 ; int c2 = z3 - z1 ; int A = b1 * c2 - b2 * c1 ; int B = a2 * c1 - a1 * c2 ; int C = a1 * b2 - b1 * a2 ; int D = ( - A * x1 - B * y1 - C * z1 ) ; float * rslt = XandYandZintercept ( A , B , C , D ) ; for ( int i = 0 ; i < 3 ; i ++ ) { cout << rslt [ i ] << " " ; } }
int countPairs ( int * P , int * Q , int N , int M ) { int A [ 2 ] = { 0 } , B [ 2 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( int i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; }
float find_angle ( int x , int y , int z ) { int volume = x * x * y ; float ans = 0 ; if ( z < volume / 2 ) { float d = ( x * y * y ) / ( 2.0 * z ) ; ans = atan ( d ) ; } else { z = volume - z ; float d = ( 2 * z ) / ( float ) ( x * x * x ) ; ans = atan ( d ) ; } ans = ( ans * 180 ) / 3.14159265 ; return ans ; }
vector < pair < int , int > > FindPoints ( int n ) { vector < pair < int , int > > v ; v . push_back ( { 0 , 0 } ) ; v . push_back ( { 0 , n } ) ; v . push_back ( { n , 0 } ) ; v . push_back ( { n , n } ) ; if ( n % 2 == 0 ) v . push_back ( { n / 2 , n / 2 } ) ; return v ; }
double findsolution ( double d , double h , double m , double n ) { double k = ( 4 * m ) / ( pie * d * d ) ; if ( n > k ) return -1 ; double ans = ( h / ( k - n ) ) ; return ans ; }
pair < double , double > find_Centroid ( vector < pair < double , double > > & v ) { pair < double , double > ans = { 0 , 0 } ; int n = v . size ( ) ; double signedArea = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { double x0 = v [ i ] . first , y0 = v [ i ] . second ; double x1 = v [ ( i + 1 ) % n ] . first , y1 = v [ ( i + 1 ) % n ] . second ; double A = ( x0 * y1 ) - ( x1 * y0 ) ; signedArea += A ; ans . first += ( x0 + x1 ) * A ; ans . second += ( y0 + y1 ) * A ; } signedArea *= 0.5 ; ans . first = ( ans . first ) / ( 6 * signedArea ) ; ans . second = ( ans . second ) / ( 6 * signedArea ) ; return ans ; }
int sumOfInternalAngles ( int n ) { if ( n < 3 ) return 0 ; return ( n - 2 ) * 180 ; }
int cntWays ( int n ) { if ( n % 2 == 1 ) { return 0 ; } else { return ( n - 2 ) / 4 ; } }
int noOfTriangles ( int n ) { int y = 4 * n ; return ( ( y * ( y - 2 ) * ( y - 1 ) ) - ( 4 * n * ( n - 2 ) * ( n - 1 ) ) ) / 6 ; }
int angle ( int n ) { return 2 * n ; }
bool checkDiagonal ( int mat [ N ] [ M ] , int i , int j ) { int res = mat [ i ] [ j ] ; while ( ++ i < N && ++ j < M ) { if ( mat [ i ] [ j ] != res ) return false ; } return true ; }
int ifRight ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int a = ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ; int b = ( ( x1 - x3 ) * ( x1 - x3 ) ) + ( ( y1 - y3 ) * ( y1 - y3 ) ) ; int c = ( ( x2 - x3 ) * ( x2 - x3 ) ) + ( ( y2 - y3 ) * ( y2 - y3 ) ) ; if ( ( a == ( b + c ) && a != 0 && b != 0 && c != 0 ) || ( b == ( a + c ) && a != 0 && b != 0 && c != 0 ) || ( c == ( a + b ) && a != 0 && b != 0 && c != 0 ) ) { return 1 ; } return 0 ; }
void isValidCombination ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int x , y ; bool possible = 0 ; if ( ifRight ( x1 , y1 , x2 , y2 , x3 , y3 ) ) { cout << "ALREADY RIGHT ANGLED" ; return ; } else { for ( int i = 0 ; i < 4 ; i ++ ) { x = dx [ i ] + x1 ; y = dy [ i ] + y1 ; if ( ifRight ( x , y , x2 , y2 , x3 , y3 ) ) { cout << "POSSIBLE" ; return ; } x = dx [ i ] + x2 ; y = dy [ i ] + y2 ; if ( ifRight ( x1 , y1 , x , y , x3 , y3 ) ) { cout << "POSSIBLE" ; return ; } x = dx [ i ] + x3 ; y = dy [ i ] + y3 ; if ( ifRight ( x1 , y1 , x2 , y2 , x , y ) ) { cout << "POSSIBLE" ; return ; } } } if ( ! possible ) cout << "NOT POSSIBLE" << endl ; }
double area_of_regular_polygon ( double n , double len ) { double P = ( len * n ) ; double A = len / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; double area = ( P * A ) / 2 ; return area ; }
double area_of_triangle_inscribed ( double n , double len ) { double area = area_of_regular_polygon ( n , len ) ; double triangle = area / n ; double ins_tri = ( triangle * 3 ) ; return ins_tri ; }
void maxRegions ( int n ) { int num ; num = n * ( n + 1 ) / 2 + 1 ; cout << num ; }
bool pointsAreOnSameSideOfLine ( int a , int b , int c , int x1 , int y1 , int x2 , int y2 ) { fx1 = a * x1 + b * y1 - c ; fx2 = a * x2 + b * y2 - c ; if ( ( fx1 * fx2 ) > 0 ) return true ; return false ; }
float Area ( int d , int h1 , int h2 ) { float area ; area = 0.5 * d * ( h1 + h2 ) ; return area ; }
float diagonal_length ( float a ) { float L ; L = a * sqrt ( 3 ) ; return L ; }
double find_area ( int r , int d ) { double R = d / PI ; R += pow ( r , 2 ) ; R = sqrt ( R ) ; double area = PI * pow ( R , 2 ) ; return area ; }
bool Valid ( int a , int b , int c , int d ) { if ( a + b + c + d == 360 ) return true ; return false ; }
bool Valid ( int a , int b , int c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return true ; else return false ; }
double calculate_angle ( double n ) { double total_angle = 360 ; return total_angle / n ; }
float areaOfKite ( int a , int b , double angle ) { angle = angle * PI ; double area = a * b * sin ( angle ) ; return area ; }
float angleOncirCumference ( float z ) { return ( z / 2 ) ; }
void newvol ( double x ) { cout << "percentage increase " << "in the volume of the cube is " << pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 << "%" << endl ; }
void newvol ( double x ) { cout << "percentage increase in the" << " volume of the sphere is " << pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 << "%" << endl ; }
int countZeroes ( int mat [ N ] [ N ] ) { int row = N - 1 , col = 0 ; int count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; }
void newvol ( double x ) { cout << "percentage increase " << "in the volume of the cylinder is " << x << "%" << endl ; }
void radius ( double n , double d ) { cout << "The side of each square is " << d / ( ( n - 1 ) * sqrt ( 2 ) ) << endl ; }
void findTriangles ( int n ) { int num = n ; cout << num << " " ; cout << num * ( num - 4 ) * ( num - 5 ) / 6 ; }
void radius ( int n , int d ) { cout << "The radius of each circle is " << d / ( 2 * n - 2 ) << endl ; }
void radius ( int n , int d ) { cout << "The side of each square is " << d / ( n - 1 ) << endl ; }
double innerCirclearea ( double radius ) { if ( radius < 0 ) { return -1 ; } double r = radius / 2 ; double Area = ( 3.14 * pow ( r , 2 ) ) ; return Area ; }
double areaOfTriangle ( float d ) { float c = 1.618 * d ; float s = ( d + c + c ) / 2 ; double area = sqrt ( s * ( s - c ) * ( s - c ) * ( s - d ) ) ; return 5 * area ; }
double areaOfRegPentagon ( float d ) { double cal = 4 * tan ( PI / 5 ) ; double area = ( 5 * d * d ) / cal ; return area ; }
double areaOfPentagram ( float d ) { return areaOfRegPentagon ( d ) + areaOfTriangle ( d ) ; }
void lengperpbisect ( double r1 , double r2 ) { double z = 2 * sqrt ( ( r1 * r1 ) - ( ( r1 - r2 ) * ( r1 - r2 ) / 4 ) ) ; cout << "The length of the " << "perpendicular bisector is " << z << endl ; }
void anglequichord ( int z ) { cout << "The angle is " << z << " degrees" << endl ; }
void lengchord ( int z ) { cout << "The length is " << z << endl ; }
void angleextcycquad ( int z ) { cout << "The exterior angle of the" << " cyclic quadrilateral is " << z << " degrees" << endl ; }
void anglechordtang ( int z ) { cout << "The angle between tangent" << " and the chord is " << z << " degrees" << endl ; }
void circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = sqrt ( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ) ; if ( distSq + r2 == r1 ) cout << "The smaller circle lies completely" << " inside the bigger circle with " << "touching each other " << "at a point of circumference. " << endl ; else if ( distSq + r2 < r1 ) cout << "The smaller circle lies completely" << " inside the bigger circle without" << " touching each other " << "at a point of circumference. " << endl ; else cout << "The smaller does not lies inside" << " the bigger circle completely." << endl ; }
int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return -1 ; else return 0 ; }
int countOdd ( int n ) { int coun = 0 , m , j , i ; for ( i = n - 2 ; i >= 1 ; i -- ) { if ( i & 1 ) { m = ( n - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } else { m = ( ( n - 1 ) - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } } return coun ; }
int countEven ( int n ) { int coun = 0 , m , j , i ; for ( i = n - 2 ; i >= 1 ; i -- ) { if ( i & 1 ) { m = ( ( n - 1 ) - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } else { m = ( n - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } } return coun ; }
int countNegative ( int M [ ] [ 4 ] , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; }
int GCD ( int a , int b ) { return ( b != 0 ? GCD ( b , a % b ) : a ) ; }
void ratiotang ( int r1 , int r2 ) { cout << "The ratio is " << r1 / GCD ( r1 , r2 ) << ":" << r2 / GCD ( r1 , r2 ) << endl ; }
int Regions ( int Vertices , int Edges ) { int R = Edges + 2 - Vertices ; return R ; }
void ratiotang ( int r1 , int r2 ) { cout << "The ratio is " << r1 / GCD ( r1 , r2 ) << " : " << r2 / GCD ( r1 , r2 ) << endl ; }
void lengthOfTangent ( double r1 , double r2 , double d ) { cout << "The length of the transverse" << " common tangent is " << sqrt ( pow ( d , 2 ) - pow ( ( r1 + r2 ) , 2 ) ) << endl ; }
int remainingArea ( int N , int M , int K ) { while ( K -- && N && M ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; }
void lengtang ( double r1 , double r2 , double d ) { cout << "The length of the direct" << " common tangent is " << sqrt ( pow ( d , 2 ) - pow ( ( r1 - r2 ) , 2 ) ) << endl ; }
void rad ( double d , double h ) { cout << "The radius of the circle is " << ( ( d * d ) / ( 8 * h ) + h / 2 ) << endl ; }
void lengtang ( double r1 , double r2 ) { cout << "The length of the " << "direct common tangent is " << 2 * sqrt ( r1 * r2 ) << endl ; }
void diameter ( double r ) { cout << "The length of the longest chord" << " or diameter of the circle is " << 2 * r << endl ; }
double dist ( double m , double b1 , double b2 ) { double d = fabs ( b2 - b1 ) / ( ( m * m ) - 1 ) ; return d ; }
double getSlope ( double m ) { return m ; }
LLI totalTriangles ( LLI h , LLI v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; LLI Total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return Total ; }
int findLargestPlus ( int mat [ N ] [ N ] ) { int left [ N ] [ N ] , right [ N ] [ N ] , top [ N ] [ N ] , bottom [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { top [ 0 ] [ i ] = mat [ 0 ] [ i ] ; bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] ; left [ i ] [ 0 ] = mat [ i ] [ 0 ] ; right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ; else left [ i ] [ j ] = 0 ; if ( mat [ j ] [ i ] == 1 ) top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 ; else top [ j ] [ i ] = 0 ; j = N - 1 - j ; if ( mat [ j ] [ i ] == 1 ) bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 ; else bottom [ j ] [ i ] = 0 ; if ( mat [ i ] [ j ] == 1 ) right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 ; else right [ i ] [ j ] = 0 ; j = N - 1 - j ; } } int n = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int len = min ( min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) ; if ( len > n ) n = len ; } } if ( n ) return 4 * ( n - 1 ) + 1 ; return 0 ; }
int noOfSquares ( int x1 , int y1 , int x2 , int y2 ) { int dx = abs ( x2 - x1 ) ; int dy = abs ( y2 - y1 ) ; int ans = dx + dy - __gcd ( dx , dy ) ; cout << ans ; }
int countSteps ( int x , int y ) { if ( x < y ) { return x + y + 2 * ( ( y - x ) / 2 ) ; } else { return x + y + 2 * ( ( ( x - y ) + 1 ) / 2 ) ; } }
bool isSlopeGood ( double slope , int arr [ ] , int n ) { set < double > setOfLines ; for ( int i = 0 ; i < n ; i ++ ) setOfLines . insert ( arr [ i ] - slope * ( i ) ) ; return setOfLines . size ( ) == 2 ; }
bool checkForParallel ( int arr [ ] , int n ) { bool slope1 = isSlopeGood ( arr [ 1 ] - arr [ 0 ] , arr , n ) ; bool slope2 = isSlopeGood ( arr [ 2 ] - arr [ 1 ] , arr , n ) ; bool slope3 = isSlopeGood ( ( arr [ 2 ] - arr [ 0 ] ) / 2 , arr , n ) ; return ( slope1 slope2 slope3 ) ; }
ll countPaths ( int x1 , int y1 , int x2 , int y2 ) { int m = abs ( x1 - x2 ) ; int n = abs ( y1 - y2 ) ; return ( binomialCoeff ( m + n , n ) ) ; }
pair < int , int > findFourthVertex ( int n , int m , string s [ ] ) { map < int , int > row , col ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( s [ i ] [ j ] == '*' ) { row [ i ] ++ ; col [ j ] ++ ; } int x , y ; for ( auto tm : row ) if ( tm . second == 1 ) x = tm . first ; for ( auto tm : col ) if ( tm . second == 1 ) y = tm . first ; return make_pair ( x + 1 , y + 1 ) ; }
float sph ( float r , float R , float h ) { if ( r < 0 && R < 0 && h < 0 ) return -1 ; float x = r ; float V = ( 4 * 3.14 * pow ( r , 3 ) ) / 3 ; return V ; }
float Area ( float a , float b ) { if ( a < 0 && b < 0 ) return -1 ; float h = sqrt ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ) ; float A = 0.70477 * pow ( h , 2 ) ; return A ; }
int maxRectangles ( int L , int B , int l , int b ) { int horizontal = 0 , vertical = 0 ; if ( l <= L && b <= B ) { int columns = B / b ; int rows = L / l ; horizontal = rows * columns ; } if ( l <= B && b <= L ) { int columns = L / b ; int rows = B / l ; vertical = rows * columns ; } return max ( horizontal , vertical ) ; }
float cone ( float a ) { if ( a < 0 ) return -1 ; float r = ( a * sqrt ( 2 ) ) / 3 ; float h = ( 2 * a ) / 3 ; float V = 3.14 * pow ( r , 2 ) * h ; return V ; }
float Area ( float a ) { if ( a < 0 ) return -1 ; float h = 1.268 * a ; float A = 0.70477 * pow ( h , 2 ) ; return A ; }
float Area ( float r ) { if ( r < 0 ) return -1 ; float x = ( 2 * r ) / sqrt ( 5 ) ; float A = 0.70477 * pow ( x , 2 ) ; return A ; }
float Area ( float a ) { if ( a < 0 ) return -1 ; float x = 0.464 * a ; float A = 0.70477 * pow ( x , 2 ) ; return A ; }
double areaCircle ( double b ) { double area = pi * b * b ; return area ; }
double areaSquare ( double side , double fold ) { double area = side * side ; return area * 1.0 / pow ( 2 , fold ) ; }
bool checkOrtho ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int m1 , m2 ; if ( x2 - x1 == 0 && x4 - x3 == 0 ) return false ; else if ( x2 - x1 == 0 ) { m2 = ( y4 - y3 ) / ( x4 - x3 ) ; if ( m2 == 0 ) return true ; else return false ; } else if ( x4 - x3 == 0 ) { m1 = ( y2 - y1 ) / ( x2 - x1 ) ; if ( m1 == 0 ) return true ; else return false ; } else { m1 = ( y2 - y1 ) / ( x2 - x1 ) ; m2 = ( y4 - y3 ) / ( x4 - x3 ) ; if ( m1 * m2 == -1 ) return true ; else return false ; } }
float square ( float a ) { if ( a < 0 ) return -1 ; float x = 0.464 * a ; return x ; }
float ReuleauxArea ( float r ) { if ( r < 0 ) return -1 ; float A = 0.70477 * 2 * pow ( r , 2 ) ; return A ; }
float cyl ( float a ) { if ( a < 0 ) return -1 ; float r = ( 2 * a * sqrt ( 2 ) ) / 3 ; float h = ( 2 * a ) / 3 ; float V = 3.14 * pow ( r , 2 ) * h ; return V ; }
float Area ( float l , float b , float h ) { if ( l < 0 b < 0 h < 0  ) return -1 ; float x = ( l * b ) / ( l + b ) ; float A = 0.70477 * pow ( x , 2 ) ; return A ; }
bool isPossible ( float x , float y , float z ) { float a = x * x + y * y + z * z ; if ( ceil ( a ) == 1 && floor ( a ) == 1 ) return true ; return false ; }
float polyapothem ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; return a / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; }
float polydiagonal ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; return 2 * a * sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ; }
float polyarea ( float n , float r ) { if ( r < 0 && n < 0 ) return -1 ; float A = ( ( r * r * n ) * sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; }
float decdiagonal ( float a ) { if ( a < 0 ) return -1 ; float d = 1.902 * a ; return d ; }
float hexagonside ( float a ) { if ( a < 0 ) return -1 ; float x = 0.5176 * a ; return x ; }
float hexagonside ( float a ) { if ( a < 0 ) return -1 ; float x = a / 3 ; return x ; }
float hexDiagonal ( float a ) { if ( a < 0 ) return -1 ; float d = 1.73 * a ; return d ; }
float pentdiagonal ( float a ) { if ( a < 0 ) return -1 ; float d = 1.22 * a ; return d ; }
float ReuleauxArea ( float a ) { if ( a < 0 ) return -1 ; float A = 0.70477 * pow ( a , 2 ) ; return A ; }
float calculateSide ( float n , float r ) { float theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return 2 * r * sin ( theta_in_radians / 2 ) ; }
float squareArea ( float a ) { if ( a < 0 ) return -1 ; float area = pow ( 1.268 , 2 ) * pow ( a , 2 ) ; return area ; }
float hexagonArea ( float d ) { return ( 3 * sqrt ( 3 ) * pow ( d , 2 ) ) / 8 ; }
float cyl ( float r , float R , float h ) { if ( h < 0 && r < 0 && R < 0 ) return -1 ; float r1 = r ; float h1 = h ; float V = 3.14 * pow ( r1 , 2 ) * h1 ; return V ; }
float findVolume ( float a ) { if ( a < 0 ) return -1 ; float r = a / 2 ; float h = a ; float V = 3.14 * pow ( r , 2 ) * h ; return V ; }
float length_rope ( float r ) { return ( ( 2 * PI * r ) + 6 * r ) ; }
float cube ( float h , float r ) { if ( h < 0 && r < 0 ) return -1 ; float a = pow ( h , 3 ) ; return a ; }
float sph ( float r , float h ) { if ( r < 0 && h < 0 ) return -1 ; float R = r ; return R ; }
float cyl ( float R ) { if ( R < 0 ) return -1 ; float V = ( 2 * 3.14 * pow ( R , 3 ) ) / ( 3 * sqrt ( 3 ) ) ; return V ; }
float rod ( float h , float r ) { if ( h < 0 && r < 0 ) return -1 ; float l = sqrt ( pow ( h , 2 ) + 4 * pow ( r , 2 ) ) ; return l ; }
float coner ( float R ) { if ( R < 0 ) return -1 ; float r = ( 2 * sqrt ( 2 ) * R ) / 3 ; return r ; }
float coneh ( float R ) { if ( R < 0 ) return -1 ; float h = ( 4 * R ) / 3 ; return h ; }
float coneRadius ( float a ) { if ( a < 0 ) return -1 ; float r = a / sqrt ( 2 ) ; return r ; }
float coneHeight ( float a ) { if ( a < 0 ) return -1 ; float h = a ; return h ; }
float largestCube ( float r ) { if ( r < 0 ) return -1 ; float a = ( 2 * r ) / sqrt ( 3 ) ; return a ; }
float sphere ( float a ) { if ( a < 0 ) return -1 ; float r = a / 2 ; return r ; }
int numberOfCuts ( int M , int N ) { int result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; }
float maxVol ( float P , float A ) { float l = ( P - sqrt ( P * P - 24 * A ) ) / 12 ; float V = l * ( A / 2.0 - l * ( P / 4.0 - l ) ) ; return V ; }
int maxArea ( float perimeter ) { int length = ( int ) ceil ( perimeter / 4 ) ; int breadth = ( int ) floor ( perimeter / 4 ) ; return length * breadth ; }
int findSegment ( int n , int m , int segment_length [ ] ) { double meet_point = ( 1.0 * n ) / 2.0 ; int sum = 0 ; int segment_number = 0 ; for ( int i = 0 ; i < m ; i ++ ) { sum += segment_length [ i ] ; if ( ( double ) sum == meet_point ) { segment_number = -1 ; break ; } if ( sum > meet_point ) { segment_number = i + 1 ; break ; } } return segment_number ; }
ll countMaxIntersect ( ll n ) { return ( n ) * ( n - 1 ) / 2 ; }
void equation_parabola ( float x1 , float y1 , float a , float b , float c ) { float t = a * a + b * b ; float a1 = t - ( a * a ) ; float b1 = t - ( b * b ) ; float c1 = ( -2 * t * x1 ) - ( 2 * c * a ) ; float d1 = ( -2 * t * y1 ) - ( 2 * c * b ) ; float e1 = -2 * a * b ; float f1 = ( - c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 1 ) ; cout << "equation of parabola is " << a1 << " x^2 + " << b1 << " y^2 + " << c1 << " x + " << d1 << " y + " << e1 << " xy + " << f1 << " = 0." ; }
int countRectangles ( int l , int w ) { int squareSide = __gcd ( l , w ) ; return ( l * w ) / ( squareSide * squareSide ) ; }
void section ( double x1 , double x2 , double y1 , double y2 , double z1 , double z2 , double m , double n ) { double x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) ; double y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) ; double z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) ; cout << "(" << x << ", " ; cout << y << ", " ; cout << z << ")" << endl ; }
int Squares ( int n , int m , int a ) { return ( ( m + a - 1 ) / a ) * ( ( n + a - 1 ) / a ) ; }
float area ( float r ) { return ( 0.5 ) * ( 3.14 ) * ( r * r ) ; }
bool checkEquilibrium ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 ) { int resx = x1 + x2 + x3 ; int resy = y1 + y2 + y3 ; int resz = z1 + z2 + z3 ; if ( resx == 0 and resy == 0 and resz == 0 ) return true ; else return false ; }
float hexadiagonal ( float a ) { if ( a < 0 ) return -1 ; return 2 * a ; }
float octadiagonal ( float a ) { if ( a < 0 ) return -1 ; return a * sqrt ( 4 + ( 2 * sqrt ( 2 ) ) ) ; }
void CalPeri ( ) { int s = 5 , Perimeter ; Perimeter = 10 * s ; cout << "The Perimeter of Decagon is : " << Perimeter ; }
float octaside ( float a ) { if ( a < 0 ) return -1 ; float s = a / ( sqrt ( 2 ) + 1 ) ; return s ; }
double findEdges ( double s1 , double s2 , double s3 ) { double a = sqrt ( s1 * s2 / s3 ) ; double b = sqrt ( s3 * s1 / s2 ) ; double c = sqrt ( s3 * s2 / s1 ) ; double sum = a + b + c ; return 4 * sum ; }
float findRadiusOfcircumcircle ( float n , float a ) { if ( n < 0 a < 0  ) return -1 ; float radius = a / sqrt ( 2 - ( 2 * cos ( 360 / n ) ) ) ; return radius ; }
float rhombusarea ( float l , float b ) { if ( l < 0 b < 0  ) return -1 ; return ( l * b ) / 2 ; }
bool Arrive ( int a , int b , int n ) { if ( n >= abs ( a ) + abs ( b ) and ( n - ( abs ( a ) + abs ( b ) ) ) % 2 == 0 ) return true ; return false ; }
bool Move ( int a , int x , int b ) { if ( ( ( ( b - a ) % x == 0 ) || ( ( b - a - 1 ) % x == 0 ) && a + 1 != b ) && b >= a ) return true ; return false ; }
float area ( float a , float b ) { if ( a < 0 b < 0  ) return -1 ; float A = a * b ; return A ; }
float circle_inscribed ( int a ) { return PI * ( a * a ) / 12 ; }
float surfaceArea ( float a , float b , float h ) { return 5 * a * b + 5 * b * h ; }
float volume ( float b , float h ) { return ( 5 * b * h ) / 2 ; }
float findRadiusOfcircumcircle ( float l , float b ) { if ( l < 0 b < 0  ) return -1 ; float radius = sqrt ( pow ( l , 2 ) + pow ( b , 2 ) ) / 2 ; return radius ; }
float circlearea ( float a , float b , float c ) { if ( a < 0 b < 0 c < 0  ) return -1 ; float p = ( a + b + c ) / 2 ; float At = sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; float A = 3.14 * pow ( ( ( a * b * c ) / ( 4 * At ) ) , 2 ) ; return A ; }
float altitude ( float a , float b ) { return sqrt ( pow ( a , 2 ) - ( pow ( b , 2 ) / 4 ) ) ; }
int surfaceArea ( int b , int s ) { return 2 * b * s + pow ( b , 2 ) ; }
float trianglearea ( float l , float b ) { if ( l < 0 b < 0  ) return -1 ; float area = ( l * b ) / 2 ; return area ; }
float area ( float a ) { if ( a < 0 ) return -1 ; float area = sqrt ( a ) / 6 ; return area ; }
void halfsquare ( int n , int x , int y ) { int half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) cout << "NO" << endl ; else cout << "YES" << endl ; }
int checkpoint ( int h , int k , int x , int y , int a ) { int p = pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ; return p ; }
int checkpoint ( int h , int k , int x , int y , int a , int b ) { int p = ( pow ( ( x - h ) , 2 ) / pow ( a , 2 ) ) + ( pow ( ( y - k ) , 2 ) / pow ( b , 2 ) ) ; return p ; }
float area ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { float area = sqrt ( pow ( ( y1 * z2 - y2 * z1 ) , 2 ) + pow ( ( x1 * z2 - x2 * z1 ) , 2 ) + pow ( ( x1 * y2 - x2 * y1 ) , 2 ) ) ; area = area / 2 ; return area ; }
float trianglearea ( float a , float b ) { if ( a < 0 b < 0  ) return -1 ; float area = ( 3 * sqrt ( 3 ) * pow ( a , 2 ) ) / ( 4 * b ) ; return area ; }
float squarearea ( float a , float b ) { if ( a < 0 b < 0  ) return -1 ; float area = 4 * ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ; return area ; }
double longestRodInCuboid ( int length , int breadth , int height ) { double result ; int temp ; temp = length * length + breadth * breadth + height * height ; result = sqrt ( temp ) ; return result ; }
float trianglearea ( float r ) { if ( r < 0 ) return -1 ; return r * r ; }
float squarearea ( float r ) { if ( r < 0 ) return -1 ; float a = 4 * ( pow ( r , 2 ) / 5 ) ; return a ; }
float rectanglearea ( float a , float b ) { if ( a < 0 b < 0  ) return -1 ; return 2 * a * b ; }
float trapezoidarea ( float r ) { if ( r < 0 ) return -1 ; float a = ( 3 * sqrt ( 3 ) * pow ( r , 2 ) ) / 4 ; return a ; }
float squareArea ( float l , float b , float h ) { if ( l < 0 b < 0 h < 0  ) return -1 ; float a = ( l * b ) / ( l + b ) ; return a * a ; }
float circlearea ( float a , float b ) { if ( a < 0 b < 0  ) return -1 ; float A = ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) ; return A ; }
float circlearea ( float l , float b ) { if ( l < 0 b < 0  ) return -1 ; if ( l < b ) return 3.14 * pow ( l / 2 , 2 ) ; else return 3.14 * pow ( b / 2 , 2 ) ; }
int maxLines ( int n , int x1 [ ] , int y1 [ ] , int x2 [ ] , int y2 [ ] ) { unordered_set < double > s ; double slope ; for ( int i = 0 ; i < n ; ++ i ) { if ( x1 [ i ] == x2 [ i ] ) slope = INT_MAX ; else slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) * 1.0 ; s . insert ( slope ) ; } return s . size ( ) ; }
int squares ( int l , int b , int a ) { return ceil ( l / ( double ) a ) * ceil ( b / ( double ) a ) ; }
int gcd ( int a , int b ) { if ( a == 0 b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
int squarearea ( int l , int b ) { if ( l < 0 b < 0  ) return -1 ; int n = ( l * b ) / gcd ( l , b ) ; return n * n ; }
float angle_triangle ( int x1 , int x2 , int x3 , int y1 , int y2 , int y3 , int z1 , int z2 , int z3 ) { int num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) ; float den = sqrt ( pow ( ( x2 - x1 ) , 2 ) + pow ( ( y2 - y1 ) , 2 ) + pow ( ( z2 - z1 ) , 2 ) ) * sqrt ( pow ( ( x3 - x1 ) , 2 ) + pow ( ( y3 - y1 ) , 2 ) + pow ( ( z3 - z1 ) , 2 ) ) ; float angle = acos ( num / den ) * ( 180.0 / 3.141592653589793238463 ) ; return angle ; }
void is_partition_possible ( int n , int x [ ] , int y [ ] , int w [ ] ) { map < int , int > weight_at_x ; int max_x = -2e3 , min_x = 2e3 ; for ( int i = 0 ; i < n ; i ++ ) { int new_x = x [ i ] - y [ i ] ; max_x = max ( max_x , new_x ) ; min_x = min ( min_x , new_x ) ; weight_at_x [ new_x ] += w [ i ] ; } vector < int > sum_till ; sum_till . push_back ( 0 ) ; for ( int x = min_x ; x <= max_x ; x ++ ) { sum_till . push_back ( sum_till . back ( ) + weight_at_x [ x ] ) ; } int total_sum = sum_till . back ( ) ; int partition_possible = false ; for ( int i = 1 ; i < sum_till . size ( ) ; i ++ ) { if ( sum_till [ i ] == total_sum - sum_till [ i ] ) partition_possible = true ; if ( sum_till [ i - 1 ] == total_sum - sum_till [ i ] ) partition_possible = true ; } printf ( partition_possible ? "YES\n" : "NO\n" ) ; }
void makePolygon ( float a ) { float n = 360 / ( 180 - a ) ; if ( n == ( int ) n ) cout << "YES" ; else cout << "NO" ; }
bool LiesInsieRectangle ( int a , int b , int x , int y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; }
float area ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { float area = sqrt ( pow ( ( y1 * z2 - y2 * z1 ) , 2 ) + pow ( ( x1 * z2 - x2 * z1 ) , 2 ) + pow ( ( x1 * y2 - x2 * y1 ) , 2 ) ) ; return area ; }
void equation_plane ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 , int x , int y , int z ) { int a1 = x2 - x1 ; int b1 = y2 - y1 ; int c1 = z2 - z1 ; int a2 = x3 - x1 ; int b2 = y3 - y1 ; int c2 = z3 - z1 ; int a = b1 * c2 - b2 * c1 ; int b = a2 * c1 - a1 * c2 ; int c = a1 * b2 - b1 * a2 ; int d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) cout << "Coplanar" << endl ; else cout << "Not Coplanar" << endl ; }
int solve ( int M , int N , int s ) { if ( N % s == 0 ) { N = N / s ; } else { N = ( N / s ) + 1 ; } if ( M % s == 0 ) { M = M / s ; } else { M = ( M / s ) + 1 ; } return M * N ; }
int max_intersection ( int * center , int length , int k ) { sort ( center , center + 3 ) ; if ( center [ 2 ] - center [ 0 ] >= 2 * k + length ) { return 0 ; } else if ( center [ 2 ] - center [ 0 ] >= 2 * k ) { return ( 2 * k - ( center [ 2 ] - center [ 0 ] - length ) ) ; } else return length ; }
void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = max ( x1 , x3 ) ; int y5 = max ( y1 , y3 ) ; int x6 = min ( x2 , x4 ) ; int y6 = min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { cout << "No intersection" ; return ; } cout << "(" << x5 << ", " << y5 << ") " ; cout << "(" << x6 << ", " << y6 << ") " ; int x7 = x5 ; int y7 = y6 ; cout << "(" << x7 << ", " << y7 << ") " ; int x8 = x6 ; int y8 = y5 ; cout << "(" << x8 << ", " << y8 << ") " ; }
bool FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 and x < x2 and y > y1 and y < y2 ) return true ; return false ; }
void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) { float x1 , y1 , z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { x1 = y1 = 0 ; z1 = - d1 / c1 ; d = fabs ( ( c2 * z1 + d2 ) ) / ( sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; cout << "Perpendicular distance is " << d << endl ; } else cout << "Planes are not parallel" ; return ; }
void distance ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { float d = ( a1 * a2 + b1 * b2 + c1 * c2 ) ; float e1 = sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; float e2 = sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = d / ( e1 * e2 ) ; float pi = 3.14159 ; float A = ( 180 / pi ) * ( acos ( d ) ) ; cout << "Angle is " << A << " degree" ; }
static double haversine ( double lat1 , double lon1 , double lat2 , double lon2 ) { double dLat = ( lat2 - lat1 ) * M_PI / 180.0 ; double dLon = ( lon2 - lon1 ) * M_PI / 180.0 ; lat1 = ( lat1 ) * M_PI / 180.0 ; lat2 = ( lat2 ) * M_PI / 180.0 ; double a = pow ( sin ( dLat / 2 ) , 2 ) + pow ( sin ( dLon / 2 ) , 2 ) * cos ( lat1 ) * cos ( lat2 ) ; double rad = 6371 ; double c = 2 * asin ( sqrt ( a ) ) ; return rad * c ; }
void equation_plane ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 ) { float a1 = x2 - x1 ; float b1 = y2 - y1 ; float c1 = z2 - z1 ; float a2 = x3 - x1 ; float b2 = y3 - y1 ; float c2 = z3 - z1 ; float a = b1 * c2 - b2 * c1 ; float b = a2 * c1 - a1 * c2 ; float c = a1 * b2 - b1 * a2 ; float d = ( - a * x1 - b * y1 - c * z1 ) ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 2 ) ; cout << "equation of plane is " << a << " x + " << b << " y + " << c << " z + " << d << " = 0." ; }
float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; }
int countNumberOfTriangles ( int n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; }
int countRectangles ( int radius ) { int rectangles = 0 ; int diameter = 2 * radius ; int diameterSquare = diameter * diameter ; for ( int a = 1 ; a < 2 * radius ; a ++ ) { for ( int b = 1 ; b < 2 * radius ; b ++ ) { int diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; }
int simi_aaa ( int a1 [ ] , int a2 [ ] ) { sort ( a1 , a1 + 3 ) ; sort ( a2 , a2 + 3 ) ; if ( a1 [ 0 ] == a2 [ 0 ] && a1 [ 1 ] == a2 [ 1 ] && a1 [ 2 ] == a2 [ 2 ] ) return 1 ; else return 0 ; }
int simi_sas ( int s1 [ ] , int s2 [ ] , int a1 [ ] , int a2 [ ] ) { sort ( a1 , a1 + 3 ) ; sort ( a2 , a2 + 3 ) ; sort ( s1 , s1 + 3 ) ; sort ( s2 , s2 + 3 ) ; if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] ) { if ( a1 [ 2 ] == a2 [ 2 ] ) return 1 ; } if ( s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] ) { if ( a1 [ 0 ] == a2 [ 0 ] ) return 1 ; } if ( s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) { if ( a1 [ 1 ] == a2 [ 1 ] ) return 1 ; } return 0 ; }
int simi_sss ( int s1 [ ] , int s2 [ ] ) { sort ( s1 , s1 + 3 ) ; sort ( s2 , s2 + 3 ) ; if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] && s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] && s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) return 1 ; return 0 ; }
int centeredDodecagonal ( long int n ) { return 6 * n * ( n - 1 ) + 1 ; }
int heptagonalNumber ( int n ) { return ( ( 5 * n * n ) - ( 3 * n ) ) / 2 ; }
int centeredTridecagonalNum ( long int n ) { return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; }
int pentagon_pyramidal ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; }
int pentagon_pyramidal ( int n ) { return n * n * ( n + 1 ) / 2 ; }
bool checkConcurrent ( int a1 , int b1 , int c1 , int a2 , int b2 , int c2 , int a3 , int b3 , int c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }
int getQuadrant ( int X , int Y , int R , int PX , int PY ) { if ( PX == X && PY == Y ) return 0 ; int val = pow ( ( PX - X ) , 2 ) + pow ( ( PY - Y ) , 2 ) ; if ( val > pow ( R , 2 ) ) return -1 ; if ( PX > X && PY >= Y ) return 1 ; if ( PX <= X && PY > Y ) return 2 ; if ( PX < X && PY <= Y ) return 3 ; if ( PX >= X && PY < Y ) return 4 ; }
int center_pentadecagonal_num ( long int n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; }
int icosidigonal_num ( long int n ) { return ( 20 * n * n - 18 * n ) / 2 ; }
int center_nonadecagon_num ( long int n ) { return ( 19 * n * n - 19 * n + 2 ) / 2 ; }
int center_octadecagon_num ( long int n ) { return 9 * n * n - 9 * n + 1 ; }
int hendecagonal_num ( int n ) { return ( 9 * n * n - 7 * n ) / 2 ; }
int centereddecagonalnum ( int n ) { return ( 5 * n * n + 5 * n + 1 ) ; }
void Ksmallest ( int x , int y , int k ) { if ( x == 0 && y == 0 ) return ; else if ( x == 0 ) { y -- ; cout << "V" ; Ksmallest ( x , y , k ) ; } else if ( y == 0 ) { x -- ; cout << "H" ; Ksmallest ( x , y , k ) ; } else { if ( factorial ( x - 1 , y ) > k ) { cout << "H" ; Ksmallest ( x - 1 , y , k ) ; } else { cout << "V" ; Ksmallest ( x , y - 1 , k - factorial ( x - 1 , y ) ) ; } } }
int nthEnneadecagonal ( long int n ) { return ( 17 * n * n - 15 * n ) / 2 ; }
void inorder ( node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; cout << "TABSYMBOL" << root -> data ; inorder ( root -> right ) ; } }
int centered_pentagonal_Num ( int n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; }
void findPoint ( int x1 , int y1 , int x2 , int y2 ) { cout << "(" << 2 * x2 - x1 << ", " << 2 * y2 - y1 << ")" ; }
int pivotDis ( int x0 , int y0 , int x1 , int y1 ) { return sqrt ( ( x1 - x0 ) * ( x1 - x0 ) + ( y1 - y0 ) * ( y1 - y0 ) ) ; }
int minDis ( int D , int r1 , int r2 ) { return max ( ( D - r1 - r2 ) , 0 ) ; }
int maxDis ( int D , int r1 , int r2 ) { return D + r1 + r2 ; }
double findPCSlope ( double m ) { return -1.0 / m ; }
void otherEndPoint ( int x1 , int y1 , int m1 , int m2 ) { float x2 = ( float ) ( 2 * m1 - x1 ) ; float y2 = ( float ) ( 2 * m2 - y1 ) ; cout << "x2 = " << x2 << ", " << "y2 = " << y2 ; }
bool isValid ( int arr [ ] , int i , int j , int m , int c ) { if ( i == j ) return false ; int lhs = arr [ j ] ; int rhs = m * arr [ i ] + c ; return ( lhs == rhs ) ; }
int findOrderedPoints ( int arr [ ] , int n , int m , int c ) { int counter = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int firstIndex = i , secondIndex = j ; if ( isValid ( arr , firstIndex , secondIndex , m , c ) ) counter ++ ; } } return counter ; }
int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
int overlappingArea ( Point l1 , Point r1 , Point l2 , Point r2 ) { int area1 = abs ( l1 . x - r1 . x ) * abs ( l1 . y - r1 . y ) ; int area2 = abs ( l2 . x - r2 . x ) * abs ( l2 . y - r2 . y ) ; int x_dist = min ( r1 . x , r2 . x ) - max ( l1 . x , l2 . x ) ; int y_dist = ( min ( r1 . y , r2 . y ) - max ( l1 . y , l2 . y ) ) ; int areaI = 0 ; if ( x_dist > 0 && y_dist > 0 ) { areaI = x_dist * y_dist ; } return ( area1 + area2 - areaI ) ; }
bool checkOrigin ( int x1 , int y1 , int x2 , int y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; }
bool checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { int dis = sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; }
float areacircumscribed ( float a ) { return ( a * a * ( PI / 2 ) ) ; }
double surface_area_octahedron ( double side ) { return ( 2 * ( sqrt ( 3 ) ) * ( side * side ) ) ; }
int find_Area ( int r ) { return ( 2 * r * r ) ; }
bool checkValidity ( int a , int b , int c ) { if ( a + b <= c a + c <= b b + c <= a ) return false ; else return true ; }
bool isRectangle ( int a , int b , int c , int d ) { if ( a == b == c == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; }
int nCk ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
int count_Straightlines ( int n , int m ) { return ( nCk ( n , 2 ) - nCk ( m , 2 ) + 1 ) ; }
bool isBetween ( int a , int b , int c ) { return min ( a , b ) <= c && c <= max ( a , b ) ; }
bool canJoin ( int x [ ] , int y [ ] , int i , int j , int k ) { return ( x [ k ] == x [ i ] x [ k ] == x [ j ] ) && isBetween ( y [ i ] , y [ j ] , y [ k ] ) || ( y [ k ] == y [ i ] y [ k ] == y [ j ] ) && isBetween ( x [ i ] , x [ j ] , x [ k ] ) ; }
int countLineSegments ( int x [ ] , int y [ ] ) { if ( ( x [ 0 ] == x [ 1 ] && x [ 1 ] == x [ 2 ] ) || ( y [ 0 ] == y [ 1 ] && y [ 1 ] == y [ 2 ] ) ) return 1 ; else if ( canJoin ( x , y , 0 , 1 , 2 ) || canJoin ( x , y , 0 , 2 , 1 ) || canJoin ( x , y , 1 , 2 , 0 ) ) return 2 ; else return 3 ; }
double vol_of_dodecahedron ( int side ) { return ( ( ( 15 + ( 7 * ( sqrt ( 5 ) ) ) ) / 4 ) * ( pow ( side , 3 ) ) ) ; }
int perimeter ( int diameter , int height ) { return 2 * ( diameter + height ) ; }
float area_of_segment ( float radius , float angle ) { float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; }
void midpoint ( int x1 , int x2 , int y1 , int y2 ) { cout << ( float ) ( x1 + x2 ) / 2 << " , " << ( float ) ( y1 + y2 ) / 2 ; }
int contribution_height ( int current , int previous ) { return abs ( current - previous ) ; }
int surfaceArea ( int A [ N ] [ M ] ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int up = 0 ; int left = 0 ; if ( i > 0 ) up = A [ i - 1 ] [ j ] ; if ( j > 0 ) left = A [ i ] [ j - 1 ] ; ans += contribution_height ( A [ i ] [ j ] , up ) + contribution_height ( A [ i ] [ j ] , left ) ; if ( i == N - 1 ) ans += A [ i ] [ j ] ; if ( j == M - 1 ) ans += A [ i ] [ j ] ; } } ans += N * M * 2 ; return ans ; }
double area_of_tetrahedron ( int side ) { return ( sqrt ( 3 ) * ( side * side ) ) ; }
double vol_tetra ( int side ) { double volume = ( pow ( side , 3 ) / ( 6 * sqrt ( 2 ) ) ) ; return volume ; }
void overflow ( int H , int r , int h , int N , int R ) { float tank_cap = 3.14 * r * r * H ; float water_vol = 3.14 * r * r * h ; float balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; float vol = water_vol + balls_vol ; if ( vol > tank_cap ) { cout << "Overflow" << endl ; } else { cout << "Not in overflow state" << endl ; } }
float volume ( int radius , int height ) { return ( ( 22 / 7 ) * radius * radius * height ) ; }
int maxvolume ( int s ) { int maxvalue = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; maxvalue = max ( maxvalue , i * j * k ) ; } } return maxvalue ; }
int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; }
float volumeOfEllipsoid ( float r1 , float r2 , float r3 ) { float pi = 3.14 ; return 1.33 * pi * r1 * r2 * r3 ; }
float slope ( float x1 , float y1 , float x2 , float y2 ) { if ( x1 == x2 ) return INT_MAX ; return ( y2 - y1 ) / ( x2 - x1 ) ; }
float cal_cos ( float n ) { float accuracy = 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= fabs ( cosval - cosx ) ) ; return cosx ; }
float third_side ( int a , int b , float c ) { float angle = cal_cos ( c ) ; return sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) ; }
float volumeTriangular ( int a , int b , int h ) { float vol = ( 0.1666 ) * a * b * h ; return vol ; }
float volumeSquare ( int b , int h ) { float vol = ( 0.33 ) * b * b * h ; return vol ; }
float volumePentagonal ( int a , int b , int h ) { float vol = ( 0.83 ) * a * b * h ; return vol ; }
float volumeHexagonal ( int a , int b , int h ) { float vol = a * b * h ; return vol ; }
double areaOctagon ( double side ) { return ( float ) ( 2 * ( 1 + sqrt ( 2 ) ) * side * side ) ; }
double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; }
double hexagonArea ( double s ) { return ( ( 3 * sqrt ( 3 ) * ( s * s ) ) / 2 ) ; }
int findCommon ( int mat [ M ] [ N ] ) { int column [ M ] ; int min_row ; int i ; for ( i = 0 ; i < M ; i ++ ) column [ i ] = N - 1 ; min_row = 0 ; while ( column [ min_row ] >= 0 ) { for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) min_row = i ; } int eq_count = 0 ; for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) { if ( column [ i ] == 0 ) return -1 ; column [ i ] -= 1 ; } else eq_count ++ ; } if ( eq_count == M ) return mat [ min_row ] [ column [ min_row ] ] ; } return -1 ; }
int Circumference ( int a ) { return 4 * a ; }
double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { cout << "Angle cannot" , " be formed" ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } }
void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) cout << "Angle not possible" ; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; cout << sector ; } }
int findCommon ( int mat [ M ] [ N ] ) { unordered_map < int , int > cnt ; int i , j ; for ( i = 0 ; i < M ; i ++ ) { cnt [ mat [ i ] [ 0 ] ] ++ ; for ( j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) cnt [ mat [ i ] [ j ] ] ++ ; } } for ( auto ele : cnt ) { if ( ele . second == M ) return ele . first ; } return -1 ; }
double surfaceAreaCuboid ( double l , double h , double w ) { return ( 2 * l * w + 2 * w * h + 2 * l * h ) ; }
double surfaceCube ( double a ) { return ( 6 * a * a ) ; }
int minRadius ( int k , int x [ ] , int y [ ] , int n ) { int dis [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; sort ( dis , dis + n ) ; return dis [ k - 1 ] ; }
int areaRectangle ( int a , int b ) { int area = a * b ; return area ; }
int perimeterRectangle ( int a , int b ) { int perimeter = 2 * ( a + b ) ; return perimeter ; }
int areaSquare ( int side ) { int area = side * side ; return area ; }
int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; }
int minPerimeter ( int n ) { int l = sqrt ( n ) ; int sq = l * l ; if ( sq == n ) return l * 4 ; else { long long int row = n / l ; long long int perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }
void checkCollision ( int a , int b , int c , int x , int y , int radius ) { int dist = ( abs ( a * x + b * y + c ) ) / sqrt ( a * a + b * b ) ; if ( radius == dist ) cout << "Touch" << endl ; else if ( radius > dist ) cout << "Intersect" << endl ; else cout << "Outside" << endl ; }
void possibleOrNot ( long long a1 , long long a2 , long long b1 , long long b2 , long long c1 , long long c2 ) { long long dis1 = pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) ; long long dis2 = pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) ; if ( dis1 != dis2 ) cout << "No" ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) cout << "No" ; else cout << "Yes" ; }
int replaceSurrounded ( char mat [ ] [ N ] ) { for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] == 'O' ) mat [ i ] [ j ] = '-' ; for ( int i = 0 ; i < M ; i ++ ) if ( mat [ i ] [ 0 ] == '-' ) floodFillUtil ( mat , i , 0 , '-' , 'O' ) ; for ( int i = 0 ; i < M ; i ++ ) if ( mat [ i ] [ N - 1 ] == '-' ) floodFillUtil ( mat , i , N - 1 , '-' , 'O' ) ; for ( int i = 0 ; i < N ; i ++ ) if ( mat [ 0 ] [ i ] == '-' ) floodFillUtil ( mat , 0 , i , '-' , 'O' ) ; for ( int i = 0 ; i < N ; i ++ ) if ( mat [ M - 1 ] [ i ] == '-' ) floodFillUtil ( mat , M - 1 , i , '-' , 'O' ) ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] == '-' ) mat [ i ] [ j ] = 'X' ; }
void fitOrNotFit ( int R , int r , int x , int y , int rad ) { double val = sqrt ( pow ( x , 2 ) + pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) cout << "Fits\n" ; else cout << "Doesn't Fit\n" ; }
bool check ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 , int x , int y ) { float A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) + area ( x1 , y1 , x4 , y4 , x3 , y3 ) ; float A1 = area ( x , y , x1 , y1 , x2 , y2 ) ; float A2 = area ( x , y , x2 , y2 , x3 , y3 ) ; float A3 = area ( x , y , x3 , y3 , x4 , y4 ) ; float A4 = area ( x , y , x1 , y1 , x4 , y4 ) ; return ( A == A1 + A2 + A3 + A4 ) ; }
int rectCount ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; }
int countObtuseAngles ( int a , int b , int k ) { int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return min ( c1 , c2 ) ; }
int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= sqrt ( n ) ; ++ length ) for ( int height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }
void isPolygonPossible ( int arr [ ] , int N ) { int limit = sqrt ( N ) ; for ( int i = 1 ; i <= limit ; i ++ ) { if ( N % i == 0 ) { if ( checkPolygonWithMidpoints ( arr , N , i ) || checkPolygonWithMidpoints ( arr , N , ( N / i ) ) ) return ; } } cout << "Not possiblen" ; }
int minRevolutions ( double r , int x1 , int y1 , int x2 , int y2 ) { double d = sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return ceil ( d / ( 2 * r ) ) ; }
bool inside ( vector < pair < int , int > > a , pair < int , int > p ) { pair < int , int > mid = { 0 , 0 } ; int n = a . size ( ) ; p . first *= n ; p . second *= n ; for ( int i = 0 ; i < n ; i ++ ) { mid . first += a [ i ] . first ; mid . second += a [ i ] . second ; a [ i ] . first *= n ; a [ i ] . second *= n ; } for ( int i = 0 , j ; i < n ; i ++ ) { j = ( i + 1 ) % n ; int x1 = a [ i ] . first , x2 = a [ j ] . first ; int y1 = a [ i ] . second , y2 = a [ j ] . second ; int a1 = y1 - y2 ; int b1 = x2 - x1 ; int c1 = x1 * y2 - y1 * x2 ; int for_mid = a1 * mid . first + b1 * mid . second + c1 ; int for_p = a1 * p . first + b1 * p . second + c1 ; if ( for_mid * for_p < 0 ) return false ; } return true ; }
void addPoint ( vector < pair < int , int > > & a , pair < int , int > p ) { if ( inside ( a , p ) ) return ; int ind = 0 ; int n = a . size ( ) ; for ( int i = 1 ; i < n ; i ++ ) if ( sqDist ( p , a [ i ] ) < sqDist ( p , a [ ind ] ) ) ind = i ; int up = ind ; while ( orientation ( p , a [ up ] , a [ ( up + 1 ) % n ] ) >= 0 ) up = ( up + 1 ) % n ; int low = ind ; while ( orientation ( p , a [ low ] , a [ ( n + low - 1 ) % n ] ) <= 0 ) low = ( n + low - 1 ) % n ; vector < pair < int , int > > ret ; int curr = up ; ret . push_back ( a [ curr ] ) ; while ( curr != low ) { curr = ( curr + 1 ) % n ; ret . push_back ( a [ curr ] ) ; } ret . push_back ( p ) ; a . clear ( ) ; for ( int i = 0 ; i < ret . size ( ) ; i ++ ) a . push_back ( ret [ i ] ) ; }
int getDistance ( int x1 , int y1 , int x2 , int y2 ) { return ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ; }
int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = floor ( base / 2 ) ; return base * ( base + 1 ) / 2 ; }
int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
void preprocess ( int p [ ] , int x [ ] , int y [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) p [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; sort ( p , p + n ) ; }
int query ( int p [ ] , int n , int rad ) { int start = 0 , end = n - 1 ; while ( ( end - start ) > 1 ) { int mid = ( start + end ) / 2 ; double tp = sqrt ( p [ mid ] ) ; if ( tp > ( rad * 1.0 ) ) end = mid - 1 ; else start = mid ; } double tp1 = sqrt ( p [ start ] ) , tp2 = sqrt ( p [ end ] ) ; if ( tp1 > ( rad * 1.0 ) ) return 0 ; else if ( tp2 <= ( rad * 1.0 ) ) return end + 1 ; else return start + 1 ; }
double getArea ( double base , double hypotenuse ) { double height = sqrt ( hypotenuse * hypotenuse - base * base ) ; return 0.5 * base * height ; }
void printRightAngleTriangle ( int hypotenuse , int area ) { int hsquare = hypotenuse * hypotenuse ; double sideForMaxArea = sqrt ( hsquare / 2.0 ) ; double maxArea = getArea ( sideForMaxArea , hypotenuse ) ; if ( area > maxArea ) { cout << "Not possiblen" ; return ; } double low = 0.0 ; double high = sideForMaxArea ; double base ; while ( abs ( high - low ) > eps ) { base = ( low + high ) / 2.0 ; if ( getArea ( base , hypotenuse ) >= area ) high = base ; else low = base ; } double height = sqrt ( hsquare - base * base ) ; cout << base << " " << height << endl ; }
float squareRoot ( float n ) { float x = n ; float y = 1 ; float e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }
int findMaximumHeight ( int N ) { int n = 1 + 8 * N ; int maxH = ( -1 + squareRoot ( n ) ) / 2 ; return maxH ; }
double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return abs ( area / 2.0 ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int getCount ( Point p , Point q ) { if ( p . x == q . x ) return abs ( p . y - q . y ) - 1 ; if ( p . y == q . y ) return abs ( p . x - q . x ) - 1 ; return gcd ( abs ( p . x - q . x ) , abs ( p . y - q . y ) ) - 1 ; }
int getMinSteps ( int n ) { int table [ n + 1 ] ; table [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! ( i % 2 ) && ( i % 3 ) ) table [ i ] = 1 + min ( table [ i - 1 ] , table [ i / 2 ] ) ; else if ( ! ( i % 3 ) && ( i % 2 ) ) table [ i ] = 1 + min ( table [ i - 1 ] , table [ i / 3 ] ) ; else if ( ! ( i % 2 ) && ! ( i % 3 ) ) table [ i ] = 1 + min ( table [ i - 1 ] , min ( table [ i / 2 ] , table [ i / 3 ] ) ) ; else table [ i ] = 1 + table [ i - 1 ] ; } return table [ n ] ; }
int distSq ( Point p , Point q ) { return ( p . x - q . x ) * ( p . x - q . x ) + ( p . y - q . y ) * ( p . y - q . y ) ; }
double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return abs ( area / 2.0 ) ; }
void youngify ( int mat [ ] [ N ] , int i , int j ) { int downVal = ( i + 1 < N ) ? mat [ i + 1 ] [ j ] : INF ; int rightVal = ( j + 1 < N ) ? mat [ i ] [ j + 1 ] : INF ; if ( downVal == INF && rightVal == INF ) return ; if ( downVal < rightVal ) { mat [ i ] [ j ] = downVal ; mat [ i + 1 ] [ j ] = INF ; youngify ( mat , i + 1 , j ) ; } else { mat [ i ] [ j ] = rightVal ; mat [ i ] [ j + 1 ] = INF ; youngify ( mat , i , j + 1 ) ; } }
int extractMin ( int mat [ ] [ N ] ) { int ret = mat [ 0 ] [ 0 ] ; mat [ 0 ] [ 0 ] = INF ; youngify ( mat , 0 , 0 ) ; return ret ; }
void printSorted ( int mat [ ] [ N ] ) { cout << "Elements of matrix in sorted order n" ; for ( int i = 0 ; i < N * N ; i ++ ) cout << extractMin ( mat ) << " " ; }
double f ( double x , int p , double num ) { return pow ( x , p ) - num ; }
double f_prime ( double x , int p ) { return p * pow ( x , p - 1 ) ; }
int minimumAdditionOperation ( unsigned long long int N ) { int count = 0 ; while ( N ) { if ( N & 1 == 1 ) { count ++ ; } N = N >> 1 ; } return count ; }
int minimumOperations ( int arr [ ] , int N ) { int mini = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; while ( arr [ i ] % 2 == 0 ) { arr [ i ] = arr [ i ] / 2 ; count ++ ; } if ( mini > count ) { mini = count ; } } return mini ; }
int minimumSizeArr ( int A , int B ) { int currXor = 0 ; int reminder = ( A - 1 ) % 4 ; if ( reminder == 0 ) currXor = A - 1 ; else if ( reminder == 1 ) currXor = 1 ; else if ( reminder == 2 ) currXor = A ; int minSize = A ; if ( currXor == B ) return minSize ; else if ( currXor ^ B == A ) return minSize + 2 ; else return minSize + 1 ; }
void modifiedSieve ( ) { memset ( gpf , 0 , sizeof ( gpf ) ) ; gpf [ 0 ] = 0 ; gpf [ 1 ] = 1 ; for ( int i = 2 ; i < maxn ; i ++ ) { if ( gpf [ i ] > 0 ) continue ; for ( int j = i ; j < maxn ; j += i ) { gpf [ j ] = max ( i , gpf [ j ] ) ; } } }
int greatestValidInt ( int N ) { modifiedSieve ( ) ; for ( int i = N ; i > 0 ; i -- ) { if ( gpf [ i ] > sqrt ( i ) ) { return i ; } } return -1 ; }
void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= mxn ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= mxn ; i += p ) prime [ i ] = false ; } } }
int countMin ( int arr [ ] , int n ) { int cMinSwaps = 0 ; int cPrimeIndices = 0 ; int cPrimeNos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ i + 1 ] ) { cPrimeIndices ++ ; if ( ! prime [ arr [ i ] ] ) cMinSwaps ++ ; else cPrimeNos ++ ; } else if ( prime [ arr [ i ] ] ) { cPrimeNos ++ ; } } if ( cPrimeNos >= cPrimeIndices ) return cMinSwaps ; else return -1 ; }
double subfactorial ( int N ) { double res = 0 , fact = 1 ; int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = fact * i ; if ( count % 2 == 0 ) res = res - ( 1 / fact ) ; else res = res + ( 1 / fact ) ; count ++ ; } return fact * ( 1 + res ) ; }
int minOperations ( int A [ ] , int B [ ] , int N ) { int cnt = 0 ; int i = 0 ; while ( i < N ) { int j = 0 ; while ( j < N && i < N ) { if ( B [ i ] == A [ j ] ) { i ++ ; } j ++ ; } cnt ++ ; } return cnt ; }
int countPairs ( int N ) { int res = 0 ; for ( int q = 1 ; q * q <= N ; q ++ ) { int maxP = min ( 2 * N - q , N / q ) ; if ( maxP < q ) continue ; int cnt = maxP - q + 1 ; res += ( cnt / 2 + ( cnt & 1 ) ) ; } return res ; }
void largestSubset ( int a [ ] , int N ) { int bit [ 32 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int x = 31 ; while ( a [ i ] > 0 ) { if ( a [ i ] & 1 == 1 ) { bit [ x ] ++ ; } a [ i ] = a [ i ] >> 1 ; x -- ; } } cout << * max_element ( bit , bit + 32 ) ; }
int countDistinctSums ( int N , int L , int R ) { int minSum = L * N ; int maxSum = R * N ; return maxSum - minSum + 1 ; }
void setSumtoZero ( double arr [ ] , int N ) { int A [ N ] ; int sum = 0 ; int m = INT_MIN ; for ( int i = 0 ; i < N ; i ++ ) { sum += ceil ( arr [ i ] ) ; A [ i ] = ceil ( arr [ i ] ) ; } if ( sum > 0 ) { m = min ( sum , N ) ; for ( int i = 0 ; i < N && m > 0 ; i ++ ) { A [ i ] = floor ( arr [ i ] ) ; if ( A [ i ] != floor ( arr [ i ] ) ) m -- ; } } for ( int i = 0 ; i < N ; i ++ ) { cout << A [ i ] << " " ; } }
int countDivisors ( int n ) { int divisors = 0 ; int i ; for ( i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) { divisors ++ ; } } if ( i - ( n / i ) == 1 ) { i -- ; } for ( ; i >= 1 ; i -- ) { if ( n % i == 0 ) { divisors ++ ; } } return divisors ; }
int possibleTriplets ( int N ) { int count = 0 ; for ( int i = 1 ; i < N ; i ++ ) { count += countDivisors ( N - i ) ; } return count ; }
long long convertToBase9 ( long long n ) { long long ans = 0 ; long long a = 1 ; while ( n > 0 ) { ans += ( a * ( n % 9 ) ) ; a *= 10 ; n /= 9 ; } return ans ; }
long long getNthnumber ( long long base9 , long long K ) { long long ans = 0 ; long long a = 1 ; while ( base9 > 0 ) { int cur = base9 % 10 ; if ( cur >= K ) { ans += a * ( cur + 1 ) ; } else { ans += a * cur ; } base9 /= 10 ; a *= 10 ; } return ans ; }
int UniqueGeometricTerms ( int N , int a1 , int r1 , int a2 , int r2 ) { set < int > S ; long long p1 = a1 ; for ( int i = 0 ; i < N ; i ++ ) { S . insert ( p1 ) ; p1 = ( long long ) ( p1 * r1 ) ; } long long p2 = a2 ; for ( int i = 0 ; i < N ; i ++ ) { S . insert ( p2 ) ; p2 = ( long long ) ( p2 * r2 ) ; } return S . size ( ) ; }
void nearestLeft ( int arr [ ] , int N , vector < int > & steps ) { int L = - N ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { L = - ( N - i ) ; break ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { L = i ; } steps [ i ] = i - L ; } }
int findSum ( int arr [ ] , int N , int M , int K ) { vector < int > steps ( N ) ; int sum = accumulate ( arr , arr + N , 0 ) ; if ( sum == 0 ) { return 0 ; } nearestLeft ( arr , N , steps ) ; nearestRight ( arr , N , steps ) ; for ( int i = 0 ; i < N ; i ++ ) sum += 2 * K * max ( 0 , M - steps [ i ] ) ; return sum ; }
int countPairs ( int L , int R ) { int cntPair = 0 ; for ( int a = L ; a <= R ; a ++ ) { for ( int b = a + 1 ; b <= R ; b ++ ) { int x = getProduct ( a ) ; int y = getProduct ( b ) ; if ( x && y && ( a * y ) == ( b * x ) ) { cntPair ++ ; } } } return cntPair ; }
int maxSum ( vector < vector < int > > & matrix ) { int r = matrix . size ( ) ; int c = matrix [ 0 ] . size ( ) ; int sum = 0 ; int mini = INT_MAX ; int count = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { int k = matrix [ i ] [ j ] ; mini = min ( mini , abs ( k ) ) ; if ( k < 0 ) count ++ ; sum += abs ( k ) ; } } if ( count % 2 == 0 ) { return sum ; } else { return ( sum - 2 * mini ) ; } }
int highestPowerof2 ( int n ) { int p = int ( log2 ( n ) ) ; if ( p % 2 == 0 ) p -= 1 ; return int ( pow ( 2 , p ) ) ; }
int minStep ( int N , int X ) { if ( N % 2 and X == 0 ) return -1 ; int size = 0 ; while ( X < N ) { N -= highestPowerof2 ( N ) ; size += 1 ; } if ( N ) size += 1 ; return size ; }
void transpose ( int A [ ] [ N ] , int B [ ] [ M ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; }
int canPossibleReplacement ( int N , int arr [ ] ) { int S = 0 ; int i ; for ( i = 0 ; i < N ; i ++ ) S += arr [ i ] ; int P = 1 ; for ( i = 0 ; i < N ; i ++ ) { P *= i ; } for ( int i = 0 ; i < N ; i ++ ) { int x = arr [ i ] ; int y = ( S - x ) / ( P / x - 1 ) ; if ( ( S - x + y ) == ( P * y ) / x ) return 1 ; } return 0 ; }
int positionAfterKJumps ( int X , int Y , int K ) { int addY = Y * ( K / 2 ) ; int reduceX = -1 * X * ( K / 2 + K % 2 ) ; return addY + reduceX ; }
void predictTheWinner ( int K , int N ) { if ( N % ( K + 1 ) == 0 ) cout << "Bob" ; else cout << "Alice" ; }
void countTriplets ( int size , int queries , int arr [ ] , int Q [ ] [ 2 ] ) { int arr_even [ size + 1 ] , arr_odd [ size + 1 ] ; int even = 0 , odd = 0 ; arr_even [ 0 ] = 0 ; arr_odd [ 0 ] = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ i ] % 2 ) { odd ++ ; } else { even ++ ; } arr_even [ i + 1 ] = even ; arr_odd [ i + 1 ] = odd ; } for ( int i = 0 ; i < queries ; i ++ ) { int l = Q [ i ] [ 0 ] , r = Q [ i ] [ 1 ] ; int odd = arr_odd [ r ] - arr_odd [ l - 1 ] ; int even = arr_even [ r ] - arr_even [ l - 1 ] ; int ans = ( even * ( even - 1 ) * ( even - 2 ) ) / 6 + ( odd * ( odd - 1 ) / 2 ) * even ; cout << ans << " " ; } }
void transpose ( int A [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) swap ( A [ i ] [ j ] , A [ j ] [ i ] ) ; }
int findMaxK ( int N ) { int K = N ; for ( int i = N - 1 ; i >= 0 ; i -- ) { K &= i ; if ( K == 0 ) { return i ; } } return 0 ; }
int countPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( arr [ j ] % arr [ i ] == 0 ) && ( j + 1 ) % ( i + 1 ) == 0 && ( arr [ j ] / arr [ i ] == ( j + 1 ) / ( i + 1 ) ) ) { count ++ ; } } } return count ; }
int smallestMaximum ( int N , int K ) { int sum = ( ( N + K - 1 ) / K ) * K ; if ( sum % N != 0 ) return ( sum / N ) + 1 ; else return sum / N ; }
int findMinMax ( vector < int > & a ) { int min_val = 1000000000 ; for ( int i = 1 ; i < a . size ( ) ; ++ i ) { min_val = min ( min_val , a [ i ] * a [ i - 1 ] ) ; } return min_val ; }
void add ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; }
int nCr ( int n , int r , int f [ ] ) { if ( n < r ) { return 0 ; } return f [ n ] / ( f [ r ] * f [ n - r ] ) ; }
int Min_sum ( int arr [ ] , int N ) { int min_sum = 1000000 , maxGcd = 1 ; for ( int i = 0 ; i < N ; i ++ ) { int gcd ; if ( i == 0 ) gcd = arr [ 1 ] ; else { gcd = arr [ i - 1 ] ; } for ( int j = 0 ; j < N ; j ++ ) { if ( j != i ) gcd = gcdOfTwoNos ( gcd , arr [ j ] ) ; } int c = arr [ i ] ; if ( gcd > maxGcd ) maxGcd = gcd ; } return maxGcd ; }
void performQuery ( vector < int > arr , vector < vector < int > > Q ) { for ( int i = 0 ; i < Q . size ( ) ; i ++ ) { int or1 = 0 ; int x = Q [ i ] [ 0 ] ; arr [ x - 1 ] = Q [ i ] [ 1 ] ; for ( int j = 0 ; j < arr . size ( ) ; j ++ ) { or1 = or1 | arr [ j ] ; } cout << or1 << " " ; } }
void subtract ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; }
int countOddIntegers ( int arr [ ] , int N ) { int Fact [ N ] = { } ; Fact [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { Fact [ i ] = i * Fact [ i - 1 ] ; } int freq [ 10 ] = { } ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } int ans = 0 ; for ( int i = 1 ; i <= 9 ; i += 2 ) { if ( ! freq [ i ] ) continue ; freq [ i ] -- ; for ( int j = 1 ; j <= 9 ; j ++ ) { int cur_ans = 0 ; if ( freq [ j ] == 0 ) { continue ; } freq [ j ] -- ; cur_ans = Fact [ N - 2 ] ; for ( int k = 0 ; k <= 9 ; k ++ ) { cur_ans = cur_ans / Fact [ freq [ k ] ] ; } ans += cur_ans ; freq [ j ] ++ ; } freq [ i ] ++ ; } return ans ; }
int intCount ( int X , int K ) { int ans = 0 ; for ( int z = 0 ; z < pow ( 10 , K ) ; z += ( pow ( 10 , K ) - 1 ) / 9 ) { if ( z > X ) break ; ans += ( ( X - z ) / pow ( 10 , K ) + 1 ) ; } return ans ; }
int intCountInRange ( int L , int R , int K ) { return ( intCount ( R , K ) - intCount ( L - 1 , K ) ) ; }
void findSum ( TreeNode * root , int target , int K ) { int sum = 0 ; kDistanceSum ( root , target , K , sum ) ; cout << sum ; }
int CountPair ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { int val = arr [ i ] + sumOfDigits ( arr [ i ] ) ; mp [ val ] ++ ; } int count = 0 ; for ( auto x : mp ) { int val = x . first ; int times = x . second ; count += ( ( times * ( times - 1 ) ) / 2 ) ; } return count ; }
bool isValid ( int x , int y1 , int y2 ) { return ( x >= 0 && x < R && y1 >= 0 && y1 < C && y2 >= 0 && y2 < C ) ; }
int getMaxUtil ( int arr [ R ] [ C ] , int mem [ R ] [ C ] [ C ] , int x , int y1 , int y2 ) { if ( ! isValid ( x , y1 , y2 ) ) return INT_MIN ; if ( x == R - 1 && y1 == 0 && y2 == C - 1 ) return ( y1 == y2 ) ? arr [ x ] [ y1 ] : arr [ x ] [ y1 ] + arr [ x ] [ y2 ] ; if ( x == R - 1 ) return INT_MIN ; if ( mem [ x ] [ y1 ] [ y2 ] != -1 ) return mem [ x ] [ y1 ] [ y2 ] ; int ans = INT_MIN ; int temp = ( y1 == y2 ) ? arr [ x ] [ y1 ] : arr [ x ] [ y1 ] + arr [ x ] [ y2 ] ; ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 , y2 - 1 ) ) ; ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 , y2 + 1 ) ) ; ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 , y2 ) ) ; ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 - 1 , y2 ) ) ; ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 - 1 , y2 - 1 ) ) ; ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 - 1 , y2 + 1 ) ) ; ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 + 1 , y2 ) ) ; ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 + 1 , y2 - 1 ) ) ; ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 + 1 , y2 + 1 ) ) ; return ( mem [ x ] [ y1 ] [ y2 ] = ans ) ; }
int geMaxCollection ( int arr [ R ] [ C ] ) { int mem [ R ] [ C ] [ C ] ; memset ( mem , -1 , sizeof ( mem ) ) ; return getMaxUtil ( arr , mem , 0 , 0 , C - 1 ) ; }
void printFactors ( int n ) { for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { int d1 = i , d2 = n ; while ( d2 % d1 == 0 ) { d2 = d2 / d1 ; } if ( d1 > 1 && d2 > 1 ) { cout << d1 << ", " << d2 ; return ; } } } cout << -1 ; }
int countTriplets ( int arr [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; else even ++ ; } int c1 = odd * ( even * ( even - 1 ) ) / 2 ; int c2 = ( odd * ( odd - 1 ) * ( odd - 2 ) ) / 6 ; return c1 + c2 ; }
int maxUniqueElements ( int A [ ] , int N ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ A [ i ] ] ++ ; } int cnt = 0 ; for ( auto x : mp ) { if ( x . second % 2 == 0 ) { cnt ++ ; } } int ans = mp . size ( ) ; if ( cnt % 2 == 1 ) { ans -- ; } return ans ; }
long long countCells ( int n , int m , int s ) { int mx1 = -1 ; int cont1 = 0 ; for ( int i = 0 ; i < s && i < n ; ++ i ) { int aux = ( n - ( i + 1 ) ) / s + 1 ; if ( aux > mx1 ) { mx1 = cont1 = aux ; } else if ( aux == mx1 ) cont1 += aux ; } int mx2 = -1 ; int cont2 = 0 ; for ( int i = 0 ; i < s && i < m ; ++ i ) { int aux = ( m - ( i + 1 ) ) / s + 1 ; if ( aux > mx2 ) mx2 = cont2 = aux ; else if ( aux == mx2 ) cont2 += aux ; } return ( long long ) ( cont1 * cont2 ) ; }
void build_tree ( int * b , vector < int > & seg_tree , int l , int r , int vertex ) { if ( l == r ) { seg_tree [ vertex ] = b [ l ] ; return ; } int mid = ( l + r ) / 2 ; build_tree ( b , seg_tree , l , mid , 2 * vertex ) ; build_tree ( b , seg_tree , mid + 1 , r , 2 * vertex + 1 ) ; seg_tree [ vertex ] = __gcd ( seg_tree [ 2 * vertex ] , seg_tree [ 2 * vertex + 1 ] ) ; }
int range_gcd ( vector < int > & seg_tree , int v , int tl , int tr , int l , int r ) { if ( l > r ) return 0 ; if ( l == tl && r == tr ) return seg_tree [ v ] ; int tm = ( tl + tr ) / 2 ; return __gcd ( range_gcd ( seg_tree , 2 * v , tl , tm , l , min ( tm , r ) ) , range_gcd ( seg_tree , 2 * v + 1 , tm + 1 , tr , max ( tm + 1 , l ) , r ) ) ; }
void maxSubarrayLen ( int arr [ ] , int n ) { vector < int > seg_tree ( 4 * ( n ) + 1 , 0 ) ; build_tree ( arr , seg_tree , 0 , n - 1 , 1 ) ; int maxLen = 0 ; int l = 0 , r = 0 ; while ( r < n && l < n ) { if ( range_gcd ( seg_tree , 1 , 0 , n - 1 , l , r ) == 1 ) { l ++ ; } maxLen = max ( maxLen , r - l + 1 ) ; r ++ ; } cout << maxLen ; }
bool can_empty ( ll a , ll b , ll c ) { if ( ( a + b + c ) % 4 != 0 ) return false ; else { int m = min ( a , min ( b , c ) ) ; if ( m < ( ( a + b + c ) / 4 ) ) return false ; } return true ; }
int countTotalPairs ( int N , int K ) { if ( K == 0 ) { return N * N ; } int ans = 0 ; for ( int b = K + 1 ; b <= N ; b ++ ) { ans += ( N / b ) * ( b - K ) ; ans += max ( N % b - K + 1 , 0 ) ; } return ans ; }
void maxFrequencySubarrayUtil ( vector < int > A , int N , int M ) { int i = 0 ; unordered_map < int , int > m ; int val = 0 ; for ( ; i < M ; i ++ ) { m [ A [ i ] ] ++ ; val = max ( val , m [ A [ i ] ] ) ; } cout << val << " " ; for ( i = M ; i < N ; i ++ ) { m [ A [ i - M ] ] -- ; m [ A [ i ] ] ++ ; val = 0 ; for ( auto x : m ) { val = max ( val , x . second ) ; } cout << val << " " ; } }
int smallest ( int k , int d ) { int cnt = 1 ; int m = d % k ; vector < int > v ( k , 0 ) ; v [ m ] = 1 ; while ( 1 ) { if ( m == 0 ) return cnt ; m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k ; if ( v [ m ] == 1 ) return -1 ; v [ m ] = 1 ; cnt ++ ; } return -1 ; }
int getPairsCount ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && abs ( arr [ i ] - arr [ j ] ) >= min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; }
int minSteps ( int N ) { int count = 1 , res = 0 ; for ( int i = 1 ; i <= N ; i += count ) { res = max ( res , count ) ; count ++ ; } return res ; }
int countReachablePoints ( int X , int Y , int L , int R ) { int diff_arr [ 100000 ] = { 0 } ; int count = 0 ; diff_arr [ X ] = 1 ; diff_arr [ X + 1 ] = -1 ; for ( int i = X ; i <= Y ; i ++ ) { diff_arr [ i ] += diff_arr [ i - 1 ] ; if ( diff_arr [ i ] >= 1 ) { diff_arr [ i + L ] += 1 ; diff_arr [ i + R + 1 ] -= 1 ; count ++ ; } } return count ; }
int minimumSubarray ( vector < int > arr , int n , int m ) { vector < int > mapu ( m + 1 , 0 ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mapu [ arr [ i ] ] ++ ; if ( mapu [ arr [ i ] ] == ( n / m ) + 1 ) c ++ ; } if ( c == 0 ) return 0 ; int ans = n ; int l = 0 , r = 0 ; while ( r < n ) { if ( -- mapu [ arr [ r ] ] == ( n / m ) ) c -- ; if ( c == 0 ) { while ( l <= r && c == 0 ) { ans = min ( ans , r - l + 1 ) ; if ( ++ mapu [ arr [ l ] ] > ( n / m ) ) c ++ ; l ++ ; } } r ++ ; } return ans ; }
void findAandB ( int N ) { int K = log2 ( N ) ; int B = ( 1 << K ) ; int A = B ^ N ; cout << A << ' ' << B ; }
int pathCountRec ( int mat [ ] [ C ] , int m , int n , int k ) { if ( m < 0 n < 0  ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m ] [ n ] ) ; return pathCountRec ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountRec ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; }
int pathCount ( int mat [ ] [ C ] , int k ) { return pathCountRec ( mat , R - 1 , C - 1 , k ) ; }
int minDistance ( int start [ ] , int end [ ] , int n , int d ) { int left = INT_MIN ; int right = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { left = max ( left , start [ i ] ) ; right = min ( right , end [ i ] ) ; } if ( left > right ) return -1 ; if ( d >= left && d <= right ) return 0 ; if ( d < left ) return ( left - d ) ; if ( d > right ) return ( d - right ) ; }
int power ( int x , unsigned int y ) { if ( y == 0 ) return 1 ; if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; }
int order ( int num ) { int count = 0 ; while ( num ) { count ++ ; num = num / 10 ; } return count ; }
int isArmstrong ( int N ) { int r = order ( N ) ; int temp = N , sum = 0 ; while ( temp ) { int d = temp % 10 ; sum += power ( d , r ) ; temp = temp / 10 ; } return ( sum == N ) ; }
int maxSum ( int arr [ ] , int N , int K ) { if ( N < K ) { return -1 ; } int res = 0 ; for ( int i = 0 ; i < K ; i ++ ) { res += arr [ i ] ; } int curr_sum = res ; for ( int i = K ; i < N ; i ++ ) { curr_sum += arr [ i ] - arr [ i - K ] ; res = max ( res , curr_sum ) ; } return res ; }
int maxArmstrong ( int arr [ ] , int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = isArmstrong ( arr [ i ] ) ; } return maxSum ( arr , N , K ) ; }
int power ( long long x , unsigned int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
void printArr ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int minDifference = INT_MAX ; int minIndex = -1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( minDifference > abs ( arr [ i ] - arr [ i - 1 ] ) ) { minDifference = abs ( arr [ i ] - arr [ i - 1 ] ) ; minIndex = i - 1 ; } } int Arr [ n ] ; Arr [ 0 ] = arr [ minIndex ] ; Arr [ n - 1 ] = arr [ minIndex + 1 ] ; int pos = 1 ; for ( int i = minIndex + 2 ; i < n ; i ++ ) { Arr [ pos ++ ] = arr [ i ] ; } for ( int i = 0 ; i < minIndex ; i ++ ) { Arr [ pos ++ ] = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { cout << Arr [ i ] << " " ; } }
void findValuesOfK ( int g ) { int count = 0 ; for ( int i = 1 ; i * i <= g ; i ++ ) { if ( g % i == 0 ) { if ( i != g / i ) { if ( i & 1 ) { count ++ ; } if ( ( g / i ) & 1 ) { count ++ ; } } else if ( i & 1 ) { count ++ ; } } } cout << count ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { res = res * i ; } return res ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
void countPairs ( int arr [ ] , int N ) { int answer = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] + arr [ j ] == i + j ) { answer ++ ; } } } cout << answer ; }
int pathCountDPRecDP ( int mat [ ] [ C ] , int m , int n , int k ) { if ( m < 0 n < 0  ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m ] [ n ] ) ; if ( dp [ m ] [ n ] [ k ] != -1 ) return dp [ m ] [ n ] [ k ] ; dp [ m ] [ n ] [ k ] = pathCountDPRecDP ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountDPRecDP ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; return dp [ m ] [ n ] [ k ] ; }
void checkDistribution ( int R , int B , int D ) { if ( max ( R , B ) <= min ( R , B ) * ( D + 1 ) ) { cout << "Yes" ; } else { cout << "No" ; } }
int itemType ( int n ) { int count = 0 ; for ( int day = 1 ; ; day ++ ) { for ( int type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) return type ; } } }
vector < pair < int , int > > primeFactor ( int N ) { vector < pair < int , int > > v ; int count = 0 ; while ( ! ( N % 2 ) ) { N >>= 1 ; count ++ ; } if ( count ) v . push_back ( { 2 , count } ) ; for ( int i = 3 ; i <= sqrt ( N ) ; i += 2 ) { count = 0 ; while ( N % i == 0 ) { count ++ ; N = N / i ; } if ( count ) { v . push_back ( { i , count } ) ; } } if ( N > 2 ) v . push_back ( { N , 1 } ) ; return v ; }
long long ABS ( long long x ) { return max ( x , - x ) ; }
bool isvalid ( int i , int j ) { if ( i < 0 j < 0 i > = R j > = C ) return false ; return true ; }
int getLenUtil ( char mat [ R ] [ C ] , int i , int j , char prev ) { if ( ! isvalid ( i , j ) || ! isadjacent ( prev , mat [ i ] [ j ] ) ) return 0 ; if ( dp [ i ] [ j ] != -1 ) return dp [ i ] [ j ] ; int ans = 0 ; for ( int k = 0 ; k < 8 ; k ++ ) ans = max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , mat [ i ] [ j ] ) ) ; return dp [ i ] [ j ] = ans ; }
string BaseConversion ( int N ) { string s = "" ; while ( N != 0 ) { if ( N % 2 == 0 ) { s = "0" + s ; } else { s = "1" + s ; N -- ; } N /= -2 ; } if ( s == "" ) { s = "0" ; } return s ; }
void check ( int N ) { int twos = 0 , fives = 0 ; while ( N % 2 == 0 ) { N /= 2 ; twos ++ ; } while ( N % 5 == 0 ) { N /= 5 ; fives ++ ; } if ( N == 1 && twos <= fives ) { cout << 2 * fives - twos ; } else { cout << -1 ; } }
string isMakeZero ( int arr [ ] , int N , int K ) { map < int , int > MP ; vector < int > V ; int X = 1 ; int i ; while ( X > 0 && X < INT_MAX ) { V . push_back ( X ) ; X *= K ; } for ( i = 0 ; i < N ; i ++ ) { for ( int j = V . size ( ) - 1 ; j >= 0 ; j -- ) { if ( MP [ V [ j ] ] == 0 && V [ j ] <= arr [ i ] ) { arr [ i ] -= V [ j ] ; MP [ V [ j ] ] = 1 ; } } if ( arr [ i ] != 0 ) break ; } if ( i < N ) return "No" ; else return "Yes" ; }
int countOperations ( int N , int M ) { bool visited [ 100001 ] ; fill ( visited , visited + 100001 , false ) ; queue < pair < int , int > > Q ; Q . push ( make_pair ( N , 0 ) ) ; visited [ N ] = true ; while ( ! Q . empty ( ) ) { int aux = Q . front ( ) . first ; int cont = Q . front ( ) . second ; Q . pop ( ) ; if ( aux == M ) return cont ; for ( int i = 2 ; i * i <= aux ; i ++ ) if ( aux % i == 0 ) { if ( aux + i <= M && ! visited [ aux + i ] ) { Q . push ( make_pair ( aux + i , cont + 1 ) ) ; visited [ aux + i ] = true ; } if ( aux + aux / i <= M && ! visited [ aux + aux / i ] ) { Q . push ( make_pair ( aux + aux / i , cont + 1 ) ) ; visited [ aux + aux / i ] = true ; } } } return -1 ; }
double Avgdifference ( double arr [ ] , int N , int K ) { double min = 1000000 , max = -1 ; for ( int i = 0 ; i <= N - K ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < K ; j ++ ) { sum += arr [ i + j ] ; } if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
double Avgdifference ( double arr [ ] , int N , int K ) { double sum = 0 ; for ( int i = 0 ; i < K ; i ++ ) sum += arr [ i ] ; double min = sum ; double max = sum ; for ( int i = K ; i <= N - K + 1 ; i ++ ) { sum += arr [ i ] - arr [ i - K ] ; if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; }
int minimumElement ( int arr [ ] , int N , int K ) { int minElement = arr [ 0 ] ; for ( int i = 0 ; i < N ; ++ i ) { minElement = min ( minElement , arr [ i ] ) ; } int reqOperations = 0 ; for ( int i = 0 ; i < N ; ++ i ) { reqOperations += arr [ i ] - minElement ; } if ( reqOperations < K ) { K -= reqOperations ; minElement -= ( K + N - 1 ) / N ; } return minElement ; }
vector < string > FractionSplit ( long long n , long long d ) { vector < string > UnitFactions ; while ( n > 0 ) { long long x = ( d + n - 1 ) / n ; string s = "1/" + to_string ( x ) ; UnitFactions . push_back ( s ) ; n = n * x - d ; d = d * x ; } return UnitFactions ; }
void findPermutation ( int N ) { int arr [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = i + 1 ; } for ( int i = 1 ; i < N ; i += 2 ) { swap ( arr [ i ] , arr [ i - 1 ] ) ; } if ( N % 2 == 1 && N > 1 ) { swap ( arr [ N - 1 ] , arr [ N - 2 ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << " " ; } }
void rangeSum ( int arr [ ] , int N , int L , int R ) { int sum = 0 ; for ( int i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; } cout << sum ; }
void rangeSum ( int arr [ ] , int N , int L , int R ) { int prefix [ N + 1 ] ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } int leftsum = ( ( L - 1 ) / N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] ; int rightsum = ( R / N ) * prefix [ N ] + prefix [ R % N ] ; cout << rightsum - leftsum ; }
void addAP ( int A [ ] , int Q , int operations [ 2 ] [ 4 ] ) { for ( int j = 0 ; j < 2 ; ++ j ) { int L = operations [ j ] [ 0 ] , R = operations [ j ] [ 1 ] , a = operations [ j ] [ 2 ] , d = operations [ j ] [ 3 ] ; int curr = a ; for ( int i = L - 1 ; i < R ; i ++ ) { A [ i ] += curr ; curr += d ; } } for ( int i = 0 ; i < 4 ; ++ i ) cout << A [ i ] << " " ; }
void maximizeNumber ( int N , int K ) { string s = to_string ( N ) ; int L = s . length ( ) ; string result ; int i = 0 ; while ( ( i < L ) && ( K <= ( s [ i ] - '0' ) ) ) { result . push_back ( s [ i ] ) ; ++ i ; } result . push_back ( char ( K + '0' ) ) ; while ( i < L ) { result . push_back ( s [ i ] ) ; ++ i ; } cout << result ; }
void countArrays ( int N , int K ) { cout << int ( power ( N , K ) ) ; }
void minimumDistance ( vector < int > arr , int N ) { int ind = 0 ; int prev = arr [ ind ] ; int s = arr . size ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int distance = INT_MAX ; if ( i < arr [ 0 ] ) { distance = arr [ 0 ] - i ; } else if ( i >= prev && ind + 1 < s && i <= arr [ ind + 1 ] ) { distance = min ( i - prev , arr [ ind + 1 ] - i ) ; if ( i == arr [ ind + 1 ] ) { distance = 0 ; prev = arr [ ind + 1 ] ; ind ++ ; } } else { distance = i - prev ; } cout << distance << " " ; } }
int countOfPairs ( int arr [ ] , int N , int X ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( ( ( arr [ i ] ^ arr [ j ] ) & X ) == 0 ) count ++ ; } } return count ; }
int countOfPairs ( int arr [ ] , int N , int X ) { int count = 0 ; unordered_map < int , int > M ; for ( int i = 0 ; i < N ; i ++ ) { M [ ( arr [ i ] & X ) ] ++ ; } for ( auto m : M ) { int p = m . second ; count += p * ( p - 1 ) / 2 ; } return count ; }
int ConcatenateArr ( int arr [ ] , int N ) { int ans = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { int l = floor ( log10 ( arr [ i ] ) + 1 ) ; ans = ans * pow ( 10 , l ) ; ans += arr [ i ] ; } return ans ; }
int countXor ( int N ) { int cnt = N / 2 + 1 ; return cnt ; }
int DistRecursion ( string S , int i , int dist ) { if ( i == S . length ( ) ) return abs ( dist ) ; if ( S [ i ] == 'L' ) return DistRecursion ( S , i + 1 , dist - 1 ) ; if ( S [ i ] == 'R' ) return DistRecursion ( S , i + 1 , dist + 1 ) ; return max ( DistRecursion ( S , i + 1 , dist - 1 ) , DistRecursion ( S , i + 1 , dist + 1 ) ) ; }
int maxDistance ( string S ) { return DistRecursion ( S , 0 , 0 ) ; }
bool isPerfect ( long long int N ) { long long int sum = 1 ; for ( long long int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { if ( i * i != N ) sum = sum + i + N / i ; else sum = sum + i ; } } if ( sum == N && N != 1 ) return true ; return false ; }
void Query ( int arr [ ] [ 2 ] , int N ) { int prefix [ MAX + 1 ] = { 0 } ; for ( int i = 2 ; i <= MAX ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + isPerfect ( i ) ; } for ( int i = 0 ; i < N ; i ++ ) { cout << prefix [ arr [ i ] [ 1 ] ] - prefix [ arr [ i ] [ 0 ] - 1 ] << " " ; } }
int ExpoFactorial ( int N ) { int res = 1 ; int mod = 1000000007 ; for ( int i = 2 ; i < N + 1 ; i ++ ) res = ( int ) pow ( i , res ) % mod ; return res ; }
int maxSubArraySumRepeated ( int arr [ ] , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int curr = arr [ 0 ] ; int ans = arr [ 0 ] ; if ( K == 1 ) { for ( int i = 1 ; i < N ; i ++ ) { curr = max ( arr [ i ] , curr + arr [ i ] ) ; ans = max ( ans , curr ) ; } return ans ; } vector < int > V ; for ( int i = 0 ; i < 2 * N ; i ++ ) { V . push_back ( arr [ i % N ] ) ; } int maxSuf = V [ 0 ] ; int maxPref = V [ 2 * N - 1 ] ; curr = V [ 0 ] ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr += V [ i ] ; maxPref = max ( maxPref , curr ) ; } curr = V [ 2 * N - 1 ] ; for ( int i = 2 * N - 2 ; i >= 0 ; i -- ) { curr += V [ i ] ; maxSuf = max ( maxSuf , curr ) ; } curr = V [ 0 ] ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr = max ( V [ i ] , curr + V [ i ] ) ; ans = max ( ans , curr ) ; } if ( sum > 0 ) { int temp = 1LL * sum * ( K - 2 ) ; ans = max ( ans , max ( temp + maxPref , temp + maxSuf ) ) ; } return ans ; }
int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
long long numOfNecklace ( int N ) { long long ans = factorial ( N ) / ( factorial ( N / 2 ) * factorial ( N / 2 ) ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans /= 2 ; return ans ; }
int nthNumber ( int n ) { int divs [ 1000000 ] ; bool vis [ 1000000 ] ; int cnt = 0 ; for ( int i = 2 ; cnt < n ; i ++ ) { if ( divs [ i ] == 0 ) { for ( int j = 2 * i ; j < 1000000 ; j += i ) { if ( vis [ j ] ) { continue ; } vis [ j ] = 1 ; int currNum = j ; int count = 0 ; while ( currNum % i == 0 ) { divs [ j ] ++ ; currNum = currNum / i ; count ++ ; } if ( currNum == 1 && count == 3 && divs [ j ] == 3 ) { cnt ++ ; } else if ( currNum != 1 && divs [ currNum ] == 0 && count == 1 && divs [ j ] == 1 ) { cnt ++ ; } if ( cnt == n ) { return j ; } } } } return -1 ; }
int findkey ( int A , int B , int C ) { int ans = 0 ; int cur = 1 ; while ( A > 0 ) { int a = A % 10 ; int b = B % 10 ; int c = C % 10 ; A = A / 10 ; B = B / 10 ; C = C / 10 ; int m = max ( a , max ( c , b ) ) ; ans += cur * m ; cur = cur * 10 ; } return ans ; }
int SumOfPrimeDivisors ( int n ) { int sum = 0 ; if ( n % 2 == 0 ) { sum = sum + 2 ; } while ( n % 2 == 0 ) { n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { sum = sum + i ; } while ( n % i == 0 ) { n = n / i ; } } if ( n > 2 ) { sum = sum + n ; } return sum ; }
int countNumbers ( int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( ( i & 1 ) == 0 ) { count ++ ; } } return count ; }
int countNumbers ( int l , int r ) { return ( ( r / 2 ) - ( l - 1 ) / 2 ) ; }
bool isPerfectSquare ( int x ) { int s = sqrt ( x ) ; return ( s * s == x ) ; }
bool isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
int contiguousFibonacciNumber ( int arr [ ] , int n ) { int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isFibonacci ( arr [ i ] ) ) { current_length ++ ; } else { current_length = 0 ; } max_length = max ( max_length , current_length ) ; } return max_length ; }
int Kadane ( int arr [ ] , int n ) { int largestSum = 0 , currMax = 0 ; int currSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currSum += arr [ i ] ; currMax = max ( currMax , arr [ i ] ) ; largestSum = max ( largestSum , currMax * currSum ) ; if ( currSum < 0 ) { currMax = 0 ; currSum = 0 ; } } return largestSum ; }
int maximumWeight ( int arr [ ] , int n ) { int largestSum = Kadane ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = - arr [ i ] ; } largestSum = max ( largestSum , Kadane ( arr , n ) ) ; return largestSum ; }
void evenOdd ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int even_digits = 0 ; int odd_digits = 0 ; int temp = arr [ i ] ; while ( temp ) { if ( ( temp % 10 ) & 1 ) odd_digits ++ ; else even_digits ++ ; temp /= 10 ; } if ( even_digits > odd_digits ) { int res = 0 ; while ( arr [ i ] ) { res += arr [ i ] % 10 ; arr [ i ] /= 10 ; } cout << res << " " ; } else if ( odd_digits > even_digits ) { int res = 1 ; while ( arr [ i ] ) { res *= arr [ i ] % 10 ; arr [ i ] /= 10 ; } cout << res << " " ; } else cout << arr [ i ] << " " ; } }
int sumOfFirstM ( int A [ ] , int N , int M ) { int sum = 0 ; for ( int i = 0 ; i < M ; i ++ ) { sum = sum + A [ i % N ] ; } return sum ; }
int findSmallestNumK ( int n ) { int cummAnd = n ; int i = n - 1 ; while ( cummAnd != 0 ) { cummAnd = cummAnd & i ; if ( cummAnd == 0 ) { return i ; } i -- ; } return -1 ; }
int findMinInsertions ( char str [ ] , int l , int h ) { if ( l > h ) return INT_MAX ; if ( l == h ) return 0 ; if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 ; return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str , l + 1 , h - 1 ) : ( min ( findMinInsertions ( str , l , h - 1 ) , findMinInsertions ( str , l + 1 , h ) ) + 1 ) ; }
void canReach0toM ( int a [ ] [ 2 ] , int n , int m ) { int rightMost [ m + 1 ] ; int dp [ m + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { rightMost [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { int a1 = a [ i ] [ 0 ] ; int b1 = a [ i ] [ 1 ] ; rightMost [ a1 ] = max ( rightMost [ a1 ] , b1 ) ; } for ( int i = m ; i >= 0 ; i -- ) { dp [ i ] = i ; for ( int j = min ( m , rightMost [ i ] ) ; j > i ; j -- ) { dp [ i ] = max ( dp [ i ] , dp [ j ] ) ; } } if ( dp [ 0 ] >= m ) { cout << "Yes" ; } else { cout << "No" ; } }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void countPairs ( int * arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int x = 1 ; x <= arr [ i ] ; x ++ ) { for ( int y = x ; y <= arr [ i ] ; y ++ ) { if ( gcd ( x , y ) > 1 ) count ++ ; } } cout << count << " " ; } }
int maximumTurns ( int arr [ ] , int N ) { int Count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { while ( arr [ i ] % 2 == 0 ) { Count ++ ; arr [ i ] = arr [ i ] / 2 ; } } return Count ; }
void findSet ( int N , int K ) { vector < int > a ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i != K ) a . push_back ( i ) ; } int MaxDistinct = ( N - K ) + ( K / 2 ) ; reverse ( a . begin ( ) , a . end ( ) ) ; for ( int i = 0 ; i < MaxDistinct ; i ++ ) cout << a [ i ] << " " ; }
void linearCongruence ( long long A , long long B , long long N ) { A = A % N ; B = B % N ; long long u = 0 , v = 0 ; long long d = ExtendedEuclidAlgo ( A , N , u , v ) ; if ( B % d != 0 ) { cout << -1 << endl ; return ; } long long x0 = ( u * ( B / d ) ) % N ; if ( x0 < 0 ) x0 += N ; for ( long long i = 0 ; i <= d - 1 ; i ++ ) cout << ( x0 + i * ( N / d ) ) % N << " " ; }
int distinctGCDs ( int arr [ ] , int N ) { int M = -1 , ans = 0 ; map < int , int > Mp ; for ( int i = 0 ; i < N ; i ++ ) { M = max ( M , arr [ i ] ) ; Mp [ arr [ i ] ] = 1 ; } for ( int i = 1 ; i <= M ; i ++ ) { int currGcd = 0 ; for ( int j = i ; j <= M ; j += i ) { if ( Mp [ j ] ) { currGcd = __gcd ( currGcd , j ) ; if ( currGcd == i ) { ans ++ ; break ; } } } } return ans ; }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
void countSubarray ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int mxSubarray = 0 ; int mxOther = 0 ; for ( int k = i ; k <= j ; k ++ ) { mxSubarray = max ( mxSubarray , arr [ k ] ) ; } for ( int k = 0 ; k < i ; k ++ ) { mxOther = max ( mxOther , arr [ k ] ) ; } for ( int k = j + 1 ; k < n ; k ++ ) { mxOther = max ( mxOther , arr [ k ] ) ; } if ( mxSubarray > ( 2 * mxOther ) ) count ++ ; } } cout << count ; }
void countSubarray ( int arr [ ] , int n ) { int count = 0 , L = 0 , R = 0 ; int mx = * max_element ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] * 2 > mx ) { L = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] * 2 > mx ) { R = i ; break ; } } cout << ( L + 1 ) * ( n - R ) ; }
int factorialWithoutMul ( int N ) { int ans = N ; for ( int i = N - 1 ; i > 0 ; i -- ) { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ans ; ans = sum ; } return ans ; }
bool isPrime ( int X ) { for ( int i = 2 ; i * i <= X ; i ++ ) return false ; return true ; }
int countSetBits ( int n ) { int count = 0 ; while ( n ) { n = n & ( n - 1 ) ; count ++ ; } return count ; }
int minOperations ( int A , int B ) { int cnt1 = 0 , cnt2 = 0 ; cnt1 += countSetBits ( A ) ; cnt2 += countSetBits ( B ) ; if ( ( cnt1 + cnt2 ) % 2 != 0 ) return -1 ; int oneZero = 0 , zeroOne = 0 ; int ans = 0 ; for ( int i = 0 ; i < max ( cnt1 , cnt2 ) ; i ++ ) { int bitpos = 1 << i ; if ( ( ! ( bitpos & A ) ) && ( bitpos & B ) ) zeroOne ++ ; if ( ( bitpos & A ) && ( ! ( bitpos & B ) ) ) oneZero ++ ; } ans = ( zeroOne / 2 ) + ( oneZero / 2 ) ; if ( zeroOne % 2 != 0 ) ans += 2 ; return ans ; }
void sieveSundaram ( ) { bool marked [ MAX / 2 + 100 ] = { 0 } ; for ( int i = 1 ; i <= ( sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ; primes . push_back ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . push_back ( 2 * i + 1 ) ; }
bool isSmithBrotherPair ( int X , int Y ) { return isSmith ( X ) && isSmith ( Y ) && abs ( X - Y ) == 1 ; }
int countSmithBrotherPairs ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) { if ( isSmithBrotherPair ( A [ i ] , A [ j ] ) ) count ++ ; } return count ; }
void tripletAndSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { ans += arr [ i ] & arr [ j ] & arr [ k ] ; } } } cout << ans ; }
void countPairs ( int arr [ ] , int N ) { int count = 0 , totalSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalSum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( totalSum % ( arr [ i ] + arr [ j ] ) == 0 ) { count += 1 ; } } } cout << count ; }
int countOfBase ( int N ) { int count = 0 ; for ( int i = 2 ; i <= N ; ++ i ) { int highestPower = ( int ) ( log ( N ) / log ( i ) ) ; int firstDigit = N / ( int ) pow ( i , highestPower ) ; if ( firstDigit == 1 ) { ++ count ; } } return count ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
bool PermuteAndFind ( vector < long > power , int idx , long SumSoFar , int target ) { if ( idx == power . size ( ) ) { if ( SumSoFar == target ) return true ; return false ; } bool select = PermuteAndFind ( power , idx + 1 , SumSoFar , target ) ; bool notselect = PermuteAndFind ( power , idx + 1 , SumSoFar + power [ idx ] , target ) ; return ( select notselect ) ; }
void DistinctPowersOf3 ( int N ) { vector < long > power ( 16 ) ; power [ 0 ] = 1 ; for ( int i = 1 ; i < 16 ; i ++ ) power [ i ] = 3 * power [ i - 1 ] ; bool found = PermuteAndFind ( power , 0 , 0L , N ) ; if ( found == true ) { cout << "Yes" ; } else { cout << "No" ; } }
unordered_map < int , int > PrimeFactor ( int N ) { unordered_map < int , int > primef ; while ( N % 2 == 0 ) { if ( primef . count ( 2 ) ) { primef [ 2 ] += 1 ; } else { primef [ 2 ] = 1 ; } N /= 2 ; } for ( int i = 3 ; i <= sqrt ( N ) ; i ++ ) { while ( N % i == 0 ) { if ( primef . count ( i ) ) { primef [ i ] += 1 ; } else { primef [ i ] = 1 ; } N /= 2 ; } } if ( N > 2 ) { primef [ N ] = 1 ; } return primef ; }
int CountToMakeEqual ( int X , int Y ) { int gcdofXY = __gcd ( X , Y ) ; int newX = Y / gcdofXY ; int newY = X / gcdofXY ; unordered_map < int , int > primeX ; unordered_map < int , int > primeY ; primeX = PrimeFactor ( newX ) ; primeY = PrimeFactor ( newY ) ; int ans = 0 ; for ( auto c : primeX ) { if ( X % c . first != 0 ) { return -1 ; } ans += primeX [ c . first ] ; } for ( auto c : primeY ) { if ( Y % c . first != 0 ) { return -1 ; } ans += primeY [ c . first ] ; } return ans ; }
void maximumSubsequenceSum ( int A [ ] , int N ) { int ans = 0 ; map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ A [ i ] - i ] += A [ i ] ; ans = max ( ans , mp [ A [ i ] - i ] ) ; } cout << ans << endl ; }
void getPermutation ( int N ) { if ( N <= 3 ) { cout << -1 ; return ; } int i = N ; if ( N % 2 == 0 ) i -- ; while ( i >= 1 ) { cout << i << " " ; i -= 2 ; } cout << 4 << " " << 2 << " " ; i = 6 ; while ( i <= N ) { cout << i << " " ; i += 2 ; } }
int gcd ( int A , int B ) { if ( B == 0 ) return A ; else return gcd ( B , A % B ) ; }
int getDistinctValues ( int A , int B , int C ) { int g = gcd ( A , B ) ; int num_values = C / g ; return num_values ; }
void nearestPerfectSquare ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int sr = sqrt ( arr [ i ] ) ; int a = sr * sr ; int b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) cout << a << " " ; else cout << b << " " ; } }
int currSubArrayScore ( int * a , int * b , int l , int r ) { int straightScore = 0 ; int reverseScore = 0 ; for ( int i = l ; i <= r ; i ++ ) { straightScore += a [ i ] * b [ i ] ; reverseScore += a [ r - ( i - l ) ] * b [ i ] ; } return max ( straightScore , reverseScore ) ; }
void maxScoreSubArray ( int * a , int * b , int n ) { int res = 0 , start = 0 , end = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int currScore = currSubArrayScore ( a , b , i , j ) ; if ( currScore > res ) { res = currScore ; start = i ; end = j ; } } } cout << res ; }
void maxScoreSubArray ( int * a , int * b , int n ) { int res = 0 ; for ( int mid = 0 ; mid < n ; mid ++ ) { int straightScore = a [ mid ] * b [ mid ] , reverseScore = a [ mid ] * a [ mid ] ; int prev = mid - 1 , next = mid + 1 ; res = max ( res , max ( straightScore , reverseScore ) ) ; while ( prev >= 0 && next < n ) { straightScore += ( a [ prev ] * b [ prev ] + a [ next ] * b [ next ] ) ; reverseScore += ( a [ prev ] * b [ next ] + a [ next ] * b [ prev ] ) ; res = max ( res , max ( straightScore , reverseScore ) ) ; prev -- ; next ++ ; } straightScore = 0 ; reverseScore = 0 ; prev = mid - 1 , next = mid ; while ( prev >= 0 && next < n ) { straightScore += ( a [ prev ] * b [ prev ] + a [ next ] * b [ next ] ) ; reverseScore += ( a [ prev ] * b [ next ] + a [ next ] * b [ prev ] ) ; res = max ( res , max ( straightScore , reverseScore ) ) ; prev -- ; next ++ ; } } cout << res ; }
int minimumSizeSubarray ( int arr [ ] , int N ) { int i = 0 , j = N - 1 ; while ( i < N and arr [ i ] == 0 ) { i ++ ; } if ( i == N ) return 1 ; while ( j >= 0 and arr [ j ] == 0 ) { j -- ; } return ( j - i + 1 ) ; }
void countXorPartition ( int N ) { double a = pow ( 2 , floor ( N - log ( N + 1 ) / log ( 2 ) ) ) ; cout << a ; }
void countValues ( int A , int B , int C ) { if ( B >= A ) { cout << 0 ; return ; } if ( B == 0 ) { cout << C / A ; return ; } int ans = C / A ; if ( ans * A + B <= C ) { ans ++ ; } cout << ans ; }
void SieveOfEratosthenes ( int n ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } }
int floorDifference ( int A [ ] , int N , int X ) { int totalSum = 0 ; int perElementSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalSum += A [ i ] ; perElementSum += A [ i ] / X ; } int totalFloorSum = totalSum / X ; return abs ( totalFloorSum - perElementSum ) ; }
int maximumSum ( int arr [ ] , int N ) { int ans = 0 ; for ( int bit = 0 ; bit < 32 ; bit ++ ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & ( 1 << bit ) ) { sum += arr [ i ] ; } } ans = max ( ans , sum ) ; } return ans ; }
void maxCount ( int arr [ ] , int N , int K ) { set < int > st ; for ( int i = 0 ; i < N ; i ++ ) { st . insert ( arr [ i ] ) ; } if ( N - st . size ( ) <= K ) { cout << "Yes" ; } else cout << "No" ; }
void kthDigitFromLast ( int n , int k ) { if ( k <= 0 ) { cout << -1 << endl ; return ; } while ( ( k - 1 ) > 0 && n > 0 ) { n = n / 10 ; k -- ; } if ( n == 0 ) { cout << -1 << endl ; } else { cout << n % 10 << endl ; } }
void findWinner ( int X , int Y ) { int playerA = ( X ^ Y ) ; bool flag = false ; for ( int i = 1 ; i <= X ; i ++ ) { for ( int j = 1 ; j <= Y ; j ++ ) { int val = ( i ^ j ) ; if ( val > playerA ) { flag = true ; break ; } } if ( flag ) { break ; } } if ( flag ) { cout << "Yes" ; } else { cout << "No" ; } }
void findWinner ( int X , int Y ) { int first = ( X ^ Y ) ; int second = ( X + Y ) ; if ( first == second ) { cout << "No" ; } else { cout << "Yes" ; } }
int countWays ( int arr [ ] , int N ) { int arr_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) arr_xor ^= arr [ i ] ; int pref_xor = 0 , suff_xor = 0 ; vector < int > pref_ind ; int suff_inds [ N + 1 ] ; memset ( suff_inds , 0 , sizeof suff_inds ) ; for ( int i = 0 ; i < N ; i ++ ) { pref_xor ^= arr [ i ] ; if ( pref_xor == arr_xor ) pref_ind . push_back ( i ) ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { suff_xor ^= arr [ i ] ; suff_inds [ i ] += suff_inds [ i + 1 ] ; if ( suff_xor == arr_xor ) suff_inds [ i ] ++ ; } int tot_ways = 0 ; for ( int idx : pref_ind ) { if ( idx < N - 1 ) tot_ways += suff_inds [ idx + 2 ] ; } return tot_ways ; }
int KthSmallest ( int A [ ] , int B [ ] , int N , int K ) { int M = 0 ; for ( int i = 0 ; i < N ; i ++ ) { M = max ( A [ i ] , M ) ; } int freq [ M + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { freq [ A [ i ] ] += B [ i ] ; } int sum = 0 ; for ( int i = 0 ; i <= M ; i ++ ) { sum += freq [ i ] ; if ( sum >= K ) { return i ; } } return -1 ; }
int xorSumOfArray ( int arr [ ] , int n , int k , int count [ ] ) { int sum = 0 ; int p = 1 ; for ( int i = 0 ; i < 31 ; i ++ ) { int val = 0 ; if ( ( k & ( 1 << i ) ) != 0 ) { int not_set = n - count [ i ] ; val = ( ( not_set ) * p ) ; } else { val = ( count [ i ] * p ) ; } sum += val ; p = ( p * 2 ) ; } return sum ; }
void sumOfXors ( int arr [ ] , int n , int queries [ ] , int q ) { int count [ 32 ] ; memset ( count , 0 , sizeof ( count ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 31 ; j ++ ) { if ( arr [ i ] & ( 1 << j ) ) count [ j ] ++ ; } } for ( int i = 0 ; i < q ; i ++ ) { int k = queries [ i ] ; cout << xorSumOfArray ( arr , n , k , count ) << " " ; } }
int IsSumEqualsXor ( int i , int n , bool bound , string & s ) { if ( i == n ) return 1 ; if ( dp [ i ] [ bound ] != -1 ) return dp [ i ] [ bound ] ; int ans = 0 ; if ( bound and s [ i ] == '0' ) { ans = IsSumEqualsXor ( i + 1 , n , 1 , s ) ; } else { ans = 2 * IsSumEqualsXor ( i + 1 , n , bound & ( s [ i ] == '1' ) , s ) ; ans += IsSumEqualsXor ( i + 1 , n , 0 , s ) ; } return dp [ i ] [ bound ] = ans ; }
int findNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }
int findSmallest ( int M , int N ) { int x = findNum ( M , N ) ; return x - M ; }
int toDeci ( string str , int base ) { int len = str . size ( ) ; int power = 1 ; int num = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str [ i ] ) >= base ) { printf ( "Invalid Number" ) ; return -1 ; } num += val ( str [ i ] ) * power ; power = power * base ; } return num ; }
int fact ( int N ) { if ( N == 1 N == 0 ) return 1 ; return N * fact ( N - 1 ) ; }
void prefixFactorialArray ( int arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { arr [ i ] += arr [ i - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = fact ( arr [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << " " ; } }
void prefixFactorialArray ( int A [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) { A [ i ] += A [ i - 1 ] ; } int fact [ A [ N - 1 ] + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= A [ N - 1 ] ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = fact [ A [ i ] ] ; } for ( int i = 0 ; i < N ; i ++ ) { cout << A [ i ] << " " ; } }
void countPairs ( int arr [ ] , int n , int x ) { int count = 0 ; map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] - x * i ] ++ ; } for ( auto x : mp ) { int n = x . second ; count += ( n * ( n - 1 ) ) / 2 ; } cout << count ; }
double findAverage ( int N ) { double S = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { S += i * i * i * i ; } return S / N ; }
double findAverage ( int N ) { double avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N * N ) + ( 10 * N * N ) - 1 ) / 30.0 ; return avg ; }
bool ToCheckPowerofX ( int n , int x ) { while ( n > 0 ) { int rem = n % x ; if ( rem >= 2 ) { return false ; } n = n / x ; } return true ; }
int maximumOfTwo ( int N ) { int M = reverseBin ( N ) ; return max ( N , M ) ; }
void findbitwiseOR ( int * a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sub_array = a [ i ] ; res = res | curr_sub_array ; for ( int j = i ; j < n ; j ++ ) { curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } } cout << res ; }
void findbitwiseOR ( int * a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res | a [ i ] ; cout << res ; }
int findDecimal ( float arr [ ] , int N ) { int bit , power = 0 , result = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { bit = abs ( floor ( arr [ i ] ) - round ( arr [ i ] ) ) ; if ( bit ) result += pow ( 2 , power ) ; power ++ ; } cout << result ; }
int totalMoney ( int N ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { ans += i / 7 ; ans += ( i % 7 + 1 ) ; } return ans ; }
int minTime ( int A [ ] , int n , int K ) { int max_ability = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { max_ability = max ( max_ability , A [ i ] ) ; } int tmp [ max_ability + 1 ] = { 0 } ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { tmp [ A [ i ] ] ++ ; } for ( int i = max_ability ; i >= 0 ; i -- ) { if ( tmp [ i ] != 0 ) { if ( tmp [ i ] * i < K ) { K -= ( i * tmp [ i ] ) ; tmp [ i / 2 ] += tmp [ i ] ; count += tmp [ i ] ; if ( K <= 0 ) { return count ; } } else { if ( K % i != 0 ) { count += ( K / i ) + 1 ; } else { count += ( K / i ) ; } return count ; } } } return -1 ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
void minimumRod ( int A [ ] , int N ) { cout << N * findlcm ( A , N ) ; }
void check ( int n ) { int sumOfDigit = 0 ; int prodOfDigit = 1 ; while ( n > 0 ) { int rem ; rem = n % 10 ; sumOfDigit += rem ; prodOfDigit *= rem ; n /= 10 ; } if ( sumOfDigit > prodOfDigit ) cout << "Yes" ; else cout << "No" ; }
bool check ( int N , int D ) { while ( N > 0 ) { if ( findDigit ( N , D ) == true ) { return true ; } N -= D ; } return false ; }
int FindSum ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int power = log2 ( arr [ i ] ) ; int LesserValue = pow ( 2 , power ) ; int LargerValue = pow ( 2 , power + 1 ) ; if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) { res += arr [ i ] ; } } return res ; }
int power ( long long x , unsigned int y ) { int res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
void countRelations ( int N ) { cout << ( power ( 2 , N ) - 2 ) * power ( 2 , N * N - N ) ; }
int minOperations ( int N ) { int arr [ N ] ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = ( 2 * i ) + 1 ; sum = sum + arr [ i ] ; } int mid = 0 ; if ( N % 2 == 0 ) { mid = sum / N ; } else { mid = arr [ N / 2 ] ; } int ans = 0 ; for ( int i = 0 ; i < N / 2 ; i ++ ) { ans += mid - arr [ i ] ; } return ans ; }
int minOperation ( int N ) { if ( N % 2 == 0 ) { return ( N / 2 ) * ( N / 2 ) ; } int k = ( N - 1 ) / 2 ; return k * ( k + 1 ) ; }
int findXORS ( int arr1 [ ] , int arr2 [ ] , int N , int M ) { int XORS1 = 0 ; int XORS2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { XORS1 ^= arr1 [ i ] ; } for ( int i = 0 ; i < M ; i ++ ) { XORS2 ^= arr2 [ i ] ; } return XORS1 and XORS2 ; }
void findPermutation ( vector < int > & arr ) { int N = arr . size ( ) ; int i = N - 2 ; while ( i >= 0 && arr [ i ] <= arr [ i + 1 ] ) i -- ; if ( i == -1 ) { cout << "-1" ; return ; } int j = N - 1 ; while ( j > i && arr [ j ] >= arr [ i ] ) j -- ; while ( j > i && arr [ j ] == arr [ j - 1 ] ) { j -- ; } swap ( arr [ i ] , arr [ j ] ) ; for ( auto & it : arr ) { cout << it << ' ' ; } }
bool isPowerof2 ( unsigned int n ) { return ( ( n & ( n - 1 ) ) && n ) ; }
void countNum ( int N ) { int ans = log2 ( N ) + 1 ; cout << ans << "\n" ; }
int nearestPow ( int x , int base ) { int k = int ( log ( x ) / log ( base ) ) ; if ( abs ( pow ( base , k ) - x ) < abs ( pow ( base , ( k + 1 ) ) - x ) ) return pow ( base , k ) ; else return pow ( base , ( k + 1 ) ) ; }
int ceilDifference ( int arr [ ] , int n , int x ) { int totalSum = 0 ; int perElementSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { totalSum += arr [ i ] ; perElementSum += ceil ( ( double ) ( arr [ i ] ) / ( double ) ( x ) ) ; } int totalCeilSum = ceil ( ( double ) ( totalSum ) / ( double ) ( x ) ) ; return abs ( perElementSum - totalCeilSum ) ; }
void computeTotient ( int N , int phi [ ] ) { for ( int p = 2 ; p <= N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i <= N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } }
void countPairs ( int N ) { int cnt_type1 = 0 , cnt_type2 = 0 ; int half_N = N / 2 ; cnt_type1 = ( half_N * ( half_N - 1 ) ) / 2 ; int phi [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { phi [ i ] = i ; } computeTotient ( N , phi ) ; for ( int i = ( N / 2 ) + 1 ; i <= N ; i ++ ) cnt_type2 += ( i - phi [ i ] - 1 ) ; cout << cnt_type1 + cnt_type2 ; }
int countTriplets ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i * j > N ) break ; ans += N / ( i * j ) ; } } return ans ; }
void findSumOfGP ( double a , double r ) { if ( abs ( r ) >= 1 ) { cout << "Infinite" ; return ; } double sum = a / ( 1 - r ) ; cout << sum ; }
int power ( long long x , unsigned int y ) { int res = 1 ; x = x % mod ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
int numberOfRelations ( int N ) { return power ( 3 , ( N * N - N ) / 2 ) ; }
int countNumbers ( int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( __gcd ( i , N ) != 1 ) count ++ ; } cout << count ; }
int phi ( int N ) { int result = N ; for ( int p = 2 ; p * p <= N ; ++ p ) { if ( N % p == 0 ) { while ( N % p == 0 ) N /= p ; result -= result / p ; } } if ( N > 1 ) result -= result / N ; return result ; }
int countNumbers ( int N ) { int count = N - phi ( N ) ; cout << count ; }
void Query ( int arr [ ] , int N , vector < vector < int > > Q ) { int mul = 1 ; int add = 0 ; for ( int i = 0 ; i < Q . size ( ) ; i ++ ) { if ( Q [ i ] [ 0 ] == 0 ) { add = add + Q [ i ] [ 1 ] ; } else if ( Q [ i ] [ 0 ] == 1 ) { mul = mul * Q [ i ] [ 1 ] ; add = add * Q [ i ] [ 1 ] ; } else { int ans = arr [ Q [ i ] [ 1 ] ] * mul + add ; cout << ans << " " ; } } }
int nearFibo ( int X ) { double a = ( pow ( 5 , 0.5 ) + 1 ) / 2 ; int n = int ( log ( ( pow ( 5 , 0.5 ) ) * X ) / log ( a ) ) ; int nth = nthFibo ( n ) ; int nplus = nthFibo ( n + 1 ) ; if ( abs ( X - nth ) < abs ( X - nplus ) ) return nth ; else return nplus ; }
void sieveOfEratosthenes ( int N , int s [ ] ) { vector < bool > prime ( N + 1 , false ) ; for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= N ; j += 2 ) { if ( ! prime [ i * j ] ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } }
int getMaxPairSum ( int arr [ ] , int N , int K ) { int preMax [ N ] ; preMax [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { preMax [ i ] = max ( preMax [ i - 1 ] , arr [ i ] ) ; } int res = INT_MIN ; for ( int i = K ; i < N ; i ++ ) { res = max ( res , arr [ i ] + preMax [ i - K ] ) ; } return res ; }
void sumOfInfiniteAGP ( double a , double d , double r ) { double ans = a / ( 1 - r ) + ( d * r ) / ( 1 - r * r ) ; cout << ans ; }
int countPairs ( int arr [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 arr [ j ] % arr [ i ] == 0 ) { count ++ ; } } } return count ; }
int CountPairs ( int arr [ ] , int N ) { int res = 0 ; map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } for ( auto p : mp ) { int x = p . first ; int y = p . second ; if ( x == 1 ) { res += N - 1 ; continue ; } res += ( y * ( y - 1 ) ) / 2 ; for ( int j = 2 ; j <= sqrt ( x ) ; j ++ ) { if ( x % j == 0 ) { res += mp [ j ] ; if ( j != x / j ) res += mp [ x / j ] ; } } } return res ; }
void findClosestTarget ( int i , int curr , int B [ ] , int M , int K ) { if ( abs ( curr - K ) < mini ) { mini = abs ( curr - K ) ; ans = curr ; } if ( abs ( curr - K ) == mini ) { ans = min ( ans , curr ) ; } if ( i >= M ) return ; findClosestTarget ( i + 1 , curr + B [ i ] , B , M , K ) ; findClosestTarget ( i + 1 , curr + 2 * B [ i ] , B , M , K ) ; findClosestTarget ( i + 1 , curr , B , M , K ) ; }
int findClosest ( int A [ ] , int B [ ] , int N , int M , int K ) { for ( int i = 0 ; i < N ; i ++ ) { findClosestTarget ( 0 , A [ i ] , B , M , K ) ; } return ans ; }
int countbits ( int n ) { int count = 0 ; while ( n != 0 ) { if ( n & 1 ) count ++ ; n = n / 2 ; } return count ; }
int BitProduct ( int arr [ ] , int N ) { int product = 1 ; for ( int i = 0 ; i < N ; i ++ ) { int bits = countbits ( arr [ i ] ) ; product *= bits ; } return product ; }
vector < int > removeEveryKth ( vector < int > l , int k ) { for ( int i = 0 ; i < l . size ( ) ; i ++ ) { if ( i % k == 0 ) l [ i ] = 0 ; } vector < int > arr ; arr . push_back ( 0 ) ; for ( int i = 1 ; i < l . size ( ) ; i ++ ) { if ( l [ i ] != 0 ) arr . push_back ( l [ i ] ) ; } return arr ; }
void printArray ( vector < int > l ) { for ( int i = 1 ; i < l . size ( ) ; i ++ ) cout << l [ i ] << " " ; cout << endl ; }
void printSequence ( int n , int k ) { vector < int > l ( n + 1 ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) l [ i ] = i ; int x = 1 ; for ( int i = 0 ; i < k ; i ++ ) { int p = l [ x ] + l [ x + 1 ] ; l = removeEveryKth ( l , p ) ; x += 1 ; } printArray ( l ) ; }
void OddDivisorsSum ( int n , int q , int a [ ] , vector < pair < int , int > > Query ) { int DP [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int x = sqrt ( a [ i ] ) ; if ( x * x == a [ i ] ) DP [ i ] = a [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { DP [ i ] = DP [ i - 1 ] + DP [ i ] ; } for ( int i = 0 ; i < q ; i ++ ) { int l = Query [ i ] . first ; int r = Query [ i ] . second ; if ( l == 0 ) { cout << DP [ r ] << " " ; } else { cout << DP [ r ] - DP [ l - 1 ] << " " ; } } }
static void findSubset ( vector < int > arr ) { int N = arr . size ( ) ; map < int , int > mp ; int totSum = 0 ; int s = 0 ; int flag = 0 ; vector < int > ans ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { totSum += arr [ i ] ; mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } sort ( arr . begin ( ) , arr . end ( ) ) ; int i = N - 1 ; while ( i >= 0 ) { int frq = mp [ arr [ i ] ] ; if ( ( frq + ans . size ( ) ) < ( N - ( frq + ans . size ( ) ) ) ) { for ( int k = 0 ; k < frq ; k ++ ) { ans . push_back ( arr [ i ] ) ; totSum -= arr [ i ] ; s += arr [ i ] ; i -- ; } } else { i -= frq ; } if ( s > totSum ) { flag = 1 ; break ; } } if ( flag == 1 ) { for ( i = ans . size ( ) - 1 ; i >= 0 ; i -- ) { cout << ans [ i ] << " " ; } } else { cout << -1 ; } }
int minStepK ( int arr [ ] , int N , int K ) { int E = 0 ; int S = 0 ; for ( int i = 0 ; i < N ; i ++ ) { S += arr [ i ] ; if ( arr [ i ] % 2 == 0 ) E += 1 ; } if ( S >= K ) return 0 ; else if ( S + E < K ) return -1 ; else return K - S ; }
int Rotate ( int n , int f ) { int temp = n ; int maxi = n ; int mini = n ; for ( int idx = 0 ; idx < 7 ; idx ++ ) { if ( temp & 1 ) { temp >>= 1 ; temp += pow ( 2 , 7 ) ; } else temp >>= 1 ; mini = min ( mini , temp ) ; maxi = max ( maxi , temp ) ; } if ( f ) return ( maxi ) ; else return ( mini ) ; }
int minimumDiff ( int arr [ ] , int N ) { int res = arr [ 0 ] , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int min_diff = sum ; for ( int i = 0 ; i < N ; i ++ ) { if ( abs ( sum - ( arr [ i ] * N ) ) < min_diff ) { min_diff = abs ( sum - ( arr [ i ] * N ) ) ; res = arr [ i ] ; } } cout << res ; }
int makeEqual ( int * arr , int n ) { int fre0 [ 33 ] = { 0 } ; int fre1 [ 33 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; for ( int j = 0 ; j < 33 ; j ++ ) { if ( x & 1 ) { fre1 [ j ] += 1 ; } else { fre0 [ j ] += 1 ; } x = x >> 1 ; } } int ans = 0 ; for ( int i = 0 ; i < 33 ; i ++ ) { ans += min ( fre0 [ i ] , fre1 [ i ] ) ; } return ans ; }
void check ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum == 0 ) cout << "Yes" ; else cout << "No" ; }
int primeDivisors ( int arr [ ] , int N ) { int K = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { K = max ( K , arr [ i ] ) ; } int prime [ K + 1 ] = { 0 } ; prime [ 0 ] = 1 ; prime [ 1 ] = 1 ; for ( int i = 2 ; i < K + 1 ; i ++ ) { if ( ! prime [ i ] ) { for ( int j = 2 * i ; j < K + 1 ; j += i ) { prime [ j ] = 1 ; } } } int factor [ K + 1 ] = { 0 } ; factor [ 0 ] = 0 ; factor [ 1 ] = 1 ; for ( int i = 2 ; i < K + 1 ; i ++ ) { factor [ i ] += 1 ; for ( int j = i ; j < K + 1 ; j += i ) { factor [ j ] += 1 ; } } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( prime [ factor [ arr [ i ] ] ] == 0 ) count ++ ; } return count ; }
int isPresent ( int n , int x ) { string num = to_string ( n ) ; for ( int i = 0 ; i < num . size ( ) ; i ++ ) { if ( ( num [ i ] - '0' ) == x ) return i ; } return -1 ; }
int removeDigit ( int n , int index ) { string num = to_string ( n ) ; string ans = "" ; for ( int i = 0 ; i < num . size ( ) ; i ++ ) { if ( i != index ) ans += num [ i ] ; } if ( ans == "" || ( ans . size ( ) == 1 && ans [ 0 ] == '0' ) ) return -1 ; int x = stoi ( ans ) ; return x ; }
bool reduceNtoX ( int a , int b , int d [ ] , int n ) { queue < int > q ; q . push ( a ) ; unordered_map < int , bool > visited ; visited [ a ] = true ; while ( ! q . empty ( ) ) { int top = q . front ( ) ; q . pop ( ) ; if ( top < 0 ) continue ; if ( top == b ) return true ; for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] != 0 && top % d [ i ] == 0 && ! visited [ top / d [ i ] ] ) { q . push ( top / d [ i ] ) ; visited [ top / d [ i ] ] = true ; } int index = isPresent ( top , d [ i ] ) ; if ( index != -1 ) { int newElement = removeDigit ( top , index ) ; if ( newElement != -1 && ( ! visited [ newElement ] ) ) { q . push ( newElement ) ; visited [ newElement ] = true ; } } } } return false ; }
void SieveOfEratosthenes ( int n , bool prime [ ] ) { prime [ 0 ] = 0 ; prime [ 1 ] = 0 ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } }
int fact ( int n ) { if ( n == 1 n == 0 ) return 1 ; else return n * fact ( n - 1 ) ; }
int findValue ( int n , int r , int a ) { int k = ( a - 1 ) / fact ( n ) ; int answer = k ; for ( int i = 1 ; i < n + 1 ; i ++ ) answer = answer * ( n + r - i ) ; answer = answer + 1 ; return answer ; }
void expectedValue ( int P , int a , int b , int N ) { double expValue = P + ( N * 0.5 * ( a + b ) ) ; cout << expValue ; }
int startingPoint ( int A [ ] , int N ) { int sum = 0 ; int in = 0 ; int min = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( sum < min ) { min = sum ; in = i + 1 ; } } if ( sum < 0 ) { return -1 ; } return in % N ; }
int findMinSum ( vector < vector < int > > mat , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int res = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( i != j ) { res |= mat [ i ] [ j ] ; } } sum += res ; } return sum ; }
void findMedian ( int Mean , int Mode ) { double Median = ( 2 * Mean + Mode ) / 3.0 ; cout << Median ; }
void sumOfBinaryNumbers ( int n ) { int ans = 0 ; int one = 1 ; while ( 1 ) { if ( n <= 1 ) { ans = ( ans + n ) % MOD ; break ; } int x = log2 ( n ) ; int cur = 0 ; int add = ( one << ( x - 1 ) ) ; for ( int i = 1 ; i <= x ; i ++ ) { cur = ( cur + add ) % MOD ; add = ( add * 10 % MOD ) ; } ans = ( ans + cur ) % MOD ; int rem = n - ( one << x ) + 1 ; int p = pow ( 10 , x ) ; p = ( p * ( rem % MOD ) ) % MOD ; ans = ( ans + p ) % MOD ; n = rem - 1 ; } cout << ans ; }
int uniqueElementsLCM ( int arr [ ] , int N ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } int lcm = 1 ; for ( auto i : freq ) { if ( i . second == 1 ) { lcm = findLCM ( lcm , i . first ) ; } } if ( lcm == 1 ) lcm = -1 ; cout << lcm ; }
int maxAdjacentDifference ( vector < int > A ) { int diff = 0 ; for ( int i = 1 ; i < ( int ) A . size ( ) ; i ++ ) { diff = max ( diff , A [ i ] - A [ i - 1 ] ) ; } return diff ; }
int MinimumValue ( int arr [ ] , int N ) { int MinValue = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { vector < int > new_arr ; for ( int j = 0 ; j < N ; j ++ ) { if ( i == j ) continue ; new_arr . push_back ( arr [ j ] ) ; } MinValue = min ( MinValue , maxAdjacentDifference ( new_arr ) ) ; } return MinValue ; }
void findNode ( map < int , int > mp , int n ) { int a [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = mp [ i + 1 ] ; } int count0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count0 ++ ; } } count0 -= 1 ; if ( count0 <= floor ( ( ( double ) n ) / ( ( double ) 2 ) ) ) { cout << "Yes" ; } else cout << "No" ; }
int count ( int num ) { int ans = 0 ; while ( num > 0 ) { ans += num & 1 ; num >>= 1 ; } return ans ; }
void checkGoodMatrix ( vector < vector < int > > mat ) { vector < int > P ; vector < int > S ; vector < int > MR ; vector < int > MC ; for ( int i = 0 ; i < mat . size ( ) ; i ++ ) { for ( int j = 0 ; j < mat [ 0 ] . size ( ) ; j ++ ) { if ( i == j ) P . push_back ( mat [ i ] [ j ] ) ; if ( i + j == mat . size ( ) - 1 ) S . push_back ( mat [ i ] [ j ] ) ; if ( i == floor ( ( mat . size ( ) - 1 ) / 2 ) ) MR . push_back ( mat [ i ] [ j ] ) ; if ( j == floor ( ( mat . size ( ) - 1 ) / 2 ) ) MC . push_back ( mat [ i ] [ j ] ) ; } } reverse ( S . begin ( ) , S . end ( ) ) ; int P0 = convert ( P ) ; int S0 = convert ( S ) ; int MR0 = convert ( MR ) ; int MC0 = convert ( MC ) ; int setBitsPS = count ( ( P0 & S0 ) ) ; int setBitsMM = count ( ( MR0 & MC0 ) ) ; if ( setBitsPS > setBitsMM ) cout << "Yes" ; else cout << "No" ; }
int power ( long long x , unsigned int y ) { int res = 1 ; x = x % mod ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
int antisymmetricRelation ( int N ) { return ( power ( 2 , N ) * 1LL * power ( 3 , ( N * N - N ) / 2 ) ) % mod ; }
int power ( long long x , unsigned int y ) { int res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
int asymmetricRelation ( int N ) { return power ( 3 , ( N * N - N ) / 2 ) ; }
void crossProduct ( int vect_A [ ] , int vect_B [ ] , int cross_P [ ] ) { cross_P [ 0 ] = vect_A [ 1 ] * vect_B [ 2 ] - vect_A [ 2 ] * vect_B [ 1 ] ; cross_P [ 1 ] = vect_A [ 2 ] * vect_B [ 0 ] - vect_A [ 0 ] * vect_B [ 2 ] ; cross_P [ 2 ] = vect_A [ 0 ] * vect_B [ 1 ] - vect_A [ 1 ] * vect_B [ 0 ] ; }
void checkCollinearity ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { int A [ 3 ] = { x1 , y1 , z1 } ; int B [ 3 ] = { x2 , y2 , z2 } ; int cross_P [ 3 ] ; crossProduct ( A , B , cross_P ) ; if ( cross_P [ 0 ] == 0 && cross_P [ 1 ] == 0 && cross_P [ 2 ] == 0 ) cout << "Yes" ; else cout << "No" ; }
float vectorMagnitude ( int x , int y , int z ) { int sum = x * x + y * y + z * z ; return sqrt ( sum ) ; }
float kineticEnergy ( float M , float V ) { float KineticEnergy ; KineticEnergy = 0.5 * M * V * V ; return KineticEnergy ; }
float potentialEnergy ( float M , float H ) { float PotentialEnergy ; PotentialEnergy = M * 9.8 * H ; return PotentialEnergy ; }
int nearestPow ( int x , int y ) { if ( y == 1 ) return 1 ; int k = log10 ( x ) / log10 ( y ) ; if ( abs ( pow ( y , k ) - x ) < abs ( pow ( y , ( k + 1 ) ) - x ) ) return pow ( y , k ) ; return pow ( y , ( k + 1 ) ) ; }
void countPairs ( int arr [ ] , int N ) { int even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; } if ( N - even >= 1 ) { cout << even ; return ; } cout << 0 ; }
void nearestFibonacci ( int num ) { if ( num == 0 ) { cout << 0 ; return ; } int first = 0 , second = 1 ; int third = first + second ; while ( third <= num ) { first = second ; second = third ; third = first + second ; } int ans = ( abs ( third - num ) >= abs ( second - num ) ) ? second : third ; cout << ans ; }
bool checkPermutation ( int ans [ ] , int a [ ] , int n ) { int Max = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { Max = max ( Max , ans [ i ] ) ; if ( Max != a [ i ] ) return false ; } return true ; }
void findPermutation ( int a [ ] , int n ) { int ans [ n ] = { 0 } ; unordered_map < int , int > um ; for ( int i = 0 ; i < n ; i ++ ) { if ( um . find ( a [ i ] ) == um . end ( ) ) { ans [ i ] = a [ i ] ; um [ a [ i ] ] = i ; } } vector < int > v ; int j = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( um . find ( i ) == um . end ( ) ) { v . push_back ( i ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ans [ i ] == 0 ) { ans [ i ] = v [ j ] ; j ++ ; } } if ( checkPermutation ( ans , a , n ) ) { for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << " " ; } } else cout << "-1" ; }
bool isPower ( int m , int y ) { int res1 = log ( y ) / log ( m ) ; double res2 = log ( y ) / log ( m ) ; return ( res1 == res2 ) ; }
int numSub ( int arr [ ] , int n , int m ) { int ans = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPower ( m , arr [ i ] ) ) { cnt ++ ; ans += ( cnt * ( cnt - 1 ) ) / 2 ; } else { cnt = 0 ; } } return ans ; }
void SieveOfEratosthenes ( int n ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } }
void assignValues ( int Edges [ ] [ 2 ] , int n ) { vector < int > tree [ n + 1 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int u = Edges [ i ] [ 0 ] ; int v = Edges [ i ] [ 1 ] ; tree [ u ] . push_back ( v ) ; tree [ v ] . push_back ( u ) ; } vector < bool > visited ( n + 1 , false ) ; vector < int > answer ( n + 1 ) ; int K = 1 ; queue < int > q ; q . push ( 1 ) ; answer [ 1 ] = K ; while ( ! q . empty ( ) ) { int node = q . front ( ) ; q . pop ( ) ; visited [ node ] = true ; K = ( ( answer [ node ] == 1 ) ? 2 : 1 ) ; for ( auto child : tree [ node ] ) { if ( ! visited [ child ] ) { q . push ( child ) ; answer [ child ] = K ; } } } for ( int i = 1 ; i <= n ; i ++ ) { cout << answer [ i ] << " " ; } }
void distribute ( int N , int K , int M , int arr [ ] ) { int distribution [ N ] = { 0 } ; int ptr = K - 1 ; int rem = M ; while ( rem > 0 ) { if ( rem >= arr [ ptr ] ) { distribution [ ptr ] += arr [ ptr ] ; rem -= arr [ ptr ] ; } else { distribution [ ptr ] += rem ; rem = 0 ; } ptr = ( ptr + 1 ) % N ; } for ( int i = 0 ; i < N ; i ++ ) { cout << distribution [ i ] << " " ; } }
void sumOfSquaredDifferences ( int arr [ ] , int N ) { int ans = 0 ; int sumA = 0 , sumB = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sumA += ( arr [ i ] * arr [ i ] ) ; sumB += arr [ i ] ; } sumA = N * sumA ; sumB = ( sumB * sumB ) ; ans = sumA - sumB ; cout << ans ; }
bool isPrime ( ll n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( ll i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
void findMinimumNumber ( ll arr [ ] , ll N ) { vector < ll > primes ; findPrime ( primes ) ; ll ans = INT_MAX ; ll n = primes . size ( ) ; for ( ll i = 1 ; i < ( 1 << n ) ; i ++ ) { ll temp = 1 ; for ( ll j = 0 ; j < n ; j ++ ) { if ( i & ( 1 << j ) ) { temp *= primes [ j ] ; } } bool check = true ; for ( ll k = 0 ; k < N ; k ++ ) { if ( gcd ( temp , arr [ k ] ) == 1 ) { check = false ; break ; } } if ( check ) ans = min ( ans , temp ) ; } cout << ans ; }
void waysToRemove ( int n , int m ) { int ans = 0 ; if ( m == 1 ) { cout << n ; return ; } for ( int d = 0 ; d >= 0 ; d ++ ) { int len = m + ( m - 1 ) * d ; if ( len > n ) break ; ans += ( n - len ) + 1 ; } cout << ans ; }
void countStairs ( int n , int x , int a , int b ) { int vis [ n + 1 ] = { 0 } ; int moves [ ] = { + a , - a , + b , - b } ; queue < int > q ; q . push ( x ) ; vis [ x ] = 1 ; while ( ! q . empty ( ) ) { int currentStair = q . front ( ) ; q . pop ( ) ; for ( int j = 0 ; j < 4 ; j ++ ) { int newStair = currentStair + moves [ j ] ; if ( newStair > 0 && newStair <= n && ! vis [ newStair ] ) { q . push ( newStair ) ; vis [ newStair ] = 1 ; } } } int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( vis [ i ] == 1 ) cnt ++ ; cout << cnt ; }
int minimumSteps ( int x , int y ) { int cnt = 0 ; while ( x != 0 && y != 0 ) { if ( x > y ) { cnt += x / y ; x %= y ; } else { cnt += y / x ; y %= x ; } } cnt -- ; if ( x > 1 y > 1 ) cnt = -1 ; cout << cnt ; }
int cntPairs ( int arr [ ] , int N ) { int res = 0 ; int bit [ 32 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int pos = log2 ( arr [ i ] ) ; bit [ pos ] ++ ; } for ( int i = 0 ; i < 32 ; i ++ ) { res += ( bit [ i ] * ( bit [ i ] - 1 ) ) / 2 ; } return res ; }
void minimumMEX ( int arr [ ] , int N , int K ) { set < int > s ; for ( int i = 1 ; i <= N + 1 ; i ++ ) s . insert ( i ) ; for ( int i = 0 ; i < K ; i ++ ) s . erase ( arr [ i ] ) ; int mex = * ( s . begin ( ) ) ; for ( int i = K ; i < N ; i ++ ) { s . erase ( arr [ i ] ) ; s . insert ( arr [ i - K ] ) ; int firstElem = * ( s . begin ( ) ) ; mex = min ( mex , firstElem ) ; } cout << mex << ' ' ; }
void smallerNumbers ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { count ++ ; } } cout << count << " " ; } }
int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; }
void minimumOperations ( int X , int Y ) { int GCD = gcd ( X , Y ) ; X = X / GCD ; Y = Y / GCD ; int count = 0 ; while ( X != Y ) { if ( Y > X ) { swap ( X , Y ) ; } if ( X % 2 == 0 ) { X = X / 2 ; } else if ( X % 3 == 0 ) { X = X / 3 ; } else if ( X % 5 == 0 ) { X = X / 5 ; } else { cout << "-1" ; return ; } count ++ ; } cout << count ; }
int minOperations ( int a [ ] , int n ) { int ans = accumulate ( a , a + n , 0 ) - n ; for ( int x = 1 ; ; x ++ ) { int curPow = 1 , curCost = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curCost += abs ( a [ i ] - curPow ) ; curPow *= x ; } if ( curPow / x > ans + a [ n - 1 ] ) break ; ans = min ( ans , curCost ) ; } return ans ; }
int truncMod ( int a , int n ) { int q = a / n ; return a - n * q ; }
void addEdge ( vector < int > Adj [ ] , int u , int v ) { Adj [ u ] . push_back ( v ) ; Adj [ v ] . push_back ( u ) ; }
void isPossible ( struct Node Arr [ ] , int N ) { vector < int > Adj [ N ] ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] . R < Arr [ j ] . L Arr [ i ] . L > Arr [ j ] . R ) { continue ; } else { if ( Arr [ i ] . V == Arr [ j ] . V ) { addEdge ( Adj , i , j ) ; } } } } bool visited [ N ] = { false } ; for ( int i = 0 ; i < N ; i ++ ) { if ( visited [ i ] == false && Adj [ i ] . size ( ) > 0 ) { if ( check ( Adj , i , N , visited ) == false ) { cout << "No" ; return ; } } } cout << "Yes" ; }
void printArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << " " ; } }
int bitOr ( int arr [ ] , int N ) { int count = 0 ; int length = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { length ++ ; } else { if ( length != 0 ) { count += ( ( length ) * ( length + 1 ) ) / 2 ; } length = 0 ; } } count += ( ( length ) * ( length + 1 ) ) / 2 ; return count ; }
double mean ( int arr [ ] , int N ) { double avg = 0 ; for ( int i = 0 ; i < N ; i ++ ) { avg += ( arr [ i ] - avg ) / ( i + 1 ) ; } return avg ; }
int maximumAND ( int arr [ ] , int n , int m ) { int tot = 1 << n ; int mx = 0 ; for ( int bm = 0 ; bm < tot ; bm ++ ) { int andans = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ( bm >> i ) & 1 ) { if ( count == 0 ) { andans = arr [ i ] ; } else { andans = andans & arr [ i ] ; } count ++ ; } } if ( count == ( m + 1 ) ) { mx = max ( mx , andans ) ; } } return mx ; }
void findTotalSum ( vector < string > & ops ) { if ( ops . empty ( ) ) { cout << 0 ; return ; } stack < int > pts ; int ans = 0 ; for ( int i = 0 ; i < ops . size ( ) ; i ++ ) { if ( ops [ i ] == "C" ) { ans -= pts . top ( ) ; pts . pop ( ) ; } else if ( ops [ i ] == "D" ) { pts . push ( pts . top ( ) * 2 ) ; ans += pts . top ( ) ; } else if ( ops [ i ] == "+" ) { int a = pts . top ( ) ; pts . pop ( ) ; int b = pts . top ( ) ; pts . push ( a ) ; ans += ( a + b ) ; pts . push ( a + b ) ; } else { int n = stoi ( ops [ i ] ) ; ans += n ; pts . push ( n ) ; } } cout << ans ; }
void findXOR ( vector < vector < vector < int > > > & mat , int N ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) { if ( ( i == j && j == k ) ) { XOR ^= mat [ i ] [ j ] [ k ] ; XOR ^= mat [ i ] [ j ] [ N - k - 1 ] ; } } } } cout << XOR << "\n" ; }
void findXOR ( vector < vector < vector < int > > > & mat , int N ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { XOR ^= mat [ i ] [ i ] [ i ] ; XOR ^= mat [ i ] [ i ] [ N - i - 1 ] ; } cout << XOR << "\n" ; }
int countSubtreesUtil ( int cur , int par ) { int res = 1 ; for ( int i = 0 ; i < graph [ cur ] . size ( ) ; i ++ ) { int v = graph [ cur ] [ i ] ; if ( v == par ) continue ; res = ( res * ( countSubtreesUtil ( v , cur ) + 1 ) ) % mod ; } ans = ( ans + res ) % mod ; return res ; }
void countSubtrees ( int N , vector < pair < int , int > > & adj ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { int a = adj [ i ] . first ; int b = adj [ i ] . second ; graph [ a ] . push_back ( b ) ; graph [ b ] . push_back ( a ) ; } countSubtreesUtil ( 1 , 1 ) ; cout << ans + 1 ; }
void sieve ( ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= limit ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= limit ; i += p ) prime [ i ] = false ; } } }
int findOperations ( int arr [ ] , int n ) { sieve ( ) ; int minm = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { minm = min ( minm , arr [ i ] ) ; } int val = minm ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == minm + 1 ) { val = minm - 2 ; break ; } } int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int D = arr [ i ] - val ; if ( D == 0 ) { continue ; } else if ( prime [ D ] == true ) { cnt += 1 ; } else if ( D % 2 == 0 ) { cnt += 2 ; } else { if ( prime [ D - 2 ] == true ) { cnt += 2 ; } else { cnt += 3 ; } } } return cnt ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int maximumRowValue ( int n , int m ) { return gcd ( n , m ) ; }
void checkCommonDivisor ( int arr [ ] , int N , int X ) { int G = 0 ; for ( int i = 0 ; i < N ; i ++ ) { G = __gcd ( G , arr [ i ] ) ; } int copy_G = G ; for ( int divisor = 2 ; divisor <= X ; divisor ++ ) { while ( G % divisor == 0 ) { G = G / divisor ; } } if ( G <= X ) { cout << "Yes\n" ; for ( int i = 0 ; i < N ; i ++ ) cout << arr [ i ] / copy_G << " " ; cout << endl ; } else cout << "No" ; }
void countPairs ( int arr [ ] , int N ) { int count = 0 ; unordered_map < double , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { double val = 1.0 * arr [ i ] ; double idx = 1.0 * ( i + 1 ) ; count += mp [ val / idx ] ; mp [ val / idx ] ++ ; } cout << count ; }
void findConvolution ( const vector < int > & a , const vector < int > & b ) { int n = a . size ( ) , m = b . size ( ) ; vector < long long > c ( n + m - 1 ) ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { c [ i + j ] += 1LL * ( a [ i ] * b [ j ] ) % MOD ; } } for ( int k = 0 ; k < c . size ( ) ; ++ k ) { c [ k ] %= MOD ; cout << c [ k ] << " " ; } }
int count1s ( int start_i , int start_j , int end_i , int end_j , int mat [ ] [ P ] ) { int count = 0 ; for ( int x = start_i ; x < end_i ; x ++ ) { for ( int y = start_j ; y < end_j ; y ++ ) { if ( mat [ x ] [ y ] == 1 ) count ++ ; } } return count ; }
int findMinimumCount ( int N , int M , int A , int B , int mat [ ] [ P ] ) { int minimum = 1e9 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( i + A <= N && j + B <= M ) { int count = count1s ( i , j , i + A , j + B , mat ) ; minimum = min ( count , minimum ) ; } if ( i + B <= N && j + A <= M ) { int count = count1s ( i , j , i + B , j + A , mat ) ; minimum = min ( count , minimum ) ; } } } return minimum ; }
bool checkEvenPower ( int n ) { int x = 0 ; while ( x < n ) { int value = pow ( 2 , x ) ; if ( value == n ) { if ( x % 2 == 0 ) return true ; else return false ; } x ++ ; } return false ; }
int getMaxUtil ( vector < int > p , int arr [ ] , int ans , bool chosen [ ] , int N ) { if ( p . size ( ) == N ) { ans = max ( ans , calcScore ( p , arr , N ) ) ; return ans ; } for ( int i = 0 ; i < N ; i ++ ) { if ( chosen [ i ] ) { continue ; } chosen [ i ] = true ; p . push_back ( i ) ; ans = getMaxUtil ( p , arr , ans , chosen , N ) ; chosen [ i ] = false ; p . pop_back ( ) ; } return ans ; }
void getMax ( int arr [ ] , int N ) { int ans = 0 ; bool chosen [ N ] ; for ( int i = 0 ; i < N ; i ++ ) chosen [ i ] = false ; vector < int > p ; int res = getMaxUtil ( p , arr , ans , chosen , N ) ; cout << res ; }
long multiplyByMersenne ( long N , long M ) { long x = log2 ( M + 1 ) ; return ( ( N << x ) - N ) ; }
int findSum ( int N , int K ) { int ans = 0 ; int i = 1 ; while ( i <= N ) { ans += N / i ; i = i * K ; } cout << ans ; }
void minimumInsertions ( int arr [ ] , int N , int K ) { bool possible = 1 ; int res = 0 ; int last = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= K ) { possible = 0 ; break ; } if ( last + arr [ i ] > K ) res ++ ; last = arr [ i ] ; } if ( possible ) { cout << res ; } else { cout << "-1" ; } }
int maxSubSum ( int arr [ ] , int n , int k , int totalDistinct ) { if ( k > n ) return 0 ; int maxm = 0 , sum = 0 ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { sum = 0 ; set < int > st ; for ( int j = i ; j < i + k ; j ++ ) { sum += arr [ j ] ; st . insert ( arr [ j ] ) ; } if ( ( int ) st . size ( ) == totalDistinct ) maxm = max ( sum , maxm ) ; } return maxm ; }
int distinct ( vector < int > arr , int N ) { set < int > st ; for ( int i = 0 ; i < N ; i ++ ) { st . insert ( arr [ i ] ) ; } return st . size ( ) ; }
int maxSubarraySumUtil ( vector < int > arr , int N , int K , int totalDistinct ) { if ( K > N ) return 0 ; int mx = 0 ; int sum = 0 ; map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] += 1 ; sum += arr [ i ] ; if ( i >= K ) { mp [ arr [ i - K ] ] -= 1 ; sum -= arr [ i - K ] ; if ( mp [ arr [ i - K ] ] == 0 ) mp . erase ( arr [ i - K ] ) ; } if ( mp . size ( ) == totalDistinct ) mx = max ( mx , sum ) ; } return mx ; }
void maxSubarraySum ( vector < int > arr , int K ) { int N = arr . size ( ) ; int totalDistinct = distinct ( arr , N ) ; cout << maxSubarraySumUtil ( arr , N , K , totalDistinct ) ; }
int irreflexiveRelation ( int N ) { return power ( 2 , N * N - N ) ; }
void countAPs ( long long int N ) { long long int count = 0 ; for ( long long int i = 1 ; i * i <= 2 * N ; i ++ ) { long long int res = 2 * N ; if ( res % i == 0 ) { long long int op = res / i - i + 1 ; if ( op % 2 == 0 ) { count ++ ; } if ( i * i != res and ( i - res / i + 1 ) % 2 == 0 ) { count ++ ; } } } cout << count - 1 << "\n" ; }
int perfectSquare ( int num ) { int sr = sqrt ( num ) ; int a = sr * sr ; int b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( num - a ) < ( b - num ) ) { return a ; } else { return b ; } }
int powerOfTwo ( int num ) { int lg = log2 ( num ) ; int p = pow ( 2 , lg ) ; return p ; }
void uniqueElement ( int arr [ ] , int N ) { bool ans = true ; unordered_map < int , int > freq ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } for ( auto el : freq ) { if ( el . second == 1 ) { ans = false ; int ps = perfectSquare ( el . first ) ; cout << powerOfTwo ( ps ) << ' ' ; } } if ( ans ) cout << "-1" ; }
bool canExpress ( int N ) { int temp = N ; int n = 0 ; while ( N != 0 ) { N /= 10 ; n ++ ; } N = temp ; int sum = 0 ; while ( N != 0 ) { sum += pow ( N % 10 , n ) ; N /= 10 ; } return ( sum == temp ) ; }
void precompute ( ) { for ( int i = 1 ; i < R ; i ++ ) { if ( canExpress ( i ) ) { arr [ i ] = 1 ; } } for ( int i = 1 ; i < R ; i ++ ) { arr [ i ] += arr [ i - 1 ] ; } }
void countNumbers ( int queries [ ] [ 2 ] , int N ) { precompute ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int L1 = queries [ i ] [ 0 ] ; int R1 = queries [ i ] [ 1 ] ; cout << ( arr [ R1 ] - arr [ L1 - 1 ] ) << ' ' ; } }
bool isAnyPrime ( int first , int last ) { int num1 = first * 10 + last ; int num2 = last * 10 + first ; if ( sieve [ num1 ] == 1 sieve [ num2 ] == 1 ) return true ; else return false ; }
void sumOfNodeInAPath ( int node_value ) { int sum_of_node = 0 ; while ( node_value ) { sum_of_node += node_value ; node_value /= 2 ; } cout << sum_of_node ; return ; }
void findSum ( vector < int > Q ) { for ( int i = 0 ; i < Q . size ( ) ; i ++ ) { int node_value = Q [ i ] ; sumOfNodeInAPath ( node_value ) ; cout << " " ; } }
string oddDivisor ( int N ) { int X = N ; while ( N % 2 == 0 ) { N /= 2 ; } for ( int i = 3 ; i * i <= X ; i += 2 ) { if ( N % i == 0 ) { return "Yes" ; } } if ( N != X ) return "Yes" ; return "No" ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
void preprocess ( ) { for ( int i = 1 ; i <= 1000000 ; i ++ ) primes [ i ] = i ; for ( int i = 2 ; i * i <= 1000000 ; i ++ ) { if ( primes [ i ] == i ) { for ( int j = 2 * i ; j <= 1000000 ; j += i ) { if ( primes [ j ] == j ) primes [ j ] = i ; } } } }
int Steps ( int x , int m ) { int steps = 0 ; bool flag = false ; while ( x > 1 ) { if ( primes [ x ] > m ) { flag = true ; break ; } x /= primes [ x ] ; steps ++ ; } if ( flag ) return -1 ; return steps ; }
int minimumSteps ( int x , int y , int m ) { preprocess ( ) ; int g = gcd ( x , y ) ; x = x / g ; y = y / g ; int x_steps = Steps ( x , m ) ; int y_steps = Steps ( y , m ) ; if ( x_steps == -1 y_steps == -1 ) return -1 ; return x_steps + y_steps ; }
int LongestNonDeficientSubsequence ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isNonDeficient ( arr [ i ] ) ) { res += 1 ; } } return res ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 , num = 2 ; i <= n ; num ++ ) { if ( countPrimeFactors ( num ) == 2 ) { sum += num ; i ++ ; } } return sum ; }
void check ( int n , int k ) { int s = findSum ( k - 1 ) ; if ( s >= n ) cout << "No" ; else cout << "Yes" ; }
int setBitCount ( int n ) { int ans = 0 ; while ( n ) { ans += n & 1 ; n >>= 1 ; } return ans ; }
bool isPronic ( int n ) { int range = sqrt ( n ) ; for ( int i = 0 ; i < range + 1 ; i ++ ) { if ( i * ( i + 1 ) == n ) return true ; } return false ; }
int LOG ( int a , int b ) { return log ( a ) / log ( b ) ; }
void countSubsequences ( vector < int > A ) { int odd = 0 ; int even = 0 ; for ( int el : A ) { if ( el % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 ) cout << ( 0 ) ; else cout << ( 1 << ( A . size ( ) - 1 ) ) ; }
long long int gcd ( long long int a , long long int b ) { while ( b > 0 ) { long long int rem = a % b ; a = b ; b = rem ; } return a ; }
int countNumberOfWays ( long long int n ) { if ( n == 1 ) return -1 ; long long int g = 0 ; int power = 0 ; while ( n % 2 == 0 ) { power ++ ; n /= 2 ; } g = gcd ( g , power ) ; for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { power = 0 ; while ( n % i == 0 ) { power ++ ; n /= i ; } g = gcd ( g , power ) ; } if ( n > 2 ) g = gcd ( g , 1 ) ; int ways = 1 ; power = 0 ; while ( g % 2 == 0 ) { g /= 2 ; power ++ ; } ways *= ( power + 1 ) ; for ( int i = 3 ; i <= sqrt ( g ) ; i += 2 ) { power = 0 ; while ( g % i == 0 ) { power ++ ; g /= i ; } ways *= ( power + 1 ) ; } if ( g > 2 ) ways *= 2 ; return ways ; }
int coprime ( int a , int b ) { return ( __gcd ( a , b ) == 1 ) ; }
int noOfCoPrimePairs ( int N , int d1 , int d2 ) { vector < string > l ; l . push_back ( to_string ( d1 ) ) ; l . push_back ( to_string ( d2 ) ) ; sort ( l . begin ( ) , l . end ( ) ) ; if ( N < stoi ( l [ 1 ] ) ) return 0 ; vector < string > total = l ; vector < string > temp2 = l ; int flag = 0 ; vector < string > temp3 ; while ( l [ 0 ] . length ( ) < 10 ) { for ( int i = 0 ; i < l . size ( ) ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { if ( stoi ( l [ i ] + temp2 [ j ] ) > N ) { flag = 1 ; break ; } total . push_back ( l [ i ] + temp2 [ j ] ) ; temp3 . push_back ( l [ i ] + temp2 [ j ] ) ; } if ( flag == 1 ) break ; } if ( flag == 1 ) break ; l = temp3 ; vector < string > temp3 ; } int lenOfTotal = total . size ( ) ; int ans = numOfPairs ( total , lenOfTotal ) ; cout << ( ans ) ; }
void countEqualElementPairs ( int arr [ ] , int N ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] += 1 ; } int total = 0 ; for ( auto i : mp ) { total += ( i . second * ( i . second - 1 ) ) / 2 ; } for ( int i = 0 ; i < N ; i ++ ) { cout << total - ( mp [ arr [ i ] ] - 1 ) << " " ; } }
int minDeletions ( int arr [ ] , int N ) { map < int , int > freq ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } vector < int > v ; for ( auto z : freq ) { v . push_back ( z . second ) ; } sort ( v . begin ( ) , v . end ( ) ) ; int size = v . size ( ) ; int ans = N - ( v [ 0 ] * size ) ; for ( int i = 1 ; i < v . size ( ) ; i ++ ) { if ( v [ i ] != v [ i - 1 ] ) { int safe = v [ i ] * ( size - i ) ; ans = min ( ans , N - safe ) ; } } cout << ans ; }
int countPairs ( int arr [ ] , int N ) { int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; } int ans = ( N - odd + odd / 2 - 1 ) + odd / 2 ; return ans ; }
int countBit ( int n ) { return int ( log2 ( n ) ) + 1 ; }
int countSetBit ( int n ) { int ans = 0 ; while ( n > 0 ) { ans += ( n & 1 ) ; n >>= 1 ; } return ans ; }
int maximize ( int n ) { int bits = countBit ( n ) ; int setBits = countSetBit ( n ) ; int ans = 0 ; for ( int i = 0 ; i < bits ; i ++ ) { if ( i < setBits ) ans |= 1 ; if ( i != setBits - 1 ) ans <<= 1 ; } return ans ; }
int minimize ( int n ) { int setBits = countSetBit ( n ) ; int ans = 0 ; for ( int i = 0 ; i < setBits ; i ++ ) { ans |= 1 ; if ( i != setBits - 1 ) ans <<= 1 ; } return ans ; }
int maxDiff ( vector < int > arr ) { int caseOne = 0 ; int SumOfOdd = 0 ; int SumOfeven = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( i % 2 ) SumOfOdd += minimize ( arr [ i ] ) ; else SumOfeven += maximize ( arr [ i ] ) ; } caseOne = abs ( SumOfOdd - SumOfeven ) ; int caseTwo = 0 ; SumOfOdd = 0 ; SumOfeven = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( i % 2 ) SumOfOdd += maximize ( arr [ i ] ) ; else SumOfeven += minimize ( arr [ i ] ) ; } caseTwo = abs ( SumOfOdd - SumOfeven ) ; return max ( caseOne , caseTwo ) ; }
bool isVowel ( char c ) { string vowel = "aeiou" ; for ( int i = 0 ; i < vowel . length ( ) ; ++ i ) if ( vowel [ i ] == c ) return true ; return false ; }
bool printRLE ( string str , string typed ) { int n = str . length ( ) , m = typed . length ( ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] != typed [ j ] ) return false ; if ( isVowel ( str [ i ] ) == false ) { j ++ ; continue ; } int count1 = 1 ; while ( i < n - 1 && str [ i ] == str [ i + 1 ] ) { count1 ++ ; i ++ ; } int count2 = 1 ; while ( j < m - 1 && typed [ j ] == str [ i ] ) { count2 ++ ; j ++ ; } if ( count1 > count2 ) return false ; } return true ; }
void findSplit ( int arr [ ] , int N ) { int l = 1 , r = N - 2 ; int lsum , msum , rsum ; vector < int > sum ( N ) ; sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { sum [ i ] = sum [ i - 1 ] + arr [ i ] ; } while ( l < r ) { lsum = sum [ l - 1 ] ; msum = sum [ r - 1 ] - sum [ l ] ; rsum = sum [ N - 1 ] - sum [ r ] ; if ( lsum == msum and msum == rsum ) { cout << l << " " << r << endl ; return ; } if ( lsum < rsum ) l ++ ; else if ( lsum > rsum ) r -- ; else { l ++ ; r -- ; } } cout << -1 << endl ; }
int solve ( int A [ ] , int n , int Q [ ] , int q ) { int one = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( A [ i ] == 1 ) one ++ ; int glows = 0 , count = 0 ; if ( one >= ceil ( n / 2 ) ) glows = 1 ; for ( int i = 0 ; i < q ; i ++ ) { int prev = glows ; if ( A [ Q [ i ] - 1 ] == 1 ) one -- ; if ( A [ Q [ i ] - 1 ] == 0 ) one ++ ; A [ Q [ i ] - 1 ] ^= 1 ; if ( one >= ceil ( n / 2.0 ) ) { glows = 1 ; } else { glows = 0 ; } if ( prev != glows ) count ++ ; } return count ; }
int elementsHavingDigitSumK ( int arr [ ] , int N , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; ++ i ) { if ( sumOfDigits ( arr [ i ] ) == K ) { count ++ ; } } cout << count ; }
int processDiagonal ( vector < int > arr ) { int ans = 0 ; int getBit = 1 ; for ( int i = 0 ; i < 32 ; i ++ ) { int S = 0 ; int NS = 0 ; for ( auto j : arr ) { if ( getBit & j ) S += 1 ; else NS += 1 ; } if ( S > NS ) ans += pow ( 2 , i ) ; getBit <<= 1 ; } return ans ; }
int findSum ( vector < vector < int > > mat ) { int i = 0 ; int j = 0 ; vector < int > priDiag ; while ( i < mat . size ( ) ) { priDiag . push_back ( mat [ i ] [ j ] ) ; i += 1 ; j += 1 ; } i = 0 ; j = mat . size ( ) - 1 ; vector < int > secDiag ; while ( i < mat . size ( ) ) { secDiag . push_back ( mat [ i ] [ j ] ) ; i += 1 ; j -= 1 ; } return processDiagonal ( priDiag ) + processDiagonal ( secDiag ) ; }
void minimumDifference ( int N ) { int sum1 = ( 1 << N ) , sum2 = 0 ; for ( int i = 1 ; i < N / 2 ; i ++ ) sum1 += ( 1 << i ) ; for ( int i = N / 2 ; i < N ; i ++ ) sum2 += ( 1 << i ) ; cout << sum1 - sum2 ; }
