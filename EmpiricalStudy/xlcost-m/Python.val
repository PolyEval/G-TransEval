def sumOfTwoPerfectCubes ( N ) : NEW_LINE INDENT cubes = { } NEW_LINE i = 1 NEW_LINE while i * i * i <= N : NEW_LINE INDENT cubes [ i * i * i ] = i NEW_LINE i += 1 NEW_LINE DEDENT for itr in cubes : NEW_LINE INDENT firstNumber = itr NEW_LINE secondNumber = N - itr NEW_LINE if secondNumber in cubes : NEW_LINE INDENT print ( "True" , end = "" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( "False" , end = "" ) NEW_LINE DEDENT
def SieveOfEratosthenes ( N ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , N + 1 ) : NEW_LINE INDENT if p * p > N : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , N + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def checksubarrayExist1_N ( arr , N ) : NEW_LINE INDENT pos = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT pos [ arr [ i ] ] = i NEW_LINE DEDENT st = { } NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT st [ pos [ i ] ] = 1 NEW_LINE Min = sorted ( list ( st . keys ( ) ) ) [ 0 ] NEW_LINE Max = sorted ( list ( st . keys ( ) ) ) [ - 1 ] NEW_LINE if ( Max - Min + 1 == i ) : NEW_LINE INDENT print ( "True" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "False" , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def reverseCircularArray ( arr , N , K ) : NEW_LINE INDENT start , end = K , K - 1 NEW_LINE count = N // 2 NEW_LINE while ( count ) : NEW_LINE INDENT temp = arr [ start % N ] NEW_LINE arr [ start % N ] = arr [ end % N ] NEW_LINE arr [ end % N ] = temp NEW_LINE start += 1 NEW_LINE end -= 1 NEW_LINE if ( end == - 1 ) : NEW_LINE INDENT end = N - 1 NEW_LINE DEDENT count -= 1 NEW_LINE DEDENT printArray ( arr , N ) NEW_LINE DEDENT
def XOR_for_every_i ( A , N ) : NEW_LINE INDENT frequency_of_bits = [ 0 ] * 32 NEW_LINE for i in range ( N ) : NEW_LINE INDENT bit_position = 0 NEW_LINE M = A [ i ] NEW_LINE while ( M ) : NEW_LINE INDENT if ( M & 1 != 0 ) : NEW_LINE INDENT frequency_of_bits [ bit_position ] += 1 NEW_LINE DEDENT bit_position += 1 NEW_LINE M >>= 1 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT M = A [ i ] NEW_LINE value_at_that_bit = 1 NEW_LINE XOR_sum = 0 NEW_LINE for bit_position in range ( 32 ) : NEW_LINE INDENT if ( M & 1 != 0 ) : NEW_LINE INDENT XOR_sum += ( ( N - frequency_of_bits [ bit_position ] ) * value_at_that_bit ) NEW_LINE DEDENT else : NEW_LINE INDENT XOR_sum += ( ( frequency_of_bits [ bit_position ] ) * value_at_that_bit ) NEW_LINE DEDENT M >>= 1 NEW_LINE value_at_that_bit <<= 1 NEW_LINE DEDENT print ( XOR_sum , end = " " ) NEW_LINE DEDENT return NEW_LINE DEDENT
def findSum ( a , b , N ) : NEW_LINE INDENT if N == 1 : NEW_LINE INDENT print ( a ) NEW_LINE return NEW_LINE DEDENT s = a + b NEW_LINE for i in range ( 0 , N - 2 ) : NEW_LINE INDENT x = a ^ b NEW_LINE s += x NEW_LINE a = b NEW_LINE b = x NEW_LINE DEDENT print ( s ) NEW_LINE return NEW_LINE DEDENT
def countNumbersUtil ( N ) : NEW_LINE INDENT count = 0 NEW_LINE digits = [ ] NEW_LINE while ( N ) : NEW_LINE INDENT digits . append ( N % 10 ) NEW_LINE N //= 10 NEW_LINE DEDENT digits . reverse ( ) NEW_LINE D = len ( digits ) NEW_LINE for i in range ( 1 , D + 1 , 1 ) : NEW_LINE INDENT res = getPower ( i ) NEW_LINE if ( i == D ) : NEW_LINE INDENT for p in range ( 1 , D + 1 , 1 ) : NEW_LINE INDENT x = digits [ p - 1 ] NEW_LINE tmp = 0 NEW_LINE if ( p % 2 == 0 ) : NEW_LINE INDENT tmp = ( ( 5 - ( x // 2 + 1 ) ) * getPower ( D - p ) ) NEW_LINE DEDENT else : NEW_LINE INDENT tmp = ( ( 5 - ( x + 1 ) // 2 ) * getPower ( D - p ) ) NEW_LINE DEDENT res -= tmp NEW_LINE if ( p % 2 != x % 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT count += res NEW_LINE DEDENT return count NEW_LINE DEDENT
def array_sum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def check ( n ) : NEW_LINE INDENT return ( 2 * rev ( n ) == n + 1 ) NEW_LINE DEDENT
def highestPower ( n ) : NEW_LINE INDENT return int ( ( math . log ( n ) // math . log ( 2 ) ) ) NEW_LINE DEDENT
def isPrimePossible ( N ) : NEW_LINE INDENT s = str ( N ) NEW_LINE l = len ( s ) NEW_LINE if ( l < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( l ) : NEW_LINE INDENT str1 = deleteIth ( s , i ) NEW_LINE num = int ( str1 ) NEW_LINE if ( isPrime ( num ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT sr = pow ( x , 1 / 2 ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def findlcm ( arr , n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ( ( arr [ i ] * ans ) // ( gcd ( arr [ i ] , ans ) ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findAandB ( n , k ) : NEW_LINE INDENT flag = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if str ( i ) . count ( chr ( k + 48 ) ) == 0 and str ( n - i ) . count ( chr ( k + 48 ) ) == 0 : NEW_LINE INDENT print ( i , n - i ) NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def SquareRoot ( num ) : NEW_LINE INDENT count = 0 NEW_LINE for n in range ( 1 , num + 1 , 2 ) : NEW_LINE INDENT num = num - n NEW_LINE count = count + 1 NEW_LINE if ( num == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def IncrementFactors ( count , val ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i * i <= val ) : NEW_LINE INDENT if ( val % i == 0 ) : NEW_LINE INDENT if ( i == val // i ) : NEW_LINE INDENT count [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] += 1 NEW_LINE count [ val // i ] += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def calcSum ( k , n ) : NEW_LINE INDENT value = ( k * n * ( n + 1 ) ) // 2 NEW_LINE return value NEW_LINE DEDENT
def storeDivisors ( n , div ) : NEW_LINE INDENT for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i == int ( n / i ) ) : NEW_LINE INDENT div . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT div . append ( i ) NEW_LINE div . append ( int ( n / i ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def sieveSundaram ( ) : NEW_LINE INDENT marked = [ False ] * ( ( MAX // 2 ) + 1 ) NEW_LINE for i in range ( 1 , ( ( int ( math . sqrt ( MAX ) ) - 1 ) // 2 ) + 1 ) : NEW_LINE INDENT j = ( i * ( i + 1 ) ) << 1 NEW_LINE while j <= ( MAX // 2 ) : NEW_LINE INDENT marked [ j ] = True NEW_LINE j = j + 2 * i + 1 NEW_LINE DEDENT DEDENT primes . append ( 2 ) NEW_LINE for i in range ( 1 , ( MAX // 2 ) + 1 ) : NEW_LINE INDENT if marked [ i ] == False : NEW_LINE INDENT primes . append ( 2 * i + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def firstDigit ( n ) : NEW_LINE INDENT digits = math . log10 ( n ) NEW_LINE n = ( n / math . pow ( 10 , digits ) ) NEW_LINE return n NEW_LINE DEDENT
def sumOfSumSeries ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 2 ) ) // 6 NEW_LINE DEDENT
def isTetradic ( n ) : NEW_LINE INDENT if ispalindrome ( n ) : NEW_LINE INDENT if isContaindigit ( n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( n ** 0.5 ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def getRow ( rowIndex ) : NEW_LINE INDENT currow = [ ] NEW_LINE currow . append ( 1 ) NEW_LINE if ( rowIndex == 0 ) : NEW_LINE INDENT return currow NEW_LINE DEDENT prev = getRow ( rowIndex - 1 ) NEW_LINE for i in range ( 1 , len ( prev ) ) : NEW_LINE INDENT curr = prev [ i - 1 ] + prev [ i ] NEW_LINE currow . append ( curr ) NEW_LINE DEDENT currow . append ( 1 ) NEW_LINE return currow NEW_LINE DEDENT
def gonNum360 ( n ) : NEW_LINE INDENT return ( 358 * n * n - 356 * n ) // 2 NEW_LINE DEDENT
def gonNum257 ( n ) : NEW_LINE INDENT return ( 255 * n * n - 253 * n ) // 2 NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT for x in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % x == 0 ) : NEW_LINE INDENT small = x NEW_LINE big = n // x NEW_LINE if ( small % 2 == big % 2 ) : NEW_LINE INDENT a = ( small + big ) // 2 NEW_LINE b = ( big - small ) // 2 NEW_LINE print ( a , b ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT
def Is_Practical ( A ) : NEW_LINE INDENT divisors = [ ] NEW_LINE divisors = get_divisors ( A ) NEW_LINE for i in range ( 2 , A ) : NEW_LINE INDENT if ( summ_Possible ( divisors , i ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def operation ( arr , N ) : NEW_LINE INDENT right = 0 NEW_LINE ans = 0 NEW_LINE num = 0 NEW_LINE for left in range ( 0 , N ) : NEW_LINE INDENT while ( right < N and num + arr [ right ] == ( num ^ arr [ right ] ) ) : NEW_LINE INDENT num += arr [ right ] NEW_LINE right += 1 NEW_LINE DEDENT ans += right - left NEW_LINE if ( left == right ) : NEW_LINE INDENT right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT num -= arr [ left ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT
def findMaxSize ( a , n ) : NEW_LINE INDENT frq = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT frq [ a [ i ] ] += 1 NEW_LINE DEDENT maxfrq = max ( frq ) NEW_LINE dist = n + 1 - frq . count ( 0 ) NEW_LINE ans1 = min ( maxfrq - 1 , dist ) NEW_LINE ans2 = min ( maxfrq , dist - 1 ) NEW_LINE ans = max ( ans1 , ans2 ) NEW_LINE return ans NEW_LINE DEDENT
def minCount ( n ) : NEW_LINE INDENT hasharr = [ 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 ] NEW_LINE if ( n > 69 ) : NEW_LINE INDENT return hasharr [ n % 10 ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( n >= hasharr [ n % 10 ] * 7 ) : NEW_LINE INDENT return hasharr [ n % 10 ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def findMaxSum ( A , B , n ) : NEW_LINE INDENT maxArr = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT X = joinNumbers ( A [ i ] , B [ i ] ) NEW_LINE Y = joinNumbers ( B [ i ] , A [ i ] ) NEW_LINE mx = max ( X , Y ) NEW_LINE maxArr [ i ] = mx NEW_LINE DEDENT maxAns = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxAns += maxArr [ i ] NEW_LINE DEDENT return maxAns NEW_LINE DEDENT
def SmallestPerfectSquare ( N ) : NEW_LINE INDENT X = 1e9 NEW_LINE for i in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if N % i == 0 : NEW_LINE INDENT a = i NEW_LINE b = N // i NEW_LINE if b - a != 0 and ( b - a ) % 2 == 0 : NEW_LINE INDENT X = min ( X , ( b - a ) // 2 ) NEW_LINE DEDENT DEDENT DEDENT return ( X * X if X != 1e9 else - 1 ) NEW_LINE DEDENT
def PrintReverseOrder ( N ) : NEW_LINE INDENT for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def dfs ( u , adj , vis ) : NEW_LINE INDENT vis [ u ] = 1 NEW_LINE componentSize = 1 NEW_LINE for x in adj [ u ] : NEW_LINE INDENT if ( vis [ x ] == 0 ) : NEW_LINE INDENT componentSize += dfs ( x , adj , vis ) NEW_LINE DEDENT DEDENT return componentSize NEW_LINE DEDENT
def prefix ( ) : NEW_LINE INDENT for i in range ( 1 , N , 1 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + phi [ i ] NEW_LINE DEDENT DEDENT
def findCo_PrimePaths ( root , path ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return path NEW_LINE DEDENT path . append ( root . key ) NEW_LINE path = findCo_PrimePaths ( root . left , path ) NEW_LINE path = findCo_PrimePaths ( root . right , path ) NEW_LINE if ( root . left == None and root . right == None ) : NEW_LINE INDENT if ( isPathCo_Prime ( path ) ) : NEW_LINE INDENT printCo_PrimePaths ( path ) NEW_LINE DEDENT DEDENT path . pop ( ) NEW_LINE return path NEW_LINE DEDENT
def sieve ( ) : NEW_LINE INDENT position [ 0 ] = - 1 NEW_LINE position [ 1 ] = - 1 NEW_LINE pos = 0 NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if ( position [ i ] == 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE position [ i ] = pos NEW_LINE for j in range ( i * 2 , limit + 1 , i ) : NEW_LINE INDENT position [ j ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def permutation ( arr , N ) : NEW_LINE INDENT hash = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( hash [ i ] != 1 ) : NEW_LINE INDENT return "No" NEW_LINE DEDENT DEDENT return "Yes" NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while n // 100 : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n = abs ( n + ( d * 13 ) ) NEW_LINE DEDENT return ( n % 43 == 0 ) NEW_LINE DEDENT
def countDigit ( n ) : NEW_LINE INDENT prime = [ False ] * 10 NEW_LINE prime [ 2 ] = True NEW_LINE prime [ 3 ] = True NEW_LINE prime [ 5 ] = True NEW_LINE prime [ 7 ] = True NEW_LINE temp = n NEW_LINE count = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 NEW_LINE temp //= 10 NEW_LINE if ( d > 0 and n % d == 0 and prime [ d ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def maxValue ( a ) : NEW_LINE INDENT a = bin ( a ) [ 2 : ] NEW_LINE b = '' NEW_LINE for i in list ( a ) : NEW_LINE INDENT b += str ( int ( not int ( i ) ) ) NEW_LINE DEDENT print ( int ( b , 2 ) ) NEW_LINE return int ( b , 2 ) NEW_LINE DEDENT
def nextFibonacci ( n ) : NEW_LINE INDENT a = n * ( 1 + sqrt ( 5 ) ) / 2.0 NEW_LINE return round ( a ) NEW_LINE DEDENT
def preCompute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + checkArmstrong ( i ) NEW_LINE DEDENT DEDENT
def isPrime ( N ) : NEW_LINE INDENT isPrime = True NEW_LINE arr = [ 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 ] NEW_LINE if ( N < 2 ) : NEW_LINE INDENT isPrime = False NEW_LINE DEDENT if ( N % 2 == 0 or N % 3 == 0 or N % 5 == 0 ) : NEW_LINE INDENT isPrime = False NEW_LINE DEDENT for i in range ( 0 , int ( math . sqrt ( N ) ) , 30 ) : NEW_LINE INDENT for c in arr : NEW_LINE INDENT if ( c > int ( math . sqrt ( N ) ) ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT if ( N % ( c + i ) == 0 ) : NEW_LINE INDENT isPrime = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( not isPrime ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if ( isPrime ) : NEW_LINE INDENT print ( "Prime Number" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Not a Prime Number" ) NEW_LINE DEDENT DEDENT
def perfectCube ( N ) : NEW_LINE INDENT cube = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT cube = i * i * i NEW_LINE if ( cube == N ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE return NEW_LINE DEDENT elif ( cube > N ) : NEW_LINE INDENT print ( "NO" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def count ( n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT sum = sum + binomialCoeff ( n , j ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def prevPowerofK ( n , k ) : NEW_LINE INDENT p = int ( math . log ( n ) / math . log ( k ) ) NEW_LINE return int ( math . pow ( k , p ) ) NEW_LINE DEDENT
def kth_element ( a , n , k ) : NEW_LINE INDENT pos , neg = [ ] , [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT pos . append ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT neg . append ( a [ i ] ) NEW_LINE DEDENT DEDENT pos = sorted ( pos ) NEW_LINE neg = sorted ( neg ) NEW_LINE l = - 10 ** 18 NEW_LINE ans = 0 NEW_LINE r = 10 ** 18 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) >> 1 NEW_LINE if ( check ( mid , pos , neg , k ) ) : NEW_LINE INDENT ans = mid NEW_LINE r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def nextNumberDistinctDigit ( n ) : NEW_LINE INDENT while ( n < INT_MAX ) : NEW_LINE INDENT distinct_digits = countDistinct ( n + 1 ) NEW_LINE total_digits = countDigit ( n + 1 ) NEW_LINE if ( distinct_digits == total_digits ) : NEW_LINE INDENT return n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT n += 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def Count_subarray ( arr , n ) : NEW_LINE INDENT total_sum = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT total_sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT subarray_sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT subarray_sum += arr [ j ] NEW_LINE remaining_sum = total_sum - subarray_sum NEW_LINE if ( subarray_sum > remaining_sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT sum = 45.0 NEW_LINE DEDENT else : NEW_LINE INDENT sum = ( 99.0 / 2.0 ) * pow ( 10 , n - 1 ) * pow ( 10 , ( n - 1 ) / 2 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def getSize ( a ) : NEW_LINE INDENT sz = 0 NEW_LINE while ( a != None ) : NEW_LINE INDENT a = a . next NEW_LINE sz += 1 NEW_LINE DEDENT return sz NEW_LINE DEDENT
def diameter ( n ) : NEW_LINE INDENT L , H , templen = 0 , 0 , 0 NEW_LINE L = 1 NEW_LINE H = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT while ( L * 2 <= n ) : NEW_LINE INDENT L *= 2 NEW_LINE H += 1 NEW_LINE DEDENT if ( n >= L * 2 - 1 ) : NEW_LINE INDENT return 2 * H + 1 NEW_LINE DEDENT elif ( n >= L + ( L / 2 ) - 1 ) : NEW_LINE INDENT return 2 * H NEW_LINE DEDENT return 2 * H - 1 NEW_LINE DEDENT
def countSquares ( n ) : NEW_LINE INDENT return ( pow ( n , 2 ) - ( 2 * n ) + 2 ) NEW_LINE DEDENT
def max_element ( a , n ) : NEW_LINE INDENT pre = [ 0 ] * n NEW_LINE pre [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = max ( pre [ i - 1 ] , a [ i ] ) NEW_LINE DEDENT suf = [ 0 ] * n NEW_LINE suf [ n - 1 ] = a [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suf [ i ] = max ( suf [ i + 1 ] , a [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT print ( suf [ i + 1 ] , end = " " ) NEW_LINE DEDENT elif ( i == n - 1 ) : NEW_LINE INDENT print ( pre [ i - 1 ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( pre [ i - 1 ] , suf [ i + 1 ] ) , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def cntCells ( n ) : NEW_LINE INDENT cells = pow ( n , 2 ) + pow ( n - 1 , 2 ) NEW_LINE return cells NEW_LINE DEDENT
def findNums ( n ) : NEW_LINE INDENT if ( n <= 11 ) : NEW_LINE INDENT if ( n == 8 ) : NEW_LINE INDENT print ( "4 4" , end = " " ) NEW_LINE DEDENT if ( n == 10 ) : NEW_LINE INDENT print ( "4 6" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "-1" , end = " " ) NEW_LINE DEDENT DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( "4 " , ( n - 4 ) , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "9 " , n - 9 , end = " " ) NEW_LINE DEDENT DEDENT
def oddFib ( n ) : NEW_LINE INDENT n = ( 3 * n + 1 ) // 2 NEW_LINE a = - 1 NEW_LINE b = 1 NEW_LINE c = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return c NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 2 or n == 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def difference ( n ) : NEW_LINE INDENT S = ( n * ( n + 1 ) ) // 2 NEW_LINE res = S * ( S - 1 ) NEW_LINE return res NEW_LINE DEDENT
def findSmallestNonZeroY ( A_num ) : NEW_LINE INDENT A_binary = bin ( A_num ) NEW_LINE B = 1 NEW_LINE length = len ( A_binary ) NEW_LINE no_ones = ( A_binary ) . count ( '1' ) NEW_LINE if length == no_ones : NEW_LINE INDENT return A_num + 1 NEW_LINE DEDENT for i in range ( length ) : NEW_LINE INDENT ch = A_binary [ length - i - 1 ] NEW_LINE if ( ch == '0' ) : NEW_LINE INDENT B = pow ( 2.0 , i ) NEW_LINE break NEW_LINE DEDENT DEDENT return B NEW_LINE DEDENT
def minimum_elements ( n , arr ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 0 NEW_LINE diff = arr [ 1 ] - arr [ 0 ] NEW_LINE g = diff NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT diff = arr [ i ] - arr [ i - 1 ] NEW_LINE g = gcd ( g , diff ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT diff = arr [ i ] - arr [ i - 1 ] NEW_LINE cnt = diff // g NEW_LINE ans += ( cnt - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def Digits ( n ) : NEW_LINE INDENT largest = 0 NEW_LINE smallest = 9 NEW_LINE while ( n ) : NEW_LINE INDENT r = n % 10 NEW_LINE largest = max ( r , largest ) NEW_LINE smallest = min ( r , smallest ) NEW_LINE n = n // 10 NEW_LINE DEDENT print ( largest , smallest ) NEW_LINE DEDENT
def countWords ( N , M ) : NEW_LINE INDENT return pow ( N , M ) - nPr ( N , M ) NEW_LINE DEDENT
def countBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def sum_of_4_squares ( n ) : NEW_LINE INDENT i , odd , even = 0 , 0 , 0 NEW_LINE for i in range ( 1 , int ( n ** ( .5 ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT even += i NEW_LINE DEDENT else : NEW_LINE INDENT odd += i NEW_LINE DEDENT if ( ( n // i ) != i ) : NEW_LINE INDENT if ( ( n // i ) % 2 == 0 ) : NEW_LINE INDENT even += ( n // i ) NEW_LINE DEDENT else : NEW_LINE INDENT odd += ( n // i ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 8 * ( odd + even ) NEW_LINE DEDENT else : NEW_LINE INDENT return 24 * ( odd ) NEW_LINE DEDENT DEDENT
def Maximum_Length ( a ) : NEW_LINE INDENT counts = [ 0 ] * 11 NEW_LINE for index , v in enumerate ( a ) : NEW_LINE INDENT counts [ v ] += 1 NEW_LINE k = sorted ( [ i for i in counts if i ] ) NEW_LINE if len ( k ) == 1 or ( k [ 0 ] == k [ - 2 ] and k [ - 1 ] - k [ - 2 ] == 1 ) or ( k [ 0 ] == 1 and k [ 1 ] == k [ - 1 ] ) : NEW_LINE INDENT ans = index NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT
def numberOfDays ( a , b , n ) : NEW_LINE INDENT Days = b * ( n + a ) // ( a + b ) NEW_LINE return Days NEW_LINE DEDENT
def countX ( a , b ) : NEW_LINE INDENT if ( b > a ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = a - b NEW_LINE ans = 0 NEW_LINE i = 1 NEW_LINE while i * i <= x : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT d1 = i NEW_LINE d2 = b - 1 NEW_LINE if ( i * i != x ) : NEW_LINE INDENT d2 = x // i NEW_LINE DEDENT if ( d1 > b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if ( d2 > b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
def isSafe ( N , M , str ) : NEW_LINE INDENT coll = 0 NEW_LINE colr = 0 NEW_LINE rowu = 0 NEW_LINE rowd = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == 'L' ) : NEW_LINE INDENT coll += 1 NEW_LINE if ( colr > 0 ) : NEW_LINE INDENT colr -= 1 NEW_LINE DEDENT if ( coll == M ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT elif ( str [ i ] == 'R' ) : NEW_LINE INDENT colr += 1 NEW_LINE if ( coll > 0 ) : NEW_LINE INDENT coll -= 1 NEW_LINE DEDENT if ( colr == M ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT elif ( str [ i ] == 'U' ) : NEW_LINE INDENT rowu += 1 NEW_LINE if ( rowd > 0 ) : NEW_LINE INDENT rowd -= 1 NEW_LINE DEDENT if ( rowu == N ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT elif ( str [ i ] == 'D' ) : NEW_LINE INDENT rowd += 1 NEW_LINE if ( rowu > 0 ) : NEW_LINE INDENT rowu -= 1 NEW_LINE DEDENT if ( rowd == N ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if ( abs ( rowd ) < N and abs ( rowu ) < N and abs ( coll ) < M and abs ( colr ) < M ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def countOnes ( arr , N ) : NEW_LINE INDENT for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT for j in range ( i , N + 1 , 1 ) : NEW_LINE INDENT if ( j % i == 0 ) : NEW_LINE INDENT if ( arr [ j - 1 ] == 0 ) : else : NEW_LINE INDENT  DEDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT return count NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT
def findSum ( num ) : NEW_LINE INDENT sumo = 0 NEW_LINE sume = 0 NEW_LINE x = 1 NEW_LINE cur = 0 NEW_LINE ans = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT inc = min ( x , num ) NEW_LINE num -= inc NEW_LINE if ( cur == 0 ) : NEW_LINE INDENT ans = ans + sumodd ( sumo + inc ) - sumodd ( sumo ) NEW_LINE sumo += inc NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + sumeven ( sume + inc ) - sumeven ( sume ) NEW_LINE sume += inc NEW_LINE DEDENT x *= 2 NEW_LINE cur ^= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def noOfYears ( t1 , n1 , t2 ) : NEW_LINE INDENT years = ( t2 - 1 ) * n1 / ( t1 - 1 ) NEW_LINE return years NEW_LINE DEDENT
def isPossible ( n ) : NEW_LINE INDENT fac = [ 0 for i in range ( 10 ) ] NEW_LINE fac [ 0 ] = 1 NEW_LINE fac [ 1 ] = 1 NEW_LINE for i in range ( 2 , 10 , 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i NEW_LINE DEDENT sum = 0 NEW_LINE x = n NEW_LINE while ( x ) : NEW_LINE INDENT sum += fac [ x % 10 ] NEW_LINE x = int ( x / 10 ) NEW_LINE DEDENT if ( sum % n == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def countSquares ( r , c , m ) : NEW_LINE INDENT squares = 0 NEW_LINE for i in range ( 1 , 9 ) : NEW_LINE INDENT for j in range ( 1 , 9 ) : NEW_LINE INDENT if ( max ( abs ( i - r ) , abs ( j - c ) ) <= m ) : NEW_LINE INDENT squares = squares + 1 NEW_LINE DEDENT DEDENT DEDENT return squares NEW_LINE DEDENT
def minOperations ( n , m ) : NEW_LINE INDENT if ( m % n != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT minOperations = 0 NEW_LINE q = int ( m / n ) NEW_LINE while ( q % 2 == 0 ) : NEW_LINE INDENT q = int ( q / 2 ) NEW_LINE minOperations += 1 NEW_LINE DEDENT while ( q % 3 == 0 ) : NEW_LINE INDENT q = int ( q / 3 ) NEW_LINE minOperations += 1 NEW_LINE DEDENT if ( q == 1 ) : NEW_LINE INDENT return minOperations NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def getCount ( a , b , c ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , 82 ) : NEW_LINE INDENT cr = b * pow ( i , a ) + c NEW_LINE tmp = cr NEW_LINE sm = 0 NEW_LINE while ( tmp ) : NEW_LINE INDENT sm += tmp % 10 NEW_LINE tmp //= 10 NEW_LINE DEDENT if ( sm == i and cr < 10 ** 9 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def checkSpecialPrime ( sieve , num ) : NEW_LINE INDENT while ( num ) : NEW_LINE INDENT if ( sieve [ num ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT num = int ( num / 10 ) NEW_LINE DEDENT return True NEW_LINE DEDENT
def canTakeDown ( bishopX , bishopY , pawnX , pawnY ) : NEW_LINE INDENT if ( pawnX - bishopX == pawnY - bishopY ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( - pawnX + bishopX == pawnY - bishopY ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def isPossible ( n , k , arr ) : NEW_LINE INDENT sum = arr [ 0 ] NEW_LINE maxVal = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE maxVal = max ( maxVal , arr [ i ] ) NEW_LINE DEDENT if ( int ( maxVal ) > int ( ( sum + k ) / n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def checkTriangularSumRepresentation ( n ) : NEW_LINE INDENT tri = list ( ) NEW_LINE i = 1 NEW_LINE while ( 1 ) : NEW_LINE INDENT x = i * ( i + 1 ) // 2 NEW_LINE if ( x >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT tri . append ( x ) NEW_LINE i += 1 NEW_LINE DEDENT for tm in tri : NEW_LINE INDENT if n - tm in tri : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def secondary_polygon ( Angle ) : NEW_LINE INDENT edges_primary = 360 // Angle NEW_LINE if edges_primary >= 6 : NEW_LINE INDENT edges_max_secondary = edges_primary // 2 NEW_LINE return edges_max_secondary + 3 NEW_LINE DEDENT else : NEW_LINE INDENT return "Not Possible" NEW_LINE DEDENT DEDENT
def CPwithProfit ( sellingPrice , profit ) : NEW_LINE INDENT costPrice = ( ( sellingPrice * 100.0 ) / ( 100 + profit ) ) NEW_LINE return costPrice NEW_LINE DEDENT
def removeZero ( n ) : NEW_LINE INDENT res = 0 NEW_LINE d = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 != 0 ) : NEW_LINE INDENT res += ( n % 10 ) * d NEW_LINE d *= 10 NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT k = int ( sqrt ( n ) ) + 1 NEW_LINE for i in range ( 5 , k , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def ETF ( ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( phi [ i ] == i ) : NEW_LINE INDENT phi [ i ] = i - 1 NEW_LINE for j in range ( 2 * i , n + 1 , i ) : NEW_LINE INDENT phi [ j ] = ( phi [ j ] * ( i - 1 ) ) // i NEW_LINE DEDENT DEDENT DEDENT DEDENT
def checkIsHP ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT rec = [ ] NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT a = 1 / arr [ i ] NEW_LINE rec . append ( a ) NEW_LINE DEDENT return ( rec ) NEW_LINE rec . sort ( ) NEW_LINE d = rec [ 1 ] - rec [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( rec [ i ] - rec [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def Valid ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c == 180 ) and a != 0 and b != 0 and c != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def solve ( n , base ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT remainder = n % base NEW_LINE sum = sum + remainder NEW_LINE n = int ( n / base ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , mt . ceil ( mt . sqrt ( p_size + 1 ) ) ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT
def findEle ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == sum - arr [ i ] : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def divisibleBy3 ( number ) : NEW_LINE INDENT sumOfDigit = 0 NEW_LINE for i in range ( 0 , len ( number ) , 1 ) : NEW_LINE INDENT sumOfDigit += ord ( number [ i ] ) - ord ( '0' ) NEW_LINE DEDENT if ( sumOfDigit % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def largestNumber ( n ) : NEW_LINE INDENT s = "" NEW_LINE duplicate = n NEW_LINE while ( n ) : NEW_LINE INDENT s = chr ( n % 10 + 48 ) + s NEW_LINE n //= 10 NEW_LINE DEDENT index = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ( ( ord ( s [ i ] ) - ord ( '0' ) ) % 2 & 1 ) == 0 ) : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( index == - 1 ) : NEW_LINE INDENT return duplicate NEW_LINE DEDENT num = 0 NEW_LINE for i in range ( index ) : NEW_LINE INDENT num = num * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT num = num * 10 + ( ord ( s [ index ] ) - ord ( '0' ) - 1 ) NEW_LINE for i in range ( index + 1 , len ( s ) ) : NEW_LINE INDENT num = num * 10 + 9 NEW_LINE DEDENT return num NEW_LINE DEDENT
def Sum_upto_nth_Term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( 2 * n + 7 ) // 3 NEW_LINE DEDENT
def get_unit_digit ( N ) : NEW_LINE INDENT if ( N == 0 or N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( N == 2 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT elif ( N == 3 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE INDENT return 3 NEW_LINE DEDENT DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * ( MAX ) NEW_LINE prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for p in range ( 2 , 100 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT product = 1 NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT product = product * p NEW_LINE s . add ( product + 1 ) NEW_LINE DEDENT DEDENT DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= MAX ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE i = i + p NEW_LINE DEDENT DEDENT DEDENT DEDENT
def findF_N ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = ans + ( i + 1 ) * ( n - i - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def PrimeFactors ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE x = n NEW_LINE i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE while ( x % i == 0 ) : NEW_LINE INDENT x //= i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( x > 1 ) : NEW_LINE INDENT v . append ( x ) NEW_LINE DEDENT return v NEW_LINE DEDENT
def computeSemiPrime ( ) : NEW_LINE INDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT cnt , num , j = 0 , i , 2 NEW_LINE while cnt < 2 and j * j <= num : NEW_LINE INDENT while num % j == 0 : NEW_LINE INDENT num /= j NEW_LINE cnt += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if num > 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if cnt == 2 : NEW_LINE INDENT sprime [ i ] = True NEW_LINE arr . append ( i ) NEW_LINE DEDENT DEDENT DEDENT
def sumProductDifference ( a , b , c , d , e ) : NEW_LINE INDENT rootSum = ( - 1 * b ) / a NEW_LINE rootProduct = e / a NEW_LINE return abs ( rootSum - rootProduct ) NEW_LINE DEDENT
def findAnglesA ( a , b , c ) : NEW_LINE INDENT A = math . acos ( ( b * b + c * c - a * a ) / ( 2 * b * c ) ) NEW_LINE return A * 180 / PI NEW_LINE DEDENT
def findAnglesB ( a , b , c ) : NEW_LINE INDENT B = math . acos ( ( a * a + c * c - b * b ) / ( 2 * a * c ) ) NEW_LINE return B * 180 / PI NEW_LINE DEDENT
def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT
def findSum ( N ) : NEW_LINE INDENT return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 NEW_LINE DEDENT
def isPower ( a ) : NEW_LINE INDENT if a == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( a ) ) + 1 ) : NEW_LINE INDENT val = log ( a ) / log ( i ) NEW_LINE if ( round ( ( val - int ( val ) ) , 8 ) < 0.00000001 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def mostFrequent ( arr , n ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in Hash . keys ( ) : NEW_LINE INDENT Hash [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Hash [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT max_count = 0 NEW_LINE res = - 1 NEW_LINE for i in Hash : NEW_LINE INDENT if ( max_count < Hash [ i ] ) : NEW_LINE INDENT res = i NEW_LINE max_count = Hash [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def Profit ( costPrice , sellingPrice ) : NEW_LINE INDENT profit = ( sellingPrice - costPrice ) NEW_LINE return profit NEW_LINE DEDENT
def check ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT if sum % 7 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def isPrime ( num ) : NEW_LINE INDENT if ( num < 2 or num % 2 == 0 ) : NEW_LINE INDENT return num == 2 NEW_LINE DEDENT for i in range ( 3 , mt . ceil ( mt . sqrt ( num + 1 ) ) ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def value ( a , b , c ) : NEW_LINE INDENT x = 0 NEW_LINE q = 0 NEW_LINE w = 0 NEW_LINE v = [ ] NEW_LINE for i in range ( 1 , 82 ) : NEW_LINE INDENT no = pow ( i , a ) NEW_LINE no = b * no + c NEW_LINE if ( no > 0 and no < 1000000000 ) : NEW_LINE INDENT x = getsum ( no ) NEW_LINE if ( x == i ) : NEW_LINE INDENT q += 1 NEW_LINE v . append ( no ) NEW_LINE w += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( len ( v ) ) : NEW_LINE INDENT print ( v [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def countOddSum ( ar , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT val = val + ar [ j ] NEW_LINE if ( val % 2 != 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return ( result ) NEW_LINE DEDENT
def printSeries ( n ) : NEW_LINE INDENT prev = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT curr = findTriangularNumber ( i ) NEW_LINE curr = int ( curr + prev ) NEW_LINE print ( curr , end = ' ' ) NEW_LINE prev = curr NEW_LINE DEDENT DEDENT
def rev ( n , temp ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return temp NEW_LINE DEDENT temp = ( temp * 10 ) + ( n % 10 ) NEW_LINE return rev ( n / 10 , temp ) NEW_LINE DEDENT
def determinantOfMatrix ( mat ) : NEW_LINE INDENT ans = ( mat [ 0 ] [ 0 ] * ( mat [ 1 ] [ 1 ] * mat [ 2 ] [ 2 ] - mat [ 2 ] [ 1 ] * mat [ 1 ] [ 2 ] ) - mat [ 0 ] [ 1 ] * ( mat [ 1 ] [ 0 ] * mat [ 2 ] [ 2 ] - mat [ 1 ] [ 2 ] * mat [ 2 ] [ 0 ] ) + mat [ 0 ] [ 2 ] * ( mat [ 1 ] [ 0 ] * mat [ 2 ] [ 1 ] - mat [ 1 ] [ 1 ] * mat [ 2 ] [ 0 ] ) ) NEW_LINE return ans NEW_LINE DEDENT
def calculateSeries ( n ) : NEW_LINE INDENT return ( 2 + ( n * n + n - 2 ) * math . factorial ( n + 1 ) ) NEW_LINE DEDENT
def isEmirpimes ( n ) : NEW_LINE INDENT if ( checkSemiprime ( n ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT r = 0 NEW_LINE t = n NEW_LINE while ( t != 0 ) : NEW_LINE INDENT r = r * 10 + t % 10 NEW_LINE t = t / n NEW_LINE DEDENT if ( r == n ) : NEW_LINE INDENT return false NEW_LINE DEDENT return ( checkSemiprime ( r ) ) NEW_LINE DEDENT
def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT c = ( - 2 * num ) NEW_LINE b = 1 NEW_LINE a = 1 NEW_LINE d = ( b * b ) - ( 4 * a * c ) NEW_LINE if ( d < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT root1 = ( - b + math . sqrt ( d ) ) // ( 2 * a ) NEW_LINE root2 = ( - b - math . sqrt ( d ) ) // ( 2 * a ) NEW_LINE if ( root1 > 0 and math . floor ( root1 ) == root1 ) : NEW_LINE INDENT return root1 NEW_LINE DEDENT if ( root2 > 0 and math . floor ( root2 ) == root2 ) : NEW_LINE INDENT return root2 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def calculateProbability ( N ) : NEW_LINE INDENT probability = N / ( N + 1 ) NEW_LINE return probability NEW_LINE DEDENT
def fnMod ( n ) : NEW_LINE INDENT if ( n % 5 == 1 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def findHcf ( arr , size ) : NEW_LINE INDENT ans = arr [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , size , 1 ) : NEW_LINE INDENT ans = gcd ( ans , arr [ i ] [ 0 ] ) NEW_LINE DEDENT return ( ans ) NEW_LINE DEDENT
def nthTrimorphic ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( sys . maxsize ) : NEW_LINE INDENT if ( checkTrimorphic ( i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT
def check ( n ) : NEW_LINE INDENT m = n NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 10 NEW_LINE if ( r > 0 ) : NEW_LINE INDENT if ( ( m % r ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = n // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT sum = sum + i * ( i + 1 ) * ( i + 2 ) NEW_LINE i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def generatePrimeFactors ( ) : NEW_LINE INDENT factor [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT factor [ i ] = i NEW_LINE DEDENT i = 4 NEW_LINE while ( i < MAX ) : NEW_LINE INDENT factor [ i ] = 2 NEW_LINE i += 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( i * i < MAX ) : NEW_LINE INDENT if ( factor [ i ] == i ) : NEW_LINE INDENT j = i * i NEW_LINE while ( j < MAX ) : NEW_LINE INDENT if ( factor [ j ] == j ) : NEW_LINE INDENT factor [ j ] = i NEW_LINE DEDENT j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT
def quadrant ( x , y ) : NEW_LINE INDENT if ( x > 0 and y > 0 ) : NEW_LINE INDENT print ( "lies in First quadrant" ) NEW_LINE DEDENT elif ( x < 0 and y > 0 ) : NEW_LINE INDENT print ( "lies in Second quadrant" ) NEW_LINE DEDENT elif ( x < 0 and y < 0 ) : NEW_LINE INDENT print ( "lies in Third quadrant" ) NEW_LINE DEDENT elif ( x > 0 and y < 0 ) : NEW_LINE INDENT print ( "lies in Fourth quadrant" ) NEW_LINE DEDENT elif ( x == 0 and y > 0 ) : NEW_LINE INDENT print ( "lies at positive y axis" ) NEW_LINE DEDENT elif ( x == 0 and y < 0 ) : NEW_LINE INDENT print ( "lies at negative y axis" ) NEW_LINE DEDENT elif ( y == 0 and x < 0 ) : NEW_LINE INDENT print ( "lies at negative x axis" ) NEW_LINE DEDENT elif ( y == 0 and x > 0 ) : NEW_LINE INDENT print ( "lies at positive x axis" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "lies at origin" ) NEW_LINE DEDENT DEDENT
def kthgroupsum ( k ) : NEW_LINE INDENT return k * k * k NEW_LINE DEDENT
def kmphTOmph ( kmph ) : NEW_LINE INDENT mph = 0.6214 * kmph NEW_LINE return mph NEW_LINE DEDENT
def point ( a , b , c , d , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT x = b + i * a NEW_LINE if ( x - d ) % c == 0 and x - d >= 0 : NEW_LINE INDENT print x NEW_LINE return NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print "No collision point" NEW_LINE DEDENT DEDENT
def fact ( n ) : NEW_LINE INDENT f = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f *= i NEW_LINE DEDENT return f NEW_LINE DEDENT
def isPalindrome ( n ) : NEW_LINE INDENT divide = 8 if ( isOctal ( n ) == False ) else 10 NEW_LINE octal = [ ] NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octal . append ( n % divide ) NEW_LINE n = int ( n / divide ) NEW_LINE DEDENT j = len ( octal ) - 1 NEW_LINE k = 0 NEW_LINE while ( k <= j ) : NEW_LINE INDENT if ( octal [ j ] != octal [ k ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT j -= 1 NEW_LINE k += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def isThreeDisctFactors ( n ) : NEW_LINE INDENT sq = int ( sqrt ( n ) ) NEW_LINE if ( 1 * sq * sq != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( isPrime ( sq ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def decToHexa ( n ) : NEW_LINE INDENT hexaDeciNum = [ '0' ] * 100 NEW_LINE i = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT temp = 0 NEW_LINE temp = n % 16 NEW_LINE if ( temp < 10 ) : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 48 ) NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 55 ) NEW_LINE i = i + 1 NEW_LINE DEDENT n = int ( n / 16 ) NEW_LINE DEDENT j = i - 1 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT print ( ( hexaDeciNum [ j ] ) , end = "" ) NEW_LINE j = j - 1 NEW_LINE DEDENT DEDENT
def binaryToDecimal ( n ) : NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE temp = num NEW_LINE while ( temp ) : NEW_LINE INDENT last_digit = temp % 10 NEW_LINE temp = int ( temp / 10 ) NEW_LINE dec_value += last_digit * base NEW_LINE base = base * 2 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT
def closestMultiple ( n , x ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return x NEW_LINE DEDENT z = ( int ) ( x / 2 ) NEW_LINE n = n + z NEW_LINE n = n - ( n % x ) NEW_LINE return n NEW_LINE DEDENT
def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product *= n NEW_LINE DEDENT while ( ( product // pow ( 10 , k ) ) != 0 ) : NEW_LINE INDENT product = product // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT
def countDigits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = n // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
def printGenerators ( n ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( gcd ( i , n ) == 1 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def SubArraySum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def generateNumbers ( factor , n , k ) : NEW_LINE INDENT next = [ 0 ] * k NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT toincrement = 0 NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( next [ j ] < next [ toincrement ] ) : NEW_LINE INDENT toincrement = j NEW_LINE DEDENT DEDENT if ( output != next [ toincrement ] ) : NEW_LINE INDENT output = next [ toincrement ] NEW_LINE print ( next [ toincrement ] , end = " " ) NEW_LINE i += 1 NEW_LINE DEDENT next [ toincrement ] += factor [ toincrement ] NEW_LINE DEDENT DEDENT
def sumofproduct ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT y = int ( n / x ) NEW_LINE ans += ( y * x ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findPrimePair ( n ) : NEW_LINE INDENT isPrime = [ 0 ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( isPrime [ i ] and isPrime [ n - i ] ) : NEW_LINE INDENT print ( i , ( n - i ) ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT
def lcm ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = int ( ( ans * i ) / math . gcd ( ans , i ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findSmallestPrimeFactors ( ) : NEW_LINE INDENT for i in range ( maxn ) : NEW_LINE INDENT smallest_prime [ i ] = INF NEW_LINE DEDENT for i in range ( 2 , maxn ) : NEW_LINE INDENT if ( smallest_prime [ i ] == INF ) : NEW_LINE INDENT smallest_prime [ i ] = i NEW_LINE for j in range ( i * i , maxn , i ) : NEW_LINE INDENT  DEDENT if ( smallest_prime [ j ] > i ) : NEW_LINE INDENT smallest_prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT
def prepareSum ( s ) : NEW_LINE INDENT sum [ 0 ] = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT sum [ i + 1 ] = sum [ i ] + toInt ( s [ i ] ) NEW_LINE DEDENT DEDENT
def oneDigit ( num ) : NEW_LINE INDENT return ( num >= 0 and num < 10 ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT
def updateBIT ( BITree , n , index , val ) : NEW_LINE INDENT while ( index <= n ) : NEW_LINE INDENT BITree [ index ] += val NEW_LINE DEDENT index += index & ( - index ) NEW_LINE DEDENT
def nearestSmallerEqFib ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT f1 , f2 , f3 = 0 , 1 , 1 NEW_LINE while ( f3 <= n ) : NEW_LINE INDENT f1 = f2 NEW_LINE f2 = f3 NEW_LINE f3 = f1 + f2 NEW_LINE DEDENT return f2 NEW_LINE DEDENT
def mod ( num , a ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT res = ( res * 10 + int ( num [ i ] ) ) % a NEW_LINE DEDENT return res NEW_LINE DEDENT
def replace0with5 ( number ) : NEW_LINE INDENT number += calculateAddedValue ( number ) NEW_LINE return number NEW_LINE DEDENT
def findXOR ( X ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( X ) : NEW_LINE INDENT ans ^= ( X % 10 ) NEW_LINE X //= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findLen ( arr , n , m ) : NEW_LINE INDENT filter = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] m ) == m ) : NEW_LINE INDENT filter . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT if ( len ( filter ) == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT c_or = filter [ 0 ] NEW_LINE for i in range ( 1 , len ( filter ) ) : NEW_LINE INDENT c_or |= filter [ i ] NEW_LINE DEDENT if ( c_or == m ) : NEW_LINE INDENT return len ( filter ) NEW_LINE DEDENT DEDENT
def Add_Edge ( x , y ) : NEW_LINE INDENT al [ x ] . append ( y ) NEW_LINE root_node [ y ] = False NEW_LINE DEDENT
def multiplyByFifteen ( n ) : NEW_LINE INDENT prod = ( n << 4 ) NEW_LINE prod = prod - n NEW_LINE return prod NEW_LINE DEDENT
def ternary ( number ) : NEW_LINE INDENT ans , rem , base = 0 , 1 , 1 NEW_LINE while number > 0 : NEW_LINE INDENT rem = number % 3 NEW_LINE ans = ans + rem * base NEW_LINE number //= 3 NEW_LINE base = base * 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def ReplaceElements ( arr , n ) : NEW_LINE INDENT X = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT X ^= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = X ^ arr [ i ] NEW_LINE DEDENT DEDENT
def findSubArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE maxsize = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT sum = - 1 if ( arr [ i ] == 0 ) else 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1 NEW_LINE if ( sum == 0 and maxsize < j - i + 1 ) : NEW_LINE INDENT maxsize = j - i + 1 NEW_LINE startindex = i NEW_LINE DEDENT DEDENT DEDENT if ( maxsize == - 1 ) : NEW_LINE INDENT print ( "No such subarray" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( startindex , "to" , startindex + maxsize - 1 ) NEW_LINE DEDENT return maxsize NEW_LINE DEDENT
def BinaryLifting ( presum , n , x ) : NEW_LINE INDENT pos = 0 NEW_LINE LOGN = int ( math . log2 ( n ) ) NEW_LINE if ( x <= presum [ 0 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( LOGN , - 1 , - 1 ) : NEW_LINE INDENT if ( pos + ( 1 << i ) < n and presum [ pos + ( 1 << i ) ] < x ) : NEW_LINE INDENT pos += ( 1 << i ) NEW_LINE DEDENT DEDENT return pos + 1 NEW_LINE DEDENT
def setbitsfromLtoR ( L , R ) : NEW_LINE INDENT return ( ( 1 << ( R + 1 ) ) - ( 1 << L ) ) NEW_LINE DEDENT
def isFibbinaryNum ( n ) : NEW_LINE INDENT if ( ( n & ( n >> 1 ) ) == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def oddbitsetnumber ( n ) : NEW_LINE INDENT count = 0 NEW_LINE res = 0 NEW_LINE temp = n NEW_LINE while temp > 0 : NEW_LINE INDENT if count % 2 == 0 : NEW_LINE INDENT res |= ( 1 << count ) NEW_LINE DEDENT count += 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return ( n res ) NEW_LINE DEDENT
def posOfRightmostSetBit ( n ) : NEW_LINE INDENT return int ( math . log2 ( n & - n ) + 1 ) NEW_LINE DEDENT
def modifyBit ( n , p , b ) : NEW_LINE INDENT mask = 1 << p NEW_LINE return ( n & ~ mask ) | ( ( b << p ) & mask ) NEW_LINE DEDENT
def isOnesComplementOfOther ( a , b ) : NEW_LINE INDENT return areAllBitsSet ( a ^ b ) NEW_LINE DEDENT
def setBitNumber ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n = n + 1 NEW_LINE return ( n >> 1 ) NEW_LINE DEDENT
def posOfRightMostSameBit ( m , n ) : NEW_LINE INDENT loopCounter = 1 NEW_LINE while ( m > 0 or n > 0 ) : NEW_LINE INDENT a = m % 2 == 1 NEW_LINE b = n % 2 == 1 NEW_LINE if ( not ( a ^ b ) ) : NEW_LINE INDENT return loopCounter NEW_LINE DEDENT m = m >> 1 NEW_LINE n = n >> 1 NEW_LINE loopCounter += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def CountZeroBit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( not ( n & 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def countPairsWithKDiff ( arr , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n - 1 , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT xoredNum = arr [ i ] ^ arr [ j ] NEW_LINE if ( k == bitCount ( xoredNum ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def countTrailingZero ( x ) : NEW_LINE INDENT lookup = [ 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 ] NEW_LINE return lookup [ ( - x & x ) % 37 ] NEW_LINE DEDENT
def maxConsecutiveOnes ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = ( x & ( x << 1 ) ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def findXOR ( Set , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return Set [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def findFourElements ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = ( i , j ) NEW_LINE DEDENT DEDENT d = - 10 ** 9 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT abs_diff = abs ( arr [ i ] - arr [ j ] ) NEW_LINE if abs_diff in mp . keys ( ) : NEW_LINE INDENT p = mp [ abs_diff ] NEW_LINE if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) : NEW_LINE INDENT d = max ( d , max ( arr [ i ] , arr [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return d NEW_LINE DEDENT
def recaman ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( 0 , "," , end = '' ) NEW_LINE s = set ( [ ] ) NEW_LINE s . add ( 0 ) NEW_LINE prev = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = prev - i NEW_LINE if ( curr < 0 or curr in s ) : NEW_LINE INDENT curr = prev + i NEW_LINE DEDENT s . add ( curr ) NEW_LINE print ( curr , "," , end = '' ) NEW_LINE prev = curr NEW_LINE DEDENT DEDENT
def findMin ( arr , low , high ) : NEW_LINE INDENT while ( low < high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( arr [ mid ] == arr [ high ] ) : NEW_LINE INDENT high -= 1 NEW_LINE DEDENT elif ( arr [ mid ] > arr [ high ] ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT return arr [ high ] NEW_LINE DEDENT
def splitArr ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , k ) : NEW_LINE INDENT x = arr [ 0 ] NEW_LINE for j in range ( 0 , n - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = x NEW_LINE DEDENT DEDENT
def printSmall ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , n ) : NEW_LINE INDENT max_var = arr [ k - 1 ] NEW_LINE pos = k - 1 NEW_LINE for j in range ( k - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] > max_var ) : NEW_LINE INDENT max_var = arr [ j ] NEW_LINE pos = j NEW_LINE DEDENT DEDENT if ( max_var > arr [ i ] ) : NEW_LINE INDENT j = pos NEW_LINE while ( j < k - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE j += 1 NEW_LINE DEDENT arr [ k - 1 ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def findFirstMissing ( array , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return end + 1 NEW_LINE DEDENT if ( start != array [ start ] ) : NEW_LINE INDENT return start NEW_LINE DEDENT mid = int ( ( start + end ) / 2 ) NEW_LINE if ( array [ mid ] == mid ) : NEW_LINE INDENT return findFirstMissing ( array , mid + 1 , end ) NEW_LINE DEDENT return findFirstMissing ( array , start , mid ) NEW_LINE DEDENT
def countInRange ( arr , n , x , y ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= x and arr [ i ] <= y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def upperIndex ( arr , n , x ) : NEW_LINE INDENT l = 0 NEW_LINE h = n - 1 NEW_LINE while ( l <= h ) : NEW_LINE INDENT mid = int ( ( l + h ) / 2 ) NEW_LINE if ( arr [ mid ] <= x ) : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT return h NEW_LINE DEDENT DEDENT
def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , " " , end = "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def findPeakUtil ( arr , low , high , n ) : NEW_LINE INDENT mid = low + ( high - low ) / 2 NEW_LINE mid = int ( mid ) NEW_LINE if ( ( mid == 0 or arr [ mid - 1 ] <= arr [ mid ] ) and ( mid == n - 1 or arr [ mid + 1 ] <= arr [ mid ] ) ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( mid > 0 and arr [ mid - 1 ] > arr [ mid ] ) : NEW_LINE INDENT return findPeakUtil ( arr , low , ( mid - 1 ) , n ) NEW_LINE DEDENT else : NEW_LINE INDENT return findPeakUtil ( arr , ( mid + 1 ) , high , n ) NEW_LINE DEDENT DEDENT
def maximum ( a , b , c ) : NEW_LINE INDENT return max ( max ( a , b ) , c ) NEW_LINE DEDENT
def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l , res_r = 0 , 0 NEW_LINE l , r , diff = 0 , n - 1 , MAX_VAL NEW_LINE while r > l : NEW_LINE INDENT if abs ( arr [ l ] + arr [ r ] - x ) < diff : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if arr [ l ] + arr [ r ] > x : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( 'The closest pair is {} and {}' . format ( arr [ res_l ] , arr [ res_r ] ) ) NEW_LINE DEDENT
def findPartiion ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT if ( Sum % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT part = [ 0 ] * ( ( Sum // 2 ) + 1 ) NEW_LINE for i in range ( ( Sum // 2 ) + 1 ) : NEW_LINE INDENT part [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( Sum // 2 , arr [ i ] - 1 , - 1 ) : NEW_LINE INDENT if ( part [ j - arr [ i ] ] == 1 or j == arr [ i ] ) : NEW_LINE INDENT part [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT return part [ Sum // 2 ] NEW_LINE DEDENT
def solveWordWrap ( l , n , M ) : NEW_LINE INDENT extras = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE lc = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE c = [ 0 for i in range ( n + 1 ) ] NEW_LINE p = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT extras [ i ] [ i ] = M - l [ i - 1 ] NEW_LINE for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT extras [ i ] [ j ] = ( extras [ i ] [ j - 1 ] - l [ j - 1 ] - 1 ) NEW_LINE DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT if extras [ i ] [ j ] < 0 : NEW_LINE INDENT lc [ i ] [ j ] = INF NEW_LINE DEDENT elif j == n and extras [ i ] [ j ] >= 0 : NEW_LINE INDENT lc [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT lc [ i ] [ j ] = ( extras [ i ] [ j ] * extras [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT c [ 0 ] = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT c [ j ] = INF NEW_LINE for i in range ( 1 , j + 1 ) : NEW_LINE INDENT if ( c [ i - 1 ] != INF and lc [ i ] [ j ] != INF and ( ( c [ i - 1 ] + lc [ i ] [ j ] ) < c [ j ] ) ) : NEW_LINE INDENT c [ j ] = c [ i - 1 ] + lc [ i ] [ j ] NEW_LINE p [ j ] = i NEW_LINE DEDENT DEDENT DEDENT printSolution ( p , n ) NEW_LINE DEDENT
def optCost ( freq , i , j ) : NEW_LINE INDENT if j < i : NEW_LINE INDENT return 0 NEW_LINE DEDENT if j == i : NEW_LINE INDENT return freq [ i ] NEW_LINE DEDENT fsum = Sum ( freq , i , j ) NEW_LINE Min = 999999999999 NEW_LINE for r in range ( i , j + 1 ) : NEW_LINE INDENT cost = ( optCost ( freq , i , r - 1 ) + optCost ( freq , r + 1 , j ) ) NEW_LINE if cost < Min : NEW_LINE INDENT Min = cost NEW_LINE DEDENT DEDENT return Min + fsum NEW_LINE DEDENT
def minCoins ( coins , m , V ) : NEW_LINE INDENT if ( V == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = sys . maxsize NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT if ( coins [ i ] <= V ) : NEW_LINE INDENT sub_res = minCoins ( coins , m , V - coins [ i ] ) NEW_LINE if ( sub_res != sys . maxsize and sub_res + 1 < res ) : NEW_LINE INDENT res = sub_res + 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return x * power ( x , y - 1 ) NEW_LINE DEDENT
def maximumNumberDistinctPrimeRange ( m , n ) : NEW_LINE INDENT factorCount = [ 0 ] * ( n + 1 ) NEW_LINE prime = [ False ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT factorCount [ i ] = 0 NEW_LINE prime [ i ] = True NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT factorCount [ i ] = 1 NEW_LINE for j in range ( i * 2 , n + 1 , i ) : NEW_LINE INDENT factorCount [ j ] += 1 NEW_LINE prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT max = factorCount [ m ] NEW_LINE num = m NEW_LINE for i in range ( m , n + 1 ) : NEW_LINE INDENT if ( factorCount [ i ] > max ) : NEW_LINE INDENT max = factorCount [ i ] NEW_LINE num = i NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT
def getSingle ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , INT_SIZE ) : NEW_LINE INDENT sm = 0 NEW_LINE x = ( 1 << i ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] & x ) : NEW_LINE INDENT sm = sm + 1 NEW_LINE DEDENT DEDENT if ( ( sm % 3 ) != 0 ) : NEW_LINE INDENT result = result | x NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT i = 0 NEW_LINE ans = 0 NEW_LINE while ( ( 1 << i ) <= n ) : NEW_LINE INDENT k = 0 NEW_LINE change = 1 << i NEW_LINE for j in range ( 0 , n + 1 ) : NEW_LINE INDENT ans += k NEW_LINE if change == 1 : NEW_LINE INDENT k = not k NEW_LINE change = 1 << i NEW_LINE DEDENT else : NEW_LINE INDENT change -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def swapBits ( x , p1 , p2 , n ) : NEW_LINE INDENT set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) NEW_LINE set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) NEW_LINE xor = ( set1 ^ set2 ) NEW_LINE xor = ( xor << p1 ) | ( xor << p2 ) NEW_LINE result = x ^ xor NEW_LINE return result NEW_LINE DEDENT
def minSwaps ( n , pairs , arr ) : NEW_LINE INDENT index = [ ] NEW_LINE for i in range ( 2 * n + 1 + 1 ) : NEW_LINE INDENT index . append ( 0 ) NEW_LINE DEDENT for i in range ( 1 , 2 * n + 1 ) : NEW_LINE INDENT index [ arr [ i ] ] = i NEW_LINE DEDENT return minSwapsUtil ( arr , pairs , index , 1 , 2 * n ) NEW_LINE DEDENT
def maxOfSegmentMins ( a , n , k ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT return min ( a ) NEW_LINE DEDENT if k == 2 : NEW_LINE INDENT return max ( a [ 0 ] , a [ n - 1 ] ) NEW_LINE DEDENT return max ( a ) NEW_LINE DEDENT
def MinOperation ( a , b , n ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE b . sort ( reverse = False ) NEW_LINE result = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( a [ i ] > b [ i ] ) : NEW_LINE INDENT result = result + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT elif ( a [ i ] < b [ i ] ) : NEW_LINE INDENT result = result + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def findMissing ( arr1 , arr2 , M , N ) : NEW_LINE INDENT if ( M != N - 1 and N != M - 1 ) : NEW_LINE INDENT print ( "Invalid Input" ) NEW_LINE return NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT res = res ^ arr1 [ i ] NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT res = res ^ arr2 [ i ] NEW_LINE DEDENT print ( "Missing element is" , res ) NEW_LINE DEDENT
def calculate ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE s = [ ] NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT s . append ( ( a [ i ] + a [ j ] ) ) NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT mini = min ( s ) NEW_LINE maxi = max ( s ) NEW_LINE return abs ( maxi - mini ) NEW_LINE DEDENT
def findMinSum ( a , b , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def push ( head_ref , new_data ) : NEW_LINE INDENT new_Node = Node ( new_data ) NEW_LINE new_Node . data = new_data NEW_LINE new_Node . next = head_ref NEW_LINE head_ref = new_Node NEW_LINE head = head_ref NEW_LINE return head NEW_LINE DEDENT
def fun ( arr , k ) : NEW_LINE INDENT n = len ( arr ) - 1 NEW_LINE v = n - k NEW_LINE if v >= 0 : NEW_LINE INDENT reverse ( arr , 0 , v ) NEW_LINE reverse ( arr , v + 1 , n ) NEW_LINE reverse ( arr , 0 , n ) NEW_LINE return arr NEW_LINE DEDENT DEDENT
def rotateSubList ( A , m , n , k ) : NEW_LINE INDENT size = n - m + 1 NEW_LINE if ( k > size ) : NEW_LINE INDENT k = k % size NEW_LINE DEDENT if ( k == 0 or k == size ) : NEW_LINE INDENT head = A NEW_LINE while ( head != None ) : NEW_LINE INDENT print ( head . data ) NEW_LINE head = head . next NEW_LINE DEDENT return NEW_LINE DEDENT link = None NEW_LINE if ( m == 1 ) : NEW_LINE INDENT link = A NEW_LINE DEDENT c = A NEW_LINE count = 0 NEW_LINE end = None NEW_LINE pre = None NEW_LINE while ( c != None ) : NEW_LINE INDENT count = count + 1 NEW_LINE if ( count == m - 1 ) : NEW_LINE INDENT pre = c NEW_LINE link = c . next NEW_LINE DEDENT if ( count == n - k ) : NEW_LINE INDENT if ( m == 1 ) : NEW_LINE INDENT end = c NEW_LINE A = c . next NEW_LINE DEDENT else : NEW_LINE INDENT end = c NEW_LINE pre . next = c . next NEW_LINE DEDENT DEDENT if ( count == n ) : NEW_LINE INDENT d = c . next NEW_LINE c . next = link NEW_LINE end . next = d NEW_LINE head = A NEW_LINE while ( head != None ) : NEW_LINE INDENT print ( head . data , end = " " ) NEW_LINE head = head . next NEW_LINE DEDENT return NEW_LINE DEDENT c = c . next NEW_LINE DEDENT DEDENT
def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ) NEW_LINE DEDENT DEDENT
def createHash ( hashmap , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hashmap . add ( prev ) NEW_LINE hashmap . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hashmap . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT
def solve ( N , M ) : NEW_LINE INDENT ans = int ( ( N ) * int ( M / 2 ) ) NEW_LINE if ( M % 2 == 1 ) : NEW_LINE INDENT ans += int ( ( N + 1 ) / 2 ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT
def rangeXor ( BITree , l , r ) : NEW_LINE INDENT return ( getXOR ( BITree , r ) ^ getXOR ( BITree , l - 1 ) ) NEW_LINE DEDENT
def query ( L , R ) : NEW_LINE INDENT return prefix [ R ] - prefix [ L - 1 ] NEW_LINE DEDENT
def game ( v , n ) : NEW_LINE INDENT m = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( v [ i ] not in m ) : NEW_LINE INDENT m [ v [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ v [ i ] ] += 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE check = 0 NEW_LINE for i in m . values ( ) : NEW_LINE INDENT if ( i > 1 ) : NEW_LINE INDENT if ( i >= 4 and i % 2 == 0 ) : NEW_LINE INDENT check += 1 NEW_LINE DEDENT count += 1 NEW_LINE DEDENT DEDENT if ( check % 2 != 0 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT if ( check % 2 != 0 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT elif ( n % 2 == 0 and count % 2 == 0 ) : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT
def SieveOfEratosthenes ( ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT prime [ i ] = 1 NEW_LINE DEDENT DEDENT
def fact ( n , a = 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return fact ( n - 1 , n * a ) NEW_LINE DEDENT
def maximumMedian ( arr , N , K ) : NEW_LINE INDENT low = 0 NEW_LINE high = 1000000009 NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( isMaximumMedian ( arr , N , K , mid ) ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT
def findMinDays ( arr , R , N , X , K ) : NEW_LINE INDENT low = 0 NEW_LINE high = X NEW_LINE minDays = 0 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp = arr [ i ] + R [ i ] * mid NEW_LINE if ( temp >= K ) : NEW_LINE INDENT sum += temp NEW_LINE DEDENT DEDENT if ( sum >= X ) : NEW_LINE INDENT minDays = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT print ( minDays ) NEW_LINE DEDENT
def maximumIndices ( arr , N ) : NEW_LINE INDENT temp = [ 0 ] * N NEW_LINE maxIndices = ( N - 1 ) // 2 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( maxIndices ) : NEW_LINE INDENT temp [ 2 * i + 1 ] = arr [ i ] NEW_LINE DEDENT j = 0 NEW_LINE i = maxIndices NEW_LINE while ( i < N ) : NEW_LINE INDENT if ( temp [ j ] == 0 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE i += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( temp [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def check ( n , m , x , y , vl ) : NEW_LINE INDENT temp = m NEW_LINE if ( vl > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT ex = n - vl NEW_LINE ex *= y NEW_LINE temp += ex NEW_LINE cr = temp // x NEW_LINE if ( cr >= vl ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def findPoint ( arr , N , K ) : NEW_LINE INDENT left = 0 NEW_LINE if ( N % 2 ) : NEW_LINE INDENT left = arr [ N // 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT left = arr [ N // 2 - 1 ] + 1 NEW_LINE DEDENT right = arr [ N - 1 ] NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) // 2 NEW_LINE temp = findSum ( arr , N , mid ) NEW_LINE if ( temp == K ) : NEW_LINE INDENT print ( mid ) NEW_LINE return NEW_LINE DEDENT elif ( K < temp ) : NEW_LINE INDENT right = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT DEDENT left = arr [ 0 ] NEW_LINE right = arr [ N // 2 ] - 1 NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) // 2 NEW_LINE temp = findSum ( arr , N , mid ) NEW_LINE if ( temp == K ) : NEW_LINE INDENT print ( mid ) NEW_LINE return NEW_LINE DEDENT elif ( K > temp ) : NEW_LINE INDENT right = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT DEDENT print ( "-1" ) NEW_LINE DEDENT
def NthComposite ( N ) : NEW_LINE INDENT IsPrime = [ True ] * 1000005 NEW_LINE DEDENT
def printArray ( res ) : NEW_LINE INDENT res . sort ( ) NEW_LINE for i in range ( len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def minCount ( A , B , N ) : NEW_LINE INDENT i = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( A [ i ] == B [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return N - i NEW_LINE DEDENT
def minimumNumber ( K , X ) : NEW_LINE INDENT if ( K > X ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE return NEW_LINE DEDENT low = K NEW_LINE high = X NEW_LINE res = - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( ( high - low ) // 2 ) NEW_LINE if ( isGreaterEqual ( mid , K , X ) ) : NEW_LINE INDENT res = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT
def right_search ( A , num ) : NEW_LINE INDENT low , high = 0 , len ( A ) - 1 NEW_LINE ans = high NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( A [ mid ] <= num ) : NEW_LINE INDENT ans = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def inv ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE x0 = 0 NEW_LINE x1 = 1 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if ( x1 < 0 ) : NEW_LINE INDENT x1 += m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT
def prefixArr ( arr , prefix , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT prefix [ i ] [ 0 ] = arr [ i ] NEW_LINE prefix [ i ] [ 1 ] = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] [ 0 ] = max ( prefix [ i - 1 ] [ 0 ] , arr [ i ] ) NEW_LINE prefix [ i ] [ 1 ] = min ( prefix [ i - 1 ] [ 1 ] , arr [ i ] ) NEW_LINE DEDENT DEDENT return prefix NEW_LINE DEDENT
def Query ( arr , N , Q ) : NEW_LINE INDENT tree = [ 0 ] * ( 4 * N ) NEW_LINE build_seg_tree ( 0 , N - 1 , 0 , tree , arr ) NEW_LINE for i in range ( len ( Q ) ) : NEW_LINE INDENT if ( Q [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT print ( query ( Q [ i ] [ 1 ] , Q [ i ] [ 2 ] , 0 , N - 1 , 0 , tree ) , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT update ( 0 , N - 1 , 0 , Q [ i ] [ 1 ] , Q [ i ] [ 2 ] , tree , arr ) NEW_LINE DEDENT DEDENT DEDENT
def Sieve ( ) : NEW_LINE INDENT p = [ True ] * ( N + 1 ) NEW_LINE p [ 0 ] = p [ 1 ] = False NEW_LINE i = 2 NEW_LINE while ( i * i <= N ) : NEW_LINE INDENT if ( p [ i ] == True ) : NEW_LINE INDENT for j in range ( i * i , N , i ) : NEW_LINE INDENT p [ j ] = False NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( p [ i ] != False ) : NEW_LINE INDENT prime . append ( pow ( i , 4 ) ) NEW_LINE DEDENT DEDENT DEDENT
def isValidDigit ( digit , K ) : NEW_LINE INDENT while ( K != 0 ) : NEW_LINE INDENT if ( K % 10 == digit ) : NEW_LINE INDENT return True NEW_LINE DEDENT K = K // 10 NEW_LINE DEDENT return False NEW_LINE DEDENT
def update ( index , s , e , new_val , pos ) : NEW_LINE INDENT global Tree NEW_LINE global max NEW_LINE if ( s == e ) : NEW_LINE INDENT Tree [ index ] = new_val NEW_LINE DEDENT else : NEW_LINE INDENT m = ( s + e ) // 2 NEW_LINE if ( pos <= m ) : NEW_LINE INDENT update ( 2 * index , s , m , new_val , pos ) NEW_LINE DEDENT else : NEW_LINE INDENT update ( 2 * index + 1 , m + 1 , e , new_val , pos ) NEW_LINE DEDENT Tree [ index ] = max ( Tree [ 2 * index ] , Tree [ 2 * index + 1 ] ) NEW_LINE DEDENT DEDENT
def printAnswer ( N , edges ) : NEW_LINE INDENT for i in range ( N + 1 ) : NEW_LINE INDENT parent [ i ] = i NEW_LINE DEDENT for i in range ( len ( edges ) ) : NEW_LINE INDENT connect ( edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) NEW_LINE DEDENT connectedComponents ( N ) NEW_LINE DEDENT
def countNumbers ( n , d ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT x = i NEW_LINE while ( x > 0 ) : NEW_LINE INDENT if ( x % 8 == d ) : NEW_LINE INDENT total += 1 NEW_LINE break NEW_LINE DEDENT x = x // 8 NEW_LINE DEDENT DEDENT print ( total ) NEW_LINE DEDENT
def smallestLeft ( arr , total , sum , i , dp ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT return abs ( total - 2 * sum ) NEW_LINE DEDENT if ( dp [ i ] [ sum ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ sum ] NEW_LINE DEDENT X = smallestLeft ( arr , total , sum + arr [ i - 1 ] , i - 1 , dp ) NEW_LINE Y = smallestLeft ( arr , total , sum , i - 1 , dp ) NEW_LINE dp [ i ] [ sum ] = min ( X , Y ) NEW_LINE return dp [ i ] [ sum ] NEW_LINE DEDENT
def findWordsSameRow ( arr ) : NEW_LINE INDENT mp = { 'q' : 1 , 'w' : 1 , 'e' : 1 , 'r' : 1 , 't' : 1 , 'y' : 1 , 'u' : 1 , 'o' : 1 , 'p' : 1 , 'i' : 1 , 'a' : 2 , 's' : 2 , 'd' : 2 , 'f' : 2 , 'g' : 2 , 'h' : 2 , 'j' : 2 , 'k' : 2 , 'l' : 2 , 'z' : 3 , 'x' : 3 , 'c' : 3 , 'v' : 3 , 'b' : 3 , 'n' : 3 , 'm' : 3 } NEW_LINE for word in arr : NEW_LINE INDENT if ( len ( word ) != 0 ) : NEW_LINE INDENT flag = True NEW_LINE rowNum = mp [ word [ 0 ] . lower ( ) ] NEW_LINE M = len ( word ) NEW_LINE for i in range ( 1 , M ) : NEW_LINE INDENT if ( mp [ word [ i ] . lower ( ) ] != rowNum ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( word , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def countSubsequece ( a , n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( a [ j ] == a [ l ] and a [ i ] == a [ k ] ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return answer NEW_LINE DEDENT
def countSubsequence ( a , n ) : NEW_LINE INDENT fill_counts ( a , n ) NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT answer += ( lcount [ a [ j ] ] [ i - 1 ] * rcount [ a [ i ] ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def MincntBothPalin ( str1 , str2 , N ) : NEW_LINE INDENT i = 0 NEW_LINE j = N - 1 NEW_LINE cntOp = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( str1 [ i ] == str1 [ j ] and str2 [ i ] != str2 [ j ] ) : NEW_LINE INDENT cntOp += 1 NEW_LINE DEDENT elif ( str1 [ i ] != str1 [ j ] and str2 [ i ] == str2 [ j ] ) : NEW_LINE INDENT cntOp += 1 NEW_LINE DEDENT elif ( str1 [ i ] != str1 [ j ] and str2 [ i ] != str2 [ j ] ) : NEW_LINE INDENT if ( str1 [ i ] == str2 [ j ] and str2 [ i ] == str1 [ j ] ) : NEW_LINE INDENT cntOp += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntOp += 2 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return cntOp NEW_LINE DEDENT
def isValid ( wood , N , len , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT count += wood [ i ] // len NEW_LINE DEDENT return ( count >= K ) NEW_LINE DEDENT
def isMorannumber ( n ) : NEW_LINE INDENT dup = n NEW_LINE sums = digiSum ( dup ) NEW_LINE if ( n % sums == 0 ) : NEW_LINE INDENT c = n // sums NEW_LINE if isPrime ( c ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def maxEqualIdx ( arr , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE prefixSum = [ 0 ] * ( len ( arr ) + 1 ) NEW_LINE prefixSum [ 1 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , len ( prefixSum ) - 1 , 1 ) : NEW_LINE INDENT prefixSum [ i + 1 ] = prefixSum [ i ] + arr [ i ] NEW_LINE DEDENT max = len ( arr ) NEW_LINE min = 1 NEW_LINE ans = 1 NEW_LINE while ( min <= max ) : NEW_LINE INDENT mid = ( max + min ) // 2 NEW_LINE if ( check ( prefixSum , mid , k , arr ) ) : NEW_LINE INDENT ans = mid NEW_LINE min = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT max = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def sfpa ( V , src , Edges , M ) : NEW_LINE INDENT g = [ [ ] for i in range ( V ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT u = Edges [ i ] [ 0 ] NEW_LINE v = Edges [ i ] [ 1 ] NEW_LINE w = Edges [ i ] [ 2 ] NEW_LINE g [ u ] . append ( [ v , w ] ) NEW_LINE DEDENT dist = [ sys . maxsize for i in range ( V ) ] NEW_LINE inQueue = [ False for i in range ( V ) ] NEW_LINE cnt = [ 0 for i in range ( V ) ] NEW_LINE dist [ src ] = 0 NEW_LINE q = [ ] NEW_LINE q . append ( src ) NEW_LINE inQueue [ src ] = True NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT u = q [ 0 ] NEW_LINE q . remove ( q [ 0 ] ) NEW_LINE inQueue [ u ] = False NEW_LINE for x in g [ u ] : NEW_LINE INDENT v = x [ 0 ] NEW_LINE cost = x [ 1 ] NEW_LINE if ( dist [ v ] > dist [ u ] + cost ) : NEW_LINE INDENT dist [ v ] = dist [ u ] + cost NEW_LINE if ( inQueue [ v ] == False ) : NEW_LINE INDENT q . append ( v ) NEW_LINE inQueue [ v ] = True NEW_LINE cnt [ v ] += 1 NEW_LINE if ( cnt [ v ] >= V ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def countNum ( N , sum , K , st , dp ) : NEW_LINE INDENT if ( N == 0 and sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ N ] [ sum ] [ st ] != - 1 ) : NEW_LINE INDENT return dp [ N ] [ sum ] [ st ] NEW_LINE DEDENT res = 0 NEW_LINE start = 1 NEW_LINE if ( st == 1 ) : NEW_LINE INDENT start = 0 NEW_LINE DEDENT else : NEW_LINE INDENT start = 1 NEW_LINE DEDENT for i in range ( start , 10 ) : NEW_LINE INDENT min = 0 NEW_LINE if ( ( st i ) > 0 ) : NEW_LINE INDENT min = 1 NEW_LINE DEDENT else : NEW_LINE INDENT min = 0 NEW_LINE DEDENT res += countNum ( N - 1 , ( sum + i ) % K , K , min , dp ) NEW_LINE dp [ N ] [ sum ] [ st ] = res NEW_LINE DEDENT return dp [ N ] [ sum ] [ st ] NEW_LINE DEDENT
def hIndex ( citations , n ) : NEW_LINE INDENT hindex = 0 NEW_LINE low = 0 NEW_LINE high = n - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( citations [ mid ] >= ( mid + 1 ) ) : NEW_LINE INDENT low = mid + 1 NEW_LINE hindex = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT print ( hindex ) NEW_LINE return hindex NEW_LINE DEDENT
def countNodes ( V , E , src , dest , edges ) : NEW_LINE INDENT adj = [ [ ] for i in range ( V + 1 ) ] NEW_LINE for i in range ( E ) : NEW_LINE INDENT adj [ edges [ i ] [ 0 ] ] . append ( edges [ i ] [ 1 ] ) NEW_LINE adj [ edges [ i ] [ 1 ] ] . append ( edges [ i ] [ 0 ] ) NEW_LINE DEDENT vis = [ 0 ] * ( V + 1 ) NEW_LINE count = dfs ( src , dest , vis , adj ) NEW_LINE return count - 2 NEW_LINE DEDENT
def longestGP ( A , N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return N NEW_LINE DEDENT length = 1 NEW_LINE common_ratio = 1 NEW_LINE maxlength = 1 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT if ( A [ i + 1 ] % A [ i ] == 0 ) : NEW_LINE INDENT if ( A [ i + 1 ] // A [ i ] == common_ratio ) : NEW_LINE INDENT length = length + 1 NEW_LINE maxlength = max ( maxlength , length ) NEW_LINE DEDENT else : NEW_LINE INDENT common_ratio = A [ i + 1 ] // A [ i ] NEW_LINE length = 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxlength = max ( maxlength , length ) NEW_LINE length = 1 NEW_LINE DEDENT DEDENT maxlength = max ( maxlength , length ) NEW_LINE return maxlength NEW_LINE DEDENT
def add_seg ( seg , start , end , current , index ) : NEW_LINE INDENT if ( index > end or index < start ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( start == end ) : NEW_LINE INDENT seg [ current ] = 1 NEW_LINE return NEW_LINE DEDENT mid = int ( ( start + end ) / 2 ) NEW_LINE add_seg ( seg , start , mid , 2 * current + 1 , index ) NEW_LINE add_seg ( seg , mid + 1 , end , 2 * current + 2 , index ) NEW_LINE seg [ current ] = seg [ 2 * current + 1 ] + seg [ 2 * current + 2 ] NEW_LINE DEDENT
def getPrefixLength ( srcStr , targetStr ) : NEW_LINE INDENT if ( len ( targetStr ) == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT srcStr = srcStr . lower ( ) NEW_LINE targetStr = targetStr . lower ( ) NEW_LINE dictCount = dict ( [ ] ) NEW_LINE nUnique = 0 NEW_LINE for ch in targetStr : NEW_LINE INDENT if ( ch not in dictCount ) : NEW_LINE INDENT nUnique += 1 NEW_LINE dictCount [ ch ] = 0 NEW_LINE DEDENT dictCount [ ch ] += 1 NEW_LINE DEDENT for i in range ( len ( srcStr ) ) : NEW_LINE INDENT ch = srcStr [ i ] NEW_LINE if ( ch not in dictCount ) : NEW_LINE INDENT continue NEW_LINE DEDENT dictCount [ ch ] -= 1 NEW_LINE if ( dictCount [ ch ] == 0 ) : NEW_LINE INDENT nUnique -= 1 NEW_LINE DEDENT if ( nUnique == 0 ) : NEW_LINE INDENT return ( i + 1 ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def minOperations ( S , K ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT zero , one = 0 , 0 NEW_LINE for j in range ( i , len ( S ) , K ) : NEW_LINE INDENT if ( S [ j ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT one += 1 NEW_LINE DEDENT DEDENT ans += min ( zero , one ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def func ( A , B , C , x ) : NEW_LINE INDENT return ( A * x * x + B * x + C ) NEW_LINE DEDENT
def minDays ( arr , n , k ) : NEW_LINE INDENT l = len ( arr ) NEW_LINE left = 1 NEW_LINE right = 1e9 NEW_LINE if ( n * k > l ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT while ( left < right ) : NEW_LINE INDENT mid = ( left + right ) // 2 NEW_LINE cnt = 0 NEW_LINE product = 0 NEW_LINE for j in range ( l ) : NEW_LINE INDENT if ( arr [ j ] > mid ) : NEW_LINE INDENT cnt = 0 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE if ( cnt >= k ) : NEW_LINE INDENT product += 1 NEW_LINE cnt = 0 NEW_LINE DEDENT DEDENT DEDENT if ( product < n ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right = mid NEW_LINE DEDENT DEDENT return left NEW_LINE DEDENT
def minimumMoves ( S , K ) : NEW_LINE INDENT N = len ( S ) NEW_LINE ops = 0 NEW_LINE last_idx = - 1 NEW_LINE for i in range ( K ) : NEW_LINE INDENT if ( S [ i ] == '1' ) : NEW_LINE INDENT last_idx = i NEW_LINE DEDENT DEDENT if ( last_idx == - 1 ) : NEW_LINE INDENT ops += 1 NEW_LINE S [ K - 1 ] = '1' NEW_LINE last_idx = K - 1 NEW_LINE DEDENT for i in range ( N - K + 1 ) : NEW_LINE INDENT if ( last_idx < i ) : NEW_LINE INDENT last_idx = - 1 NEW_LINE DEDENT if ( S [ i + K - 1 ] == '1' ) : NEW_LINE INDENT last_idx = i + K - 1 NEW_LINE DEDENT if ( last_idx == - 1 ) : NEW_LINE INDENT ops += 1 NEW_LINE S = S [ : i + K - 1 ] + '1' + S [ i + K : ] NEW_LINE last_idx = i + K - 1 NEW_LINE DEDENT DEDENT return ops NEW_LINE DEDENT
def missingElement ( arr , n ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE min_ele = arr [ 0 ] NEW_LINE x = 0 NEW_LINE d = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > max_ele ) : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < min_ele ) : NEW_LINE INDENT min_ele = arr [ i ] NEW_LINE DEDENT DEDENT d = ( max_ele - min_ele ) // n NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT x = x ^ ( min_ele + ( i * d ) ) NEW_LINE DEDENT return x NEW_LINE DEDENT
def longestPermutation ( a , n ) : NEW_LINE INDENT freq = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT length = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( freq [ i ] == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT length += 1 NEW_LINE DEDENT return length NEW_LINE DEDENT
def findColor ( mapWithColor , query ) : NEW_LINE INDENT maximum = 0 NEW_LINE while ( query >= 1 ) : NEW_LINE INDENT if ( query ) in mapWithColor . keys ( ) : NEW_LINE INDENT maximum = max ( maximum , mapWithColor [ query ] ) NEW_LINE DEDENT if ( query % 2 == 1 ) : NEW_LINE INDENT query = ( query - 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT query = query // 2 NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT
def findlength ( string , n , k ) : NEW_LINE INDENT maxLen = 0 NEW_LINE freq = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT setZero ( freq ) NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT freq [ ord ( string [ j ] ) - ord ( 'a' ) ] += 1 NEW_LINE if ( atLeastK ( freq , k ) ) : NEW_LINE INDENT maxLen = max ( maxLen , j - i + 1 ) NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT
def maxSumArray ( arr , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE mp = { i : 0 for i in range ( 4 ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum1 += arr [ i ] NEW_LINE mp [ arr [ i ] ] += 1 NEW_LINE DEDENT minimum = maxsize NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if ( key == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT minimum = min ( minimum , value * key ) NEW_LINE DEDENT return ( sum1 - minimum ) NEW_LINE DEDENT
def create_table ( n ) : NEW_LINE INDENT pow = 1 NEW_LINE co = 0 NEW_LINE while True : NEW_LINE INDENT pow <<= 1 NEW_LINE lookup_table [ co ] = ( n + ( pow >> 1 ) ) // pow NEW_LINE if lookup_table [ co ] == 0 : NEW_LINE INDENT break NEW_LINE DEDENT co += 1 NEW_LINE DEDENT DEDENT
def costToPanagram ( string , cost ) : NEW_LINE INDENT n = len ( string ) NEW_LINE occurrences = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT occurrences [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT gain = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if occurrences [ i ] == 0 : NEW_LINE INDENT gain -= 2 * cost [ i ] NEW_LINE DEDENT elif occurrences [ i ] > 1 : NEW_LINE INDENT gain += cost [ i ] * ( occurrences [ i ] - 1 ) NEW_LINE DEDENT DEDENT if gain >= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return gain * - 1 NEW_LINE DEDENT
def strScore ( string , s , n ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ string [ i ] ] = i + 1 NEW_LINE DEDENT if s not in m . keys ( ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT score = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT score += ord ( s [ i ] ) - ord ( 'a' ) + 1 NEW_LINE DEDENT score = score * m [ s ] NEW_LINE return score NEW_LINE DEDENT
def replacePi ( input ) : NEW_LINE INDENT output = "" NEW_LINE size = len ( input ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( i + 1 < size and input [ i ] == 'p' and input [ i + 1 ] == 'i' ) : NEW_LINE INDENT output += "3.14" NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT output += input [ i ] NEW_LINE DEDENT DEDENT return output NEW_LINE DEDENT
def check_pair_product ( self , prod ) : NEW_LINE INDENT p = self . head NEW_LINE s = set ( ) NEW_LINE while p != None : NEW_LINE INDENT curr = p . data NEW_LINE if ( prod % curr == 0 and ( prod // curr ) in s ) : NEW_LINE INDENT print ( curr , prod // curr ) NEW_LINE return True NEW_LINE DEDENT s . add ( p . data ) NEW_LINE p = p . next NEW_LINE DEDENT return False NEW_LINE DEDENT
def minSum ( arr , n ) : NEW_LINE INDENT sm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ i - 1 ] : NEW_LINE INDENT j = i NEW_LINE while j < n and arr [ j ] <= arr [ j - 1 ] : NEW_LINE INDENT arr [ j ] = arr [ j ] + 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT sm = sm + arr [ i ] NEW_LINE DEDENT return sm NEW_LINE DEDENT
def totalNumbersWithSpecificDifference ( N , diff ) : NEW_LINE INDENT low = 1 NEW_LINE high = N NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( mid - sumOfDigit ( mid ) < diff ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ( N - high ) NEW_LINE DEDENT
def computeCost ( arr , N , X ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cost += abs ( arr [ i ] - X ) NEW_LINE DEDENT return cost NEW_LINE DEDENT
def insertionSort ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE key = 0 NEW_LINE j = 0 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT key = arr [ i ] NEW_LINE j = i - 1 NEW_LINE while ( j >= 0 and arr [ j ] > key ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT arr [ j + 1 ] = key NEW_LINE DEDENT DEDENT
def minimumRange ( arr , N , K ) : NEW_LINE INDENT if ( K >= N ) : NEW_LINE INDENT print ( 0 , end = '' ) NEW_LINE return NEW_LINE DEDENT arr . sort ( ) NEW_LINE left = 0 NEW_LINE right = N - 1 NEW_LINE for i in range ( K ) : NEW_LINE INDENT if ( arr [ right - 1 ] - arr [ left ] < arr [ right ] - arr [ left + 1 ] ) : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT left += 1 NEW_LINE DEDENT DEDENT print ( arr [ right ] - arr [ left ] , end = '' ) NEW_LINE DEDENT
def minimum_possible_sum ( arr , n , k ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT smallest_element = arr [ 0 ] NEW_LINE smallest_pos = 0 NEW_LINE largest_element = arr [ 0 ] NEW_LINE largest_pos = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] >= largest_element ) : NEW_LINE INDENT largest_element = arr [ i ] NEW_LINE largest_pos = i NEW_LINE DEDENT if ( arr [ i ] < smallest_element ) : NEW_LINE INDENT smallest_element = arr [ i ] NEW_LINE smallest_pos = i NEW_LINE DEDENT DEDENT a = smallest_element * 2 NEW_LINE b = largest_element // 2 NEW_LINE if ( a + b < smallest_element + largest_element ) : NEW_LINE INDENT arr [ smallest_pos ] = a NEW_LINE arr [ largest_pos ] = b NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def XorSum ( A , B , N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT ans = ans ^ ( A [ i ] + B [ j ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findCount ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE result = 1 NEW_LINE cur_max = arr [ 0 ] NEW_LINE cur_min = arr [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT cur_max = arr [ i ] NEW_LINE if ( cur_max - cur_min > K ) : NEW_LINE INDENT result += 1 NEW_LINE cur_max = arr [ i ] NEW_LINE cur_min = arr [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def checkToMakeEqual ( S1 , S2 ) : NEW_LINE INDENT freq = [ 0 for _ in range ( 26 ) ] NEW_LINE for i in range ( len ( S1 ) ) : NEW_LINE INDENT freq [ ord ( S1 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT flag = 0 NEW_LINE for i in range ( len ( S2 ) ) : NEW_LINE INDENT if freq [ ord ( S2 [ i ] ) - ord ( 'a' ) ] == 0 : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT freq [ ord ( S2 [ i ] ) - ord ( 'a' ) ] -= 1 NEW_LINE DEDENT if flag == 1 : NEW_LINE INDENT print ( "No" ) NEW_LINE return NEW_LINE DEDENT invCount1 = inversionCount ( S1 ) NEW_LINE invCount2 = inversionCount ( S2 ) NEW_LINE if ( ( invCount1 == invCount2 ) or ( ( invCount1 % 2 ) == ( invCount2 % 2 ) ) or haveRepeated ( S1 , S2 ) == 1 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def findKthSmallest ( arr , n , k ) : NEW_LINE INDENT max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT counter = [ 0 ] * ( max + 1 ) NEW_LINE smallest = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT counter [ arr [ i ] ] += 1 NEW_LINE DEDENT for num in range ( 1 , max + 1 ) : NEW_LINE INDENT if ( counter [ num ] > 0 ) : NEW_LINE INDENT smallest += counter [ num ] NEW_LINE DEDENT if ( smallest >= k ) : NEW_LINE INDENT return num NEW_LINE DEDENT DEDENT DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE if ( arr [ 0 ] == arr [ n - 1 ] ) : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Yes" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT
def countVowels ( string ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( isVowel ( string [ i ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findSum ( arr , n , k ) : NEW_LINE INDENT ans = arr [ n - k - 1 ] - arr [ 0 ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT ans = min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def cntElements ( arr , n ) : NEW_LINE INDENT copy_arr = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT copy_arr [ i ] = arr [ i ] NEW_LINE DEDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != copy_arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def UpdateArr ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE i += 2 NEW_LINE j -= 2 NEW_LINE DEDENT printArr ( arr , n ) NEW_LINE DEDENT
def pre ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT DEDENT
def sieve ( n ) : NEW_LINE INDENT for p in range ( 2 , n ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT pr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT
def SemiPrimeSum ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( pr ) ) : NEW_LINE INDENT for j in range ( i , len ( pr ) ) : NEW_LINE INDENT if ( pr [ i ] * pr [ j ] > N ) : NEW_LINE INDENT break NEW_LINE DEDENT ans += pr [ i ] * pr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def quickSort ( arr , low , high , mod ) : NEW_LINE INDENT if ( low < high ) : NEW_LINE INDENT pi = partition ( arr , low , high , mod ) NEW_LINE quickSort ( arr , low , pi - 1 , mod ) NEW_LINE quickSort ( arr , pi + 1 , high , mod ) NEW_LINE return arr NEW_LINE DEDENT DEDENT
def maxWater ( height , n ) : NEW_LINE INDENT maximum = 0 NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( height [ i ] < height [ j ] ) : NEW_LINE INDENT maximum = max ( maximum , ( j - i - 1 ) * height [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT elif ( height [ j ] < height [ i ] ) : NEW_LINE INDENT maximum = max ( maximum , ( j - i - 1 ) * height [ j ] ) NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT maximum = max ( maximum , ( j - i - 1 ) * height [ i ] ) NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT
def check ( str ) : NEW_LINE INDENT min = sys . maxsize NEW_LINE max = - sys . maxsize - 1 NEW_LINE sum = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT ascii = str [ i ] NEW_LINE if ( ord ( ascii ) < 96 or ord ( ascii ) > 122 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += ord ( ascii ) NEW_LINE if ( min > ord ( ascii ) ) : NEW_LINE INDENT min = ord ( ascii ) NEW_LINE DEDENT if ( max < ord ( ascii ) ) : NEW_LINE INDENT max = ord ( ascii ) NEW_LINE DEDENT DEDENT min -= 1 NEW_LINE eSum = ( ( ( max * ( max + 1 ) ) // 2 ) - ( ( min * ( min + 1 ) ) // 2 ) ) NEW_LINE return sum == eSum NEW_LINE DEDENT
def findNumbers ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE freq = [ 0 for i in range ( arr [ 0 ] + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT size = int ( sqrt ( n ) ) NEW_LINE brr = [ 0 for i in range ( len ( arr ) ) ] NEW_LINE l = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( freq [ arr [ i ] ] > 0 ) : NEW_LINE INDENT brr [ l ] = arr [ i ] NEW_LINE freq [ brr [ l ] ] -= 1 NEW_LINE l += 1 NEW_LINE for j in range ( l ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT x = gcd ( arr [ i ] , brr [ j ] ) NEW_LINE freq [ x ] -= 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT printArr ( brr , size ) NEW_LINE DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def merge_and_sort ( output , arr , n , k ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT output [ i * n + j ] = arr [ i ] [ j ] NEW_LINE DEDENT DEDENT output . sort ( ) NEW_LINE DEDENT
def AlternateRearrange ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT v1 . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT index = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE flag = False NEW_LINE if ( arr [ 0 ] % 2 == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT while ( index < n ) : NEW_LINE INDENT if ( flag == True and i < len ( v1 ) ) : NEW_LINE INDENT arr [ index ] = v1 [ i ] NEW_LINE index += 1 NEW_LINE i += 1 NEW_LINE flag = ~ flag NEW_LINE DEDENT elif j < len ( v2 ) : NEW_LINE INDENT arr [ index ] = v2 [ j ] NEW_LINE index += 1 NEW_LINE j += 1 NEW_LINE flag = ~ flag NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE DEDENT DEDENT
def getNumToAdd ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE numToAdd = - 1 NEW_LINE numAdded = False NEW_LINE for i in range ( 2 , n , 1 ) : NEW_LINE INDENT diff = arr [ i ] - arr [ i - 1 ] NEW_LINE if ( diff != d ) : NEW_LINE INDENT if ( numAdded ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( diff == 2 * d ) : NEW_LINE INDENT numToAdd = arr [ i ] - d NEW_LINE numAdded = True NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT if ( numToAdd == - 1 ) : NEW_LINE INDENT return ( arr [ n - 1 ] + d ) NEW_LINE DEDENT return numToAdd NEW_LINE DEDENT
def PointInKSquares ( n , a , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return a [ n - k ] NEW_LINE DEDENT
def maxArrayCover ( a , n , x ) : NEW_LINE INDENT a . sort ( ) NEW_LINE cc = 0 NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += a [ i ] NEW_LINE if ( s > x ) : NEW_LINE INDENT break NEW_LINE DEDENT cc += 1 NEW_LINE DEDENT if ( sum ( a ) == x ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT if ( cc == n ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return cc NEW_LINE DEDENT DEDENT DEDENT
def findMaxNum ( arr , n ) : NEW_LINE INDENT arr . sort ( rever num = arr [ 0 ] se = True ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT num = num * 10 + arr [ i ] NEW_LINE DEDENT return num NEW_LINE DEDENT
def sort ( arr , n ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 999 ) : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( index == - 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT sortRec ( arr , index , n , n ) NEW_LINE DEDENT
def merge ( arr1 , arr2 , n , m ) : NEW_LINE INDENT gap = n + m NEW_LINE gap = nextGap ( gap ) NEW_LINE while gap > 0 : NEW_LINE INDENT i = 0 NEW_LINE while i + gap < n : NEW_LINE INDENT if ( arr1 [ i ] > arr1 [ i + gap ] ) : NEW_LINE INDENT arr1 [ i ] , arr1 [ i + gap ] = arr1 [ i + gap ] , arr1 [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT j = gap - n if gap > n else 0 NEW_LINE while i < n and j < m : NEW_LINE INDENT if ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT arr1 [ i ] , arr2 [ j ] = arr2 [ j ] , arr1 [ i ] NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT if ( j < m ) : NEW_LINE INDENT j = 0 NEW_LINE while j + gap < m : NEW_LINE INDENT if ( arr2 [ j ] > arr2 [ j + gap ] ) : NEW_LINE INDENT arr2 [ j ] , arr2 [ j + gap ] = arr2 [ j + gap ] , arr2 [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT gap = nextGap ( gap ) NEW_LINE DEDENT DEDENT
def _mergeSort ( arr , temp , left , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if right > left : NEW_LINE INDENT mid = ( right + left ) // 2 NEW_LINE inv_count = _mergeSort ( arr , temp , left , mid ) NEW_LINE inv_count += _mergeSort ( arr , temp , mid + 1 , right ) NEW_LINE inv_count += merge ( arr , temp , left , mid + 1 , right ) NEW_LINE DEDENT return inv_count NEW_LINE DEDENT
def printSorted ( a , b , c ) : NEW_LINE INDENT get_max = max ( a , max ( b , c ) ) NEW_LINE get_min = - max ( - a , max ( - b , - c ) ) NEW_LINE get_mid = ( a + b + c ) - ( get_max + get_min ) NEW_LINE print ( get_min , " " , get_mid , " " , get_max ) NEW_LINE DEDENT
def countSwaps ( arr , n ) : NEW_LINE INDENT temp = [ 0 for i in range ( n ) ] NEW_LINE return _mergeSort ( arr , temp , 0 , n - 1 ) NEW_LINE DEDENT
def pancakeSort ( arr , n ) : NEW_LINE INDENT curr_size = n NEW_LINE while curr_size > 1 : NEW_LINE INDENT mi = findMax ( arr , curr_size ) NEW_LINE if mi != curr_size - 1 : NEW_LINE INDENT flip ( arr , mi ) NEW_LINE flip ( arr , curr_size - 1 ) NEW_LINE DEDENT curr_size -= 1 NEW_LINE DEDENT DEDENT
def largestMerge ( word1 , word2 ) : NEW_LINE INDENT merge = "" NEW_LINE while len ( word1 ) != 0 or len ( word2 ) != 0 : NEW_LINE INDENT if word1 >= word2 : NEW_LINE INDENT merge = merge + word1 [ 0 ] NEW_LINE word1 = word1 [ 1 : ] NEW_LINE DEDENT else : NEW_LINE INDENT merge = merge + word2 [ 0 ] NEW_LINE word2 = word2 [ 1 : ] NEW_LINE DEDENT DEDENT return merge NEW_LINE DEDENT
def find ( arr , N ) : NEW_LINE INDENT Sum = sum ( arr ) NEW_LINE if Sum % N : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = Sum // N NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE while i < N : NEW_LINE INDENT ans = ans + abs ( k - arr [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return ans // 2 NEW_LINE DEDENT DEDENT
def maxXORUtil ( arr , N , xrr , orr ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return xrr ^ orr NEW_LINE DEDENT x = maxXORUtil ( arr , N - 1 , xrr ^ orr , arr [ N - 1 ] ) NEW_LINE y = maxXORUtil ( arr , N - 1 , xrr , orr arr [ N - 1 ] ) NEW_LINE return max ( x , y ) NEW_LINE DEDENT
def maximumXOR ( arr , N ) : NEW_LINE INDENT return maxXORUtil ( arr , N , 0 , 0 ) NEW_LINE DEDENT
def findEquation ( S , M ) : NEW_LINE INDENT print ( "1 " , ( ( - 1 ) * S ) , " " , M ) NEW_LINE DEDENT
def isPalindrome ( N ) : NEW_LINE INDENT temp = N NEW_LINE res = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT rem = temp % 10 NEW_LINE res = res * 10 + rem NEW_LINE temp //= 10 NEW_LINE DEDENT if ( res == N ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def minSteps ( a , n ) : NEW_LINE INDENT prefix_sum = a [ : ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix_sum [ i ] += prefix_sum [ i - 1 ] NEW_LINE DEDENT mx = - 1 NEW_LINE for subgroupsum in prefix_sum : NEW_LINE INDENT sum = 0 NEW_LINE i = 0 NEW_LINE grp_count = 0 NEW_LINE while i < n : NEW_LINE INDENT sum += a [ i ] NEW_LINE if sum == subgroupsum : NEW_LINE INDENT grp_count += 1 NEW_LINE sum = 0 NEW_LINE DEDENT elif sum > subgroupsum : NEW_LINE INDENT grp_count = - 1 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if grp_count > mx : NEW_LINE INDENT mx = grp_count NEW_LINE DEDENT DEDENT return n - mx NEW_LINE DEDENT
def findSubseq ( A , B , K , i ) : NEW_LINE INDENT ans = [ ] NEW_LINE findSubseqUtil ( A , B , ans , K , i ) NEW_LINE if not ans : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def MinimumCost ( A , B , N ) : NEW_LINE INDENT totalCost = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT mod_A = B [ i ] % A [ i ] NEW_LINE totalCost_A = min ( mod_A , A [ i ] - mod_A ) NEW_LINE mod_B = A [ i ] % B [ i ] NEW_LINE totalCost_B = min ( mod_B , B [ i ] - mod_B ) NEW_LINE totalCost += min ( totalCost_A , totalCost_B ) NEW_LINE DEDENT return totalCost NEW_LINE DEDENT
def longestSubarray ( arr , N , K ) : NEW_LINE INDENT um = { } NEW_LINE sum , maxLen = 0 , 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE if ( sum == K ) : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT if ( sum not in um ) : NEW_LINE INDENT um [ sum ] = i NEW_LINE DEDENT if ( ( sum - K ) in um ) : NEW_LINE INDENT if ( maxLen < ( i - um [ sum - K ] ) ) : NEW_LINE INDENT maxLen = i - um [ sum - K ] NEW_LINE DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT
def findArrayWithMaxProduct ( arr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] >= 0 ) : NEW_LINE INDENT arr [ i ] = - arr [ i ] - 1 NEW_LINE DEDENT DEDENT if ( N % 2 == 1 ) : NEW_LINE INDENT max_element = - 1 NEW_LINE index = - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) > max_element ) : NEW_LINE INDENT max_element = abs ( arr [ i ] ) NEW_LINE index = i NEW_LINE DEDENT DEDENT arr [ index ] = - arr [ index ] - 1 NEW_LINE DEDENT for i in arr : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT
def maximumCandy ( candies , safety , N , M ) : NEW_LINE INDENT total = 0 NEW_LINE ans = 10 ** 8 NEW_LINE all_safe = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( candies [ i ] + M > safety [ i ] ) : NEW_LINE INDENT all_safe = False NEW_LINE ans = min ( ans , safety [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = min ( ans , candies [ i ] + M ) NEW_LINE DEDENT total += candies [ i ] NEW_LINE DEDENT if ( all_safe ) : NEW_LINE INDENT return total NEW_LINE DEDENT else : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT
def canArrayBeReduced ( arr , N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT print ( arr [ 0 ] ) NEW_LINE return NEW_LINE DEDENT if ( arr [ 0 ] < arr [ N - 1 ] ) : NEW_LINE INDENT print ( arr [ N - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Not Possible" ) NEW_LINE DEDENT DEDENT
def maxValueAtIndexK ( N , K , M ) : NEW_LINE INDENT S1 = 0 NEW_LINE S2 = 0 NEW_LINE S1 = K * ( K + 1 ) // 2 NEW_LINE S2 = ( N - K - 1 ) * ( N - K ) // 2 NEW_LINE X = ( M + S1 + S2 ) // N NEW_LINE print ( X ) NEW_LINE DEDENT
def countEvenPairs ( N , M ) : NEW_LINE INDENT count = 0 NEW_LINE nEven = int ( math . floor ( N / 2 ) ) NEW_LINE nOdd = int ( math . ceil ( N / 2 ) ) NEW_LINE mEven = int ( math . floor ( M / 2 ) ) NEW_LINE mOdd = int ( math . ceil ( M / 2 ) ) NEW_LINE count = nEven * mEven + nOdd * mOdd NEW_LINE return count NEW_LINE DEDENT
def findNums ( X , Y ) : NEW_LINE INDENT A = 0 NEW_LINE B = 0 NEW_LINE if ( X < Y ) : NEW_LINE INDENT A = - 1 NEW_LINE B = - 1 NEW_LINE DEDENT elif ( ( ( abs ( X - Y ) ) & 1 ) != 0 ) : NEW_LINE INDENT A = - 1 NEW_LINE B = - 1 NEW_LINE DEDENT elif ( X == Y ) : NEW_LINE INDENT A = 0 NEW_LINE B = Y NEW_LINE DEDENT else : NEW_LINE INDENT A = ( X - Y ) // 2 NEW_LINE if ( ( A & Y ) == 0 ) : NEW_LINE INDENT B = ( A + Y ) NEW_LINE DEDENT else : NEW_LINE INDENT A = - 1 NEW_LINE B = - 1 NEW_LINE DEDENT DEDENT print A NEW_LINE print B NEW_LINE DEDENT
def findPartition ( nums , N ) : NEW_LINE INDENT prefix = [ 0 ] * N NEW_LINE suffix = [ 0 ] * N NEW_LINE prefix [ 0 ] = nums [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT prefix [ i ] = ( prefix [ i - 1 ] * nums [ i ] ) NEW_LINE DEDENT suffix [ N - 1 ] = nums [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffix [ i ] = ( suffix [ i + 1 ] * nums [ i ] ) NEW_LINE DEDENT for k in range ( N - 1 ) : NEW_LINE INDENT if ( GCD ( prefix [ k ] , suffix [ k + 1 ] ) == 1 ) : NEW_LINE INDENT return k NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def palindromeMatrix ( N , M , arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( ( N + 1 ) // 2 ) : NEW_LINE INDENT for j in range ( ( M + 1 ) // 2 ) : NEW_LINE INDENT s = { } NEW_LINE s [ ( i , j ) ] = 1 NEW_LINE s [ ( i , M - j - 1 ) ] = 1 NEW_LINE s [ ( N - i - 1 , j ) ] = 1 NEW_LINE s [ ( N - i - 1 , M - j - 1 ) ] = 1 NEW_LINE values = [ ] NEW_LINE for p , q in s : NEW_LINE INDENT values . append ( arr [ p ] [ q ] ) NEW_LINE DEDENT maxm = max ( values ) NEW_LINE for k in range ( len ( values ) ) : NEW_LINE INDENT ans += maxm - values [ k ] NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT
def MinOperation ( arr , N , K ) : NEW_LINE INDENT cntOpe = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( K > arr [ i ] ) : NEW_LINE INDENT if ( ( K - arr [ i ] ) % 2 == 0 ) : NEW_LINE INDENT cntOpe += 2 NEW_LINE DEDENT else : NEW_LINE INDENT cntOpe += 1 NEW_LINE DEDENT DEDENT elif ( K < arr [ i ] ) : NEW_LINE INDENT if ( ( K - arr [ i ] ) % 2 == 0 ) : NEW_LINE INDENT cntOpe += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntOpe += 2 NEW_LINE DEDENT DEDENT DEDENT return cntOpe NEW_LINE DEDENT
def printSmallSub ( arr , N ) : NEW_LINE INDENT gcdArr = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT gcdArr = math . gcd ( gcdArr , arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT if ( arr [ i ] == gcdArr ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( math . gcd ( arr [ i ] , arr [ j ] ) == gcdArr ) : NEW_LINE INDENT print ( arr [ i ] , end = " " ) NEW_LINE print ( arr [ j ] , end = " " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def smlstNonNeg ( arr , N ) : NEW_LINE INDENT smNonNeg = 0 NEW_LINE hash = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] >= 0 and arr [ i ] < N ) : NEW_LINE INDENT hash [ arr [ i ] ] = True NEW_LINE DEDENT while ( hash [ smNonNeg ] ) : NEW_LINE INDENT smNonNeg += 1 NEW_LINE DEDENT print ( smNonNeg , end = " " ) NEW_LINE DEDENT DEDENT
def numberOfWays ( N ) : NEW_LINE INDENT count = count_of_primes [ N ] - 1 NEW_LINE mod = 1000000007 NEW_LINE answer = power ( 2 , count , mod ) NEW_LINE if N == 1 : NEW_LINE INDENT answer = 0 NEW_LINE DEDENT print ( answer ) NEW_LINE DEDENT
def cntPairs ( arr , N ) : NEW_LINE INDENT isPrime = getPrimeNum ( ) NEW_LINE cntOne = 0 NEW_LINE cntPrime = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT cntOne += 1 NEW_LINE DEDENT elif ( isPrime [ i ] ) : NEW_LINE INDENT cntPrime += 1 NEW_LINE DEDENT DEDENT cntNonComp = 0 NEW_LINE cntNonComp = ( cntPrime * cntOne + cntOne * ( cntOne - 1 ) // 2 ) NEW_LINE res = 0 NEW_LINE res = ( N * ( N - 1 ) // 2 - cntNonComp ) NEW_LINE return res NEW_LINE DEDENT
def printArray ( brr ) : NEW_LINE INDENT for it in brr : NEW_LINE INDENT print ( it , end = ' ' ) NEW_LINE DEDENT DEDENT
def MinimumFlips ( s , n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = 1 if s [ i ] == '1' else 0 NEW_LINE DEDENT oddone = [ 0 ] * ( n + 1 ) NEW_LINE evenone = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT oddone [ i + 1 ] = oddone [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT oddone [ i + 1 ] = oddone [ i ] + 0 NEW_LINE DEDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT evenone [ i + 1 ] = evenone [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT evenone [ i + 1 ] = evenone [ i ] + 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT oddone [ i + 1 ] = oddone [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT oddone [ i + 1 ] = oddone [ i ] + 0 NEW_LINE DEDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT evenone [ i + 1 ] = evenone [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT evenone [ i + 1 ] = evenone [ i ] + 0 NEW_LINE DEDENT DEDENT DEDENT minimum = min ( oddone [ n ] , evenone [ n ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT minimum = min ( minimum , oddone [ n ] - oddone [ i + 1 ] + evenone [ i + 1 ] ) NEW_LINE minimum = min ( minimum , evenone [ n ] - evenone [ i + 1 ] + oddone [ i + 1 ] ) NEW_LINE DEDENT DEDENT return minimum NEW_LINE DEDENT
def shortestpath ( m , n ) : NEW_LINE INDENT mfactor = [ ] NEW_LINE nfactor = [ ] NEW_LINE fre = dict . fromkeys ( range ( n + 1 ) , 0 ) NEW_LINE mfactor . append ( m ) NEW_LINE fre [ m ] = 1 NEW_LINE while ( m != 1 ) : NEW_LINE INDENT if ( isprm ( m ) ) : NEW_LINE INDENT mfactor . append ( 1 ) NEW_LINE fre [ 1 ] = 1 NEW_LINE m = 1 NEW_LINE DEDENT else : NEW_LINE INDENT sqt = ( int ) ( math . sqrt ( m ) ) NEW_LINE for i in range ( 2 , sqt + 1 ) : NEW_LINE INDENT if ( m % i == 0 ) : NEW_LINE INDENT mfactor . append ( m // i ) NEW_LINE fre [ m // i ] = 1 NEW_LINE m = ( m // i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT nfactor . append ( n ) NEW_LINE while ( fre [ n ] != 1 ) : NEW_LINE INDENT if ( isprm ( n ) ) : NEW_LINE INDENT nfactor . append ( 1 ) NEW_LINE n = 1 NEW_LINE DEDENT else : NEW_LINE INDENT sqt = ( int ) ( math . sqrt ( n ) ) NEW_LINE for i in range ( 2 , sqt + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT nfactor . append ( n // i ) NEW_LINE n = ( n // i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( len ( mfactor ) ) : NEW_LINE INDENT if ( mfactor [ i ] == n ) : NEW_LINE INDENT break NEW_LINE DEDENT print ( mfactor [ i ] , end = " <--> " ) NEW_LINE DEDENT for i in range ( len ( nfactor ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT print ( nfactor [ i ] , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( nfactor [ i ] , end = " <--> " ) NEW_LINE DEDENT DEDENT DEDENT
def factorial ( N ) : NEW_LINE INDENT if N <= 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT fact = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = ( fact * i ) % Mod NEW_LINE DEDENT return fact NEW_LINE DEDENT
def noOfFactors ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT count = 0 NEW_LINE ans = 1 NEW_LINE while ( N % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE N = N // 2 NEW_LINE DEDENT ans *= ( count // 2 + 1 ) NEW_LINE i = 3 NEW_LINE while i * i <= N : NEW_LINE INDENT count = 0 NEW_LINE while ( N % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE N = N // i NEW_LINE DEDENT ans *= ( count // 2 + 1 ) NEW_LINE i += 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minCost ( N , M , vCost , eCost , sorc , colored , destination ) : NEW_LINE INDENT adj = [ [ ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT adj [ sorc [ i ] ] . append ( destination [ i ] ) NEW_LINE adj [ destination [ i ] ] . append ( sorc [ i ] ) NEW_LINE DEDENT vis = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( len ( colored ) ) : NEW_LINE INDENT DFS ( colored [ i ] , vis , adj ) NEW_LINE DEDENT X = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( vis [ i ] == 0 ) : NEW_LINE INDENT X += 1 NEW_LINE DFS ( i , vis , adj ) NEW_LINE DEDENT DEDENT mincost = X * min ( vCost , eCost ) NEW_LINE print ( mincost ) NEW_LINE DEDENT
def power ( N , P ) : NEW_LINE INDENT return math . pow ( N , P ) NEW_LINE DEDENT
def Solve ( N , M ) : NEW_LINE INDENT temp = ( N - 1 ) * ( M - 1 ) NEW_LINE ans = pow ( 2 , temp ) NEW_LINE if ( ( N + M ) % 2 != 0 ) : NEW_LINE INDENT print ( ans ) NEW_LINE else : print ( 2 * ans ) NEW_LINE if __name__ == '__main__' : NEW_LINE INDENT N , M = 3 , 3 NEW_LINE Solve ( N , M ) NEW_LINE DEDENT DEDENT DEDENT
def findMaximumLength ( lis ) : NEW_LINE INDENT global id , length , diameter NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE id += 1 NEW_LINE length = 0 NEW_LINE diameter = 0 NEW_LINE for i in range ( row ) : NEW_LINE INDENT for j in range ( col ) : NEW_LINE INDENT if ( lis [ i ] [ j ] != 0 ) : NEW_LINE INDENT x , y = dfs ( i , j , lis , x , y ) NEW_LINE i = row NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT id += 1 NEW_LINE length = 0 NEW_LINE diameter = 0 NEW_LINE x , y = dfs ( x , y , lis , x , y ) NEW_LINE print ( diameter ) NEW_LINE DEDENT
def maxModulosum ( a , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE DEDENT return sum1 - n NEW_LINE DEDENT
def noOfPermutations ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT a . sort ( ) NEW_LINE if ( a [ n - 1 ] == a [ n - 2 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT x = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 2 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT x += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return pow ( 2 , n - 2 * x - 1 ) NEW_LINE DEDENT
def maxValue ( arr , n , moves ) : NEW_LINE INDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT distance = n - 1 - i NEW_LINE if ( moves < distance ) : NEW_LINE INDENT break NEW_LINE DEDENT can_take = moves // distance NEW_LINE take = min ( arr [ i ] , can_take ) NEW_LINE arr [ n - 1 ] += take NEW_LINE moves -= take * distance NEW_LINE DEDENT DEDENT return arr [ n - 1 ] NEW_LINE DEDENT
def hasCrest ( arr , n , L , R ) : NEW_LINE INDENT present = [ 0 ] * n NEW_LINE for i in range ( 1 , n - 2 + 1 ) : NEW_LINE INDENT if ( ( arr [ i ] <= arr [ i + 1 ] ) and ( arr [ i ] <= arr [ i - 1 ] ) ) : NEW_LINE INDENT present [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT present [ i ] += present [ i - 1 ] NEW_LINE DEDENT if ( present [ L ] == present [ R - 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def getMin ( arr , n ) : NEW_LINE INDENT minVal = min ( arr ) NEW_LINE return minVal NEW_LINE DEDENT
def Substring ( s ) : NEW_LINE INDENT ans , temp = 1 , 1 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT temp += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , temp ) NEW_LINE temp = 1 NEW_LINE DEDENT DEDENT ans = max ( ans , temp ) NEW_LINE return ans NEW_LINE DEDENT
def countOp ( x ) : NEW_LINE INDENT arr = [ 0 ] * MAX NEW_LINE arr [ 0 ] = 1 NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] * 2 NEW_LINE DEDENT temp = x NEW_LINE flag = True NEW_LINE ans = 0 NEW_LINE operations = 0 NEW_LINE flag2 = False NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( arr [ i ] - 1 == x ) : NEW_LINE INDENT flag2 = True NEW_LINE DEDENT if ( arr [ i ] > x ) : NEW_LINE INDENT ans = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( flag ) : NEW_LINE INDENT if ( arr [ ans ] < x ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT operations += 1 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT take = x ^ ( arr [ i ] - 1 ) NEW_LINE if ( take <= arr [ ans ] - 1 ) : NEW_LINE INDENT if ( take > temp ) : NEW_LINE INDENT temp = take NEW_LINE DEDENT DEDENT DEDENT if ( temp == arr [ ans ] - 1 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT temp += 1 NEW_LINE operations += 1 NEW_LINE x = temp NEW_LINE if ( x == arr [ ans ] - 1 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT return operations NEW_LINE DEDENT
def getMinSum ( arr , n ) : NEW_LINE INDENT bits_count = [ 0 ] * MAX NEW_LINE max_bit = 0 NEW_LINE sum = 0 NEW_LINE ans = 0 NEW_LINE for d in range ( n ) : NEW_LINE INDENT e = arr [ d ] NEW_LINE f = 0 NEW_LINE while ( e > 0 ) : NEW_LINE INDENT rem = e % 2 NEW_LINE e = e // 2 NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT bits_count [ f ] += rem NEW_LINE DEDENT f += 1 NEW_LINE DEDENT max_bit = max ( max_bit , f ) NEW_LINE DEDENT for d in range ( max_bit ) : NEW_LINE INDENT temp = pow ( 2 , d ) NEW_LINE if ( bits_count [ d ] > n // 2 ) : NEW_LINE INDENT ans = ans + temp NEW_LINE DEDENT DEDENT for d in range ( n ) : NEW_LINE INDENT arr [ d ] = arr [ d ] ^ ans NEW_LINE sum = sum + arr [ d ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def replacedArray ( N , arr ) : NEW_LINE INDENT pos_sum = 0 NEW_LINE neg_sum = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT diff = abs ( pos_sum ) - abs ( neg_sum ) NEW_LINE if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos_sum = pos_sum + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT neg_sum = neg_sum + arr [ i ] NEW_LINE DEDENT arr [ i ] = abs ( diff ) NEW_LINE DEDENT DEDENT
def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE ans += n * int ( a / n ) * int ( b / n ) NEW_LINE ans += int ( a / n ) * ( b % n ) NEW_LINE ans += ( a % n ) * int ( b / n ) NEW_LINE ans += int ( ( ( a % n ) + ( b % n ) ) / n ) NEW_LINE return ans NEW_LINE DEDENT
def minChanges ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( ( i - 1 >= 0 ) and A [ i - 1 ] == 1 and A [ i + 1 ] == 1 and A [ i ] == 0 ) : NEW_LINE INDENT A [ i + 1 ] = 0 NEW_LINE cnt = cnt + 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def solve ( v , n ) : NEW_LINE INDENT ans = 0 NEW_LINE ul = 0 NEW_LINE ll = 0 NEW_LINE ll = v [ 0 ] . first NEW_LINE ul = v [ 0 ] . second NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( v [ i ] . first <= ul and v [ i ] . first >= ll ) or ( v [ i ] . second >= ll and v [ i ] . second <= ul ) : NEW_LINE INDENT if v [ i ] . first > ll : NEW_LINE INDENT ll = v [ i ] . first NEW_LINE DEDENT if v [ i ] . second < ul : NEW_LINE INDENT ul = v [ i ] . second NEW_LINE DEDENT DEDENT elif v [ i ] . first > ul : NEW_LINE INDENT ans += abs ( ul - v [ i ] . first ) NEW_LINE ul = v [ i ] . first NEW_LINE ll = v [ i ] . first NEW_LINE DEDENT elif v [ i ] . second < ll : NEW_LINE INDENT ans += abs ( ll - v [ i ] . second ) NEW_LINE ul = v [ i ] . second NEW_LINE ll = v [ i ] . second NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def steps ( N , M ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( N == 2 ) : NEW_LINE INDENT return M NEW_LINE DEDENT return 2 * M + ( N - 3 ) NEW_LINE DEDENT
def dfs ( w ) : NEW_LINE INDENT global ans NEW_LINE if ( cd [ w ] == 0 ) : NEW_LINE INDENT return w NEW_LINE DEDENT if ( wt [ w ] < ans ) : NEW_LINE INDENT ans = wt [ w ] NEW_LINE DEDENT return dfs ( cd [ w ] ) NEW_LINE DEDENT
def digitsNum ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT print ( "0" , end = "" ) NEW_LINE DEDENT if ( N % 9 != 0 ) : NEW_LINE INDENT print ( N % 9 , end = "" ) NEW_LINE DEDENT for i in range ( 1 , int ( N / 9 ) + 1 ) : NEW_LINE INDENT print ( "9" , end = "" ) NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( "0" , end = "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def bestpermutation ( arr , k , n ) : NEW_LINE INDENT h = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT h [ arr [ i ] ] = i NEW_LINE DEDENT if ( n <= k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE arr . reverse ( ) NEW_LINE DEDENT else : NEW_LINE INDENT for j in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( k > 0 ) : NEW_LINE INDENT initial_index = h [ j ] NEW_LINE best_index = n - j NEW_LINE if ( initial_index != best_index ) : NEW_LINE INDENT h [ j ] = best_index NEW_LINE element = arr [ best_index ] NEW_LINE h [ element ] = initial_index NEW_LINE arr [ best_index ] , arr [ initial_index ] = ( arr [ initial_index ] , arr [ best_index ] ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
def sumArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def firstFit ( weight , n , c ) : NEW_LINE INDENT res = 0 NEW_LINE bin_rem = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < res ) : NEW_LINE INDENT if ( bin_rem [ j ] >= weight [ i ] ) : NEW_LINE INDENT bin_rem [ j ] = bin_rem [ j ] - weight [ i ] NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == res ) : NEW_LINE INDENT bin_rem [ res ] = c - weight [ i ] NEW_LINE res = res + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def find ( A , B , C , N ) : NEW_LINE INDENT arr = [ 0 ] * N NEW_LINE arr [ 0 ] = A NEW_LINE arr [ 1 ] = B NEW_LINE arr [ 2 ] = C NEW_LINE for i in range ( 3 , N ) : NEW_LINE INDENT arr [ i ] = ( arr [ i - 1 ] + arr [ i - 2 ] + arr [ i - 3 ] ) NEW_LINE DEDENT return arr [ N - 1 ] NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT r1 = r2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT r1 , r2 = max ( r1 , r2 + arr [ 0 ] [ i ] ) , max ( r2 , r1 + arr [ 1 ] [ i ] ) NEW_LINE DEDENT print ( max ( r1 , r2 ) ) NEW_LINE DEDENT
def countMinCoins ( n , C , m ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT dp [ 0 ] = 0 NEW_LINE return 0 NEW_LINE DEDENT if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT ret = sys . maxsize NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( C [ i ] <= n ) : NEW_LINE INDENT x = countMinCoins ( n - C [ i ] , C , m ) NEW_LINE if ( x != sys . maxsize ) : NEW_LINE INDENT ret = min ( ret , 1 + x ) NEW_LINE DEDENT DEDENT DEDENT dp [ n ] = ret NEW_LINE return ret NEW_LINE DEDENT
def findSolution ( n , C , m ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT for it in denomination : NEW_LINE INDENT print ( it , end = " " ) NEW_LINE DEDENT return NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( n - C [ i ] >= 0 and dp [ n - C [ i ] ] + 1 == dp [ n ] ) : NEW_LINE INDENT denomination . append ( C [ i ] ) NEW_LINE findSolution ( n - C [ i ] , C , m ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
def count_unique_sum ( n ) : NEW_LINE INDENT ar = [ 0 ] * ( n + 1 ) NEW_LINE fsum = [ 0 ] * ( n + 1 ) NEW_LINE rsum = [ 0 ] * ( n + 1 ) NEW_LINE ans = 1 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT ar [ i ] = i NEW_LINE DEDENT fsum [ 0 ] = ar [ 0 ] NEW_LINE rsum [ n ] = ar [ n ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fsum [ i ] = ar [ i ] + fsum [ i - 1 ] NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT rsum [ i ] = ar [ i ] + rsum [ i + 1 ] NEW_LINE DEDENT for k in range ( 2 , n + 1 ) : NEW_LINE INDENT ans += ( 1 + rsum [ n + 1 - k ] - fsum [ k - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def precompute ( nextpos , arr , N ) : NEW_LINE INDENT nextpos [ N - 1 ] = N NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT nextpos [ i ] = nextpos [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT nextpos [ i ] = i + 1 NEW_LINE DEDENT DEDENT DEDENT
def fun ( pos , sum , st , check , f ) : NEW_LINE INDENT global N NEW_LINE global v NEW_LINE if ( pos == N ) : NEW_LINE INDENT return ( sum == 0 and check == 1 ) NEW_LINE DEDENT if ( dp [ pos ] [ sum ] [ st ] [ check ] [ f ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ sum ] [ st ] [ check ] [ f ] NEW_LINE DEDENT lmt = 9 NEW_LINE if ( f == False ) : NEW_LINE INDENT lmt = v [ pos ] NEW_LINE DEDENT ans = 0 NEW_LINE for digit in range ( lmt + 1 ) : NEW_LINE INDENT nf = f NEW_LINE new_sum = ( sum + digit ) % K NEW_LINE new_check = check NEW_LINE new_st = st NEW_LINE if ( f == 0 and digit < lmt ) : NEW_LINE INDENT nf = 1 NEW_LINE DEDENT if ( check == 0 and digit != 0 ) : NEW_LINE INDENT new_st = digit NEW_LINE new_check = 1 NEW_LINE DEDENT if ( pos == N - 1 and new_st == digit ) : NEW_LINE INDENT continue NEW_LINE DEDENT ans += fun ( pos + 1 , new_sum , new_st , new_check , nf ) NEW_LINE dp [ pos ] [ sum ] [ st ] [ check ] [ f ] = ans NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minSumProd ( S , K ) : NEW_LINE INDENT Len = len ( S ) NEW_LINE if ( K > Len ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( K == Len ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp = [ 0 ] * Len NEW_LINE count_zero = 0 NEW_LINE count_one = 0 NEW_LINE for j in range ( 0 , Len , 1 ) : NEW_LINE INDENT if ( S [ j ] == '0' ) : NEW_LINE INDENT count_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_one += 1 NEW_LINE DEDENT dp [ j ] = count_zero * count_one NEW_LINE DEDENT for i in range ( 1 , K ) : NEW_LINE INDENT for j in range ( Len - 1 , i - 1 , - 1 ) : NEW_LINE INDENT count_zero = 0 NEW_LINE count_one = 0 NEW_LINE dp [ j ] = sys . maxsize NEW_LINE for k in range ( j , i - 1 , - 1 ) : NEW_LINE INDENT if ( S [ k ] == '0' ) : NEW_LINE INDENT count_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_one += 1 NEW_LINE DEDENT dp [ j ] = min ( dp [ j ] , count_zero * count_one + dp [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ Len - 1 ] NEW_LINE DEDENT
def countPairs ( arr , N ) : NEW_LINE INDENT maxm = max ( arr ) NEW_LINE i = 0 NEW_LINE k = 0 NEW_LINE bitscount = [ 0 for i in range ( maxm + 1 ) ] NEW_LINE i = 1 NEW_LINE while i <= maxm : NEW_LINE INDENT bitscount [ i ] = 1 NEW_LINE i *= 2 NEW_LINE DEDENT for i in range ( 1 , maxm + 1 ) : NEW_LINE INDENT if ( bitscount [ i ] == 1 ) : NEW_LINE INDENT k = i NEW_LINE DEDENT if ( bitscount [ i ] == 0 ) : NEW_LINE INDENT bitscount [ i ] = ( bitscount [ k ] + bitscount [ i - k ] ) NEW_LINE DEDENT DEDENT setbits = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if bitscount [ arr [ i ] ] in setbits : NEW_LINE INDENT setbits [ bitscount [ arr [ i ] ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT setbits [ bitscount [ arr [ i ] ] ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for it in setbits . values ( ) : NEW_LINE INDENT ans += it * ( it - 1 ) // 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def solve ( n , k , m ) : NEW_LINE INDENT if n == 0 and k == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 0 and k != 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n != 0 and k == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n < 0 or k < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ n ] [ k ] : NEW_LINE INDENT return dp [ n ] [ k ] NEW_LINE DEDENT ans = 0 NEW_LINE for j in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = ans + solve ( n - j , k - 1 , m ) NEW_LINE DEDENT dp [ n ] [ k ] = ans NEW_LINE return dp [ n ] [ k ] NEW_LINE DEDENT
def isprime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def productDigitSum ( x , y ) : NEW_LINE INDENT sumx = 0 NEW_LINE while x : NEW_LINE INDENT sumx += x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT sumy = 0 NEW_LINE while y : NEW_LINE INDENT sumy += y % 10 NEW_LINE y = y // 10 NEW_LINE DEDENT return sumx * sumy NEW_LINE DEDENT
def CountSets ( x , pos ) : NEW_LINE INDENT if ( x <= 0 ) : NEW_LINE INDENT if ( pos == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( pos == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ x ] [ pos ] != - 1 ) : NEW_LINE INDENT return dp [ x ] [ pos ] NEW_LINE DEDENT answer = ( CountSets ( x - 1 , pos ) + CountSets ( x - 2 , pos - 1 ) ) NEW_LINE dp [ x ] [ pos ] = answer NEW_LINE return answer NEW_LINE DEDENT
def splitIntoPrimes ( number ) : NEW_LINE INDENT if ( number == '' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( len ( number ) <= 6 and checkPrime ( number ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT numLen = len ( number ) NEW_LINE ans = 1000000 NEW_LINE for i in range ( 1 , ( min ( 6 , numLen ) + 1 ) ) : NEW_LINE INDENT if ( checkPrime ( number [ : i ] ) ) : NEW_LINE INDENT val = splitIntoPrimes ( number [ i : ] ) NEW_LINE if ( val != - 1 ) : NEW_LINE INDENT ans = min ( ans , 1 + val ) NEW_LINE DEDENT DEDENT DEDENT if ( ans == 1000000 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
def dp ( pos , fl , pr , bin ) : NEW_LINE INDENT if ( pos == len ( bin ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( memo [ pos ] [ fl ] [ pr ] != - 1 ) : NEW_LINE INDENT return memo [ pos ] [ fl ] [ pr ] NEW_LINE DEDENT val = 0 NEW_LINE if ( bin [ pos ] == '0' ) : NEW_LINE INDENT val = val + dp ( pos + 1 , fl , 0 , bin ) NEW_LINE DEDENT elif ( bin [ pos ] == '1' ) : NEW_LINE INDENT val = val + dp ( pos + 1 , 1 , 0 , bin ) NEW_LINE DEDENT if ( pr == 0 ) : NEW_LINE INDENT if ( fl == 1 ) : NEW_LINE INDENT val += dp ( pos + 1 , fl , 1 , bin ) NEW_LINE DEDENT elif ( bin [ pos ] == '1' ) : NEW_LINE INDENT val += dp ( pos + 1 , fl , 1 , bin ) NEW_LINE DEDENT DEDENT memo [ pos ] [ fl ] [ pr ] = val NEW_LINE return val NEW_LINE DEDENT
def TotalWays ( n , s , k ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ s - 1 ] = 1 NEW_LINE for i in range ( s , n ) : NEW_LINE INDENT idx = max ( s - 1 , i - k ) NEW_LINE for j in range ( idx , i ) : NEW_LINE INDENT dp [ i ] += dp [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT
def solve ( arr , n , i , pos ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( LAS [ i ] [ pos ] ) : NEW_LINE INDENT return LAS [ i ] [ pos ] NEW_LINE DEDENT inc = 0 NEW_LINE exc = 0 NEW_LINE if ( arr [ i ] > 0 and pos == True ) : NEW_LINE INDENT pos = False NEW_LINE inc = 1 + solve ( arr , n , i + 1 , pos ) NEW_LINE DEDENT elif ( arr [ i ] < 0 and pos == False ) : NEW_LINE INDENT pos = True NEW_LINE inc = 1 + solve ( arr , n , i + 1 , pos ) NEW_LINE DEDENT exc = solve ( arr , n , i + 1 , pos ) NEW_LINE LAS [ i ] [ pos ] = max ( inc , exc ) NEW_LINE return LAS [ i ] [ pos ] NEW_LINE DEDENT
def query ( In , l , r , l1 , r1 ) : NEW_LINE INDENT if ( l > r ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( r < l1 or l > r1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l1 <= l and r <= r1 ) : NEW_LINE INDENT return seg [ In ] NEW_LINE DEDENT m = ( l + r ) // 2 NEW_LINE return query ( 2 * In + 1 , l , m , l1 , r1 ) + query ( 2 * In + 2 , m + 1 , r , l1 , r1 ) NEW_LINE DEDENT
def minMergeCost ( i , j , arr ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] [ j ] ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT v [ i ] [ j ] = True NEW_LINE x = dp [ i ] [ j ] NEW_LINE x = sys . maxsize NEW_LINE tot = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT tot += arr [ k ] NEW_LINE DEDENT for k in range ( i + 1 , j + 1 ) : NEW_LINE INDENT x = min ( x , tot + minMergeCost ( i , k - 1 , arr ) + minMergeCost ( k , j , arr ) ) NEW_LINE DEDENT return x NEW_LINE DEDENT
def numberOfCells ( mat ) : NEW_LINE INDENT row = [ [ False for i in range ( N ) ] for i in range ( N ) ] NEW_LINE col = [ [ False for i in range ( N ) ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT if j + 1 < N : NEW_LINE INDENT row [ i ] [ j ] = row [ i ] [ j + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT row [ i ] [ j ] = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT row [ i ] [ j ] = False NEW_LINE DEDENT DEDENT DEDENT for j in range ( N ) : NEW_LINE INDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT if i + 1 < N : NEW_LINE INDENT col [ i ] [ j ] = col [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT col [ i ] [ j ] = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT col [ i ] [ j ] = False NEW_LINE DEDENT DEDENT DEDENT cnt = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT for j in range ( N - 1 ) : NEW_LINE INDENT if ( row [ i ] [ j ] and col [ i ] [ j ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if ( col [ i ] [ N - 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT for j in range ( N - 1 ) : NEW_LINE INDENT if ( row [ N - 1 ] [ j ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def subsequence ( S , T , n , m ) : NEW_LINE INDENT dp = np . zeros ( ( n + 1 , m + 1 ) ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] NEW_LINE if ( S [ i - 1 ] == T [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT dp [ i ] [ j ] += mod NEW_LINE dp [ i ] [ j ] %= mod NEW_LINE DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT
def findCount ( n ) : NEW_LINE INDENT return int ( math . log ( n , 2 ) ) + 1 NEW_LINE DEDENT
def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT v [ i ] [ curr ] = 1 NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) NEW_LINE r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) NEW_LINE dp [ i ] [ curr ] = l NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) NEW_LINE DEDENT return dp [ i ] [ curr ] NEW_LINE DEDENT
def findLen ( arr , i , curr , n , m ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT if ( curr == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if ( v [ i ] [ curr ] ) : NEW_LINE INDENT return dp [ i ] [ curr ] NEW_LINE DEDENT v [ i ] [ curr ] = 1 NEW_LINE l = findLen ( arr , i + 1 , curr , n , m ) NEW_LINE r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) NEW_LINE dp [ i ] [ curr ] = l NEW_LINE if ( r != - 1 ) : NEW_LINE INDENT dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) NEW_LINE DEDENT return dp [ i ] [ curr ] NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT
def findPath ( maze , xpos , ypos , key ) : NEW_LINE INDENT if xpos < 0 or xpos >= len ( maze ) or ypos < 0 or ypos >= len ( maze ) : NEW_LINE INDENT return False NEW_LINE DEDENT if maze [ xpos ] [ ypos ] == '1' : NEW_LINE INDENT if key == True : NEW_LINE INDENT if xpos == len ( maze ) - 1 and ypos == len ( maze ) - 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return findPath ( maze , xpos + 1 , ypos , False ) or findPath ( maze , xpos , ypos + 1 , False ) NEW_LINE DEDENT return False NEW_LINE DEDENT if xpos == len ( maze ) - 1 and ypos == len ( maze ) - 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return findPath ( maze , xpos + 1 , ypos , key ) or findPath ( maze , xpos , ypos + 1 , key ) NEW_LINE DEDENT
def findPrefixCount ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , bitscount ) : NEW_LINE INDENT prefix_count [ i ] [ 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT prefix_count [ i ] [ j ] = ( ( arr [ j ] >> i ) & 1 ) NEW_LINE prefix_count [ i ] [ j ] += prefix_count [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT
def countWays ( n , l , r ) : NEW_LINE INDENT tL , tR = l , r NEW_LINE L = [ 0 for i in range ( 2 ) ] NEW_LINE R = [ 0 for i in range ( 2 ) ] NEW_LINE L [ l % 2 ] = l NEW_LINE R [ r % 2 ] = r NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE if ( l <= tR and r >= tL ) : NEW_LINE INDENT L [ l % 2 ] , R [ r % 2 ] = l , r NEW_LINE DEDENT cnt0 , cnt1 = 0 , 0 NEW_LINE if ( R [ 0 ] and L [ 0 ] ) : NEW_LINE INDENT cnt0 = ( R [ 0 ] - L [ 0 ] ) // 2 + 1 NEW_LINE DEDENT if ( R [ 1 ] and L [ 1 ] ) : NEW_LINE INDENT cnt1 = ( R [ 1 ] - L [ 1 ] ) // 2 + 1 NEW_LINE DEDENT dp = [ [ 0 for i in range ( 2 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = cnt0 NEW_LINE dp [ 1 ] [ 1 ] = cnt1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( cnt0 * dp [ i - 1 ] [ 0 ] + cnt1 * dp [ i - 1 ] [ 1 ] ) NEW_LINE dp [ i ] [ 1 ] = ( cnt0 * dp [ i - 1 ] [ 1 ] + cnt1 * dp [ i - 1 ] [ 0 ] ) NEW_LINE DEDENT return dp [ n ] [ 0 ] NEW_LINE DEDENT
def dfs ( node , parent , dp1 , dp2 , adj ) : NEW_LINE INDENT firstmax , secondmax = - 1 , - 1 NEW_LINE DEDENT for i in adj [ node ] : NEW_LINE INDENT if i == parent : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( i , node , dp1 , dp2 , adj ) NEW_LINE if firstmax == - 1 : NEW_LINE INDENT firstmax = dp1 [ i ] NEW_LINE DEDENT DEDENT elif dp1 [ i ] >= firstmax : secondmax = firstmax NEW_LINE firstmax = dp1 [ i ] NEW_LINE secondmax = dp1 [ i ] NEW_LINE
def countRec ( start , end , dp , st ) : NEW_LINE INDENT sum = 0 NEW_LINE if ( start > end ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ start ] [ end ] != - 1 ) : NEW_LINE INDENT return dp [ start ] [ end ] NEW_LINE DEDENT r = 0 NEW_LINE for i in range ( start + 1 , end + 1 , 2 ) : NEW_LINE INDENT if ( checkFunc ( start , i , st ) ) : NEW_LINE INDENT sum = ( sum + countRec ( start + 1 , i - 1 , dp , st ) * countRec ( i + 1 , end , dp , st ) ) NEW_LINE DEDENT elif ( st [ start ] == '?' and st [ i ] == '?' ) : NEW_LINE INDENT sum = ( sum + countRec ( start + 1 , i - 1 , dp , st ) * countRec ( i + 1 , end , dp , st ) * 3 ) NEW_LINE DEDENT DEDENT dp [ start ] [ end ] = sum NEW_LINE return dp [ start ] [ end ] NEW_LINE DEDENT
def countWays ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE return countRec ( 0 , n - 1 , dp , st ) NEW_LINE DEDENT
def pre_compute ( a ) : NEW_LINE INDENT if a [ 0 ] [ 0 ] == 'a' : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for row in range ( n ) : NEW_LINE INDENT for col in range ( n ) : NEW_LINE INDENT if ( row != 0 or col != 0 ) : NEW_LINE INDENT dp [ row ] [ col ] = 9999 NEW_LINE DEDENT if ( row != 0 ) : NEW_LINE INDENT dp [ row ] [ col ] = min ( dp [ row ] [ col ] , dp [ row - 1 ] [ col ] ) NEW_LINE DEDENT if ( col != 0 ) : NEW_LINE INDENT dp [ row ] [ col ] = min ( dp [ row ] [ col ] , dp [ row ] [ col - 1 ] ) NEW_LINE DEDENT if ( a [ row ] [ col ] != 'a' and ( row != 0 or col != 0 ) ) : NEW_LINE INDENT dp [ row ] [ col ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
def CommomSubsequencesCount ( s , t ) : NEW_LINE INDENT n1 = len ( s ) NEW_LINE n2 = len ( t ) NEW_LINE dp = [ [ 0 for i in range ( n2 + 1 ) ] for i in range ( n1 + 1 ) ] NEW_LINE for i in range ( 1 , n1 + 1 ) : NEW_LINE INDENT for j in range ( 1 , n2 + 1 ) : NEW_LINE INDENT if ( s [ i - 1 ] == t [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = ( 1 + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] - dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n1 ] [ n2 ] NEW_LINE DEDENT
def lcs ( dp , a , b , m , n ) : NEW_LINE INDENT for i in range ( 100 ) : NEW_LINE INDENT for j in range ( 100 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT if ( m < 0 or n < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ m ] [ n ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( a [ m ] == b [ n ] ) : NEW_LINE INDENT ans = ( ord ( a [ m ] ) - 48 ) + lcs ( dp , a , b , m - 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( lcs ( dp , a , b , m - 1 , n ) , lcs ( dp , a , b , m , n - 1 ) ) NEW_LINE DEDENT dp [ m ] [ n ] = ans NEW_LINE return ans NEW_LINE DEDENT
def largestSumOfAverages ( A , K ) : NEW_LINE INDENT n = len ( A ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE memo [ i + 1 ] [ 1 ] = int ( sum / ( i + 1 ) ) NEW_LINE DEDENT return score ( n , A , K ) NEW_LINE DEDENT
def largestSumOfAverages ( A , K ) : NEW_LINE INDENT n = len ( A ) NEW_LINE pre_sum = [ 0 ] * ( n + 1 ) NEW_LINE pre_sum [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] NEW_LINE DEDENT dp = [ 0 ] * n NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) NEW_LINE DEDENT for k in range ( K - 1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return int ( dp [ 0 ] ) NEW_LINE DEDENT
def findMaxVal ( arr , n , num , maxLimit ) : NEW_LINE INDENT global ans NEW_LINE ind = 0 NEW_LINE findMaxValUtil ( arr , n , num , maxLimit , ind ) NEW_LINE return ans NEW_LINE DEDENT
def findMaxVal ( arr , n , num , maxLimit ) : NEW_LINE INDENT ind = - 1 NEW_LINE val = - 1 NEW_LINE dp = [ [ 0 for i in range ( maxLimit + 1 ) ] for j in range ( n ) ] NEW_LINE for ind in range ( n ) : NEW_LINE INDENT for val in range ( maxLimit + 1 ) : NEW_LINE INDENT if ( ind == 0 ) : NEW_LINE INDENT if ( num - arr [ ind ] == val or num + arr [ ind ] == val ) : NEW_LINE INDENT dp [ ind ] [ val ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ ind ] [ val ] = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( val - arr [ ind ] >= 0 and val + arr [ ind ] <= maxLimit ) : NEW_LINE INDENT if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 or dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) : NEW_LINE INDENT dp [ ind ] [ val ] = 1 NEW_LINE DEDENT DEDENT elif ( val - arr [ ind ] >= 0 ) : NEW_LINE INDENT dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] NEW_LINE DEDENT elif ( val + arr [ ind ] <= maxLimit ) : NEW_LINE INDENT dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ ind ] [ val ] = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT for val in range ( maxLimit , - 1 , - 1 ) : NEW_LINE INDENT if ( dp [ n - 1 ] [ val ] == 1 ) : NEW_LINE INDENT return val NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def gen ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT return 4 * gen ( n // 2 ) NEW_LINE DEDENT elif n % 2 == 1 : NEW_LINE INDENT return 4 * gen ( n // 2 ) + 1 NEW_LINE DEDENT DEDENT
def solve ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] = - 1 NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT nck [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT currLog2 = - 1 NEW_LINE currPower2 = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( currPower2 == i ) : NEW_LINE INDENT currLog2 += 1 NEW_LINE currPower2 *= 2 NEW_LINE DEDENT log2 [ i ] = currLog2 NEW_LINE DEDENT return numberOfHeaps ( n ) NEW_LINE DEDENT
def largestSubset ( a , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE dp [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT mxm = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ j ] % a [ i ] == 0 or a [ i ] % a [ j ] == 0 : NEW_LINE INDENT mxm = max ( mxm , dp [ j ] ) NEW_LINE DEDENT DEDENT dp [ i ] = 1 + mxm NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT
def maxLenSub ( arr , n ) : NEW_LINE INDENT mls = [ ] NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mls . append ( 1 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) : NEW_LINE INDENT mls [ i ] = mls [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < mls [ i ] ) : NEW_LINE INDENT max = mls [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def minimumNumberOfDeletions ( arr , n ) : NEW_LINE INDENT len = lis ( arr , n ) NEW_LINE return ( n - len ) NEW_LINE DEDENT
def countGroups ( position , previous_sum , length , num ) : NEW_LINE INDENT if ( position == length ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( position , length ) : NEW_LINE INDENT sum = sum + int ( num [ i ] ) NEW_LINE if ( sum >= previous_sum ) : NEW_LINE INDENT res = res + countGroups ( i + 1 , sum , length , num ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def lenOfLongestGP ( sett , n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return n NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return 2 if ( sett [ 1 ] % sett [ 0 ] == 0 ) else 1 NEW_LINE DEDENT sett . sort ( ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE llgp = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if sett [ n - 1 ] % sett [ i ] == 0 : NEW_LINE INDENT L [ i ] [ n - 1 ] = 2 NEW_LINE if 2 > llgp : NEW_LINE INDENT llgp = 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT L [ i ] [ n - 1 ] = 1 NEW_LINE DEDENT DEDENT L [ n - 1 ] [ n - 1 ] = 1 NEW_LINE for j in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while i >= 0 and k <= n - 1 : NEW_LINE INDENT if sett [ i ] * sett [ k ] < sett [ j ] * sett [ j ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif sett [ i ] * sett [ k ] > sett [ j ] * sett [ j ] : NEW_LINE INDENT if sett [ j ] % sett [ i ] == 0 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if sett [ j ] % sett [ i ] == 0 : NEW_LINE INDENT L [ i ] [ j ] = L [ j ] [ k ] + 1 NEW_LINE if L [ i ] [ j ] > llgp : NEW_LINE INDENT llgp = L [ i ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = 1 NEW_LINE DEDENT i -= 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT while i >= 0 : NEW_LINE INDENT if sett [ j ] % sett [ i ] == 0 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT return llgp NEW_LINE DEDENT
def findMinRec ( arr , i , sumCalculated , sumTotal ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT return abs ( ( sumTotal - sumCalculated ) - sumCalculated ) NEW_LINE DEDENT return min ( findMinRec ( arr , i - 1 , sumCalculated + arr [ i - 1 ] , sumTotal ) , findMinRec ( arr , i - 1 , sumCalculated , sumTotal ) ) NEW_LINE DEDENT
def findMin ( a , n ) : NEW_LINE INDENT su = 0 NEW_LINE su = sum ( a ) NEW_LINE dp = [ [ 0 for i in range ( su + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = True NEW_LINE DEDENT for j in range ( 1 , su + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = False NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , su + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE if a [ i - 1 ] <= j : NEW_LINE INDENT dp [ i ] [ j ] |= dp [ i - 1 ] [ j - a [ i - 1 ] ] NEW_LINE DEDENT DEDENT DEDENT diff = sys . maxsize NEW_LINE for j in range ( su // 2 , - 1 , - 1 ) : NEW_LINE INDENT if dp [ n ] [ j ] == True : NEW_LINE INDENT diff = su - ( 2 * j ) NEW_LINE break NEW_LINE DEDENT DEDENT return diff NEW_LINE DEDENT
def minSize ( arr , n , k ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE return minSizeRec ( arr , 0 , n - 1 , k ) NEW_LINE DEDENT
def minRemovals ( arr , l , h ) : NEW_LINE INDENT if ( l >= h ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT mn = mini ( arr , l , h ) NEW_LINE mx = max ( arr , l , h ) NEW_LINE if ( 2 * mn > mx ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( min ( minRemovals ( arr , l + 1 , h ) , minRemovals ( arr , l , h - 1 ) ) + 1 ) NEW_LINE DEDENT
def optimalStrategyOfGame ( arr , n ) : NEW_LINE INDENT table = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for gap in range ( n ) : NEW_LINE INDENT for j in range ( gap , n ) : NEW_LINE INDENT i = j - gap NEW_LINE x = 0 NEW_LINE if ( ( i + 2 ) <= j ) : NEW_LINE INDENT x = table [ i + 2 ] [ j ] NEW_LINE DEDENT y = 0 NEW_LINE if ( ( i + 1 ) <= ( j - 1 ) ) : NEW_LINE INDENT y = table [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT z = 0 NEW_LINE if ( i <= ( j - 2 ) ) : NEW_LINE INDENT z = table [ i ] [ j - 2 ] NEW_LINE DEDENT table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) NEW_LINE DEDENT DEDENT return table [ 0 ] [ n - 1 ] NEW_LINE DEDENT
def lps ( seq , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( seq [ i ] == seq [ j ] and i + 1 == j ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( seq [ i ] == seq [ j ] ) : NEW_LINE INDENT return lps ( seq , i + 1 , j - 1 ) + 2 NEW_LINE DEDENT return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) NEW_LINE DEDENT
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT if n == 0 or W == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt [ n - 1 ] > W ) : NEW_LINE INDENT return knapSack ( W , wt , val , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) NEW_LINE DEDENT DEDENT
def MatrixChainOrder ( p , i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return 0 NEW_LINE DEDENT _min = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT count = ( MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE if count < _min : NEW_LINE INDENT _min = count NEW_LINE DEDENT DEDENT return _min NEW_LINE DEDENT
def solve ( arr , N ) : NEW_LINE INDENT M = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT M [ i ] = arr [ i ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE Count = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT Count [ arr [ i ] ] = pow ( 2 , N - i - 1 ) NEW_LINE DEDENT for it in Count . values ( ) : NEW_LINE INDENT print ( it , end = " " ) NEW_LINE DEDENT DEDENT
def min_time_to_cut ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int ( math . log2 ( N ) ) + 1 NEW_LINE DEDENT
def q3 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE return NEW_LINE DEDENT if ( s [ i ] == 'a' ) : NEW_LINE INDENT q4 ( s , i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) NEW_LINE DEDENT DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE if ( N % 2 == 1 ) : NEW_LINE INDENT nth = ( N * N ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT nth = ( N * N ) - 1 NEW_LINE DEDENT return nth NEW_LINE DEDENT
def start ( c ) : NEW_LINE INDENT if ( c == 't' or c == 'T' ) : NEW_LINE INDENT dfa = 1 NEW_LINE DEDENT DEDENT
def isEqualSubstring ( string , x ) : NEW_LINE INDENT n = len ( string ) NEW_LINE i = 0 NEW_LINE while i < n and i < x : NEW_LINE INDENT if ( string [ i ] != string [ n - i - 1 ] ) : NEW_LINE INDENT print ( "false" ) NEW_LINE return NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( "true" ) NEW_LINE return NEW_LINE DEDENT
def canMakeEqual ( S ) : NEW_LINE INDENT N = len ( S ) NEW_LINE weightOfString = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT weightOfString += ord ( S [ i ] ) - ord ( 'a' ) + 1 NEW_LINE DEDENT if ( weightOfString % N == 0 ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def updateTree ( s , tree , start , end , treeNode , idx , X ) : NEW_LINE INDENT if ( ( start == end ) and ( idx == start ) ) : NEW_LINE INDENT s [ idx ] = X NEW_LINE tree [ treeNode ] . square_sum = pow ( ord ( X ) - ord ( 'a' ) + 1 , 2 ) NEW_LINE return NEW_LINE DEDENT mid = start + ( ( end - start ) // 2 ) NEW_LINE if ( idx <= mid ) : NEW_LINE INDENT updateTree ( s , tree , start , mid , ( 2 * treeNode ) , idx , X ) NEW_LINE DEDENT else : NEW_LINE INDENT updateTree ( s , tree , mid + 1 , end , ( 2 * treeNode ) + 1 , idx , X ) NEW_LINE DEDENT tree [ treeNode ] . square_sum = ( tree [ ( 2 * treeNode ) ] . square_sum + tree [ ( 2 * treeNode ) + 1 ] . square_sum ) NEW_LINE DEDENT
def getPalindromePath ( root ) : NEW_LINE INDENT global finalAns NEW_LINE finalAns = "$" NEW_LINE lexicographicallySmall ( root , "" ) NEW_LINE if ( finalAns == "$" ) : NEW_LINE INDENT print ( "No Palindromic Path exists" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( finalAns ) NEW_LINE DEDENT DEDENT
def permute ( n , r ) : NEW_LINE INDENT ans = 0 NEW_LINE ans = fact ( n ) // fact ( n - r ) NEW_LINE return ans NEW_LINE DEDENT
def isValid ( a1 , a2 , strr , flag ) : NEW_LINE INDENT v1 , v2 = 0 , 0 NEW_LINE if ( flag == 0 ) : NEW_LINE INDENT v1 = strr [ 4 ] NEW_LINE v2 = strr [ 3 ] NEW_LINE DEDENT else : NEW_LINE INDENT v1 = strr [ 1 ] NEW_LINE v2 = strr [ 0 ] NEW_LINE DEDENT if ( v1 != a1 and v1 != '?' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( v2 != a2 and v2 != '?' ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def minDel ( s1 , s2 ) : NEW_LINE INDENT i = len ( s1 ) NEW_LINE j = len ( s2 ) NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( s1 [ i - 1 ] != s2 [ j - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return i + j NEW_LINE DEDENT
def can_Construct ( S , K ) : NEW_LINE INDENT m = dict ( ) NEW_LINE p = 0 NEW_LINE if ( len ( S ) == K ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in S : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT if ( K > len ( S ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT for h in m : NEW_LINE INDENT if ( m [ h ] % 2 != 0 ) : NEW_LINE INDENT p = p + 1 NEW_LINE DEDENT DEDENT DEDENT if ( K < p ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def bcdToDecimal ( s ) : NEW_LINE INDENT length = len ( s ) NEW_LINE check = 0 NEW_LINE check0 = 0 NEW_LINE num = 0 NEW_LINE sum = 0 NEW_LINE mul = 1 NEW_LINE rev = 0 NEW_LINE for i in range ( length - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum += ( ord ( s [ i ] ) - ord ( '0' ) ) * mul NEW_LINE mul *= 2 NEW_LINE check += 1 NEW_LINE if ( check == 4 or i == 0 ) : NEW_LINE INDENT if ( sum == 0 and check0 == 0 ) : NEW_LINE INDENT num = 1 NEW_LINE check0 = 1 NEW_LINE DEDENT else : NEW_LINE INDENT num = num * 10 + sum NEW_LINE DEDENT check = 0 NEW_LINE sum = 0 NEW_LINE mul = 1 NEW_LINE DEDENT DEDENT while ( num > 0 ) : NEW_LINE INDENT rev = rev * 10 + ( num % 10 ) NEW_LINE num //= 10 NEW_LINE DEDENT if ( check0 == 1 ) : NEW_LINE INDENT return rev - 1 NEW_LINE DEDENT return rev NEW_LINE DEDENT
def isPossibleSum ( N ) : NEW_LINE INDENT if ( isPrime ( N ) and isPrime ( N - 2 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def findMaxFrequency ( s ) : NEW_LINE INDENT arr = [ 0 ] * 26 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT arr [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT hash = { } NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT if arr [ i ] not in hash : NEW_LINE INDENT hash [ arr [ i ] ] = 0 NEW_LINE DEDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT max_count = 0 NEW_LINE res = - 1 NEW_LINE for i in hash : NEW_LINE INDENT if ( max_count < hash [ i ] ) : NEW_LINE INDENT res = i NEW_LINE max_count = hash [ i ] NEW_LINE DEDENT DEDENT print ( "Frequency" , res , "is repeated" , max_count , "times" ) NEW_LINE DEDENT
def checkIfStartsWithVowels ( string ) : NEW_LINE INDENT if ( not ( string [ 0 ] == 'A' or string [ 0 ] == 'a' or string [ 0 ] == 'E' or string [ 0 ] == 'e' or string [ 0 ] == 'I' or string [ 0 ] == 'i' or string [ 0 ] == 'O' or string [ 0 ] == 'o' or string [ 0 ] == 'U' or string [ 0 ] == 'u' ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def xExistsInY ( x , y ) : NEW_LINE INDENT if ( len ( x ) > len ( y ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT cnt_x = [ 0 ] * MAX NEW_LINE cnt = [ 0 ] * MAX NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT cnt_x [ ord ( x [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( x ) ) : NEW_LINE INDENT cnt [ ord ( y [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT if ( areEqual ( cnt_x , cnt ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , len ( y ) - len ( x ) + 1 ) : NEW_LINE INDENT cnt [ ord ( y [ i - 1 ] ) - ord ( 'a' ) ] -= 1 NEW_LINE cnt [ ord ( y [ i + len ( x ) - 1 ] ) - ord ( 'a' ) ] += 1 NEW_LINE if ( areEqual ( cnt , cnt_x ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def updateFreq ( strr , freq ) : NEW_LINE INDENT lenn = len ( strr ) NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT freq [ ord ( strr [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT DEDENT
def cntWays ( string , n ) : NEW_LINE INDENT x = n + 1 NEW_LINE ways = x * x * ( x * x - 1 ) // 12 NEW_LINE return ways NEW_LINE DEDENT
def countSticks ( string , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt += ( sticks [ ord ( string [ i ] ) - ord ( '0' ) ] ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT
def countTotalDistinct ( string ) : NEW_LINE INDENT cnt = 0 NEW_LINE items = set ( ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT temp = "" NEW_LINE ans = set ( ) NEW_LINE for j in range ( i , len ( string ) ) : NEW_LINE INDENT temp = temp + string [ j ] NEW_LINE ans . add ( string [ j ] ) NEW_LINE if temp not in items : NEW_LINE INDENT items . add ( temp ) NEW_LINE cnt += len ( ans ) NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT
def getOrgString ( s ) : NEW_LINE INDENT print ( s [ 0 ] , end = "" ) NEW_LINE i = 1 NEW_LINE while ( i < len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ i ] ) >= ord ( 'A' ) and ord ( s [ i ] ) <= ord ( 'Z' ) ) : NEW_LINE INDENT print ( " " , s [ i ] . lower ( ) , end = "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] , end = "" ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT
def getIndex ( s1 , s2 , length ) : NEW_LINE INDENT i = 0 NEW_LINE j = length - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( s1 [ i ] != s2 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT return i - 1 NEW_LINE DEDENT elif ( isPalindrome ( s2 , i , j ) ) : NEW_LINE INDENT return i - 1 NEW_LINE DEDENT elif ( isPalindrome ( s1 , i , j ) ) : NEW_LINE INDENT return j NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def countSubStrings ( s , anotherStr , k ) : NEW_LINE INDENT illegal = [ False ] * MAX_CHAR NEW_LINE for i in range ( len ( anotherStr ) ) : NEW_LINE INDENT illegal [ ord ( anotherStr [ i ] ) ] = True NEW_LINE DEDENT us = set ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ss = "" NEW_LINE count = 0 NEW_LINE for j in range ( i , len ( s ) ) : NEW_LINE INDENT if ( illegal [ ord ( s [ j ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT ss = ss + s [ j ] NEW_LINE if ( count <= k ) : NEW_LINE INDENT us . add ( ss ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( us ) NEW_LINE DEDENT
def PrimeCharacters ( s ) : NEW_LINE INDENT prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( max_val ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( prime [ ord ( s [ i ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def matchPattern ( s ) : NEW_LINE INDENT count = 0 NEW_LINE n = len ( s ) NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT while ( i < n and s [ i ] == 'a' ) : NEW_LINE INDENT count += 1 NEW_LINE i = + 1 NEW_LINE DEDENT while ( i < n and s [ i ] == 'b' ) : NEW_LINE INDENT count -= 1 NEW_LINE i += 1 NEW_LINE DEDENT if ( count != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def compare ( arr1 , arr2 ) : NEW_LINE INDENT for i in range ( ALL_CHARS ) : NEW_LINE INDENT if arr1 [ i ] != arr2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def maximum_one ( s , n ) : NEW_LINE INDENT cnt_one = 0 NEW_LINE cnt , max_cnt = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT cnt_one += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , cnt ) NEW_LINE cnt = 0 NEW_LINE DEDENT DEDENT max_cnt = max ( max_cnt , cnt ) NEW_LINE left = [ 0 ] * n NEW_LINE right = [ 0 ] * n NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT left [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ 0 ] = 0 NEW_LINE DEDENT if ( s [ n - 1 ] == '1' ) : NEW_LINE INDENT right [ n - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ n - 1 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT left [ i ] = left [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT sum = left [ i - 1 ] + right [ i + 1 ] NEW_LINE if ( sum < cnt_one ) : NEW_LINE INDENT max_cnt = max ( max_cnt , sum + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , sum ) NEW_LINE DEDENT DEDENT DEDENT return max_cnt NEW_LINE DEDENT
def bitToBeFlipped ( s ) : NEW_LINE INDENT last = s [ len ( s ) - 1 ] NEW_LINE first = s [ 0 ] NEW_LINE if ( last == first ) : NEW_LINE INDENT if ( last == '0' ) : NEW_LINE INDENT return '1' NEW_LINE DEDENT else : NEW_LINE INDENT return '0' NEW_LINE DEDENT DEDENT elif ( last != first ) : NEW_LINE INDENT return last NEW_LINE DEDENT DEDENT
def countPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE sum = 0 NEW_LINE hashTable = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashTable [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( hashTable [ i ] ) : NEW_LINE INDENT sum += ( hashTable [ i ] * ( hashTable [ i ] + 1 ) // 2 ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def smallestNumber ( n ) : NEW_LINE INDENT num = 0 NEW_LINE s = "" NEW_LINE duplicate = n NEW_LINE while ( n ) : NEW_LINE INDENT s = chr ( n % 10 + 48 ) + s NEW_LINE n //= 10 NEW_LINE DEDENT index = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT digit = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( ( digit & 1 ) == 0 ) : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( index == - 1 ) : NEW_LINE INDENT return duplicate NEW_LINE DEDENT for i in range ( index ) : NEW_LINE INDENT num = num * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT num = num * 10 + ( ord ( s [ index ] ) - ord ( '0' ) + 1 ) NEW_LINE for i in range ( index + 1 , len ( s ) ) : NEW_LINE INDENT num = num * 10 + 1 NEW_LINE DEDENT return num NEW_LINE DEDENT
def count_carry ( a , b ) : NEW_LINE INDENT carry = 0 NEW_LINE count = 0 NEW_LINE len_a = len ( a ) NEW_LINE len_b = len ( b ) NEW_LINE while ( len_a != 0 or len_b != 0 ) : NEW_LINE INDENT x = 0 NEW_LINE y = 0 NEW_LINE if ( len_a > 0 ) : NEW_LINE INDENT x = int ( a [ len_a - 1 ] ) + int ( '0' ) NEW_LINE len_a -= 1 NEW_LINE DEDENT if ( len_b > 0 ) : NEW_LINE INDENT y = int ( b [ len_b - 1 ] ) + int ( '0' ) NEW_LINE len_b -= 1 NEW_LINE DEDENT sum = x + y + carry NEW_LINE if ( sum >= 10 ) : NEW_LINE INDENT carry = 1 NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def leastCount ( s1 , s2 , n ) : NEW_LINE INDENT count1 = [ 0 ] * MAX_CHAR NEW_LINE count2 = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT count1 [ ord ( s1 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE count2 [ ord ( s2 [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( count1 [ i ] != 0 ) : NEW_LINE INDENT res += abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def allCharactersSame ( s ) : NEW_LINE INDENT s1 = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT s1 . append ( s [ i ] ) NEW_LINE DEDENT s1 = list ( set ( s1 ) ) NEW_LINE if ( len ( s1 ) == 1 ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT
def check_isogram ( string ) : NEW_LINE INDENT length = len ( string ) NEW_LINE mapHash = [ 0 ] * 26 NEW_LINE for i in range ( length ) : NEW_LINE INDENT mapHash [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE if ( mapHash [ ord ( string [ i ] ) - ord ( 'a' ) ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def maxLengthNonPalinSubstring ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE ch = str [ 0 ] NEW_LINE i = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( str [ i ] != ch ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( isPalindrome ( str ) ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT return n NEW_LINE DEDENT
def traverseTree ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( root . data , end = " " ) NEW_LINE if ( root . child == None ) : NEW_LINE INDENT return NEW_LINE DEDENT q = deque ( ) NEW_LINE curr = root . child NEW_LINE q . append ( curr ) NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE INDENT curr = q . popleft ( ) NEW_LINE while ( curr != None ) : NEW_LINE INDENT print ( curr . data , end = " " ) NEW_LINE if ( curr . child != None ) : NEW_LINE INDENT q . append ( curr . child ) NEW_LINE DEDENT curr = curr . next NEW_LINE DEDENT DEDENT DEDENT
def transpose ( mat , tr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT tr [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT
def qType1 ( l , x , str1 ) : NEW_LINE INDENT str1 [ l - 1 ] = x NEW_LINE DEDENT
def getFrequency ( tree , idx , i ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( idx > 0 ) : NEW_LINE INDENT sum += tree [ idx ] [ i ] NEW_LINE idx -= ( idx & - idx ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def qType2 ( tree , l , r , str1 ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , 27 ) : NEW_LINE INDENT if ( l == 1 ) : NEW_LINE INDENT if ( getFrequency ( tree , r , i ) % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( getFrequency ( tree , r , i ) - getFrequency ( tree , l - 1 , i ) ) % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( "Yes" ) if ( count <= 1 ) else print ( "No" ) NEW_LINE DEDENT
def difference ( arr , n ) : NEW_LINE INDENT d1 = 0 NEW_LINE d2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT d1 += arr [ i ] [ j ] NEW_LINE DEDENT if ( i == n - j - 1 ) : NEW_LINE INDENT d2 += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return abs ( d1 - d2 ) NEW_LINE DEDENT
def isValid ( row , col ) : NEW_LINE INDENT return ( row >= 0 ) and ( col >= 0 ) and ( row < 4 ) and ( col < 4 ) NEW_LINE DEDENT
def comb ( n , r ) : NEW_LINE INDENT global box1 , box2 , fact NEW_LINE res = fact [ n ] // fact [ r ] NEW_LINE res //= fact [ n - r ] NEW_LINE return res NEW_LINE DEDENT
def getMinPathSum ( graph , visited , necessary , source , dest , currSum ) : NEW_LINE INDENT global minSum NEW_LINE if ( src == dest ) : NEW_LINE INDENT flag = True NEW_LINE for i in necessary : NEW_LINE INDENT if ( not visited [ i ] ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT minSum = min ( minSum , currSum ) NEW_LINE DEDENT return NEW_LINE DEDENT else : NEW_LINE INDENT visited [ src ] = True NEW_LINE for node in graph [ src ] : NEW_LINE INDENT if not visited [ node [ 0 ] ] : NEW_LINE INDENT visited [ node [ 0 ] ] = True NEW_LINE getMinPathSum ( graph , visited , necessary , node [ 0 ] , dest , currSum + node [ 1 ] ) NEW_LINE visited [ node [ 0 ] ] = False NEW_LINE DEDENT DEDENT visited [ src ] = False NEW_LINE DEDENT DEDENT
def is_clique ( b ) : NEW_LINE INDENT for i in range ( 1 , b ) : NEW_LINE INDENT for j in range ( i + 1 , b ) : NEW_LINE INDENT if ( graph [ store [ i ] ] [ store [ j ] ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def generateAllBinaryStrings ( n , arr , i ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT printTheArray ( arr , n ) NEW_LINE return NEW_LINE DEDENT arr [ i ] = 0 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE arr [ i ] = 1 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE DEDENT
def uniquePaths ( grid ) : NEW_LINE INDENT z_count = 0 NEW_LINE n = len ( grid ) NEW_LINE m = len ( grid [ 0 ] ) NEW_LINE ans = 0 NEW_LINE vis = [ [ 0 for j in range ( m ) ] for i in range ( n ) ] NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if grid [ i ] [ j ] == 0 : NEW_LINE INDENT z_count += 1 NEW_LINE DEDENT elif ( grid [ i ] [ j ] == 1 ) : NEW_LINE INDENT x = i NEW_LINE y = j NEW_LINE DEDENT DEDENT DEDENT grid , vis , ans = dfs ( x , y , grid , vis , ans , 0 , z_count ) NEW_LINE return ans NEW_LINE DEDENT
def isPrime ( x ) : NEW_LINE INDENT sqroot = int ( math . sqrt ( x ) ) NEW_LINE flag = True NEW_LINE if ( x == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , sqroot + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def minStepsRecur ( height , l , r , h ) : NEW_LINE INDENT if l >= r : NEW_LINE INDENT return 0 NEW_LINE DEDENT m = l NEW_LINE for i in range ( l , r ) : NEW_LINE INDENT if height [ i ] < height [ m ] : NEW_LINE INDENT m = i NEW_LINE DEDENT DEDENT return min ( r - l , minStepsRecur ( height , l , m , height [ m ] ) + minStepsRecur ( height , m + 1 , r , height [ m ] ) + height [ m ] - h ) NEW_LINE DEDENT
def findFrequency ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in mp : NEW_LINE INDENT mp [ arr [ i ] ] = 0 NEW_LINE DEDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in mp : NEW_LINE INDENT print ( "Element" , i , "occurs" , mp [ i ] , "times" ) NEW_LINE DEDENT DEDENT
def secondary_polygon ( Angle ) : NEW_LINE INDENT edges_primary = 360 // Angle NEW_LINE if edges_primary >= 6 : NEW_LINE INDENT edges_max_secondary = edges_primary // 2 NEW_LINE return edges_max_secondary + 3 NEW_LINE DEDENT else : NEW_LINE INDENT return "Not Possible" NEW_LINE DEDENT DEDENT
def parallel ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT if ( ( - ( a1 / b1 ) ) == ( - ( a2 / b2 ) ) ) : NEW_LINE INDENT print ( "Yes" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "No" ) NEW_LINE DEDENT DEDENT
def No_of_cubes ( N , K ) : NEW_LINE INDENT No = 0 NEW_LINE No = ( N - K + 1 ) NEW_LINE No = pow ( No , 3 ) NEW_LINE return No NEW_LINE DEDENT
def updateArray ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT for i in range ( x1 , x2 ) : NEW_LINE INDENT for j in range ( y1 , y2 ) : NEW_LINE INDENT arr [ i ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT
def calcAngle ( h , m ) : NEW_LINE INDENT if ( h < 0 or m < 0 or h > 12 or m > 60 ) : NEW_LINE INDENT print ( "Wrong input" ) NEW_LINE DEDENT if ( h == 12 ) : NEW_LINE INDENT h = 0 NEW_LINE DEDENT if ( m == 60 ) : NEW_LINE INDENT m = 0 NEW_LINE DEDENT hour_angle = 0.5 * ( h * 60 + m ) NEW_LINE minute_angle = 6 * m NEW_LINE angle = abs ( hour_angle - minute_angle ) NEW_LINE angle = min ( 360 - angle , angle ) NEW_LINE return angle NEW_LINE DEDENT
def heptacontagonNum ( n ) : NEW_LINE INDENT return ( 68 * n * n - 66 * n ) // 2 NEW_LINE DEDENT
def octacontagonNum ( n ) : NEW_LINE INDENT return ( 78 * n * n - 76 * n ) // 2 NEW_LINE DEDENT
def Pentadecagonal_num ( n ) : NEW_LINE INDENT return ( 13 * n * n - 11 * n ) / 2 NEW_LINE DEDENT
def check ( n , m ) : NEW_LINE INDENT if ( m % n == 0 ) : NEW_LINE INDENT print ( "YES" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "NO" ) NEW_LINE DEDENT DEDENT
def dist ( x1 , y1 , x2 , y2 , r ) : NEW_LINE INDENT print ( "The shortest distance between a point and a circle is " , ( ( ( ( x2 - x1 ) ** 2 ) + ( ( y2 - y1 ) ** 2 ) ) ** ( 1 / 2 ) ) - r ) NEW_LINE DEDENT
def ellipse ( l , b ) : NEW_LINE INDENT if l < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = ( 3.14 * l * b ) / 4 NEW_LINE return x NEW_LINE DEDENT
def squareSide ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = 0.423 * a NEW_LINE return x NEW_LINE DEDENT
def CubeVolume ( d ) : NEW_LINE INDENT Volume = ( sqrt ( 3 ) * pow ( d , 3 ) ) / 9 NEW_LINE return Volume NEW_LINE DEDENT
def cyl ( r , h ) : NEW_LINE INDENT if ( r < 0 and h < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT R = ( 2 * r ) / 3 NEW_LINE H = ( 2 * h ) / 3 NEW_LINE V = 3.14 * math . pow ( R , 2 ) * H NEW_LINE return V NEW_LINE DEDENT
def perimeter ( r ) : NEW_LINE INDENT return ( 3.14 ) * ( r ) NEW_LINE DEDENT
def hexadecagonalNum ( n ) : NEW_LINE INDENT return ( ( 14 * n * n ) - 12 * n ) // 2 NEW_LINE DEDENT
def intersection ( n ) : NEW_LINE INDENT return n * ( n - 1 ) NEW_LINE DEDENT
def numberOfWays ( x ) : NEW_LINE INDENT dp = [ ] NEW_LINE dp . append ( 1 ) NEW_LINE dp . append ( 1 ) NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT dp . append ( dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ) NEW_LINE DEDENT return ( dp [ x ] ) NEW_LINE DEDENT
def check_and_print ( required_time , given_time ) : NEW_LINE INDENT if required_time < given_time : NEW_LINE INDENT print ( "Overflow" ) NEW_LINE DEDENT elif required_time > given_time : NEW_LINE INDENT print ( "Underflow" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "Filled" ) NEW_LINE DEDENT DEDENT
def maxArea ( a , b , c , d ) : NEW_LINE INDENT semiperimeter = ( a + b + c + d ) / 2 NEW_LINE return math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) NEW_LINE DEDENT
def directionOfPoint ( A , B , P ) : NEW_LINE INDENT global RIGHT , LEFT , ZERO NEW_LINE B . x -= A . x NEW_LINE B . y -= A . y NEW_LINE P . x -= A . x NEW_LINE P . y -= A . y NEW_LINE cross_product = B . x * P . y - B . y * P . x NEW_LINE if ( cross_product > 0 ) : NEW_LINE INDENT return RIGHT NEW_LINE DEDENT if ( cross_product < 0 ) : NEW_LINE INDENT return LEFT NEW_LINE DEDENT return ZERO NEW_LINE DEDENT
def areaCube ( a ) : NEW_LINE INDENT return ( a * a * a ) NEW_LINE DEDENT
def sqDist ( p1 , p2 ) : NEW_LINE INDENT return ( ( p1 [ 0 ] - p2 [ 0 ] ) * ( p1 [ 0 ] - p2 [ 0 ] ) + ( p1 [ 1 ] - p2 [ 1 ] ) * ( p1 [ 1 ] - p2 [ 1 ] ) ) NEW_LINE DEDENT
def isSquare ( p1 , p2 , p3 , p4 ) : NEW_LINE INDENT if d2 == 0 or d3 == 0 or d4 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if d2 == d3 and 2 * d2 == d4 and 2 * distSq ( p2 , p4 ) == distSq ( p2 , p3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if d3 == d4 and 2 * d3 == d2 and 2 * distSq ( p3 , p2 ) == distSq ( p3 , p4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if d2 == d4 and 2 * d2 == d3 and 2 * distSq ( p2 , p3 ) == distSq ( p2 , p4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def getProduct ( n ) : NEW_LINE INDENT product = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT product = product * ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT
def lastPositiveElement ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT greatest = - 1 NEW_LINE secondGreatest = - 1 NEW_LINE for x in arr : NEW_LINE INDENT if ( x >= greatest ) : NEW_LINE INDENT secondGreatest = greatest NEW_LINE greatest = x NEW_LINE DEDENT elif ( x >= secondGreatest ) : NEW_LINE INDENT secondGreatest = x NEW_LINE DEDENT DEDENT return greatest - secondGreatest NEW_LINE DEDENT
def countQuadruples ( A , N ) : NEW_LINE INDENT ans = 0 NEW_LINE freq = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] in freq : NEW_LINE INDENT ans += freq [ A [ i ] ] NEW_LINE DEDENT else : NEW_LINE INDENT freq [ A [ i ] ] = 0 NEW_LINE DEDENT for j in range ( i ) : NEW_LINE INDENT for k in range ( j ) : NEW_LINE INDENT if A [ i ] * A [ j ] * A [ k ] in freq : NEW_LINE INDENT freq [ A [ i ] * A [ j ] * A [ k ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ A [ i ] * A [ j ] * A [ k ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def countArrays ( n , k ) : NEW_LINE INDENT mod = 1000000007 NEW_LINE ans = power ( n , k , mod ) NEW_LINE return ans NEW_LINE DEDENT
def printInorder ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT printInorder ( root . left ) NEW_LINE print ( root . data , "" , end = "" ) NEW_LINE printInorder ( root . right ) NEW_LINE DEDENT
def countWays ( s , t ) : NEW_LINE INDENT n = len ( s ) NEW_LINE sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE K = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT sum1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum1 -= 1 NEW_LINE DEDENT DEDENT m = len ( t ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( t [ i ] == '1' ) : NEW_LINE INDENT sum2 += 1 NEW_LINE DEDENT elif ( t [ i ] == '0' ) : NEW_LINE INDENT sum2 -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT K += 1 NEW_LINE DEDENT DEDENT P = abs ( sum1 - sum2 ) NEW_LINE if ( P > K or ( K - P ) % 2 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT print ( nCr ( K , ( P + K ) // 2 ) ) NEW_LINE DEDENT
def pathCountDP ( mat , k ) : NEW_LINE INDENT return pathCountDPRecDP ( mat , R - 1 , C - 1 , k ) NEW_LINE DEDENT
def isadjacent ( prev , curr ) : NEW_LINE INDENT if ( ord ( curr ) - ord ( prev ) ) == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def getLen ( mat , s ) : NEW_LINE INDENT for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == s ) : NEW_LINE INDENT for k in range ( 8 ) : NEW_LINE INDENT ans = max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , s ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def isSmith ( n ) : NEW_LINE INDENT original_no = n NEW_LINE pDigitSum = 0 NEW_LINE i = 0 NEW_LINE while ( primes [ i ] <= n // 2 ) : NEW_LINE INDENT while ( n % primes [ i ] == 0 ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE n = n // p NEW_LINE while ( p > 0 ) : NEW_LINE INDENT pDigitSum += ( p % 10 ) NEW_LINE p = p // 10 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( n != 1 and n != original_no ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT pDigitSum = pDigitSum + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT DEDENT sumDigits = 0 NEW_LINE while ( original_no > 0 ) : NEW_LINE INDENT sumDigits = sumDigits + original_no % 10 NEW_LINE original_no = original_no // 10 NEW_LINE DEDENT return ( pDigitSum == sumDigits ) NEW_LINE DEDENT
def smallestPermutation ( arr , N ) : NEW_LINE INDENT w = [ False for i in range ( 2 * N + 1 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT w [ arr [ i ] ] = True NEW_LINE DEDENT S = set ( ) NEW_LINE for i in range ( 1 , 2 * N + 1 , 1 ) : NEW_LINE INDENT if ( w [ i ] == False ) : NEW_LINE INDENT S . add ( i ) NEW_LINE DEDENT DEDENT found = True NEW_LINE P = [ ] NEW_LINE S = list ( S ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT it = bisect_left ( S , arr [ i ] ) NEW_LINE if ( it == - 1 ) : NEW_LINE INDENT found = False NEW_LINE break NEW_LINE DEDENT P . append ( arr [ i ] ) NEW_LINE P . append ( S [ it ] ) NEW_LINE S . remove ( S [ it ] ) NEW_LINE DEDENT if ( found == False ) : NEW_LINE INDENT print ( "-1" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 2 * N ) : NEW_LINE INDENT print ( P [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT
def findlcm ( arr , n ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = ( ( ( arr [ i ] * ans ) ) / ( gcd ( arr [ i ] , ans ) ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT
def findLast ( mat ) : NEW_LINE INDENT m = len ( mat ) NEW_LINE n = len ( mat [ 0 ] ) NEW_LINE rows = set ( ) NEW_LINE cols = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if mat [ i ] [ j ] : NEW_LINE INDENT rows . add ( i ) NEW_LINE cols . add ( j ) NEW_LINE DEDENT DEDENT DEDENT avRows = m - len ( list ( rows ) ) NEW_LINE avCols = n - len ( list ( cols ) ) NEW_LINE choices = min ( avRows , avCols ) NEW_LINE if choices & 1 : NEW_LINE INDENT print ( 'P1' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 'P2' ) NEW_LINE DEDENT DEDENT
def nearestPowerDiff ( arr , N , a , b ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT log_a = int ( math . log ( arr [ i ] ) / math . log ( a ) ) NEW_LINE A = int ( pow ( a , log_a ) ) NEW_LINE B = int ( pow ( a , log_a + 1 ) ) NEW_LINE if ( ( arr [ i ] - A ) < ( B - arr [ i ] ) ) : NEW_LINE INDENT log_a = A NEW_LINE DEDENT else : NEW_LINE INDENT log_a = B NEW_LINE DEDENT log_b = int ( math . log ( arr [ i ] ) / math . log ( b ) ) NEW_LINE A = int ( pow ( b , log_b ) ) NEW_LINE B = int ( pow ( b , log_b + 1 ) ) NEW_LINE if ( ( arr [ i ] - A ) < ( B - arr [ i ] ) ) : NEW_LINE INDENT log_b = A NEW_LINE DEDENT else : NEW_LINE INDENT log_b = B NEW_LINE DEDENT arr [ i ] = abs ( log_a - log_b ) NEW_LINE DEDENT printArray ( arr , N ) NEW_LINE DEDENT
def checkEvenPower ( N ) : NEW_LINE INDENT if ( ( N & ( N - 1 ) ) != 0 ) : NEW_LINE INDENT return false NEW_LINE DEDENT N = N & 0x55555555 NEW_LINE return ( N > 0 ) NEW_LINE DEDENT
def distinct ( arr , n ) : NEW_LINE INDENT mpp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mpp [ arr [ i ] ] = 1 NEW_LINE DEDENT return len ( mpp ) NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT global mod NEW_LINE res = 1 NEW_LINE x = x % mod NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % mod NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % mod NEW_LINE DEDENT return res NEW_LINE DEDENT
def isNonDeficient ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE sum = sum + ( n // i ) NEW_LINE DEDENT DEDENT DEDENT return sum >= 2 * n NEW_LINE DEDENT
def lastElement ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE if n % 2 == 0 : NEW_LINE INDENT multiplier = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT multiplier = 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] * multiplier NEW_LINE multiplier = multiplier * ( n - 1 - i ) / ( i + 1 ) * ( - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
