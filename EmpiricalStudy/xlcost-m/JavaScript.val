function sumOfTwoPerfectCubes ( N ) { var cubes = new Map ( ) ; for ( var i = 1 ; i * i * i <= N ; i ++ ) cubes . set ( i * i * i , i ) ; var ans = false ; cubes . forEach ( ( value , key ) => { var firstNumber = key ; var secondNumber = N - value ; if ( cubes . has ( secondNumber ) ) { document . write ( "True" ) ; ans = true ; return ; } } ) ; if ( ans ) { return ; } document . write ( "False" ) ; }
function SieveOfEratosthenes ( N ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( var p = 2 ; p * p <= N ; p ++ ) { if ( prime [ p ] == true ) { for ( var i = p * p ; i <= N ; i += p ) prime [ i ] = false ; } } }
function checksubarrayExist1_N ( arr , N ) { let pos = new Map ( ) ; for ( let i = 0 ; i < N ; i ++ ) { pos . set ( arr [ i ] , i ) ; } let st = new Set ( ) ; for ( let i = 1 ; i <= N ; i ++ ) { st . add ( pos . get ( i ) ) ; let Min = Math . min ( ... st ) ; let Max = Math . max ( ... st ) ; if ( Max - Min + 1 == i ) { document . write ( "True▁" ) ; } else { document . write ( "False▁" ) ; } } }
function reverseCircularArray ( arr , N , K ) { let start = K , end = K - 1 ; let count = Math . floor ( N / 2 ) ; while ( count -- ) { let temp = arr [ start % N ] ; arr [ start % N ] = arr [ end % N ] ; arr [ end % N ] = temp ; start ++ ; end -- ; if ( end === - 1 ) { end = N - 1 ; } } printArray ( arr , N ) ; }
function XOR_for_every_i ( A , N ) { let frequency_of_bits = new Uint8Array ( 32 ) ; for ( let i = 0 ; i < N ; i ++ ) { let bit_position = 0 ; let M = A [ i ] ; while ( M != 0 ) { if ( ( M & 1 ) != 0 ) { frequency_of_bits [ bit_position ] += 1 ; } bit_position += 1 ; M >>= 1 ; } } for ( let i = 0 ; i < N ; i ++ ) { let M = A [ i ] ; let value_at_that_bit = 1 ; let XOR_sum = 0 ; for ( let bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( ( M & 1 ) != 0 ) { XOR_sum += ( N - frequency_of_bits [ bit_position ] ) * value_at_that_bit ; } else { XOR_sum += ( frequency_of_bits [ bit_position ] ) * value_at_that_bit ; } M >>= 1 ; value_at_that_bit <<= 1 ; } document . write ( XOR_sum + "▁" ) ; } return ; }
function findSum ( a , b , n ) { if ( n == 1 ) { document . write ( a ) ; return ; } let s = a + b ; for ( i = 0 ; i < n - 2 ; i ++ ) { let x = a ^ b ; s += x ; a = b ; b = x ; } document . write ( s ) ; }
function countNumbersUtil ( N ) { var count = 0 ; var digits = [ ] ; while ( N ) { digits . push ( N % 10 ) ; N = parseInt ( N / 10 ) ; } digits . reverse ( ) ; var D = digits . length ; for ( var i = 1 ; i <= D ; i ++ ) { var res = getPower ( i ) ; if ( i == D ) { for ( var p = 1 ; p <= D ; p ++ ) { var x = digits [ p - 1 ] ; var tmp = 0 ; if ( p % 2 == 0 ) { tmp = ( 5 - parseInt ( x / ( 2 + 1 ) ) ) * getPower ( D - p ) ; } else { tmp = ( 5 - parseInt ( ( x + 1 ) / 2 ) ) * getPower ( D - p ) ; } res -= tmp ; if ( p % 2 != x % 2 ) { break ; } } } count += res ; } return count ; }
function array_sum ( arr , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
function check ( n ) { return 2 * rev ( n ) == n + 1 ; }
function highestPower ( n ) { return parseInt ( Math . log ( n ) / Math . log ( 2 ) ) ; }
function isPrimePossible ( N ) { let s = N . toString ( ) ; let l = s . length ; if ( l < 2 ) return false ; for ( let i = 0 ; i < l ; i ++ ) { let str = deleteIth ( s , i ) ; let num = parseInt ( str ) ; if ( isPrime ( num ) ) return true ; } return false ; }
function isPerfectSquare ( x ) { sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function findlcm ( arr , n ) { let ans = 1 ; for ( let i = 1 ; i <= n ; i ++ ) ans = ( ( ( arr [ i ] * ans ) ) / ( gcd ( arr [ i ] , ans ) ) ) ; return ans ; }
function findAandB ( n , k ) { var flag = 0 ; for ( var i = 1 ; i < n ; i ++ ) { if ( freqCount ( i . toString ( ) , String . fromCharCode ( k + 48 ) ) == 0 && freqCount ( ( n - i ) . toString ( ) , String . fromCharCode ( k + 48 ) ) == 0 ) { document . write ( "(" + i + ",▁" + ( n - i ) + ")" ) ; flag = 1 ; break ; } } if ( flag == 0 ) cout + - 1 ; }
function SquareRoot ( num ) { let count = 0 ; for ( let n = 1 ; n <= num ; n += 2 ) { num = num - n ; count += 1 ; if ( num == 0 ) break ; } return count ; }
function IncrementFactors ( count , val ) { for ( let i = 1 ; i * i <= val ; i ++ ) { if ( val % i == 0 ) { if ( i == parseInt ( val / i ) ) { count [ i ] ++ ; } else { count [ i ] ++ ; count [ parseInt ( val / i ) ] ++ ; } } } }
function calcSum ( k , n ) { let value = ( k * n * ( n + 1 ) ) / 2 ; return value ; }
function storeDivisors ( n , div ) { for ( var i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) div . push ( i ) ; else { div . push ( i ) ; div . push ( n / i ) ; } } } }
function sieveSundaram ( ) { let marked = Array . from ( { length : MAX / 2 + 1 } , ( _ , i ) => 0 ) ; for ( let i = 1 ; i <= Math . floor ( ( Math . sqrt ( MAX ) - 1 ) / 2 ) ; i ++ ) { for ( let j = ( i * ( i + 1 ) ) << 1 ; j <= Math . floor ( MAX / 2 ) ; j = j + 2 * i + 1 ) { marked [ j ] = true ; } } primes . push ( 2 ) ; for ( let i = 1 ; i <= Math . floor ( MAX / 2 ) ; i ++ ) if ( marked [ i ] == false ) primes . push ( 2 * i + 1 ) ; }
function firstDigit ( n ) { let digits = parseInt ( ( Math . log ( n ) / Math . log ( 10 ) ) ) ; n = parseInt ( ( n / Math . pow ( 10 , digits ) ) ) ; return n ; }
function sumOfSumSeries ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
function isTetradic ( n ) { if ( ispalindrome ( n ) && isContaindigit ( n ) ) return true ; return false ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( var i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function getRow ( rowIndex ) { let currow = [ ] ; currow . push ( 1 ) ; if ( rowIndex == 0 ) { return currow ; } let prev = getRow ( rowIndex - 1 ) ; for ( let i = 1 ; i < prev . length ; i ++ ) { let curr = prev [ i - 1 ] + prev [ i ] ; currow . push ( curr ) ; } currow . push ( 1 ) ; return currow ; }
function gonNum360 ( n ) { return ( 358 * n * n - 356 * n ) / 2 ; }
function gonNum257 ( n ) { return ( 255 * n * n - 253 * n ) / 2 ; }
function solve ( n ) { for ( var x = 1 ; x <= Math . sqrt ( n ) ; x ++ ) { if ( n % x == 0 ) { var small = x ; var big = n / x ; if ( small % 2 == big % 2 ) { var a = ( small + big ) / 2 ; var b = ( big - small ) / 2 ; document . write ( a + "▁" + b ) ; return ; } } } document . write ( - 1 ) ; }
function Is_Practical ( A ) { var divisors = [ ] ; divisors = get_divisors ( A ) ; for ( var i = 2 ; i < A ; i ++ ) { if ( Sum_Possible ( divisors , i ) == false ) return false ; } return true ; }
function operation ( arr , N ) { let right = 0 , ans = 0 , num = 0 ; for ( let left = 0 ; left < N ; left ++ ) { while ( right < N && num + arr [ right ] == ( num ^ arr [ right ] ) ) { num += arr [ right ] ; right ++ ; } ans += right - left ; if ( left == right ) right ++ ; else num -= arr [ left ] ; } return ans ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; for ( var i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
function fact ( n ) { var res = 1 ; for ( var i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
function findMaxSize ( a , n ) { var frq = Array ( n + 1 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; ++ i ) frq [ a [ i ] ] ++ ; var maxfrq = frq . reduce ( ( a , b ) => Math . max ( a , b ) )  var dist = n + 1 - frq . filter ( x => x == 0 ) . length ; var ans1 = Math . min ( maxfrq - 1 , dist ) ; var ans2 = Math . min ( maxfrq , dist - 1 ) ; var ans = Math . max ( ans1 , ans2 ) ; return ans ; }
function minCount ( n ) { let hasharr = [ 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 ] ; if ( n > 69 ) return hasharr [ n % 10 ] ; else { if ( n >= hasharr [ n % 10 ] * 7 ) return ( hasharr [ n % 10 ] ) ; else return - 1 ; } }
function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; }
function findMaxSum ( A , B , n ) { var maxArr = Array ( n ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; ++ i ) { var X = joinNumbers ( A [ i ] , B [ i ] ) ; var Y = joinNumbers ( B [ i ] , A [ i ] ) ; var mx = Math . max ( X , Y ) ; maxArr [ i ] = mx ; } var maxAns = 0 ; for ( var i = 0 ; i < n ; i ++ ) { maxAns += maxArr [ i ] ; } return maxAns ; }
function SmallestPerfectSquare ( N ) { let X = 1e9 ; let ans ; for ( let i = 1 ; i < Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { let a = i ; let b = N / i ; if ( ( b - a != 0 ) && ( ( b - a ) % 2 == 0 ) ) { X = Math . min ( X , ( b - a ) / 2 ) ; } } } if ( X != 1e9 ) ans = X * X ; else ans = - 1 ; return ans ; }
function PrintReverseOrder ( N ) { for ( let i = N ; i > 0 ; i -- ) document . write ( i + "▁" ) ; }
function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
function dfs ( u , adj , vis ) { vis [ u ] = 1 ; let componentSize = 1 ; for ( let it in adj [ u ] ) { if ( vis [ it ] == 0 ) { componentSize += dfs ( it , adj , vis ) ; } } return componentSize ; }
function prefix ( ) { for ( i = 1 ; i < N ; i ++ ) pref [ i ] = pref [ i - 1 ] + phi [ i ] ; }
function findCo_PrimePaths ( root , path ) { if ( root == null ) return ; path . push ( root . key ) ; findCo_PrimePaths ( root . left , path ) ; findCo_PrimePaths ( root . right , path ) ; if ( root . left == null && root . right == null ) { if ( isPathCo_Prime ( path ) ) { printCoPrimePaths ( path ) ; } } path . pop ( ) ; }
function sieve ( ) { position [ 0 ] = - 1 , position [ 1 ] = - 1 ; var pos = 0 ; for ( var i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( var j = i * 2 ; j <= limit ; j += i ) position [ j ] = - 1 ; } } }
function permutation ( arr , N ) { var hash = Array ( N + 1 ) . fill ( 0 ) ; for ( var i = 0 ; i < N ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( var i = 1 ; i <= N ; i ++ ) { if ( hash [ i ] != 1 ) return "No" ; } return "Yes" ; }
function isDivisible ( n ) { let d ; while ( parseInt ( n / 100 ) > 0 ) { d = n % 10 ; n = parseInt ( n / 10 )  n = Math . abs ( n + ( d * 13 ) ) ; } return ( n % 43 == 0 ) ; }
function countDigit ( n ) { var prime = Array ( 10 ) . fill ( false ) ; prime [ 2 ] = prime [ 3 ] = true ; prime [ 5 ] = prime [ 7 ] = true ; var temp = n , count = 0 ; while ( temp != 0 ) { var d = temp % 10 ; temp = parseInt ( temp / 10 ) ; if ( d > 0 && n % d == 0 && prime [ d ] ) count ++ ; } return count ; }
function maxValue ( a ) { var c = a . toString ( 2 ) ; var b = "" ; for ( var i = 0 ; i < c . length ; i ++ ) { if ( ( c [ i ] - "0" ) == 1 ) b += "0" ; else b += "1" ; } document . write ( parseInt ( b , 2 ) ) ; }
function nextFibonacci ( n ) { var a = n * ( 1 + Math . sqrt ( 5 ) ) / 2.0 ; return Math . round ( a ) ; }
function preCompute ( ) { for ( let i = 1 ; i < 100001 ; i ++ ) { pref [ i ] = pref [ i - 1 ] + checkArmstrong ( i ) ; } }
function isPrime ( N ) { let isPrime = true ; let arr = [ 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 ] ; if ( N < 2 ) { isPrime = false ; } if ( N % 2 == 0 N % 3 == 0 N % 5 == 0 ) { isPrime = false ; } for ( let i = 0 ; i < Math . sqrt ( N ) ; i += 30 ) { for ( let c of arr ) { if ( c > Math . sqrt ( N ) ) { break ; } else { if ( N % ( c + i ) == 0 ) { isPrime = false ; break ; } } if ( ! isPrime ) break ; } } if ( isPrime ) document . write ( "Prime▁Number" ) ; else document . write ( "Not▁a▁Prime▁Number" ) ; }
function perfectCube ( N ) { let cube ; for ( let i = 0 ; i <= N ; i ++ ) { cube = i * i * i ; if ( cube === N ) { document . write ( "Yes" ) ; return ; } else if ( cube > N ) { document . write ( "NO" ) ; return ; } } }
function isPrime ( n ) { if ( n <= 1 ) return false ; var i ; for ( i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
function count ( n , k ) { var sum = 0 ; for ( var j = 1 ; j <= k ; j ++ ) { sum = sum + binomialCoeff ( n , j ) ; } return sum ; }
function prevPowerofK ( n , k ) { var p = parseInt ( Math . log ( n ) / Math . log ( k ) ) ; return parseInt ( Math . pow ( k , p ) ) ; }
function kth_element ( a , n , k ) { let pos = [ ] ; let neg = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) pos . push ( a [ i ] ) ; else neg . push ( a [ i ] ) ; } sort ( pos . begin ( ) , pos . end ( ) ) ; sort ( neg . begin ( ) , neg . end ( ) ) ; pos . sort ( function ( a , b ) { return a - b } ) ; neg . sort ( function ( a , b ) { return a - b } ) ; let l = - 1e8 , ans = 0 , r = 1e8 ; while ( l <= r ) { let mid = ( l + r ) >> 1 ; if ( check ( mid , pos , neg , k ) ) { ans = mid ; r = mid - 1 ; } else l = mid + 1 ; } return ans ; }
function nextNumberDistinctDigit ( n ) { while ( n < INT_MAX ) { let distinct_digits = countDistinct ( n + 1 ) ; let total_digits = countDigit ( n + 1 ) ; if ( distinct_digits == total_digits ) { return n + 1 ; } else n ++ ; } return - 1 ; }
function Count_subarray ( arr , n ) { var total_sum = 0 , subarray_sum , remaining_sum , count = 0 ; for ( i = 0 ; i < n ; i ++ ) { total_sum += arr [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { subarray_sum = 0 ; for ( j = i ; j < n ; j ++ ) { subarray_sum += arr [ j ] ; remaining_sum = total_sum - subarray_sum ; if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; }
function getSum ( n ) { var sum = 0 ; if ( n == 1 ) { sum = 45.0 ; } else { sum = ( 99.0 / 2.0 ) * Math . pow ( 10 , n - 1 ) * Math . pow ( 10 , parseInt ( ( n - 1 ) / 2 ) ) ; } return sum ; }
function getSize ( a ) { let sz = 0 ; while ( a != null ) { a = a . next ; sz ++ ; } return sz ; }
function diameter ( n ) { var L , H , templen ; L = 1 ; H = 0 ; if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 2 ; } if ( n == 3 ) { return 3 ; } while ( L * 2 <= n ) { L *= 2 ; H ++ ; } if ( n >= L * 2 - 1 ) return 2 * H + 1 ; else if ( n >= L + ( L / 2 ) - 1 ) return 2 * H ; return 2 * H - 1 ; }
function countSquares ( n ) { return ( Math . pow ( n , 2 ) - ( 2 * n ) + 2 ) ; }
function max_element ( a , n ) { let pre = new Array ( n ) ; pre [ 0 ] = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) pre [ i ] = Math . max ( pre [ i - 1 ] , a [ i ] ) ; let suf = new Array ( n ) ; suf [ n - 1 ] = a [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = Math . max ( suf [ i + 1 ] , a [ i ] ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( i == 0 ) document . write ( suf [ i + 1 ] + "▁" ) ; else if ( i == n - 1 ) document . write ( pre [ i - 1 ] + "▁" ) ; else document . write ( Math . max ( pre [ i - 1 ] , suf [ i + 1 ] ) + "▁" ) ; } }
function cntCells ( n ) { var cells = Math . pow ( n , 2 ) + Math . pow ( n - 1 , 2 ) ; return cells ; }
function findNums ( n ) { if ( n <= 11 ) { if ( n == 8 ) document . write ( "4▁4" ) ; if ( n == 10 ) document . write ( "4▁6" ) ; else document . write ( "-1" ) ; return ; } if ( n % 2 == 0 ) document . write ( "4▁" + ( n - 4 ) ) ; else document . write ( "9▁" + ( n - 9 ) ) ; }
function oddFib ( n ) { n = ( 3 * n + 1 ) / 2 ; var a = - 1 , b = 1 , c , i ; for ( i = 1 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n == 2 n == 3 ) return true ; for ( let i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
function difference ( n ) { let S , res ; S = Math . floor ( ( n * ( n + 1 ) ) / 2 ) ; res = S * ( S - 1 ) ; return res ; }
function findSmallestNonZeroY ( A_num ) { let A_binary = ( A_num >>> 0 ) . toString ( 2 ) ; let B = 1 ; let len = A_binary . length ; let no_ones = bitCount ( A_num ) ; if ( len == no_ones ) { return A_num + 1 ; } for ( let i = 0 ; i < len ; i ++ ) { let ch = A_binary [ len - i - 1 ] ; if ( ch == "0" ) { B = Math . floor ( Math . pow ( 2.0 , i ) ) ; break ; } } return B ; }
function minimum_elements ( n , arr ) { if ( n < 3 ) return 0 ; let g , ans = 0 , diff , cnt ; diff = arr [ 1 ] - arr [ 0 ] ; g = diff ; for ( let i = 2 ; i < n ; i ++ ) { diff = arr [ i ] - arr [ i - 1 ] ; g = gcd ( g , diff ) ; } for ( let i = 1 ; i < n ; i ++ ) { diff = arr [ i ] - arr [ i - 1 ] ; cnt = parseInt ( diff / g ) ; ans += ( cnt - 1 ) ; } return ans ; }
function Digits ( n ) { let largest = 0 ; let smallest = 9 ; while ( n ) { let r = n % 10 ; largest = Math . max ( r , largest ) ; smallest = Math . min ( r , smallest ) ; n = parseInt ( n / 10 ) ; } document . write ( largest + "▁" + smallest ) ; }
function countWords ( N , M ) { return Math . pow ( N , M ) - nPr ( N , M ) ; }
function countBits ( n ) { let count = 0 ; while ( n ) { count ++ ; n >>= 1 ; } return count ; }
function sum_of_4_squares ( n ) { var i , odd = 0 , even = 0 ; for ( i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i % 2 == 0 ) even += i ; else odd += i ; if ( ( n / i ) != i ) { if ( ( n / i ) % 2 == 0 ) even += ( n / i ) ; else odd += ( n / i ) ; } } } if ( n % 2 == 1 ) return 8 * ( odd + even ) ; else return 24 * ( odd ) ; }
function Maximum_Length ( a ) { let counts = new Array ( 11 ) ; counts . fill ( 0 ) ; let ans = 0 ; for ( let index = 0 ; index < a . length ; index ++ ) { counts [ a [ index ] ] += 1 ; let k = [ ] ; for ( let i = 0 ; i < counts . length ; i ++ ) { if ( counts [ i ] != 0 ) { k . push ( i ) ; } } k . sort ( function ( a , b ) { return a - b } ) ; if ( k . length == 1 || ( k [ 0 ] == k [ k . length - 2 ] && k [ k . length - 1 ] - k [ k . length - 2 ] == 1 ) || ( k [ 0 ] == 1 && k [ 1 ] == k [ k . length - 1 ] ) ) ans = index ; } return ( ans ) ; }
function numberOfDays ( a , b , n ) { var Days = b * ( n + a ) / ( a + b ) ; return Days ; }
function countX ( a , b ) { if ( b > a ) return 0 ; else if ( a == b ) return - 1 ; else { let x = a - b , ans = 0 ; for ( let i = 1 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { let d1 = i , d2 = b - 1 ; if ( i * i != x ) d2 = parseInt ( x / i ) ; if ( d1 > b ) ans ++ ; if ( d2 > b ) ans ++ ; } } return ans ; } }
function isSafe ( N , M , str ) { var coll = 0 , colr = 0 , rowu = 0 , rowd = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == "L" ) { coll ++ ; if ( colr > 0 ) { colr -- ; } if ( coll == M ) { break ; } } else if ( str [ i ] == "R" ) { colr ++ ; if ( coll > 0 ) { coll -- ; } if ( colr == M ) { break ; } } else if ( str [ i ] == "U" ) { - rowu ++ ; if ( rowd > 0 ) { rowd -- ; } if ( rowu == N ) { break ; } } else if ( str [ i ] == "D" ) { rowd ++ ; if ( rowu > 0 ) { rowu -- ; } if ( rowd == N ) { break ; } } } if ( Math . abs ( rowd ) < N && Math . abs ( rowu ) < N && Math . abs ( coll ) < M && Math . abs ( colr ) < M ) { return true ; } return false ; }
function countOnes ( arr , N ) { for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = i ; j <= N ; j ++ ) { if ( j % i == 0 ) { if ( arr [ j - 1 ] == 0 ) arr [ j - 1 ] = 1 ; else arr [ j - 1 ] = 0 ; } } } let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( arr [ i ] == 1 ) count ++ ; return count ; }
function power ( x , y , p ) { while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; }
function findSum ( num ) { let sumo = 0 ; let sume = 0 ; let x = 1 ; let cur = 0 ; let ans = 0 ; while ( num > 0 ) { let inc = Math . min ( x , num ) ; num -= inc ; if ( cur == 0 ) { ans = ans + sumodd ( sumo + inc ) - sumodd ( sumo ) ; sumo += inc ; } else { ans = ans + sumeven ( sume + inc ) - sumeven ( sume ) ; sume += inc ; } x *= 2 ; cur ^= 1 ; } return ans ; }
function noOfYears ( t1 , n1 , t2 ) { var years = ( ( t2 - 1 ) * n1 / ( t1 - 1 ) ) ; return years ; }
function isPossible ( n ) { var fac = new Array ( 10 ) ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( var i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; var sum = 0 ; var x = n ; while ( x != 0 ) { sum += fac [ x % 10 ] ; x = parseInt ( x / 10 ) ; } if ( sum % n == 0 ) return true ; return false ; }
function countSquares ( r , c , m ) { let squares = 0 ; for ( let i = 1 ; i <= 8 ; i ++ ) { for ( let j = 1 ; j <= 8 ; j ++ ) { if ( Math . max ( Math . abs ( i - r ) , Math . abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; }
function minOperations ( n , m ) { if ( m % n != 0 ) return - 1 ; var minOperations = 0 ; var q = m / n ; while ( q % 2 == 0 ) { q = q / 2 ; minOperations ++ ; } while ( q % 3 == 0 ) { q = q / 3 ; minOperations ++ ; } if ( q == 1 ) return minOperations ; return - 1 ; }
function getCount ( a , b , c ) { let count = 0 ; for ( let i = 1 ; i <= 81 ; i ++ ) { let cr = b * Math . pow ( i , a ) + c ; let tmp = cr ; let sm = 0 ; while ( tmp != 0 ) { sm += tmp % 10 ; tmp = Math . floor ( tmp / 10 ) ; } if ( sm == i && cr < 1e9 ) count ++ ; } return count ; }
function checkSpecialPrime ( sieve , num ) { while ( num > 0 ) { if ( sieve [ num ] ) { return false ; } num = parseInt ( num / 10 ) ; } return true ; }
function canTakeDown ( bishopX , bishopY , pawnX , pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; }
function isPossible ( n , k , arr ) { let sum = arr [ 0 ] ; let maxVal = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { sum += arr [ i ] ; maxVal = Math . max ( maxVal , arr [ i ] ) ; } if ( maxVal > ( sum + k ) / n ) return false ; return true ; }
function checkTriangularSumRepresentation ( n ) { var tri = new Set ( ) ; var i = 1 ; while ( 1 ) { var x = i * parseInt ( ( i + 1 ) / 2 ) ; if ( x >= n ) break ; tri . add ( x ) ; i ++ ; } var ans = false ; tri . forEach ( tm => { if ( tri . has ( n - tm ) ) ans = true } ) ; return ans ; }
function secondary_polygon ( Angle ) { var edges_primary = 360 / Angle ; if ( edges_primary >= 6 ) { var edges_max_secondary = edges_primary / 2 ; document . write ( edges_max_secondary + 3 ) ; } else document . write ( "Not▁Possible" ) ; }
function CPwithProfit ( sellingPrice , profit ) { var costPrice ; costPrice = ( sellingPrice * 100 ) / ( 100 + profit ) ; return costPrice ; }
function removeZero ( n ) { let res = 0 ; let d = 1 ; while ( n > 0 ) { if ( n % 10 != 0 ) { res += ( n % 10 ) * d ; d *= 10 ; } n = Math . floor ( n / 10 ) ; } return res ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
function ETF ( ) { for ( i = 1 ; i <= n ; i ++ ) { phi [ i ] = i ; } for ( i = 2 ; i <= n ; i ++ ) { if ( phi [ i ] == i ) { phi [ i ] = i - 1 ; for ( j = 2 * i ; j <= n ; j += i ) { phi [ j ] = ( phi [ j ] * ( i - 1 ) ) / i ; } } } }
function checkIsHP ( arr ) { let n = arr . length ; if ( n == 1 ) { return true ; } let rec = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { rec . push ( ( 1 / arr [ i ] ) ) ; } rec . sort ( ( a , b ) => a - b ) ; let d = ( rec [ 1 ] ) - ( rec [ 0 ] ) ; for ( let i = 2 ; i < n ; i ++ ) { if ( rec [ i ] - rec [ i - 1 ] != d ) { return false ; } } return true ; }
function Valid ( a , b , c ) { if ( a + b + c == 180 && a != 0 && b != 0 && c != 0 ) return 1 ; else return 0 ; }
function solve ( n , base ) { var sum = 0 ; while ( n > 0 ) { var remainder = n % base ; sum += remainder ; n = parseInt ( n / base ) ; } return sum ; }
function SieveOfEratosthenes ( prime , p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( let i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } }
function findEle ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] == sum - arr [ i ] ) return arr [ i ] ; return - 1 ; }
function divisibleBy3 ( number ) { let sumOfDigit = 0 ; for ( let i = 0 ; i < number . length ; i ++ ) sumOfDigit += number [ i ] - "0" ; if ( sumOfDigit % 3 == 0 ) return true ; return false ; }
function isPrime ( n ) { if ( n <= 1 ) return false ; for ( var i = 2 ; i <= parseInt ( Math . sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
function largestNumber ( n ) { var s = "" ; var duplicate = n ; while ( n > 0 ) { s = String . fromCharCode ( n % 10 + 48 ) + s ; n = parseInt ( n / 10 ) ; } var index = - 1 ; for ( i = 0 ; i < s . length ; i ++ ) { if ( ( ( s . charAt ( i ) . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) % 2 & 1 ) == 0 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; var num = 0 ; for ( i = 0 ; i < index ; i ++ ) num = num * 10 + ( s . charAt ( i ) . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) ; num = num * 10 + ( s . charAt ( index ) . charCodeAt ( 0 ) - ( "0" ) . charCodeAt ( 0 ) - 1 ) ; for ( i = index + 1 ; i < s . length ; i ++ ) num = num * 10 + 9 ; return num ; }
function Sum_upto_nth_Term ( n ) { let r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; document . write ( r ) ; }
function get_unit_digit ( N ) { if ( N == 0 N == 1 ) return 1 ; else if ( N == 2 ) return 3 ; else if ( N == 3 ) return 9 ; return 3 ; }
function SieveOfEratosthenes ( ) { let prime = new Array ( MAX ) ; for ( let i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } let product = 1 ; for ( let p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { product = product * p ; s . add ( product + 1 ) ; } } }
function SieveOfEratosthenes ( ) { for ( i = 0 ; i <= MAX ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; for ( p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
function findF_N ( n ) { var ans = 0 ; for ( var i = 0 ; i < n ; ++ i ) ans += ( i + 1 ) * ( n - i - 1 ) ; return ans ; }
function PrimeFactors ( n ) { let v = [ ] ; let x = n ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( x % i == 0 ) { v . push ( i ) ; while ( x % i == 0 ) x = Math . floor ( x / i ) ; } } if ( x > 1 ) v . push ( x ) ; return v ; }
function computeSemiPrime ( ) { for ( var i = 2 ; i < MAX ; i ++ ) { var cnt = 0 ; var num = i ; for ( var j = 2 ; cnt < 2 && j * j <= num ; ++ j ) { while ( num % j == 0 ) { } } if ( num > 1 ) ++ cnt ; if ( cnt == 2 ) { sprime [ i ] = true ; arr . push ( i ) ; } } }
function sumProductDifference ( a , b , c , d , e ) { var rootSum = ( - 1 * b ) / a ; var rootProduct = e / a ; return Math . abs ( rootSum - rootProduct ) ; }
function findAnglesA ( a , b , c ) { let A = Math . acos ( ( b * b + c * c - a * a ) / ( 2 * b * c ) ) ; return A * 180 / PI ; }
function findAnglesB ( a , b , c ) { let B = Math . acos ( ( a * a + c * c - b * b ) / ( 2 * a * c ) ) ; return B * 180 / PI ; }
function isPerfectSquare ( x ) { sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; }
function findSum ( N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; }
function isPower ( a ) { if ( a == 1 ) return true ; for ( let i = 2 ; i * i <= a ; i ++ ) { let val = Math . log ( a ) / Math . log ( i ) ; if ( ( val - Math . floor ( val ) ) < 0.00000001 ) return true ; } return false ; }
function mostFrequent ( arr , n ) { var hash = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( hash . has ( arr [ i ] ) ) hash . set ( arr [ i ] , hash . get ( arr [ i ] ) + 1 ) else hash . set ( arr [ i ] , 1 ) } var max_count = 0 , res = - 1 ; hash . forEach ( ( value , key ) => { if ( max_count < value ) { res = key ; max_count = value ; } } ) ; return res ; }
function Profit ( costPrice , sellingPrice ) { let profit = ( sellingPrice - costPrice ) ; return profit ; }
function check ( n ) { let sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = Math . floor ( n / 10 ) ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; }
function isPrime ( num ) { if ( num < 2 num % 2 == 0 ) return num == 2 ; for ( i = 3 ; i * i <= num ; i += 2 ) if ( num % i == 0 ) return false ; return true ; }
function value ( a , b , c ) { let co = 0 , p = 0 ; let no , r = 0 , x = 0 , q = 0 , w = 0 ; let v = [ ] ; for ( let i = 1 ; i < 82 ; i ++ ) { no = Math . pow ( i , a ) ; no = b * no + c ; if ( no > 0 && no < 1000000000 ) { x = getsum ( no ) ; if ( x == i ) { q ++ ; v . push ( no ) ; w ++ ; } } } for ( let i = 0 ; i < v . length ; i ++ ) { document . write ( v [ i ] + "▁" ) ; } }
function countOddSum ( ar , n ) { let result = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { let val = 0 ; for ( let j = i ; j <= n - 1 ; j ++ ) { val = val + ar [ j ] ; if ( val % 2 != 0 ) result ++ ; } } return ( result ) ; }
function printSeries ( n ) { var prev = 0 ; var curr ; for ( var i = 1 ; i <= n ; i ++ ) { curr = findTriangularNumber ( i ) ; curr = curr + prev ; document . write ( curr + "▁" ) ; prev = curr ; } }
function rev ( n , temp ) { if ( n == 0 ) return temp ; temp = ( temp * 10 ) + ( n % 10 ) ; return rev ( Math . floor ( n / 10 ) , temp ) ; }
function determinantOfMatrix ( mat ) { let ans ; ans = mat [ 0 ] [ 0 ] * ( mat [ 1 ] [ 1 ] * mat [ 2 ] [ 2 ] - mat [ 2 ] [ 1 ] * mat [ 1 ] [ 2 ] ) - mat [ 0 ] [ 1 ] * ( mat [ 1 ] [ 0 ] * mat [ 2 ] [ 2 ] - mat [ 1 ] [ 2 ] * mat [ 2 ] [ 0 ] ) + mat [ 0 ] [ 2 ] * ( mat [ 1 ] [ 0 ] * mat [ 2 ] [ 1 ] - mat [ 1 ] [ 1 ] * mat [ 2 ] [ 0 ] ) ; return ans ; }
function calculateSeries ( n ) { return 2 + ( n * n + n - 2 ) * factorial ( n + 1 ) ; }
function isEmirpimes ( n ) { if ( checkSemiprime ( n ) == false ) return false ; let r = 0 ; for ( let t = n ; t != 0 ; t = parseInt ( t / n , 10 ) ) r = r * 10 + t % 10 ; if ( r == n ) return false ; return ( checkSemiprime ( r ) ) ; }
function isTriangular ( num ) { if ( num < 0 ) return 0 ; var c = ( - 2 * num ) ; var b = 1 , a = 1 ; var d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return - 1 ; var root1 = ( - b + Math . sqrt ( d ) ) / ( 2 * a ) ; var root2 = ( - b - Math . sqrt ( d ) ) / ( 2 * a ) ; if ( parseInt ( ( root1 ) ) > 0 && parseInt ( ( Math . floor ( root1 ) ) ) == parseInt ( ( root1 ) ) ) return parseInt ( root1 ) ; if ( parseInt ( ( root2 ) ) > 0 && parseInt ( ( Math . floor ( root2 ) ) ) == parseInt ( ( root2 ) ) ) return parseInt ( ( root2 ) ) ; return - 1 ; }
function calculateProbability ( N ) { let probability = N / ( N + 1 ) ; return probability ; }
function fnMod ( n ) { if ( n % 5 == 1 ) return 4 ; else return 0 ; }
function findHcf ( arr , size ) { let ans = arr [ 0 ] [ 0 ] ; for ( let i = 1 ; i < size ; i ++ ) ans = gcd ( ans , arr [ i ] [ 0 ] ) ; return ( ans ) ; }
function nthTrimorphic ( n ) { let count = 0 ; for ( let i = 0 ; i < LET_MAX ; i ++ ) { if ( checkTrimorphic ( i ) ) count ++ ; if ( count == n ) return i ; } return - 1 ; }
function check ( n ) { let m = n ; while ( n ) { let r = n % 10 ; if ( r > 0 ) if ( ( n % r ) != 0 ) return false ; n /= 10 ; } return true ; }
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + i * ( i + 1 ) * ( i + 2 ) ; return sum ; }
function generatePrimeFactors ( ) { factor [ 1 ] = 1 ; for ( i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } }
function quadrant ( x , y ) { if ( x > 0 && y > 0 ) document . write ( "lies▁in▁First▁quadrant" ) ; else if ( x < 0 && y > 0 ) document . write ( "lies▁in▁Second▁quadrant" ) ; else if ( x < 0 && y < 0 ) document . write ( "lies▁in▁Third▁quadrant" ) ; else if ( x > 0 && y < 0 ) document . write ( "lies▁in▁Fourth▁quadrant" ) ; else if ( x == 0 && y > 0 ) document . write ( "lies▁at▁positive▁y▁axis" ) ; else if ( x == 0 && y < 0 ) document . write ( "lies▁at▁negative▁y▁axis" ) ; else if ( y == 0 && x < 0 ) document . write ( "lies▁at▁negative▁x▁axis" ) ; else if ( y == 0 && x > 0 ) document . write ( "lies▁at▁positive▁x▁axis" ) ; else document . write ( "lies▁at▁origin" ) ; }
function kthgroupsum ( k ) { return k * k * k ; }
function kmphTOmph ( kmph ) { return ( 0.6214 * kmph ) ; }
function point ( a , b , c , d , n ) { let x ; let flag = 0 ; for ( let i = 0 ; i < n ; i ++ ) { x = b + i * a ; if ( ( x - d ) % c == 0 && x - d >= 0 ) { document . write ( x ) ; flag = 1 ; break ; } } if ( flag == 0 ) { document . write ( "No▁collision▁point" ) ; } }
function fact ( n ) { var f = 1 ; for ( var i = 2 ; i <= n ; i ++ ) f *= i ; return f ; }
function isPalindrome ( n ) { var divide = ( isOctal ( n ) == false ) ? 8 : 10 ; var octal = new Array ( MAX_DIGITS ) ; var i = 0 ; while ( n != 0 ) { octal [ i ++ ] = n % divide ; n = Math . floor ( n / divide ) ; } for ( var j = i - 1 , k = 0 ; k <= j ; j -- , k ++ ) if ( octal [ j ] != octal [ k ] ) return false ; return true ; }
function isThreeDisctFactors ( n ) { let sq = parseInt ( Math . sqrt ( n ) ) ; if ( sq * sq != n ) return false ; return isPrime ( sq ) ? true : false ; }
function decToHexa ( n ) { var hexaDeciNum = Array . from ( { length : 100 } , ( _ , i ) => 0 ) ; var i = 0 ; while ( n != 0 ) { var temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = String . fromCharCode ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = String . fromCharCode ( temp + 55 ) ; i ++ ; } n = parseInt ( n / 16 ) ; } for ( j = i - 1 ; j >= 0 ; j -- ) document . write ( hexaDeciNum [ j ] ) ; }
function binaryToDecimal ( n ) { let num = n ; let dec_value = 0 ; let base = 1 ; let temp = num ; while ( temp ) { let last_digit = temp % 10 ; temp = Math . floor ( temp / 10 ) ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }
function closestMultiple ( n , x ) { if ( x > n ) return x ; n = n + parseInt ( x / 2 , 10 ) ; n = n - ( n % x ) ; return n ; }
function firstkdigits ( n , k ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) product *= n ; while ( Math . floor ( product / Math . pow ( 10 , k ) ) != 0 ) product = Math . floor ( product / 10 ) ; return product ; }
function countDigits ( n ) { let count = 0 ; while ( n > 0 ) { count ++ ; n = Math . floor ( n / 10 ) ; } return count ; }
function printGenerators ( n ) { document . write ( "1▁" ) ; for ( var i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) document . write ( i + "▁" ) ; }
function SubArraySum ( arr , n ) { let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; }
function generateNumbers ( factor , n , k ) { let next = new Array ( k ) ; next . fill ( 0 ) ; for ( let i = 0 ; i < n ; ) { let toincrement = 0 ; for ( let j = 0 ; j < k ; j ++ ) if ( next [ j ] < next [ toincrement ] ) toincrement = j ; if ( output != next [ toincrement ] ) { output = next [ toincrement ] ; document . write ( next [ toincrement ] + "▁" ) ; i ++ ; } next [ toincrement ] += factor [ toincrement ] ; } }
function sumofproduct ( n ) { var ans = 0 ; for ( x = 1 ; x <= n ; x ++ ) { var y = parseInt ( n / x ) ; ans += ( y * x ) ; } return ans ; }
function findPrimePair ( n ) { let isPrime = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { isPrime [ i ] = false ; } SieveOfEratosthenes ( n , isPrime ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( isPrime [ i ] && isPrime [ n - i ] ) { document . write ( i + "▁" + ( n - i ) ) ; return ; } } }
function lcm ( n ) { let ans = 1 ; for ( let i = 1 ; i <= n ; i ++ ) ans = ( ans * i ) / ( gcd ( ans , i ) ) ; return ans ; }
function findSmallestPrimeFactors ( ) { for ( let i = 0 ; i < maxn ; i ++ ) smallest_prime [ i ] = INF ; for ( let i = 2 ; i < maxn ; i ++ ) { if ( smallest_prime [ i ] == INF ) { smallest_prime [ i ] = i ; for ( let j = i * i ; j < maxn ; j += i ) { if ( smallest_prime [ j ] > i ) smallest_prime [ j ] = i ; } } } }
function prepareSum ( s ) { sum [ 0 ] = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { sum [ i + 1 ] = sum [ i ] + toInt ( s [ i ] ) ; } }
function oneDigit ( num ) { return ( num >= 0 && num < 10 ) ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
function updateBIT ( BITree , n , index , val ) { while ( index <= n ) { BITree [ index ] += val ; index += index & ( - index ) ; } }
function nearestSmallerEqFib ( n ) { if ( n == 0 n == 1 ) return n ; let f1 = 0 ; let f2 = 1 ; let f3 = 1 ; while ( f3 <= n ) { f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return f2 ; }
function mod ( num , a ) { let res = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) res = ( res * 10 + num [ i ] - "0" ) % a ; return res ; }
function replace0with5 ( number ) { return number += calculateAddedValue ( number ) ; }
function findXOR ( X ) { let ans = 0 ; while ( X != 0 ) { ans ^= ( X % 10 ) ; X /= 10 ; } return ans ; }
function findLen ( arr , n , m ) { var filter = [ ] ; for ( var i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] m ) == m ) filter . push ( arr [ i ] ) ; if ( filter . length == 0 ) return 0 ; var c_or = filter [ 0 ] ; for ( var i = 1 ; i < filter . length ; i ++ ) c_or |= filter [ i ] ; if ( c_or == m ) return filter . length ; return 0 ; }
function Add_Edge ( x , y ) { al [ x ] . push ( y ) ; root_node [ y ] = false ; }
function multiplyByFifteen ( n ) { let prod = ( n << 4 ) ; prod = prod - n ; return prod ; }
function ternary ( number ) { let ans = 0 , rem = 1 , base = 1 ; while ( number > 0 ) { rem = number % 3 ; ans = ans + rem * base ; number = Math . floor ( number / 3 ) ; base = base * 10 ; } return ans ; }
function ReplaceElements ( arr , n ) { let X = 0 ; for ( let i = 0 ; i < n ; ++ i ) { X ^= arr [ i ] ; } for ( let i = 0 ; i < n ; ++ i ) { arr [ i ] = X ^ arr [ i ] ; } }
function findSubArray ( arr , n ) { let sum = 0 ; let maxsize = - 1 , startindex = 0 ; let endindex = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) document . write ( "No▁such▁subarray" ) ; else document . write ( startindex + "▁to▁" + endindex ) ; return maxsize ; }
function BinaryLifting ( presum , n , k ) { let pos = 0 ; let LOGN = Math . log ( n ) ; if ( x <= presum [ 0 ] ) return 0 ; for ( let i = LOGN ; i >= 0 ; i -- ) { if ( pos + ( 1 << i ) < n && presum [ pos + ( 1 << i ) ] < x ) { pos += ( 1 << i ) ; } } return pos + 1 ; }
function setbitsfromLtoR ( L , R ) { return ( 1 << ( R + 1 ) ) - ( 1 << L ) ; }
function isFibbinaryNum ( n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; }
function oddbitsetnumber ( n ) { let count = 0 ; let res = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
function posOfRightmostSetBit ( n ) { return parseInt ( Math . log ( n & - n ) / Math . log ( 2 ) ) + 1 ; }
function modifyBit ( n , p , b ) { let mask = 1 << p ; return ( n & ~ mask ) | ( ( b << p ) & mask ) ; }
function isOnesComplementOfOther ( a , b ) { return areAllBitsSet ( a ^ b ) ; }
function setBitNumber ( n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; }
function posOfRightMostSameBit ( m , n ) { let loopCounter = 1 ; while ( m > 0 n > 0 ) { let a = m % 2 == 1 ; let b = n % 2 == 1 ; if ( ! ( a ^ b ) ) { return loopCounter ; } m = m >> 1 ; n = n >> 1 ; loopCounter ++ ; } return - 1 ; }
function CountZeroBit ( n ) { let count = 0 ; while ( n > 0 ) { if ( n % 2 != 0 ) count ++ ; n >>= 1 ; } return count ; }
function countPairsWithKDiff ( arr , n , k ) { for ( let i = 0 ; i < n - 1 ; ++ i ) { for ( let j = i + 1 ; j < n ; ++ j ) { let xoredNum = arr [ i ] ^ arr [ j ] ; if ( k == bitCount ( xoredNum ) ) ++ ans ; } } return ans ; }
function countTrailingZero ( x ) { let lookup = [ 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 ] ; return lookup [ ( - x & x ) % 37 ] ; }
function maxConsecutiveOnes ( x ) { let count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; }
function findXOR ( Set , n ) { if ( n == 1 ) return Set [ 0 ] ; else return 0 ; }
function findFourElements ( arr , n ) { let map = new Map ( ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { map . set ( arr [ i ] + arr [ j ] , new Indexes ( i , j ) ) ; } } let d = Number . MIN_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { let abs_diff = Math . abs ( arr [ i ] - arr [ j ] ) ; if ( map . has ( abs_diff ) ) { let indexes = map . get ( abs_diff ) ; if ( indexes . getI ( ) != i && indexes . getI ( ) != j && indexes . getJ ( ) != i && indexes . getJ ( ) != j ) { d = Math . max ( d , Math . max ( arr [ i ] , arr [ j ] ) ) ; } } } } return d ; }
function recaman ( n ) { if ( n <= 0 ) return ; document . write ( 0 + "%d,▁" ) ; let s = new Set ( ) ; s . add ( 0 ) ; let prev = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let curr = prev - i ; if ( curr < 0 || s . has ( curr ) ) curr = prev + i ; s . add ( curr ) ; document . write ( curr + "%d,▁" ) ; prev = curr ; } }
function findMin ( arr , low , high ) { while ( low < high ) { let mid = Math . floor ( low + ( high - low ) / 2 ) ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; }
function splitArr ( arr , n , k ) { for ( let i = 0 ; i < k ; i ++ ) { let x = arr [ 0 ] ; for ( let j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }
function printSmall ( arr , n , k ) { for ( let i = k ; i < n ; ++ i ) { let max_var = arr [ k - 1 ] ; let pos = k - 1 ; for ( let j = k - 2 ; j >= 0 ; j -- ) { if ( arr [ j ] > max_var ) { max_var = arr [ j ] ; pos = j ; } } if ( max_var > arr [ i ] ) { let j = pos ; while ( j < k - 1 ) { arr [ j ] = arr [ j + 1 ] ; j ++ ; } arr [ k - 1 ] = arr [ i ] ; } } for ( let i = 0 ; i < k ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function findFirstMissing ( array , start , end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; let mid = parseInt ( ( start + end ) / 2 , 10 ) ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; }
function countInRange ( arr , n , x , y ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; }
function upperIndex ( arr , n , y ) { let l = 0 , h = n - 1 ; while ( l <= h ) { let mid = parseInt ( ( l + h ) / 2 , 10 ) ; if ( arr [ mid ] <= y ) l = mid + 1 ; else h = mid - 1 ; } return h ; }
function printArray ( arr , size ) { let i = 0 ; for ( i = 0 ; i < size ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } document . write ( "" ) ; }
function findPeakUtil ( arr , low , high , n ) { var mid = low + parseInt ( ( high - low ) / 2 ) ; if ( ( mid == 0 arr [ mid - 1 ] <= arr [ mid ] ) && ( mid == n - 1 arr [ mid + 1 ] <= arr [ mid ] ) ) return mid ; else if ( mid > 0 && arr [ mid - 1 ] > arr [ mid ] ) return findPeakUtil ( arr , low , ( mid - 1 ) , n ) ; else return findPeakUtil ( arr , ( mid + 1 ) , high , n ) ; }
function maximum ( a , b , c ) { return Math . max ( Math . max ( a , b ) , c ) ; }
function printClosest ( arr , n , x ) { let res_l = 0 , res_r = 0 ; let l = 0 , r = n - 1 , diff = Number . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } document . write ( "▁The▁closest▁pair▁is▁" + arr [ res_l ] + "▁and▁" + arr [ res_r ] ) ; }
function findPartiion ( arr , n ) { let sum = 0 ; let i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; let part = new Array ( parseInt ( sum / 2 + 1 , 10 ) ) ; for ( i = 0 ; i <= parseInt ( sum / 2 , 10 ) ; i ++ ) { part [ i ] = false ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = parseInt ( sum / 2 , 10 ) ; j >= arr [ i ] ; j -- ) { if ( part [ j - arr [ i ] ] == true j == arr [ i ] ) part [ j ] = true ; } } return part [ parseInt ( sum / 2 , 10 ) ] ; }
function solveWordWrap ( l , n , M ) { let extras = new Array ( n + 1 ) ; let lc = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { extras [ i ] = new Array ( n + 1 ) ; lc [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { extras [ i ] [ j ] = 0 ; lc [ i ] [ j ] = 0 ; } } let c = new Array ( n + 1 ) ; let p = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) { extras [ i ] [ i ] = M - l [ i - 1 ] ; for ( let j = i + 1 ; j <= n ; j ++ ) extras [ i ] [ j ] = extras [ i ] [ j - 1 ] - l [ j - 1 ] - 1 ; } for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = i ; j <= n ; j ++ ) { if ( extras [ i ] [ j ] < 0 ) lc [ i ] [ j ] = MAX ; else if ( j == n && extras [ i ] [ j ] >= 0 ) lc [ i ] [ j ] = 0 ; else lc [ i ] [ j ] = extras [ i ] [ j ] * extras [ i ] [ j ] ; } } c [ 0 ] = 0 ; for ( let j = 1 ; j <= n ; j ++ ) { c [ j ] = MAX ; for ( let i = 1 ; i <= j ; i ++ ) { if ( c [ i - 1 ] != MAX && lc [ i ] [ j ] != MAX && ( c [ i - 1 ] + lc [ i ] [ j ] < c [ j ] ) ) { c [ j ] = c [ i - 1 ] + lc [ i ] [ j ] ; p [ j ] = i ; } } } printSolution ( p , n ) ; }
function optCost ( freq , i , j ) { if ( j < i ) return 0 ; if ( j == i ) return freq [ i ] ; var fsum = sum ( freq , i , j ) ; var min = Number . MAX_SAFE_INTEGER ; for ( var r = i ; r <= j ; ++ r ) { var cost = optCost ( freq , i , r - 1 ) + optCost ( freq , r + 1 , j ) ; if ( cost < min ) min = cost ; } return min + fsum ; }
function minCoins ( coins , m , V ) { if ( V == 0 ) return 0 ; let res = Number . MAX_VALUE ; for ( let i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { let sub_res = minCoins ( coins , m , V - coins [ i ] ) ; if ( sub_res != Number . MAX_VALUE && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; }
function power ( x , y ) { if ( y == 0 ) return 1 ; if ( x == 0 ) return 0 ; return x * power ( x , y - 1 ) ; }
function maximumNumberDistinctPrimeRange ( m , n ) { let factorCount = new Array ( n + 1 ) ; let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { factorCount [ i ] = 0 ; prime [ i ] = true ; } for ( let i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) { factorCount [ i ] = 1 ; for ( let j = i * 2 ; j <= n ; j += i ) { factorCount [ j ] ++ ; prime [ j ] = false ; } } } let max = factorCount [ m ] ; let num = m ; for ( let i = m ; i <= n ; i ++ ) { if ( factorCount [ i ] > max ) { max = factorCount [ i ] ; num = i ; } } return num ; }
function getSingle ( arr , n ) { let result = 0 ; let x , sum ; for ( let i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( let j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & x ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; }
function countSetBits ( n ) { let i = 0 ; let ans = 0 ; while ( ( 1 << i ) <= n ) { let k = 0 ; let change = 1 << i ; for ( let j = 0 ; j <= n ; j ++ ) { ans += k ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; }
function swapBits ( x , p1 , p2 , n ) { let set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; let set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; let xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; let result = x ^ xor ; return result ; }
function minSwaps ( n , pairs , arr ) { var index = Array ( 2 * n + 1 ) . fill ( 0 ) ; for ( i = 1 ; i <= 2 * n ; i ++ ) index [ arr [ i ] ] = i ; return minSwapsUtil ( arr , pairs , index , 1 , 2 * n ) ; }
function maxOfSegmentMins ( a , n , k ) { if ( k == 1 ) { a . sort ( ) ; return a [ 0 ] ; } if ( k == 2 ) return Math . max ( a [ 0 ] , a [ n - 1 ] ) ; return a [ n - 1 ] ; }
function MinOperation ( a , b , n ) { a . sort ( function ( a , b ) { return a - b } ) ; b . sort ( function ( a , b ) { return a - b } ) ; let result = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( a [ i ] > b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; } return result ; }
function findMissing ( arr1 , arr2 , M , N ) { if ( M != N - 1 && N != M - 1 ) { document . write ( "Invalid▁Input" ) ; return ; } let res = 0 ; for ( let i = 0 ; i < M ; i ++ ) res = res ^ arr1 [ i ] ; for ( let i = 0 ; i < N ; i ++ ) res = res ^ arr2 [ i ] ; document . write ( "Missing▁element▁is▁" + res ) ; }
function calculate ( a , n ) { a . sort ( ) ; let i , j ; let s = [ ] ; for ( i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . push ( ( a [ i ] + a [ j ] ) ) ; let mini = Math . min ( ... s ) ; let maxi = Math . max ( ... s ) ; return Math . abs ( maxi - mini ) ; }
function findMinSum ( a , b , n ) { a . sort ( ) ; b . sort ( ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + Math . abs ( a [ i ] - b [ i ] ) ; return sum ; }
function push ( head_ref , new_data ) { var new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; head = head_ref ; }
function fun ( arr , k ) { var n = 4 - 1 ; var v = n - k ; if ( v >= 0 ) { reverse ( arr , 0 , v ) ; reverse ( arr , v + 1 , n ) ; reverse ( arr , 0 , n ) ; } }
function rotateSubList ( A , m , n , k ) { var size = n - m + 1 ; if ( k > size ) { k = k % size ; } if ( k == 0 k == size ) { var head = A ; while ( head != null ) { document . write ( head . data ) ; head = head . next ; } return ; } var link = null ; if ( m == 1 ) { link = A ; } var c = A ; var count = 0 ; var end = null ; var pre = null ; while ( c != null ) { count ++ ; if ( count == m - 1 ) { pre = c ; link = c . next ; } if ( count == n - k ) { if ( m == 1 ) { end = c ; A = c . next ; } else { end = c ; pre . next = c . next ; } } if ( count == n ) { var d = c . next ; c . next = link ; end . next = d ; var head = A ; while ( head != null ) { document . write ( head . data + "▁" ) ; head = head . next ; } return ; } c = c . next ; } }
function printArray ( arr , size ) { for ( let i = 0 ; i < size ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function createHash ( hash , maxElement ) { var prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr <= maxElement ) { var temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } }
function solve ( N , M ) { var ans = ( N ) * parseInt ( ( M / 2 ) ) ; if ( M % 2 == 1 ) { ans += parseInt ( ( N + 1 ) / 2 ) ; } document . write ( ans ) ; }
function rangeXor ( BITree , l , r ) { return getXOR ( BITree , r ) ^ getXOR ( BITree , l - 1 ) ; }
function query ( L , R ) { if ( L == 0 ) return prefix [ R ] ; return prefix [ R ] - prefix [ L - 1 ] ; }
function game ( v , n ) { let m = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! m . has ( v [ i ] ) ) m . set ( v [ i ] , 1 ) ; else m . set ( v [ i ] , m . get ( v [ i ] ) + 1 ) ; } let count = 0 ; let check = 0 ; for ( let [ key , value ] of m . entries ( ) ) { if ( value > 1 ) { if ( value >= 4 && value % 2 == 0 ) check ++ ; count ++ ; } } let flag ; if ( check % 2 != 0 ) flag = false ; if ( check % 2 != 0 ) document . write ( "Yes" ) ; else if ( n % 2 == 0 && count % 2 == 0 ) document . write ( "No" ) ; else document . write ( "Yes" ) ; }
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
function SieveOfEratosthenes ( ) { for ( i = 0 ; i < N ; i ++ ) prime [ i ] = 1 ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( p = 2 ; p * p < N ; p ++ ) { if ( prime [ p ] == 1 ) { for ( i = p * p ; i < N ; i += p ) prime [ i ] = 0 ; } } }
function fact ( n ) { return factTR ( n , 1 ) ; }
function maximumMedian ( arr , N , K ) { let low = 0 , high = 1e9 ; while ( low < high ) { let mid = low + Math . floor ( ( high - low ) / 2 ) ; if ( isMaximumMedian ( arr , N , K , mid ) ) { low = mid + 1 ; } else { high = mid ; } } return low ; }
function findMinDays ( arr , R , N , X , K ) { let low = 0 , high = X ; let minDays ; while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let temp = arr [ i ] + R [ i ] * mid ; if ( temp >= K ) { sum += temp ; } } if ( sum >= X ) { minDays = mid ; high = mid - 1 ; } else { low = mid + 1 ; } } document . write ( minDays ) ; }
function maximumIndices ( arr , N ) { let temp = new Array ( N ) . fill ( 0 ) ; let maxIndices = parseInt ( ( N - 1 ) / 2 ) ; arr . sort ( function ( a , b ) { return a - b ; } )  for ( let i = 0 ; i < maxIndices ; i ++ ) { temp [ 2 * i + 1 ] = arr [ i ] ; } let j = 0 ; for ( let i = maxIndices ; i < N ; ) { if ( temp [ j ] == 0 ) { temp [ j ] = arr [ i ] ; i ++ ; } j ++ ; } for ( let i = 0 ; i < N ; i ++ ) { document . write ( temp [ i ] + "▁" ) ; } }
function check ( n , m , x , y , vl ) { var temp = m ; if ( vl > n ) return false ; var ex = n - vl ; ex *= y ; temp += ex ; var cr = parseInt ( temp / x ) ; if ( cr >= vl ) return true ; return false ; }
function findPoint ( arr , N , K ) { var left ; if ( N % 2 == 1 ) { left = arr [ parseInt ( N / 2 ) ] ; } else { left = arr [ parseInt ( N / 2 ) - 1 ] + 1 ; } var right = arr [ N - 1 ] ; while ( left <= right ) { var mid = parseInt ( ( left + right ) / 2 ) ; var temp = findSum ( arr , N , mid ) ; if ( temp == K ) { document . write ( mid ) ; return ; } else if ( K < temp ) { right = mid - 1 ; } else { left = mid + 1 ; } } left = arr [ 0 ] ; right = arr [ parseInt ( N / 2 ) ] - 1 ; while ( left <= right ) { var mid = parseInt ( ( left + right ) / 2 ) ; var temp = findSum ( arr , N , mid ) ; if ( temp == K ) { document . write ( mid ) ; return ; } else if ( K > temp ) { right = mid - 1 ; } else { left = mid + 1 ; } } document . write ( "-1" ) ; }
function NthComposite ( N ) { let IsPrime = [ ] ; for ( let i = 0 ; i < MAX_SIZE ; i ++ ) IsPrime . push ( true ) ; for ( let p = 2 ; p * p < MAX_SIZE ; p ++ ) { if ( IsPrime [ p ] == true ) { for ( let i = p * p ; i < MAX_SIZE ; i += p ) IsPrime [ i ] = false ; } } let Composites = [ ] ; for ( let p = 4 ; p < MAX_SIZE ; p ++ ) if ( ! IsPrime [ p ] ) Composites . push ( p ) ; return Composites [ N - 1 ] ; }
function printArray ( res ) { res . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < res . length ; i ++ ) { document . write ( res [ i ] + "▁" ) ; } }
function minCount ( A , B , N ) { var i = 0  for ( let j = 0 ; j < N ; j ++ ) { if ( A [ i ] == B [ j ] ) i += 1 } return N - i }
function minimumNumber ( K , X ) { if ( K > X ) { document . write ( "-1" ) ; return ; } let low = K , high = X , res = - 1 ; while ( low <= high ) { let mid = low + parseInt ( ( high - low ) / 2 ) ; if ( isGreaterEqual ( mid , K , X ) ) { res = mid ; high = mid - 1 ; } else low = mid + 1 ; } document . write ( res ) ; }
function right_search ( A , num ) { let low = 0 , high = A . length - 1 ; let ans = high ; while ( low <= high ) { let mid = low + Math . floor ( ( high - low ) / 2 ) ; if ( A [ mid ] <= num ) { ans = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return ans ; }
function inv ( a , m ) { var m0 = m , t , q ; var x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = parseInt ( a / m ) ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; }
function prefixArr ( arr , prefix , N ) { for ( var i = 0 ; i < N ; i ++ ) { if ( i == 0 ) { prefix [ i ] [ 0 ] = arr [ i ] ; prefix [ i ] [ 1 ] = arr [ i ] ; } else { prefix [ i ] [ 0 ] = Math . max ( prefix [ i - 1 ] [ 0 ] , arr [ i ] ) ; prefix [ i ] [ 1 ] = Math . min ( prefix [ i - 1 ] [ 1 ] , arr [ i ] ) ; } } }
function Query ( arr , N , Q ) { var tree = new Array ( 4 * N ) ; tree . fill ( 0 ) ; build_seg_tree ( 0 , N - 1 , 0 , tree , arr ) ; for ( var i = 0 ; i < Q . length ; i ++ ) { if ( Q [ i ] [ 0 ] == 1 ) document . write ( query ( Q [ i ] [ 1 ] , Q [ i ] [ 2 ] , 0 , N - 1 , 0 , tree ) + "▁" ) ; else update ( 0 , N - 1 , 0 , Q [ i ] [ 1 ] , Q [ i ] [ 2 ] , tree , arr ) ; } }
function Sieve ( ) { index = 0 ; let p = new Array ( N + 1 ) . fill ( 0 ) ; for ( let i = 0 ; i <= N ; i ++ ) { p [ i ] = 1 ; } p [ 0 ] = p [ 1 ] = 0 ; for ( let i = 2 ; i * i <= N ; i ++ ) { if ( p [ i ] == 1 ) { for ( let j = i * i ; j <= N ; j += i ) { p [ j ] = 0 ; } } } for ( let i = 1 ; i < N ; i ++ ) { if ( p [ i ] == 1 ) { prime [ index ++ ] = ( Math . pow ( i , 4 ) ) ; } } }
function isValidDigit ( digit , K ) { while ( K != 0 ) { if ( K % 10 == digit ) { return true ; } K = parseInt ( K / 10 ) ; } return false ; }
function update ( index , s , e , new_val , pos ) { if ( s == e ) Tree [ index ] = new_val ; else { let m = parseInt ( ( s + e ) / 2 , 10 ) ; if ( pos <= m ) { update ( 2 * index , s , m , new_val , pos ) ; } else { update ( 2 * index + 1 , m + 1 , e , new_val , pos ) ; } Tree [ index ] = Math . max ( Tree [ 2 * index ] , Tree [ 2 * index + 1 ] ) ; } }
function printAnswer ( N , edges ) { for ( var i = 0 ; i <= N ; i ++ ) { parent [ i ] = i ; } for ( var i = 0 ; i < edges . length ; i ++ ) { connect ( edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) ; } connectedComponents ( N ) ; }
function countNumbers ( n , d ) { let total = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let x = i ; while ( x > 0 ) { if ( x % 8 == d ) { total ++ ; break ; } x = x / 8 ; } } document . write ( total ) ; }
function smallestLeft ( arr , total , sum , i , dp ) { if ( i == 0 ) { return Math . abs ( total - 2 * sum ) ; } if ( dp [ i ] [ sum ] != - 1 ) return dp [ i ] [ sum ] ; let X = smallestLeft ( arr , total , sum + arr [ i - 1 ] , i - 1 , dp ) ; let Y = smallestLeft ( arr , total , sum , i - 1 , dp ) ; return dp [ i ] [ sum ] = Math . min ( X , Y ) ; }
function findWordsSameRow ( arr ) { var mp = { } ; mp [ "q" ] = 1 ; mp [ "w" ] = 1 ; mp [ "e" ] = 1 ; mp [ "r" ] = 1 ; mp [ "t" ] = 1 ; mp [ "y" ] = 1 ; mp [ "u" ] = 1 ; mp [ "o" ] = 1 ; mp [ "p" ] = 1 ; mp [ "i" ] = 1 ; mp [ "a" ] = 2 ; mp [ "s" ] = 2 ; mp [ "d" ] = 2 ; mp [ "f" ] = 2 ; mp [ "g" ] = 2 ; mp [ "h" ] = 2 ; mp [ "j" ] = 2 ; mp [ "k" ] = 2 ; mp [ "l" ] = 2 ; mp [ "z" ] = 3 ; mp [ "x" ] = 3 ; mp [ "c" ] = 3 ; mp [ "v" ] = 3 ; mp [ "b" ] = 3 ; mp [ "n" ] = 3 ; mp [ "m" ] = 3 ; for ( const word of arr ) { if ( word . length !== 0 ) { var flag = true ; var rowNum = mp [ word [ 0 ] . toLowerCase ( ) ] ; var M = word . length ; for ( var i = 1 ; i < M ; i ++ ) { if ( mp [ word [ i ] . toLowerCase ( ) ] !== rowNum ) { flag = false ; break ; } } if ( flag ) { document . write ( word + "▁" ) ; } } } }
function countSubsequece ( a , n ) { let i , j , k , l ; let answer = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ j ] == a [ l ] && a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; }
function countSubsequence ( a , n ) { let i , j ; fill_counts ( a , n ) ; let answer = 0 ; for ( i = 1 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n - 1 ; j ++ ) { answer += lcount [ a [ j ] ] [ i - 1 ] * rcount [ a [ i ] ] [ j + 1 ] ; } } return answer ; }
function MincntBothPalin ( str1 , str2 , N ) { var i = 0 ; var j = N - 1 ; var cntOp = 0 ; while ( i < j ) { if ( str1 [ i ] === str1 [ j ] && str2 [ i ] !== str2 [ j ] ) { cntOp += 1 ; } else if ( str1 [ i ] !== str1 [ j ] && str2 [ i ] === str2 [ j ] ) { cntOp += 1 ; } else if ( str1 [ i ] !== str1 [ j ] && str2 [ i ] !== str2 [ j ] ) { if ( str1 [ i ] === str2 [ j ] && str2 [ i ] === str1 [ j ] ) { cntOp += 1 ; } else { cntOp += 2 ; } } i += 1 ; j -= 1 ; } return cntOp ; }
function isValid ( wood , N , len , K ) { var count = 0 ; for ( i = 0 ; i < N ; i ++ ) { count += parseInt ( wood [ i ] / len ) ; } return count >= K ; }
function isMorannumber ( n ) { let dup = n ; let sum = digiSum ( dup ) ; if ( n % sum == 0 ) { let c = n / sum ; if ( isPrime ( c ) ) { return true ; } } return false ; }
function maxEqualIdx ( arr , k ) { arr . sort ( ) ; let prefixSum = new Array ( arr . length + 1 ) . fill ( 0 ) ; prefixSum [ 1 ] = arr [ 0 ] ; for ( let i = 1 ; i < prefixSum . length - 1 ; ++ i ) { prefixSum [ i + 1 ] = prefixSum [ i ] + arr [ i ] ; } let max = arr . length ; let min = 1 ; let ans = 1 ; while ( min <= max ) { let mid = Math . floor ( ( max + min ) / 2 ) ; if ( check ( prefixSum , mid , k , arr ) ) { ans = mid ; min = mid + 1 ; } else { max = mid - 1 ; } } return ans ; }
function sfpa ( V , src , Edges , M ) { var g = Array . from ( Array ( V ) , ( ) => Array ( ) ) ; for ( var i = 0 ; i < M ; i ++ ) { var u = Edges [ i ] [ 0 ] ; var v = Edges [ i ] [ 1 ] ; var w = Edges [ i ] [ 2 ] ; g [ u ] . push ( new pair ( v , w ) ) ; } var dist = Array ( V ) ; for ( var i = 0 ; i < V ; i ++ ) dist [ i ] = 1000000000 ; var inQueue = Array ( V ) . fill ( false ) ; var cnt = Array ( V ) . fill ( 0 ) ; dist [ src ] = 0 ; var q = [ ] ; q . push ( src ) ; inQueue [ src ] = true ; while ( q . length != 0 ) { var u = q [ 0 ] ; q . shift ( ) ; inQueue [ u ] = false ; for ( var x of g [ u ] ) { var v = x . first ; var cost = x . second ; if ( dist [ v ] > dist [ u ] + cost ) { dist [ v ] = dist [ u ] + cost ; if ( ! inQueue [ v ] ) { q . push ( v ) ; inQueue [ v ] = true ; cnt [ v ] ++ ; if ( cnt [ v ] >= V ) return true ; } } } } return false ; }
function countNum ( N , sum , K , st , dp ) { if ( N == 0 && sum == 0 ) { return 1 ; } if ( N < 0 ) { return 0 ; } if ( dp [ N ] [ sum ] [ st ] != - 1 ) { return dp [ N ] [ sum ] [ st ] ; } var res = 0 ; var start = st == 1 ? 0 : 1 ; for ( var i = start ; i <= 9 ; i ++ ) { res += countNum ( N - 1 , ( sum + i ) % K , K , ( st i > 0 ) , dp ) ; } return dp [ N ] [ sum ] [ st ] = res ; }
function hIndex ( citations , n ) { let hindex = 0 ; let low = 0 , high = n - 1 ; while ( low <= high ) { let mid = ( low + high ) / 2 ; if ( citations [ mid ] >= ( mid + 1 ) ) { low = mid + 1 ; hindex = mid + 1 ; } else { high = mid - 1 ; } } document . write ( hindex ) ; return hindex ; }
function countNodes ( V , E , src , dest , edges ) { let adj = new Array ( V + 1 ) ; for ( let i = 0 ; i < adj . length ; i ++ ) adj [ i ] = [ ] ; for ( let i = 0 ; i < E ; i ++ ) { adj [ edges [ i ] [ 0 ] ] . push ( edges [ i ] [ 1 ] ) ; adj [ edges [ i ] [ 1 ] ] . push ( edges [ i ] [ 0 ] ) ; } let vis = new Array ( V + 1 ) ; for ( let i = 0 ; i < vis . length ; i ++ ) { vis [ i ] = 0 ; } let count = dfs ( src , dest , vis , adj ) ; return count - 2 ; }
function longestGP ( A , N ) { if ( N < 2 ) return N ; let length = 1 , common_ratio = 1 ; let maxlength = 1 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i + 1 ] % A [ i ] == 0 ) { if ( A [ i + 1 ] / A [ i ] == common_ratio ) { length = length + 1 ; maxlength = Math . max ( maxlength , length ) ; } else { common_ratio = A [ i + 1 ] / A [ i ] ; length = 2 ; } } else { maxlength = Math . max ( maxlength , length ) ; length = 1 ; } } maxlength = Math . max ( maxlength , length ) ; return maxlength ; }
function add_seg ( seg , start , end , current , index ) { if ( index > end index < start ) return ; if ( start == end ) { seg [ current ] = 1 ; return ; } let mid = parseInt ( ( start + end ) / 2 , 10 ) ; add_seg ( seg , start , mid , 2 * current + 1 , index ) ; add_seg ( seg , mid + 1 , end , 2 * current + 2 , index ) ; seg [ current ] = seg [ 2 * current + 1 ] + seg [ 2 * current + 2 ] ; }
function getPrefixLength ( srcStr , targetStr ) { if ( targetStr . length === 0 ) return 0 ; srcStr = srcStr . toLowerCase ( ) ; targetStr = targetStr . toLowerCase ( ) ; var dictCount = { } ; var nUnique = 0 ; for ( const ch of targetStr ) { if ( dictCount . hasOwnProperty ( ch ) !== true ) { nUnique += 1 ; dictCount [ ch ] = 0 ; } dictCount [ ch ] += 1 ; } for ( var i = 0 ; i < srcStr . length ; i ++ ) { var ch = srcStr [ i ] ; if ( dictCount . hasOwnProperty ( ch ) !== true ) continue ; dictCount [ ch ] -= 1 ; if ( dictCount [ ch ] === 0 ) nUnique -= 1 ; if ( nUnique === 0 ) return i + 1 ; } return - 1 ; }
function minOperations ( S , K ) { var ans = 0 ; for ( var i = 0 ; i < K ; i ++ ) { var zero = 0 , one = 0 ; for ( var j = i ; j < S . length ; j += K ) { if ( S [ j ] === "0" ) zero ++ ; else one ++ ; } ans += Math . min ( zero , one ) ; } return ans ; }
function func ( A , B , C , x ) { return ( A * x * x + B * x + C ) ; }
function minDays ( arr , n , k ) { let l = arr . length , left = 1 , right = 1000000000 ; if ( n * k > l ) return - 1 ; while ( left < right ) { let mid = parseInt ( ( left + right ) / 2 ) , cnt = 0 , product = 0 ; for ( let j = 0 ; j < l ; ++ j ) { if ( arr [ j ] > mid ) { cnt = 0 ; } else if ( ++ cnt >= k ) { product ++ ; cnt = 0 ; } } if ( product < n ) { left = mid + 1 ; } else { right = mid ; } } return left ; }
function minimumMoves ( S , K ) { var N = S . length ; var ops = 0 ; var last_idx = - 1 ; for ( var i = 0 ; i < K ; i ++ ) { if ( S [ i ] == "1" ) last_idx = i ; } if ( last_idx == - 1 ) { ++ ops ; S [ K - 1 ] = "1" ; last_idx = K - 1 ; } for ( var i = 1 ; i < N - K + 1 ; i ++ ) { if ( last_idx < i ) last_idx = - 1 ; if ( S [ i + K - 1 ] == "1" ) last_idx = i + K - 1 ; if ( last_idx == - 1 ) { ++ ops ; S [ i + K - 1 ] = "1" ; last_idx = i + K - 1 ; } } return ops ; }
function missingElement ( arr , n ) { let max_ele = arr [ 0 ] ; let min_ele = arr [ 0 ] ; let x = 0 ; let d ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; if ( arr [ i ] < min_ele ) min_ele = arr [ i ] ; } d = parseInt ( ( max_ele - min_ele ) / n , 10 ) ; for ( let i = 0 ; i < n ; i ++ ) { x = x ^ arr [ i ] ; } for ( let i = 0 ; i <= n ; i ++ ) { x = x ^ ( min_ele + ( i * d ) ) ; } return x ; }
function longestPermutation ( arr , n ) { let freq = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( freq . has ( arr [ i ] ) ) { freq . set ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . set ( arr [ i ] , 1 ) ; } } let len = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( ! freq . has ( i ) ) { break ; } len ++ ; } return len ; }
function findColor ( mapWithColor , query ) { let maximum = 0 ; while ( query >= 1 ) { if ( mapWithColor . has ( query ) ) { maximum = Math . max ( maximum , mapWithColor . get ( query ) ) ; } if ( query % 2 == 1 ) query = ( query - 1 ) / 2 ; else query = query / 2 ; } return maximum ; }
function findlength ( str , n , k ) { var maxLen = 0 ; var freq = Array ( MAX ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { setZero ( freq ) ; for ( var j = i ; j < n ; j ++ ) { freq [ str [ j ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; if ( atLeastK ( freq , k ) ) { maxLen = Math . max ( maxLen , j - i + 1 ) ; } } } return maxLen ; }
function maxSumArray ( arr , n ) { var sum = 0 ; var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( mp . has ( arr [ i ] ) ) mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) else mp . set ( arr [ i ] , 1 ) } var minimum = 1000000000 ; mp . forEach ( ( value , key ) => { minimum = Math . min ( minimum , value * key ) ; } ) ; return ( sum - minimum ) ; }
function create_table ( n ) { let pow = 1 ; let co = 0 ; while ( true ) { pow <<= 1 ; lookup_table [ co ] = parseInt ( ( n + ( pow >> 1 ) ) / pow , 10 ) ; if ( lookup_table [ co ++ ] == 0 ) { break ; } } }
function costToPanagram ( str , cost ) { var i , n = str . length ; var occurrences = Array ( 26 ) . fill ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) occurrences [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; var gain = 0 ; for ( i = 0 ; i < 26 ; i ++ ) { if ( occurrences [ i ] == 0 ) gain -= ( 2 * cost [ i ] ) ; else if ( occurrences [ i ] > 1 ) gain += ( cost [ i ] * ( occurrences [ i ] - 1 ) ) ; } if ( gain >= 0 ) return 0 ; return ( gain * - 1 ) ; }
function strScore ( str , s , n ) { let m = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) m . set ( str [ i ] , i + 1 ) ; if ( ! m . has ( s ) ) return 0 ; let score = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) score += s [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) + 1 ; score = score * m . get ( s ) ; return score ; }
function replacePi ( input ) { var output = "" ; var size = input . length ; for ( var i = 0 ; i < size ; ++ i ) { if ( i + 1 < size && input [ i ] === "p" && input [ i + 1 ] === "i" ) { output += "3.14" ; i ++ ; } else { output += input [ i ] ; } } return output ; }
function check_pair_product ( head , prod ) { var s = [ ] ; var p = head ; while ( p != null ) { var curr = p . data ; if ( prod % curr == 0 && s . includes ( prod / curr ) ) { document . write ( curr + "▁" + prod / curr ) ; return true ; } s . push ( p . data ) ; p = p . next ; } return false ; }
function minSum ( arr , n ) { let sum = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { let j = i ; while ( j < n && arr [ j ] <= arr [ j - 1 ] ) { arr [ j ] = arr [ j ] + 1 ; j ++ ; } } sum = sum + arr [ i ] ; } return sum ; }
function totalNumbersWithSpecificDifference ( N , diff ) { let low = 1 ; let high = N ; while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( mid - sumOfDigit ( mid ) < diff ) low = mid + 1 ; else high = mid - 1 ; } return ( N - high ) ; }
function computeCost ( arr , N , X ) { let cost = 0 ; for ( let i = 0 ; i < N ; i ++ ) cost += Math . abs ( arr [ i ] - X ) ; return cost ; }
function insertionSort ( arr , n ) { let i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } }
function minimumRange ( arr , N , K ) { if ( K >= N ) { document . write ( 0 ) ; return ; } arr . sort ( ( a , b ) => a - b ) ; var left = 0 , right = N - 1 , i ; for ( i = 0 ; i < K ; i ++ ) { if ( arr [ right - 1 ] - arr [ left ] < arr [ right ] - arr [ left + 1 ] ) right -- ; else left ++ ; } document . write ( arr [ right ] - arr [ left ] ) ; }
function minimum_possible_sum ( arr , n , k ) { if ( n == 0 ) { return 0 ; } if ( n == 1 ) { return arr [ 0 ] ; } for ( let i = 0 ; i < k ; i ++ ) { let smallest_element = arr [ 0 ] ; let smallest_pos = 0 ; let largest_element = arr [ 0 ] ; let largest_pos = 0 ; for ( let j = 1 ; j < n ; j ++ ) { if ( arr [ j ] >= largest_element ) { largest_element = arr [ j ] ; largest_pos = j ; } if ( arr [ j ] < smallest_element ) { smallest_element = arr [ j ] ; smallest_pos = j ; } } let a = smallest_element * 2 ; let b = largest_element / 2 ; if ( a + b < smallest_element + largest_element ) { arr [ smallest_pos ] = a ; arr [ largest_pos ] = b ; } } let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { ans += arr [ i ] ; } return ans ; }
function XorSum ( A , B , N ) { var ans = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { ans = ans ^ ( A [ i ] + B [ j ] ) ; } } return ans ; }
function findCount ( arr , N , K ) { arr . sort ( ) ; let result = 1 ; let cur_max = arr [ 0 ] ; let cur_min = arr [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) { cur_max = arr [ i ] ; if ( cur_max - cur_min > K ) { result ++ ; cur_max = arr [ i ] ; cur_min = arr [ i ] ; } } return result ; }
function checkToMakeEqual ( S1 , S2 ) { var freq = Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < S1 . length ; i ++ ) { freq [ S1 [ i ] - "a" ] ++ ; } var flag = 0 ; for ( var i = 0 ; i < S2 . length ; i ++ ) { if ( freq [ S2 [ i ] - "a" ] == 0 ) { flag = true ; break ; } freq [ S2 [ i ] - "a" ] -- ; } if ( flag == true ) { document . write ( "No" ) ; return ; } var invCount1 = inversionCount ( S1 ) ; var invCount2 = inversionCount ( S2 ) ; if ( invCount1 == invCount2 || ( invCount1 & 1 ) == ( invCount2 & 1 ) || haveRepeated ( S1 , S2 ) ) { document . write ( "Yes" ) ; } else document . write ( "No" ) ; }
function findKthSmallest ( arr , n , k ) { let max = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } let counter = Array . from ( { length : max + 1 } , ( _ , i ) => 0 ) ; let smallest = 0 ; for ( let i = 0 ; i < n ; i ++ ) { counter [ arr [ i ] ] ++ ; } for ( let num = 1 ; num <= max ; num ++ ) { if ( counter [ num ] > 0 ) { smallest += counter [ num ] ; } if ( smallest >= k ) { return num ; } } return - 1 ; }
function printArr ( arr , n ) { arr . sort ( ) ; if ( arr [ 0 ] == arr [ n - 1 ] ) { document . write ( "No" ) ; } else { document . write ( "Yes" ) ; for ( i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + "▁" ) ; } } }
function countVowels ( str ) { let count = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) ++ count ; return count ; }
function findSum ( arr , n , k ) { var ans = arr [ n - k - 1 ] - arr [ 0 ] ; for ( var i = 1 ; i <= k ; i ++ ) { ans = Math . min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; } return ans ; }
function cntElements ( arr , n ) { let copy_arr = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) copy_arr [ i ] = arr [ i ] ; let count = 0 ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != copy_arr [ i ] ) { count ++ ; } } return count ; }
function UpdateArr ( arr , n ) { let i = 0 , j = n - 1 ; while ( i < j ) { let temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; i += 2 ; j -= 2 ; } printArr ( arr , n ) ; }
function pre ( ) { fact [ 0 ] = 1 ; for ( let i = 1 ; i < N ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; } }
function sieve ( n ) { for ( let i = 2 ; i <= n ; i += 1 ) { prime [ i ] = 1 ; } for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( let p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) pr . push ( p ) ; }
function SemiPrimeSum ( N ) { let ans = 0 ; for ( let i = 0 ; i < pr . length ; i += 1 ) { for ( let j = i ; j < pr . length ; j += 1 ) { if ( pr [ i ] * pr [ j ] > N ) break ; ans += pr [ i ] * pr [ j ] ; } } return ans ; }
function quickSort ( arr , low , high , mod ) { if ( low < high ) { var pi = partition ( arr , low , high , mod ) ; quickSort ( arr , low , pi - 1 , mod ) ; quickSort ( arr , pi + 1 , high , mod ) ; } }
function maxWater ( height , n ) { var maximum = 0 ; var i = 0 , j = n - 1 ; while ( i < j ) { if ( height [ i ] < height [ j ] ) { maximum = Math . max ( maximum , ( j - i - 1 ) * height [ i ] ) ; i ++ ; } else if ( height [ j ] < height [ i ] ) { maximum = Math . max ( maximum , ( j - i - 1 ) * height [ j ] ) ; j -- ; } else { maximum = Math . max ( maximum , ( j - i - 1 ) * height [ i ] ) ; i ++ ; j -- ; } } return maximum ; }
function check ( str ) { var min = Number . MAX_VALUE ; var max = Number . MIN_VALUE ; var sum = 0 ; for ( i = 0 ; i < str . length ; i ++ ) { var ascii = parseInt ( str . charCodeAt ( i ) ) ; if ( ascii < 96 ascii > 122 ) return false ; sum += ascii ; if ( min > ascii ) min = ascii ; if ( max < ascii ) max = ascii ; } min -= 1 ; var eSum = parseInt ( ( max * ( max + 1 ) ) / 2 ) - ( ( min * ( min + 1 ) ) / 2 ) ; return sum == eSum ; }
function findNumbers ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; reverse ( arr ) ; let freq = new Array ( arr [ 0 ] + 1 ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } let size = parseInt ( Math . sqrt ( n ) , 10 ) ; let brr = new Array ( size ) ; brr . fill ( 0 ) ; let x , l = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( freq [ arr [ i ] ] > 0 && l < size ) { brr [ l ] = arr [ i ] ; freq [ brr [ l ] ] -- ; l ++ ; for ( let j = 0 ; j < l ; j ++ ) { if ( i != j ) { x = __gcd ( arr [ i ] , brr [ j ] ) ; freq [ x ] -= 2 ; } } } } printArr ( brr , size ) ; }
function printArr ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function merge_and_sort ( output , arr , n , k ) { for ( let i = 0 ; i < k ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { output [ i * n + j ] = arr [ i ] [ j ] ; } } output . sort ( function ( a , b ) { return a - b } ) ; }
function AlternateRearrange ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) v1 . push ( arr [ i ] ) ; else v2 . push ( arr [ i ] ) ; var index = 0 , i = 0 , j = 0 ; var flag = false ; if ( arr [ 0 ] % 2 == 0 ) flag = true ; while ( index < n ) { if ( flag == true ) { arr [ index ++ ] = v1 [ i ++ ] ; flag = ! flag ; } else { arr [ index ++ ] = v2 [ j ++ ] ; flag = ! flag ; } } for ( i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function getNumToAdd ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; var d = arr [ 1 ] - arr [ 0 ] ; var numToAdd = - 1 ; var numAdded = false ; for ( var i = 2 ; i < n ; i ++ ) { var diff = arr [ i ] - arr [ i - 1 ] ; if ( diff != d ) { if ( numAdded ) return - 1 ; if ( diff == 2 * d ) { numToAdd = arr [ i ] - d ; numAdded = true ; } else return - 1 ; } } if ( numToAdd == - 1 ) return ( arr [ n - 1 ] + d ) ; return numToAdd ; }
function PointInKSquares ( n , a , k ) { a . sort ( ) ; return a [ n - k ] ; }
function maxArrayCover ( a , n , x ) { a . sort ( ) ; let cc = 0 ; let s = 0 ; for ( let i = 0 ; i < n ; i ++ ) { s += a [ i ] ; if ( s > x ) { break ; } cc += 1 ; } var sum = a . reduce ( function ( a , b ) { return a + b ; } , 0 ) ; if ( sum == x ) { return n ; } else { if ( cc == n ) { return n - 1 ; } else { return cc ; } } }
function findMaxNum ( arr , n ) { arr . sort ( function ( a , b ) { return b - a ; } ) ; var num = arr [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) { num = num * 10 + arr [ i ] ; } return num ; }
function sort ( arr , n ) { let index = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 999 ) { index = i ; break ; } } if ( index == - 1 ) return ; sortRec ( arr , index , n , n ) ; }
function merge ( arr1 , arr2 , n , m ) { let i , j , gap = n + m ; for ( gap = nextGap ( gap ) ; gap > 0 ; gap = nextGap ( gap ) ) { for ( i = 0 ; i + gap < n ; i ++ ) if ( arr1 [ i ] > arr1 [ i + gap ] ) { let temp = arr1 [ i ] ; arr1 [ i ] = arr1 [ i + gap ] ; arr1 [ i + gap ] = temp ; } for ( j = gap > n ? gap - n : 0 ; i < n && j < m ; i ++ , j ++ ) if ( arr1 [ i ] > arr2 [ j ] ) { let temp = arr1 [ i ] ; arr1 [ i ] = arr2 [ j ] ; arr2 [ j ] = temp ; } if ( j < m ) { for ( j = 0 ; j + gap < m ; j ++ ) if ( arr2 [ j ] > arr2 [ j + gap ] ) { let temp = arr2 [ j ] ; arr2 [ j ] = arr2 [ j + gap ] ; arr2 [ j + gap ] = temp ; } } } }
function _mergeSort ( arr , temp , left , right ) { let mid , inv_count = 0 ; if ( right > left ) { mid = ( right + left ) / 2 ; inv_count = _mergeSort ( arr , temp , left , mid ) ; inv_count += _mergeSort ( arr , temp , mid + 1 , right ) ; inv_count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_count ; }
function printSorted ( a , b , c ) { let get_max = Math . max ( a , Math . max ( b , c ) ) ; let get_min = - Math . max ( - a , Math . max ( - b , - c ) ) ; let get_mid = ( a + b + c ) - ( get_max + get_min ) ; document . write ( get_min + "▁" + get_mid + "▁" + get_max ) ; }
function countSwaps ( arr , n ) { let temp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { temp [ i ] = 0 ; } return _mergeSort ( arr , temp , 0 , n - 1 ) ; }
function pancakeSort ( arr , n ) { for ( let curr_size = n ; curr_size > 1 ; -- curr_size ) { let mi = findMax ( arr , curr_size ) ; if ( mi != curr_size - 1 ) { flip ( arr , mi ) ; flip ( arr , curr_size - 1 ) ; } } return 0 ; }
function largestMerge ( word1 , word2 ) { let merge = "" ; while ( word1 . length != 0 word2 . length != 0 ) { if ( word1 . localeCompare ( word2 ) == 0 || ( word1 . localeCompare ( word2 ) > 0 ) ) { merge = merge + word1 [ 0 ] ; word1 = word1 . substring ( 1 ) ; } else { merge = merge + word2 [ 0 ] ; word2 = word2 . substring ( 1 ) ; } } return merge ; }
function find ( arr , N ) { let Sum = 0 ; let i = 0 ; let ans = 0 ; for ( i = 0 ; i < N ; i ++ ) { Sum += arr [ i ] ; } if ( Sum % N ) { return - 1 ; } else { k = Math . floor ( Sum / N ) ; ans = 0 ; i = 0 ; while ( i < N ) { ans = ans + Math . abs ( k - arr [ i ] ) ; i += 1 ; } } return Math . floor ( ans / 2 ) ; }
function maxXORUtil ( arr , N , xrr , orr ) { if ( N == 0 ) return xrr ^ orr ; let x = maxXORUtil ( arr , N - 1 , xrr ^ orr , arr [ N - 1 ] ) ; let y = maxXORUtil ( arr , N - 1 , xrr , orr arr [ N - 1 ] ) ; return Math . max ( x , y ) ; }
function maximumXOR ( arr , N ) { return maxXORUtil ( arr , N , 0 , 0 ) ; }
function findEquation ( S , M ) { document . write ( "1▁" + ( ( - 1 ) * S ) + "▁" + M ) ; }
function isPalindrome ( N ) { int temp = N ; let res = 0 ; while ( temp != 0 ) { let rem = temp % 10 ; res = res * 10 + rem ; temp = Math . floor ( temp / 10 ) ; } if ( res == N ) { return true ; } else { return false ; } }
function minSteps ( a , n ) { var prefix_sum = Array ( n ) . fill ( 0 ) ; prefix_sum [ 0 ] = a [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] + a [ i ] ; var mx = - 1 ; for ( var subgroupsum = 0 ; subgroupsum < prefix_sum . length ; subgroupsum ++ ) { var sum = 0 ; var i = 0 ; var grp_count = 0 ; while ( i < n ) { sum += a [ i ] ; if ( sum == prefix_sum [ subgroupsum ] ) { grp_count += 1 ; sum = 0 ; } else if ( sum > prefix_sum [ subgroupsum ] ) { grp_count = - 1 ; break ; } i += 1 ; } if ( grp_count > mx ) mx = grp_count ; } return n - mx ; }
function findSubseq ( A , B , K , i ) { let ans = [ ] ; findSubseqUtil ( A , B , ans , K , i ) ; if ( ans . length < 1 ) document . write ( - 1 ) ; }
function MinimumCost ( A , B , N ) { var totalCost = 0 ; for ( i = 0 ; i < N ; i ++ ) { var mod_A = B [ i ] % A [ i ] ; var totalCost_A = Math . min ( mod_A , A [ i ] - mod_A ) ; var mod_B = A [ i ] % B [ i ] ; var totalCost_B = Math . min ( mod_B , B [ i ] - mod_B ) ; totalCost += Math . min ( totalCost_A , totalCost_B ) ; } return totalCost ; }
function longestSubarray ( arr , N , K ) { let um = new Map ( ) ; let sum = 0 , maxLen = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; if ( sum == K ) maxLen = i + 1 ; if ( ! um . has ( sum ) ) um . set ( sum , i ) ; if ( um . has ( sum - K ) ) { if ( maxLen < ( i - um . get ( sum - K ) ) ) maxLen = i - um . get ( sum - K ) ; } } return maxLen ; }
function findArrayWithMaxProduct ( arr , N ) { for ( var i = 0 ; i < N ; i ++ ) if ( arr [ i ] >= 0 ) { arr [ i ] = - arr [ i ] - 1 ; } if ( N % 2 === 1 ) { var max_element = - 1 ; var index = - 1 ; for ( var i = 0 ; i < N ; i ++ ) if ( Math . abs ( arr [ i ] ) > max_element ) { max_element = Math . abs ( arr [ i ] ) ; index = i ; } arr [ index ] = - arr [ index ] - 1 ; } for ( var i = 0 ; i < N ; i ++ ) document . write ( arr [ i ] + "▁" ) ; }
function maximumCandy ( candies , safety , N , M ) { let total = 0 ; let ans = Number . MAX_VALUE ; let all_safe = true ; for ( let i = 0 ; i < N ; i ++ ) { if ( candies [ i ] + M > safety [ i ] ) { all_safe = false ; ans = Math . min ( ans , safety [ i ] ) ; } else { ans = Math . min ( ans , candies [ i ] + M ) ; } total += candies [ i ] ; } if ( all_safe ) return total ; else return ans ; }
function canArrayBeReduced ( arr , N ) { if ( N == 1 ) { document . write ( arr [ 0 ] ) ; return ; } if ( arr [ 0 ] < arr [ N - 1 ] ) { document . write ( arr [ N - 1 ] ) ; } else document . write ( "Not▁Possible" ) ; }
function maxValueAtIndexK ( N , K , M ) { let S1 = 0 , S2 = 0 ; S1 = K * ( K + 1 ) / 2 ; S2 = ( N - K - 1 ) * ( N - K ) / 2 ; let X = ( M + S1 + S2 ) / N ; document . write ( X ) ; }
function countEvenPairs ( N , M ) { let count = 0 ; nEven = parseInt ( Math . floor ( N / 2 ) ) ; nOdd = parseInt ( Math . ceil ( N / 2 ) ) ; mEven = parseInt ( Math . floor ( M / 2 ) ) ; mOdd = parseInt ( Math . ceil ( M / 2 ) ) ; count = nEven * mEven + nOdd * mOdd ; return count ; }
function findNums ( X , Y ) { let A , B ; if ( X < Y ) { A = - 1 ; B = - 1 ; } else if ( Math . abs ( X - Y ) & 1 ) { A = - 1 ; B = - 1 ; } else if ( X == Y ) { A = 0 ; B = Y ; } else { A = ( X - Y ) / 2 ; if ( ( A & Y ) == 0 ) { B = ( A + Y ) ; } else { A = - 1 ; B = - 1 ; } } document . write ( A + "▁" + B ) ; }
function findPartition ( nums , N ) { var prefix = Array ( N ) , suffix = Array ( N ) , i , k ; prefix [ 0 ] = nums [ 0 ] ; for ( i = 1 ; i < N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] * nums [ i ] ; } suffix [ N - 1 ] = nums [ N - 1 ] ; for ( i = N - 2 ; i >= 0 ; i -- ) { suffix [ i ] = suffix [ i + 1 ] * nums [ i ] ; } for ( k = 0 ; k < N - 1 ; k ++ ) { if ( GCD ( prefix [ k ] , suffix [ k + 1 ] ) == 1 ) { return k ; } } return - 1 ; }
function palindromeMatrix ( N , M , arr ) { let ans = 0 ; for ( let i = 0 ; i < Math . floor ( ( N + 1 ) / 2 ) ; i ++ ) { for ( let j = 0 ; j < Math . floor ( ( M + 1 ) / 2 ) ; j ++ ) { let s = new Set ( ) ; s . add ( new pair ( i , j ) ) ; s . add ( new pair ( i , M - j - 1 ) ) ; s . add ( new pair ( N - i - 1 , j ) ) ; s . add ( new pair ( N - i - 1 , M - j - 1 ) ) ; let values = [ ] ; for ( let p of s . values ( ) ) { values . push ( arr [ p . first ] [ p . second ] ) ; } values . sort ( function ( a , b ) { return a - b ; } ) ; let max = Math . max ( ... values ) ; for ( let k = 1 ; k < values . length ; k ++ ) { ans += max - values [ k ] ; } } } document . write ( ans ) ; }
function MinOperation ( arr , N , K ) { let cntOpe = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( K > arr [ i ] ) { if ( ( K - arr [ i ] ) % 2 == 0 ) { cntOpe += 2 ; } else { cntOpe += 1 ; } } else if ( K < arr [ i ] ) { if ( ( K - arr [ i ] ) % 2 == 0 ) { cntOpe += 1 ; } else { cntOpe += 2 ; } } } return cntOpe ; }
function printSmallSub ( arr , N ) { let gcdArr = 0 ; for ( let i = 0 ; i < N ; i ++ ) { gcdArr = gcd ( gcdArr , arr [ i ] ) ; } for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == gcdArr ) { document . write ( arr [ i ] + "▁" ) ; return ; } } for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( gcd ( arr [ i ] , arr [ j ] ) == gcdArr ) { document . write ( arr [ i ] + "▁" + arr [ j ] ) ; return ; } } } }
function smlstNonNeg ( arr , N ) { let smNonNeg = 0 ; let hash = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { hash [ i ] = false ; } for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= 0 && arr [ i ] < N ) { hash [ arr [ i ] ] = true ; } while ( hash [ smNonNeg ] ) { smNonNeg ++ ; } document . write ( smNonNeg + "▁" ) ; } }
function numberOfWays ( N ) { var count = count_of_primes [ N ] - 1 ; var mod = 1000000007 ; var answer = power ( 2 , count , mod ) ; if ( N == 1 ) answer = 0 ; document . write ( answer ) ; }
function cntPairs ( arr , N ) { let isPrime = getPrimeNum ( ) ; let cntOne = 0 ; let cntPrime = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) { cntOne += 1 ; } else if ( isPrime [ i ] ) { cntPrime += 1 ; } } let cntNonComp = 0 ; cntNonComp = cntPrime * cntOne + Math . floor ( cntOne * ( cntOne - 1 ) / 2 ) ; let res = 0 ; res = N * Math . floor ( ( N - 1 ) / 2 ) - cntNonComp ; return res ; }
function printArray ( brr ) { for ( let it of brr ) { document . write ( it + "▁" ) ; } }
function MinimumFlips ( s , n ) { let a = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { a [ i ] = ( s [ i ] == "1" ? 1 : 0 ) ; } let oddone = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; let evenone = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; oddone [ 0 ] = 0 ; evenone [ 0 ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) { oddone [ i + 1 ] = oddone [ i ] + ( a [ i ] == 1 ? 1 : 0 ) ; evenone [ i + 1 ] = evenone [ i ] + ( a [ i ] == 0 ? 1 : 0 ) ; } else { oddone [ i + 1 ] = oddone [ i ] + ( a [ i ] == 0 ? 1 : 0 ) ; evenone [ i + 1 ] = evenone [ i ] + ( a [ i ] == 1 ? 1 : 0 ) ; } } let minimum = Math . min ( oddone [ n ] , evenone [ n ] ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( n % 2 != 0 ) { minimum = Math . min ( minimum , oddone [ n ] - oddone [ i + 1 ] + evenone [ i + 1 ] ) ; minimum = Math . min ( minimum , evenone [ n ] - evenone [ i + 1 ] + oddone [ i + 1 ] ) ; } } return minimum ; }
function shortestpath ( m , n ) { let mfactor = new Array ( )  let nfactor = new Array ( )  let fre = new Map ( ) ; mfactor . push ( m ) ; fre [ m ] = 1 ; while ( m != 1 ) { if ( isprm ( m ) ) { mfactor . push ( 1 ) ; fre [ 1 ] = 1 ; m = 1 ; } else { for ( let i = 2 ; i <= Math . sqrt ( m ) ; i ++ ) { if ( m % i == 0 ) { mfactor . push ( m / i ) ; fre [ m / i ] = 1 ; m = ( m / i ) ; break ; } } } } nfactor . push ( n ) ; while ( fre [ n ] != 1 ) { if ( isprm ( n ) ) { nfactor . push ( 1 ) ; n = 1 ; } else { for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { nfactor . push ( n / i ) ; n = ( n / i ) ; break ; } } } } for ( let i = 0 ; i < mfactor . length ; i ++ ) { if ( mfactor [ i ] == n ) break ; document . write ( mfactor [ i ] + "▁<-->▁" ) ; } for ( let i = nfactor . length - 1 ; i >= 0 ; i -- ) { if ( i == 0 ) document . write ( nfactor [ i ] ) ; else document . write ( nfactor [ i ] + "▁<-->▁" ) ; } }
function factorial ( N ) { if ( N <= 0 ) return 1 ; var fact = 1 ; for ( var i = 1 ; i <= N ; i ++ ) { fact = ( fact * i ) % Mod ; } return fact ; }
function noOfFactors ( N ) { if ( N == 1 ) return 1 ; let count = 0 ; let ans = 1 ; while ( N % 2 == 0 ) { count ++ ; N = N / 2 ; } ans *= ( count / 2 + 1 ) ; for ( let i = 3 ; i * i <= N ; i = i + 2 ) { count = 0 ; while ( N % i == 0 ) { count ++ ; N = N / i ; } ans *= ( count / 2 + 1 ) ; } return ans ; }
function minCost ( N , M , vCost , eCost , sorc , colored , destination ) { var adj = [ ] ; for ( var i = 0 ; i < N + 1 ; i ++ ) adj . push ( new Array ( ) ) ; for ( var i = 0 ; i < M ; i ++ ) { ( adj [ sorc [ i ] ] ) . push ( destination [ i ] ) ; ( adj [ destination [ i ] ] ) . push ( sorc [ i ] ) ; } var vis = Array ( N + 1 ) . fill ( 0 ) ; for ( var i = 0 ; i < colored . length ; i ++ ) { DFS ( colored [ i ] , vis , adj ) ; } var X = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { if ( vis [ i ] == 0 ) { X ++ ; DFS ( i , vis , adj ) ; } } var mincost = X * Math . min ( vCost , eCost ) ; document . write ( mincost ) ; }
function power ( N , P ) { return Math . pow ( N , P ) ; }
function Solve ( N , M ) { let temp = ( N - 1 ) * ( M - 1 ) ; let ans = ( Math . pow ( 2 , temp ) ) ; if ( ( N + M ) % 2 != 0 ) document . write ( ans ) ; else document . write ( 2 * ans ) ; }
function findMaximumLength ( lis ) { id ++ ; length = 0 ; diameter = 0 ; for ( let i = 0 ; i < row ; i ++ ) { for ( let j = 0 ; j < col ; j ++ ) { if ( lis [ i ] [ j ] != 0 ) { dfs ( i , j , lis ) ; i = row ; break ; } } } id ++ ; length = 0 ; diameter = 0 ; dfs ( x , y , lis ) ; document . write ( diameter ) ; }
function maxModulosum ( a , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return sum - n ; }
function noOfPermutations ( a , n ) { if ( n == 1 ) { return 1 ; } a . sort ( ) ; if ( a [ n - 1 ] == a [ n - 2 ] ) { return 0 ; } let x = 0 ; for ( let i = 0 ; i < n - 2 ; ++ i ) { if ( a [ i ] == a [ i + 1 ] ) { if ( a [ i ] == a [ i + 2 ] ) { return 0 ; } x ++ ; i ++ ; } } return pow ( 2 , n - 2 * x - 1 ) ; }
function maxValue ( arr , n , moves ) { for ( var i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { var distance = n - 1 - i ; if ( moves < distance ) break ; var can_take = parseInt ( moves / distance ) ; var take = Math . min ( arr [ i ] , can_take ) ; arr [ n - 1 ] += take ; moves -= take * distance ; } } return arr [ n - 1 ] ; }
function hasCrest ( arr , n , L , R ) { let present = new Uint8Array ( n ) ; for ( let i = 1 ; i <= n - 2 ; i ++ ) { if ( ( arr [ i ] <= arr [ i + 1 ] ) && ( arr [ i ] <= arr [ i - 1 ] ) ) { present [ i ] = 1 ; } } for ( let i = 1 ; i < n ; i ++ ) { present [ i ] += present [ i - 1 ] ; } if ( present [ L ] == present [ R - 1 ] ) return true ; return false ; }
function getMin ( arr , n ) { var minVal = Math . min . apply ( Math , arr ) ; return minVal ; }
function Substring ( s ) { var ans = 1 , temp = 1 ; for ( var i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { ++ temp ; } else { ans = Math . max ( ans , temp ) ; temp = 1 ; } } ans = Math . max ( ans , temp ) ; return ans ; }
function countOp ( x ) { let arr = new Array ( MAX ) ; arr [ 0 ] = 1 ; for ( let i = 1 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] * 2 ; let temp = x ; let flag = true ; let ans ; let operations = 0 ; let flag2 = false ; for ( let i = 0 ; i < MAX ; i ++ ) { if ( arr [ i ] - 1 == x ) flag2 = true ; if ( arr [ i ] > x ) { ans = i ; break ; } } if ( flag2 ) return 0 ; while ( flag ) { if ( arr [ ans ] < x ) ans ++ ; operations ++ ; for ( let i = 0 ; i < MAX ; i ++ ) { let take = x ^ ( arr [ i ] - 1 ) ; if ( take <= arr [ ans ] - 1 ) { if ( take > temp ) temp = take ; } } if ( temp == arr [ ans ] - 1 ) { flag = false ; break ; } temp ++ ; operations ++ ; x = temp ; if ( x == arr [ ans ] - 1 ) flag = false ; } return operations ; }
function getMinSum ( arr , n ) { let bits_count = new Array ( MAX ) . fill ( 0 ) , max_bit = 0 , sum = 0 , ans = 0 ; for ( let d = 0 ; d < n ; d ++ ) { let e = arr [ d ] , f = 0 ; while ( e > 0 ) { let rem = e % 2 ; e = parseInt ( e / 2 ) ; if ( rem == 1 ) { bits_count [ f ] += rem ; } f ++ ; } max_bit = Math . max ( max_bit , f ) ; } for ( let d = 0 ; d < max_bit ; d ++ ) { let temp = Math . pow ( 2 , d ) ; if ( bits_count [ d ] > parseInt ( n / 2 ) ) ans = ans + temp ; } for ( let d = 0 ; d < n ; d ++ ) { arr [ d ] = arr [ d ] ^ ans ; sum = sum + arr [ d ] ; } return sum ; }
function replacedArray ( N , arr ) { var pos_sum , neg_sum , i , j , diff ; pos_sum = 0 ; neg_sum = 0 ; for ( i = N - 1 ; i >= 0 ; i -- ) { diff = Math . abs ( pos_sum ) - Math . abs ( neg_sum ) ; if ( arr [ i ] > 0 ) pos_sum += arr [ i ] ; else neg_sum += arr [ i ] ; arr [ i ] = Math . abs ( diff ) ; } }
function findCountOfPairs ( a , b , n ) { let ans = 0 ; ans += n * parseInt ( a / n , 10 ) * parseInt ( b / n , 10 )  ans += parseInt ( a / n , 10 ) * parseInt ( b % n , 10 ) ; ans += parseInt ( a % n , 10 ) * parseInt ( b / n , 10 ) ; ans += parseInt ( ( ( a % n ) + ( b % n ) ) / n , 10 ) ; return ans ; }
function minChanges ( A , n ) { var cnt = 0 ; for ( var i = 0 ; i < n - 2 ; ++ i ) { if ( ( i - 1 >= 0 ) && A [ i - 1 ] == 1 && A [ i + 1 ] == 1 && A [ i ] == 0 ) { A [ i + 1 ] = 0 ; cnt ++ ; } } return cnt ; }
function solve ( v , n ) { let ans , ul , ll ; let first = 0 ; let second = 1 ; ll = v [ 0 ] [ first ] ; ul = v [ 0 ] [ second ] ; ans = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( ( v [ i ] [ first ] <= ul && v [ i ] [ first ] >= ll ) || ( v [ i ] [ second ] >= ll && v [ i ] [ second ] <= ul ) ) { if ( v [ i ] [ first ] > ll ) { ll = v [ i ] [ first ] ; } if ( v [ i ] [ second ] < ul ) { ul = v [ i ] [ second ] ; } } else if ( v [ i ] [ first ] > ul ) { ans += Math . abs ( ul - v [ i ] [ first ] ) ; ul = v [ i ] [ first ] ; ll = v [ i ] [ first ] ; } else if ( v [ i ] [ second ] < ll ) { ans += Math . abs ( ll - v [ i ] [ second ] ) ; ul = v [ i ] [ second ] ; ll = v [ i ] [ second ] ; } } return ans ; }
function steps ( N , M ) { if ( N == 1 ) return 0 ; return M ; return 2 * M + ( N - 3 ) ; }
function dfs ( w ) { if ( cd [ w ] == 0 ) return w ; if ( wt [ w ] < ans ) ans = wt [ w ] ; return dfs ( cd [ w ] ) ; }
function digitsNum ( N ) { if ( N == 0 ) document . write ( "0" ) ; if ( N % 9 != 0 ) document . write ( N % 9 ) ; for ( var i = 1 ; i <= N / 9 ; ++ i ) document . write ( "9" ) ; for ( var i = 1 ; i <= N ; ++ i ) document . write ( "0" ) ; document . write ( "" ) ; }
function bestpermutation ( arr , k , n ) { let h = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { h . set ( arr [ i ] , i ) ; } if ( n <= k ) { arr . sort ( function ( a , b ) { return b - a ; } ) ; } else { for ( let j = n ; j >= 1 ; j -- ) { if ( k > 0 ) { let initial_index = h [ j ] ; let best_index = n - j ; if ( initial_index != best_index ) { h . set ( j , best_index ) ; let element = arr . get ( best_index ) ; h . set ( element , initial_index ) ; let temp = arr [ best_index ] ; arr . set ( best_index , arr [ initial_index ] ) ; arr . set ( initial_index , temp ) ; k -- ; } } } } }
function sumArray ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } return sum ; }
function firstFit ( weight , n , c ) { let res = 0 ; let bin_rem = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { let j ; for ( j = 0 ; j < res ; j ++ ) { if ( bin_rem [ j ] >= weight [ i ] ) { bin_rem [ j ] = bin_rem [ j ] - weight [ i ] ; break ; } } if ( j == res ) { bin_rem [ res ] = c - weight [ i ] ; res ++ ; } } return res ; }
function find ( A , B , C , N ) { let arr = new Array ( N ) . fill ( 0 ) ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; for ( let i = 3 ; i < N ; i ++ ) { arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] + arr [ i - 3 ] ; } return arr [ N - 1 ] ; }
function maxSum ( arr , n ) { var r1 = 0 , r2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { var temp = r1 ; r1 = Math . max ( r1 , r2 + arr [ 0 ] [ i ] ) ; r2 = Math . max ( r2 , temp + arr [ 1 ] [ i ] ) ; } document . write ( Math . max ( r1 , r2 ) ) ; }
function countMinCoins ( n , C , m ) { if ( n == 0 ) { dp [ 0 ] = 0 ; return 0 ; } if ( dp [ n ] != - 1 ) return dp [ n ] ; var ret = 1000000000 ; for ( var i = 0 ; i < m ; i ++ ) { if ( C [ i ] <= n ) { var x = countMinCoins ( n - C [ i ] , C , m ) ; if ( x != 1000000000 ) ret = Math . min ( ret , 1 + x ) ; } } dp [ n ] = ret ; return ret ; }
function findSolution ( n , C , m ) { if ( n == 0 ) { denomination . forEach ( it => { document . write ( it + "▁" ) ; } ) ; return ; } for ( var i = 0 ; i < m ; i ++ ) { if ( n - C [ i ] >= 0 && dp [ n - C [ i ] ] + 1 == dp [ n ] ) { denomination . push ( C [ i ] ) ; findSolution ( n - C [ i ] , C , m ) ; break ; } } }
function count_unique_sum ( n ) { let i ; let ans = 1 ; let ar = new Array ( n + 1 ) ; let fsum = new Array ( n + 1 ) ; let rsum = new Array ( n + 1 ) ; fsum . fill ( 0 ) ; rsum . fill ( 0 ) ; for ( i = 0 ; i <= n ; i ++ ) { ar [ i ] = i ; } fsum [ 0 ] = ar [ 0 ] ; rsum [ n ] = ar [ n ] ; for ( i = 1 ; i <= n ; i ++ ) { fsum [ i ] = ar [ i ] + fsum [ i - 1 ] ; } for ( i = n - 1 ; i >= 0 ; i -- ) { rsum [ i ] = ar [ i ] + rsum [ i + 1 ] ; } for ( let k = 2 ; k <= n ; k ++ ) { ans += 1 + rsum [ n + 1 - k ] - fsum [ k - 1 ] ; } return ans ; }
function precompute ( nextpos , arr , N ) { nextpos [ N - 1 ] = N ; for ( var i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == arr [ i + 1 ] ) nextpos [ i ] = nextpos [ i + 1 ] ; else nextpos [ i ] = i + 1 ; } }
function fun ( pos , sum , st , check , f ) { if ( pos == N ) { return ( sum == 0 && check == 1 ) ? 1 : 0 ; } if ( dp [ pos ] [ sum ] [ st ] [ check ] [ f ] != - 1 ) return dp [ pos ] [ sum ] [ st ] [ check ] [ f ] ; var lmt = 9 ; if ( f == 0 ) lmt = v [ pos ] ; var ans = 0 ; for ( var digit = 0 ; digit <= lmt ; digit ++ ) { var nf = f ; var new_sum = ( sum + digit ) % K ; var new_check = check ; var new_st = st ; if ( f == 0 && digit < lmt ) nf = 1 ; if ( check == 0 && digit != 0 ) { new_st = digit ; new_check = 1 ; } if ( pos == N - 1 && new_st == digit ) continue ; ans += fun ( pos + 1 , new_sum , new_st , new_check , nf ) ; } return dp [ pos ] [ sum ] [ st ] [ check ] [ f ] = ans ; }
function minSumProd ( S , K ) { let len = S . length ; if ( K > len ) return - 1 ; if ( K == len ) return 0 ; let dp = new Array ( len ) ; let count_zero = 0 , count_one = 0 ; for ( let j = 0 ; j < len ; j ++ ) { ( S [ j ] == "0" ) ? count_zero ++ : count_one ++ ; dp [ j ] = count_zero * count_one ; } for ( let i = 1 ; i < K ; i ++ ) { for ( let j = len ; j >= i ; j -- ) { count_zero = 0 , count_one = 0 ; dp [ j ] = Number . MAX_SAFE_INTEGER ; for ( let k = j ; k >= i ; k -- ) { ( S [ k ] == "0" ) ? count_zero ++ : count_one ++ ; dp [ j ] = Math . min ( dp [ j ] , count_zero * count_one + dp [ k - 1 ] ) ; } } } return dp [ len - 1 ] ; }
function countPairs ( arr , N ) { var maxm = arr . reduce ( ( a , b ) => Math . max ( a , b ) ) ; var i , k ; var bitscount = Array ( maxm + 1 ) . fill ( 0 ) ; for ( i = 1 ; i <= maxm ; i *= 2 ) bitscount [ i ] = 1 ; for ( i = 1 ; i <= maxm ; i ++ ) { if ( bitscount [ i ] == 1 ) k = i ; if ( bitscount [ i ] == 0 ) { bitscount [ i ] = bitscount [ k ] + bitscount [ i - k ] ; } } var setbits = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( setbits . has ( bitscount [ arr [ i ] ] ) ) setbits . set ( bitscount [ arr [ i ] ] , setbits . get ( bitscount [ arr [ i ] ] ) + 1 ) else setbits . set ( bitscount [ arr [ i ] ] , 1 ) } var ans = 0 ; setbits . forEach ( ( value , key ) => { ans += value * ( value - 1 ) / 2 ; } ) ; return ans ; }
function solve ( n , k , m ) { if ( n == 0 && k == 0 ) return 1 ; if ( n == 0 && k != 0 ) return 0 ; if ( n != 0 && k == 0 ) { return 0 ; } if ( n < 0 k < 0 ) return 0 ; if ( dp [ n ] [ k ] > 0 ) return dp [ n ] [ k ] ; var ans = 0 ; for ( var j = 1 ; j <= m ; j ++ ) { ans += solve ( n - j , k - 1 , m ) ; } return dp [ n ] [ k ] = ans ; }
function isprime ( n ) { if ( n == 1 ) return false ; for ( var i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; }
function productDigitSum ( x , y ) { let sumx = 0 ; while ( x ) { sumx += ( x % 10 ) ; x = Math . floor ( x / 10 ) ; } let sumy = 0 ; while ( y ) { sumy += ( y % 10 ) ; y = Math . floor ( y / 10 ) ; } return ( sumx * sumy ) ; }
function CountSets ( x , pos ) { if ( x <= 0 ) { if ( pos == 0 ) return 1 ; else return 0 ; } if ( pos == 0 ) return 1 ; if ( dp [ x ] [ pos ] != - 1 ) return dp [ x ] [ pos ] ; var answer = CountSets ( x - 1 , pos ) + CountSets ( x - 2 , pos - 1 ) ; return dp [ x ] [ pos ] = answer ; }
function splitIntoPrimes ( number ) { if ( number . length == 0 ) return 0 ; if ( number . length <= 6 && checkPrime ( number ) ) return 1 ; else { let numLen = number . length ; let ans = 1000000 ; for ( let i = 1 ; i <= 6 && i <= numLen ; i ++ ) { if ( checkPrime ( number . substr ( 0 , i ) ) ) { let val = splitIntoPrimes ( number . substr ( i ) ) ; if ( val != - 1 ) { ans = Math . min ( ans , 1 + val ) ; } } } if ( ans == 1000000 ) return - 1 ; return ans ; } }
function dp ( pos , fl , pr , bin ) { if ( pos == bin . length ) return 1 ; if ( memo [ pos ] [ fl ] [ pr ] != - 1 ) return memo [ pos ] [ fl ] [ pr ] ; var val = 0 ; if ( bin [ pos ] == "0" ) val = val + dp ( pos + 1 , fl , 0 , bin ) ; else if ( bin [ pos ] == "1" ) val = val + dp ( pos + 1 , 1 , 0 , bin ) ; if ( pr == 0 ) { if ( fl == 1 ) { val += dp ( pos + 1 , fl , 1 , bin ) ; } else if ( bin [ pos ] == "1" ) { val += dp ( pos + 1 , fl , 1 , bin ) ; } } return memo [ pos ] [ fl ] [ pr ] = val ; }
function TotalWays ( n , s , k ) { let dp = new Array ( n ) ; dp . fill ( 0 ) ; dp [ s - 1 ] = 1 ; for ( let i = s ; i < n ; i ++ ) { let idx = Math . max ( s - 1 , i - k ) ; for ( let j = idx ; j < i ; j ++ ) { dp [ i ] += dp [ j ] ; } } return dp [ n - 1 ] ; }
function solve ( arr , n , i , pos ) { if ( i == n ) return 0 ; if ( LAS [ i ] [ pos ] ) return LAS [ i ] [ pos ] ; let inc = 0 , exc = 0 ; if ( arr [ i ] > 0 && pos == true ) { pos = false ; inc = 1 + solve ( arr , n , i + 1 , pos ) ; } else if ( arr [ i ] < 0 && pos == false ) { pos = true ; inc = 1 + solve ( arr , n , i + 1 , pos ) ; } exc = solve ( arr , n , i + 1 , pos ) ; LAS [ i ] [ pos ] = Math . max ( inc , exc ) ; return LAS [ i ] [ pos ] ; }
function query ( inVal , l , r , l1 , r1 ) { if ( l > r ) return 0 ; if ( r < l1 l > r1 ) return 0 ; if ( l1 <= l && r <= r1 ) return seg [ inVal ] ; var m = parseInt ( ( l + r ) / 2 ) ; return query ( 2 * inVal + 1 , l , m , l1 , r1 ) + query ( 2 * inVal + 2 , m + 1 , r , l1 , r1 ) ; }
function minMergeCost ( i , j , arr ) { if ( i == j ) return 0 ; if ( v [ i ] [ j ] ) return dp [ i ] [ j ] ; v [ i ] [ j ] = 1 ; var x = dp [ i ] [ j ] ; x = 1000000000 ; var tot = 0 ; for ( var k = i ; k <= j ; k ++ ) tot += arr [ k ] ; for ( var k = i + 1 ; k <= j ; k ++ ) { x = Math . min ( x , tot + minMergeCost ( i , k - 1 , arr ) + minMergeCost ( k , j , arr ) ) ; } return x ; }
function numberOfCells ( mat ) { let row = new Array ( N ) ; let col = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { row [ i ] = new Array ( N ) ; col [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { row [ i ] [ j ] = 0 ; col [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) { for ( let j = N - 1 ; j >= 0 ; j -- ) { if ( mat [ i ] [ j ] == 1 ) { row [ i ] [ j ] = ( j + 1 < N ) ? row [ i ] [ j + 1 ] : true ; } else { row [ i ] [ j ] = false ; } } } for ( let j = 0 ; j < N ; j ++ ) { for ( let i = N - 1 ; i >= 0 ; i -- ) { if ( mat [ i ] [ j ] == 1 ) { col [ i ] [ j ] = ( i + 1 < N ) ? col [ i + 1 ] [ j ] : true ; } else { col [ i ] [ j ] = false ; } } } let cnt = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { for ( let j = 0 ; j < N - 1 ; j ++ ) { if ( row [ i ] [ j ] && col [ i ] [ j ] ) { cnt ++ ; } } } for ( let i = 0 ; i < N ; i ++ ) { if ( col [ i ] [ N - 1 ] ) cnt ++ ; } for ( let j = 0 ; j < N - 1 ; j ++ ) { if ( row [ N - 1 ] [ j ] ) cnt ++ ; } return cnt ; }
function subsequence ( S , T , n , m ) { let dp = new Array ( )  for ( let i = 0 ; i < n + 1 ; i ++ ) { let temp = [ ] ; for ( let j = 0 ; j < m + 1 ; j ++ ) { temp . push ( [ ] ) } dp . push ( temp ) } for ( let i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( let j = 0 ; j <= m ; j ++ ) dp [ 0 ] [ j ] = 1 ; for ( let i = 1 ; i <= n ; ++ i ) { for ( let j = 1 ; j <= m ; ++ j ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; if ( S [ i - 1 ] == T [ j - 1 ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] ; dp [ i ] [ j ] += mod ; dp [ i ] [ j ] %= mod ; } } return dp [ n ] [ m ] ; }
function findCount ( n ) { return parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) + 1 ; }
function findLen ( arr , i , curr , n , m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; var l = findLen ( arr , i + 1 , curr , n , m ) ; var r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
function findLen ( arr , i , curr , n , m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; var l = findLen ( arr , i + 1 , curr , n , m ) ; var r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; }
function countWays ( n ) { let dp = new Array ( n + 1 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 1 ; for ( let i = 3 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; } return dp [ n ] ; }
function findPath ( maze , xpos , ypos , key ) { if ( xpos < 0 xpos >= maze . length ypos < 0 ypos >= maze . length ) return false ; if ( maze [ xpos ] [ ypos ] == "1" ) { if ( key == true ) if ( xpos == maze . length - 1 && ypos == maze . length - 1 ) return true ; return findPath ( maze , xpos + 1 , ypos , false ) || findPath ( maze , xpos , ypos + 1 , false ) ; return false ; } if ( xpos == maze . length - 1 && ypos == maze . length - 1 ) return true ; return findPath ( maze , xpos + 1 , ypos , key ) || findPath ( maze , xpos , ypos + 1 , key ) ; }
function findPrefixCount ( arr , n ) { for ( let i = 0 ; i < bitscount ; i ++ ) { prefix_count [ i ] [ 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) ; for ( let j = 1 ; j < n ; j ++ ) { prefix_count [ i ] [ j ] = ( ( arr [ j ] >> i ) & 1 ) ; prefix_count [ i ] [ j ] += prefix_count [ i ] [ j - 1 ] ; } } }
function countWays ( n , l , r ) { let tL = l , tR = r ; let L = new Array ( 3 ) ; let R = new Array ( 3 ) ; L [ l % 2 ] = l ; R [ r % 2 ] = r ; l ++ ; r -- ; if ( l <= tR && r >= tL ) { L [ l % 2 ] = l ; R [ r % 2 ] = r ; } let cnt0 = 0 , cnt1 = 0 ; if ( R [ 0 ] > 0 && L [ 0 ] > 0 ) cnt0 = ( R [ 0 ] - L [ 0 ] ) / 2 + 1 ; if ( R [ 1 ] > 0 && L [ 1 ] > 0 ) cnt1 = ( R [ 1 ] - L [ 1 ] ) / 2 + 1 ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( 3 ) ; for ( let j = 0 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 1 ] [ 0 ] = cnt0 ; dp [ 1 ] [ 1 ] = cnt1 ; for ( let i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = ( cnt0 * dp [ i - 1 ] [ 0 ] + cnt1 * dp [ i - 1 ] [ 1 ] ) ; dp [ i ] [ 1 ] = ( cnt0 * dp [ i - 1 ] [ 1 ] + cnt1 * dp [ i - 1 ] [ 0 ] ) ; } return dp [ n ] [ 0 ] ; }
function dfs ( node , parent , dp1 , dp2 , adj ) { let firstmax = - 1 ; let secondmax = - 1 ; for ( let i = 0 ; i < adj [ node ] . length ; ++ i ) { if ( adj [ node ] [ i ] == parent ) continue ; dfs ( adj [ node ] [ i ] , node , dp1 , dp2 , adj ) ; if ( firstmax == - 1 ) { firstmax = dp1 [ adj [ node ] [ i ] ] ; } else if ( dp1 [ adj [ node ] [ i ] ] >= firstmax ) { secondmax = firstmax ; firstmax = dp1 [ adj [ node ] [ i ] ] ; } else if ( dp1 [ adj [ node ] [ i ] ] > secondmax ) { secondmax = dp1 [ adj [ node ] [ i ] ] ; } } dp1 [ node ] = 1 ; dp1 [ node ] += firstmax ; if ( secondmax != - 1 ) dp2 [ node ] = 1 + firstmax + secondmax ; return Math . max ( dp1 [ node ] , dp2 [ node ] ) ; }
function countRec ( start , end , dp , st ) { let sum = 0 ; if ( start > end ) return 1 ; if ( dp [ start ] [ end ] != - 1 ) return dp [ start ] [ end ] ; let i , r = 0 ; for ( i = start + 1 ; i <= end ; i += 2 ) { if ( checkFunc ( start , i , st ) == 1 ) { sum = sum + countRec ( start + 1 , i - 1 , dp , st ) * countRec ( i + 1 , end , dp , st ) ; } else if ( st [ start ] == "?" && st [ i ] == "?" ) { sum = sum + countRec ( start + 1 , i - 1 , dp , st ) * countRec ( i + 1 , end , dp , st ) * 3 ; } } return dp [ start ] [ end ] = sum ; }
function countWays ( st ) { let n = st . length ; if ( n % 2 == 1 ) return 0 ; let dp = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) { dp [ i ] = new Array ( MAX ) ; for ( let j = 0 ; j < MAX ; j ++ ) dp [ i ] [ j ] = - 1 ; } return countRec ( 0 , n - 1 , dp , st ) ; }
function pre_compute ( a ) { if ( a [ 0 ] [ 0 ] == "a" ) dp [ 0 ] [ 0 ] = 0 ; else dp [ 0 ] [ 0 ] = 1 ; for ( let row = 0 ; row < n ; row ++ ) { for ( let col = 0 ; col < n ; col ++ ) { if ( row != 0 col != 0 ) dp [ row ] [ col ] = Number . MAX_VALUE ; if ( row != 0 ) { dp [ row ] [ col ] = Math . min ( dp [ row ] [ col ] , dp [ row - 1 ] [ col ] ) ; } if ( col != 0 ) { dp [ row ] [ col ] = Math . min ( dp [ row ] [ col ] , dp [ row ] [ col - 1 ] ) ; } if ( a [ row ] [ col ] != "a" && ( row != 0 col != 0 ) ) dp [ row ] [ col ] += 1 ; } } }
function CommomSubsequencesCount ( s , t ) { var n1 = s . length ; var n2 = t . length ; var dp = Array . from ( Array ( n1 + 1 ) , ( ) => Array ( n2 + 1 ) ) ; for ( var i = 0 ; i <= n1 ; i ++ ) { for ( var j = 0 ; j <= n2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( var i = 1 ; i <= n1 ; i ++ ) { for ( var j = 1 ; j <= n2 ; j ++ ) { if ( s [ i - 1 ] == t [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] - dp [ i - 1 ] [ j - 1 ] ; } } return dp [ n1 ] [ n2 ] ; }
function lcs ( dp , a , b , m , n ) { if ( m < 0 n < 0 ) { return 0 ; } if ( dp [ m ] [ n ] != - 1 ) return dp [ m ] [ n ] ; let ans = 0 ; if ( a [ m ] == b [ n ] ) { ans = ( a [ m ] . charCodeAt ( 0 ) - 48 ) + lcs ( dp , a , b , m - 1 , n - 1 ) ; } else ans = Math . max ( lcs ( dp , a , b , m - 1 , n ) , lcs ( dp , a , b , m , n - 1 ) ) ; dp [ m ] [ n ] = ans ; return ans ; }
function largestSumOfAverages ( A , K ) { let n = A . length ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += A [ i ] ; memo [ i + 1 ] [ 1 ] = sum / ( i + 1 ) ; } return score ( n , A , K ) ; }
function largestSumOfAverages ( A , K ) { var n = A . length ; var pre_sum = Array ( n + 1 ) . fill ( - 1 ) ; pre_sum [ 0 ] = 0 ; for ( var i = 0 ; i < n ; i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ; var dp = Array ( n ) . fill ( - 1 ) ; var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ; for ( k = 0 ; k < K - 1 ; k ++ ) for ( i = 0 ; i < n ; i ++ ) for ( j = i + 1 ; j < n ; j ++ ) dp [ i ] = Math . max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ; return dp [ 0 ] ; }
function findMaxVal ( arr , n , num , maxLimit ) { let ind = 0 ; findMaxValUtil ( arr , n , num , maxLimit , ind ) ; return ans ; }
function findMaxVal ( arr , n , num , maxLimit ) { var ind ; var val ; var dp = Array . from ( Array ( n ) , ( ) => Array ( maxLimit + 1 ) ) ; for ( ind = 0 ; ind < n ; ind ++ ) { for ( val = 0 ; val <= maxLimit ; val ++ ) { if ( ind == 0 ) { if ( num - arr [ ind ] == val num + arr [ ind ] == val ) { dp [ ind ] [ val ] = 1 ; } else { dp [ ind ] [ val ] = 0 ; } } else { if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] || dp [ ind - 1 ] [ val + arr [ ind ] ] ; } else if ( val - arr [ ind ] >= 0 ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] ; } else if ( val + arr [ ind ] <= maxLimit ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] ; } else { dp [ ind ] [ val ] = 0 ; } } } } for ( val = maxLimit ; val >= 0 ; val -- ) { if ( dp [ n - 1 ] [ val ] ) { return val ; } } return - 1 ; }
function gen ( n ) { if ( n == 0 ) return 0 ; else if ( n == 1 ) return 1 ; else if ( n % 2 == 0 ) return 4 * gen ( parseInt ( n / 2 , 10 ) ) ; else if ( n % 2 == 1 ) return 4 * gen ( parseInt ( n / 2 , 10 ) ) + 1 ; return 0 ; }
function solve ( n ) { for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = - 1 ; } for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { nck [ i ] [ j ] = - 1 ; } } let currLog2 = - 1 ; let currPower2 = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( currPower2 == i ) { currLog2 ++ ; currPower2 *= 2 ; } log2 [ i ] = currLog2 ; } return numberOfHeaps ( n ) ; }
function largestSubset ( a , n ) { let dp = [ ] ; dp [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { let mxm = 0 ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] % a [ i ] == 0 a [ i ] % a [ j ] == 0 ) { mxm = Math . max ( mxm , dp [ j ] ) ; } } dp [ i ] = 1 + mxm ; } return Math . max ( ... dp ) ; }
function maxLenSub ( arr , n ) { let mls = new Array ( n ) . fill ( 1 ) , max = 0 ; for ( let i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; }
function minimumNumberOfDeletions ( arr , n ) { let len = lis ( arr , n ) ; return ( n - len ) ; }
function countGroups ( position , previous_sum , length , num ) { if ( position == length ) return 1 ; let res = 0 ; let sum = 0 ; for ( let i = position ; i < length ; i ++ ) { sum += ( num [ i ] . charCodeAt ( ) - "0" . charCodeAt ( ) ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } return res ; }
function lenOfLongestGP ( set , n ) { if ( n < 2 ) { return n ; } if ( n == 2 ) { return ( set [ 1 ] % set [ 0 ] == 0 ? 2 : 1 ) ; } set . sort ( function ( a , b ) { return a - b } ) ; let L = new Array ( n ) ; for ( let i = 0 ; i < n ; ++ i ) { L [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; ++ j ) { L [ i ] [ j ] = 0 ; } } let llgp = 1 ; for ( let i = 0 ; i < n - 1 ; ++ i ) { if ( set [ n - 1 ] % set [ i ] == 0 ) { L [ i ] [ n - 1 ] = 2 ; if ( 2 > llgp ) llgp = 2 ; } else { L [ i ] [ n - 1 ] = 1 ; } } L [ n - 1 ] [ n - 1 ] = 1 ; for ( let j = n - 2 ; j >= 1 ; -- j ) { let i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) { ++ k ; } else if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] ) { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = 2 ; if ( 2 > llgp ) llgp = 2 ; } else { L [ i ] [ j ] = 1 ; } -- i ; } else { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; if ( L [ i ] [ j ] > llgp ) { llgp = L [ i ] [ j ] ; } } else { L [ i ] [ j ] = 1 ; } -- i ; ++ k ; } } while ( i >= 0 ) { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = 2 ; if ( 2 > llgp ) llgp = 2 ; } else { L [ i ] [ j ] = 1 ; } -- i ; } } return llgp ; }
function findMinRec ( arr , i , sumCalculated , sumTotal ) { if ( i == 0 ) return Math . abs ( ( sumTotal - sumCalculated ) - sumCalculated ) ; return Math . min ( findMinRec ( arr , i - 1 , sumCalculated + arr [ i - 1 ] , sumTotal ) , findMinRec ( arr , i - 1 , sumCalculated , sumTotal ) ) ; }
function findMin ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( sum + 1 ) ; for ( let j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = true ; } } for ( let i = 1 ; i <= sum ; i ++ ) dp [ 0 ] [ i ] = false ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= sum ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; if ( arr [ i - 1 ] <= j ) dp [ i ] [ j ] |= dp [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } let diff = Number . MAX_VALUE ; for ( let j = Math . floor ( sum / 2 ) ; j >= 0 ; j -- ) { if ( dp [ n ] [ j ] == true ) { diff = sum - 2 * j ; break ; } } return diff ; }
function minSize ( arr , n , k ) { for ( let i = 0 ; i < MAX ; i ++ ) { for ( let j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return minSizeRec ( arr , 0 , n - 1 , k ) ; }
function minRemovals ( arr , l , h ) { if ( l >= h ) return 0 ; let mn = min ( arr , l , h ) ; let mx = max ( arr , l , h ) ; if ( 2 * mn > mx ) return 0 ; return Math . min ( minRemovals ( arr , l + 1 , h ) , minRemovals ( arr , l , h - 1 ) ) + 1 ; }
function optimalStrategyOfGame ( arr , n ) { let table = new Array ( n ) ; let gap , i , j , x , y , z ; for ( let d = 0 ; d < n ; d ++ ) { table [ d ] = new Array ( n ) ; } for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = Math . max ( arr [ i ] + Math . min ( x , y ) , arr [ j ] + Math . min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }
function lps ( seq , i , j ) { if ( i == j ) { return 1 ; } if ( seq [ i ] == seq [ j ] && i + 1 == j ) { return 2 ; } if ( seq [ i ] == seq [ j ] ) { return lps ( seq , i + 1 , j - 1 ) + 2 ; } return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; }
function knapSack ( W , wt , val , n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }
function MatrixChainOrder ( p , i , j ) { if ( i == j ) return 0 ; var min = Number . MAX_VALUE ; var k = 0 ; for ( k = i ; k < j ; k ++ ) { var count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; }
function solve ( arr , N ) { var M = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { M . set ( i , arr [ i ] ) ; } arr . sort ( ( a , b ) => a - b ) ; var Count = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { Count . set ( arr [ i ] , parseInt ( Math . pow ( 2 , N - i - 1 ) ) ) ; } M . forEach ( ( value , key ) => { document . write ( Count . get ( value ) + "▁" ) ; } ) ; }
function min_time_to_cut ( N ) { if ( N == 0 ) return 0 ; return Math . ceil ( Math . log ( N ) / Math . log ( 2 ) ) ; }
function q3 ( s , i ) { if ( i == s . length ) { document . write ( "Yes" ) ; return ; } if ( s [ i ] == "a" ) q4 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; }
function nthTerm ( N ) { let nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; }
function start ( c ) { if ( c == "t" c == "T" ) dfa = 1 ; }
function isEqualSubstring ( str , x ) { let n = str . length ; let i = 0 ; while ( i < n && i < x ) { if ( str [ i ] !== str [ n - i - 1 ] ) { document . write ( "false" ) ; return ; } i ++ ; } document . write ( "true" ) ; }
function canMakeEqual ( S ) { var N = S . length ; var weightOfString = 0 ; for ( var i = 0 ; i < N ; i ++ ) { weightOfString += S . charAt ( i ) . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) + 1 ; } if ( weightOfString % N == 0 ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function updateTree ( s , tree , start , end , treenode , idx , X ) { if ( ( start == end ) && ( idx == start ) ) { s [ idx ] = X ; tree [ treenode ] . square_sum = Math . pow ( X . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) + 1 , 2 ) ; return ; } let mid = start + Math . floor ( ( end - start ) / 2 ) ; if ( idx <= mid ) { updateTree ( s , tree , start , mid , ( 2 * treenode ) , idx , X ) ; } else { updateTree ( s , tree , mid + 1 , end , ( 2 * treenode ) + 1 , idx , X ) ; } tree [ treenode ] . square_sum = tree [ ( 2 * treenode ) ] . square_sum + tree [ ( 2 * treenode ) + 1 ] . square_sum ; }
function getPalindromePath ( root ) { finalAns = "$" ; lexicographicallySmall ( root , "" ) ; if ( finalAns == "$" ) document . write ( "No▁Palindromic▁Path▁exists" ) ; else document . write ( finalAns ) ; }
function permute ( n , r ) { var ans = 0 ; ans = ( fact ( n ) / fact ( n - r ) ) ; return ans ; }
function isValid ( a1 , a2 , str , flag ) { let v1 , v2 ; if ( flag == 0 ) { v1 = str [ 4 ] ; v2 = str [ 3 ] ; } else { v1 = str [ 1 ] ; v2 = str [ 0 ] ; } if ( v1 != a1 && v1 != "?" ) return false ; if ( v2 != a2 && v2 != "?" ) return false ; return true ; }
function minDel ( s1 , s2 ) { var i = s1 . length ; var j = s2 . length ; while ( i > 0 && j > 0 ) { if ( s1 [ i - 1 ] != s2 [ j - 1 ] ) { break ; } i -- ; j -- ; } return i + j ; }
function can_Construct ( S , K ) { var m = new Map ( ) ; var i = 0 , j = 0 , p = 0 ; if ( S . length == K ) { return true ; } for ( i = 0 ; i < S . length ; i ++ ) { if ( m . has ( S [ i ] ) ) m . set ( S [ i ] , m . get ( S [ i ] ) + 1 ) else m . set ( S [ i ] , 1 ) } if ( K > S . length ) { return false ; } else { m . forEach ( ( value , key ) => { if ( value % 2 != 0 ) { p = p + 1 ; } } ) ; } if ( K < p ) { return false ; } return true ; }
function bcdToDecimal ( s ) { let len = s . length ; let check = 0 , check0 = 0 ; let num = 0 , sum = 0 ; let mul = 1 , rev = 0 ; for ( let i = len - 1 ; i >= 0 ; i -- ) { sum += ( s [ i ] - "0" ) * mul ; mul *= 2 ; check ++ ; if ( check == 4 i == 0 ) { if ( sum == 0 && check0 == 0 ) { num = 1 ; check0 = 1 ; } else { num = num * 10 + sum ; } check = 0 ; sum = 0 ; mul = 1 ; } } while ( num > 0 ) { rev = rev * 10 + ( num % 10 ) ; num = Math . floor ( num / 10 ) ; } if ( check0 == 1 ) return rev - 1 ; return rev ; }
function isPossibleSum ( N ) { if ( isPrime ( N ) && isPrime ( N - 2 ) ) { return true ; } else { return false ; } }
function findMaxFrequency ( s ) { var arr = Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < s . length ; i ++ ) arr [ s [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; var hash = new Map ( ) ; for ( var i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] != 0 ) { if ( hash . has ( arr [ i ] ) ) hash . set ( arr [ i ] , hash . get ( arr [ i ] ) + 1 ) else hash . set ( arr [ i ] , 1 ) } var max_count = 0 , res = - 1 ; hash . forEach ( ( value , key ) => { if ( max_count < value ) { res = key ; max_count = value ; } } ) ; document . write ( "Frequency▁" + res + "▁is▁repeated▁" + max_count + "▁times" ) ; }
function checkIfStartsWithVowels ( str ) { if ( ! ( str [ 0 ] == "A" str [ 0 ] == "a" str [ 0 ] == "E" str [ 0 ] == "e" str [ 0 ] == "I" str [ 0 ] == "i" str [ 0 ] == "O" str [ 0 ] == "o" str [ 0 ] == "U" str [ 0 ] == "u" ) ) return 1 ; else return 0 ; }
function xExistsInY ( x , y ) { if ( x . length > y . length ) return false ; var cnt_x = Array ( MAX ) . fill ( 0 ) ; var cnt = Array ( MAX ) . fill ( 0 ) ; for ( var i = 0 ; i < x . length ; i ++ ) cnt_x [ x [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < x . length ; i ++ ) cnt [ y [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; if ( areEqual ( cnt_x , cnt ) ) return true ; for ( var i = 1 ; i < y . length - x . length + 1 ; i ++ ) { cnt [ y [ i - 1 ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] -- ; cnt [ y [ i + x . length - 1 ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; if ( areEqual ( cnt , cnt_x ) ) return true ; } return false ; }
function updateFreq ( str , freq ) { var len = str . length ; for ( var i = 0 ; i < len ; i ++ ) { freq [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; } }
function cntWays ( str , n ) { var x = n + 1 ; var ways = x * x * ( x * x - 1 ) / 12 ; return ways ; }
function countSticks ( str , n ) { var cnt = 0 ; for ( var i = 0 ; i < n ; i ++ ) { cnt += ( sticks [ str [ i ] - "0" ] ) ; } return cnt ; }
function countTotalDistinct ( str ) { let cnt = 0 ; let items = new Set ( ) ; for ( let i = 0 ; i < str . length ; ++ i ) { let temp = "" ; let ans = new Set ( ) ; for ( let j = i ; j < str . length ; ++ j ) { temp = temp + str [ j ] ; ans . add ( str [ j ] ) ; if ( ! items . has ( temp ) ) { items . add ( temp ) ; cnt += ans . size ; } } } return cnt ; }
function getOrgString ( s ) { document . write ( s [ 0 ] ) ; var i = 1 ; while ( i < s . length ) { if ( s [ i ] . charCodeAt ( 0 ) >= "A" . charCodeAt ( 0 ) && s [ i ] . charCodeAt ( 0 ) <= "Z" . charCodeAt ( 0 ) ) document . write ( "▁" + s [ i ] . toLowerCase ( ) ) ; else document . write ( s [ i ] ) ; i ++ ; } }
function getIndex ( s1 , s2 , len ) { let i = 0 , j = len - 1 ; while ( i < j ) { if ( s1 [ i ] != s2 [ j ] ) { break ; } i ++ ; j -- ; } if ( i == j ) { return i - 1 ; } else if ( isPalindrome ( s2 , i , j ) ) return i - 1 ; else if ( isPalindrome ( s1 , i , j ) ) return j ; return - 1 ; }
function countSubStrings ( s , anotherStr , k ) { let illegal = [ ] ; for ( let i = 0 ; i < 256 ; i ++ ) illegal . push ( false ) ; for ( let i = 0 ; i < anotherStr . length ; i ++ ) illegal [ anotherStr [ i ] ] = true ; let us = new Set ( ) ; for ( let i = 0 ; i < s . length ; ++ i ) { let ss = "" ; let count = 0 ; for ( let j = i ; j < s . length ; ++ j ) { if ( illegal [ s [ j ] ] ) ++ count ; ss = ss + s [ j ] ; if ( count <= k ) { us . add ( ss ) ; } else break ; } } return us . size ; }
function PrimeCharacters ( s ) { var prime = new Array ( max_val + 1 ) ; for ( var i = 0 ; i <= max_val ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( var p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] === true ) { for ( var i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } var count = 0 ; for ( var i = 0 ; i < s . length ; ++ i ) { if ( prime [ s [ i ] . charCodeAt ( 0 ) ] ) count ++ ; } return count ; }
function matchPattern ( s ) { let count = 0 ; let n = s . length ; let i = 0 ; while ( i < n ) { while ( i < n && s [ i ] == "a" ) { count ++ ; i ++ ; } while ( i < n && s [ i ] == "b" ) { count -- ; i ++ ; } if ( count != 0 ) return false ; } return true ; }
function compare ( arr1 , arr2 ) { for ( let i = 0 ; i < ALL_CHARS ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; }
function maximum_one ( s , n ) { var cnt_one = 0 ; var max_cnt = 0 , temp = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == "1" ) { cnt_one ++ ; temp ++ ; } else { max_cnt = Math . max ( temp , max_cnt ) ; temp = 0 ; } } max_cnt = Math . max ( max_cnt , temp ) ; var left = Array ( n ) ; var right = Array ( n ) ; if ( s [ 0 ] == "1" ) left [ 0 ] = 1 ; else left [ 0 ] = 0 ; if ( s [ n - 1 ] == "1" ) right [ n - 1 ] = 1 ; else right [ n - 1 ] = 0 ; for ( var i = 1 ; i < n ; i ++ ) { if ( s [ i ] == "1" ) left [ i ] = left [ i - 1 ] + 1 ; else left [ i ] = 0 ; } for ( var i = n - 2 ; i >= 0 ; i -- ) { if ( s [ i ] == "1" ) right [ i ] = right [ i + 1 ] + 1 ; else right [ i ] = 0 ; } for ( var i = 1 ; i < n - 1 ; i ++ ) { if ( s [ i ] == "0" ) { var sum = left [ i - 1 ] + right [ i + 1 ] ; if ( sum < cnt_one ) max_cnt = Math . max ( max_cnt , sum + 1 ) ; else max_cnt = Math . max ( max_cnt , sum ) ; } } return max_cnt ; }
function bitToBeFlipped ( s ) { let last = s [ s . length - 1 ] ; let first = s [ 0 ] ; if ( last == first ) { if ( last == "0" ) { return "1" ; } else { return "0" ; } } else if ( last != first ) { return last ; } }
function countPalindrome ( str ) { var n = str . length ; var sum = 0 ; var hashTable = Array ( MAX_CHAR ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) hashTable [ str [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < 26 ; i ++ ) { if ( hashTable [ i ] ) sum += ( hashTable [ i ] * ( hashTable [ i ] + 1 ) / 2 ) ; } return sum ; }
function smallestNumber ( n ) { var num = 0 ; var s = "" ; var duplicate = n ; while ( n ) { s = String . fromCharCode ( n % 10 + 48 ) + s ; n = parseInt ( n / 10 ) ; } var index = - 1 ; for ( var i = 0 ; i < s . length ; i ++ ) { var digit = s [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ; if ( ( digit & 1 ) == 0 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; for ( var i = 0 ; i < index ; i ++ ) num = num * 10 + ( s [ i ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) ) ; num = num * 10 + ( s [ index ] . charCodeAt ( 0 ) - "0" . charCodeAt ( 0 ) + 1 ) ; for ( var i = index + 1 ; i < s . length ; i ++ ) num = num * 10 + 1 ; return num ; }
function count_carry ( a , b ) { let carry = 0 ; let count = 0 ; let len_a = a . length , len_b = b . length ; while ( len_a != 0 len_b != 0 ) { let x = 0 , y = 0 ; if ( len_a > 0 ) { x = a [ len_a - 1 ] - "0" ; len_a -- ; } if ( len_b > 0 ) { y = b [ len_b - 1 ] - "0" ; len_b -- ; } let sum = x + y + carry ; if ( sum >= 10 ) { carry = 1 ; count ++ ; } else carry = 0 ; } return count ; }
function leastCount ( s1 , s2 , n ) { let count1 = new Array ( MAX_CHAR ) ; let count2 = new Array ( MAX_CHAR ) ; for ( let i = 0 ; i < MAX_CHAR ; i ++ ) { count1 [ i ] = 0 ; count2 [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { count1 [ s1 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] += 1 ; count2 [ s2 [ i ] . charCodeAt ( 0 ) - "a" . charCodeAt ( 0 ) ] += 1 ; } let res = 0 ; for ( let i = 0 ; i < MAX_CHAR ; i ++ ) { if ( count1 [ i ] != 0 ) { res += Math . abs ( count1 [ i ] - count2 [ i ] ) ; } } return res ; }
function allCharactersSame ( s ) { let s1 = new Set ( ) ; for ( let i = 0 ; i < s . length ; i ++ ) { s1 . add ( s [ i ] ) ; } if ( s1 . size == 1 ) document . write ( "YES" ) ; else document . write ( "NO" ) ; }
function check_isogram ( str ) { let length = str . length ; let mapHash = new Array ( 26 ) ; mapHash . fill ( 0 ) ; for ( let i = 0 ; i < length ; i ++ ) { mapHash [ str [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] ++ ; if ( mapHash [ str [ i ] . charCodeAt ( ) - "a" . charCodeAt ( ) ] > 1 ) { return false ; } } return true ; }
function maxLengthNonPalinSubstring ( str ) { let n = str . length ; let ch = str [ 0 ] ; let i = 1 ; for ( i = 1 ; i < n ; i ++ ) { if ( str [ i ] != ch ) { break ; } } if ( i == n ) return 0 ; if ( isPalindrome ( str ) ) return n - 1 ; return n ; }
function traverseTree ( root ) { if ( root == null ) return ; document . write ( root . data + "▁" ) ; if ( root . child == null ) return ; let q = [ ] ; let curr = root . child ; q . push ( curr ) ; while ( q . length != 0 ) { curr = q [ 0 ] ; q . shift ( ) ; while ( curr != null ) { document . write ( curr . data + "▁" ) ; if ( curr . child != null ) { q . push ( curr . child ) ; } curr = curr . next ; } } }
function transpose ( mat , tr , N ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) tr [ i ] [ j ] = mat [ j ] [ i ] ; }
function qType1 ( l , x , str1 ) { str1 [ l - 1 ] = x ; }
function getFrequency ( tree , idx , i ) { let sum = 0 ; while ( idx > 0 ) { sum += tree [ idx ] [ i ] ; idx -= ( idx & - idx ) ; } return sum ; }
function qType2 ( tree , l , r , str ) { let count = 0 ; for ( let i = 1 ; i <= 26 ; i ++ ) { if ( l == 1 ) { if ( getFrequency ( tree , r , i ) % 2 == 1 ) count ++ ; } else { if ( ( getFrequency ( tree , r , i ) - getFrequency ( tree , l - 1 , i ) ) % 2 == 1 ) count ++ ; } } if ( count <= 1 ) document . write ( "Yes" ) ; else document . write ( "No" ) ; }
function difference ( arr , n ) { let d1 = 0 , d2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i ] [ j ] ; if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ; } } return Math . abs ( d1 - d2 ) ; }
function isValid ( row , col ) { return ( row >= 0 ) && ( col >= 0 ) && ( row < ROW ) && ( col < COL ) ; }
function comb ( n , r ) { var res = fact [ n ] / fact [ r ] ; res /= fact [ n - r ] ; return res ; }
function getMinPathSum ( graph , visited , necessary , src , dest , currSum ) { if ( src == dest ) { var flag = true ; for ( var i of necessary ) { if ( ! visited [ i ] ) { flag = false ; break ; } } if ( flag ) minSum = Math . min ( minSum , currSum ) ; return ; } else { visited [ src ] = true ; for ( var node of graph [ src ] ) { if ( ! visited [ node . first ] ) { visited [ node . first ] = true ; getMinPathSum ( graph , visited , necessary , node . first , dest , currSum + node . second ) ; visited [ node . first ] = false ; } } visited [ src ] = false ; } }
function is_clique ( b ) { for ( let i = 1 ; i < b ; i ++ ) { for ( let j = i + 1 ; j < b ; j ++ ) if ( graph [ store [ i ] ] [ store [ j ] ] == 0 ) { return false ; } } return true ; }
function generateAllBinaryStrings ( n , arr , i ) { if ( i == n ) { printTheArray ( arr , n ) ; return ; } arr [ i ] = 0 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; arr [ i ] = 1 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; }
function uniquePaths ( grid ) { let n = grid . length , m = grid [ 0 ] . length ; let vis = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { vis [ i ] = new Array ( m ) ; for ( let j = 0 ; j < m ; j ++ ) { vis [ i ] [ j ] = false ; } } let x = 0 , y = 0 ; for ( let i = 0 ; i < n ; ++ i ) { for ( let j = 0 ; j < m ; ++ j ) { if ( grid [ i ] [ j ] == 0 ) z_count ++ ; else if ( grid [ i ] [ j ] == 1 ) { x = i ; y = j ; } } } dfs ( x , y , grid , vis , 0 , z_count ) ; return ans ; }
function isPrime ( x ) { var sqroot = Math . sqrt ( x ) ; var flag = true ; if ( x == 1 ) return false ; for ( var i = 2 ; i <= sqroot ; i ++ ) if ( x % i == 0 ) return false ; return true ; }
function minStepsRecur ( height , l , r , h ) { if ( l >= r ) return 0 ; let m = l ; for ( let i = l ; i < r ; i ++ ) if ( height [ i ] < height [ m ] ) m = i ; return Math . min ( r - l , minStepsRecur ( height , l , m , height [ m ] ) + minStepsRecur ( height , m + 1 , r , height [ m ] ) + height [ m ] - h ) ; }
function findFrequency ( arr , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! mp . has ( arr [ i ] ) ) mp . set ( arr [ i ] , 0 ) ; mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } for ( let [ key , value ] of mp . entries ( ) ) { document . write ( "Element▁" + key + "▁occurs▁" + value + "▁times" ) ; } }
function secondary_polygon ( Angle ) { var edges_primary = 360 / Angle ; if ( edges_primary >= 6 ) { var edges_max_secondary = edges_primary / 2 ; document . write ( edges_max_secondary + 3 ) ; } else document . write ( "Not▁Possible" ) ; }
function parallel ( a1 , b1 , c1 , a2 , b2 , c2 ) { if ( ( - ( a1 / b1 ) ) == ( - ( a2 / b2 ) ) ) { document . write ( "Yes" ) ; } else { document . write ( "No" ) ; } }
function No_of_cubes ( N , K ) { let No = 0 ; No = ( N - K + 1 ) ; No = Math . pow ( No , 3 ) ; return No ; }
function updateArray ( x1 , y1 , x2 , y2 ) { for ( let i = x1 ; i < x2 ; i ++ ) { for ( let j = y1 ; j < y2 ; j ++ ) { arr [ i ] [ j ] = true ; } } }
function calcAngle ( h , m ) { if ( h < 0 m < 0 h > 12 m > 60 ) document . write ( "Wrong▁input" ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) m = 0 ; var hour_angle = 0.5 * ( h * 60 + m ) ; var minute_angle = 6 * m ; var angle = Math . abs ( hour_angle - minute_angle ) ; angle = Math . min ( 360 - angle , angle ) ; return angle ; }
function heptacontagonNum ( n ) { return ( 68 * n * n - 66 * n ) / 2 ; }
function octacontagonNum ( n ) { return ( 78 * n * n - 76 * n ) / 2 ; }
function Pentadecagonal_num ( n ) { return ( 13 * n * n - 11 * n ) / 2 ; }
function check ( n , m ) { if ( m % n == 0 ) { document . write ( "YES" ) ; } else { document . write ( "NO" ) ; } return 0 ; }
function dist ( x1 , y1 , x2 , y2 , r ) { document . write ( "The▁shortest▁distance▁" + "between▁a▁point▁and▁a▁circle▁is▁" + ( Math . sqrt ( ( Math . pow ( ( x2 - x1 ) , 2 ) ) + ( Math . pow ( ( y2 - y1 ) , 2 ) ) ) - r ) . toFixed ( 5 ) ) ; }
function ellipse ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; var x = ( 3.14 * l * b ) / 4 ; return x ; }
function squareSide ( a ) { if ( a < 0 ) return - 1 ; var x = ( 0.423 * a ) ; return x ; }
function CubeVolume ( d ) { let Volume ; Volume = ( Math . sqrt ( 3 ) * Math . pow ( d , 3 ) ) / 9 ; return Volume ; }
function cyl ( r , h ) { if ( r < 0 && h < 0 ) return - 1 ; var R = ( 2 * r ) / 3 ; var H = ( 2 * h ) / 3 ; var V = 3.14 * Math . pow ( R , 2 ) * H ; return V ; }
function perimeter ( r ) { return ( ( 3.14 ) * ( r ) ) ; }
function hexadecagonalNum ( n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; }
function intersection ( n ) { return n * ( n - 1 ) ; }
function numberOfWays ( x ) { let dp = Array ( x + 1 ) . fill ( 0 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
function check_and_print ( required_time , given_time ) { if ( required_time < given_time ) document . write ( "Overflow" ) ; else if ( required_time > given_time ) document . write ( "Underflow" ) ; else document . write ( "Filled" ) ; }
function maxArea ( a , b , c , d ) { let semiperimeter = ( a + b + c + d ) / 2 ; return Math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }
function directionOfPoint ( A , B , P ) { B . x -= A . x ; B . y -= A . y ; P . x -= A . x ; P . y -= A . y ; let cross_product = B . x * P . y - B . y * P . x ; if ( cross_product > 0 ) return RIGHT ; if ( cross_product < 0 ) return LEFT ; return ZERO ; }
function areaCube ( a ) { return ( a * a * a ) ; }
function sqDist ( p1 , p2 ) { return ( p1 [ 0 ] - p2 [ 0 ] ) * ( p1 [ 0 ] - p2 [ 0 ] ) + ( p1 [ 1 ] - p2 [ 1 ] ) * ( p1 [ 1 ] - p2 [ 1 ] ) ; }
function isSquare ( p1 , p2 , p3 , p4 ) { if ( d2 == 0 d3 == 0 d4 == 0 ) return false ; if ( d2 == d3 && 2 * d2 == d4 && 2 * distSq ( p2 , p4 ) == distSq ( p2 , p3 ) ) { return true ; } if ( d3 == d4 && 2 * d3 == d2 && 2 * distSq ( p3 , p2 ) == distSq ( p3 , p4 ) ) { return true ; } if ( d2 == d4 && 2 * d2 == d3 && 2 * distSq ( p2 , p3 ) == distSq ( p2 , p4 ) ) { return true ; } return false ; }
function getProduct ( n ) { let product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = Math . floor ( n / 10 ) ; } return product ; }
function lastPositiveElement ( arr ) { let N = arr . length ; if ( N == 1 ) return arr [ 0 ] ; let greatest = - 1 , secondGreatest = - 1 ; for ( let x of arr ) { if ( x >= greatest ) { secondGreatest = greatest ; greatest = x ; } else if ( x >= secondGreatest ) { secondGreatest = x ; } } return greatest - secondGreatest ; }
function countQuadruples ( A , N ) { let ans = 0 ; let freq = new Map ( ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( freq . has ( arr [ i ] ) ) { ans += freq . get ( A [ i ] ) ; } for ( let j = 0 ; j < i ; j ++ ) { for ( let k = 0 ; k < j ; k ++ ) { if ( freq . has ( A [ i ] * A [ j ] * A [ k ] ) ) { freq . set ( freq . get ( A [ i ] * A [ j ] * A [ k ] ) , freq . get ( [ A [ i ] * A [ j ] * A [ k ] ] ) + 1 ) ; } else { freq . set ( A [ i ] * A [ j ] * A [ k ] , 1 ) ; } } } } return ans ; }
function countArrays ( n , k ) { let mod = 1000000007 ; let ans = power ( n , k , mod ) ; return ans ; }
function printInorder ( root ) { if ( root == null ) return ; printInorder ( root . left ) ; document . write ( root . data + "▁" ) ; printInorder ( root . right ) ; }
function countWays ( s , t ) { let n = s . length ; let sum1 = 0 , sum2 = 0 , K = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == "1" ) { sum1 ++ ; } else sum1 -- ; } let m = t . length ; for ( let i = 0 ; i < m ; i ++ ) { if ( t [ i ] == "1" ) { sum2 ++ ; } else if ( t [ i ] == "0" ) { sum2 -- ; } else K ++ ; } let P = Math . abs ( sum1 - sum2 ) ; if ( P > K || ( K - P ) % 2 ) { document . write ( 0 ) ; return ; } document . write ( nCr ( K , ( P + K ) / 2 ) ) ; }
function pathCountDP ( mat , k ) { for ( i = 0 ; i < R ; i ++ ) for ( j = 0 ; j < C ; j ++ ) for ( l = 0 ; l < MAX_K ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; return pathCountDPRecDP ( mat , R - 1 , C - 1 , k ) ; }
function isadjacent ( prev , curr ) { return ( ( curr . charCodeAt ( ) - prev . charCodeAt ( ) ) == 1 ) ; }
function getLen ( mat , s ) { for ( let i = 0 ; i < R ; ++ i ) for ( let j = 0 ; j < C ; ++ j ) dp [ i ] [ j ] = - 1 ; let ans = 0 ; for ( let i = 0 ; i < R ; i ++ ) { for ( let j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == s ) { for ( let k = 0 ; k < 8 ; k ++ ) ans = Math . max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , s ) ) ; } } } return ans ; }
function isSmith ( n ) { let original_no = n ; let pDigitSum = 0 ; for ( let i = 0 ; primes [ i ] <= Math . floor ( n / 2 ) ; i ++ ) { while ( n % primes [ i ] == 0 ) { let p = primes [ i ] ; n = Math . floor ( n / p ) ; while ( p > 0 ) { pDigitSum += ( p % 10 ) ; p = Math . floor ( p / 10 ) ; } } } if ( n != 1 && n != original_no ) { while ( n > 0 ) { pDigitSum = pDigitSum + n % 10 ; n = Math . floor ( n / 10 ) ; } } let sumDigits = 0 ; while ( original_no > 0 ) { sumDigits = sumDigits + original_no % 10 ; original_no = Math . floor ( original_no / 10 ) ; } return ( pDigitSum == sumDigits ) ; }
function smallestPermutation ( arr , N ) { let w = new Array ( 2 * N + 1 ) ; for ( let i = 0 ; i < N ; i ++ ) { w [ arr [ i ] ] = true ; } let S = new Set ( ) ; for ( let i = 1 ; i <= 2 * N ; i ++ ) { if ( ! w [ i ] ) S . add ( i ) ; } let found = true ; let P = [ ] ; let p = [ 4 , 5 , 1 , 2 , 3 , 6 ] ; for ( let i = 0 ; i < N ; i ++ ) { if ( S . has ( arr [ i ] ) ) { found = false ; break ; } P . push ( arr [ i ] ) ; P . push ( arr [ i ] ) ; S . delete ( arr [ i ] ) ; } if ( ! found ) { document . write ( "-1" ) ; } else { for ( let i = 0 ; i < 2 * N ; i ++ ) document . write ( p [ i ] + "▁" ) ; } }
function findlcm ( arr , n ) { let ans = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { ans = ( ( ( arr [ i ] * ans ) ) / ( gcd ( arr [ i ] , ans ) ) ) ; } return ans ; }
function findLast ( mat ) { let m = mat . length ; let n = mat [ 0 ] . length ; let rows = new Set ( ) ; let cols = new Set ( ) ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] ) { rows . add ( i ) ; cols . add ( j ) ; } } } let avRows = m - rows . size ; let avCols = n - cols . size ; let choices = Math . min ( avRows , avCols ) ; if ( choices & 1 ) document . write ( "P1" ) else document . write ( "P2" ) }
function nearestPowerDiff ( arr , N , a , b ) { for ( let i = 0 ; i < N ; i ++ ) { let log_a = Math . floor ( Math . log ( arr [ i ] ) / Math . log ( a ) ) ; let A = Math . floor ( Math . pow ( a , log_a ) ) ; let B = Math . floor ( Math . pow ( a , log_a + 1 ) ) ; if ( ( arr [ i ] - A ) < ( B - arr [ i ] ) ) log_a = A ; else log_a = B ; let log_b = Math . floor ( Math . log ( arr [ i ] ) / Math . log ( b ) ) ; A = Math . floor ( Math . pow ( b , log_b ) ) ; B = Math . floor ( Math . pow ( b , log_b + 1 ) ) ; if ( ( arr [ i ] - A ) < ( B - arr [ i ] ) ) log_b = A ; else log_b = B ; arr [ i ] = Math . abs ( log_a - log_b ) ; } printArray ( arr , N ) ; }
function checkEvenPower ( N ) { if ( ( N & ( N - 1 ) ) != 0 ) return false ; N = N & 0x55555555 ; return ( N > 0 ) ; }
function distinct ( arr , n ) { var mpp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { mpp . set ( arr [ i ] , 1 ) ; } return mpp . size ; }
function power ( x , y ) { let res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; }
function isNonDeficient ( n ) { let sum = 0 ; for ( let i = 1 ; i <= Math . floor ( Math . sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( Math . floor ( n / i ) == i ) { sum = sum + i ; } else { sum = sum + i ; sum = sum + Math . floor ( n / i ) ; } } } return sum >= 2 * n ; }
function lastElement ( arr , n ) { let sum = 0 ; let multiplier = n % 2 == 0 ? - 1 : 1 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * multiplier ; multiplier = multiplier * ( n - 1 - i ) / ( i + 1 ) * ( - 1 ) ; } return sum ; }
