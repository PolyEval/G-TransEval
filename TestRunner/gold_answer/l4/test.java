double distinctOddRatio ( List < Integer > numbers ) { int distinctCount = ( int ) numbers . stream ( ) . distinct ( ) . count ( ) ; int distinctOddCount = ( int ) numbers . stream ( ) . distinct ( ) . filter ( n -> n % 2 == 1 ) . count ( ) ; return ( double ) distinctOddCount / distinctCount ; } 
int compareSum ( List < Integer > numbers , List < String > words ) { int intSum = numbers . stream ( ) . mapToInt ( n -> n ) . sum ( ) ; int wordLengthSum = words . stream ( ) . mapToInt ( String :: length ) . sum ( ) ; if ( intSum < wordLengthSum ) { return - 1 ; } if ( intSum > wordLengthSum ) { return 1 ; } return 0 ; } 
boolean allLongerThan ( List < String > shortWords , List < String > longWords ) { int maxOfShort = shortWords . stream ( ) . mapToInt ( String :: length ) . max ( ) . getAsInt ( ) ; int minOfLong = longWords . stream ( ) . mapToInt ( String :: length ) . min ( ) . getAsInt ( ) ; return minOfLong > maxOfShort ; } 
int compareOddEvenRange ( List < Integer > numbers ) { int rangeOdd = numbers . stream ( ) . filter ( n -> n % 2 == 1 ) . mapToInt ( n -> n ) . max ( ) . getAsInt ( ) - numbers . stream ( ) . filter ( n -> n % 2 == 1 ) . mapToInt ( n -> n ) . min ( ) . getAsInt ( ) ; int rangeEven = numbers . stream ( ) . filter ( n -> n % 2 == 0 ) . mapToInt ( n -> n ) . max ( ) . getAsInt ( ) - numbers . stream ( ) . filter ( n -> n % 2 == 0 ) . mapToInt ( n -> n ) . min ( ) . getAsInt ( ) ; if ( rangeOdd < rangeEven ) { return - 1 ; } if ( rangeOdd > rangeEven ) { return 1 ; } return 0 ; } 
double averageDistinctLength ( List < String > words ) { double averageLen = words . stream ( ) . distinct ( ) . mapToInt ( String :: length ) . average ( ) . getAsDouble ( ) ; return averageLen ; } 
int withDrawBalance ( int start , List < Integer > withdrawals ) { int end = withdrawals . stream ( ) . reduce ( start , ( balance , nextWithdrawal ) -> nextWithdrawal <= balance ? balance - nextWithdrawal : balance ) ; return end ; } 
String firstShortAndStartsWithO ( List < String > words ) { String matchedElement = words . stream ( ) . filter ( w -> w . length ( ) < 5 ) . filter ( w -> w . charAt ( 0 ) == 'o' ) . findFirst ( ) . orElse ( "" ) ; return matchedElement ; } 
int bigNumberAtIndex ( List < Integer > numbers , int index ) { int targetNum = numbers . stream ( ) . filter ( n -> n > 5 ) . skip ( index ) . findFirst ( ) . get ( ) ; return targetNum ; } 
boolean containsSquareInRange ( int rangeStart , int rangeLength ) { boolean containsSquare = IntStream . range ( rangeStart , rangeStart + rangeLength ) . anyMatch ( n -> Math . pow ( ( int ) Math . sqrt ( n ) , 2 ) == n ) ; return containsSquare ; } 
Map < Integer , List < Integer > > groupNumbersByMod ( List < Integer > numbers , int mod ) { var numberGroups = numbers . stream ( ) . collect ( Collectors . groupingBy ( n -> n % mod ) ) ; return numberGroups ; } 
Map < Character , List < String > > groupWordsByFirstChar ( List < String > words ) { var wordGroups = words . stream ( ) . collect ( Collectors . groupingBy ( w -> w . charAt ( 0 ) ) ) ; return wordGroups ; } 
List < String > orderByLengthAndDescending ( List < String > words ) { var sortedWords = words . stream ( ) . sorted ( Comparator . comparingInt ( String :: length ) . thenComparing ( Comparator . reverseOrder ( ) ) ) . collect ( Collectors . toList ( ) ) ; return sortedWords ; } 
List < String > orderFirstCharDescendingReverse ( List < String > words ) { var sortedWords = words . stream ( ) . sorted ( Comparator . comparing ( ( String w ) -> w . charAt ( 0 ) ) . reversed ( ) . thenComparing ( Comparator . naturalOrder ( ) ) ) . collect ( Collectors . toList ( ) ) ; Collections . reverse ( sortedWords ) ; return sortedWords ; } 
List < Integer > getSubListOfNegative ( List < Integer > numbers , int start , int length ) { List < Integer > subList = numbers . stream ( ) . skip ( start ) . filter ( n -> n < 0 ) . limit ( length ) . collect ( Collectors . toList ( ) ) ; return subList ; } 
List < Integer > getPositiveSequence ( List < Integer > numbers ) { List < Integer > subSequence = numbers . stream ( ) . dropWhile ( n -> n <= 0 ) . takeWhile ( n -> n >= 0 ) . collect ( Collectors . toList ( ) ) ; return subSequence ; } 
List < Integer > getLargerThanIndexSequence ( List < Integer > numbers ) { List < Integer > subSequence = IntStream . range ( 0 , numbers . size ( ) ) . dropWhile ( i -> numbers . get ( i ) < i ) . takeWhile ( i -> numbers . get ( i ) >= i ) . mapToObj ( i -> numbers . get ( i ) ) . collect ( Collectors . toList ( ) ) ; return subSequence ; } 
List < String > rearrangeWordByIndexes ( List < String > words , List < Integer > indexes ) { List < Integer > newIndexes = indexes . stream ( ) . filter ( n -> n >= words . size ( ) ) . map ( n -> n % words . size ( ) ) . toList ( ) ; List < String > newWords = newIndexes . stream ( ) . map ( n -> words . get ( n ) ) . toList ( ) ; return newWords ; } 
List < List < String > > getWordsUpperLower ( List < String > words ) { var upperLowerWords = words . stream ( ) . map ( w -> Arrays . asList ( w . toUpperCase ( ) , w . toLowerCase ( ) ) ) . collect ( Collectors . toList ( ) ) ; return upperLowerWords ; } 
List < Boolean > selectIfInPlace ( List < Integer > numbers ) { List < Boolean > numsInPlace = IntStream . range ( 0 , numbers . size ( ) ) . mapToObj ( index -> numbers . get ( index ) == index ) . collect ( Collectors . toList ( ) ) ; return numsInPlace ; } 
List < List < Integer > > selectPairs ( List < Integer > numbersA , List < Integer > numbersB ) { List < List < Integer > > pairs = numbersA . stream ( ) . flatMap ( a -> numbersB . stream ( ) . filter ( b -> a < b ) . map ( b -> Arrays . asList ( a , b ) ) ) . collect ( Collectors . toList ( ) ) ; return pairs ; } 
List < String > stringCrossJoin ( List < String > endWords , List < String > beginWords ) { List < String > crossStrings = beginWords . stream ( ) . flatMap ( b -> endWords . stream ( ) . filter ( e -> b . charAt ( 0 ) == e . charAt ( e . length ( ) - 1 ) ) . map ( e -> e + " " + b ) ) . collect ( Collectors . toList ( ) ) ; return crossStrings ; } 
int elementsContainSubword ( List < String > words , String subword ) { if ( words . stream ( ) . limit ( 5 ) . allMatch ( w -> w . contains ( subword ) ) ) { return 1 ; } else if ( words . stream ( ) . limit ( 5 ) . anyMatch ( w -> w . contains ( subword ) ) ) { return 0 ; } else { return - 1 ; } } 
List < Integer > ConcatLargeNumbers ( List < Integer > numbersA , List < Integer > numbersB , int flag ) { List < Integer > allNumbers = Stream . concat ( numbersA . stream ( ) . filter ( n -> n > flag ) , numbersB . stream ( ) . filter ( n -> n > flag ) ) . collect ( Collectors . toList ( ) ) ; return allNumbers ; } 
int DotProduct ( List < Integer > vectorA , List < Integer > vectorB ) { int dotProduct = IntStream . range ( 0 , vectorA . size ( ) ) . map ( i -> vectorA . get ( i ) * vectorB . get ( i ) ) . sum ( ) ; return dotProduct ; } 
List < Integer > SetDifference ( List < Integer > setA , List < Integer > setB ) { List < Integer > difference = new ArrayList < > ( setA ) ; difference . addAll ( setB ) ; List < Integer > intersection = new ArrayList < > ( setA ) ; intersection . retainAll ( setB ) ; difference . removeAll ( intersection ) ; Collections . sort ( difference ) ; return difference ; } 
