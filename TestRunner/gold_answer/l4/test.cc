double DistinctOddRatio ( vector < int > numbers ) { unordered_set < int > distinct_numbers ( numbers . begin ( ) , numbers . end ( ) ) ; int distinct_count = ranges :: distance ( distinct_numbers ) ; int distinct_odd_count = ranges :: distance ( distinct_numbers | views :: filter ( [ ] ( int n ) { return n % 2 == 1 ; } ) ) ; return ( double ) distinct_odd_count / distinct_count ; } 
int CompareSum ( vector < int > numbers , vector < string > words ) { int int_sum = reduce ( numbers . begin ( ) , numbers . end ( ) ) ; auto tmp = words | views :: transform ( [ ] ( string & w ) { return w . size ( ) ; } ) ; int word_length_sum = reduce ( tmp . begin ( ) , tmp . end ( ) ) ; if ( int_sum < word_length_sum ) { return -1 ; } if ( int_sum > word_length_sum ) { return 1 ; } return 0 ; } 
bool AllLongerThan ( vector < string > short_words , vector < string > long_words ) { int max_of_short = ranges :: max ( short_words | views :: transform ( [ ] ( string & w ) { return w . size ( ) ; } ) ) ; int min_of_long = ranges :: min ( long_words | views :: transform ( [ ] ( string & w ) { return w . size ( ) ; } ) ) ; return min_of_long > max_of_short ; } 
int CompareOddEvenRange ( vector < int > numbers ) { int range_odd = ranges :: max ( numbers | views :: filter ( [ ] ( int n ) { return n % 2 == 1 ; } ) ) - ranges :: min ( numbers | views :: filter ( [ ] ( int n ) { return n % 2 == 1 ; } ) ) ; int range_even = ranges :: max ( numbers | views :: filter ( [ ] ( int n ) { return n % 2 == 0 ; } ) ) - ranges :: min ( numbers | views :: filter ( [ ] ( int n ) { return n % 2 == 0 ; } ) ) ; if ( range_odd < range_even ) { return -1 ; } if ( range_odd > range_even ) { return 1 ; } return 0 ; } 
double AverageDistinctLength ( vector < string > words ) { unordered_set < string > s ( words . begin ( ) , words . end ( ) ) ; vector < string > distinct_words ( s . begin ( ) , s . end ( ) ) ; auto distinct_size = distinct_words | views :: transform ( [ ] ( string & w ) { return w . size ( ) ; } ) ; double average_len = ! distinct_size . empty ( ) ? ( double ) reduce ( distinct_size . begin ( ) , distinct_size . end ( ) ) / ranges :: distance ( distinct_size ) : 0 ; return average_len ; } 
int WithDrawBalance ( int start , vector < int > withdrawals ) { int end = accumulate ( withdrawals . begin ( ) , withdrawals . end ( ) , start , [ ] ( int balance , int next_withdrawal ) { return next_withdrawal <= balance ? balance - next_withdrawal : balance ; } ) ; return end ; } 
string FirstShortAndStartsWithO ( vector < string > words ) { auto matched_view = words | views :: filter ( [ ] ( const string & w ) { return w . size ( ) < 5 ; } ) | views :: filter ( [ ] ( const string & w ) { return w [ 0 ] == 'o' ; } ) | views :: take ( 1 ) ; string matched_element = matched_view . empty ( ) ? "" : matched_view . front ( ) ; return matched_element ; } 
int BigNumberAtIndex ( vector < int > numbers , int index ) { auto matched_view = numbers | views :: filter ( [ ] ( int n ) { return n > 5 ; } ) | views :: drop ( index ) ; int target_num = matched_view . front ( ) ; return target_num ; } 
bool ContainsSquareInRange ( int range_start , int range_length ) { bool contains_square = ranges :: any_of ( views :: iota ( range_start , range_start + range_length ) , [ ] ( int n ) { return pow ( ( int ) sqrt ( n ) , 2 ) == n ; } ) ; return contains_square ; } 
unordered_map < int , vector < int > > GroupNumbersByMod ( vector < int > numbers , int mod ) { unordered_map < int , vector < int > > number_groups ; for ( int n : numbers ) { int key = n % mod ; number_groups [ key ] . push_back ( n ) ; } return number_groups ; } 
unordered_map < char , vector < string > > GroupWordsByFirstChar ( vector < string > words ) { unordered_map < char , vector < string > > word_groups ; for ( string & word : words ) { word_groups [ word [ 0 ] ] . push_back ( word ) ; } return word_groups ; } 
vector < string > OrderByLengthAndDescending ( vector < string > words ) { vector < string > sorted_words = words ; sort ( sorted_words . begin ( ) , sorted_words . end ( ) , [ ] ( string & a , string & b ) { if ( a . length ( ) == b . length ( ) ) { return a > b ; } return a . length ( ) < b . length ( ) ; } ) ; return sorted_words ; } 
vector < string > OrderFirstCharDescendingReverse ( vector < string > words ) { vector < string > sorted_words = words ; sort ( sorted_words . begin ( ) , sorted_words . end ( ) , [ ] ( string & a , string & b ) { if ( a [ 0 ] == b [ 0 ] ) { return a < b ; } return a [ 0 ] > b [ 0 ] ; } ) ; reverse ( sorted_words . begin ( ) , sorted_words . end ( ) ) ; return sorted_words ; } 
vector < int > GetSubListOfNegative ( vector < int > numbers , int start , int length ) { auto matched_view = numbers | views :: drop ( start ) | views :: filter ( [ ] ( int n ) { return n < 0 ; } ) | views :: take ( length ) ; vector < int > sub_list ; ranges :: copy ( matched_view , back_inserter ( sub_list ) ) ; return sub_list ; } 
vector < int > GetPositiveSequence ( vector < int > numbers ) { auto matched_view = numbers | views :: drop_while ( [ ] ( int n ) { return n <= 0 ; } ) | views :: take_while ( [ ] ( int n ) { return n >= 0 ; } ) ; vector < int > sub_sequence ; ranges :: copy ( matched_view , back_inserter ( sub_sequence ) ) ; return sub_sequence ; } 
vector < int > GetLargerThanIndexSequence ( vector < int > numbers ) { auto matched_view = views :: iota ( 0 , ( int ) numbers . size ( ) ) | views :: drop_while ( [ & numbers ] ( int n ) { return numbers [ n ] < n ; } ) | views :: take_while ( [ & numbers ] ( int n ) { return numbers [ n ] > n ; } ) | views :: transform ( [ & numbers ] ( int n ) { return numbers [ n ] ; } ) ; vector < int > sub_sequence ; ranges :: copy ( matched_view , back_inserter ( sub_sequence ) ) ; return sub_sequence ; } 
vector < string > RearrangeWordByIndexes ( vector < string > words , vector < int > indexes ) { auto new_indexes = indexes | views :: filter ( [ & words ] ( int n ) { return n >= words . size ( ) ; } ) | views :: transform ( [ & words ] ( int n ) { return n % words . size ( ) ; } ) ; auto matched_view = new_indexes | views :: transform ( [ & words ] ( int n ) { return words [ n ] ; } ) ; vector < string > new_words ; ranges :: copy ( matched_view , back_inserter ( new_words ) ) ; return new_words ; } 
vector < vector < string > > GetWordsUpperLower ( vector < string > words ) { auto matched_view = words | views :: transform ( [ ] ( string & w ) { string upper = w ; string lower = w ; ranges :: transform ( upper . begin ( ) , upper . end ( ) , upper . begin ( ) , :: toupper ) ; ranges :: transform ( lower . begin ( ) , lower . end ( ) , lower . begin ( ) , :: tolower ) ; return vector < string > { upper , lower } ; } ) ; vector < vector < string > > upper_lower_words ; ranges :: copy ( matched_view , back_inserter ( upper_lower_words ) ) ; return upper_lower_words ; } 
vector < bool > SelectIfInPlace ( vector < int > numbers ) { auto matched_view = views :: iota ( 0 , ( int ) numbers . size ( ) ) | views :: transform ( [ & numbers ] ( int n ) { return numbers [ n ] == n ; } ) ; vector < bool > nums_in_place ; ranges :: copy ( matched_view , back_inserter ( nums_in_place ) ) ; return nums_in_place ; } 
vector < vector < int > > SelectPairs ( vector < int > numbers_a , vector < int > numbers_b ) { auto matched_view = numbers_a | views :: transform ( [ & numbers_b ] ( int a ) { return numbers_b | views :: filter ( [ a ] ( auto b ) { return a < b ; } ) | views :: transform ( [ a ] ( auto b ) { return vector < int > { a , b } ; } ) ; } ) | views :: join ; vector < vector < int > > pairs ; ranges :: copy ( matched_view , back_inserter ( pairs ) ) ; return pairs ; } 
vector < string > StringCrossJoin ( vector < string > end_words , vector < string > begin_words ) { auto matched_view = begin_words | views :: transform ( [ & end_words ] ( string & b ) { return end_words | views :: filter ( [ b ] ( string & e ) { return b [ 0 ] == e [ e . length ( ) - 1 ] ; } ) | views :: transform ( [ b ] ( auto e ) { return e + " " + b ; } ) ; } ) | views :: join ; vector < string > cross_strings ; ranges :: copy ( matched_view , back_inserter ( cross_strings ) ) ; return cross_strings ; } 
int ElementsContainSubword ( vector < string > words , string subword ) { if ( ranges :: all_of ( words | views :: take ( 5 ) , [ & subword ] ( string & w ) { return w . find ( subword ) != string :: npos ; } ) ) return 1 ; if ( ranges :: any_of ( words | views :: take ( 5 ) , [ & subword ] ( string & w ) { return w . find ( subword ) != string :: npos ; } ) ) return 0 ; return -1 ; } 
vector < int > ConcatLargeNumbers ( vector < int > numbers_a , vector < int > numbers_b , int flag ) { auto large_numbers_a = numbers_a | views :: filter ( [ flag ] ( int n ) { return n > flag ; } ) ; auto large_numbers_b = numbers_b | views :: filter ( [ flag ] ( int n ) { return n > flag ; } ) ; std :: vector < int > all_numbers ; ranges :: copy ( large_numbers_a , back_inserter ( all_numbers ) ) ; ranges :: copy ( large_numbers_b , back_inserter ( all_numbers ) ) ; return all_numbers ; } 
int DotProduct ( vector < int > vector_a , vector < int > vector_b ) { int dot_product = inner_product ( vector_a . begin ( ) , vector_a . end ( ) , vector_b . begin ( ) , 0 ) ; return dot_product ; } 
vector < int > SetDifference ( vector < int > set_a , vector < int > set_b ) { vector < int > difference ; ranges :: sort ( set_a ) ; ranges :: sort ( set_b ) ; set_symmetric_difference ( set_a . begin ( ) , set_a . end ( ) , set_b . begin ( ) , set_b . end ( ) , back_inserter ( difference ) ) ; return difference ; } 
