function distinctOddRatio ( numbers ) { let distinctCount = new Set ( numbers ) . size ; let distinctOddCount = [ ... new Set ( numbers ) ] . filter ( n => n % 2 === 1 ) . length ; return distinctOddCount / distinctCount ; } 
function compareSum ( numbers , words ) { let intSum = numbers . reduce ( ( acc , n ) => acc + n ) ; let wordLengthSum = words . reduce ( ( acc , w ) => acc + w . length , 0 ) ; if ( intSum < wordLengthSum ) { return - 1 ; } else if ( intSum > wordLengthSum ) { return 1 ; } else { return 0 ; } } 
function allLongerThan ( shortWords , longWords ) { let maxOfShort = Math . max ( ... shortWords . map ( w => w . length ) ) ; let minOfLong = Math . min ( ... longWords . map ( w => w . length ) ) ; return minOfLong > maxOfShort ; } 
function compareOddEvenRange ( numbers ) { let rangeOdd = Math . max ( ... numbers . filter ( n => n % 2 === 1 ) ) - Math . min ( ... numbers . filter ( n => n % 2 === 1 ) ) ; let rangeEven = Math . max ( ... numbers . filter ( n => n % 2 === 0 ) ) - Math . min ( ... numbers . filter ( n => n % 2 === 0 ) ) ; if ( rangeOdd < rangeEven ) { return - 1 ; } if ( rangeOdd > rangeEven ) { return 1 ; } return 0 ; } 
function averageDistinctLength ( words ) { let distinctWords = [ ... new Set ( words ) ] ; let averageLen = distinctWords ? distinctWords . reduce ( ( acc , w ) => acc + w . length , 0 ) / distinctWords . length : 0 ; return averageLen ; } 
function withdrawBalance ( start , withdrawals ) { let end = withdrawals . reduce ( ( balance , nextWithdrawal ) => { return nextWithdrawal <= balance ? balance - nextWithdrawal : balance ; } , start ) ; return end ; } 
function firstShortAndStartsWithO ( words ) { let matchedElement = words . filter ( w => w . length < 5 ) . filter ( w => w . charAt ( 0 ) === 'o' ) [ 0 ] ?? "" ; return matchedElement ; } 
function bigNumberAtIndex ( numbers , index ) { let targetNum = numbers . filter ( n => n > 5 ) [ index ] ; return targetNum ; } 
function containsSquareInRange ( rangeStart , rangeLength ) { let containsSquare = [ ... Array ( rangeStart + rangeLength ) . keys ( ) ] . slice ( rangeStart ) . some ( n => Math . pow ( Math . trunc ( Math . sqrt ( n ) ) , 2 ) === n ) ; return containsSquare ; } 
function groupNumbersByMod ( numbers , mod ) { let numberGroups = numbers . reduce ( ( acc , n ) => { let key = n % mod ; if ( acc . has ( key ) ) { acc . get ( key ) . push ( n ) } else { acc . set ( key , [ n ] ) } return acc ; } , new Map ( ) ) ; return numberGroups ; } 
function groupNumbersByFirstChar ( words ) { let wordsGroups = words . reduce ( ( acc , w ) => { let key = w [ 0 ] ; if ( acc . has ( key ) ) { acc . get ( key ) . push ( w ) } else { acc . set ( key , [ w ] ) } return acc ; } , new Map ( ) ) ; return wordsGroups ; } 
function orderByLengthAndDescending ( words ) { let sortedWords = words . sort ( ( a , b ) => a . length - b . length !== 0 ? a . length - b . length : b . localeCompare ( a ) ) ; return sortedWords ; } 
function orderFirstCharDescendingReverse ( words ) { let sortedWords = words . sort ( ( a , b ) => b . charCodeAt ( 0 ) - a . charCodeAt ( 0 ) !== 0 ? b . charCodeAt ( 0 ) - a . charCodeAt ( 0 ) : a . localeCompare ( b ) ) . reverse ( ) ; return sortedWords ; } 
function getSubListOfNegative ( numbers , start , length ) { let subList = numbers . slice ( start ) . filter ( n => n < 0 ) . slice ( 0 , length ) ; return subList ; } 
function getPositiveSequence ( numbers ) { let subSequence = [ ] ; for ( let i = 0 ; i < numbers . length ; i ++ ) { if ( numbers [ i ] <= 0 ) { continue } subSequence = numbers . slice ( i ) ; break ; } for ( let i = 0 ; i < subSequence . length ; i ++ ) { if ( subSequence [ i ] > 0 ) { continue } subSequence = subSequence . slice ( 0 , i ) ; break ; } return subSequence ; } 
function getLargerThanIndexSequence ( numbers ) { let subSequence = numbers . map ( ( n , index ) => [ n , index ] ) ; for ( let i = 0 ; i < subSequence . length ; i ++ ) { if ( subSequence [ i ] [ 0 ] < subSequence [ i ] [ 1 ]  ) { continue ; } subSequence = subSequence . slice ( i ) ; break ; } for ( let i = 0 ; i < subSequence . length ; i ++ ) { if ( subSequence [ i ] [ 0 ] >= subSequence [ i ] [ 1 ]  ) { continue ; } subSequence = subSequence . slice ( 0 , i ) ; } subSequence = subSequence . map ( x => x [ 0 ] ) ; return subSequence ; }
function rearrangeWordByIndexes ( words , indexes ) { let newIndexes = indexes . filter ( n => n >= words . length ) . map ( n => n % words . length ) ; let newWords = newIndexes . map ( n => words [ n ] ) ; return newWords ; } 
function getWordsUpperLower ( words ) { let upperLowerWords = words . map ( w => [ w . toUpperCase ( ) , w . toLowerCase ( ) ] ) ; return upperLowerWords ; } 
function selectIfInPlace ( numbers ) { let numsInPlace = numbers . map ( ( num , index ) => num === index ) ; return numsInPlace ; } 
function selectPairs ( numbersA , numbersB ) { let pairs = numbersA . flatMap ( a => numbersB . filter ( b => a < b ) . map ( b => [ a , b ] ) ) ; return pairs ; } 
function stringCrossJoin ( endWords , beginWords ) { let crossStrings = beginWords . flatMap ( b => endWords . filter ( e => b [ 0 ] === e . slice ( - 1 ) ) . map ( e => e + ' ' + b ) ) ; return crossStrings ; } 
function elementsContainSubword ( words , subword ) { if ( words . slice ( 0 , 5 ) . every ( w => w . includes ( subword ) ) ) { return 1 ; } else if ( words . slice ( 0 , 5 ) . some ( w => w . includes ( subword ) ) ) { return 0 ; } else { return - 1 ; } } 
function concatLargeNumbers ( numbersA , numbersB , flag ) { let allNumbers = [ ... numbersA . filter ( n => n > flag ) , ... numbersB . filter ( n => n > flag ) ] ; return allNumbers ; } 
function dotProduct ( vectorA , vectorB ) { let dotProduct = vectorA . reduce ( ( acc , val , i ) => acc + val * vectorB [ i ] , 0 ) ; return dotProduct ; } 
function setDifference ( setA , setB ) { let difference = [ ... new Set ( [ ... setA , ... setB ] ) ] . filter ( x => ! setA . includes ( x ) || ! setB . includes ( x ) ) ; difference . sort ( ( a , b ) => a - b ) ; return difference ; } 