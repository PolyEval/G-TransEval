def distinct_odd_ratio ( numbers ) : NEW_LINE INDENT distinct_count = len ( set ( numbers ) ) NEW_LINE distinct_odd_count = len ( [ n for n in set ( numbers ) if n % 2 == 1 ] ) NEW_LINE return distinct_odd_count / distinct_count NEW_LINE DEDENT 
def compare_sum ( numbers , words ) : NEW_LINE INDENT int_sum = sum ( numbers ) NEW_LINE word_length_sum = sum ( [ len ( word ) for word in words ] ) NEW_LINE if int_sum < word_length_sum : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif int_sum > word_length_sum : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT 
def all_longer_than ( short_words , long_words ) : NEW_LINE INDENT max_of_short = max ( [ len ( w ) for w in short_words ] ) NEW_LINE min_of_long = min ( [ len ( w ) for w in long_words ] ) NEW_LINE return min_of_long > max_of_short NEW_LINE DEDENT 
def compare_odd_even_range ( numbers ) : NEW_LINE INDENT range_odd = max ( [ n for n in numbers if n % 2 == 1 ] ) - min ( [ n for n in numbers if n % 2 == 1 ] ) NEW_LINE range_even = max ( [ n for n in numbers if n % 2 == 0 ] ) - min ( [ n for n in numbers if n % 2 == 0 ] ) NEW_LINE if range_odd < range_even : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if range_odd > range_even : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT 
def average_distinct_length ( words ) : NEW_LINE INDENT distinct_words = set ( words ) NEW_LINE average_len = sum ( [ len ( w ) for w in distinct_words ] ) / len ( distinct_words ) if distinct_words else 0 NEW_LINE return average_len NEW_LINE DEDENT 
def withdraw_balance ( start , withdrawals ) : NEW_LINE INDENT end = functools . reduce ( lambda balance , nextWithdrawal : balance - nextWithdrawal if nextWithdrawal <= balance else balance , withdrawals , start ) NEW_LINE return end NEW_LINE DEDENT 
def first_short_and_starts_with_o ( words ) : NEW_LINE INDENT matched_element = next ( iter ( [ w for w in [ w1 for w1 in words if len ( w1 ) < 5 ] if w . startswith ( 'o' ) ] ) , "" ) NEW_LINE return matched_element NEW_LINE DEDENT 
def big_number_at_index ( numbers , index ) : NEW_LINE INDENT target_num = [ n for n in numbers if n > 5 ] [ index ] NEW_LINE return target_num NEW_LINE DEDENT 
def contains_square_in_range ( range_start , range_length ) : NEW_LINE INDENT contains_square = any ( [ int ( math . sqrt ( n ) ) ** 2 == n for n in range ( range_start , range_start + range_length ) ] ) NEW_LINE return contains_square NEW_LINE DEDENT 
def group_numbers_by_mod ( numbers , mod ) : NEW_LINE INDENT number_groups = { } NEW_LINE for k , g in itertools . groupby ( numbers , lambda n : n % mod ) : NEW_LINE INDENT number_groups [ k ] = number_groups . get ( k , [ ] ) + list ( g ) NEW_LINE DEDENT return number_groups NEW_LINE DEDENT 
def group_words_by_first_char ( words ) : NEW_LINE INDENT word_groups = { } NEW_LINE for k , g in itertools . groupby ( words , lambda w : w [ 0 ] ) : NEW_LINE INDENT word_groups [ k ] = word_groups . get ( k , [ ] ) + list ( g ) NEW_LINE DEDENT return word_groups NEW_LINE DEDENT 
def order_by_length_and_descending ( words ) : NEW_LINE INDENT sorted_words = sorted ( sorted ( words , key = lambda w : w , reverse = True ) , key = lambda w : len ( w ) ) NEW_LINE return sorted_words NEW_LINE DEDENT 
def order_first_char_descending_reverse ( words ) : NEW_LINE INDENT sorted_words = sorted ( words , key = lambda w : ( - ord ( w [ 0 ] ) , w ) , reverse = True ) NEW_LINE return sorted_words NEW_LINE DEDENT 
def get_sublist_of_negative ( numbers , start , length ) : NEW_LINE INDENT sub_list = [ n for n in numbers [ start : ] if n < 0 ] [ : length ] NEW_LINE return sub_list NEW_LINE DEDENT 
def get_positive_sequence ( numbers ) : NEW_LINE INDENT sub_sequence = list ( itertools . takewhile ( lambda n : n > 0 , itertools . dropwhile ( lambda n : n <= 0 , numbers ) ) ) NEW_LINE return sub_sequence NEW_LINE DEDENT 
def get_larger_than_index_sequence ( numbers ) : NEW_LINE INDENT sub_sequence = [ x [ 1 ] for x in itertools . takewhile ( lambda x : x [ 1 ] >= x [ 0 ] , itertools . dropwhile ( lambda x : x [ 1 ] < x [ 0 ] , enumerate ( numbers ) ) ) ] NEW_LINE return sub_sequence NEW_LINE DEDENT 
def rearrange_word_by_indexes ( words , indexes ) : NEW_LINE INDENT new_indexes = [ n % len ( words ) for n in indexes if n >= len ( words ) ] NEW_LINE new_words = [ words [ n ] for n in new_indexes ] NEW_LINE return new_words NEW_LINE DEDENT 
def get_words_upper_lower ( words ) : NEW_LINE INDENT upper_lower_words = [ [ w . upper ( ) , w . lower ( ) ] for w in words ] NEW_LINE return upper_lower_words NEW_LINE DEDENT 
def select_if_in_place ( numbers ) : NEW_LINE INDENT nums_in_place = [ num == index for index , num in enumerate ( numbers ) ] NEW_LINE return nums_in_place NEW_LINE DEDENT 
def select_pairs ( numbers_a , numbers_b ) : NEW_LINE INDENT pairs = [ [ a , b ] for a in numbers_a for b in numbers_b if a < b ] NEW_LINE return pairs NEW_LINE DEDENT 
def string_cross_join ( end_words , begin_words ) : NEW_LINE INDENT cross_strings = [ e + ' ' + b for b in begin_words for e in end_words if b [ 0 ] == e [ - 1 ] ] NEW_LINE return cross_strings NEW_LINE DEDENT 
def elements_contain_subword ( words , subword ) : NEW_LINE INDENT if all ( subword in w for w in words [ : 5 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif any ( subword in w for w in words [ : 5 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT 
def concat_large_numbers ( numbers_a , numbers_b , flag ) : NEW_LINE INDENT all_numbers = [ n for n in numbers_a if n > flag ] + [ n for n in numbers_b if n > flag ] NEW_LINE return all_numbers NEW_LINE DEDENT 
def dot_product ( vector_a , vector_b ) : NEW_LINE INDENT dot_product = sum ( [ a * b for a , b in zip ( vector_a , vector_b ) ] ) NEW_LINE return dot_product NEW_LINE DEDENT 
def set_difference ( set_a , set_b ) : NEW_LINE INDENT difference = sorted ( list ( set ( set_a ) . symmetric_difference ( set ( set_b ) ) ) ) NEW_LINE return difference NEW_LINE DEDENT 