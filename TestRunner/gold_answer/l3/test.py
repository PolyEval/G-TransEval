def separate_paren_groups ( paren_string ) : NEW_LINE INDENT all_parens = [ ] NEW_LINE current_paren = [ ] NEW_LINE current_depth = 0 NEW_LINE for c in paren_string : NEW_LINE INDENT if c == "(" : NEW_LINE INDENT current_depth += 1 NEW_LINE current_paren . append ( c ) NEW_LINE DEDENT elif c == ")" : NEW_LINE INDENT current_depth -= 1 NEW_LINE current_paren . append ( c ) NEW_LINE if current_depth == 0 : NEW_LINE INDENT all_parens . append ( "" . join ( current_paren ) ) NEW_LINE current_paren . clear ( ) NEW_LINE DEDENT DEDENT DEDENT return all_parens NEW_LINE DEDENT 
def parse_nested_parens ( paren_string ) : NEW_LINE INDENT all_levels = [ ] NEW_LINE level = 0 NEW_LINE max_level = 0 NEW_LINE for i in range ( len ( paren_string ) ) : NEW_LINE INDENT chr = paren_string [ i ] NEW_LINE if chr == "(" : NEW_LINE INDENT level += 1 NEW_LINE if level > max_level : NEW_LINE INDENT max_level = level NEW_LINE DEDENT DEDENT if chr == ")" : NEW_LINE INDENT level -= 1 NEW_LINE if level == 0 : NEW_LINE INDENT all_levels . append ( max_level ) NEW_LINE max_level = 0 NEW_LINE DEDENT DEDENT DEDENT return all_levels NEW_LINE DEDENT 
def filter_by_substring ( strings , substring ) : NEW_LINE INDENT result = [ ] NEW_LINE for s in strings : NEW_LINE INDENT if substring in s : NEW_LINE INDENT result . append ( s ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def rolling_max ( numbers ) : NEW_LINE INDENT running_max = 0 NEW_LINE result = [ ] NEW_LINE for n in numbers : NEW_LINE INDENT if n > running_max : NEW_LINE INDENT running_max = n NEW_LINE DEDENT result . append ( running_max ) NEW_LINE DEDENT return result NEW_LINE DEDENT 
def make_palindrome ( s ) : NEW_LINE INDENT if not s : NEW_LINE INDENT return "" NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT r_str = s [ i : ] NEW_LINE if r_str == r_str [ : : - 1 ] : NEW_LINE INDENT n_str = s [ 0 : i ] NEW_LINE n2_str = n_str [ : : - 1 ] NEW_LINE return s + n2_str NEW_LINE DEDENT DEDENT return s [ : - 2 ] + s [ : : - 1 ] NEW_LINE DEDENT 
def string_xor ( a , b ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] == b [ i ] : NEW_LINE INDENT result . append ( "0" ) NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( "1" ) NEW_LINE DEDENT DEDENT return "" . join ( result ) NEW_LINE DEDENT 
def longest ( strings ) : NEW_LINE INDENT if not strings : NEW_LINE INDENT return "" NEW_LINE DEDENT max_len = max ( len ( x ) for x in strings ) NEW_LINE for s in strings : NEW_LINE INDENT if len ( s ) == max_len : NEW_LINE INDENT return s NEW_LINE DEDENT DEDENT return "" NEW_LINE DEDENT 
def string_sequence ( n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( str ( i ) ) NEW_LINE s . append ( " " ) NEW_LINE DEDENT s . append ( str ( n ) ) NEW_LINE return "" . join ( s ) NEW_LINE DEDENT 
def count_distinct_characters ( s ) : NEW_LINE INDENT distinct = set ( ) NEW_LINE for c in s . lower ( ) : NEW_LINE INDENT distinct . add ( c ) NEW_LINE DEDENT return len ( distinct ) NEW_LINE DEDENT 
def how_many_times ( s , sub ) : NEW_LINE INDENT times = 0 NEW_LINE for i in range ( len ( s ) - len ( sub ) + 1 ) : NEW_LINE INDENT if s [ i : i + len ( sub ) ] == sub : NEW_LINE INDENT times += 1 NEW_LINE DEDENT DEDENT return times NEW_LINE DEDENT 
def sort_numbers ( numbers ) : NEW_LINE INDENT to_num = { "zero" : 0 , "one" : 1 , "two" : 2 , "three" : 3 , "four" : 4 , "five" : 5 , "six" : 6 , "seven" : 7 , "eight" : 8 , "nine" : 9 } NEW_LINE from_num = { 0 : "zero" , 1 : "one" , 2 : "two" , 3 : "three" , 4 : "four" , 5 : "five" , 6 : "six" , 7 : "seven" , 8 : "eight" , 9 : "nine" } NEW_LINE ints = [ ] NEW_LINE current = [ ] NEW_LINE for i in range ( len ( numbers ) + 1 ) : NEW_LINE INDENT if i == len ( numbers ) or numbers [ i ] == " " : NEW_LINE INDENT if "" . join ( current ) in to_num : NEW_LINE INDENT ints . append ( to_num [ "" . join ( current ) ] ) NEW_LINE current . clear ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT current . append ( numbers [ i ] ) NEW_LINE DEDENT DEDENT ints . sort ( ) NEW_LINE result = [ ] NEW_LINE for i in range ( len ( ints ) ) : NEW_LINE INDENT result . append ( from_num [ ints [ i ] ] ) NEW_LINE if i != len ( ints ) - 1 : NEW_LINE INDENT result . append ( " " ) NEW_LINE DEDENT DEDENT return "" . join ( result ) NEW_LINE DEDENT 
def find_closest_elements ( numbers ) : NEW_LINE INDENT closest_pair = [ numbers [ 0 ] , numbers [ 1 ] ] NEW_LINE distance = abs ( closest_pair [ 0 ] - closest_pair [ 1 ] ) NEW_LINE for i in range ( len ( numbers ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( numbers ) ) : NEW_LINE INDENT if abs ( numbers [ i ] - numbers [ j ] ) < distance : NEW_LINE INDENT closest_pair [ 0 ] = numbers [ i ] NEW_LINE closest_pair [ 1 ] = numbers [ j ] NEW_LINE distance = abs ( numbers [ i ] - numbers [ j ] ) NEW_LINE DEDENT DEDENT DEDENT closest_pair . sort ( ) NEW_LINE return closest_pair NEW_LINE DEDENT 
def rescale_to_unit ( numbers ) : NEW_LINE INDENT min_num = min ( numbers ) NEW_LINE max_num = max ( numbers ) NEW_LINE result = [ ] NEW_LINE for n in numbers : NEW_LINE INDENT result . append ( ( n - min_num ) / ( max_num - min_num ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT 
def filter_integers ( values ) : NEW_LINE INDENT result = [ ] NEW_LINE for e in values : NEW_LINE INDENT if isinstance ( e , int ) : NEW_LINE INDENT result . append ( e ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def remove_duplicates ( numbers ) : NEW_LINE INDENT counter = { } NEW_LINE for i in numbers : NEW_LINE INDENT counter [ i ] = counter . get ( i , 0 ) + 1 NEW_LINE DEDENT result = [ ] NEW_LINE for i in numbers : NEW_LINE INDENT if counter [ i ] == 1 : NEW_LINE INDENT result . append ( i ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def flip_case ( s ) : NEW_LINE INDENT result = [ ] NEW_LINE for c in s : NEW_LINE INDENT if c . islower ( ) : NEW_LINE INDENT result . append ( c . upper ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( c . lower ( ) ) NEW_LINE DEDENT DEDENT return "" . join ( result ) NEW_LINE DEDENT 
def filter_by_prefix ( strings , prefix ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( strings ) ) : NEW_LINE INDENT if strings [ i ] . startswith ( prefix ) : NEW_LINE INDENT result . append ( strings [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def find_zero ( xs ) : NEW_LINE INDENT ans = 0 NEW_LINE value = 0 NEW_LINE for i in range ( len ( xs ) ) : NEW_LINE INDENT value += xs [ i ] * ans ** i NEW_LINE DEDENT while abs ( value ) > 1e-6 : NEW_LINE INDENT driv = 0 NEW_LINE for i in range ( 1 , len ( xs ) ) : NEW_LINE INDENT driv += xs [ i ] * ans ** ( i - 1 ) * i NEW_LINE DEDENT ans -= value / driv NEW_LINE value = 0 NEW_LINE for i in range ( len ( xs ) ) : NEW_LINE INDENT value += xs [ i ] * ans ** i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def sort_third ( l ) : NEW_LINE INDENT thirds = [ ] NEW_LINE for i in range ( 0 , len ( l ) , 3 ) : NEW_LINE INDENT thirds . append ( l [ i ] ) NEW_LINE DEDENT thirds . sort ( ) NEW_LINE result = [ ] NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT if i % 3 == 0 : NEW_LINE INDENT result . append ( thirds [ i // 3 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( l [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def unique ( l ) : NEW_LINE INDENT result = list ( set ( l ) ) NEW_LINE result . sort ( ) NEW_LINE return result NEW_LINE DEDENT 
def max_element ( l ) : NEW_LINE INDENT return max ( l ) NEW_LINE DEDENT 
def triples_sum_to_zero ( l ) : NEW_LINE INDENT for i in range ( len ( l ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( l ) ) : NEW_LINE INDENT for k in range ( j + 1 , len ( l ) ) : NEW_LINE INDENT if l [ i ] + l [ j ] + l [ k ] == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT 
def fib4 ( n ) : NEW_LINE INDENT results = [ 0 , 0 , 2 , 0 ] NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT results . append ( results [ i - 4 ] + results [ i - 3 ] + results [ i - 2 ] + results [ i - 1 ] ) NEW_LINE DEDENT return results [ n ] NEW_LINE DEDENT 
def is_palindrome ( text ) : NEW_LINE INDENT pr = text [ : : - 1 ] NEW_LINE return pr == text NEW_LINE DEDENT 
def remove_vowels ( text ) : NEW_LINE INDENT result = [ ] NEW_LINE vowels = "aeiou" NEW_LINE for ch in text : NEW_LINE INDENT if ch . lower ( ) not in vowels : NEW_LINE INDENT result . append ( ch ) NEW_LINE DEDENT DEDENT return "" . join ( result ) NEW_LINE DEDENT 
def same_chars ( s0 , s1 ) : NEW_LINE INDENT set0 = set ( ) NEW_LINE for c in s0 : NEW_LINE INDENT set0 . add ( c ) NEW_LINE DEDENT set1 = set ( ) NEW_LINE for c in s1 : NEW_LINE INDENT set1 . add ( c ) NEW_LINE DEDENT return set0 == set1 NEW_LINE DEDENT 
def common ( l1 , l2 ) : NEW_LINE INDENT us = set ( ) NEW_LINE for e1 in l1 : NEW_LINE INDENT for e2 in l2 : NEW_LINE INDENT if e1 == e2 : NEW_LINE INDENT us . add ( e1 ) NEW_LINE DEDENT DEDENT DEDENT ret = list ( us ) NEW_LINE ret . sort ( ) NEW_LINE return ret NEW_LINE DEDENT 
def correct_bracketing ( brackets ) : NEW_LINE INDENT depth = 0 NEW_LINE for b in brackets : NEW_LINE INDENT if b == "(" : NEW_LINE INDENT depth += 1 NEW_LINE DEDENT else : NEW_LINE INDENT depth -= 1 NEW_LINE DEDENT if depth < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return depth == 0 NEW_LINE DEDENT 
def circular_shift ( x , shift ) : NEW_LINE INDENT s = str ( x ) NEW_LINE if shift > len ( s ) : NEW_LINE INDENT return s [ : : - 1 ] NEW_LINE DEDENT return s [ - shift : ] + s [ : - shift ] NEW_LINE DEDENT 
def search ( lst ) : NEW_LINE INDENT counter = { } NEW_LINE for i in lst : NEW_LINE INDENT counter [ i ] = counter . get ( i , 0 ) + 1 NEW_LINE DEDENT ans = - 1 NEW_LINE for key , value in counter . items ( ) : NEW_LINE INDENT if value >= key > ans : NEW_LINE INDENT ans = key NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def smallest_change ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( arr ) // 2 ) : NEW_LINE INDENT if arr [ i ] != arr [ - i - 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def total_match ( lst1 , lst2 ) : NEW_LINE INDENT sum1 = 0 NEW_LINE for st in lst1 : NEW_LINE INDENT sum1 += len ( st ) NEW_LINE DEDENT sum2 = 0 NEW_LINE for st in lst2 : NEW_LINE INDENT sum2 += len ( st ) NEW_LINE DEDENT return lst2 if sum1 > sum2 else lst1 NEW_LINE DEDENT 
def is_happy ( s ) : NEW_LINE INDENT if len ( s ) < 3 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( len ( s ) - 2 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] or s [ i + 1 ] == s [ i + 2 ] or s [ i ] == s [ i + 2 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def numerical_letter_grade ( grades ) : NEW_LINE INDENT letter_grade = [ ] NEW_LINE for gpa in grades : NEW_LINE INDENT if gpa == 4.0 : NEW_LINE INDENT letter_grade . append ( "A+" ) NEW_LINE DEDENT elif gpa > 3.7 : NEW_LINE INDENT letter_grade . append ( "A" ) NEW_LINE DEDENT elif gpa > 3.3 : NEW_LINE INDENT letter_grade . append ( "A-" ) NEW_LINE DEDENT elif gpa > 3.0 : NEW_LINE INDENT letter_grade . append ( "B+" ) NEW_LINE DEDENT elif gpa > 2.7 : NEW_LINE INDENT letter_grade . append ( "B" ) NEW_LINE DEDENT elif gpa > 2.3 : NEW_LINE INDENT letter_grade . append ( "B-" ) NEW_LINE DEDENT elif gpa > 2.0 : NEW_LINE INDENT letter_grade . append ( "C+" ) NEW_LINE DEDENT elif gpa > 1.7 : NEW_LINE INDENT letter_grade . append ( "C" ) NEW_LINE DEDENT elif gpa > 1.3 : NEW_LINE INDENT letter_grade . append ( "C-" ) NEW_LINE DEDENT elif gpa > 1.0 : NEW_LINE INDENT letter_grade . append ( "D+" ) NEW_LINE DEDENT elif gpa > 0.7 : NEW_LINE INDENT letter_grade . append ( "D" ) NEW_LINE DEDENT elif gpa > 0.0 : NEW_LINE INDENT letter_grade . append ( "D-" ) NEW_LINE DEDENT else : NEW_LINE INDENT letter_grade . append ( "E" ) NEW_LINE DEDENT DEDENT return letter_grade NEW_LINE DEDENT 
def solve ( n ) : NEW_LINE INDENT bi_str = [ ] NEW_LINE sum = 0 NEW_LINE for c in str ( n ) : NEW_LINE INDENT sum += ord ( c ) - ord ( "0" ) NEW_LINE DEDENT while sum > 0 : NEW_LINE INDENT bi_str . insert ( 0 , str ( sum % 2 ) ) NEW_LINE sum //= 2 NEW_LINE DEDENT return "" . join ( bi_str ) NEW_LINE DEDENT 
def anti_shuffle ( s ) : NEW_LINE INDENT ret = [ ] NEW_LINE current = [ ] NEW_LINE for i in range ( len ( s ) + 1 ) : NEW_LINE INDENT if i == len ( s ) or s [ i ] == " " : NEW_LINE INDENT current . sort ( ) NEW_LINE if ret : NEW_LINE INDENT ret . append ( " " ) NEW_LINE DEDENT ret . append ( "" . join ( current ) ) NEW_LINE current . clear ( ) NEW_LINE DEDENT else : NEW_LINE INDENT current . append ( s [ i ] ) NEW_LINE DEDENT DEDENT return "" . join ( ret ) NEW_LINE DEDENT 
def sort_array ( array ) : NEW_LINE INDENT if not array : NEW_LINE INDENT return array NEW_LINE DEDENT if ( array [ 0 ] + array [ - 1 ] ) % 2 == 1 : NEW_LINE INDENT array . sort ( ) NEW_LINE DEDENT else : NEW_LINE INDENT array . sort ( reverse = True ) NEW_LINE DEDENT return array NEW_LINE DEDENT 
def encrypt ( s ) : NEW_LINE INDENT ans = [ ] NEW_LINE for c in s : NEW_LINE INDENT if c . isalpha ( ) : NEW_LINE INDENT ans . append ( chr ( ord ( "a" ) + ( ord ( c ) - ord ( "a" ) + 4 ) % 26 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( c ) NEW_LINE DEDENT DEDENT return "" . join ( ans ) NEW_LINE DEDENT 
def is_bored ( s ) : NEW_LINE INDENT is_start = True NEW_LINE sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == "." or s [ i ] == "?" or s [ i ] == "!" : NEW_LINE INDENT is_start = True NEW_LINE DEDENT elif is_start : NEW_LINE INDENT if s [ i ] == " " : NEW_LINE INDENT continue NEW_LINE DEDENT if s [ i : i + 2 ] == "I " : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT is_start = False NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT 
def encode ( message ) : NEW_LINE INDENT vowels = "aeiouAEIOU" NEW_LINE ret = [ ] NEW_LINE for c in message : NEW_LINE INDENT if c . isupper ( ) : NEW_LINE INDENT c = c . lower ( ) NEW_LINE if c in vowels : NEW_LINE INDENT c = chr ( ord ( "a" ) + ( ord ( c ) - ord ( "a" ) + 2 ) % 26 ) NEW_LINE DEDENT DEDENT elif c . islower ( ) : NEW_LINE INDENT c = c . upper ( ) NEW_LINE if c in vowels : NEW_LINE INDENT c = chr ( ord ( "A" ) + ( ord ( c ) - ord ( "A" ) + 2 ) % 26 ) NEW_LINE DEDENT DEDENT ret . append ( c ) NEW_LINE DEDENT return "" . join ( ret ) NEW_LINE DEDENT 
def skjkasdkd ( lst ) : NEW_LINE INDENT largest = 0 NEW_LINE for n in lst : NEW_LINE INDENT if n > largest : NEW_LINE INDENT prime = True NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT prime = False NEW_LINE DEDENT DEDENT if prime : NEW_LINE INDENT largest = n NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE s = str ( largest ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT sum += ord ( s [ i ] ) - ord ( "0" ) NEW_LINE DEDENT return sum NEW_LINE DEDENT 
def check_dict_case ( dict ) : NEW_LINE INDENT if not dict : NEW_LINE INDENT return False NEW_LINE DEDENT is_lower = 0 NEW_LINE is_upper = 0 NEW_LINE for key in dict : NEW_LINE INDENT for c in key : NEW_LINE INDENT if c . islower ( ) : NEW_LINE INDENT is_lower = 1 NEW_LINE DEDENT elif c . isupper ( ) : NEW_LINE INDENT is_upper = 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return is_lower + is_upper == 1 NEW_LINE DEDENT 
def multiply ( a , b ) : NEW_LINE INDENT return ( abs ( a ) % 10 ) * ( abs ( b ) % 10 ) NEW_LINE DEDENT 
def count_upper ( s ) : NEW_LINE INDENT u_vowel = "AEIOU" NEW_LINE count = 0 NEW_LINE for i in range ( 0 , len ( s ) , 2 ) : NEW_LINE INDENT if s [ i ] in u_vowel : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT 
def by_length ( arr ) : NEW_LINE INDENT num_to = { 1 : "One" , 2 : "Two" , 3 : "Three" , 4 : "Four" , 5 : "Five" , 6 : "Six" , 7 : "Seven" , 8 : "Eight" , 9 : "Nine" } NEW_LINE sorted_arr = sorted ( arr , reverse = True ) NEW_LINE new_arr = [ ] NEW_LINE for n in sorted_arr : NEW_LINE INDENT if n >= 1 and n <= 9 : NEW_LINE INDENT new_arr . append ( num_to [ n ] ) NEW_LINE DEDENT DEDENT return new_arr NEW_LINE DEDENT 
def f ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE prod = 1 NEW_LINE result = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i NEW_LINE prod *= i NEW_LINE if i % 2 == 0 : NEW_LINE INDENT result . append ( prod ) NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( sum ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def even_odd_palindrome ( n ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = str ( i ) NEW_LINE r_str = s [ : : - 1 ] NEW_LINE if s == r_str : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT DEDENT DEDENT return [ even_count , odd_count ] NEW_LINE DEDENT 
def histogram ( test ) : NEW_LINE INDENT count = { } NEW_LINE max = 0 NEW_LINE for i in range ( len ( test ) ) : NEW_LINE INDENT if test [ i ] != " " : NEW_LINE INDENT count [ test [ i ] ] = count . get ( test [ i ] , 0 ) + 1 NEW_LINE if count [ test [ i ] ] > max : NEW_LINE INDENT max = count [ test [ i ] ] NEW_LINE DEDENT DEDENT DEDENT result = { } NEW_LINE for key , value in count . items ( ) : NEW_LINE INDENT if value == max : NEW_LINE INDENT result [ key ] = value NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def reverse_delete ( s , c ) : NEW_LINE INDENT ret = [ ] NEW_LINE for ch in s : NEW_LINE INDENT if ch not in c : NEW_LINE INDENT ret . append ( ch ) NEW_LINE DEDENT DEDENT flag = "False" NEW_LINE if "" . join ( ret ) == "" . join ( ret [ : : - 1 ] ) : NEW_LINE INDENT flag = "True" NEW_LINE DEDENT return [ "" . join ( ret ) , flag ] NEW_LINE DEDENT 
def sort_array ( arr ) : NEW_LINE INDENT bin = [ ] NEW_LINE for i in arr : NEW_LINE INDENT b = 0 NEW_LINE n = abs ( i ) NEW_LINE while n > 0 : NEW_LINE INDENT b += n % 2 NEW_LINE n //= 2 NEW_LINE DEDENT bin . append ( b ) NEW_LINE DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT for j in range ( 1 , len ( arr ) ) : NEW_LINE INDENT if bin [ j ] < bin [ j - 1 ] or ( bin [ j ] == bin [ j - 1 ] and arr [ j ] < arr [ j - 1 ] ) : NEW_LINE INDENT bin [ j ] , bin [ j - 1 ] = bin [ j - 1 ] , bin [ j ] NEW_LINE arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] NEW_LINE DEDENT DEDENT DEDENT return arr NEW_LINE DEDENT 
def get_closest_vowel ( word ) : NEW_LINE INDENT vowels = "AEIOUaeiou" NEW_LINE for i in range ( len ( word ) - 2 , 0 , - 1 ) : NEW_LINE INDENT if word [ i ] in vowels and word [ i + 1 ] not in vowels and word [ i - 1 ] not in vowels : NEW_LINE INDENT return word [ i ] NEW_LINE DEDENT DEDENT return "" NEW_LINE DEDENT 
def match_parens ( lst ) : NEW_LINE INDENT strings = [ lst [ 0 ] + lst [ 1 ] , lst [ 1 ] + lst [ 0 ] ] NEW_LINE for l in strings : NEW_LINE INDENT count = 0 NEW_LINE for c in l : NEW_LINE INDENT if c == "(" : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if c == ")" : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if count < 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if count == 0 : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT DEDENT return "No" NEW_LINE DEDENT 
def maximum ( arr , k ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE return arr [ - k : ] NEW_LINE DEDENT 
def valid_date ( date ) : NEW_LINE INDENT if len ( date ) != 10 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT if i == 2 or i == 5 : NEW_LINE INDENT if date [ i ] != "-" : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif not date [ i ] . isdigit ( ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT month = int ( date [ 0 : 2 ] ) NEW_LINE day = int ( date [ 3 : 5 ] ) NEW_LINE year = int ( date [ 6 : 10 ] ) NEW_LINE if month < 1 or month > 12 : NEW_LINE INDENT return False NEW_LINE DEDENT if day < 1 or day > 31 : NEW_LINE INDENT return False NEW_LINE DEDENT if day == 31 and ( month == 4 or month == 6 or month == 9 or month == 11 or month == 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if day == 30 and month == 2 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT 
def split_words ( txt ) : NEW_LINE INDENT current = [ ] NEW_LINE result = [ ] NEW_LINE if " " in txt : NEW_LINE INDENT for i in range ( len ( txt ) + 1 ) : NEW_LINE INDENT if i == len ( txt ) or txt [ i ] == " " : NEW_LINE INDENT if len ( current ) > 0 : NEW_LINE INDENT result . append ( "" . join ( current ) ) NEW_LINE current . clear ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT current . append ( txt [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if "," in txt : NEW_LINE INDENT for i in range ( len ( txt ) + 1 ) : NEW_LINE INDENT if i == len ( txt ) or txt [ i ] == "," : NEW_LINE INDENT if len ( current ) > 0 : NEW_LINE INDENT result . append ( "" . join ( current ) ) NEW_LINE current . clear ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT current . append ( txt [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT num = 0 NEW_LINE for c in txt : NEW_LINE INDENT if c . islower ( ) and ord ( c ) % 2 == 0 : NEW_LINE INDENT num += 1 NEW_LINE DEDENT DEDENT return [ str ( num ) ] NEW_LINE DEDENT 
def tri ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return [ 1 ] NEW_LINE DEDENT tris = [ 1 , 3 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT tris . append ( i // 2 + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT tris . append ( tris [ i - 1 ] + tris [ i - 2 ] + ( i + 3 ) // 2 ) NEW_LINE DEDENT DEDENT return tris NEW_LINE DEDENT 
def check_if_last_char_is_a_letter ( txt ) : NEW_LINE INDENT if not txt : NEW_LINE INDENT return False NEW_LINE DEDENT return txt [ - 1 ] . isalpha ( ) and ( len ( txt ) == 1 or not txt [ - 2 ] . isalpha ( ) ) NEW_LINE DEDENT 
def order_by_points ( nums ) : NEW_LINE INDENT result = [ ] NEW_LINE for num in nums : NEW_LINE INDENT w = str ( abs ( num ) ) NEW_LINE sum = 0 NEW_LINE for c in w : NEW_LINE INDENT sum += ord ( c ) - ord ( '0' ) NEW_LINE DEDENT if num < 0 : NEW_LINE INDENT sum -= 2 * ( ord ( w [ 0 ] ) - ord ( '0' ) ) NEW_LINE DEDENT result . append ( sum ) NEW_LINE DEDENT for i in range ( len ( nums ) ) : NEW_LINE INDENT for j in range ( 1 , len ( nums ) ) : NEW_LINE INDENT if result [ j - 1 ] > result [ j ] : NEW_LINE INDENT result [ j ] , result [ j - 1 ] = result [ j - 1 ] , result [ j ] NEW_LINE nums [ j ] , nums [ j - 1 ] = nums [ j - 1 ] , nums [ j ] NEW_LINE DEDENT DEDENT DEDENT return nums NEW_LINE DEDENT 
def bf ( planet1 , planet2 ) : NEW_LINE INDENT planets = [ "Mercury" , "Venus" , "Earth" , "Mars" , "Jupiter" , "Saturn" , "Uranus" , "Neptune" ] NEW_LINE idx1 = planets . index ( planet1 ) if planet1 in planets else - 1 NEW_LINE idx2 = planets . index ( planet2 ) if planet2 in planets else - 1 NEW_LINE if idx1 == - 1 or idx2 == - 1 or idx1 == idx2 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT return planets [ idx2 + 1 : idx1 ] if idx1 > idx2 else planets [ idx1 + 1 : idx2 ] NEW_LINE DEDENT 
def sorted_list_sum ( lst ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in lst : NEW_LINE INDENT if len ( i ) % 2 == 0 : NEW_LINE INDENT result . append ( i ) NEW_LINE DEDENT DEDENT result . sort ( key = lambda s : ( len ( s ) , s ) ) NEW_LINE return result NEW_LINE DEDENT 
def cycpattern_check ( a , b ) : NEW_LINE INDENT for i in range ( len ( b ) ) : NEW_LINE INDENT rotate = b [ i : ] + b [ 0 : i ] NEW_LINE if rotate in a : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT 
def even_odd_count ( num ) : NEW_LINE INDENT even_count , odd_count = 0 , 0 NEW_LINE for i in str ( abs ( num ) ) : NEW_LINE INDENT if int ( i ) % 2 == 0 : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT DEDENT return [ even_count , odd_count ] NEW_LINE DEDENT 
def find_max ( words ) : NEW_LINE INDENT max = "" NEW_LINE max_length = 0 NEW_LINE for word in words : NEW_LINE INDENT unique = [ ] NEW_LINE for w in word : NEW_LINE INDENT if w not in unique : NEW_LINE INDENT unique . append ( w ) NEW_LINE DEDENT if len ( unique ) > max_length or ( len ( unique ) == max_length and word < max ) : NEW_LINE INDENT max = word NEW_LINE max_length = len ( unique ) NEW_LINE DEDENT DEDENT DEDENT return max NEW_LINE DEDENT 
def solve ( s ) : NEW_LINE INDENT no_letter = True NEW_LINE result = [ ] NEW_LINE for ch in s : NEW_LINE INDENT if ch . isupper ( ) : NEW_LINE INDENT ch = ch . lower ( ) NEW_LINE no_letter = False NEW_LINE DEDENT elif ch . islower ( ) : NEW_LINE INDENT ch = ch . upper ( ) NEW_LINE no_letter = False NEW_LINE DEDENT result . append ( ch ) NEW_LINE DEDENT if no_letter : NEW_LINE INDENT return "" . join ( result ) [ : : - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return "" . join ( result ) NEW_LINE DEDENT DEDENT 
def most_frequent ( arr , n ) : NEW_LINE INDENT hp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in hp : NEW_LINE INDENT hp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT max_count , res = 0 , - 1 NEW_LINE for key , value in hp . items ( ) : NEW_LINE INDENT if max_count < value : NEW_LINE INDENT res = key NEW_LINE max_count = value NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT 
def find ( a , b , k , n1 , n2 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT missing = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if a [ i ] not in s : NEW_LINE INDENT missing += 1 NEW_LINE DEDENT if missing == k : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT 
def solve_query ( start , end , arr ) : NEW_LINE INDENT frequency = dict ( ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT frequency [ arr [ i ] ] = frequency . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT count = 0 NEW_LINE for key , value in frequency . items ( ) : NEW_LINE INDENT if key == value : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT 
def segregate ( arr , size ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] <= 0 : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT 
def count_triplets ( a , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( a [ i ] ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT xr = a [ i ] ^ a [ j ] NEW_LINE if xr in s and xr != a [ i ] and xr != a [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( count / 3 ) NEW_LINE DEDENT 
def least_frequent ( arr , n ) : NEW_LINE INDENT hp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in hp : NEW_LINE INDENT hp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT min_count = n + 1 NEW_LINE res = - 1 NEW_LINE for key , value in hp . items ( ) : NEW_LINE INDENT if min_count >= value : NEW_LINE INDENT res = key NEW_LINE min_count = value NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT 
def find_permutations ( arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE max_ind , min_ind = - 1 , 10000000 NEW_LINE n = len ( arr ) NEW_LINE index_of = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT index_of [ arr [ i ] ] = i + 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT max_ind = max ( max_ind , index_of . get ( i , 0 ) ) NEW_LINE min_ind = min ( min_ind , index_of . get ( i , 0 ) ) NEW_LINE if max_ind - min_ind + 1 == i : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT 
def form_quadruplets ( arr , n ) : NEW_LINE INDENT ans , pairs = 0 , 0 NEW_LINE pairs = n // 4 NEW_LINE arr . sort ( reverse = True ) NEW_LINE for i in range ( 0 , n - pairs , 3 ) : NEW_LINE INDENT ans += arr [ i + 2 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT 
def lexicographically_maximum ( s , n ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] in m : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT v = [ ] NEW_LINE for i in range ( ord ( "a" ) , ord ( "a" ) + min ( n , 25 ) ) : NEW_LINE INDENT if chr ( i ) not in m : NEW_LINE INDENT v . append ( chr ( i ) ) NEW_LINE DEDENT DEDENT j = len ( v ) - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ord ( s [ i ] ) >= ord ( "a" ) + min ( n , 25 ) or ( s [ i ] in m and m [ s [ i ] ] > 1 ) : NEW_LINE INDENT if ord ( v [ j ] ) < ord ( s [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT m [ s [ i ] ] -= 1 NEW_LINE s = s [ 0 : i ] + v [ j ] + s [ i + 1 : ] NEW_LINE j -= 1 NEW_LINE DEDENT if j < 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if l > j : NEW_LINE INDENT break NEW_LINE DEDENT if ord ( s [ i ] ) >= ord ( "a" ) + min ( n , 25 ) or s [ i ] in m and m [ s [ i ] ] > 1 : NEW_LINE INDENT m [ s [ i ] ] -= 1 NEW_LINE s = s [ 0 : i ] + v [ l ] + s [ i + 1 : ] NEW_LINE l += 1 NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT 
def no_of_valid_kbers ( k , arr ) : NEW_LINE INDENT st = set ( ) NEW_LINE while k != 0 : NEW_LINE INDENT st . add ( k % 10 ) NEW_LINE k = k // 10 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT no = arr [ i ] NEW_LINE flag = True NEW_LINE while no != 0 : NEW_LINE INDENT digit = no % 10 NEW_LINE if digit not in st : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT no = no // 10 NEW_LINE DEDENT if flag == True : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT 
def del_cost ( s , cost ) : NEW_LINE INDENT ans = 0 NEW_LINE for_max = { } NEW_LINE for_tot = { } NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] not in for_max : NEW_LINE INDENT for_max [ s [ i ] ] = cost [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT for_max [ s [ i ] ] = max ( cost [ i ] , for_max [ s [ i ] ] ) NEW_LINE DEDENT if s [ i ] not in for_tot : NEW_LINE INDENT for_tot [ s [ i ] ] = cost [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT for_tot [ s [ i ] ] += cost [ i ] NEW_LINE DEDENT DEDENT for key , value in for_max . items ( ) : NEW_LINE INDENT ans += for_tot [ key ] - value NEW_LINE DEDENT return ans NEW_LINE DEDENT 
def replace_duplicates ( names ) : NEW_LINE INDENT hash = { } NEW_LINE for i in range ( len ( names ) ) : NEW_LINE INDENT if names [ i ] not in hash : NEW_LINE INDENT hash [ names [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = hash [ names [ i ] ] NEW_LINE hash [ names [ i ] ] += 1 NEW_LINE names [ i ] += str ( count ) NEW_LINE DEDENT DEDENT return names NEW_LINE DEDENT 
def minmax_numbers ( matrix , res ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( len ( matrix ) ) : NEW_LINE INDENT min_r = sys . maxsize NEW_LINE for j in range ( len ( matrix [ i ] ) ) : NEW_LINE INDENT min_r = min ( min_r , matrix [ i ] [ j ] ) NEW_LINE DEDENT s . add ( min_r ) NEW_LINE DEDENT for j in range ( len ( matrix [ 0 ] ) ) : NEW_LINE INDENT max_c = - sys . maxsize NEW_LINE for i in range ( len ( matrix ) ) : NEW_LINE INDENT max_c = max ( max_c , matrix [ i ] [ j ] ) NEW_LINE DEDENT if max_c in s : NEW_LINE INDENT res . append ( max_c ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT 
def length_of_longest_ap ( a , n ) : NEW_LINE INDENT dp = { } NEW_LINE res = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT d = a [ j ] - a [ i ] NEW_LINE if d in dp : NEW_LINE INDENT if i in dp [ d ] : NEW_LINE INDENT dp [ d ] [ j ] = dp [ d ] [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ d ] [ j ] = 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ d ] = { } NEW_LINE dp [ d ] [ j ] = 2 NEW_LINE DEDENT res = max ( res , dp [ d ] [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT 
def find_kth_char ( n , k ) : NEW_LINE INDENT prev = "A" NEW_LINE cur = "" NEW_LINE if n == 1 : NEW_LINE INDENT return "A" NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT cur = prev + "B" NEW_LINE for i in range ( len ( prev ) ) : NEW_LINE INDENT if prev [ i ] == "A" : NEW_LINE INDENT prev = prev [ 0 : i ] + "B" + prev [ i + 1 : ] NEW_LINE DEDENT else : NEW_LINE INDENT prev = prev [ 0 : i ] + "A" + prev [ i + 1 : ] NEW_LINE DEDENT DEDENT prev = prev [ : : - 1 ] NEW_LINE cur += prev NEW_LINE prev = cur NEW_LINE DEDENT return cur [ k - 1 ] NEW_LINE DEDENT 
def find_kth_largest ( s , k ) : NEW_LINE INDENT tmp = list ( s ) NEW_LINE tmp . sort ( reverse = True ) NEW_LINE return tmp [ k - 1 ] NEW_LINE DEDENT 
def sub_arraylen ( arr , n , k ) : NEW_LINE INDENT mp = { } NEW_LINE mp [ arr [ 0 ] ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] + arr [ i - 1 ] NEW_LINE mp [ arr [ i ] ] = i NEW_LINE DEDENT len = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < k : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT x = arr [ i ] - k NEW_LINE if x == 0 : NEW_LINE INDENT len = min ( len , i ) NEW_LINE DEDENT if x not in mp : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT len = min ( len , i - mp . get ( x , 0 ) ) NEW_LINE DEDENT DEDENT DEDENT return len NEW_LINE DEDENT 
def find_max_len ( a , k ) : NEW_LINE INDENT n = len ( a ) NEW_LINE a . sort ( ) NEW_LINE vis = [ False ] * n NEW_LINE mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] = i NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if not vis [ i ] : NEW_LINE INDENT check = a [ i ] * k NEW_LINE if check in mp : NEW_LINE INDENT c += 1 NEW_LINE vis [ mp [ check ] ] = True NEW_LINE DEDENT DEDENT DEDENT return n - c NEW_LINE DEDENT 
def min_distance_points ( a , k , n ) : NEW_LINE INDENT m = { } NEW_LINE q = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ a [ i ] ] = 1 NEW_LINE q . append ( a [ i ] ) NEW_LINE DEDENT ans = [ ] NEW_LINE while k > 0 : NEW_LINE INDENT x = q [ 0 ] NEW_LINE q = q [ 1 : : ] NEW_LINE if ( x - 1 ) not in m and k > 0 : NEW_LINE INDENT m [ x - 1 ] = 1 NEW_LINE q . append ( x - 1 ) NEW_LINE ans . append ( x - 1 ) NEW_LINE k -= 1 NEW_LINE DEDENT if ( x + 1 ) not in m and k > 0 : NEW_LINE INDENT m [ x + 1 ] = 1 NEW_LINE q . append ( x + 1 ) NEW_LINE ans . append ( x + 1 ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def isValidLen ( s , length , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE mp = dict ( ) NEW_LINE right = 0 NEW_LINE while right < length : NEW_LINE INDENT if s [ right ] in mp : NEW_LINE INDENT mp [ s [ right ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ s [ right ] ] = 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT if len ( mp ) <= k : NEW_LINE INDENT return True NEW_LINE DEDENT while right < n : NEW_LINE INDENT if s [ right ] in mp : NEW_LINE INDENT mp [ s [ right ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ s [ right ] ] = 1 NEW_LINE DEDENT mp [ s [ right - length ] ] -= 1 NEW_LINE if mp [ s [ right - length ] ] == 0 : NEW_LINE INDENT del mp [ s [ right - length ] ] NEW_LINE DEDENT if len ( mp ) <= k : NEW_LINE INDENT return True NEW_LINE DEDENT right += 1 NEW_LINE DEDENT return len ( mp ) <= k NEW_LINE DEDENT 
def partition ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ high ] NEW_LINE i = ( low - 1 ) NEW_LINE for j in range ( low , high ) : NEW_LINE INDENT if arr [ j ] <= pivot : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT arr [ i + 1 ] , arr [ high ] = arr [ high ] , arr [ i + 1 ] NEW_LINE return i + 1 NEW_LINE DEDENT 
def str_score ( strs , s , n ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ strs [ i ] ] = i + 1 NEW_LINE DEDENT if s not in m . keys ( ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT score = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT score += ord ( s [ i ] ) - ord ( "a" ) + 1 NEW_LINE DEDENT score = score * m [ s ] NEW_LINE return score NEW_LINE DEDENT 
def count_ele ( s , a , n ) : NEW_LINE INDENT mp = { } NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE if num in mp : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 0 NEW_LINE while s [ 0 ] != num : NEW_LINE INDENT mp [ s [ 0 ] ] = True NEW_LINE s . pop ( 0 ) NEW_LINE cnt += 1 NEW_LINE DEDENT s . pop ( 0 ) NEW_LINE cnt += 1 NEW_LINE ans . append ( cnt ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def maxDistinctChar ( s , n , k ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] in freq : NEW_LINE INDENT freq [ s [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT v = [ ] NEW_LINE for key , value in freq . items ( ) : NEW_LINE INDENT v . append ( value ) NEW_LINE DEDENT v . sort ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT mn = min ( v [ i ] - 1 , k ) NEW_LINE v [ i ] = v [ i ] - mn NEW_LINE k -= mn NEW_LINE DEDENT if k > 0 : NEW_LINE INDENT for i in range ( len ( v ) ) : NEW_LINE INDENT mn = min ( v [ i ] , k ) NEW_LINE v [ i ] = v [ i ] - mn NEW_LINE k -= mn NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if v [ i ] == 1 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT 
def find_kth ( arr , n , k ) : NEW_LINE INDENT missing = { } NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT missing [ arr [ i ] ] = 1 NEW_LINE DEDENT max_m = max ( arr ) NEW_LINE min_m = min ( arr ) NEW_LINE for i in range ( min_m + 1 , max_m ) : NEW_LINE INDENT if i not in missing : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == k : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT 
def almost_sort ( a , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def maximum_sum ( s , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE freq = [ 0 ] * 256 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT freq . sort ( reverse = True ) NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT if k > freq [ i ] : NEW_LINE INDENT sum += freq [ i ] * freq [ i ] NEW_LINE k -= freq [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += freq [ i ] * k NEW_LINE break NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT 
def find_min_operations ( arr , n , k ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT freq = { } NEW_LINE for j in range ( i , n , k ) : NEW_LINE INDENT freq [ arr [ j ] ] = freq . get ( arr [ j ] , 0 ) + 1 NEW_LINE DEDENT max1 = 0 NEW_LINE num = 0 NEW_LINE for key , value in freq . items ( ) : NEW_LINE INDENT if value > max1 : NEW_LINE INDENT max1 = value NEW_LINE num = key NEW_LINE DEDENT DEDENT for key , value in freq . items ( ) : NEW_LINE INDENT if key != num : NEW_LINE INDENT operations += value NEW_LINE DEDENT DEDENT DEDENT return operations NEW_LINE DEDENT 
def sub_string ( s , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for len in range ( 1 , n - i + 1 ) : NEW_LINE INDENT find = s [ i : i + len ] NEW_LINE v . append ( find ) NEW_LINE DEDENT DEDENT return v NEW_LINE DEDENT 
def check_unique_frequency ( arr , n ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] = freq . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT unique_freq = set ( ) NEW_LINE for i in freq : NEW_LINE INDENT if freq [ i ] in unique_freq : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT unique_freq . add ( freq [ i ] ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def min_cost ( str1 , str2 , n ) : NEW_LINE INDENT cost = 0 NEW_LINE tmp = list ( str1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if tmp [ i ] != str2 [ i ] : NEW_LINE INDENT if i < n - 1 and tmp [ i + 1 ] != str2 [ i + 1 ] : NEW_LINE INDENT tmp [ i ] , tmp [ i + 1 ] = tmp [ i + 1 ] , tmp [ i ] NEW_LINE cost += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cost += 1 NEW_LINE DEDENT DEDENT DEDENT return cost NEW_LINE DEDENT 
def is_valid_num ( x ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT if ord ( x [ i ] ) - ord ( "0" ) in mp : NEW_LINE INDENT return False NEW_LINE DEDENT elif ord ( x [ i ] ) - ord ( "0" ) > 5 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT mp [ ord ( x [ i ] ) - ord ( "0" ) ] = 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def minimize_diff ( arr , n , k ) : NEW_LINE INDENT max_element = max ( arr ) NEW_LINE min_element = min ( arr ) NEW_LINE if max_element - min_element <= k : NEW_LINE INDENT return max_element - min_element NEW_LINE DEDENT avg = ( max_element + min_element ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > avg : NEW_LINE INDENT arr [ i ] -= k NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += k NEW_LINE DEDENT DEDENT max_element = max ( arr ) NEW_LINE min_element = min ( arr ) NEW_LINE return max_element - min_element NEW_LINE DEDENT 
def get_min_cost ( arr , n ) : NEW_LINE INDENT min_ele = min ( arr ) NEW_LINE return min_ele * ( n - 1 ) NEW_LINE DEDENT 
def possibility ( m , length , s ) : NEW_LINE INDENT count_odd = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if m [ ord ( s [ i ] ) - ord ( '0' ) ] & 1 : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT if count_odd > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def minimum_cost_of_breaking ( x , y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE x . sort ( reverse = True ) NEW_LINE y . sort ( reverse = True ) NEW_LINE hzntl , vert = 1 , 1 NEW_LINE i , j = 0 , 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if x [ i ] > y [ j ] : NEW_LINE INDENT res += x [ i ] * vert NEW_LINE hzntl += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += y [ j ] * hzntl NEW_LINE vert += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE while i < m : NEW_LINE INDENT total += x [ i ] NEW_LINE i += 1 NEW_LINE DEDENT res += total * vert NEW_LINE total = 0 NEW_LINE while j < n : NEW_LINE INDENT total += y [ j ] NEW_LINE j += 1 NEW_LINE DEDENT res += total * hzntl NEW_LINE return res NEW_LINE DEDENT 
def find_maximum_score ( a , n ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in freq : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT dp = [ 0 ] * ( max ( a ) + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = freq . get ( 1 , 0 ) NEW_LINE for i in range ( 2 , len ( dp ) ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , dp [ i - 2 ] + freq . get ( i , 0 ) * i ) NEW_LINE DEDENT return dp [ - 1 ] NEW_LINE DEDENT 
def count_ways ( s , t , k , mod ) : NEW_LINE INDENT n = len ( s ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT p = s [ i : n ] + s [ : i ] NEW_LINE if p == t : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT dp1 = [ 0 ] * ( k + 1 ) NEW_LINE dp2 = [ 0 ] * ( k + 1 ) NEW_LINE if s == t : NEW_LINE INDENT dp1 [ 0 ] = 1 NEW_LINE dp2 [ 0 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp1 [ 0 ] = 0 NEW_LINE dp2 [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod NEW_LINE dp2 [ i ] = ( ( dp1 [ i - 1 ] * b ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod NEW_LINE DEDENT return dp1 [ k ] NEW_LINE DEDENT 
def find_subarray_sum ( arr , n , k ) : NEW_LINE INDENT prev_sum = { } NEW_LINE res = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE if curr_sum == k : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( curr_sum - k ) in prev_sum : NEW_LINE INDENT res += prev_sum [ curr_sum - k ] NEW_LINE DEDENT prev_sum [ curr_sum ] = prev_sum . get ( curr_sum , 0 ) + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT 
def maximum_occurrence ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE freq = { } NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT temp = "" NEW_LINE temp += s [ i ] NEW_LINE freq [ temp ] = freq . get ( temp , 0 ) + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT temp = "" NEW_LINE temp += s [ i ] NEW_LINE temp += s [ j ] NEW_LINE freq [ temp ] = freq . get ( temp , 0 ) + 1 NEW_LINE DEDENT DEDENT answer = - sys . maxsize NEW_LINE for key , value in freq . items ( ) : NEW_LINE INDENT answer = max ( answer , value ) NEW_LINE DEDENT return answer NEW_LINE DEDENT 
def count_characters ( strings , chars ) : NEW_LINE INDENT res = 0 NEW_LINE freq = { } NEW_LINE for i in range ( len ( chars ) ) : NEW_LINE INDENT freq [ chars [ i ] ] = freq . get ( chars [ i ] , 0 ) + 1 NEW_LINE DEDENT for st in strings : NEW_LINE INDENT flag = True NEW_LINE for c in list ( st ) : NEW_LINE INDENT if c not in freq : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT res += len ( st ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT 
def distinct_substring ( p , q , k , n ) : NEW_LINE INDENT ss = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE s = "" NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT pos = ord ( p [ j ] ) - ord ( 'a' ) NEW_LINE sum += ord ( q [ pos ] ) - ord ( '0' ) NEW_LINE s += p [ j ] NEW_LINE if sum <= k : NEW_LINE INDENT ss . add ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( ss ) NEW_LINE DEDENT 
def unique_morse_rep ( arr ) : NEW_LINE INDENT morse_code = [ ".-" , "-..." , "-.-." , "-.." , "." , "..-." , "--." , "...." , ".." , ".---" , "-.-" , ".-.." , "--" , "-." , "---" , ".--." , "--.-" , ".-." , "..." , "-" , "..-" , "...-" , ".--" , "-..-" , "-.--" , "--.." ] NEW_LINE st = set ( ) NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = "" NEW_LINE m = len ( arr [ i ] ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT temp += morse_code [ ord ( arr [ i ] [ j ] ) - ord ( "a" ) ] NEW_LINE DEDENT st . add ( temp ) NEW_LINE DEDENT return len ( st ) NEW_LINE DEDENT 
def count_substrings ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE answer = 0 NEW_LINE map = { } NEW_LINE for i in range ( k ) : NEW_LINE INDENT if str [ i ] not in map : NEW_LINE INDENT map [ str [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT map [ str [ i ] ] += 1 NEW_LINE DEDENT DEDENT if len ( map ) == k : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT if str [ i ] not in map : NEW_LINE INDENT map [ str [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT map [ str [ i ] ] += 1 NEW_LINE DEDENT map [ str [ i - k ] ] -= 1 NEW_LINE if map [ str [ i - k ] ] == 0 : NEW_LINE INDENT del map [ str [ i - k ] ] NEW_LINE DEDENT if len ( map ) == k : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT 
def can_construct ( s , k ) : NEW_LINE INDENT m = dict ( ) NEW_LINE p = 0 NEW_LINE if len ( s ) == k : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] = m . get ( s [ i ] , 0 ) + 1 NEW_LINE DEDENT if k > len ( s ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT for key , value in m . items ( ) : NEW_LINE INDENT if value % 2 != 0 : NEW_LINE INDENT p = p + 1 NEW_LINE DEDENT DEDENT DEDENT if k < p : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT 
def equal_ignore_case ( str1 , str2 ) : NEW_LINE INDENT str1 = str1 . upper ( ) NEW_LINE str2 = str2 . upper ( ) NEW_LINE return str1 == str2 NEW_LINE DEDENT 
def find_longest_sub ( bin ) : NEW_LINE INDENT n = len ( bin ) NEW_LINE sum = 0 NEW_LINE prev_sum = { } NEW_LINE max_len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if bin [ i ] == "1" : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum -= 1 NEW_LINE DEDENT if sum > 0 : NEW_LINE INDENT max_len = i + 1 NEW_LINE DEDENT elif sum <= 0 : NEW_LINE INDENT if ( sum - 1 ) in prev_sum : NEW_LINE INDENT curr_len = i - prev_sum [ sum - 1 ] NEW_LINE max_len = max ( max_len , curr_len ) NEW_LINE DEDENT DEDENT if sum not in prev_sum : NEW_LINE INDENT prev_sum [ sum ] = i NEW_LINE DEDENT DEDENT return max_len NEW_LINE DEDENT 
def has_all_codes ( s , k ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in range ( len ( s ) + 1 ) : NEW_LINE INDENT us . add ( s [ i : k ] ) NEW_LINE DEDENT return len ( us ) == 1 << k NEW_LINE DEDENT 
def check_palin ( word ) : NEW_LINE INDENT n = len ( word ) NEW_LINE word = word . lower ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if word [ i ] != word [ n - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT n -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT 
def convert ( st ) : NEW_LINE INDENT w = "" NEW_LINE z = "" NEW_LINE st = st . upper ( ) + " " NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT ch = st [ i ] NEW_LINE if ch != " " : NEW_LINE INDENT w += ch NEW_LINE DEDENT else : NEW_LINE INDENT z += w [ 0 ] . lower ( ) + w [ 1 : len ( w ) ] + " " NEW_LINE w = "" NEW_LINE DEDENT DEDENT return z NEW_LINE DEDENT 
def max_lines ( n , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT s = set ( ) NEW_LINE slope = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x1 [ i ] == x2 [ i ] : NEW_LINE INDENT slope = sys . maxsize NEW_LINE DEDENT else : NEW_LINE INDENT slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) NEW_LINE DEDENT s . add ( slope ) NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT 
def prime_factor ( n ) : NEW_LINE INDENT primef = { } NEW_LINE while n % 2 == 0 : NEW_LINE INDENT if 2 in primef : NEW_LINE INDENT primef [ 2 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT primef [ 2 ] = 1 NEW_LINE DEDENT n = n // 2 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT if i in primef : NEW_LINE INDENT primef [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT primef [ i ] = 1 NEW_LINE DEDENT n = n // i NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT primef [ n ] = 1 NEW_LINE DEDENT return primef NEW_LINE DEDENT 
def is_divisible_by_divisor ( s , d ) : NEW_LINE INDENT s %= d NEW_LINE hash_map = set ( ) NEW_LINE hash_map . add ( s ) NEW_LINE for i in range ( d + 1 ) : NEW_LINE INDENT s += s % d NEW_LINE s %= d NEW_LINE if s in hash_map : NEW_LINE INDENT if s == 0 : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT return "No" NEW_LINE DEDENT else : NEW_LINE INDENT hash_map . add ( s ) NEW_LINE DEDENT DEDENT return "Yes" NEW_LINE DEDENT 
def odd_sum ( a , n , k ) : NEW_LINE INDENT odd = set ( ) NEW_LINE even = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT even . add ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT odd . add ( a [ i ] ) NEW_LINE DEDENT DEDENT if len ( odd ) >= k : NEW_LINE INDENT return True NEW_LINE DEDENT flag = False NEW_LINE for i in range ( 1 , k , 2 ) : NEW_LINE INDENT needed = k - i NEW_LINE if needed <= len ( even ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return flag NEW_LINE DEDENT 
def day_of_year ( date ) : NEW_LINE INDENT days = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE year = int ( date [ 0 : 4 ] ) NEW_LINE month = int ( date [ 5 : 7 ] ) NEW_LINE day = int ( date [ 8 : ] ) NEW_LINE if month > 2 and year % 4 == 0 and ( year % 100 != 0 or year % 400 == 0 ) : NEW_LINE INDENT day += 1 NEW_LINE DEDENT while month > 1 : NEW_LINE INDENT day = day + days [ month - 2 ] NEW_LINE month -= 1 NEW_LINE DEDENT return day NEW_LINE DEDENT 
def is_perfect_square ( arr , n ) : NEW_LINE INDENT umap = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT umap [ arr [ i ] ] = umap . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT for key , value in umap . items ( ) : NEW_LINE INDENT if value % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def min_moves ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE ans = sys . maxsize NEW_LINE length = len ( s ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT for j in range ( length ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT continue NEW_LINE DEDENT t = list ( s ) NEW_LINE cur = 0 NEW_LINE for k in range ( i , length - 1 ) : NEW_LINE INDENT t [ k ] , t [ k + 1 ] = t [ k + 1 ] , t [ k ] NEW_LINE cur += 1 NEW_LINE DEDENT for k in range ( j - ( j > i ) , length - 2 ) : NEW_LINE INDENT t [ k ] , t [ k + 1 ] = t [ k + 1 ] , t [ k ] NEW_LINE cur += 1 NEW_LINE DEDENT pos = - 1 NEW_LINE for k in range ( length ) : NEW_LINE INDENT if t [ k ] != "0" : NEW_LINE INDENT pos = k NEW_LINE break NEW_LINE DEDENT DEDENT for k in range ( pos , 0 , - 1 ) : NEW_LINE INDENT t [ k ] , t [ k - 1 ] = t [ k - 1 ] , t [ k ] NEW_LINE cur += 1 NEW_LINE DEDENT nn = int ( "" . join ( t ) ) NEW_LINE if nn % 25 == 0 : NEW_LINE INDENT ans = min ( ans , cur ) NEW_LINE DEDENT DEDENT DEDENT if ans == sys . maxsize : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT 
def minimum_operations ( a , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] = mp . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT count = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if value > 1 : NEW_LINE INDENT count += value - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT 
def kaprekar_rec ( n , prev ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT prev = n NEW_LINE digits = [ 0 ] * 4 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT digits [ i ] = n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT digits . sort ( ) NEW_LINE asc = 0 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT asc = asc * 10 + digits [ i ] NEW_LINE DEDENT digits . sort ( ) NEW_LINE desc = 0 NEW_LINE for i in range ( 3 , - 1 , - 1 ) : NEW_LINE INDENT desc = desc * 10 + digits [ i ] NEW_LINE DEDENT diff = abs ( asc - desc ) NEW_LINE if diff == prev : NEW_LINE INDENT return diff NEW_LINE DEDENT return kaprekar_rec ( diff , prev ) NEW_LINE DEDENT 
def fraction_to_decimal ( numr , denr ) : NEW_LINE INDENT res = "" NEW_LINE mp = { } NEW_LINE rem = numr % denr NEW_LINE while rem != 0 and rem not in mp : NEW_LINE INDENT mp [ rem ] = len ( res ) NEW_LINE rem = rem * 10 NEW_LINE res_part = rem // denr NEW_LINE res += str ( res_part ) NEW_LINE rem = rem % denr NEW_LINE DEDENT if rem == 0 : NEW_LINE INDENT return "" NEW_LINE DEDENT if rem in mp : NEW_LINE INDENT return res [ mp [ rem ] : ] NEW_LINE DEDENT return "" NEW_LINE DEDENT 
def is_fancy ( num ) : NEW_LINE INDENT fp = { } NEW_LINE fp [ "0" ] = "0" NEW_LINE fp [ "1" ] = "1" NEW_LINE fp [ "6" ] = "9" NEW_LINE fp [ "8" ] = "8" NEW_LINE fp [ "9" ] = "6" NEW_LINE n = len ( num ) NEW_LINE l , r = 0 , n - 1 NEW_LINE while l <= r : NEW_LINE INDENT if num [ l ] not in fp or fp [ num [ l ] ] != num [ r ] : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT 
