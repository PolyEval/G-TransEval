def greatest_common_divisor ( a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : NEW_LINE INDENT return a + b NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return greatest_common_divisor ( a % b , b ) NEW_LINE DEDENT else : NEW_LINE INDENT return greatest_common_divisor ( a , b % a ) NEW_LINE DEDENT DEDENT 
def largest_divisor ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return n // i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def is_prime ( n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return False NEW_LINE DEDENT for k in range ( 2 , n ) : NEW_LINE INDENT if n % k == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def fizz_buzz ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 11 == 0 or i % 13 == 0 : NEW_LINE INDENT q = i NEW_LINE while q > 0 : NEW_LINE INDENT if q % 10 == 7 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT q //= 10 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT 
def prime_fib ( n ) : NEW_LINE INDENT f0 = 0 NEW_LINE f1 = 1 NEW_LINE while n > 0 : NEW_LINE INDENT p = f0 + f1 NEW_LINE is_prime = p >= 2 NEW_LINE for i in range ( 2 , p ) : NEW_LINE INDENT if p % i == 0 : NEW_LINE INDENT is_prime = False NEW_LINE break NEW_LINE DEDENT DEDENT if is_prime : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT f0 = f1 NEW_LINE f1 = p NEW_LINE DEDENT return f1 NEW_LINE DEDENT 
def triangle_area ( a , h ) : NEW_LINE INDENT return a * h / 2 NEW_LINE DEDENT 
def modp ( n , p ) : NEW_LINE INDENT ret = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ret = ( ret * 2 ) % p NEW_LINE DEDENT return ret NEW_LINE DEDENT 
def add ( x , y ) : NEW_LINE INDENT return x + y NEW_LINE DEDENT 
def fib ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT 
def largest_prime_factor ( n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT while n % i == 0 and n > i : NEW_LINE INDENT n //= i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT 
def sum_to_n ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT result += i NEW_LINE DEDENT return result NEW_LINE DEDENT 
def fibfib ( n : int ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return fibfib ( n - 1 ) + fibfib ( n - 2 ) + fibfib ( n - 3 ) NEW_LINE DEDENT 
def is_multiply_prime ( a ) : NEW_LINE INDENT num = 0 NEW_LINE for i in range ( 2 , a + 1 ) : NEW_LINE INDENT while a % i == 0 and a >= i : NEW_LINE INDENT a //= i NEW_LINE num += 1 NEW_LINE DEDENT DEDENT return num == 3 NEW_LINE DEDENT 
def is_simple_power ( x , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return x == 1 NEW_LINE DEDENT power = 1 NEW_LINE while power < x : NEW_LINE INDENT power *= n NEW_LINE DEDENT return power == x NEW_LINE DEDENT 
def choose_num ( x , y ) : NEW_LINE INDENT if x > y : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if y % 2 == 0 : NEW_LINE INDENT return y NEW_LINE DEDENT if x == y : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return y - 1 NEW_LINE DEDENT 
def is_equal_to_sum_even ( n ) : NEW_LINE INDENT return n % 2 == 0 and n >= 8 NEW_LINE DEDENT 
def special_factorial ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE special_fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE special_fact *= fact NEW_LINE DEDENT return special_fact NEW_LINE DEDENT 
def x_or_y ( n , x , y ) : NEW_LINE INDENT is_prime = n >= 2 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT is_prime = False NEW_LINE break NEW_LINE DEDENT DEDENT if is_prime : NEW_LINE INDENT return x NEW_LINE DEDENT return y NEW_LINE DEDENT 
def right_angle_triangle ( a , b , c ) : NEW_LINE INDENT return a * a == b * b + c * c or b * b == a * a + c * c or c * c == a * a + b * b NEW_LINE DEDENT 
def fast_pow ( n , k ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = fast_pow ( n , k // 2 ) NEW_LINE if k % 2 == 0 : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT return n * temp * temp NEW_LINE DEDENT DEDENT 
def is_palin ( s ) : NEW_LINE INDENT l = len ( s ) // 2 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if s [ i ] != s [ len ( s ) - i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def find_sum ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if not temp < n : NEW_LINE INDENT break NEW_LINE DEDENT temp = i - 1 NEW_LINE num = 1 NEW_LINE while temp < n : NEW_LINE INDENT if temp + i <= n : NEW_LINE INDENT ans += i * num NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( n - temp ) * num NEW_LINE DEDENT temp += i NEW_LINE num += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def get_next_gap ( gap ) : NEW_LINE INDENT gap = gap * 10 // 13 NEW_LINE if gap < 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return gap NEW_LINE DEDENT 
def count_non_decreasing ( n ) : NEW_LINE INDENT k = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count *= k + i - 1 NEW_LINE count //= i NEW_LINE DEDENT return count NEW_LINE DEDENT 
def power ( x , y ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif y % 2 == 0 : NEW_LINE INDENT return power ( x , y // 2 ) * power ( x , y // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return x * power ( x , y // 2 ) * power ( x , y // 2 ) NEW_LINE DEDENT DEDENT 
def power ( x , y ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = power ( x , y // 2 ) NEW_LINE if y % 2 == 0 : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT if y > 0 : NEW_LINE INDENT return x * temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT return temp * temp / x NEW_LINE DEDENT DEDENT DEDENT 
def multiply ( x , y ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if y > 0 : NEW_LINE INDENT return x + multiply ( x , y - 1 ) NEW_LINE DEDENT if y < 0 : NEW_LINE INDENT return - multiply ( x , - y ) NEW_LINE DEDENT DEDENT 
def smallest ( x , y , z ) : NEW_LINE INDENT if not y // x : NEW_LINE INDENT return y if ( not y // z ) else z NEW_LINE DEDENT return x if ( not x // z ) else z NEW_LINE DEDENT 
def is_power_of_four ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT while n != 1 : NEW_LINE INDENT if n % 4 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 4 NEW_LINE DEDENT return True NEW_LINE DEDENT 
def mod_inverse ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE x0 , x1 = 0 , 1 NEW_LINE if m == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT while a > 1 : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if x1 < 0 : NEW_LINE INDENT x1 += m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT 
def cnt_rotations ( s , n ) : NEW_LINE INDENT s2 = s + s NEW_LINE pre = [ 0 ] * ( 2 * n ) NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] NEW_LINE DEDENT if s2 [ i ] == 'a' or s2 [ i ] == 'e' or s2 [ i ] == 'i' or s2 [ i ] == 'o' or s2 [ i ] == 'u' : NEW_LINE INDENT pre [ i ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n - 1 , 2 * n - 1 ) : NEW_LINE INDENT r , l = i , i - n NEW_LINE x1 = pre [ r ] NEW_LINE if l >= 0 : NEW_LINE INDENT x1 -= pre [ l ] NEW_LINE DEDENT r = i - n // 2 NEW_LINE left = pre [ r ] NEW_LINE if l >= 0 : NEW_LINE INDENT left -= pre [ l ] NEW_LINE DEDENT right = x1 - left NEW_LINE if left > right : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def binomial_coeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if k > n - k : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= n - i NEW_LINE res //= i + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT 
def is_prefix ( temp , s ) : NEW_LINE INDENT if len ( temp ) < len ( s ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != temp [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT 
def lexicographically_smallest_string ( s , n ) : NEW_LINE INDENT last_ze = - 1 NEW_LINE ans = "" NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT last_ze = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if i <= last_ze and s [ i ] == '0' : NEW_LINE INDENT ans += s [ i ] NEW_LINE DEDENT elif i > last_ze : NEW_LINE INDENT ans += s [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def calculate_max ( n , m , k ) : NEW_LINE INDENT ans = - 1 NEW_LINE low , high = 0 , m NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE val = 0 NEW_LINE l = k - 1 NEW_LINE r = n - k NEW_LINE val += mid NEW_LINE if mid >= l : NEW_LINE INDENT val += l * ( 2 * mid - l - 1 ) / 2 NEW_LINE DEDENT else : NEW_LINE INDENT val += mid * ( mid - 1 ) / 2 + ( l - mid ) NEW_LINE DEDENT if mid >= r : NEW_LINE INDENT val += r * ( 2 * mid - r - 1 ) / 2 NEW_LINE DEDENT else : NEW_LINE INDENT val += mid * ( mid - 1 ) / 2 + ( r - mid ) NEW_LINE DEDENT if val <= m : NEW_LINE INDENT ans = max ( ans , mid ) NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def find_length ( s , i , j ) : NEW_LINE INDENT required = i NEW_LINE length = 0 NEW_LINE for curr in s : NEW_LINE INDENT if curr == required : NEW_LINE INDENT length += 1 NEW_LINE if required == i : NEW_LINE INDENT required = j NEW_LINE DEDENT else : NEW_LINE INDENT required = i NEW_LINE DEDENT DEDENT DEDENT return length NEW_LINE DEDENT 
def check_reverse ( left_sum , right_sum ) : NEW_LINE INDENT rev = 0 NEW_LINE temp = right_sum NEW_LINE while temp != 0 : NEW_LINE INDENT rev = rev * 10 + temp % 10 NEW_LINE temp //= 10 NEW_LINE DEDENT if rev == left_sum : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT 
def is_composite ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return False NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 5 , n + 1 , 6 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT 
def min_deletion ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE first_idx1 = - 1 NEW_LINE last_idx0 = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT first_idx1 = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT last_idx0 = i NEW_LINE break NEW_LINE DEDENT DEDENT if first_idx1 == - 1 or last_idx0 == - 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT count1 , count0 = 0 , 0 NEW_LINE for i in range ( 0 , last_idx0 ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT DEDENT for i in range ( first_idx1 + 1 , n ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT DEDENT return min ( count0 , count1 ) NEW_LINE DEDENT 
def min_steps ( s , n ) : NEW_LINE INDENT cost = 0 NEW_LINE f = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_ele = ord ( s [ i ] ) - ord ( 'a' ) NEW_LINE smaller = 0 NEW_LINE for j in range ( curr_ele + 1 ) : NEW_LINE INDENT if f [ j ] != 0 : NEW_LINE INDENT smaller += f [ j ] NEW_LINE DEDENT DEDENT if smaller == 0 : NEW_LINE INDENT cost += i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT cost += i - smaller + 1 NEW_LINE DEDENT f [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT return cost NEW_LINE DEDENT 
def number_of_ways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for a in range ( 1 , n ) : NEW_LINE INDENT for b in range ( 1 , n ) : NEW_LINE INDENT c = n - ( a + b ) NEW_LINE if a < b + c and b < a + c and c < a + b : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT 
def slope_of_num ( num , n ) : NEW_LINE INDENT slope = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if num [ i ] > num [ i - 1 ] and num [ i ] > num [ i + 1 ] : NEW_LINE INDENT slope += 1 NEW_LINE DEDENT elif num [ i ] < num [ i - 1 ] and num [ i ] < num [ i + 1 ] : NEW_LINE INDENT slope += 1 NEW_LINE DEDENT DEDENT return slope NEW_LINE DEDENT 
def middle_of_three ( a , b , c ) : NEW_LINE INDENT x = a - b NEW_LINE y = b - c NEW_LINE z = a - c NEW_LINE if x * y > 0 : NEW_LINE INDENT return b NEW_LINE DEDENT elif x * z > 0 : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT 
def count_max_set_bits ( left , right ) : NEW_LINE INDENT while ( left | ( left + 1 ) ) <= right : NEW_LINE INDENT left |= left + 1 NEW_LINE DEDENT return left NEW_LINE DEDENT 
def find_s ( s ) : NEW_LINE INDENT l = 1 NEW_LINE r = s // 2 + 1 NEW_LINE while l <= r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE sum = mid * ( mid + 1 ) / 2 NEW_LINE if sum == s : NEW_LINE INDENT return mid NEW_LINE DEDENT elif sum > s : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT 
def check ( s ) : NEW_LINE INDENT min = sys . maxsize NEW_LINE max = - sys . maxsize NEW_LINE sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ascii = ord ( s [ i ] ) NEW_LINE if ascii < 96 or ascii > 122 : NEW_LINE INDENT return False NEW_LINE DEDENT sum += ascii NEW_LINE if min > ascii : NEW_LINE INDENT min = ascii NEW_LINE DEDENT if max < ascii : NEW_LINE INDENT max = ascii NEW_LINE DEDENT DEDENT min -= 1 NEW_LINE e_sum = max * ( max + 1 ) // 2 - min * ( min + 1 ) // 2 NEW_LINE return sum == e_sum NEW_LINE DEDENT 
def minimum_possible_product ( k ) : NEW_LINE INDENT res = 1 NEW_LINE r = ( 1 << k ) - 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT res *= r - 1 NEW_LINE DEDENT res *= r NEW_LINE return res NEW_LINE DEDENT 
def find_in_grid ( i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return i * i - ( i - 1 ) NEW_LINE DEDENT elif i > j : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT return i * i - ( j - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( i - 1 ) * ( i - 1 ) + 1 + ( j - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT return ( j - 1 ) * ( j - 1 ) + 1 + ( i - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return j * j - ( i - 1 ) NEW_LINE DEDENT DEDENT DEDENT 
def find_min_operations_req_emp_str ( s ) : NEW_LINE INDENT cnt_one = 0 NEW_LINE cnt_zero = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT if cnt_one > 0 : NEW_LINE INDENT cnt_one = cnt_one - 1 NEW_LINE DEDENT cnt_zero = cnt_zero + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if cnt_zero > 0 : NEW_LINE INDENT cnt_zero = cnt_zero - 1 NEW_LINE DEDENT cnt_one = cnt_one + 1 NEW_LINE DEDENT DEDENT return cnt_one + cnt_zero NEW_LINE DEDENT 
def is_reachable ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT while x2 > x1 and y2 > y1 : NEW_LINE INDENT if x2 > y2 : NEW_LINE INDENT x2 %= y2 NEW_LINE DEDENT else : NEW_LINE INDENT y2 %= x2 NEW_LINE DEDENT DEDENT if x2 == x1 : NEW_LINE INDENT return y2 - y1 >= 0 and ( y2 - y1 ) % x1 == 0 NEW_LINE DEDENT elif y2 == y1 : NEW_LINE INDENT return x2 - x1 >= 0 and ( x2 - x1 ) % y1 == 0 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT 
def find_max_soln ( n , x , y ) : NEW_LINE INDENT ans = - sys . maxsize NEW_LINE for k in range ( n + 1 ) : NEW_LINE INDENT if k % x == y : NEW_LINE INDENT ans = max ( ans , k ) NEW_LINE DEDENT DEDENT return ans if ans >= 0 and ans <= n else - 1 NEW_LINE DEDENT 
def number_of_pairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE j = n - 1 NEW_LINE while i < j : NEW_LINE INDENT if ( i + j ) == n : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT 
def min_changes ( s , n ) : NEW_LINE INDENT count , zeros , ones = 0 , 0 , 0 NEW_LINE if s [ 0 ] != '1' : NEW_LINE INDENT count += 1 NEW_LINE ones += 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT if zeros > ones : NEW_LINE INDENT zeros -= 1 NEW_LINE ones += 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT 
def k_visible_from_left ( n , k ) : NEW_LINE INDENT if n == k : NEW_LINE INDENT return 1 NEW_LINE DEDENT if k == 1 : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans *= i NEW_LINE DEDENT return ans NEW_LINE DEDENT return k_visible_from_left ( n - 1 , k - 1 ) + ( n - 1 ) * k_visible_from_left ( n - 1 , k ) NEW_LINE DEDENT 
def find ( n , sum ) : NEW_LINE INDENT if sum > 6 * n or sum < n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT if sum >= 1 and sum <= 6 : NEW_LINE INDENT return 1.0 / 6 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT s = 0 NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT s += find ( n - 1 , sum - i ) / 6 NEW_LINE DEDENT return s NEW_LINE DEDENT 
def bin_coff ( n , r ) : NEW_LINE INDENT val = 1 NEW_LINE if r > ( n - r ) : NEW_LINE INDENT r = n - r NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT val *= n - i NEW_LINE val //= i + 1 NEW_LINE DEDENT return val NEW_LINE DEDENT 
def get_mask ( val ) : NEW_LINE INDENT mask = 0 NEW_LINE if val == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT while val : NEW_LINE INDENT d = val % 10 NEW_LINE mask |= ( 1 << d ) NEW_LINE val //= 10 NEW_LINE DEDENT return mask NEW_LINE DEDENT 
def ways_to_k_adjacent_set_bits ( n , k , current_index , adjacent_set_bits , last_bit ) : NEW_LINE INDENT if current_index == n : NEW_LINE INDENT if adjacent_set_bits == k : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT no_of_ways = 0 NEW_LINE if last_bit == 1 : NEW_LINE INDENT no_of_ways += ways_to_k_adjacent_set_bits ( n , k , current_index + 1 , adjacent_set_bits + 1 , 1 ) NEW_LINE no_of_ways += ways_to_k_adjacent_set_bits ( n , k , current_index + 1 , adjacent_set_bits , 0 ) NEW_LINE DEDENT elif last_bit != 1 : NEW_LINE INDENT no_of_ways += ways_to_k_adjacent_set_bits ( n , k , current_index + 1 , adjacent_set_bits , 1 ) NEW_LINE no_of_ways += ways_to_k_adjacent_set_bits ( n , k , current_index + 1 , adjacent_set_bits , 0 ) NEW_LINE DEDENT return no_of_ways NEW_LINE DEDENT 
def check_func ( i , j , st ) : NEW_LINE INDENT if st [ i ] == '(' and st [ j ] == ')' : NEW_LINE INDENT return 1 NEW_LINE DEDENT if st [ i ] == '(' and st [ j ] == '?' : NEW_LINE INDENT return 1 NEW_LINE DEDENT if st [ i ] == '?' and st [ j ] == ')' : NEW_LINE INDENT return 1 NEW_LINE DEDENT if st [ i ] == '[' and st [ j ] == ']' : NEW_LINE INDENT return 1 NEW_LINE DEDENT if st [ i ] == '[' and st [ j ] == '?' : NEW_LINE INDENT return 1 NEW_LINE DEDENT if st [ i ] == '?' and st [ j ] == ']' : NEW_LINE INDENT return 1 NEW_LINE DEDENT if st [ i ] == '{' and st [ j ] == '}' : NEW_LINE INDENT return 1 NEW_LINE DEDENT if st [ i ] == '{' and st [ j ] == '?' : NEW_LINE INDENT return 1 NEW_LINE DEDENT if st [ i ] == '?' and st [ j ] == '}' : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT 
def find_golomb ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 1 + find_golomb ( n - find_golomb ( find_golomb ( n - 1 ) ) ) NEW_LINE DEDENT 
def all_ones ( s , n ) : NEW_LINE INDENT co = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT co += 1 if s [ i ] == '1' else 0 NEW_LINE DEDENT return co == n NEW_LINE DEDENT 
def pad ( n ) : NEW_LINE INDENT p_prev_prev , p_prev , p_curr , p_next = 1 , 1 , 1 , 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT p_next = p_prev_prev + p_prev NEW_LINE p_prev_prev = p_prev NEW_LINE p_prev = p_curr NEW_LINE p_curr = p_next NEW_LINE DEDENT return p_next NEW_LINE DEDENT 
def odd_length_palindrome ( k ) : NEW_LINE INDENT palin = k NEW_LINE k = k // 10 NEW_LINE while k > 0 : NEW_LINE INDENT rev = k % 10 NEW_LINE palin = palin * 10 + rev NEW_LINE k = k // 10 NEW_LINE DEDENT return palin NEW_LINE DEDENT 
def change_string ( s0 ) : NEW_LINE INDENT s = list ( s0 ) NEW_LINE n = len ( s0 ) NEW_LINE if s [ 0 ] == '?' : NEW_LINE INDENT s [ 0 ] = 'a' NEW_LINE if s [ 0 ] == s [ 1 ] : NEW_LINE INDENT s [ 0 ] = chr ( ord ( s [ 0 ] ) + 1 ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if s [ i ] == '?' : NEW_LINE INDENT s [ i ] = 'a' NEW_LINE if s [ i ] == s [ i - 1 ] : NEW_LINE INDENT s [ i ] = chr ( ord ( s [ i ] ) + 1 ) NEW_LINE DEDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT s [ i ] = chr ( ord ( s [ i ] ) + 1 ) NEW_LINE DEDENT if s [ i ] == s [ i - 1 ] : NEW_LINE INDENT s [ i ] = chr ( ord ( s [ i ] ) + 1 ) NEW_LINE DEDENT DEDENT DEDENT if s [ n - 1 ] == '?' : NEW_LINE INDENT s [ n - 1 ] = 'a' NEW_LINE if s [ n - 1 ] == s [ n - 2 ] : NEW_LINE INDENT s [ n - 1 ] = chr ( ord ( s [ n - 1 ] ) + 1 ) NEW_LINE DEDENT DEDENT return "" . join ( s ) NEW_LINE DEDENT 
def total_hamming_distance ( n ) : NEW_LINE INDENT i , sum = 1 , 0 NEW_LINE while n // i > 0 : NEW_LINE INDENT sum = sum + n // i NEW_LINE i = i * 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT 
def check_bitonic ( s ) : NEW_LINE INDENT i = 1 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ i ] > s [ i - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT if s [ i ] <= s [ i - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i == len ( s ) - 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT j = i + 1 NEW_LINE for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if s [ j ] < s [ j - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT if s [ j ] >= s [ j - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i = j NEW_LINE if i != len ( s ) - 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT 
def ends_with ( str , pat ) : NEW_LINE INDENT pat_len = len ( pat ) NEW_LINE str_len = len ( str ) NEW_LINE if pat_len > str_len : NEW_LINE INDENT return False NEW_LINE DEDENT pat_len -= 1 NEW_LINE str_len -= 1 NEW_LINE while pat_len >= 0 : NEW_LINE INDENT if pat [ pat_len ] != str [ str_len ] : NEW_LINE INDENT return False NEW_LINE DEDENT pat_len -= 1 NEW_LINE str_len -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT 
def get_sum ( n , d ) : NEW_LINE INDENT if n < d : NEW_LINE INDENT return 0 NEW_LINE DEDENT while n % 10 != d : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT k = n // 10 NEW_LINE return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) // 2 NEW_LINE DEDENT 
def balanced_string_by_swapping ( s ) : NEW_LINE INDENT unbalanced_pair = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if unbalanced_pair > 0 and s [ i ] == ']' : NEW_LINE INDENT unbalanced_pair -= 1 NEW_LINE DEDENT elif s [ i ] == '[' : NEW_LINE INDENT unbalanced_pair += 1 NEW_LINE DEDENT DEDENT return ( unbalanced_pair + 1 ) // 2 NEW_LINE DEDENT 
def compute_hash ( s ) : NEW_LINE INDENT p = 31 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE hash_val = 0 NEW_LINE mul = 1 NEW_LINE for ch in s : NEW_LINE INDENT hash_val = ( hash_val + ( ord ( ch ) - ord ( 'a' ) + 1 ) * mul ) % mod NEW_LINE mul = mul * p % mod NEW_LINE DEDENT return hash_val NEW_LINE DEDENT 
def count_of_substring_with_only_ones ( s ) : NEW_LINE INDENT res , count = 0 , 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT count = count + 1 if s [ i ] == '1' else 0 NEW_LINE res = res + count NEW_LINE DEDENT return res NEW_LINE DEDENT 
def composite ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE c = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % j == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if c >= 3 : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT return flag NEW_LINE DEDENT 
def is_div_by_six ( s , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ord ( s [ i ] ) - ord ( 'a' ) + 1 NEW_LINE DEDENT if sum % 3 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT last_digit = ( ord ( s [ n - 1 ] ) - ord ( 'a' ) + 1 ) % 10 NEW_LINE if last_digit % 2 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT 
def is_redundant_braces ( s ) : NEW_LINE INDENT a , b = 0 , 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == '(' and s [ i + 2 ] == ')' : NEW_LINE INDENT return True NEW_LINE DEDENT if s [ i ] == '*' or s [ i ] == '+' or s [ i ] == '-' or s [ i ] == '/' : NEW_LINE INDENT a += 1 NEW_LINE DEDENT if s [ i ] == '(' : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT if b > a : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT 
def count_sub_str ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while i < ( n - 2 ) : NEW_LINE INDENT if s [ i ] == '0' and s [ i + 1 ] == '1' and s [ i + 2 ] == '0' : NEW_LINE INDENT count += 1 NEW_LINE i += 3 NEW_LINE DEDENT elif s [ i ] == '1' and s [ i + 1 ] == '0' and s [ i + 2 ] == '1' : NEW_LINE INDENT count += 1 NEW_LINE i += 3 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT 
def prefix_occurrences ( s ) : NEW_LINE INDENT c = s [ 0 ] NEW_LINE count_c = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == c : NEW_LINE INDENT count_c += 1 NEW_LINE DEDENT DEDENT return count_c NEW_LINE DEDENT 
def is_valid ( s , len ) : NEW_LINE INDENT for i in range ( 1 , len ) : NEW_LINE INDENT if s [ i ] == s [ i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def count ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE d = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d += ord ( s [ i ] ) NEW_LINE DEDENT if d % k == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT prev = ord ( s [ i - k ] ) NEW_LINE d -= prev NEW_LINE d += ord ( s [ i ] ) NEW_LINE if d % k == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT 
def find_substring_count ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if ord ( s [ i ] ) + 1 == ord ( s [ i + 1 ] ) : NEW_LINE INDENT result += 1 NEW_LINE while i < n - 1 and ord ( s [ i ] ) + 1 == ord ( s [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT 
def find ( s1 , s2 ) : NEW_LINE INDENT len1 = len ( s1 ) NEW_LINE len2 = len ( s2 ) NEW_LINE if len1 != len2 : NEW_LINE INDENT return False NEW_LINE DEDENT d = [ 0 ] * len1 NEW_LINE d [ 0 ] = ord ( s2 [ 0 ] ) - ord ( s1 [ 0 ] ) NEW_LINE for i in range ( 1 , len1 ) : NEW_LINE INDENT if s1 [ i ] > s2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = ord ( s2 [ i ] ) - ord ( s1 [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len1 - 1 ) : NEW_LINE INDENT if d [ i ] < d [ i + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def is_in_given_base ( s , bas ) : NEW_LINE INDENT if bas > 16 : NEW_LINE INDENT return False NEW_LINE DEDENT elif bas <= 10 : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if not ( ord ( s [ i ] ) >= ord ( '0' ) and ord ( s [ i ] ) < ord ( '0' ) + bas ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if not ( ( ord ( s [ i ] ) >= ord ( '0' ) and ord ( s [ i ] ) < ord ( '0' ) + bas ) or ( ord ( s [ i ] ) >= ord ( 'A' ) and ord ( s [ i ] ) < ( ord ( 'A' ) + bas - 10 ) ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT 
def count_non_empty_substr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE return n * ( n + 1 ) // 2 NEW_LINE DEDENT 
def even_decimal_value ( s , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT decimal_value = 0 NEW_LINE power_of_2 = 1 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT decimal_value += ( ord ( s [ k ] ) - ord ( '0' ) ) * power_of_2 NEW_LINE power_of_2 *= 2 NEW_LINE DEDENT if decimal_value % 2 == 0 : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT 
def calculate ( s ) : NEW_LINE INDENT ans = 6 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT for k in range ( 10 ) : NEW_LINE INDENT for l in range ( 10 ) : NEW_LINE INDENT for m in range ( 10 ) : NEW_LINE INDENT for n in range ( 10 ) : NEW_LINE INDENT if i + j + k == l + m + n : NEW_LINE INDENT c = 0 NEW_LINE if i != ord ( s [ 0 ] ) - ord ( '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if j != ord ( s [ 1 ] ) - ord ( '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if k != ord ( s [ 2 ] ) - ord ( '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if l != ord ( s [ 3 ] ) - ord ( '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if m != ord ( s [ 4 ] ) - ord ( '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if n != ord ( s [ 5 ] ) - ord ( '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if c < ans : NEW_LINE INDENT ans = c NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT 
def xor_zero ( s ) : NEW_LINE INDENT one_count = 0 NEW_LINE zero_count = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT one_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero_count += 1 NEW_LINE DEDENT DEDENT if one_count % 2 == 0 : NEW_LINE INDENT return zero_count NEW_LINE DEDENT return one_count NEW_LINE DEDENT 
def even_length ( n ) : NEW_LINE INDENT res = n NEW_LINE for j in range ( len ( n ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT res += n [ j ] NEW_LINE DEDENT return res NEW_LINE DEDENT 
def count_substring_with_equal_ends ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if s [ i ] == s [ j ] : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT 
def normal_slope ( a , b , x1 , y1 ) : NEW_LINE INDENT g = a / 2 NEW_LINE f = b / 2 NEW_LINE if g - x1 == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT slope = ( f - y1 ) / ( g - x1 ) NEW_LINE if slope == 0 : NEW_LINE INDENT return - 2 NEW_LINE DEDENT return slope NEW_LINE DEDENT 
def orthogonality ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT dsquare = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) NEW_LINE if dsquare == r1 * r1 + r2 * r2 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT 
def find_area_shaded ( a ) : NEW_LINE INDENT sq_area = a * a NEW_LINE semi_circle_area = ( 3.14 * ( a * a ) / 8 ) NEW_LINE shaded_area = 4 * semi_circle_area - sq_area NEW_LINE return shaded_area NEW_LINE DEDENT 
def factorial ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , a + b + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT for i in range ( 1 , a + 1 ) : NEW_LINE INDENT res = res // i NEW_LINE DEDENT for i in range ( 1 , b + 1 ) : NEW_LINE INDENT res = res // i NEW_LINE DEDENT return res NEW_LINE DEDENT 
def factor_tree ( n ) : NEW_LINE INDENT height = 0 NEW_LINE while n > 1 : NEW_LINE INDENT flag = False NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT n = n // i NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT height += 1 NEW_LINE if not flag : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return height NEW_LINE DEDENT 
def find_if_possible ( n , s , x ) : NEW_LINE INDENT if s >= x and s % 2 == x % 2 : NEW_LINE INDENT if n >= 3 : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT if s == x : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT else : NEW_LINE INDENT return "No" NEW_LINE DEDENT DEDENT if n == 2 : NEW_LINE INDENT c = ( s - x ) // 2 NEW_LINE a = c NEW_LINE b = c NEW_LINE a = a + x NEW_LINE if ( a ^ b ) == x : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT else : NEW_LINE INDENT return "No" NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT return "No" NEW_LINE DEDENT DEDENT 
def maximum_triplet_xor ( a , b , c ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 30 , - 1 , - 1 ) : NEW_LINE INDENT cur = 1 << i NEW_LINE if a >= cur : NEW_LINE INDENT ans += cur NEW_LINE a -= cur NEW_LINE DEDENT elif b >= cur : NEW_LINE INDENT ans += cur NEW_LINE b -= cur NEW_LINE DEDENT elif c >= cur : NEW_LINE INDENT ans += cur NEW_LINE c -= cur NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def item_type ( n ) : NEW_LINE INDENT count = 0 NEW_LINE day = 1 NEW_LINE while count + day * ( day + 1 ) // 2 < n : NEW_LINE INDENT count += day * ( day + 1 ) // 2 NEW_LINE day += 1 NEW_LINE DEDENT for type in range ( day , - 1 , - 1 ) : NEW_LINE INDENT count += type NEW_LINE if count >= n : NEW_LINE INDENT return type NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT 
def max_gcd_in_range ( l , r ) : NEW_LINE INDENT ans = 1 NEW_LINE for z in range ( r , 0 , - 1 ) : NEW_LINE INDENT if r // z - ( l - 1 ) // z > 1 : NEW_LINE INDENT ans = z NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def sum_of_digits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum += ( n % 10 ) NEW_LINE n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT 
def is_rep_unit_num ( n , b ) : NEW_LINE INDENT length = 0 NEW_LINE count_one = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % b NEW_LINE length += 1 NEW_LINE if r == 1 : NEW_LINE INDENT count_one += 1 NEW_LINE DEDENT n = n // b NEW_LINE DEDENT return count_one >= 3 and count_one == length NEW_LINE DEDENT 
def is_straigh_line_num ( n ) : NEW_LINE INDENT if ( n <= 99 ) : NEW_LINE INDENT return False NEW_LINE DEDENT s = str ( n ) NEW_LINE d = ord ( s [ 1 ] ) - ord ( s [ 0 ] ) NEW_LINE for i in range ( 2 , len ( s ) ) : NEW_LINE INDENT if ord ( s [ i ] ) - ord ( s [ i - 1 ] ) != d : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def get_count ( d , n ) : NEW_LINE INDENT no = n // d NEW_LINE result = no NEW_LINE for p in range ( 2 , no + 1 ) : NEW_LINE INDENT if p * p > no : NEW_LINE INDENT break NEW_LINE DEDENT if no % p == 0 : NEW_LINE INDENT while no % p == 0 : NEW_LINE INDENT no //= p NEW_LINE DEDENT result -= result // p NEW_LINE DEDENT DEDENT if no > 1 : NEW_LINE INDENT result -= result // no NEW_LINE DEDENT return result NEW_LINE DEDENT 
def is_even_parity ( x ) : NEW_LINE INDENT parity = 0 NEW_LINE while x != 0 : NEW_LINE INDENT if x & 1 : NEW_LINE INDENT parity += 1 NEW_LINE DEDENT x = x >> 1 NEW_LINE DEDENT if parity % 2 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT 
def is_perfect ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if n % i == 0 : NEW_LINE INDENT if i * i != n : NEW_LINE INDENT sum = sum + i + n // i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT DEDENT if sum == n and n != 1 : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT 
def log_a_to_base_b ( a , b ) : NEW_LINE INDENT return 1 + log_a_to_base_b ( a // b , b ) if a > ( b - 1 ) else 0 NEW_LINE DEDENT 
def using_binary_search ( start , end , n , s ) : NEW_LINE INDENT if start >= end : NEW_LINE INDENT return start NEW_LINE DEDENT mid = start + ( end - start ) // 2 NEW_LINE total_sum = ( n * ( n + 1 ) ) // 2 NEW_LINE mid_sum = ( mid * ( mid + 1 ) ) // 2 NEW_LINE if total_sum - mid_sum <= s : NEW_LINE INDENT return using_binary_search ( start , mid , n , s ) NEW_LINE DEDENT return using_binary_search ( mid + 1 , end , n , s ) NEW_LINE DEDENT 
def min_int ( s ) : NEW_LINE INDENT s1 = list ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ord ( s1 [ i ] ) >= ord ( '5' ) : NEW_LINE INDENT s1 [ i ] = chr ( ord ( '9' ) - ord ( s1 [ i ] ) + ord ( '0' ) ) NEW_LINE DEDENT DEDENT if s1 [ 0 ] == '0' : NEW_LINE INDENT s1 [ 0 ] = '9' NEW_LINE DEDENT return "" . join ( s1 ) NEW_LINE DEDENT 
def count_triplets ( a , b , c ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , a + 1 ) : NEW_LINE INDENT for j in range ( 1 , b + 1 ) : NEW_LINE INDENT for k in range ( 1 , c + 1 ) : NEW_LINE INDENT if i * k > j * j : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT 
def topsy_turvy ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == '2' or s [ i ] == '4' or s [ i ] == '5' or s [ i ] == '6' or s [ i ] == '7' or s [ i ] == '9' : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def sum_of_last_dig ( n , m ) : NEW_LINE INDENT sum = 0 NEW_LINE k = n // m NEW_LINE arr = [ 0 ] * 10 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT arr [ i ] = m * ( i + 1 ) % 10 NEW_LINE sum += arr [ i ] NEW_LINE DEDENT rem = k % 10 NEW_LINE ans = k // 10 * sum NEW_LINE for i in range ( rem ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT 
def total_pay ( total_items , price_of_one_item , n , m ) : NEW_LINE INDENT free_items = 0 NEW_LINE actual = 0 NEW_LINE free_items = total_items // ( n + m ) NEW_LINE actual = total_items - free_items NEW_LINE amount = actual * price_of_one_item NEW_LINE return amount NEW_LINE DEDENT 
def min_operations ( x , y , p , q ) : NEW_LINE INDENT if y % x != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = y // x NEW_LINE a = 0 NEW_LINE while d % p == 0 : NEW_LINE INDENT d //= p NEW_LINE a += 1 NEW_LINE DEDENT b = 0 NEW_LINE while d % q == 0 : NEW_LINE INDENT d //= q NEW_LINE b += 1 NEW_LINE DEDENT if d != 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return a + b NEW_LINE DEDENT 
def is_mersenne ( n ) : NEW_LINE INDENT while n != 0 : NEW_LINE INDENT r = n % 2 NEW_LINE if r == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT n //= 2 NEW_LINE DEDENT return True NEW_LINE DEDENT 
def find_third_digit ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 if n & 1 else 6 NEW_LINE DEDENT 
def is_odd_length ( num ) : NEW_LINE INDENT count = 0 NEW_LINE while num > 0 : NEW_LINE INDENT num = num // 10 NEW_LINE count += 1 NEW_LINE DEDENT if count % 2 != 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT 
def check_is_possible ( l , r , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if i % k == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count > 1 NEW_LINE DEDENT 
def bytes ( kilobytes ) : NEW_LINE INDENT b = kilobytes * 1024 NEW_LINE return b NEW_LINE DEDENT 
def octahedral_num ( n ) : NEW_LINE INDENT return n * ( 2 * n * n + 1 ) // 3 NEW_LINE DEDENT 
def check_equal ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] != '1' and s [ i ] != '0' and s [ i ] != '8' : NEW_LINE INDENT return "No" NEW_LINE DEDENT DEDENT start = 0 NEW_LINE end = len ( s ) - 1 NEW_LINE while start < end : NEW_LINE INDENT if s [ start ] != s [ end ] : NEW_LINE INDENT return "No" NEW_LINE DEDENT start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT return "Yes" NEW_LINE DEDENT 
def is_undulating ( n ) : NEW_LINE INDENT if len ( n ) <= 2 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , len ( n ) ) : NEW_LINE INDENT if n [ i - 2 ] != n [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def first_digit ( n ) : NEW_LINE INDENT while n >= 10 : NEW_LINE INDENT n //= 10 NEW_LINE DEDENT return n NEW_LINE DEDENT 
def count_digit ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 + count_digit ( n // 10 ) NEW_LINE DEDENT 
def is_divisible_by_5 ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE return s [ n - 1 ] == '0' or s [ n - 1 ] == '5' NEW_LINE DEDENT 
def inv ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE x0 , x1 = 0 , 1 NEW_LINE if m == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT while a > 1 : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if x1 < 0 : NEW_LINE INDENT x1 = x1 + m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT 
def only_first_and_last_are_set ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( n - 1 ) & ( n - 2 ) ) == 0 NEW_LINE DEDENT 
def divide ( dividend , divisor ) : NEW_LINE INDENT sign = - 1 if ( ( dividend < 0 ) ^ ( divisor < 0 ) ) else 1 NEW_LINE dividend = abs ( dividend ) NEW_LINE divisor = abs ( divisor ) NEW_LINE quotient = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT if temp + ( divisor << i ) <= dividend : NEW_LINE INDENT temp += divisor << i NEW_LINE quotient |= 1 << i NEW_LINE DEDENT DEDENT if sign == - 1 : NEW_LINE INDENT quotient = - quotient NEW_LINE DEDENT return quotient NEW_LINE DEDENT 
def find_profession ( level , pos ) : NEW_LINE INDENT if level == 1 : NEW_LINE INDENT return 'e' NEW_LINE DEDENT if find_profession ( level - 1 , ( pos + 1 ) // 2 ) == 'd' : NEW_LINE INDENT return 'd' if pos % 2 else 'e' NEW_LINE DEDENT return 'e' if pos % 2 else 'd' NEW_LINE DEDENT
