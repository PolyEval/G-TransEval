def has_close_elements ( numbers , threshold ) : NEW_LINE INDENT for i in range ( len ( numbers ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( numbers ) ) : NEW_LINE INDENT distance = abs ( numbers [ i ] - numbers [ j ] ) NEW_LINE if distance < threshold : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT 
def truncate_number ( number ) : NEW_LINE INDENT return number % 1 NEW_LINE DEDENT 
def below_zero ( operations ) : NEW_LINE INDENT balance = 0 NEW_LINE for op in operations : NEW_LINE INDENT balance += op NEW_LINE if balance < 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT 
def mean_absolute_deviation ( numbers ) : NEW_LINE INDENT sum_num = 0 NEW_LINE for num in numbers : NEW_LINE INDENT sum_num += num NEW_LINE DEDENT mean = sum_num / len ( numbers ) NEW_LINE sum_abs_diff = 0 NEW_LINE for num in numbers : NEW_LINE INDENT sum_abs_diff += abs ( num - mean ) NEW_LINE DEDENT return sum_abs_diff / len ( numbers ) NEW_LINE DEDENT 
def intersperse ( numbers , delimiter ) : NEW_LINE INDENT result = [ ] NEW_LINE if not numbers : NEW_LINE INDENT return result NEW_LINE DEDENT for i in range ( len ( numbers ) - 1 ) : NEW_LINE INDENT result . append ( numbers [ i ] ) NEW_LINE result . append ( delimiter ) NEW_LINE DEDENT result . append ( numbers [ - 1 ] ) NEW_LINE return result NEW_LINE DEDENT 
def sum_product ( numbers ) : NEW_LINE INDENT sum_value = 0 NEW_LINE prod_value = 1 NEW_LINE for n in numbers : NEW_LINE INDENT sum_value += n NEW_LINE prod_value *= n NEW_LINE DEDENT return [ sum_value , prod_value ] NEW_LINE DEDENT 
def all_prefixes ( string ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( 1 , len ( string ) + 1 ) : NEW_LINE INDENT result . append ( string [ : i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT 
def parse_music ( music_string ) : NEW_LINE INDENT current = [ ] NEW_LINE result = [ ] NEW_LINE for i in range ( len ( music_string ) + 1 ) : NEW_LINE INDENT if i == len ( music_string ) or music_string [ i ] == " " : NEW_LINE INDENT if "" . join ( current ) == "o" : NEW_LINE INDENT result . append ( 4 ) NEW_LINE DEDENT if "" . join ( current ) == "o|" : NEW_LINE INDENT result . append ( 2 ) NEW_LINE DEDENT if "" . join ( current ) == ".|" : NEW_LINE INDENT result . append ( 1 ) NEW_LINE DEDENT current . clear ( ) NEW_LINE DEDENT else : NEW_LINE INDENT current . append ( music_string [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def strlen ( s ) : NEW_LINE INDENT return len ( s ) NEW_LINE DEDENT 
def factorize ( n ) : NEW_LINE INDENT factors = [ ] NEW_LINE i = 2 NEW_LINE while i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT factors . append ( i ) NEW_LINE n //= i NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return factors NEW_LINE DEDENT 
def concatenate ( strings ) : NEW_LINE INDENT result = [ ] NEW_LINE for s in strings : NEW_LINE INDENT result . append ( s ) NEW_LINE DEDENT return "" . join ( result ) NEW_LINE DEDENT 
def get_positive ( l ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT if l [ i ] > 0 : NEW_LINE INDENT result . append ( l [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def sort_even ( l ) : NEW_LINE INDENT evens = [ ] NEW_LINE for i in range ( 0 , len ( l ) , 2 ) : NEW_LINE INDENT evens . append ( l [ i ] ) NEW_LINE DEDENT evens . sort ( ) NEW_LINE result = [ ] NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT result . append ( evens [ i // 2 ] ) NEW_LINE DEDENT if i % 2 == 1 : NEW_LINE INDENT result . append ( l [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def decode_cyclic ( s ) : NEW_LINE INDENT output = [ ] NEW_LINE i = 0 NEW_LINE while i <= len ( s ) - 3 : NEW_LINE INDENT x = s [ i + 2 ] + s [ i : i + 2 ] NEW_LINE output . append ( x ) NEW_LINE i += 3 NEW_LINE DEDENT return "" . join ( output ) + s [ i : ] NEW_LINE DEDENT 
def car_race_collision ( n ) : NEW_LINE INDENT return n ** 2 NEW_LINE DEDENT 
def incr_list ( l ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in l : NEW_LINE INDENT result . append ( i + 1 ) NEW_LINE DEDENT return result NEW_LINE DEDENT 
def pairs_sum_to_zero ( l ) : NEW_LINE INDENT for i in range ( len ( l ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( l ) ) : NEW_LINE INDENT if l [ i ] + l [ j ] == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT 
def change_base ( x , b ) : NEW_LINE INDENT ret = [ ] NEW_LINE while x > 0 : NEW_LINE INDENT ret . insert ( 0 , str ( x % b ) ) NEW_LINE x //= b NEW_LINE DEDENT return "" . join ( ret ) NEW_LINE DEDENT 
def median ( l ) : NEW_LINE INDENT l . sort ( ) NEW_LINE if len ( l ) % 2 == 1 : NEW_LINE INDENT return l [ len ( l ) // 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT return ( l [ len ( l ) // 2 - 1 ] + l [ len ( l ) // 2 ] ) / 2.0 NEW_LINE DEDENT DEDENT 
def decode_shift ( s : str ) : NEW_LINE INDENT result = [ ] NEW_LINE for ch in s : NEW_LINE INDENT w = ( ord ( ch ) + 21 - ord ( "a" ) ) % 26 + ord ( "a" ) NEW_LINE result . append ( chr ( w ) ) NEW_LINE DEDENT return "" . join ( result ) NEW_LINE DEDENT 
def below_threshold ( l , t ) : NEW_LINE INDENT for n in l : NEW_LINE INDENT if n >= t : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def correct_bracketing ( brackets ) : NEW_LINE INDENT depth = 0 NEW_LINE for b in brackets : NEW_LINE INDENT if b == "<" : NEW_LINE INDENT depth += 1 NEW_LINE DEDENT else : NEW_LINE INDENT depth -= 1 NEW_LINE DEDENT if depth < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return depth == 0 NEW_LINE DEDENT 
def monotonic ( l ) : NEW_LINE INDENT incr = 0 NEW_LINE decr = 0 NEW_LINE for i in range ( 1 , len ( l ) ) : NEW_LINE INDENT if l [ i ] > l [ i - 1 ] : NEW_LINE INDENT incr = 1 NEW_LINE DEDENT if l [ i ] < l [ i - 1 ] : NEW_LINE INDENT decr = 1 NEW_LINE DEDENT DEDENT return incr + decr != 2 NEW_LINE DEDENT 
def derivative ( xs ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( 1 , len ( xs ) ) : NEW_LINE INDENT result . append ( i * xs [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT 
def vowels_count ( s ) : NEW_LINE INDENT vowels = "aeiouAEIOU" NEW_LINE count = 0 NEW_LINE for ch in s : NEW_LINE INDENT if ch in vowels : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if s [ - 1 ] == "y" or s [ - 1 ] == "Y" : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT 
def digit_sum ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for c in s : NEW_LINE INDENT if c . isupper ( ) : NEW_LINE INDENT sum += ord ( c ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT 
def fruit_distribution ( s , n ) : NEW_LINE INDENT num1 = [ ] NEW_LINE num2 = [ ] NEW_LINE flag = False NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] . isdigit ( ) : NEW_LINE INDENT if not flag : NEW_LINE INDENT num1 . append ( s [ i ] ) NEW_LINE DEDENT if flag : NEW_LINE INDENT num2 . append ( s [ i ] ) NEW_LINE DEDENT DEDENT elif not flag and len ( num1 ) > 0 : NEW_LINE INDENT flag = True NEW_LINE DEDENT DEDENT return n - int ( "" . join ( num1 ) ) - int ( "" . join ( num2 ) ) NEW_LINE DEDENT 
def pluck ( arr ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT if not result : NEW_LINE INDENT result . append ( arr [ i ] ) NEW_LINE result . append ( i ) NEW_LINE DEDENT elif arr [ i ] < result [ 0 ] : NEW_LINE INDENT result [ 0 ] = arr [ i ] NEW_LINE result [ 1 ] = i NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT 
def strange_sort_list ( lst ) : NEW_LINE INDENT res = [ ] NEW_LINE lst . sort ( ) NEW_LINE l = 0 NEW_LINE r = len ( lst ) - 1 NEW_LINE while l < r : NEW_LINE INDENT res . append ( lst [ l ] ) NEW_LINE l += 1 NEW_LINE res . append ( lst [ r ] ) NEW_LINE r -= 1 NEW_LINE DEDENT if l == r : NEW_LINE INDENT res . append ( lst [ l ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT 
def triangle_area ( a , b , c ) : NEW_LINE INDENT if a + b <= c or a + c <= b or b + c <= a : NEW_LINE INDENT return - 1.0 NEW_LINE DEDENT s = ( a + b + c ) / 2 NEW_LINE area = math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) NEW_LINE return area NEW_LINE DEDENT 
def will_it_fly ( q , w ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( q ) ) : NEW_LINE INDENT if q [ i ] != q [ - i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT sum += q [ i ] NEW_LINE DEDENT return sum <= w NEW_LINE DEDENT 
def is_cube ( a ) : NEW_LINE INDENT a = abs ( a ) NEW_LINE i = round ( a ** ( 1.0 / 3 ) ) NEW_LINE return i ** 3 == a NEW_LINE DEDENT 
def hex_key ( num ) : NEW_LINE INDENT key = "2357BD" NEW_LINE total = 0 NEW_LINE for c in num : NEW_LINE INDENT if c in key : NEW_LINE INDENT total += 1 NEW_LINE DEDENT DEDENT return total NEW_LINE DEDENT 
def decimal_to_binary ( dec ) : NEW_LINE INDENT ans = [ ] NEW_LINE if dec != 0 : NEW_LINE INDENT while dec > 0 : NEW_LINE INDENT ans . insert ( 0 , str ( dec % 2 ) ) NEW_LINE dec //= 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans += "0" NEW_LINE DEDENT return "db" + "" . join ( ans ) + "db" NEW_LINE DEDENT 
def prime_length ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE if l < 2 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , l ) : NEW_LINE INDENT if l % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def starts_one_ends ( n ) : NEW_LINE INDENT if n < 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 18 * ( 10 ** ( n - 2 ) ) NEW_LINE DEDENT 
def add ( lst ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , len ( lst ) , 2 ) : NEW_LINE INDENT if lst [ i ] % 2 == 0 : NEW_LINE INDENT sum += lst [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT 
def get_row ( lst , x ) : NEW_LINE INDENT coords = [ ] NEW_LINE for i in range ( len ( lst ) ) : NEW_LINE INDENT for j in range ( len ( lst [ i ] ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if lst [ i ] [ j ] == x : NEW_LINE INDENT coords . append ( [ i , j ] ) NEW_LINE DEDENT DEDENT DEDENT return coords NEW_LINE DEDENT 
def next_smallest ( lst ) : NEW_LINE INDENT lst . sort ( ) NEW_LINE for i in range ( 1 , len ( lst ) ) : NEW_LINE INDENT if lst [ i ] != lst [ i - 1 ] : NEW_LINE INDENT return lst [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT 
def any_int ( a , b , c ) : NEW_LINE INDENT if round ( a ) != a or round ( b ) != b or round ( c ) != c : NEW_LINE INDENT return False NEW_LINE DEDENT return a + b == c or a + c == b or b + c == a NEW_LINE DEDENT 
def count_up_to ( n ) : NEW_LINE INDENT primes = [ ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT is_prime = True NEW_LINE for j in range ( 2 , i ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT is_prime = False NEW_LINE break NEW_LINE DEDENT DEDENT if is_prime : NEW_LINE INDENT primes . append ( i ) NEW_LINE DEDENT DEDENT return primes NEW_LINE DEDENT 
def closest_integer ( value ) : NEW_LINE INDENT w = float ( value ) NEW_LINE return round ( w ) NEW_LINE DEDENT 
def make_a_pile ( n ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT result . append ( n + 2 * i ) NEW_LINE DEDENT return result NEW_LINE DEDENT 
def words_string ( s ) : NEW_LINE INDENT current = [ ] NEW_LINE words = [ ] NEW_LINE for i in range ( len ( s ) + 1 ) : NEW_LINE INDENT if i == len ( s ) or s [ i ] == " " or s [ i ] == "," : NEW_LINE INDENT if len ( current ) > 0 : NEW_LINE INDENT words . append ( "" . join ( current ) ) NEW_LINE current . clear ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT current . append ( s [ i ] ) NEW_LINE DEDENT DEDENT return words NEW_LINE DEDENT 
def rounded_avg ( n , m ) : NEW_LINE INDENT if n > m : NEW_LINE INDENT return - 1 NEW_LINE DEDENT num = ( n + m ) // 2 NEW_LINE ret = [ ] NEW_LINE while num > 0 : NEW_LINE INDENT ret . insert ( 0 , str ( num % 2 ) ) NEW_LINE num //= 2 NEW_LINE DEDENT return "" . join ( ret ) NEW_LINE DEDENT 
def unique_digits ( x ) : NEW_LINE INDENT digits = [ ] NEW_LINE for n in x : NEW_LINE INDENT is_unique = True NEW_LINE for c in str ( n ) : NEW_LINE INDENT if ord ( c ) % 2 == 0 : NEW_LINE INDENT is_unique = False NEW_LINE break NEW_LINE DEDENT DEDENT if is_unique : NEW_LINE INDENT digits . append ( n ) NEW_LINE DEDENT DEDENT digits . sort ( ) NEW_LINE return digits NEW_LINE DEDENT 
def count_nums ( arr ) : NEW_LINE INDENT num = 0 NEW_LINE for n in arr : NEW_LINE INDENT neg = - 1 if n < 0 else 1 NEW_LINE n = abs ( n ) NEW_LINE digits = [ ] NEW_LINE for c in str ( n ) : NEW_LINE INDENT digits . append ( ord ( c ) - ord ( "0" ) ) NEW_LINE DEDENT digits [ 0 ] *= neg NEW_LINE sum = 0 NEW_LINE for d in digits : NEW_LINE INDENT sum += d NEW_LINE DEDENT if sum > 0 : NEW_LINE INDENT num += 1 NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT 
def move_one_ball ( arr ) : NEW_LINE INDENT if not arr : NEW_LINE INDENT return True NEW_LINE DEDENT num = 0 NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT num += 1 NEW_LINE DEDENT DEDENT if arr [ - 1 ] > arr [ 0 ] : NEW_LINE INDENT num += 1 NEW_LINE DEDENT if num < 2 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT 
def exchange ( lst1 , lst2 ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for n in lst1 : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT for n in lst2 : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if even >= odd : NEW_LINE INDENT return "YES" NEW_LINE DEDENT return "NO" NEW_LINE DEDENT 
def odd_count ( lst ) : NEW_LINE INDENT results = [ ] NEW_LINE original_str = "the number of odd elements in the string i of the input." NEW_LINE for s in lst : NEW_LINE INDENT sum = 0 NEW_LINE for d in s : NEW_LINE INDENT if d . isdigit ( ) and ord ( d ) % 2 == 1 : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT DEDENT result = [ ] NEW_LINE for c in original_str : NEW_LINE INDENT if c == "i" : NEW_LINE INDENT result . append ( str ( sum ) ) NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( c ) NEW_LINE DEDENT DEDENT results . append ( "" . join ( result ) ) NEW_LINE DEDENT return results NEW_LINE DEDENT 
def minSubArraySum ( nums ) : NEW_LINE INDENT min_sum = sys . maxsize NEW_LINE sum = 0 NEW_LINE for num in nums : NEW_LINE INDENT sum += num NEW_LINE if min_sum > sum : NEW_LINE INDENT min_sum = sum NEW_LINE DEDENT if sum > 0 : NEW_LINE INDENT sum = 0 NEW_LINE DEDENT DEDENT return min_sum NEW_LINE DEDENT 
def max_fill ( grid , capacity ) : NEW_LINE INDENT res = 0 NEW_LINE for well in grid : NEW_LINE INDENT sum = 0 NEW_LINE for n in well : NEW_LINE INDENT sum += n NEW_LINE DEDENT if sum > 0 : NEW_LINE INDENT res += ( sum - 1 ) // capacity + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT 
def select_words ( s , n ) : NEW_LINE INDENT vowels = "aeiouAEIOU" NEW_LINE current = [ ] NEW_LINE result = [ ] NEW_LINE consonant_num = 0 NEW_LINE for i in range ( len ( s ) + 1 ) : NEW_LINE INDENT if i == len ( s ) or s [ i ] == " " : NEW_LINE INDENT if consonant_num == n : NEW_LINE INDENT result . append ( "" . join ( current ) ) NEW_LINE DEDENT current . clear ( ) NEW_LINE consonant_num = 0 NEW_LINE DEDENT else : NEW_LINE INDENT current . append ( s [ i ] ) NEW_LINE if s [ i ] not in vowels : NEW_LINE INDENT consonant_num += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT 
def solution ( lst ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , len ( lst ) , 2 ) : NEW_LINE INDENT if lst [ i ] % 2 == 1 : NEW_LINE INDENT sum += lst [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT 
def add_elements ( arr , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if - 99 <= arr [ i ] <= 99 : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT 
def get_odd_collatz ( n ) : NEW_LINE INDENT odd_collatz = [ ] NEW_LINE while n > 1 : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT odd_collatz . append ( n ) NEW_LINE n = n * 3 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT n //= 2 NEW_LINE DEDENT DEDENT odd_collatz . append ( 1 ) NEW_LINE odd_collatz . sort ( ) NEW_LINE return odd_collatz NEW_LINE DEDENT 
def is_sorted ( lst ) : NEW_LINE INDENT for i in range ( 1 , len ( lst ) ) : NEW_LINE INDENT if lst [ i ] < lst [ i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT if i >= 2 and lst [ i ] == lst [ i - 1 ] and lst [ i ] == lst [ i - 2 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def intersection ( interval1 , interval2 ) : NEW_LINE INDENT inter1 = max ( interval1 [ 0 ] , interval2 [ 0 ] ) NEW_LINE inter2 = min ( interval1 [ 1 ] , interval2 [ 1 ] ) NEW_LINE l = inter2 - inter1 NEW_LINE if l < 2 : NEW_LINE INDENT return "NO" NEW_LINE DEDENT for i in range ( 2 , l ) : NEW_LINE INDENT if l % i == 0 : NEW_LINE INDENT return "NO" NEW_LINE DEDENT DEDENT return "YES" NEW_LINE DEDENT 
def prod_signs ( arr ) : NEW_LINE INDENT if not arr : NEW_LINE INDENT return - 32768 NEW_LINE DEDENT sum = 0 NEW_LINE prods = 1 NEW_LINE for i in arr : NEW_LINE INDENT sum += abs ( i ) NEW_LINE if i == 0 : NEW_LINE INDENT prods = 0 NEW_LINE DEDENT if i < 0 : NEW_LINE INDENT prods = - prods NEW_LINE DEDENT DEDENT return sum * prods NEW_LINE DEDENT 
def minPath ( grid , k ) : NEW_LINE INDENT n = len ( grid ) NEW_LINE min_num = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if grid [ i ] [ j ] == 1 : NEW_LINE INDENT tmp = [ ] NEW_LINE if i != 0 : NEW_LINE INDENT tmp . append ( grid [ i - 1 ] [ j ] ) NEW_LINE DEDENT if j != 0 : NEW_LINE INDENT tmp . append ( grid [ i ] [ j - 1 ] ) NEW_LINE DEDENT if i != n - 1 : NEW_LINE INDENT tmp . append ( grid [ i + 1 ] [ j ] ) NEW_LINE DEDENT if j != n - 1 : NEW_LINE INDENT tmp . append ( grid [ i ] [ j + 1 ] ) NEW_LINE DEDENT min_num = min ( tmp ) NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( min_num ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def digits ( n ) : NEW_LINE INDENT prod = 1 NEW_LINE for digit in str ( n ) : NEW_LINE INDENT if ord ( digit ) % 2 == 1 : NEW_LINE INDENT if prod == 0 : NEW_LINE INDENT prod == 1 NEW_LINE DEDENT prod *= ord ( digit ) - ord ( "0" ) NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT 
def is_nested ( s ) : NEW_LINE INDENT count = 0 NEW_LINE max_count = 0 NEW_LINE for ch in s : NEW_LINE INDENT if ch == "[" : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ch == "]" : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if count < 0 : NEW_LINE INDENT count = 0 NEW_LINE DEDENT if count > max_count : NEW_LINE INDENT max_count = count NEW_LINE DEDENT if count <= max_count - 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT 
def sum_squares ( lst ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in lst : NEW_LINE INDENT sum += math . ceil ( i ) * math . ceil ( i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT 
def can_arrange ( arr ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] <= i : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT 
def largest_smallest_integers ( lst ) : NEW_LINE INDENT max_neg , min_pos = 0 , 0 NEW_LINE for n in lst : NEW_LINE INDENT if n < 0 and ( max_neg == 0 or n > max_neg ) : NEW_LINE INDENT max_neg = n NEW_LINE DEDENT if n > 0 and ( min_pos == 0 or n < min_pos ) : NEW_LINE INDENT min_pos = n NEW_LINE DEDENT DEDENT return [ max_neg , min_pos ] NEW_LINE DEDENT 
def fix_spaces ( text ) : NEW_LINE INDENT res = [ ] NEW_LINE space_len = 0 NEW_LINE for i in range ( len ( text ) + 1 ) : NEW_LINE INDENT if i == len ( text ) or text [ i ] != ' ' : NEW_LINE INDENT if space_len == 1 : NEW_LINE INDENT res . append ( '_' ) NEW_LINE DEDENT if space_len == 2 : NEW_LINE INDENT res . append ( '__' ) NEW_LINE DEDENT if space_len > 2 : NEW_LINE INDENT res . append ( '-' ) NEW_LINE DEDENT space_len = 0 NEW_LINE if i != len ( text ) : NEW_LINE INDENT res . append ( text [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT space_len += 1 NEW_LINE DEDENT DEDENT return "" . join ( res ) NEW_LINE DEDENT 
def file_name_check ( file_name ) : NEW_LINE INDENT digit_num , dot_num = 0 , 0 NEW_LINE if len ( file_name ) < 5 or not file_name [ 0 ] . isalpha ( ) : NEW_LINE INDENT return "No" NEW_LINE DEDENT suffix = file_name [ - 4 : ] NEW_LINE if suffix != ".txt" and suffix != ".exe" and suffix != ".dll" : NEW_LINE INDENT return "No" NEW_LINE DEDENT for c in file_name : NEW_LINE INDENT if c . isdigit ( ) : NEW_LINE INDENT digit_num += 1 NEW_LINE DEDENT if c == '.' : NEW_LINE INDENT dot_num += 1 NEW_LINE DEDENT DEDENT if digit_num > 3 or dot_num != 1 : NEW_LINE INDENT return "No" NEW_LINE DEDENT return "Yes" NEW_LINE DEDENT 
def sum_squares ( lst ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( lst ) ) : NEW_LINE INDENT if i % 3 == 0 : NEW_LINE INDENT sum += lst [ i ] * lst [ i ] NEW_LINE DEDENT elif i % 4 == 0 : NEW_LINE INDENT sum += lst [ i ] * lst [ i ] * lst [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += lst [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT 
def words_in_sentence ( sentence ) : NEW_LINE INDENT result = [ ] NEW_LINE current = [ ] NEW_LINE for i in range ( len ( sentence ) + 1 ) : NEW_LINE INDENT if i == len ( sentence ) or sentence [ i ] == ' ' : NEW_LINE INDENT is_prime = True NEW_LINE l = len ( current ) NEW_LINE if l < 2 : NEW_LINE INDENT is_prime = False NEW_LINE DEDENT for j in range ( 2 , l ) : NEW_LINE INDENT if l % j == 0 : NEW_LINE INDENT is_prime = False NEW_LINE break NEW_LINE DEDENT DEDENT if is_prime : NEW_LINE INDENT result . append ( "" . join ( current ) + " " ) NEW_LINE DEDENT current . clear ( ) NEW_LINE DEDENT else : NEW_LINE INDENT current . append ( sentence [ i ] ) NEW_LINE DEDENT DEDENT result = "" . join ( result ) NEW_LINE if len ( result ) > 0 : NEW_LINE INDENT result = result [ : - 1 ] NEW_LINE DEDENT return result NEW_LINE DEDENT 
def simplify ( x , n ) : NEW_LINE INDENT a , b , c , d = 0 , 0 , 0 , 0 NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT if x [ i ] == '/' : NEW_LINE INDENT a = int ( x [ : i ] ) NEW_LINE b = int ( x [ i + 1 : ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( n ) ) : NEW_LINE INDENT if n [ i ] == '/' : NEW_LINE INDENT c = int ( n [ : i ] ) NEW_LINE d = int ( n [ i + 1 : ] ) NEW_LINE DEDENT DEDENT return ( a * c ) % ( b * d ) == 0 NEW_LINE DEDENT 
def specialFilter ( nums ) : NEW_LINE INDENT count = 0 NEW_LINE for num in nums : NEW_LINE INDENT if num > 10 : NEW_LINE INDENT w = str ( num ) NEW_LINE if ord ( w [ 0 ] ) % 2 == 1 and ord ( w [ - 1 ] ) % 2 == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT 
def get_max_triples ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr . append ( i * i - i + 1 ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] ) % 3 == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT 
def double_the_difference ( lst ) : NEW_LINE INDENT sum = 0 NEW_LINE for d in lst : NEW_LINE INDENT num = round ( d ) NEW_LINE if d == num : NEW_LINE INDENT if num > 0 and num % 2 == 1 : NEW_LINE INDENT sum += num * num NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT 
def compare ( game , guess ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( game ) ) : NEW_LINE INDENT result . append ( abs ( game [ i ] - guess [ i ] ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT 
def strongest_extension ( class_name , extensions ) : NEW_LINE INDENT strongest = "" NEW_LINE max = - sys . maxsize NEW_LINE for extension in extensions : NEW_LINE INDENT strength = 0 NEW_LINE for chr in extension : NEW_LINE INDENT if chr . isupper ( ) : NEW_LINE INDENT strength += 1 NEW_LINE DEDENT if chr . islower ( ) : NEW_LINE INDENT strength -= 1 NEW_LINE DEDENT DEDENT if strength > max : NEW_LINE INDENT max = strength NEW_LINE strongest = extension NEW_LINE DEDENT DEDENT return class_name + "." + strongest NEW_LINE DEDENT 
def int_to_mini_roman ( number ) : NEW_LINE INDENT num = [ 1000 , 900 , 500 , 400 , 100 , 90 , 50 , 40 , 10 , 9 , 5 , 4 , 1 ] NEW_LINE sym = [ "m" , "cm" , "d" , "cd" , "c" , "xc" , "l" , "xl" , "x" , "ix" , "v" , "iv" , "i" ] NEW_LINE pos = 0 NEW_LINE res = [ ] NEW_LINE while number > 0 : NEW_LINE INDENT while number >= num [ pos ] : NEW_LINE INDENT res . append ( sym [ pos ] ) NEW_LINE number -= num [ pos ] NEW_LINE DEDENT if number > 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT DEDENT return "" . join ( res ) NEW_LINE DEDENT 
def eat ( number , need , remaining ) : NEW_LINE INDENT return [ number + remaining , 0 ] if need > remaining else [ number + need , remaining - need ] NEW_LINE DEDENT 
def do_algebra ( ops , operands ) : NEW_LINE INDENT nums = list ( operands ) NEW_LINE current_ops = list ( ops ) NEW_LINE i = len ( current_ops ) - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if current_ops [ i ] == "**" : NEW_LINE INDENT nums [ i ] = pow ( nums [ i ] , nums [ i + 1 ] ) NEW_LINE nums . pop ( i + 1 ) NEW_LINE current_ops . pop ( i ) NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( current_ops ) : NEW_LINE INDENT if current_ops [ i ] == "*" : NEW_LINE INDENT nums [ i ] *= nums [ i + 1 ] NEW_LINE nums . pop ( i + 1 ) NEW_LINE current_ops . pop ( i ) NEW_LINE DEDENT elif current_ops [ i ] == "//" : NEW_LINE INDENT nums [ i ] //= nums [ i + 1 ] NEW_LINE nums . pop ( i + 1 ) NEW_LINE current_ops . pop ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while i < len ( current_ops ) : NEW_LINE INDENT if current_ops [ i ] == "+" : NEW_LINE INDENT nums [ i ] += nums [ i + 1 ] NEW_LINE nums . pop ( i + 1 ) NEW_LINE current_ops . pop ( i ) NEW_LINE DEDENT elif current_ops [ i ] == "-" : NEW_LINE INDENT nums [ i ] -= nums [ i + 1 ] NEW_LINE nums . pop ( i + 1 ) NEW_LINE current_ops . pop ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return nums [ 0 ] NEW_LINE DEDENT 
def generate_integers ( a , b ) : NEW_LINE INDENT lower = max ( 2 , min ( a , b ) ) NEW_LINE upper = min ( 8 , max ( a , b ) ) NEW_LINE result = [ ] NEW_LINE for i in range ( lower , upper + 1 , 2 ) : NEW_LINE INDENT result . append ( i ) NEW_LINE DEDENT return result NEW_LINE DEDENT 
def isStepNum ( n ) : NEW_LINE INDENT prev_digit = - 1 NEW_LINE while n > 0 : NEW_LINE INDENT cur_digit = n % 10 NEW_LINE if prev_digit == - 1 : NEW_LINE INDENT prev_digit = cur_digit NEW_LINE DEDENT else : NEW_LINE INDENT if abs ( prev_digit - cur_digit ) != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT prev_digit = cur_digit NEW_LINE n //= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT 
def num_of_ways ( n , k ) : NEW_LINE INDENT p = 1 NEW_LINE if k % 2 : NEW_LINE INDENT p = - 1 NEW_LINE DEDENT return ( ( n - 1 ) ** k + p * ( n - 1 ) ) // n NEW_LINE DEDENT 
def find_divisors ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( i ) NEW_LINE v . append ( n // i ) NEW_LINE DEDENT DEDENT DEDENT return v NEW_LINE DEDENT 
def egg_drop ( n , k ) : NEW_LINE INDENT if k == 1 or k == 0 : NEW_LINE INDENT return k NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return k NEW_LINE DEDENT min = sys . maxsize NEW_LINE for x in range ( 1 , k + 1 ) : NEW_LINE INDENT res = max ( egg_drop ( n - 1 , x - 1 ) , egg_drop ( n , k - x ) ) NEW_LINE if res < min : NEW_LINE INDENT min = res NEW_LINE DEDENT DEDENT return min + 1 NEW_LINE DEDENT 
def is_power_of_two ( n ) : NEW_LINE INDENT return math . ceil ( math . log2 ( n ) ) == math . floor ( math . log2 ( n ) ) NEW_LINE DEDENT 
def shortest_palindrome ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l = i NEW_LINE r = i NEW_LINE ans1 = "" NEW_LINE ans2 = "" NEW_LINE while l >= 0 and r < n and s [ l ] == s [ r ] : NEW_LINE INDENT ans1 += s [ l ] NEW_LINE l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT l = i - 1 NEW_LINE r = i NEW_LINE while l >= 0 and r < n and s [ l ] == s [ r ] : NEW_LINE INDENT ans2 += s [ l ] NEW_LINE l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT v . append ( ans1 ) NEW_LINE v . append ( ans2 ) NEW_LINE DEDENT ans = v [ 0 ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if v [ i ] != "" : NEW_LINE INDENT ans = min ( ans , v [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def minimum_adjacent_difference ( a , n , k ) : NEW_LINE INDENT min_diff = sys . maxsize NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT max_diff = - sys . maxsize NEW_LINE for j in range ( n - k - 1 ) : NEW_LINE INDENT for p in range ( i , i + j + 1 ) : NEW_LINE INDENT max_diff = max ( max_diff , a [ p + 1 ] - a [ p ] ) NEW_LINE DEDENT DEDENT min_diff = min ( min_diff , max_diff ) NEW_LINE DEDENT return min_diff NEW_LINE DEDENT 
def cal ( a , mid ) : NEW_LINE INDENT chocolate = 0 NEW_LINE for i in a : NEW_LINE INDENT if i >= mid : NEW_LINE INDENT chocolate += i - mid NEW_LINE DEDENT DEDENT return chocolate NEW_LINE DEDENT 
def check ( v , a , m ) : NEW_LINE INDENT tec = 0 NEW_LINE ans = 0 NEW_LINE b = [ 0 ] * ( len ( a ) + 3 ) NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT tec -= b [ i ] NEW_LINE if a [ i ] + tec < v : NEW_LINE INDENT mov = v - a [ i ] - tec NEW_LINE ans = ans + mov NEW_LINE tec += mov NEW_LINE b [ i + 2 ] = mov NEW_LINE DEDENT DEDENT return ans <= m NEW_LINE DEDENT 
def largest_num ( arr ) : NEW_LINE INDENT res = 0 NEW_LINE arr . sort ( ) NEW_LINE l , r = 0 , len ( arr ) - 1 NEW_LINE while l < r : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if sum == 0 : NEW_LINE INDENT res = max ( res , max ( arr [ l ] , arr [ r ] ) ) NEW_LINE return res NEW_LINE DEDENT elif sum < 0 : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT 
def binary_search ( p , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( p ) - 1 NEW_LINE index = - 1 NEW_LINE while i <= j : NEW_LINE INDENT mid = i + ( j - i ) // 2 NEW_LINE if p [ mid ] >= n : NEW_LINE INDENT index = mid NEW_LINE j = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = mid + 1 NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT 
def find_min_length ( arr ) : NEW_LINE INDENT index = len ( arr ) - 1 NEW_LINE while index > 0 and arr [ index ] >= arr [ index - 1 ] : NEW_LINE INDENT index -= 1 NEW_LINE DEDENT return index NEW_LINE DEDENT 
def min_digits ( n , k ) : NEW_LINE INDENT digits_num = math . floor ( math . log10 ( n ) + 1 ) NEW_LINE temp_sum = 0 NEW_LINE temp = digits_num NEW_LINE result = 0 NEW_LINE x , v = 0 , 0 NEW_LINE sum = 0 NEW_LINE num2 = n NEW_LINE while num2 != 0 : NEW_LINE INDENT sum += num2 % 10 NEW_LINE num2 //= 10 NEW_LINE DEDENT if sum <= k : NEW_LINE INDENT x = 0 NEW_LINE DEDENT else : NEW_LINE INDENT while temp > 0 : NEW_LINE INDENT v = n // ( 10 ** ( temp - 1 ) ) NEW_LINE temp_sum += v % 10 NEW_LINE if temp_sum >= k : NEW_LINE INDENT v //= 10 NEW_LINE v += 1 NEW_LINE result = v * ( 10 ** temp ) NEW_LINE break NEW_LINE DEDENT temp -= 1 NEW_LINE DEDENT x = result - n NEW_LINE return x NEW_LINE DEDENT return - 1 NEW_LINE DEDENT 
def check_for_perfect_square ( arr , i , j ) : NEW_LINE INDENT mid , sum = 0 , 0 NEW_LINE for m in range ( i , j + 1 ) : NEW_LINE INDENT sum += arr [ m ] NEW_LINE DEDENT low , high = 0 , sum // 2 NEW_LINE while low <= high : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if mid * mid == sum : NEW_LINE INDENT return mid NEW_LINE DEDENT elif mid * mid > sum : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT 
def min_flips ( mat , s ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE m = len ( mat [ 0 ] ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if mat [ i ] [ j ] != ord ( s [ i + j ] ) - ord ( '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT 
def construct_tree ( n , edges ) : NEW_LINE INDENT adjl = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT adjl . append ( [ ] ) NEW_LINE DEDENT for e in edges : NEW_LINE INDENT u = e [ 0 ] NEW_LINE v = e [ 1 ] NEW_LINE adjl [ u ] . append ( v ) NEW_LINE adjl [ v ] . append ( u ) NEW_LINE DEDENT return adjl NEW_LINE DEDENT 
def find_sum_of_values ( v , parent , values_children ) : NEW_LINE INDENT cur_node = v NEW_LINE Sum = 0 NEW_LINE while cur_node != - 1 : NEW_LINE INDENT Sum += values_children [ cur_node ] NEW_LINE cur_node = parent [ cur_node ] NEW_LINE DEDENT return Sum NEW_LINE DEDENT 
def get_distinct ( d , count ) : NEW_LINE INDENT num = 0 NEW_LINE count = 10 ** ( count - 1 ) NEW_LINE while count > 0 : NEW_LINE INDENT num += count * d NEW_LINE count //= 10 NEW_LINE DEDENT return num NEW_LINE DEDENT 
def is_increasing ( arr ) : NEW_LINE INDENT for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def min_adj_swaps ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE cnt_zero = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if mat [ i ] [ j ] != 0 : NEW_LINE INDENT break NEW_LINE DEDENT cnt_zero [ i ] += 1 NEW_LINE DEDENT DEDENT cnt_swaps = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if cnt_zero [ i ] < ( n - i - 1 ) : NEW_LINE INDENT first = i NEW_LINE while first < n and cnt_zero [ first ] < ( n - i - 1 ) : NEW_LINE INDENT first += 1 NEW_LINE DEDENT if first == n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT while first > i : NEW_LINE INDENT cnt_zero [ first ] , cnt_zero [ first - 1 ] = cnt_zero [ first - 1 ] , cnt_zero [ first ] NEW_LINE first -= 1 NEW_LINE cnt_swaps += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt_swaps NEW_LINE DEDENT 
def solve ( values , salary , mod ) : NEW_LINE INDENT ret = 1 NEW_LINE amt = 0 NEW_LINE values . sort ( ) NEW_LINE salary . sort ( ) NEW_LINE while len ( salary ) > 0 : NEW_LINE INDENT while len ( values ) and values [ - 1 ] >= salary [ - 1 ] : NEW_LINE INDENT amt += 1 NEW_LINE values . pop ( ) NEW_LINE DEDENT if amt == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ret *= amt NEW_LINE amt -= 1 NEW_LINE ret %= mod NEW_LINE salary . pop ( ) NEW_LINE DEDENT return ret NEW_LINE DEDENT 
def organize_in_order ( vec , op , n ) : NEW_LINE INDENT result = [ 0 ] * n NEW_LINE vec . sort ( ) NEW_LINE i , j , k = 0 , n - 1 , 0 NEW_LINE while i <= j and k <= n - 2 : NEW_LINE INDENT if op [ k ] == '<' : NEW_LINE INDENT result [ k ] = vec [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result [ k ] = vec [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT k += 1 NEW_LINE DEDENT result [ n - 1 ] = vec [ i ] NEW_LINE return result NEW_LINE DEDENT 
def count_points ( n , m , a , b , x , y ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE j = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while j < m : NEW_LINE INDENT if a [ i ] + y < b [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT if b [ j ] >= a [ i ] - x and b [ j ] <= a [ i ] + y : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT 
def are_same ( a , b ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE return a == b NEW_LINE DEDENT 
def count_number_of_strings ( s ) : NEW_LINE INDENT n = len ( s ) - 1 NEW_LINE count = 2 ** n NEW_LINE return count NEW_LINE DEDENT 
def prime_power ( x ) : NEW_LINE INDENT prime_pow = [ ] NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT if i * i > x + 1 : NEW_LINE INDENT break NEW_LINE DEDENT if x % i == 0 : NEW_LINE INDENT p = 1 NEW_LINE while x % i == 0 : NEW_LINE INDENT x //= i NEW_LINE p *= i NEW_LINE DEDENT prime_pow . append ( p ) NEW_LINE DEDENT DEDENT if x > 1 : NEW_LINE INDENT prime_pow . append ( x ) NEW_LINE DEDENT return prime_pow NEW_LINE DEDENT 
def is_perfect ( n0 ) : NEW_LINE INDENT n = math . sqrt ( n0 ) NEW_LINE if math . floor ( n ) != math . ceil ( n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT 
def find_sum ( l , r ) : NEW_LINE INDENT arr = [ ] NEW_LINE i = 0 NEW_LINE x = 2 NEW_LINE while i <= r : NEW_LINE INDENT arr . append ( i + x ) NEW_LINE if i + 1 <= r : NEW_LINE INDENT arr . append ( i + 1 + x ) NEW_LINE DEDENT x *= - 1 NEW_LINE i += 2 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT 
def results ( n , k ) : NEW_LINE INDENT return round ( n ** ( 1.0 / 2 ** k ) ) NEW_LINE DEDENT 
def factors ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE v . append ( 1 ) NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT v . append ( i ) NEW_LINE if n // i != i : NEW_LINE INDENT v . append ( n // i ) NEW_LINE DEDENT DEDENT DEDENT return v NEW_LINE DEDENT 
def smallest_num ( n ) : NEW_LINE INDENT x = 10.0 ** ( ( n - 1 ) / 2.0 ) NEW_LINE return math . ceil ( x ) NEW_LINE DEDENT 
def smallest ( s ) : NEW_LINE INDENT a = [ 0 ] * len ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT a [ i ] = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE DEDENT b = [ ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] % 2 != 0 : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT DEDENT b . sort ( ) NEW_LINE if len ( b ) > 1 : NEW_LINE INDENT return b [ 0 ] * 10 + b [ 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT 
def diagonals ( a , b , c , d ) : NEW_LINE INDENT ans = [ ] NEW_LINE ans . append ( math . sqrt ( ( a * c + b * d ) * ( a * d + b * c ) / ( a * b + c * d ) ) ) NEW_LINE ans . append ( math . sqrt ( ( a * c + b * d ) * ( a * b + c * d ) / ( a * d + b * c ) ) ) NEW_LINE return ans NEW_LINE DEDENT 
def find_number_of_digits ( n , base ) : NEW_LINE INDENT dig = math . floor ( math . log ( n ) / math . log ( base ) ) + 1 NEW_LINE return dig NEW_LINE DEDENT 
def n_gon ( n ) : NEW_LINE INDENT pro_angle_var = 0 NEW_LINE if n % 4 == 0 : NEW_LINE INDENT pro_angle_var = math . pi * ( 180.0 / n ) / 180 NEW_LINE DEDENT else : NEW_LINE INDENT pro_angle_var = math . pi * ( 180.0 / ( 2 * n ) ) / 180 NEW_LINE DEDENT neg_x = 1.0e+99 NEW_LINE pos_x = - 1.0e+99 NEW_LINE neg_y = 1.0e+99 NEW_LINE pos_y = - 1.0e+99 NEW_LINE for j in range ( n ) : NEW_LINE INDENT px = math . cos ( 2 * math . pi * j / n + pro_angle_var ) NEW_LINE py = math . sin ( 2 * math . pi * j / n + pro_angle_var ) NEW_LINE neg_x = min ( neg_x , px ) NEW_LINE pos_x = max ( pos_x , px ) NEW_LINE neg_y = min ( neg_y , py ) NEW_LINE pos_y = max ( pos_y , py ) NEW_LINE DEDENT opt2 = max ( pos_x - neg_x , pos_y - neg_y ) NEW_LINE return opt2 / math . sin ( math . pi / n ) / 2 NEW_LINE DEDENT 
def find_max_k ( n ) : NEW_LINE INDENT p = int ( math . log2 ( n ) ) NEW_LINE return 2 ** p NEW_LINE DEDENT 
def nth_fibo ( n ) : NEW_LINE INDENT a = ( 5 ** 0.5 + 1 ) / 2 NEW_LINE b = ( - 5 ** 0.5 + 1 ) / 2 NEW_LINE r = 5 ** 0.5 NEW_LINE ans = ( a ** n - b ** n ) / r NEW_LINE return int ( ans ) NEW_LINE DEDENT 
def find_prob ( l , r ) : NEW_LINE INDENT count_of_ps = math . floor ( math . sqrt ( r ) ) - math . ceil ( math . sqrt ( l ) ) + 1 NEW_LINE total = r - l + 1 NEW_LINE prob = count_of_ps / total NEW_LINE return prob NEW_LINE DEDENT 
def previous_fibonacci ( n ) : NEW_LINE INDENT a = n / ( ( 1 + math . sqrt ( 5 ) ) / 2.0 ) NEW_LINE return round ( a ) NEW_LINE DEDENT 
def dist_prime ( arr , all_primes ) : NEW_LINE INDENT list1 = [ ] NEW_LINE for i in all_primes : NEW_LINE INDENT for j in arr : NEW_LINE INDENT if j % i == 0 : NEW_LINE INDENT list1 . append ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return list1 NEW_LINE DEDENT 
def get_array ( n ) : NEW_LINE INDENT ans = [ ] NEW_LINE p2 = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT ans . append ( p2 ) NEW_LINE DEDENT n >>= 1 NEW_LINE p2 *= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT 
def maximum_length ( a ) : NEW_LINE INDENT counts = [ 0 ] * 11 NEW_LINE ans = 0 NEW_LINE for index in range ( len ( a ) ) : NEW_LINE INDENT counts [ a [ index ] ] += 1 NEW_LINE k = [ ] NEW_LINE for i in counts : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT k . append ( i ) NEW_LINE DEDENT DEDENT k . sort ( ) NEW_LINE if len ( k ) == 1 or ( k [ 0 ] == k [ - 2 ] and k [ - 1 ] - k [ - 2 ] == 1 ) or ( k [ 0 ] == 1 and k [ 1 ] == k [ - 1 ] ) : NEW_LINE INDENT ans = index NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT 
def max_edges ( n ) : NEW_LINE INDENT edges = math . floor ( n * n // 4 ) NEW_LINE return edges NEW_LINE DEDENT 
def find_k ( n , k ) : NEW_LINE INDENT a = [ ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT return a [ k - 1 ] NEW_LINE DEDENT 
def is_keith ( x , temp ) : NEW_LINE INDENT terms = [ ] NEW_LINE n = 0 NEW_LINE while temp > 0 : NEW_LINE INDENT terms . append ( temp % 10 ) NEW_LINE temp = temp // 10 NEW_LINE n += 1 NEW_LINE DEDENT terms . reverse ( ) NEW_LINE next_term , i = 0 , n NEW_LINE while next_term < x : NEW_LINE INDENT next_term = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT next_term += terms [ i - j ] NEW_LINE DEDENT terms . append ( next_term ) NEW_LINE i += 1 NEW_LINE DEDENT return next_term == x NEW_LINE DEDENT 
def factors ( n , k ) : NEW_LINE INDENT v = [ ] NEW_LINE while n % 2 == 0 : NEW_LINE INDENT v . append ( 2 ) NEW_LINE n //= 2 NEW_LINE DEDENT if len ( v ) >= k : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 3 , n + 1 , 2 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT while n % i == 0 : NEW_LINE INDENT n = n // i NEW_LINE v . append ( i ) NEW_LINE DEDENT if len ( v ) >= k : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT v . append ( n ) NEW_LINE DEDENT if len ( v ) >= k : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT 
