def GreatestCommonDivisor ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return a + b NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return GreatestCommonDivisor ( a % b , b ) NEW_LINE DEDENT else : NEW_LINE INDENT return GreatestCommonDivisor ( a , b % a ) NEW_LINE DEDENT DEDENT
def LargestDivisor ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i <= n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return n // i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def IsPrime ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for k in range ( 2 , n ) : NEW_LINE INDENT if ( n % k == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def FizzBuzz ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 11 == 0 or i % 13 == 0 ) : NEW_LINE INDENT q = i NEW_LINE while ( q > 0 ) : NEW_LINE INDENT if ( q % 10 == 7 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT q //= 10 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def PrimeFib ( n ) : NEW_LINE INDENT f0 = 0 NEW_LINE f1 = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT p = f0 + f1 NEW_LINE is_prime = p >= 2 NEW_LINE for i in range ( 2 , p ) : NEW_LINE INDENT if ( p % i == 0 ) : NEW_LINE INDENT is_prime = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( is_prime ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT f0 = f1 NEW_LINE f1 = p NEW_LINE DEDENT return f1 NEW_LINE DEDENT
def TriangleArea ( a , h ) : NEW_LINE INDENT return a * h / 2 NEW_LINE DEDENT
def ModP ( n , p ) : NEW_LINE INDENT ret = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ret = ( ret * 2 ) % p NEW_LINE DEDENT return ret NEW_LINE DEDENT
def Add ( x , y ) : NEW_LINE INDENT return x + y NEW_LINE DEDENT
def Fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return Fib ( n - 1 ) + Fib ( n - 2 ) NEW_LINE DEDENT
def LargestPrimeFactor ( n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT while ( n % i == 0 and n > i ) : NEW_LINE INDENT n //= i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def SumToN ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT result += i NEW_LINE DEDENT return result NEW_LINE DEDENT
def Fibfib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return Fibfib ( n - 1 ) + Fibfib ( n - 2 ) + Fibfib ( n - 3 ) NEW_LINE DEDENT
def IsMultiplyPrime ( a ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 2 , a + 1 ) : NEW_LINE INDENT while ( a % i == 0 and a >= i ) : NEW_LINE INDENT a //= i NEW_LINE num += 1 NEW_LINE DEDENT DEDENT return ans == 3 NEW_LINE DEDENT
def IsSimplePower ( x , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return x == 1 NEW_LINE DEDENT power = 1 NEW_LINE while power < x : NEW_LINE INDENT power *= n NEW_LINE DEDENT return power == x NEW_LINE DEDENT
def ChooseNum ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( y % 2 == 0 ) : NEW_LINE INDENT return y NEW_LINE DEDENT if ( x == y ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return y - 1 NEW_LINE DEDENT
def IsEqualToSumEven ( n ) : NEW_LINE INDENT return n % 2 == 0 and n >= 8 NEW_LINE DEDENT
def SpecialFactorial ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE special_fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE special_fact *= fact NEW_LINE DEDENT return special_fact NEW_LINE DEDENT
def XOrY ( n , x , y ) : NEW_LINE INDENT is_prime = n >= 2 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT is_prime = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( is_prime ) : NEW_LINE INDENT return x NEW_LINE DEDENT return y NEW_LINE DEDENT
def RightAngleTriangle ( a , b , c ) : NEW_LINE INDENT return a * a == b * b + c * c or b * b == a * a + c * c or c * c == a * a + b * b NEW_LINE DEDENT
def FastPow ( n , k ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = FastPow ( n , k // 2 ) NEW_LINE if ( k % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT return n * temp * temp NEW_LINE DEDENT DEDENT
def IsPalin ( s ) : NEW_LINE INDENT l = len ( s ) // 2 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] != s [ len ( s ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def FindSum ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = i - 1 NEW_LINE num = 1 NEW_LINE while ( temp < n ) : NEW_LINE INDENT if ( temp + i <= n ) : NEW_LINE INDENT ans += i * num NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( n - temp ) * num NEW_LINE DEDENT temp += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def GetNextGap ( gap ) : NEW_LINE INDENT gap = gap * 10 // 13 NEW_LINE if ( gap < 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return gap NEW_LINE DEDENT
def CountNonDecreasing ( n ) : NEW_LINE INDENT k = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count *= k + i - 1 NEW_LINE count //= i NEW_LINE DEDENT return count NEW_LINE DEDENT
def Power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y % 2 == 0 ) : NEW_LINE INDENT return Power ( x , y / 2 ) * Power ( x , y / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return x * Power ( x , y / 2 ) * Power ( x , y / 2 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return x * Power ( x , y / 2 ) * Power ( x , y / 2 ) NEW_LINE DEDENT DEDENT
def Power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = Power ( x , y // 2 ) NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT if ( y > 0 ) : NEW_LINE INDENT return x * temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT DEDENT DEDENT
def Multiply ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( y > 0 ) : NEW_LINE INDENT return x + Multiply ( x , y - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return - Multiply ( x , - y ) NEW_LINE DEDENT DEDENT
def Smallest ( x , y , z ) : NEW_LINE INDENT if ( ! ( y // x ) ) : NEW_LINE INDENT return not ( y // z ) ? y : z NEW_LINE DEDENT return not ( x // z ) ? x : z NEW_LINE DEDENT
def IsPowerOfFour ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 4 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 4 NEW_LINE DEDENT return True NEW_LINE DEDENT
def ModInverse ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE x0 = 0 NEW_LINE x1 = 1 NEW_LINE while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if ( x1 < 0 ) : NEW_LINE INDENT x1 += m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT
def CntRotations ( s , n ) : NEW_LINE INDENT s2 = bin ( s ) + s NEW_LINE pre = [ 0 ] * 2 NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] NEW_LINE DEDENT if ( s2 [ i ] == 'a' or s2 [ i ] == 'e' or s2 [ i ] == 'o' or s2 [ i ] == 'u' ) : NEW_LINE INDENT pre [ i ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT r = i NEW_LINE l = i - n // 2 NEW_LINE left = pre [ r ] NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT left -= pre [ l ] NEW_LINE DEDENT right = x1 - left NEW_LINE if ( left > right ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def BinomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= n - i NEW_LINE res //= i + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def IsPrefix ( temp , s ) : NEW_LINE INDENT if len ( temp ) < len ( s ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != temp [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def LexicographicallySmallestString ( s , n ) : NEW_LINE INDENT last_ze = - 1 NEW_LINE ans = "" NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT last_ze = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i <= last_ze and s [ i ] == '0' ) : NEW_LINE INDENT ans += s [ i ] NEW_LINE DEDENT elif ( i > last_ze ) : NEW_LINE INDENT ans += s [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def CalculateMax ( n , m , k ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = 0 NEW_LINE high = m NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE val = 0 NEW_LINE l = k - 1 NEW_LINE r = n - k NEW_LINE val += mid NEW_LINE if ( mid >= l ) : NEW_LINE INDENT val += l * ( 2 * mid - l - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT val += mid * ( mid - 1 ) / 2 + ( l - mid ) NEW_LINE DEDENT if ( mid >= r ) : NEW_LINE INDENT val += r * ( 2 * mid - r - 1 ) / 2 NEW_LINE DEDENT else : NEW_LINE INDENT val += mid * ( mid - 1 ) / 2 + ( r - mid ) NEW_LINE DEDENT if ( val <= m ) : NEW_LINE INDENT ans = max ( ans , mid ) NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def FindLength ( s , i , j ) : NEW_LINE INDENT required = i NEW_LINE length = 0 NEW_LINE for curr in range ( s ) : NEW_LINE INDENT if ( curr == required ) : NEW_LINE INDENT length += 1 NEW_LINE if ( required == i ) : NEW_LINE INDENT required = j NEW_LINE DEDENT else : NEW_LINE INDENT required = i NEW_LINE DEDENT DEDENT return length NEW_LINE DEDENT
def CheckReverse ( left_sum , right_sum ) : NEW_LINE INDENT rev = 0 NEW_LINE temp = right_sum NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT rev = rev * 10 + temp % 10 NEW_LINE temp //= 10 NEW_LINE DEDENT if ( rev == left_sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def IsComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 5 , n , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def MinDeletion ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE first_idx1 = - 1 NEW_LINE last_idx0 = - 1 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT first_idx1 = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT last_idx0 = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( first_idx1 == - 1 or last_idx0 == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count1 = 0 NEW_LINE count0 = 0 NEW_LINE for i in range ( first_idx1 + 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT DEDENT return min ( count0 , count1 ) NEW_LINE DEDENT
def MinSteps ( s , n ) : NEW_LINE INDENT smaller = 0 NEW_LINE cost = 0 NEW_LINE f = [ int ( i ) for i in range ( n ) ] NEW_LINE for j in range ( curr_ele + 1 ) : NEW_LINE INDENT if ( f [ j ] != 0 ) : NEW_LINE INDENT smaller += f [ j ] NEW_LINE DEDENT DEDENT if ( smaller == 0 ) : NEW_LINE INDENT cost += i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT cost += i - smaller + 1 NEW_LINE DEDENT f [ s [ i ] - int ( 'a' ) ] += 1 NEW_LINE DEDENT return cost NEW_LINE DEDENT
def NumberOfWays ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for a in range ( 1 , n ) : NEW_LINE INDENT for b in range ( 1 , n ) : NEW_LINE INDENT c = n - ( a + b ) NEW_LINE if ( a + b > c and a + c > b and b + c > a ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def SlopeOfNum ( num , n ) : NEW_LINE INDENT slope = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( num [ i ] > num [ i - 1 ] and num [ i ] > num [ i + 1 ] ) : NEW_LINE INDENT slope += 1 NEW_LINE DEDENT elif ( num [ i ] < num [ i - 1 ] and num [ i ] < num [ i + 1 ] ) : NEW_LINE INDENT slope += 1 NEW_LINE DEDENT DEDENT return slope NEW_LINE DEDENT
def MiddleOfThree ( a , b , c ) : NEW_LINE INDENT x = a - b NEW_LINE y = b - c NEW_LINE z = a - c NEW_LINE if ( x * y > 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT elif ( x * z > 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT
def CountMaxSetBits ( left , right ) : NEW_LINE INDENT while ( ( left | ( left + 1 ) ) <= right ) : NEW_LINE INDENT left |= left + 1 NEW_LINE DEDENT return left NEW_LINE DEDENT
def FindS ( s ) : NEW_LINE INDENT l = 1 NEW_LINE r = ( s // 2 ) + 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE sum = mid * ( mid + 1 ) / 2 NEW_LINE if ( sum == s ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( sum > s ) : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def Check ( s ) : NEW_LINE INDENT min = 10 ** 9 NEW_LINE max = 10 ** 9 NEW_LINE sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ascii = ord ( s [ i ] ) NEW_LINE if ( ascii < 96 or ascii > 122 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += ascii NEW_LINE if ( min > ascii ) : NEW_LINE INDENT min = ascii NEW_LINE DEDENT if ( max < ascii ) : NEW_LINE INDENT max = ascii NEW_LINE DEDENT DEDENT min -= 1 NEW_LINE eSum = max * ( max + 1 ) // 2 - min * ( min + 1 ) / 2 NEW_LINE return sum == eSum NEW_LINE DEDENT
def MinimumPossibleProduct ( k ) : NEW_LINE INDENT res = 1 NEW_LINE r = ( 1 << k ) - 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT res *= r - 1 NEW_LINE DEDENT res *= r NEW_LINE return res NEW_LINE DEDENT
def FindInGrid ( i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return i * i - ( i - 1 ) NEW_LINE DEDENT elif ( i > j ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT return i * i - ( j - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( i - 1 ) * ( i - 1 ) + 1 + ( j - 1 ) NEW_LINE DEDENT DEDENT elif ( j % 2 == 0 ) : NEW_LINE INDENT return ( j - 1 ) * ( j - 1 ) + 1 + ( i - 1 ) NEW_LINE DEDENT DEDENT
def FindMinOperationsReqEmpStr ( s ) : NEW_LINE INDENT cnt_one = 0 NEW_LINE cnt_zero = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT cnt_one -= 1 NEW_LINE DEDENT cnt_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( cnt_zero ) : NEW_LINE INDENT cnt_zero -= 1 NEW_LINE DEDENT cnt_one += 1 NEW_LINE DEDENT DEDENT return cnt_one + cnt_zero NEW_LINE DEDENT
def IsReachable ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT while ( x2 > x1 and y2 > y1 ) : NEW_LINE INDENT if ( x2 > y2 ) : NEW_LINE INDENT x2 %= y2 NEW_LINE DEDENT else : NEW_LINE INDENT y2 %= x2 NEW_LINE DEDENT DEDENT if ( x2 == x1 ) : NEW_LINE INDENT return y2 - y1 >= 0 and ( y2 - y1 ) % x1 == 0 NEW_LINE DEDENT elif ( y2 == y1 ) : NEW_LINE INDENT return x2 - x1 >= 0 and ( x2 - x1 ) % y1 == 0 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def FindMaxSoln ( n , x , y ) : NEW_LINE INDENT ans = 10 ** 9 NEW_LINE for k in range ( n + 1 ) : NEW_LINE INDENT if ( k % x == y ) : NEW_LINE INDENT ans = max ( ans , k ) NEW_LINE DEDENT DEDENT return ans >= 0 and ans <= n : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT
def NumberOfPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE j = n - 1 NEW_LINE while i < j : NEW_LINE INDENT if ( i + j == n ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def MinChanges ( s , n ) : NEW_LINE INDENT count , zeros , ones = 0 , 0 , 0 NEW_LINE if ( s [ 0 ] != '1' ) : NEW_LINE INDENT count += 1 NEW_LINE ones += 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT if ( zeros > ones ) : NEW_LINE INDENT zeros -= 1 NEW_LINE ones += 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def KVisibleFromLeft ( n , k ) : NEW_LINE INDENT if ( n == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 1 ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans *= i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def Find ( n , sum ) : NEW_LINE INDENT if ( sum > 6 * n or sum < n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT if ( sum >= 1 and sum <= 6 ) : NEW_LINE INDENT return 1.0 / 6 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT s = 0 NEW_LINE for i in range ( 1 , 6 ) : NEW_LINE INDENT s += Find ( n - 1 , sum - i ) / 6 NEW_LINE DEDENT return s NEW_LINE DEDENT
def BinCoff ( n , r ) : NEW_LINE INDENT val = 1 NEW_LINE if ( r > n - r ) : NEW_LINE INDENT r = n - r NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT val *= n - i NEW_LINE val //= i + 1 NEW_LINE DEDENT return val NEW_LINE DEDENT
def GetMask ( val ) : NEW_LINE INDENT mask = 0 NEW_LINE while ( val == 0 ) : NEW_LINE INDENT d = val % 10 NEW_LINE mask |= 1 << d NEW_LINE val //= 10 NEW_LINE DEDENT return mask NEW_LINE DEDENT
def WaysToKAdjacentSetBits ( n , k , current_index , adjacent_set_bits , last_bit ) : NEW_LINE INDENT if ( current_index == n ) : NEW_LINE INDENT if ( adjacent_set_bits == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def CheckFunc ( i , j , st ) : NEW_LINE INDENT if ( st [ i ] == '(' and st [ j ] == ')' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( st [ i ] == '?' and st [ j ] == ')' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( st [ i ] == '[' and st [ j ] == ']' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( st [ i ] == '{' and st [ j ] == '}' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( st [ i ] == '{' and st [ j ] == '?' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( st [ i ] == '?' and st [ j ] == '}' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def FindGolomb ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 1 + FindGolomb ( n - FindGolomb ( FindGolomb ( n - 1 ) ) ) NEW_LINE DEDENT
def AllOnes ( s , n ) : NEW_LINE INDENT co = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT co += ord ( s [ i ] ) == '1' ? 1 : 0 NEW_LINE DEDENT return co == n NEW_LINE DEDENT
def Pad ( n ) : NEW_LINE INDENT p_prev_prev = 1 NEW_LINE p_prev = 1 NEW_LINE p_curr = 1 NEW_LINE p_next = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT p_next = p_prev_prev + p_prev NEW_LINE p_prev_prev = p_prev NEW_LINE p_curr = 1 NEW_LINE p_next = p_next NEW_LINE DEDENT return p_next NEW_LINE DEDENT
def OddLengthPalindrome ( k ) : NEW_LINE INDENT palin = k NEW_LINE k = k // 10 NEW_LINE while ( k > 0 ) : NEW_LINE INDENT rev = k % 10 NEW_LINE palin = palin * 10 + rev NEW_LINE k = k // 10 NEW_LINE DEDENT return palin NEW_LINE DEDENT
def ChangeString ( s0 ) : NEW_LINE INDENT s = s0 NEW_LINE n = len ( s ) NEW_LINE if ( s [ 0 ] == s [ 1 ] ) : NEW_LINE INDENT s [ 0 ] = 'a' NEW_LINE if ( s [ 0 ] == s [ 1 ] ) : NEW_LINE INDENT s [ 0 ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT s [ i ] += 1 NEW_LINE DEDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT s [ i ] += 1 NEW_LINE DEDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT s [ i ] += 1 NEW_LINE DEDENT DEDENT if ( s [ n - 1 ] == '?' ) : NEW_LINE INDENT s [ n - 1 ] = 'a' NEW_LINE if ( s [ n - 1 ] == s [ n - 2 ] ) : NEW_LINE INDENT s [ n - 1 ] += 1 NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def TotalHammingDistance ( n ) : NEW_LINE INDENT i = 1 NEW_LINE sum = 0 NEW_LINE while ( n // i > 0 ) : NEW_LINE INDENT sum = sum + n // i NEW_LINE i = i * 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def CheckBitonic ( s ) : NEW_LINE INDENT i = 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] > s [ i - 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] <= s [ i - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == len ( s ) - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT j = i + 1 NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ j ] < s [ j - 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ j ] >= s [ j - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i = j NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def EndsWith ( string , pat ) : NEW_LINE INDENT pat_len = len ( pat ) NEW_LINE str_len = len ( string ) NEW_LINE if ( pat_len > str_len ) : NEW_LINE INDENT return False NEW_LINE DEDENT pat_len -= 1 NEW_LINE str_len -= 1 NEW_LINE while ( pat_len >= 0 ) : NEW_LINE INDENT if ( pat [ pat_len ] != string [ str_len ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT pat_len -= 1 NEW_LINE str_len -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def GetSum ( n , d ) : NEW_LINE INDENT if ( n < d ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n % 10 != d ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT k = n // 10 NEW_LINE return ( k + 1 ) * d + ( k * 10 + 10 * k ) / 2 NEW_LINE DEDENT
def BalancedStringBySwapping ( s ) : NEW_LINE INDENT unbalanced_pair = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( unbalanced_pair > 0 and s [ i ] == ']' ) : NEW_LINE INDENT -- unbalanced_pair NEW_LINE DEDENT elif ( s [ i ] == '[' ) : NEW_LINE INDENT += unbalanced_pair NEW_LINE DEDENT DEDENT return ( unbalanced_pair + 1 ) // 2 NEW_LINE DEDENT
def ComputeHash ( s ) : NEW_LINE INDENT p = 31 NEW_LINE mod = 1e9 + 7 NEW_LINE hash_val = 0 NEW_LINE mul = 1 NEW_LINE for ch in range ( s ) : NEW_LINE INDENT hash_val = ( hash_val + ( ch - 'a' + 1 ) * mul ) % mod NEW_LINE mul = mul * p % mod NEW_LINE DEDENT return hash_val NEW_LINE DEDENT
def CountOfSubstringWithOnlyOnes ( s ) : NEW_LINE INDENT res = 0 NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT count = ord ( s [ i ] ) == '1' ? count + 1 : 0 NEW_LINE res = res + count NEW_LINE DEDENT return res NEW_LINE DEDENT
def Composite ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE c = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % j == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( c >= 3 ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT return flag NEW_LINE DEDENT
def IsDivBySix ( s , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ord ( s [ i ] ) - ord ( 'a' ) + 1 NEW_LINE DEDENT if ( sum % 3 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT last_digit = ( s [ n - 1 ] - ord ( 'a' ) + 1 ) % 10 NEW_LINE if ( last_digit % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def IsRedundantBraces ( s ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '(' and s [ i + 2 ] == ')' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( s [ i ] == '*' or s [ i ] == '+' or s [ i ] == '-' or s [ i ] == '/' ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT if ( s [ i ] == '(' ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT if ( b > a ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def CountSubStr ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT if ( s [ i ] == '0' and s [ i + 1 ] == '1' and s [ i + 2 ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE i += 3 NEW_LINE DEDENT elif ( s [ i ] == '1' and s [ i + 1 ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE i += 3 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def PrefixOccurrences ( s ) : NEW_LINE INDENT c = ord ( s [ 0 ] ) NEW_LINE count_c = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == c ) : NEW_LINE INDENT count_c += 1 NEW_LINE DEDENT DEDENT return count_c NEW_LINE DEDENT
def IsValid ( s , len ) : NEW_LINE INDENT for i in range ( 1 , len ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def Count ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE d = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d += s [ i ] NEW_LINE DEDENT if ( d % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def FindSubstringCount ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if ( s [ i ] + 1 == s [ i + 1 ] ) : NEW_LINE INDENT result += 1 NEW_LINE while i < n - 1 and s [ i ] + 1 == s [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT
def Find ( s1 , s2 ) : NEW_LINE INDENT len1 = len ( s1 ) NEW_LINE len2 = len ( s2 ) NEW_LINE if ( len1 != len2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d = [ 0 ] * len1 NEW_LINE d [ 0 ] = s2 [ 0 ] - s1 [ 0 ] NEW_LINE for i in range ( 1 , len1 ) : NEW_LINE INDENT if ( s1 [ i ] > s2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = s2 [ i ] - s1 [ i ] NEW_LINE DEDENT DEDENT for i in range ( len1 - 1 ) : NEW_LINE INDENT if ( d [ i ] < d [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def IsInGivenBase ( s , bas ) : NEW_LINE INDENT if ( bas > 16 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( bas <= 10 ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] >= '0' and s [ i ] < '0' + bas ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] >= '0' and s [ i ] < '0' + bas ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def CountNonEmptySubstr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE return n * ( n + 1 ) / 2 NEW_LINE DEDENT
def EvenDecimalValue ( s , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT decimal_value = 0 NEW_LINE power_of_2 = 1 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT decimal_value += ( ord ( s [ k ] ) - ord ( '0' ) ) * power_of_2 NEW_LINE power_of_2 *= 2 NEW_LINE DEDENT if ( decimal_value % 2 == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def Calculate ( s ) : NEW_LINE INDENT ans = 6 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT for k in range ( 10 ) : NEW_LINE INDENT for l in range ( l , n ) : NEW_LINE INDENT if ( i + j + k == l + m + n ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( k != s [ 2 ] - '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( l != s [ 3 ] - '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( n != s [ 4 ] - '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( c < ans ) : NEW_LINE INDENT ans = c NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def XorZero ( s ) : NEW_LINE INDENT one_count = 0 NEW_LINE zero_count = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT one_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero_count += 1 NEW_LINE DEDENT DEDENT if ( one_count % 2 == 0 ) : NEW_LINE INDENT return zero_count NEW_LINE DEDENT DEDENT return one_count NEW_LINE DEDENT
def EvenLength ( n ) : NEW_LINE INDENT res = n NEW_LINE for j in range ( len ( n ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT res += n [ j ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def CountSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def NormalSlope ( a , b , x1 , y1 ) : NEW_LINE INDENT g = a / 2 NEW_LINE f = b / 2 NEW_LINE if ( g - x1 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT slope = ( f - y1 ) / ( g - x1 ) NEW_LINE if ( slope == 0 ) : NEW_LINE INDENT return - 2 NEW_LINE DEDENT return slope NEW_LINE DEDENT
def Orthogonality ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT dsquare = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) NEW_LINE if ( dsquare == r1 * r1 + r2 * r2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def FindAreaShaded ( a ) : NEW_LINE INDENT sq_area = a * a NEW_LINE semi_circle_area = 3.14 * ( a * a ) / 8 NEW_LINE shaded_area = 4 * semi_circle_area - sq_area NEW_LINE return shaded_area NEW_LINE DEDENT
def Factorial ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , a + b + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT for i in range ( 1 , a + b + 1 ) : NEW_LINE INDENT res = res // i NEW_LINE DEDENT for i in range ( 1 , a , b + 1 ) : NEW_LINE INDENT res = res // i NEW_LINE DEDENT return res NEW_LINE DEDENT
def FactorTree ( n ) : NEW_LINE INDENT height = 0 NEW_LINE while ( n > 1 ) : NEW_LINE INDENT flag = False NEW_LINE i = 2 NEW_LINE while ( i <= int ( n ** ( 0.5 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT height += 1 NEW_LINE if ( not flag ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return height NEW_LINE DEDENT
def FindIfPossible ( n , s , x ) : NEW_LINE INDENT if ( s >= x and s % 2 == x % 2 ) : NEW_LINE INDENT if ( n >= 3 ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT if ( s == x ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT else : NEW_LINE INDENT return "No" NEW_LINE DEDENT DEDENT if ( n == 2 ) : NEW_LINE INDENT c = ( s - x ) // 2 NEW_LINE a = c NEW_LINE b = c NEW_LINE a = a + x NEW_LINE if ( ( a ^ b ) == x ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT else : NEW_LINE INDENT return "No" NEW_LINE DEDENT DEDENT return "No" NEW_LINE DEDENT
def MaximumTripletXor ( a , b , c ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 30 , - 1 , - 1 ) : NEW_LINE INDENT cur = 1 << i NEW_LINE if ( a >= cur ) : NEW_LINE INDENT ans += cur NEW_LINE a -= cur NEW_LINE DEDENT elif ( b >= cur ) : NEW_LINE INDENT ans += cur NEW_LINE b -= cur NEW_LINE DEDENT elif ( c >= cur ) : NEW_LINE INDENT ans += cur NEW_LINE c -= cur NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def ItemType ( n ) : NEW_LINE INDENT count = 0 NEW_LINE day = 1 NEW_LINE while ( count + day * ( day + 1 ) / 2 < n ) : NEW_LINE INDENT count += day * ( day + 1 ) / 2 NEW_LINE day += 1 NEW_LINE DEDENT for type in range ( day , 0 , - 1 ) : NEW_LINE INDENT count += type NEW_LINE if ( count >= n ) : NEW_LINE INDENT return type NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def MaxGcdInRange ( l , r ) : NEW_LINE INDENT ans = 1 NEW_LINE for z in range ( r , 0 , - 1 ) : NEW_LINE INDENT if ( r // z - ( l - 1 ) // z > 1 ) : NEW_LINE INDENT ans = z NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def SumOfDigits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def IsRepUnitNum ( n , b ) : NEW_LINE INDENT length = 0 NEW_LINE count_one = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % b NEW_LINE length += 1 NEW_LINE if ( r == 1 ) : NEW_LINE INDENT count_one += 1 NEW_LINE DEDENT n = n // b NEW_LINE DEDENT return count_one >= 3 and count_one == length NEW_LINE DEDENT
def IsStraightLineNum ( n ) : NEW_LINE INDENT if ( n <= 99 ) : NEW_LINE INDENT return False NEW_LINE DEDENT s = str ( n ) NEW_LINE d = s [ 1 ] - s [ 0 ] NEW_LINE for i in range ( 2 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] - s [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def GetCount ( d , n ) : NEW_LINE INDENT no = n // d NEW_LINE result = no NEW_LINE p = 2 NEW_LINE while p * p <= no : NEW_LINE INDENT if no % p == 0 : NEW_LINE INDENT no //= p NEW_LINE DEDENT result -= result // p NEW_LINE DEDENT DEDENT if ( no > 1 ) : NEW_LINE INDENT result -= result // no NEW_LINE DEDENT return result NEW_LINE DEDENT
def IsEvenParity ( x ) : NEW_LINE INDENT parity = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT parity += 1 NEW_LINE DEDENT x = x >> 1 NEW_LINE DEDENT if ( parity % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def IsPerfect ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i * i != n ) : NEW_LINE INDENT sum = sum + i + n // i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT if ( sum == n and n != 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def LogAToBaseB ( a , b ) : NEW_LINE INDENT return a > b - 1 ? 1 + LogAToBaseB ( a // b , b ) : 0 NEW_LINE DEDENT
def UsingBinarySearch ( start , end , n , s ) : NEW_LINE INDENT if ( start >= end ) : NEW_LINE INDENT return start NEW_LINE DEDENT mid = start + ( end - start ) // 2 NEW_LINE total_sum = n * ( n + 1 ) / 2 NEW_LINE mid_sum = mid * ( mid + 1 ) / 2 NEW_LINE if ( total_sum - mid_sum <= s ) : NEW_LINE INDENT return UsingBinarySearch ( start , mid , n , s ) NEW_LINE DEDENT return UsingBinarySearch ( mid + 1 , end , n , s ) NEW_LINE DEDENT
def MinInt ( s ) : NEW_LINE INDENT s1 = [ '0' ] * len ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s1 [ i ] >= '5' ) : NEW_LINE INDENT s1 [ i ] = '9' - s1 [ i ] + '0' NEW_LINE DEDENT DEDENT if ( s1 [ 0 ] == '0' ) : NEW_LINE INDENT s1 [ 0 ] = '9' NEW_LINE DEDENT return s1 NEW_LINE DEDENT
def CountTriplets ( a , b , c ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , a + 1 ) : NEW_LINE INDENT for j in range ( 1 , b + 1 , 1 ) : NEW_LINE INDENT for k in range ( 1 , c + 1 ) : NEW_LINE INDENT if ( i * k > j * j ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def TopsyTurvy ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '2' or s [ i ] == '4' or s [ i ] == '5' or s [ i ] == '6' or s [ i ] == '7' or s [ i ] == '9' ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def SumOfLastDig ( n , m ) : NEW_LINE INDENT sum = 0 NEW_LINE k = n // m NEW_LINE arr = [ int ( m * ( i + 1 ) % 10 ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT arr [ i ] = m * ( i + 1 ) % 10 NEW_LINE sum += arr [ i ] NEW_LINE DEDENT rem = k % 10 NEW_LINE ans = k // 10 * sum NEW_LINE for i in range ( 0 , rem ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def TotalPay ( total_items , price_of_one_item , n , m ) : NEW_LINE INDENT freeItems = 0 NEW_LINE actual = 0 NEW_LINE freeItems = total_items // ( n + m ) NEW_LINE actual = total_items - freeItems NEW_LINE amount = actual * price_of_one_item NEW_LINE return amount NEW_LINE DEDENT
def MinOperations ( x , y , p , q ) : NEW_LINE INDENT if ( y % x != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = y // x NEW_LINE a = 0 NEW_LINE while ( d % p == 0 ) : NEW_LINE INDENT d //= p NEW_LINE a += 1 NEW_LINE DEDENT b = 0 NEW_LINE while ( d % q == 0 ) : NEW_LINE INDENT d // q NEW_LINE b += 1 NEW_LINE DEDENT if ( d != 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return a + b NEW_LINE DEDENT
def IsMersenne ( n ) : NEW_LINE INDENT while ( n != 0 ) : NEW_LINE INDENT r = n % 2 NEW_LINE if ( r == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n //= 2 NEW_LINE DEDENT return True NEW_LINE DEDENT
def FindThirdDigit ( n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return n & 1 ? 1 : 6 NEW_LINE DEDENT
def IsOddLength ( num ) : NEW_LINE INDENT count = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT num //= 10 NEW_LINE count += 1 NEW_LINE DEDENT if ( count % 2 != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def CheckIsPossible ( l , r , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count > 1 NEW_LINE DEDENT
def Bytes ( kilobytes ) : NEW_LINE INDENT b = kilobytes * 1024 NEW_LINE return b NEW_LINE DEDENT
def OctahedralNum ( n ) : NEW_LINE INDENT return int ( n * ( 2 * n * n + 1 ) / 3 ) NEW_LINE DEDENT
def CheckEqual ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != '1' and s [ i ] != '0' and s [ i ] != '8' ) : NEW_LINE INDENT return "No" NEW_LINE DEDENT DEDENT start = 0 NEW_LINE end = len ( s ) - 1 NEW_LINE while start < end : NEW_LINE INDENT if ( s [ start ] != s [ end ] ) : NEW_LINE INDENT return "No" NEW_LINE DEDENT start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT return "Yes" NEW_LINE DEDENT
def IsUndulating ( n ) : NEW_LINE INDENT if len ( n ) <= 2 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , len ( n ) ) : NEW_LINE INDENT if ( n [ i - 2 ] != n [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def FirstDigit ( n ) : NEW_LINE INDENT while ( n >= 10 ) : NEW_LINE INDENT n //= 10 NEW_LINE DEDENT return n NEW_LINE DEDENT
def CountDigit ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 + CountDigit ( n // 10 ) NEW_LINE DEDENT
def IsDivisibleBy5 ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE return int ( s [ n - 1 ] ) - int ( '0' ) == 0 or int ( s [ n - 1 ] ) == 5 NEW_LINE DEDENT
def Inv ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE x0 = 0 NEW_LINE x1 = 1 NEW_LINE while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if ( x1 < 0 ) : NEW_LINE INDENT x1 += m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT
def OnlyFirstAndLastAreSet ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( n - 1 ) & ( n - 2 ) ) == 0 NEW_LINE DEDENT
def Divide ( dividend , divisor ) : NEW_LINE INDENT sign = ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? - 1 : 1 NEW_LINE dividend = abs ( dividend ) NEW_LINE divisor = abs ( divisor ) NEW_LINE quotient = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT if ( temp + ( ( long long ) divisor << i ) <= dividend ) : NEW_LINE INDENT temp += ( long long ) divisor << i NEW_LINE quotient |= 1 << i NEW_LINE DEDENT DEDENT if ( sign == - 1 ) : NEW_LINE INDENT quotient = - quotient NEW_LINE DEDENT DEDENT return quotient NEW_LINE DEDENT
def FindProfession ( level , pos ) : NEW_LINE INDENT if ( level == 1 ) : NEW_LINE INDENT return 'e' NEW_LINE DEDENT if ( FindProfession ( level - 1 , ( pos + 1 ) // 2 ) == 'd' ) : NEW_LINE INDENT return pos % 2 ? 'd' : 'e' NEW_LINE DEDENT return pos % 2 ? 'e' : 'd' NEW_LINE DEDENT
def HasCloseElements ( numbers , threshold ) : NEW_LINE INDENT for i in range ( len ( numbers ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( numbers ) ) : NEW_LINE INDENT distance = abs ( numbers [ i ] - numbers [ j ] ) NEW_LINE if ( distance < threshold ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def TruncateNumber ( number ) : NEW_LINE INDENT return math . ceil ( number ** ( 1. / 3. ) ) NEW_LINE DEDENT
def BelowZero ( operations ) : NEW_LINE INDENT balance = 0 NEW_LINE for op in operations : NEW_LINE INDENT balance += op NEW_LINE if ( balance < 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def MeanAbsoluteDeviation ( numbers ) : NEW_LINE INDENT sum_num = 0 NEW_LINE for num in range ( numbers ) : NEW_LINE INDENT sum_num += num NEW_LINE DEDENT mean = sum_num / numbers . size ( ) NEW_LINE sum_abs_diff = 0 NEW_LINE for num in range ( numbers ) : NEW_LINE INDENT sum_abs_diff += abs ( num - mean ) NEW_LINE DEDENT return sum_abs_diff / numbers . size ( ) NEW_LINE DEDENT
def Intersperse ( numbers , delimiter ) : NEW_LINE INDENT result = [ ] NEW_LINE if ( numbers . empty ( ) ) : NEW_LINE INDENT return result NEW_LINE DEDENT for i in range ( len ( numbers ) - 1 ) : NEW_LINE INDENT result . append ( numbers [ i ] ) NEW_LINE result . append ( delimiter ) NEW_LINE DEDENT result . append ( numbers [ len ( numbers ) - 1 ] ) NEW_LINE return result NEW_LINE DEDENT
def SumProduct ( numbers ) : NEW_LINE INDENT sum_value = 0 NEW_LINE prod_value = 1 NEW_LINE for n in range ( numbers ) : NEW_LINE INDENT sum_value += n NEW_LINE prod_value *= n NEW_LINE DEDENT return { sum_value , prod_value } NEW_LINE DEDENT
def AllPrefixes ( s ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( 1 , len ( s ) + 1 ) : NEW_LINE INDENT result . append ( s [ 0 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def ParseMusic ( music_string ) : NEW_LINE INDENT current = "" NEW_LINE result = [ ] NEW_LINE for i in range ( len ( music_string ) + 1 ) : NEW_LINE INDENT if ( i == len ( music_string ) or music_string [ i ] == ' ' ) : NEW_LINE INDENT if ( current == "o" ) : NEW_LINE INDENT result . append ( 4 ) NEW_LINE DEDENT if ( current == "o|" ) : NEW_LINE INDENT result . append ( 2 ) NEW_LINE DEDENT if ( current == ".|" ) : NEW_LINE INDENT result . append ( 1 ) NEW_LINE DEDENT current . clear ( ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def Strlen ( s ) : NEW_LINE INDENT return len ( s ) NEW_LINE DEDENT
def Factorize ( n ) : NEW_LINE INDENT factors = [ ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT n //= i NEW_LINE factors . append ( i ) NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT return factors NEW_LINE DEDENT
def Concatenate ( strings ) : NEW_LINE INDENT result = "" NEW_LINE for s in strings : NEW_LINE INDENT result += s NEW_LINE DEDENT return result NEW_LINE DEDENT
def GetPositive ( l ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT if ( l [ i ] > 0 ) : NEW_LINE INDENT result . append ( l [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def SortEven ( l ) : NEW_LINE INDENT evens = [ ] NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT evens . append ( l [ i ] ) NEW_LINE DEDENT sort ( evens . begin ( ) , evens . end ( ) ) NEW_LINE result = [ ] NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT result . append ( evens [ i // 2 ] ) NEW_LINE DEDENT if ( i % 2 == 1 ) : NEW_LINE INDENT result . append ( l [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def DecodeCyclic ( s ) : NEW_LINE INDENT output = "" NEW_LINE i = 0 NEW_LINE while i <= len ( s ) - 3 : NEW_LINE INDENT x = s [ i + 2 ] + s [ i , 2 ] NEW_LINE output += x NEW_LINE i += 3 NEW_LINE DEDENT return output + s [ i ] NEW_LINE DEDENT
def CarRaceCollision ( n ) : NEW_LINE INDENT return int ( n ** ( 2. / 2. ) ) NEW_LINE DEDENT
def IncrList ( l ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT result . append ( i + 1 ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def PairsSumToZero ( l ) : NEW_LINE INDENT for i in range ( len ( l ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( l ) ) : NEW_LINE INDENT if ( l [ i ] + l [ j ] == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def ChangeBase ( x , b ) : NEW_LINE INDENT ret = [ 0 ] * b NEW_LINE while ( x > 0 ) : NEW_LINE INDENT ret . append ( 0 , to_string ( x % b ) ) NEW_LINE x //= b NEW_LINE DEDENT return ret NEW_LINE DEDENT
def Median ( l ) : NEW_LINE INDENT l . sort ( ) NEW_LINE if ( len ( l ) % 2 == 1 ) : NEW_LINE INDENT return l [ len ( l ) // 2 ] NEW_LINE DEDENT return ( l [ len ( l ) // 2 ] + l [ len ( l ) // 2 - 1 ] ) / 2 NEW_LINE DEDENT
def DecodeShift ( s ) : NEW_LINE INDENT result = "" NEW_LINE for ch in range ( s ) : NEW_LINE INDENT w = ( ch + 21 - 'a' ) % 26 + 'a' NEW_LINE result += w NEW_LINE DEDENT return result NEW_LINE DEDENT
def BelowThreshold ( l , t ) : NEW_LINE INDENT for n in range ( l ) : NEW_LINE INDENT if ( n >= t ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def CorrectBracketing ( brackets ) : NEW_LINE INDENT depth = 0 NEW_LINE for b in range ( brackets ) : NEW_LINE INDENT if ( b == '<' ) : NEW_LINE INDENT depth += 1 NEW_LINE DEDENT if ( b == '>' ) : NEW_LINE INDENT depth -= 1 NEW_LINE DEDENT if ( depth < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return depth == 0 NEW_LINE DEDENT
def Monotonic ( l ) : NEW_LINE INDENT incr = 0 NEW_LINE decr = 0 NEW_LINE for i in range ( 1 , len ( l ) ) : NEW_LINE INDENT if ( l [ i ] > l [ i - 1 ] ) : NEW_LINE INDENT incr = 1 NEW_LINE DEDENT if ( l [ i ] < l [ i - 1 ] ) : NEW_LINE INDENT decr = 1 NEW_LINE DEDENT DEDENT return incr + decr != 2 NEW_LINE DEDENT
def Derivative ( xs ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( 1 , len ( xs ) ) : NEW_LINE INDENT result . append ( i * xs [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def VowelsCount ( s ) : NEW_LINE INDENT vowels = "aeiouAEIOU" NEW_LINE count = 0 NEW_LINE for ch in range ( s ) : NEW_LINE INDENT if ( vowels [ ch ] != string :: npos ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( s [ len ( s ) - 1 ] == 'y' or s [ len ( s ) - 1 ] == 'Y' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def DigitSum ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for c in range ( s ) : NEW_LINE INDENT if ( isupper ( c ) ) : NEW_LINE INDENT sum += c NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def FruitDistribution ( s , n ) : NEW_LINE INDENT num1 = "" NEW_LINE num2 = "" NEW_LINE flag = False NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( isdigit ( s [ i ] ) ) : NEW_LINE INDENT if ( not flag ) : NEW_LINE INDENT num1 += s [ i ] NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT num2 += s [ i ] NEW_LINE DEDENT DEDENT elif ( not flag and num1 . length ( ) > 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT DEDENT return n - stoi ( num1 ) - stoi ( num2 ) ) NEW_LINE DEDENT
def Pluck ( arr ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT if ( result . empty ( ) ) : NEW_LINE INDENT result . append ( arr [ i ] ) NEW_LINE result . append ( i ) NEW_LINE DEDENT elif ( arr [ i ] < result [ 0 ] ) : NEW_LINE INDENT result [ 0 ] = arr [ i ] NEW_LINE result [ 1 ] = i NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def StrangeSortList ( lst ) : NEW_LINE INDENT res = [ ] NEW_LINE l = 0 NEW_LINE r = len ( lst ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT res . append ( lst [ l ] ) NEW_LINE l += 1 NEW_LINE res . append ( lst [ r ] ) NEW_LINE r -= 1 NEW_LINE DEDENT if ( l == r ) : NEW_LINE INDENT res . append ( lst [ l ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def TriangleArea ( a , b , c ) : NEW_LINE INDENT if ( a + b <= c or a + c <= b or b + c <= a ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT s = ( a + b + c ) // 2 NEW_LINE return int ( s * ( s - a ) * ( s - b ) * ( s - c ) ) NEW_LINE DEDENT
def WillItFly ( q , w ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( q ) ) : NEW_LINE INDENT if ( q [ i ] != q [ len ( q ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += q [ i ] NEW_LINE DEDENT return sum <= w NEW_LINE DEDENT
def IsCube ( a ) : NEW_LINE INDENT a = math . abs ( a ) NEW_LINE i = round ( pow ( a , 1.0 / 3 ) ) NEW_LINE return pow ( i , 3 ) == a NEW_LINE DEDENT
def HexKey ( num ) : NEW_LINE INDENT key = "2357BD" NEW_LINE total = 0 NEW_LINE for c in range ( num ) : NEW_LINE INDENT if ( key [ c ] != string :: npos ) : NEW_LINE INDENT total += 1 NEW_LINE DEDENT DEDENT return total NEW_LINE DEDENT
def DecimalToBinary ( dec ) : NEW_LINE INDENT ans = [ "0" ] * 16 NEW_LINE while ( dec != 0 ) : NEW_LINE INDENT while ( dec > 0 ) : NEW_LINE INDENT ans . append ( 0 , str ( dec % 2 ) ) NEW_LINE dec //= 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans += "0" NEW_LINE DEDENT return "db" + ans + "db" NEW_LINE DEDENT
def PrimeLength ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE if ( l < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , l ) : NEW_LINE INDENT if ( l % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def StartsOneEnds ( n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 18 * pow ( 10 , n - 2 ) NEW_LINE DEDENT
def Add ( lst ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , len ( lst ) ) : NEW_LINE INDENT if ( lst [ i ] % 2 == 0 ) : NEW_LINE INDENT sum += lst [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def GetRow ( lst , x ) : NEW_LINE INDENT coords = [ ] NEW_LINE for i in range ( len ( lst ) ) : NEW_LINE INDENT for j in range ( len ( lst [ i ] ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( lst [ i ] [ j ] == x ) : NEW_LINE INDENT coords . append ( { i , j } ) NEW_LINE DEDENT DEDENT DEDENT return coords NEW_LINE DEDENT
def NextSmallest ( lst ) : NEW_LINE INDENT lst . sort ( ) NEW_LINE for i in range ( 1 , len ( lst ) ) : NEW_LINE INDENT if ( lst [ i ] != lst [ i - 1 ] ) : NEW_LINE INDENT return lst [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def AnyInt ( a , b , c ) : NEW_LINE INDENT if ( round ( a ) != a or round ( b ) != b or round ( c ) != c ) : NEW_LINE INDENT return False NEW_LINE DEDENT a += b == c or a + c == b or b + c == a NEW_LINE DEDENT return a + b == c or a + c == a NEW_LINE DEDENT
def CountUpTo ( n ) : NEW_LINE INDENT primes = [ ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT is_prime = True NEW_LINE for j in range ( 2 , i ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT is_prime = False NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( is_prime ) : NEW_LINE INDENT primes . append ( i ) NEW_LINE DEDENT DEDENT return primes NEW_LINE DEDENT
def ClosestInteger ( value ) : NEW_LINE INDENT w = stod ( value ) NEW_LINE return round ( w ) NEW_LINE DEDENT
def MakeAPile ( n ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT result . append ( n + 2 * i ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def WordsString ( s ) : NEW_LINE INDENT current = "" NEW_LINE words = [ ] NEW_LINE for i in range ( len ( s ) + 1 ) : NEW_LINE INDENT if ( i == len ( s ) or s [ i ] == ' ' or s [ i ] == ',' ) : NEW_LINE INDENT words . append ( current ) NEW_LINE current . clear ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT current += s [ i ] NEW_LINE DEDENT return words NEW_LINE DEDENT
def RoundedAvg ( n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return "- 1" NEW_LINE DEDENT num = ( m + n ) // 2 NEW_LINE ret = [ 0 ] * m NEW_LINE while ( num > 0 ) : NEW_LINE INDENT ret . append ( 0 , str ( num % 2 ) ) NEW_LINE num //= 2 NEW_LINE DEDENT return ret NEW_LINE DEDENT
def UniqueDigits ( x ) : NEW_LINE INDENT digits = [ ] NEW_LINE for n in sorted ( x ) : NEW_LINE INDENT is_unique = True NEW_LINE for c in range ( ord ( n ) ) : NEW_LINE INDENT if ( c % 2 == 0 ) : NEW_LINE INDENT is_unique = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( is_unique ) : NEW_LINE INDENT digits . append ( n ) NEW_LINE DEDENT DEDENT if ( is_unique ) : NEW_LINE INDENT digits . append ( n ) NEW_LINE DEDENT return digits NEW_LINE DEDENT
def CountNums ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for n in range ( arr ) : NEW_LINE INDENT neg = n < 0 ? - 1 : 1 NEW_LINE n = abs ( n ) NEW_LINE digits = [ 0 ] * 9 NEW_LINE for c in range ( '0' , n ) : NEW_LINE INDENT digits . append ( ord ( c ) - ord ( '0' ) ) NEW_LINE DEDENT digits [ 0 ] *= neg NEW_LINE sum = 0 NEW_LINE for d in sorted ( digits , reverse = True ) : NEW_LINE INDENT sum += d NEW_LINE DEDENT if ( sum > 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def MoveOneBall ( arr ) : NEW_LINE INDENT if ( arr . empty ( ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT num = 0 NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT num += 1 NEW_LINE DEDENT DEDENT if ( arr [ arr [ size ( arr ) - 1 ] > arr [ 0 ] ) : NEW_LINE INDENT num += 1 NEW_LINE DEDENT if ( num < 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def Exchange ( lst1 , lst2 ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for n in sorted ( lst1 ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT for n in sorted ( lst2 ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if ( even >= odd ) : NEW_LINE INDENT return "YES" NEW_LINE DEDENT return "NO" NEW_LINE DEDENT
def OddCount ( lst ) : NEW_LINE INDENT results = [ ] NEW_LINE original_str = "the number of odd elements in the string i of the input." NEW_LINE for s in sorted ( lst , reverse = True ) : NEW_LINE INDENT sum = 0 NEW_LINE for d in range ( s ) : NEW_LINE INDENT if ( isdigit ( d ) and d % 2 == 1 ) : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT DEDENT result , c = "" , "" NEW_LINE for c in sorted ( original_str ) : NEW_LINE INDENT if ( c == 'i' ) : NEW_LINE INDENT result += str ( sum ) NEW_LINE DEDENT else : NEW_LINE INDENT result += c NEW_LINE DEDENT DEDENT return results NEW_LINE DEDENT
def MinSubArraySum ( nums ) : NEW_LINE INDENT min_sum = numeric_limits < int > :: max ( ) NEW_LINE sum = 0 NEW_LINE for num in range ( nums ) : NEW_LINE INDENT sum += num NEW_LINE if ( min_sum > sum ) : NEW_LINE INDENT min_sum = sum NEW_LINE DEDENT if ( sum > 0 ) : NEW_LINE INDENT sum = 0 NEW_LINE DEDENT DEDENT return min_sum NEW_LINE DEDENT
def MaxFill ( grid , capacity ) : NEW_LINE INDENT res = 0 NEW_LINE for auto in range ( grid ) : NEW_LINE INDENT sum = 0 NEW_LINE for n in range ( well ) : NEW_LINE INDENT sum += n NEW_LINE DEDENT if ( sum > 0 ) : NEW_LINE INDENT res += ( sum - 1 ) // capacity + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def SelectWords ( s , n ) : NEW_LINE INDENT vowels = "aeiouAEIOU" NEW_LINE current = "" NEW_LINE result = [ ] NEW_LINE consonant_num = 0 NEW_LINE for i in range ( len ( s ) + 1 ) : NEW_LINE INDENT if ( i == len ( s ) or s [ i ] == ' ' ) : NEW_LINE INDENT if ( consonant_num == n ) : NEW_LINE INDENT result . append ( current ) NEW_LINE DEDENT current . clear ( ) NEW_LINE consonant_num = 0 NEW_LINE DEDENT else : NEW_LINE INDENT current += s [ i ] NEW_LINE if ( vowels [ s [ i ] == string :: npos ) : NEW_LINE INDENT consonant_num += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def Solution ( lst ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( lst ) ) : NEW_LINE INDENT if ( lst [ i ] % 2 == 1 ) : NEW_LINE INDENT sum += lst [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def AddElements ( arr , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( arr [ i ] >= - 99 and arr [ i ] <= 99 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def GetOddCollatz ( n ) : NEW_LINE INDENT odd_collatz = [ ] NEW_LINE while ( n != 1 ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT odd_collatz . append ( n ) NEW_LINE n = n * 3 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT n //= 2 NEW_LINE DEDENT DEDENT odd_collatz . append ( 1 ) NEW_LINE sort ( odd_collatz ) NEW_LINE return odd_collatz NEW_LINE DEDENT
def IsSorted ( lst ) : NEW_LINE INDENT for i in range ( 1 , len ( lst ) ) : NEW_LINE INDENT if ( lst [ i ] < lst [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i >= 2 and lst [ i ] == lst [ i - 1 ] and lst [ i ] == lst [ i - 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def Intersection ( interval1 , interval2 ) : NEW_LINE INDENT inter1 = max ( interval1 [ 0 ] , interval2 [ 0 ] ) NEW_LINE inter2 = min ( interval1 [ 1 ] , interval2 [ 1 ] ) NEW_LINE l = inter2 - inter1 NEW_LINE if ( l < 2 ) : NEW_LINE INDENT return "NO" NEW_LINE DEDENT for i in range ( 2 , l ) : NEW_LINE INDENT if ( l % i == 0 ) : NEW_LINE INDENT return "NO" NEW_LINE DEDENT DEDENT return "YES" NEW_LINE DEDENT
def ProdSigns ( arr ) : NEW_LINE INDENT if ( arr . empty ( ) ) : NEW_LINE INDENT return - 32768 NEW_LINE DEDENT sum = 0 NEW_LINE prods = 1 NEW_LINE for i in range ( arr ) : NEW_LINE INDENT sum += abs ( i ) NEW_LINE if ( i == 0 ) : NEW_LINE INDENT prods = 0 NEW_LINE DEDENT if ( i < 0 ) : NEW_LINE INDENT prods = - prods NEW_LINE DEDENT DEDENT return sum * prods NEW_LINE DEDENT
def MinPath ( grid , k ) : NEW_LINE INDENT n = len ( grid ) NEW_LINE min_num = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( grid [ i ] [ j ] == 1 ) : NEW_LINE INDENT tmp = [ ] NEW_LINE if ( i != 0 ) : NEW_LINE INDENT tmp . append ( grid [ i - 1 ] [ j ] ) NEW_LINE DEDENT if ( j != 0 ) : NEW_LINE INDENT tmp . append ( grid [ i ] [ j - 1 ] ) NEW_LINE DEDENT if ( i != n - 1 ) : NEW_LINE INDENT tmp . append ( grid [ i + 1 ] [ j ] ) NEW_LINE DEDENT if ( j != n - 1 ) : NEW_LINE INDENT tmp . append ( grid [ i ] [ j + 1 ] ) NEW_LINE DEDENT min_num = * min_element ( tmp . begin ( ) , tmp . end ( ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def Digits ( n ) : NEW_LINE INDENT prod = 0 NEW_LINE for digit in range ( n ) : NEW_LINE INDENT if ( digit % 2 == 1 ) : NEW_LINE INDENT if ( prod == 0 ) : NEW_LINE INDENT prod = 1 NEW_LINE DEDENT prod *= digit - '0' NEW_LINE DEDENT DEDENT DEDENT return prod NEW_LINE DEDENT
def IsNested ( s ) : NEW_LINE INDENT count = 0 NEW_LINE max_count = 0 NEW_LINE for ch in range ( s ) : NEW_LINE INDENT if ( ch == '[' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( ch == ']' ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if ( count < 0 ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT if ( count > max_count ) : NEW_LINE INDENT max_count = count NEW_LINE DEDENT if ( count <= max_count - 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def SumSquares ( lst ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( lst ) : NEW_LINE INDENT sum += ceil ( i ) * ceil ( i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def CanArrange ( arr ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] <= i ) : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
def LargestSmallestIntegers ( lst ) : NEW_LINE INDENT max_neg = 0 NEW_LINE min_pos = 0 NEW_LINE for n in range ( lst ) : NEW_LINE INDENT if ( n < 0 and ( max_neg == 0 or n > max_neg ) ) : NEW_LINE INDENT max_neg = n NEW_LINE DEDENT if ( n > 0 and ( min_pos == 0 or n < min_pos ) ) : NEW_LINE INDENT min_pos = n NEW_LINE DEDENT DEDENT return { max_neg , min_pos } NEW_LINE DEDENT
def FixSpaces ( text ) : NEW_LINE INDENT res = "" NEW_LINE space_len = 0 NEW_LINE for i in range ( len ( text ) + 1 ) : NEW_LINE INDENT if ( i == len ( text ) or text [ i ] != ' ' ) : NEW_LINE INDENT if ( space_len == 1 ) : NEW_LINE INDENT res += '_' NEW_LINE DEDENT if ( space_len == 2 ) : NEW_LINE INDENT res += "__" NEW_LINE DEDENT if ( space_len > 2 ) : NEW_LINE INDENT res += '-' NEW_LINE DEDENT space_len = 0 NEW_LINE if ( i != len ( text ) ) : NEW_LINE INDENT res += text [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT space_len += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def FileNameCheck ( file_name ) : NEW_LINE INDENT digit_num = 0 NEW_LINE dot_num = 0 NEW_LINE if len ( file_name ) < 5 or not isalpha ( file_name [ 0 ] ) : NEW_LINE INDENT return "No" NEW_LINE DEDENT suffix = file_name [ len ( file_name ) - 4 ] NEW_LINE if ( suffix != ".txt" and suffix != ".exe" and suffix != ".dll" ) : NEW_LINE INDENT return "No" NEW_LINE DEDENT for c in range ( file_name ) : NEW_LINE INDENT if ( isdigit ( c ) ) : NEW_LINE INDENT digit_num += 1 NEW_LINE DEDENT if ( c == '.' ) : NEW_LINE INDENT dot_num += 1 NEW_LINE DEDENT DEDENT if ( digit_num > 3 or dot_num != 1 ) : NEW_LINE INDENT return "No" NEW_LINE DEDENT DEDENT return "Yes" NEW_LINE DEDENT
def SumSquares ( lst ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( lst ) ) : NEW_LINE INDENT if ( i % 3 == 0 ) : NEW_LINE INDENT sum += lst [ i ] * lst [ i ] NEW_LINE DEDENT elif ( i % 4 == 0 ) : NEW_LINE INDENT sum += lst [ i ] * lst [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += lst [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def WordsInSentence ( sentence ) : NEW_LINE INDENT result = "" NEW_LINE current = "" NEW_LINE for i in range ( len ( sentence ) ) : NEW_LINE INDENT if ( i == len ( sentence ) or sentence [ i ] == ' ' ) : NEW_LINE INDENT is_prime = True NEW_LINE l = len ( current ) NEW_LINE if ( l < 2 ) : NEW_LINE INDENT is_prime = False NEW_LINE break NEW_LINE DEDENT for j in range ( 2 , l ) : NEW_LINE INDENT if ( l % j == 0 ) : NEW_LINE INDENT is_prime = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( is_prime ) : NEW_LINE INDENT result += ' ' NEW_LINE DEDENT current = "" NEW_LINE DEDENT DEDENT if ( result . length ( ) > 0 ) : NEW_LINE INDENT result . pop ( ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def Simplify ( x , n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT if ( x [ i ] == '/' ) : NEW_LINE INDENT a = stoi ( x [ 0 ] ) NEW_LINE b = stoi ( x [ i + 1 ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( n ) ) : NEW_LINE INDENT if ( n [ i ] == '/' ) : NEW_LINE INDENT c = stoi ( n [ 0 ] ) NEW_LINE d = stoi ( n [ i + 1 ) ) NEW_LINE DEDENT DEDENT return ( a * c ) % ( b * d ) == 0 NEW_LINE DEDENT
def SpecialFilter ( nums ) : NEW_LINE INDENT count = 0 NEW_LINE for num in range ( nums ) : NEW_LINE INDENT if ( num > 10 ) : NEW_LINE INDENT w = str ( num ) NEW_LINE if ( w [ 0 ] % 2 == 1 and w [ 1 ] % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def GetMatrixTriples ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr . append ( i * i - i + 1 ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] + arr [ k ] ) % 3 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def DoubleTheDifference ( lst ) : NEW_LINE INDENT sum = 0 NEW_LINE for d in sorted ( lst ) : NEW_LINE INDENT num = round ( d ) NEW_LINE if ( d == num ) : NEW_LINE INDENT if ( num > 0 and num % 2 == 1 ) : NEW_LINE INDENT sum += num * num NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
def Compare ( game , guess ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( game ) ) : NEW_LINE INDENT result . append ( abs ( game [ i ] - guess [ i ] ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def StrongestExtension ( class_name , extensions ) : NEW_LINE INDENT strongest = "" NEW_LINE max = numeric_limits < int > :: min ( ) NEW_LINE for extension in sorted ( extensions , reverse = True ) : NEW_LINE INDENT strength = 0 NEW_LINE for chr in range ( '0' , 9 ) : NEW_LINE INDENT if ( isupper ( chr ) ) : NEW_LINE INDENT strength += 1 NEW_LINE DEDENT if ( islower ( chr ) ) : NEW_LINE INDENT strength -= 1 NEW_LINE DEDENT DEDENT if ( strength > max ) : NEW_LINE INDENT max = strength NEW_LINE strongest = extension NEW_LINE DEDENT DEDENT return class_name + '.' + strongest NEW_LINE DEDENT
def IntToMiniRoman ( number ) : NEW_LINE INDENT num = [ 1000 , 900 , 500 , 400 , 100 , 90 , 50 , 40 , 10 , 9 , 5 , 4 , 1 ] NEW_LINE sym = [ "m" , "cm" , "d" , "cd" , "c" , "xc" , "l" , "xl" , "x" , "iv" , "i" ] NEW_LINE pos = 0 NEW_LINE while ( number > 0 ) : NEW_LINE INDENT while ( number >= num [ pos ] ) : NEW_LINE INDENT res += sym [ pos ] NEW_LINE number -= num [ pos ] NEW_LINE DEDENT if ( number > 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def Eat ( number , need , remaining ) : NEW_LINE INDENT return need > remaining ? vector < int > { number + remaining , 0 } : vector < int > { number + need , remaining - need } NEW_LINE DEDENT
def DoAlgebra ( ops , operands ) : NEW_LINE INDENT nums = [ 0 ] * MAX NEW_LINE current_ops = [ ] NEW_LINE i = len ( current_ops ) - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( current_ops [ i ] == "**" ) : NEW_LINE INDENT nums [ i ] = pow ( nums [ i ] , nums [ i + 1 ] ) NEW_LINE nums . erase ( current_ops . begin ( ) + i ) NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( current_ops [ i ] == "//" ) : NEW_LINE INDENT nums [ i ] //= nums [ i + 1 ] NEW_LINE DEDENT nums . erase ( current_ops [ begin ( ) + i + 1 ) NEW_LINE current_ops . erase ( current_ops [ begin ( ) + i ) NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT if ( current_ops [ i ] == "+" ) : NEW_LINE INDENT nums [ i ] += nums [ i + 1 ] NEW_LINE nums . erase ( nums [ begin ( ) + i + 1 ) NEW_LINE current_ops . erase ( current_ops [ begin ( ) + i ) NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return nums [ 0 ] NEW_LINE DEDENT
def GenerateIntegers ( a , b ) : NEW_LINE INDENT lower = max ( 2 , min ( a , b ) ) NEW_LINE upper = min ( 8 , max ( a , b ) ) NEW_LINE result = [ ] NEW_LINE for i in range ( lower , upper + 1 ) : NEW_LINE INDENT result . append ( i ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def IsStepNum ( n ) : NEW_LINE INDENT prev_digit = - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT cur_digit = n % 10 NEW_LINE if ( prev_digit == - 1 ) : NEW_LINE INDENT prev_digit = cur_digit NEW_LINE DEDENT else : NEW_LINE INDENT if ( abs ( prev_digit - cur_digit ) != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT prev_digit = cur_digit NEW_LINE n //= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT
def NumOfWays ( n , k ) : NEW_LINE INDENT p = 1 NEW_LINE if ( k % 2 ) : NEW_LINE INDENT p = - 1 NEW_LINE DEDENT return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n NEW_LINE DEDENT
def FindDivisors ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i <= int ( n ** ( 0.5 ) ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( i ) NEW_LINE v . append ( n // i ) NEW_LINE DEDENT DEDENT DEDENT return v NEW_LINE DEDENT
def EggDrop ( n , k ) : NEW_LINE INDENT if k == 1 or k == 0 : NEW_LINE INDENT return k NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return k NEW_LINE DEDENT min = 2147483647 NEW_LINE for x in range ( 1 , k + 1 ) : NEW_LINE INDENT res = max ( EggDrop ( n - 1 , x - 1 ) , EggDrop ( n , k - x ) ) NEW_LINE if ( res < min ) : NEW_LINE INDENT min = res NEW_LINE DEDENT DEDENT return min + 1 NEW_LINE DEDENT
def IsPowerOfTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ceil ( log2 ( n ) ) == floor ( log2 ( n ) ) NEW_LINE DEDENT
def ShortestPalindrome ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l = i NEW_LINE r = i NEW_LINE while ( l >= 0 and r < n and s [ l ] == s [ r ] ) : NEW_LINE INDENT ans1 += s [ l ] NEW_LINE l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT l = i - 1 NEW_LINE v = i NEW_LINE while ( l >= 0 and r < n and s [ l ] == s [ r ] ) : NEW_LINE INDENT ans2 += s [ l ] NEW_LINE l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT v . append ( ans1 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( v [ i ] != "" ) : NEW_LINE INDENT ans = min ( ans , v [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def MinimumAdjacentDifference ( a , n , k ) : NEW_LINE INDENT min_diff = 10 ** 9 NEW_LINE for i in range ( 0 , k + 1 ) : NEW_LINE INDENT max_diff = 10 ** 9 NEW_LINE for j in range ( n - k - 1 ) : NEW_LINE INDENT for p in range ( i , i + j ) : NEW_LINE INDENT max_diff = max ( max_diff , a [ p + 1 ] - a [ p ] ) NEW_LINE DEDENT DEDENT min_diff = min ( min_diff , max_diff ) NEW_LINE DEDENT return min_diff NEW_LINE DEDENT
def Cal ( a , mid ) : NEW_LINE INDENT chocolate = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT if ( i >= mid ) : NEW_LINE INDENT chocolate += i - mid NEW_LINE DEDENT DEDENT return chocolate NEW_LINE DEDENT
def Check ( v , a , m ) : NEW_LINE INDENT tec = 0 NEW_LINE ans = 0 NEW_LINE b = [ int ( i ) for i in range ( len ( a ) ) ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT tec -= b [ i ] NEW_LINE if ( a [ i ] + tec < v ) : NEW_LINE INDENT mov = v - a [ i ] - tec NEW_LINE ans = ans + mov NEW_LINE tec += mov NEW_LINE b [ i + 2 ] = mov NEW_LINE DEDENT DEDENT return ans <= m NEW_LINE DEDENT
def LargestNum ( arr ) : NEW_LINE INDENT res = 0 NEW_LINE arr . sort ( ) NEW_LINE l = 0 NEW_LINE r = len ( arr ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if ( sum == 0 ) : NEW_LINE INDENT res = max ( res , max ( arr [ l ] , arr [ r ] ) ) NEW_LINE return res NEW_LINE DEDENT elif ( sum < 0 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def BinarySearch ( p , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( p ) - 1 NEW_LINE index = - 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT mid = i + ( j - i ) // 2 NEW_LINE if ( p [ mid ] >= n ) : NEW_LINE INDENT index = mid NEW_LINE j = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = mid + 1 NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
def FindMinLength ( arr ) : NEW_LINE INDENT index = len ( arr ) - 1 NEW_LINE while ( index > 0 and arr [ index ] >= arr [ index - 1 ] ) : NEW_LINE INDENT index -= 1 NEW_LINE DEDENT return index NEW_LINE DEDENT
def MinDigits ( n , k ) : NEW_LINE INDENT digits_num = int ( math . ceil ( n ** ( 10. / 10. ) ) NEW_LINE temp_sum = 0 NEW_LINE result = 0 NEW_LINE x = 0 NEW_LINE v = 0 NEW_LINE while ( num2 != 0 ) : NEW_LINE INDENT sum += num2 % 10 NEW_LINE num2 //= 10 NEW_LINE DEDENT if ( sum <= k ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT else : NEW_LINE INDENT while ( temp > 0 ) : NEW_LINE INDENT v = n // pow ( 10 , temp - 1 ) NEW_LINE temp_sum += v % 10 NEW_LINE if ( temp_sum >= k ) : NEW_LINE INDENT v //= 10 NEW_LINE result = v * pow ( 10 , temp ) NEW_LINE break NEW_LINE DEDENT temp -= 1 NEW_LINE DEDENT x = result - n NEW_LINE return x NEW_LINE DEDENT
def CheckForPerfectSquare ( arr , i , j ) : NEW_LINE INDENT mid = 0 NEW_LINE sum = 0 NEW_LINE for m in range ( i , j + 1 ) : NEW_LINE INDENT sum += arr [ m ] NEW_LINE DEDENT low = 0 NEW_LINE high = sum // 2 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( mid * mid == sum ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( mid * mid > sum ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def MinFlips ( mat , s ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE m = len ( mat ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != s [ i + j ] - '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def ConstructTree ( n , edges ) : NEW_LINE INDENT adjl = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT adjl . append ( vector < int > ( ) ) NEW_LINE DEDENT for e in edges : NEW_LINE INDENT u = e [ 0 ] NEW_LINE v = e [ 1 ] NEW_LINE adjl [ u ] . append ( v ) NEW_LINE adjl [ v ] . append ( u ) NEW_LINE DEDENT return adjl NEW_LINE DEDENT
def FindSumOfValues ( v , parent , values_children ) : NEW_LINE INDENT cur_node = v NEW_LINE sum = 0 NEW_LINE while ( cur_node != - 1 ) : NEW_LINE INDENT sum += values_children [ cur_node ] NEW_LINE cur_node = parent [ cur_node ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def GetDistinct ( d , count ) : NEW_LINE INDENT ans = 0 NEW_LINE count = pow ( 10 , count - 1 ) NEW_LINE while ( count > 0 ) : NEW_LINE INDENT ans += count * d NEW_LINE count //= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def IsIncreasing ( arr ) : NEW_LINE INDENT for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def MinAdjSwaps ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE cnt_zero = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT cnt_zero [ i ] += 1 NEW_LINE DEDENT DEDENT cnt_swaps = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( cnt_zero [ i ] < ( n - i - 1 ) : NEW_LINE INDENT first = i NEW_LINE while ( first < n and cnt_zero [ first ] < ( n - i - 1 ) ) : NEW_LINE INDENT first += 1 NEW_LINE DEDENT if ( first == n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT cnt_swaps += 1 NEW_LINE DEDENT DEDENT return cnt_swaps NEW_LINE DEDENT
def Solve ( values , salary , mod ) : NEW_LINE INDENT ret = 1 NEW_LINE amt = 0 NEW_LINE while ( len ( values ) > 0 and values [ 0 ] >= salary [ 0 ] ) : NEW_LINE INDENT amt += 1 NEW_LINE values . pop ( ) NEW_LINE DEDENT if ( amt == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ret *= amt -= 1 NEW_LINE ret %= mod NEW_LINE salary . pop ( ) NEW_LINE DEDENT return ret NEW_LINE DEDENT
def OrganizeInOrder ( vec , op , n ) : NEW_LINE INDENT result = [ 0 ] * n NEW_LINE sort ( vec ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE k = 0 NEW_LINE while ( i <= j and k <= n - 2 ) : NEW_LINE INDENT if ( op [ k ] == '<' ) : NEW_LINE INDENT result [ k ] = vec [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT result [ k ] = vec [ j - 1 ] NEW_LINE DEDENT k += 1 NEW_LINE DEDENT result [ n - 1 ] = vec [ i ] NEW_LINE return result NEW_LINE DEDENT
def CountPoints ( n , m , a , b , x , y ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE j = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < m ) : NEW_LINE INDENT if ( a [ i ] + y < b [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( b [ j ] >= a [ i ] - x and b [ j ] <= a [ i ] + y ) : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def AreSame ( a , b ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE b = sorted ( b ) NEW_LINE return a == b NEW_LINE DEDENT
def CountNumberOfStrings ( s ) : NEW_LINE INDENT n = len ( s ) - 1 NEW_LINE count = pow ( 2 , n ) NEW_LINE return count NEW_LINE DEDENT
def PrimePower ( x ) : NEW_LINE INDENT prime_pow = [ ] NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT if i * i > x : NEW_LINE INDENT break NEW_LINE DEDENT if ( x % i == 0 ) : NEW_LINE INDENT p = 1 NEW_LINE while ( x % i == 0 ) : NEW_LINE INDENT x //= i NEW_LINE p *= i NEW_LINE DEDENT prime_pow . append ( p ) NEW_LINE DEDENT DEDENT if ( x > 1 ) : NEW_LINE INDENT prime_pow . append ( x ) NEW_LINE DEDENT DEDENT return prime_pow NEW_LINE DEDENT
def IsPerfect ( n0 ) : NEW_LINE INDENT n = int ( math . sqrt ( n0 ) ) NEW_LINE if ( floor ( n ) != ceil ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def FindSum ( l , r ) : NEW_LINE INDENT arr = [ ] NEW_LINE i = 0 NEW_LINE x = 2 NEW_LINE while ( i <= r ) : NEW_LINE INDENT arr . append ( i + x ) NEW_LINE if ( i + 1 <= r ) : NEW_LINE INDENT arr . append ( i + 1 + x ) NEW_LINE DEDENT x *= - 1 NEW_LINE i += 2 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( l , r ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def Results ( n , k ) : NEW_LINE INDENT return int ( pow ( n , 1.0 / pow ( 2 , k ) ) ) NEW_LINE DEDENT
def Factors ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE v . append ( 1 ) NEW_LINE for i in range ( 2 , int ( n ** ( 0.5 ) ) + 1 ) : NEW_LINE INDENT if i > int ( n ** ( 0.5 ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE if ( n // i != i ) : NEW_LINE INDENT v . append ( n // i ) NEW_LINE DEDENT DEDENT DEDENT return v NEW_LINE DEDENT
def SmallestNum ( n ) : NEW_LINE INDENT x = pow ( 10.0 , ( n - 1 ) // 2.0 ) NEW_LINE return ceil ( x ) NEW_LINE DEDENT
def Smallest ( s ) : NEW_LINE INDENT a = [ int ( s [ 0 ] ) for i in range ( len ( s ) ) ] NEW_LINE b = [ int ( s [ i ] ) - int ( '0' ) ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if ( ( a [ i ] ) % 2 != 0 ) : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT DEDENT b . sort ( ) NEW_LINE if ( len ( b ) > 1 ) : NEW_LINE INDENT return b [ 0 ] * 10 + b [ 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def Diagonals ( a , b , c , d ) : NEW_LINE INDENT ans = [ ] NEW_LINE ans . append ( sqrt ( ( a * c + b * d ) * ( a * d + b * c ) / ( a * b + c * d ) ) ) NEW_LINE ans . append ( sqrt ( ( a * c + b * d ) * ( a * b + c * d ) / ( a * d + b * c ) ) ) NEW_LINE return ans NEW_LINE DEDENT
def FindNumberOfDigits ( n , bas ) : NEW_LINE INDENT dig = floor ( log ( n ) / log ( bas ) ) + 1 ) NEW_LINE return dig NEW_LINE DEDENT
def NGon ( n ) : NEW_LINE INDENT pro_angle_var = 0 NEW_LINE if ( n % 4 == 0 ) : NEW_LINE INDENT pro_angle_var = math . radians ( n ) / 180 NEW_LINE DEDENT else : NEW_LINE INDENT pro_angle_var = math . radians ( n ) / 180 NEW_LINE DEDENT neg_x = 1.0e+99 NEW_LINE pos_x = - 1.0e+99 NEW_LINE neg_y = 1.0e+99 NEW_LINE for j in range ( n ) : NEW_LINE INDENT px = cos ( 2 * numbers :: pi * j / n + pro_angle_var ) NEW_LINE py = sin ( 2 * numbers :: pi * j / n + pro_angle_var ) NEW_LINE neg_x = min ( neg_x , px ) NEW_LINE pos_x = max ( pos_x , px ) NEW_LINE neg_y = min ( neg_y , py ) NEW_LINE DEDENT opt2 = max ( pos_x - neg_x , pos_y - neg_y ) NEW_LINE return opt2 / math . radians ( numbers :: pi / n ) / 2 ) NEW_LINE DEDENT
def FindMaxK ( n ) : NEW_LINE INDENT p = log2 ( n ) NEW_LINE return pow ( 2 , p ) NEW_LINE DEDENT
def NthFibo ( n ) : NEW_LINE INDENT a = ( pow ( 5 , 0.5 ) + 1 ) / 2 NEW_LINE b = ( - 1 * pow ( 5 , 0.5 ) + 1 ) / 2 NEW_LINE r = pow ( 5 , 0.5 ) NEW_LINE ans = ( pow ( a , n ) - pow ( b , n ) ) / r NEW_LINE return ans NEW_LINE DEDENT
def FindProb ( l , r ) : NEW_LINE INDENT count_of_ps = int ( math . sqrt ( r ) ) - ceil ( sqrt ( l ) ) + 1 ) NEW_LINE total = r - l + 1 NEW_LINE prob = count_of_ps // total NEW_LINE return prob NEW_LINE DEDENT
def PreviousFibonacci ( n ) : NEW_LINE INDENT a = n // ( ( 1 + sqrt ( 5 ) ) / 2.0 ) NEW_LINE return round ( a ) NEW_LINE DEDENT
def DistPrime ( arr , all_primes ) : NEW_LINE INDENT list1 = [ ] NEW_LINE for i in range ( all_primes ) : NEW_LINE INDENT for j in range ( arr ) : NEW_LINE INDENT if ( j % i == 0 ) : NEW_LINE INDENT list1 . append ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return list1 NEW_LINE DEDENT
def GetArray ( n ) : NEW_LINE INDENT ans = [ ] NEW_LINE p2 = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT ans . append ( p2 ) NEW_LINE DEDENT n >>= 1 NEW_LINE p2 *= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def MaximumLength ( a ) : NEW_LINE INDENT counts = [ 11 ] * 11 NEW_LINE ans = 0 NEW_LINE for index in range ( len ( a ) ) : NEW_LINE INDENT counts [ a [ index ] ] += 1 NEW_LINE k = [ ] NEW_LINE for i in range ( counts ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT k . append ( i ) NEW_LINE DEDENT DEDENT k . sort ( ) NEW_LINE if ( k [ 0 ] == k [ len ( k ) - 2 ] and k [ len ( k ) - 1 ] == 1 ) : NEW_LINE INDENT ans = index NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT
def MaxEdges ( n ) : NEW_LINE INDENT edges = floor ( n * n / 4 ) NEW_LINE return edges NEW_LINE DEDENT
def FindK ( n , k ) : NEW_LINE INDENT a = [ ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT return a [ k - 1 ] NEW_LINE DEDENT
def IsKeith ( x , temp ) : NEW_LINE INDENT terms = [ ] NEW_LINE n = 0 NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT terms . append ( temp % 10 ) NEW_LINE temp = temp // 10 NEW_LINE n += 1 NEW_LINE DEDENT reverse ( terms , terms ) NEW_LINE next_term = 0 NEW_LINE i = n NEW_LINE while ( next_term < x ) : NEW_LINE INDENT next_term += terms [ i - j ] NEW_LINE DEDENT terms . append ( next_term ) NEW_LINE i += 1 NEW_LINE DEDENT return next_term == x NEW_LINE DEDENT
def Factors ( n , k ) : NEW_LINE INDENT v = [ ] NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT v . append ( 2 ) NEW_LINE n //= 2 NEW_LINE DEDENT if ( len ( v ) >= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 3 , n , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE v . append ( i ) NEW_LINE DEDENT if ( len ( v ) >= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT v . append ( n ) NEW_LINE DEDENT if ( v . size ( ) >= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def SeparateParenGroups ( paren_string ) : NEW_LINE INDENT all_parens = [ ] NEW_LINE current_paren = 0 NEW_LINE current_depth = 0 NEW_LINE for c in range ( paren_string ) : NEW_LINE INDENT if ( c == '(' ) : NEW_LINE INDENT current_depth += 1 NEW_LINE current_paren += c NEW_LINE DEDENT elif ( c == ')' ) : NEW_LINE INDENT current_depth -= 1 NEW_LINE current_paren += c NEW_LINE DEDENT elif ( current_depth == 0 ) : NEW_LINE INDENT all_parens . append ( current_paren ) NEW_LINE current_paren . clear ( ) NEW_LINE DEDENT DEDENT DEDENT return all_parens NEW_LINE DEDENT
def ParseNestedParens ( paren_string ) : NEW_LINE INDENT all_levels = [ ] NEW_LINE level = 0 NEW_LINE max_level = 0 NEW_LINE for i in range ( len ( paren_string ) ) : NEW_LINE INDENT chr = ord ( paren_string [ i ] ) NEW_LINE if ( chr == '(' ) : NEW_LINE INDENT level += 1 NEW_LINE if ( level > max_level ) : NEW_LINE INDENT max_level = level NEW_LINE DEDENT DEDENT if ( chr == ')' ) : NEW_LINE INDENT level -= 1 NEW_LINE if ( level == 0 ) : NEW_LINE INDENT all_levels . append ( max_level ) NEW_LINE max_level = 0 NEW_LINE DEDENT DEDENT return all_levels NEW_LINE DEDENT
def FilterBySubstring ( strings , substring ) : NEW_LINE INDENT result = [ ] NEW_LINE for s in sorted ( strings , reverse = True ) : NEW_LINE INDENT if ( s [ 0 ] != substring ) : NEW_LINE INDENT result . append ( s ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def RollingMax ( numbers ) : NEW_LINE INDENT running_max = 0 NEW_LINE result = [ ] NEW_LINE for n in range ( numbers ) : NEW_LINE INDENT if ( n > running_max ) : NEW_LINE INDENT running_max = n NEW_LINE DEDENT result . append ( running_max ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def MakePalindrome ( s ) : NEW_LINE INDENT if ( s . empty ( ) ) : NEW_LINE INDENT return "" NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT r_str = s [ i ] NEW_LINE if ( r_str == string ( r_str [ 0 ] , r_str [ rend ( ) ) ) : NEW_LINE INDENT n_str = s [ 0 ] NEW_LINE n2_str ( n_str [ 0 ] , n_str . rend ( ) ) NEW_LINE return s + n2_str NEW_LINE DEDENT DEDENT return s [ 0 ] + string ( s [ rbegin ( ) , s [ rend ( ) ) NEW_LINE DEDENT
def StringXor ( a , b ) : NEW_LINE INDENT result = '' NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if ( a [ i ] == b [ i ] ) : NEW_LINE INDENT result += '0' NEW_LINE DEDENT else : NEW_LINE INDENT result += '1' NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def Longest ( strings ) : NEW_LINE INDENT if ( strings . empty ( ) ) : NEW_LINE INDENT return "" NEW_LINE DEDENT max_len = ranges :: max ( views :: map ( strings , & string :: size ) ) NEW_LINE for s in sorted ( strings , reverse = True ) : NEW_LINE INDENT if ( s [ 0 ] == max_len ) : NEW_LINE INDENT return s NEW_LINE DEDENT DEDENT return "" NEW_LINE DEDENT
def StringSequence ( n ) : NEW_LINE INDENT s = "" NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += str ( i ) NEW_LINE s += " " NEW_LINE DEDENT s += str ( n ) NEW_LINE return s NEW_LINE DEDENT
def CountDistinctCharacter ( s ) : NEW_LINE INDENT distinct = set ( ) NEW_LINE for c in sorted ( s , reverse = True ) : NEW_LINE INDENT distinct . add ( c ) NEW_LINE DEDENT return len ( distinct ) NEW_LINE DEDENT
def HowManyTimes ( s , sub ) : NEW_LINE INDENT times = 0 NEW_LINE for i in range ( len ( s ) - sub . length ( ) ) : NEW_LINE INDENT if ( s [ i ] == sub ) : NEW_LINE INDENT times += 1 NEW_LINE DEDENT DEDENT return times NEW_LINE DEDENT
def SortNumbers ( numbers ) : NEW_LINE INDENT to_num = [ 0 , 1 ] NEW_LINE for i in range ( len ( numbers ) ) : NEW_LINE INDENT if ( i == len ( numbers ) or numbers [ i ] == ' ' ) : NEW_LINE INDENT if ( to_num [ current ] == ' ' ) : NEW_LINE INDENT ints . append ( to_num [ current ] ) NEW_LINE current . clear ( ) NEW_LINE DEDENT else : NEW_LINE INDENT current += numbers [ i ] NEW_LINE DEDENT DEDENT ints = [ 0 , "zero" ] NEW_LINE for i in range ( len ( numbers ) - 1 ) : NEW_LINE INDENT result += " " NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def FindClosestElements ( numbers ) : NEW_LINE INDENT closest_pair = [ 0 , numbers [ 1 ] ] NEW_LINE distance = abs ( closest_pair [ 0 ] - closest_pair [ 1 ] ) NEW_LINE for i in range ( len ( numbers ) ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( abs ( numbers [ i ] - numbers [ j ] ) < distance ) : NEW_LINE INDENT closest_pair [ 0 ] = numbers [ i ] NEW_LINE closest_pair [ 1 ] = numbers [ j ] NEW_LINE distance = abs ( numbers [ i ] - numbers [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return closest_pair NEW_LINE DEDENT
def RescaleToUnit ( numbers ) : NEW_LINE INDENT min_num = * min_element ( numbers [ 0 ] , numbers [ end ( ) ) NEW_LINE max_num = * max_element ( numbers [ 0 ] , numbers [ end ( ) ) NEW_LINE result = [ ] NEW_LINE for n in range ( numbers ) : NEW_LINE INDENT result . append ( ( n - min_num ) / ( max_num - min_num ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def FilterIntegers ( values ) : NEW_LINE INDENT result = [ ] NEW_LINE for e in values : NEW_LINE INDENT if ( e . type ( ) == typeid ( int ) ) : NEW_LINE INDENT result . append ( any_cast < int > ( e ) ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def removeDuplicates ( numbers ) : NEW_LINE INDENT counter = { } NEW_LINE for i in range ( numbers ) : NEW_LINE INDENT counter [ i ] = counter [ i ] + 1 NEW_LINE DEDENT vector < int > result = [ ] NEW_LINE for i in range ( numbers ) : NEW_LINE INDENT if ( counter [ i ] == 1 ) : NEW_LINE INDENT result . append ( i ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def FlipCase ( s ) : NEW_LINE INDENT result = "" NEW_LINE for c in range ( s ) : NEW_LINE INDENT if ( islower ( c ) ) : NEW_LINE INDENT result += toupper ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT result += tolower ( c ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def FilterByPrefix ( strings , prefix ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( strings ) ) : NEW_LINE INDENT if ( strings [ i ] . startswith ( prefix ) ) : NEW_LINE INDENT result . append ( strings [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def FindZero ( xs ) : NEW_LINE INDENT ans = 0 NEW_LINE value = 0 NEW_LINE for i in range ( len ( xs ) ) : NEW_LINE INDENT value += xs [ i ] * pow ( ans , i ) NEW_LINE DEDENT while ( abs ( value ) > 1e-6 ) : NEW_LINE INDENT driv = 0 NEW_LINE for i in range ( 1 , xs . size ( ) ) : NEW_LINE INDENT driv += xs [ i ] * pow ( ans , i - 1 ) * i NEW_LINE DEDENT ans -= value // driv NEW_LINE value = 0 NEW_LINE for i in range ( len ( xs ) ) : NEW_LINE INDENT value += xs [ i ] * pow ( ans , i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def SortThird ( l ) : NEW_LINE INDENT thirds = [ ] NEW_LINE for i in range ( len ( l ) , 3 ) : NEW_LINE INDENT thirds . append ( l [ i ] ) NEW_LINE DEDENT sort ( thirds , thirds . end ( ) ) NEW_LINE result = [ ] NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT if ( i % 3 == 0 ) : NEW_LINE INDENT result . append ( thirds [ i // 3 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( l [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def Unique ( l ) : NEW_LINE INDENT s = set ( l ) NEW_LINE s . add ( l [ 0 ] ) NEW_LINE vector < int > result = set ( s . begin ( ) , s . end ( ) ) NEW_LINE sort ( result . begin ( ) , result . end ( ) ) NEW_LINE return result NEW_LINE DEDENT
def MaxElement ( l ) : NEW_LINE INDENT return max_element ( l . begin ( ) , l . end ( ) ) NEW_LINE DEDENT
def TriplesSumToZero ( l ) : NEW_LINE INDENT for i in range ( len ( l ) ) : NEW_LINE INDENT for j in range ( i + 1 , j ) : NEW_LINE INDENT for k in range ( l [ i ] + l [ j ] + l [ k ] == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def Fib4 ( n ) : NEW_LINE INDENT results = [ 0 , 0 , 2 , 0 ] NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT results . append ( results [ i - 4 ] + results [ i - 3 ] + results [ i - 2 ] + results [ i - 1 ] ) NEW_LINE DEDENT return results [ n ] NEW_LINE DEDENT
def IsPalindrome ( text ) : NEW_LINE INDENT pr = ( text [ 0 ] , text [ 1 ] ) NEW_LINE return pr == text NEW_LINE DEDENT
def RemoveVowels ( text ) : NEW_LINE INDENT result = "" NEW_LINE vowels = "aeiou" NEW_LINE for ch in range ( text ) : NEW_LINE INDENT if ( tolower ( ch ) not in vowels ) : NEW_LINE INDENT result += ch NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def SameChars ( s0 , s1 ) : NEW_LINE INDENT set0 = set ( ) NEW_LINE set1 = set ( ) NEW_LINE for c in s0 : NEW_LINE INDENT set1 . add ( c ) NEW_LINE DEDENT return set0 == set1 NEW_LINE DEDENT
def Common ( l1 , l2 ) : NEW_LINE INDENT us = set ( ) NEW_LINE for e1 in range ( l1 ) : NEW_LINE INDENT for e2 in range ( l2 ) : NEW_LINE INDENT if ( e1 == e2 ) : NEW_LINE INDENT us . add ( e1 ) NEW_LINE DEDENT DEDENT DEDENT return ret NEW_LINE DEDENT
def CorrectBracketing ( brackets ) : NEW_LINE INDENT depth = 0 NEW_LINE for b in range ( brackets ) : NEW_LINE INDENT if ( b == '(' ) : NEW_LINE INDENT depth += 1 NEW_LINE DEDENT if ( b == ')' ) : NEW_LINE INDENT depth -= 1 NEW_LINE DEDENT if ( depth < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return depth == 0 NEW_LINE DEDENT
def CircularShift ( x , shift ) : NEW_LINE INDENT xs = str ( x ) NEW_LINE if ( shift > len ( xs ) ) : NEW_LINE INDENT return string ( xs [ rbegin ( ) , xs [ rend ( ) ) NEW_LINE DEDENT return xs [ 0 ] + xs [ 0 ] + xs [ 0 ] NEW_LINE DEDENT
def Search ( lst ) : NEW_LINE INDENT counter = [ 0 ] * MAX NEW_LINE for i in range ( lst ) : NEW_LINE INDENT counter [ i ] += 1 NEW_LINE DEDENT ans = - 1 NEW_LINE for auto in sorted ( counter , reverse = True ) : NEW_LINE INDENT if ( value >= key and key > ans ) : NEW_LINE INDENT ans = key NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def SmallestChange ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( arr ) // 2 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ arr . size ( ) - i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def TotalMatch ( lst1 , lst2 ) : NEW_LINE INDENT sum1 = 0 NEW_LINE for st in lst1 : NEW_LINE INDENT sum1 += len ( st ) NEW_LINE DEDENT sum2 = 0 NEW_LINE for st in lst2 : NEW_LINE INDENT sum2 += len ( st ) NEW_LINE DEDENT return sum1 > sum2 ? lst2 : lst1 NEW_LINE DEDENT
def IsHappy ( s ) : NEW_LINE INDENT if len ( s ) < 3 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( len ( s ) - 2 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] or s [ i ] == s [ i + 2 ] or s [ i + 1 ] == s [ i + 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def NumericalLetterGrade ( grades ) : NEW_LINE INDENT letter_grade = [ ] NEW_LINE for gpa in range ( 4.0 ) : NEW_LINE INDENT if ( gpa == 4.0 ) : NEW_LINE INDENT letter_grade . append ( "A+" ) NEW_LINE DEDENT elif ( gpa > 3.7 ) : NEW_LINE INDENT letter_grade . append ( "A-" ) NEW_LINE DEDENT elif ( gpa > 2.3 ) : NEW_LINE INDENT letter_grade . append ( "B" ) NEW_LINE DEDENT elif ( gpa > 2.0 ) : NEW_LINE INDENT letter_grade . append ( "C+" ) NEW_LINE DEDENT elif ( gpa > 1.7 ) : NEW_LINE INDENT letter_grade . append ( "C-" ) NEW_LINE DEDENT elif ( gpa > 0.7 ) : NEW_LINE INDENT letter_grade . append ( "D" ) NEW_LINE DEDENT elif ( gpa > 0.0 ) : NEW_LINE INDENT letter_grade . append ( "D-" ) NEW_LINE DEDENT else : NEW_LINE INDENT letter_grade . append ( "E" ) NEW_LINE DEDENT DEDENT return letter_grade NEW_LINE DEDENT
def Solve ( n ) : NEW_LINE INDENT bi_str = [ '0' ] * n NEW_LINE sum = 0 NEW_LINE for c in range ( '0' , n ) : NEW_LINE INDENT sum += ord ( c ) - ord ( '0' ) NEW_LINE DEDENT while ( sum > 0 ) : NEW_LINE INDENT bi_str . append ( 0 , str ( sum % 2 ) ) NEW_LINE sum //= 2 NEW_LINE DEDENT return bi_str NEW_LINE DEDENT
def AntiShuffle ( s ) : NEW_LINE INDENT ret = "" NEW_LINE current = "" NEW_LINE for i in range ( len ( s ) + 1 ) : NEW_LINE INDENT if ( i == len ( s ) or s [ i ] == ' ' ) : NEW_LINE INDENT sort ( current , current ) NEW_LINE if ( ! ret . empty ( ) ) : NEW_LINE INDENT ret += ' ' NEW_LINE DEDENT ret += current NEW_LINE current . clear ( ) NEW_LINE DEDENT else : NEW_LINE INDENT current += s [ i ] NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT
def SortArray ( array ) : NEW_LINE INDENT if ( array . empty ( ) ) : NEW_LINE INDENT return array NEW_LINE DEDENT if ( ( array [ 0 ] + array [ 0 ] ) % 2 == 1 ) : NEW_LINE INDENT sort ( array [ begin ( ) , array [ end ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT sort ( array , array . end ( ) , greater < > ( ) ) NEW_LINE DEDENT return array NEW_LINE DEDENT
def Encrypt ( s ) : NEW_LINE INDENT ans = "" NEW_LINE for c in range ( s ) : NEW_LINE INDENT if ( isalpha ( c ) ) : NEW_LINE INDENT ans += ( char ) ( 'a' + ( c - 'a' + 4 ) % 26 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += c NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def IsBored ( s ) : NEW_LINE INDENT is_start = True NEW_LINE sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '.' or s [ i ] == '?' or s [ i ] == '!' ) : NEW_LINE INDENT is_start = True NEW_LINE DEDENT elif ( is_start ) : NEW_LINE INDENT if ( s [ i ] == ' ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == ' ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == 'I' ) : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT is_start = False NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def Encode ( message ) : NEW_LINE INDENT vowels = "aeiouAEIOU" NEW_LINE ret = "" NEW_LINE for c in range ( message ) : NEW_LINE INDENT if ( isupper ( c ) ) : NEW_LINE INDENT c = tolower ( c ) NEW_LINE if ( vowels . find ( c ) != string :: npos ) : NEW_LINE INDENT c = 'a' + ( c - 'a' + 2 ) % 26 NEW_LINE DEDENT DEDENT elif ( islower ( c ) ) : NEW_LINE INDENT c = 'A' + ( c - 'A' + 2 ) % 26 NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT
def Skjkasdkd ( lst ) : NEW_LINE INDENT largest = 0 NEW_LINE for n in range ( lst ) : NEW_LINE INDENT if ( n > largest ) : NEW_LINE INDENT prime = True NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT prime = False NEW_LINE DEDENT DEDENT if ( prime ) : NEW_LINE INDENT largest = n NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE s = str ( largest ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT sum += ord ( s [ i ] ) - ord ( '0' ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def CheckDictCase ( dict ) : NEW_LINE INDENT if ( dict == NULL ) : NEW_LINE INDENT return False NEW_LINE DEDENT is_lower = 0 NEW_LINE is_upper = 0 NEW_LINE for key in sorted ( dict , reverse = True ) : NEW_LINE INDENT for c in range ( key ) : NEW_LINE INDENT if ( islower ( c ) ) : NEW_LINE INDENT is_lower = 1 NEW_LINE DEDENT elif ( isupper ( c ) ) : NEW_LINE INDENT is_upper = 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return is_lower + is_upper == 1 NEW_LINE DEDENT
def Multiply ( a , b ) : NEW_LINE INDENT return ( abs ( a ) % 10 ) * ( abs ( b ) % 10 ) ) NEW_LINE DEDENT
def CountUpper ( s ) : NEW_LINE INDENT u_vowel = "AEIOU" NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] not in u_vowel ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def ByLength ( arr ) : NEW_LINE INDENT num_to = { 1 , "One" } , { 2 , "Two" } , { 3 , "Three" } , { 4 , "Four" } , { 5 , "Five" } , { 6 , "Six" } , { 8 , "Eight" } , { 9 , "Nine" } NEW_LINE arr . sort ( ) NEW_LINE sorted_arr = [ ] NEW_LINE for n in range ( sorted_arr ) : NEW_LINE INDENT if ( n >= 1 and n <= 9 ) : NEW_LINE INDENT new_arr . append ( num_to [ n ] ) NEW_LINE DEDENT DEDENT return new_arr NEW_LINE DEDENT
def f ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE prod = 1 NEW_LINE result = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i NEW_LINE prod *= i NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT result . append ( prod ) NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( sum ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def EvenOddPalindrome ( n ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = str ( i ) NEW_LINE r_str = str ( s [ rbegin ( ) , s [ rend ( ) ) NEW_LINE if ( s == r_str ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT DEDENT DEDENT return { even_count , odd_count } NEW_LINE DEDENT
def Histogram ( test ) : NEW_LINE INDENT count = { } NEW_LINE max = 0 NEW_LINE for i in range ( len ( test ) ) : NEW_LINE INDENT if ( test [ i ] != ' ' ) : NEW_LINE INDENT count [ test [ i ] ] += 1 NEW_LINE if ( count [ test [ i ] ] > max ) : NEW_LINE INDENT max = count [ test [ i ] ] NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def ReverseDelete ( s , c ) : NEW_LINE INDENT ret = "" NEW_LINE for ch in range ( s ) : NEW_LINE INDENT if ( c [ ch ] == string :: npos ) : NEW_LINE INDENT ret += ch NEW_LINE DEDENT DEDENT flag = "False" NEW_LINE if ( ret == string ( ret [ rbegin ( ) , ret [ rend ( ) ) : NEW_LINE INDENT flag = "True" NEW_LINE DEDENT return { ret , flag } NEW_LINE DEDENT
def SortArray ( arr ) : NEW_LINE INDENT bin = [ ] NEW_LINE for i in range ( arr ) : NEW_LINE INDENT b = 0 NEW_LINE n = abs ( i ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT b += n % 2 NEW_LINE n //= 2 NEW_LINE DEDENT bin . append ( b ) NEW_LINE DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT for j in range ( 1 , arr . size ( arr ) : NEW_LINE INDENT if ( bin [ j ] < bin [ j - 1 ] or arr [ j ] < arr [ j - 1 ] ) ) : NEW_LINE INDENT bin [ j ] , arr [ j ] = arr [ j - 1 ] , arr [ j - 1 ] NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT
def GetClosestVowel ( word ) : NEW_LINE INDENT vowels = "AEIOUaeiou" NEW_LINE for i in range ( len ( word ) - 2 ) : NEW_LINE INDENT if ( vowels [ i ] != string :: npos and vowels [ i + 1 ] ) == string :: npos and vowels [ i - 1 ] ) == string :: npos ) : NEW_LINE INDENT return string ( 1 , word [ i ] ) NEW_LINE DEDENT DEDENT return "" NEW_LINE DEDENT
def MatchParens ( lst ) : NEW_LINE INDENT strings = [ lst [ 0 ] + lst [ 1 ] , lst [ 1 ] + lst [ 0 ] ] NEW_LINE for l in sorted ( strings , reverse = True ) : NEW_LINE INDENT count = 0 NEW_LINE for c in range ( l ) : NEW_LINE INDENT if ( c == '(' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( c == ')' ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT DEDENT if ( count < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT DEDENT return "No" NEW_LINE DEDENT
def Maximum ( arr , k ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT return { } NEW_LINE DEDENT arr . sort ( ) NEW_LINE arr . sort ( ) NEW_LINE return vector < int > ( arr [ end ( ) - k , arr [ end ( ) ) NEW_LINE DEDENT
def ValidDate ( date ) : NEW_LINE INDENT if len ( date ) != 10 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i == 2 or i == 5 ) : NEW_LINE INDENT if ( date [ i ] != '-' ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( ! isdigit ( date [ i ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT month = stoi ( date [ 0 ] ) NEW_LINE day = stoi ( date [ 3 ] ) NEW_LINE year = stoi ( date [ 6 , 4 ) NEW_LINE if ( month < 1 or month > 31 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( day == 31 and ( month == 4 or month == 9 or month == 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def SplitWords ( txt ) : NEW_LINE INDENT current = [ ] NEW_LINE result = [ ] NEW_LINE if ( len ( txt ) != string :: npos ) : NEW_LINE INDENT for i in range ( 0 , len ( txt ) , 1 ) : NEW_LINE INDENT if ( i == len ( txt ) or txt [ i ] == ' ' ) : NEW_LINE INDENT if ( current . length ( ) > 0 ) : NEW_LINE INDENT result . append ( current ) NEW_LINE DEDENT else : NEW_LINE INDENT current += txt [ i ] NEW_LINE DEDENT DEDENT if ( txt [ 0 ] == ' ' ) : NEW_LINE INDENT num += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def Tri ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return [ 1 ] NEW_LINE DEDENT tris = [ 1 , 3 ] * ( n + 1 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT tris . append ( i // 2 + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT tris . append ( i ) NEW_LINE DEDENT DEDENT return tris NEW_LINE DEDENT
def CheckIfLastCharIsALetter ( txt ) : NEW_LINE INDENT if ( len ( txt ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isalpha ( txt [ len ( txt ) - 1 ] ) and ( len ( txt ) == 1 or not isalpha ( txt [ len ( txt ) - 2 ] ) ) NEW_LINE DEDENT
def OrderByPoints ( nums ) : NEW_LINE INDENT result = [ ] NEW_LINE for num in range ( nums ) : NEW_LINE INDENT w = str ( abs ( num ) ) NEW_LINE sum = 0 NEW_LINE for c in range ( '0' , 9 ) : NEW_LINE INDENT sum += ord ( c ) - ord ( '0' ) NEW_LINE DEDENT if ( num < 0 ) : NEW_LINE INDENT sum -= 2 * ( w [ 0 ] - ord ( '0' ) NEW_LINE DEDENT result . append ( sum ) NEW_LINE DEDENT for i in range ( len ( nums ) ) : NEW_LINE INDENT j = 1 NEW_LINE while ( j < len ( nums ) ) : NEW_LINE INDENT if ( result [ j - 1 ] > result [ j ] ) : NEW_LINE INDENT result [ j ] , nums [ j - 1 ] = nums [ j - 1 ] , nums [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return nums NEW_LINE DEDENT
def Bf ( planet1 , planet2 ) : NEW_LINE INDENT planets = [ "Mercury" , "Venus" , "Earth" , "Mars" , "Saturn" , "Uranus" , "Neptune" ] NEW_LINE auto it1 = find ( planets [ 0 ] , planets [ 1 ] , planet1 ) NEW_LINE idx1 = it1 == planets [ 1 ] ? - 1 : it1 - planets [ 1 ] NEW_LINE idx2 = find ( planets [ 0 ] , planets [ 1 ] , planet2 ) NEW_LINE if ( idx1 == - 1 or idx2 == - 1 ) : NEW_LINE INDENT return { } NEW_LINE DEDENT return idx1 > idx2 ? vector < string > ( planets [ begin ( ) + idx2 + 1 , planets [ begin ( ) + idx1 ) : NEW_LINE INDENT planets [ begin ( ) + idx2 + 1 , planets [ begin ( ) + idx1 ) NEW_LINE DEDENT
def SortedListSum ( lst ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( lst ) : NEW_LINE INDENT if ( i [ 0 ] == 0 ) : NEW_LINE INDENT result . append ( i ) NEW_LINE DEDENT DEDENT result . sort ( ) NEW_LINE result . end ( ) NEW_LINE for l in range ( l , r ) : NEW_LINE INDENT if ( l [ 0 ] == r [ 0 ] ) : NEW_LINE INDENT return l < r NEW_LINE DEDENT return l [ 0 ] < r [ 0 ] NEW_LINE DEDENT
def CycpatternCheck ( a , b ) : NEW_LINE INDENT for i in range ( len ( b ) ) : NEW_LINE INDENT rotate = b [ i ] + b [ 0 ] NEW_LINE if ( a . find ( rotate ) != string :: npos ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def EvenOddCount ( num ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE for i in range ( ord ( num ) ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT DEDENT return { even_count , odd_count } NEW_LINE DEDENT
def FindMax ( words ) : NEW_LINE INDENT max = "" NEW_LINE max_length = 0 NEW_LINE for word in sorted ( words ) : NEW_LINE INDENT unique = [ ] NEW_LINE for w in range ( w ) : NEW_LINE INDENT if ( find ( unique [ begin ( ) , unique [ end ( ) , w ) == unique [ end ( ) ] ) : NEW_LINE INDENT unique . append ( w ) NEW_LINE DEDENT DEDENT if ( len ( unique ) > max_length or ( unique . size ( ) == max_length and word < max ) : NEW_LINE INDENT max = word NEW_LINE max_length = unique . size ( ) NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def Solve ( s ) : NEW_LINE INDENT no_letter = True NEW_LINE result = "" NEW_LINE for ch in range ( s ) : NEW_LINE INDENT if ( isupper ( ch ) ) : NEW_LINE INDENT ch = tolower ( ch ) NEW_LINE no_letter = False NEW_LINE DEDENT elif ( islower ( ch ) ) : NEW_LINE INDENT ch = toupper ( ch ) NEW_LINE no_letter = False NEW_LINE DEDENT else : NEW_LINE INDENT ch = str ( ch ) NEW_LINE no_letter = False NEW_LINE DEDENT result += ch NEW_LINE DEDENT if ( no_letter ) : NEW_LINE INDENT return string ( s . rbegin ( ) , s . rend ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return result NEW_LINE DEDENT DEDENT
def MostFrequent ( arr , n ) : NEW_LINE INDENT hp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in hp ) : NEW_LINE INDENT hp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT max_count = 0 NEW_LINE res = - 1 NEW_LINE for entry in hp : NEW_LINE INDENT if ( max_count < entry . second ) : NEW_LINE INDENT res = entry . first NEW_LINE max_count = entry . second NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def Find ( a , b , k , n1 , n2 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 0 , n2 ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT missing = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if ( s [ a [ i ] not in s ) : NEW_LINE INDENT missing += 1 NEW_LINE DEDENT if ( missing == k ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def SolveQuery ( start , end , arr ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for auto in sorted ( mp , reverse = True ) : NEW_LINE INDENT if ( key == value ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def Segregate ( arr , size ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] <= 0 ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT
def CountTriplets ( a , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( a [ i ] ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT xr = a [ i ] ^ a [ j ] NEW_LINE if ( s [ xr ] != a [ i ] and xr != a [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count // 3 NEW_LINE DEDENT
def LeastFrequent ( arr , n ) : NEW_LINE INDENT hp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in hp ) : NEW_LINE INDENT hp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT min_count = n + 1 NEW_LINE res = - 1 NEW_LINE for entry in sorted ( hp , reverse = True ) : NEW_LINE INDENT if ( min_count >= entry . second ) : NEW_LINE INDENT res = entry . first NEW_LINE min_count = entry . second NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def FindPermutations ( arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE max_ind = - 1 NEW_LINE min_ind = 10000000 NEW_LINE n = len ( arr ) NEW_LINE index_of = [ 0 ] * 100 NEW_LINE for i in range ( n ) : NEW_LINE INDENT index_of [ arr [ i ] ] = i + 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT max_ind = max ( max_ind , index_of [ i ] ) NEW_LINE min_ind = min ( min_ind , index_of [ i ] ) NEW_LINE if ( max_ind - min_ind + 1 == i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def FormQuadruplets ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE pairs = 0 NEW_LINE n // 4 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - pairs ) : NEW_LINE INDENT ans += arr [ i + 2 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def LexicographicallyMaximum ( s , n ) : NEW_LINE INDENT m = dict . fromkeys ( s , 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] != m . end ( ) ) : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT v = [ ] NEW_LINE for i in range ( n , 25 ) : NEW_LINE INDENT if ( m [ s [ i ] ] != m [ s [ i ] ] > 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT m [ s [ i ] ] -= 1 NEW_LINE s = s [ 0 ] + v [ l ] + s . substr ( i + 1 ) NEW_LINE l += 1 NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def NoOfValidKbers ( k , arr ) : NEW_LINE INDENT s = set ( ) NEW_LINE while ( k != 0 ) : NEW_LINE INDENT s . add ( k % 10 ) NEW_LINE k = k // 10 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT no = arr [ i ] NEW_LINE flag = True NEW_LINE while ( no != 0 ) : NEW_LINE INDENT digit = no % 10 NEW_LINE if ( s [ digit ] == s [ end ( ) ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT no = no // 10 NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def DelCost ( s , cost ) : NEW_LINE INDENT ans = 0 NEW_LINE for_max in range ( len ( s ) ) : NEW_LINE INDENT if ( for_max [ s [ i ] ] == cost [ i ] ) : NEW_LINE INDENT for_max [ s [ i ] ] = cost [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT for_max [ s [ i ] ] = max ( cost [ i ] , for_max [ s [ i ] ] ) NEW_LINE DEDENT if ( for_tot . find ( s [ i ] ) == for_tot . end ( ) ) : NEW_LINE INDENT for_tot [ s [ i ] ] = cost [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT for_tot [ s [ i ] ] = for_tot [ s [ i ] ] + cost [ i ] NEW_LINE DEDENT DEDENT if ( auto & i ) : NEW_LINE INDENT ans += for_tot [ i . first ] - i . second NEW_LINE DEDENT return ans NEW_LINE DEDENT
def ReplaceDuplicates ( names ) : NEW_LINE INDENT hash = { } NEW_LINE for i in range ( len ( names ) ) : NEW_LINE INDENT if ( names [ i ] not in hash ) : NEW_LINE INDENT hash [ names [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = hash [ names [ i ] ] NEW_LINE hash [ names [ i ] ] += 1 NEW_LINE names [ i ] += to_string ( count ) NEW_LINE DEDENT DEDENT return names NEW_LINE DEDENT
def minmaxNumbers ( matrix , res ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( len ( matrix ) ) : NEW_LINE INDENT min_r = 10 ** 9 NEW_LINE for j in range ( len ( matrix [ i ] ) ) : NEW_LINE INDENT min_r = min ( min_r , matrix [ i ] [ j ] ) NEW_LINE DEDENT s . add ( min_r ) NEW_LINE DEDENT for j in range ( len ( matrix [ 0 ] ) : NEW_LINE INDENT max_c = 10 ** 9 NEW_LINE for i in range ( len ( matrix ) ) : NEW_LINE INDENT max_c = max ( max_c , matrix [ i ] [ j ] ) NEW_LINE DEDENT if ( s [ max_c ] != s [ end ( ) ) : NEW_LINE INDENT res . append ( max_c ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def LengthOfLongestAp ( a , n ) : NEW_LINE INDENT dp = { } NEW_LINE res = 2 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT d = a [ j ] - a [ i ] NEW_LINE if ( dp [ d ] [ j ] != dp [ d ] [ i ] + 1 ) : NEW_LINE INDENT dp [ d ] [ j ] = dp [ d ] [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ d ] [ j ] = 2 NEW_LINE DEDENT res = max ( res , dp [ d ] [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def FindKthChar ( n , k ) : NEW_LINE INDENT prev = "A" NEW_LINE cur = "" NEW_LINE for j in range ( 2 , n + 1 ) : NEW_LINE INDENT cur = prev + "B" NEW_LINE for i in range ( len ( prev ) ) : NEW_LINE INDENT if ( prev [ i ] == 'A' ) : NEW_LINE INDENT prev [ i ] = 'B' NEW_LINE DEDENT else : NEW_LINE INDENT prev [ i ] = 'A' NEW_LINE DEDENT DEDENT reverse ( prev , prev . end ( ) ) NEW_LINE cur += prev NEW_LINE prev = cur NEW_LINE DEDENT return cur [ k - 1 ] NEW_LINE DEDENT
def FindKthLargest ( s , k ) : NEW_LINE INDENT tmp = s NEW_LINE sort ( tmp ) NEW_LINE reverse ( tmp ) NEW_LINE return tmp [ k - 1 ] NEW_LINE DEDENT
def SubArraylen ( arr , n , k ) : NEW_LINE INDENT mp = { } NEW_LINE mp [ arr [ 0 ] ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < k ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT x = arr [ i ] - k NEW_LINE if ( x == 0 ) : NEW_LINE INDENT length = min ( length , i ) NEW_LINE DEDENT if ( mp [ x ] == mp [ x ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT length = min ( length , i - mp [ x ] ) NEW_LINE DEDENT DEDENT DEDENT return length NEW_LINE DEDENT
def FindMaxLen ( a , k ) : NEW_LINE INDENT n = len ( a ) NEW_LINE a . sort ( ) NEW_LINE vis = [ False ] * n NEW_LINE mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] = i NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( vis [ i ] ) : NEW_LINE INDENT check = a [ i ] * k NEW_LINE if ( mp [ check ] != mp . end ( ) ) : NEW_LINE INDENT c += 1 NEW_LINE vis [ mp [ check ] ] = True NEW_LINE DEDENT DEDENT DEDENT return n - c NEW_LINE DEDENT
def MinDistancePoints ( a , k , n ) : NEW_LINE INDENT m = { } NEW_LINE q = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ a [ i ] ] = 1 NEW_LINE q . append ( a [ i ] ) NEW_LINE DEDENT ans = [ 0 ] * n NEW_LINE while k > 0 : NEW_LINE INDENT x = q [ front ( ) ] NEW_LINE if ( m [ x - 1 ] == m [ end ( ) and k > 0 ) : NEW_LINE INDENT m [ x - 1 ] = 1 NEW_LINE q . append ( x - 1 ) NEW_LINE ans . append ( x - 1 ) NEW_LINE k -= 1 NEW_LINE DEDENT if ( ! m [ x + 1 ] and k > 0 ) : NEW_LINE INDENT m [ x + 1 ] = 1 NEW_LINE q . append ( x + 1 ) NEW_LINE ans . append ( x + 1 ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def IsValidLen ( s , length , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE mp = { } NEW_LINE right = 0 NEW_LINE while ( right < length ) : NEW_LINE INDENT if ( s [ right ] not in mp ) : NEW_LINE INDENT mp [ s [ right ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ s [ right ] ] = 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT if ( mp . size ( s [ right ] ) != mp . end ( ) ) : NEW_LINE INDENT mp [ s [ right ] ] -= 1 NEW_LINE DEDENT if ( mp [ s [ right - length ] ] == 0 ) : NEW_LINE INDENT mp . erase ( s [ right - length ] ) NEW_LINE DEDENT if ( mp [ s [ right - length ] ] == 0 ) : NEW_LINE INDENT mp . erase ( s [ right - length ] ) NEW_LINE DEDENT if ( mp [ s [ right - length ] ) == 0 ) : NEW_LINE INDENT mp . erase ( s [ right - length ] ) NEW_LINE DEDENT if ( mp [ s [ right - length ] ] == 0 ) : NEW_LINE INDENT mp . erase ( s [ right - length ] ) NEW_LINE DEDENT if ( mp [ s [ right - length ] ] == 0 ) : NEW_LINE INDENT mp . erase ( s [ right - length ] ) NEW_LINE DEDENT return True NEW_LINE DEDENT
def Partition ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ high ] NEW_LINE i = ( low - 1 ) NEW_LINE for j in range ( low , high ) : NEW_LINE INDENT if ( arr [ j ] <= pivot ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i + 1 ] NEW_LINE DEDENT DEDENT arr [ i + 1 ] , arr [ high ] = arr [ high ] , arr [ i + 1 ] NEW_LINE return i + 1 NEW_LINE DEDENT
def StrScore ( strs , s , n ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ strs [ i ] ] = i + 1 NEW_LINE DEDENT if ( m [ s ] == m [ s ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT score = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT score += s [ i ] - 'a' + 1 NEW_LINE DEDENT score = score * m [ s ] NEW_LINE return score NEW_LINE DEDENT
def CountEle ( s , a , n ) : NEW_LINE INDENT mp = { } NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE if ( mp [ num ] != mp [ end ] ) : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 0 NEW_LINE while ( s [ 0 ] != num ) : NEW_LINE INDENT mp [ s [ 0 ] ] = True NEW_LINE s . erase ( s [ 0 ] ) NEW_LINE cnt += 1 NEW_LINE DEDENT s . erase ( s [ 0 ] ) NEW_LINE cnt += 1 NEW_LINE ans . append ( cnt ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def MaxDistinctChar ( s , n , k ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ s [ i ] ] += 1 NEW_LINE DEDENT v = [ int ( it [ 0 ] ) for it in freq ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT mn = min ( v [ i ] - 1 , k ) NEW_LINE v [ i ] -= mn NEW_LINE k -= mn NEW_LINE DEDENT DEDENT if k > 0 : NEW_LINE INDENT for i in range ( len ( v ) ) : NEW_LINE INDENT mn = min ( v [ i ] , k ) NEW_LINE v [ i ] -= mn NEW_LINE k -= mn NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( v [ i ] == 1 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def FindKth ( arr , n , k ) : NEW_LINE INDENT missing = set ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT missing . add ( arr [ i ] ) NEW_LINE DEDENT max_m = max ( arr [ begin ( ) , arr [ end ( ) ) NEW_LINE min_m = * min_element ( arr [ begin ( ) , arr [ end ( ) ) NEW_LINE for i in range ( min_m + 1 ) : NEW_LINE INDENT if ( missing [ i ] == missing . end ( ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def AlmostSort ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i + 1 ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def MaximumSum ( s , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE freq = [ int ( i ) for i in range ( n ) ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT freq [ s [ i ] ] += 1 NEW_LINE DEDENT sort ( freq , end = "" ) NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT if k > freq [ i ] : NEW_LINE INDENT sum += freq [ i ] * freq [ i ] NEW_LINE k -= freq [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += freq [ i ] * k NEW_LINE break NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def FindMinOperations ( arr , n , k ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT freq = [ 0 ] * n NEW_LINE for j in range ( i , n , k ) : NEW_LINE INDENT freq [ arr [ j ] ] += 1 NEW_LINE DEDENT max1 = 0 NEW_LINE num = 0 NEW_LINE for auto in range ( freq ) : NEW_LINE INDENT if ( value > max1 ) : NEW_LINE INDENT max1 = value NEW_LINE num = key NEW_LINE DEDENT DEDENT for key in range ( auto & [ key , value ] : NEW_LINE INDENT if ( key != num ) : NEW_LINE INDENT operations += value NEW_LINE DEDENT DEDENT DEDENT return operations NEW_LINE DEDENT
def SubString ( s , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for length in range ( 1 , n - i + 1 ) : NEW_LINE INDENT find = s [ i , length ] NEW_LINE v . append ( find ) NEW_LINE DEDENT DEDENT return v NEW_LINE DEDENT
def CheckUniqueFrequency ( arr , n ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT unique_freq = set ( ) NEW_LINE for auto in range ( freq ) : NEW_LINE INDENT if ( unique_freq [ key ] != unique_freq [ end ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT unique_freq [ key ] = value NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def MinCost ( strr1 , strr2 , n ) : NEW_LINE INDENT cost = 0 NEW_LINE tmp = strr2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( tmp [ i ] != str2 [ i ] ) : NEW_LINE INDENT if ( i < n - 1 and tmp [ i + 1 ] != str2 [ i + 1 ] ) : NEW_LINE INDENT temp1 = tmp [ i ] NEW_LINE cost += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cost += 1 NEW_LINE DEDENT DEDENT DEDENT return cost NEW_LINE DEDENT
def IsValidNum ( x ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT if ( x [ i ] - ord ( '0' ) not in mp ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( x [ i ] - ord ( '0' ) > 5 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def MinimizeDiff ( arr , n , k ) : NEW_LINE INDENT max = * max_element ( arr . begin ( ) , arr . end ( ) ) NEW_LINE min = * min_element ( arr . begin ( ) , arr . end ( ) ) NEW_LINE if ( max - min <= k ) : NEW_LINE INDENT return max - min NEW_LINE DEDENT avg = ( max + min ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > avg ) : NEW_LINE INDENT arr [ i ] -= k NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += k NEW_LINE DEDENT DEDENT max = * max_element ( arr . begin ( ) , arr . end ( ) ) NEW_LINE min = * min_element ( arr . begin ( ) , arr . end ( ) ) NEW_LINE return max - min NEW_LINE DEDENT
def GetMinCost ( arr , n ) : NEW_LINE INDENT min_ele = * min_element ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE return min_ele * ( n - 1 ) NEW_LINE DEDENT
def Possibility ( m , length , s ) : NEW_LINE INDENT count_odd = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( m [ s [ i ] - ord ( '0' ) ] & 1 ) : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT if ( count_odd > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def MinimumCostOfBreaking ( x , y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE x . sort ( ) NEW_LINE y . sort ( ) NEW_LINE hzntl = 1 NEW_LINE vert = 1 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( x [ i ] > y [ j ] ) : NEW_LINE INDENT res += x [ i ] * hzntl NEW_LINE hzntl += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += y [ j ] * hzntl NEW_LINE vert += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE while ( i < m ) : NEW_LINE INDENT total += x [ i ] NEW_LINE DEDENT res += total * vert NEW_LINE total = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT total += y [ j += 1 NEW_LINE DEDENT res += total * hzntl NEW_LINE return res NEW_LINE DEDENT
def FindMaximumScore ( a , n ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] not in freq ) : NEW_LINE INDENT freq [ a [ i ] ] = freq [ a [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT dp = [ 0 , 0 ] NEW_LINE for i in range ( 2 , dp [ i - 1 ] , dp [ i - 2 ] + freq [ i ] * i ) NEW_LINE DEDENT return dp [ len ( dp ) - 1 ] NEW_LINE DEDENT
def CountWays ( s , t , k , mod ) : NEW_LINE INDENT n = len ( s ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT p = s [ i , n - i ] + s [ 0 ] NEW_LINE if ( p == t ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT dp1 = [ 0 ] * ( k + 1 ) NEW_LINE dp2 = [ 0 ] * ( k + 1 ) NEW_LINE if ( s == t ) : NEW_LINE INDENT dp1 [ 0 ] = 1 NEW_LINE dp2 [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod NEW_LINE DEDENT return dp1 [ k ] NEW_LINE DEDENT
def FindSubarraySum ( arr , n , k ) : NEW_LINE INDENT prev_sum = { } NEW_LINE res = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE if ( curr_sum == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( prev_sum [ curr_sum - k ] != prev_sum [ curr_sum ] ) : NEW_LINE INDENT res += prev_sum [ curr_sum - k ] NEW_LINE DEDENT prev_sum [ curr_sum ] += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def MaximumOccurrence ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = s [ i ] NEW_LINE freq [ temp ] += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT temp = s [ i ] NEW_LINE temp += s [ j ] NEW_LINE freq [ temp ] += 1 NEW_LINE DEDENT DEDENT answer = 10 ** 9 NEW_LINE for entry in sorted ( freq , reverse = True ) : NEW_LINE INDENT answer = max ( answer , entry . second ) NEW_LINE DEDENT return answer NEW_LINE DEDENT
def CountCharacters ( strings , chars ) : NEW_LINE INDENT res = 0 NEW_LINE freq = { } NEW_LINE for i in range ( len ( chars ) ) : NEW_LINE INDENT freq [ chars [ i ] ] += 1 NEW_LINE DEDENT for st in sorted ( strings , reverse = True ) : NEW_LINE INDENT flag = True NEW_LINE for c in range ( st ) : NEW_LINE INDENT if ( freq [ c ] == freq [ end ( ) ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT res += len ( st ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def DistinctSubstring ( p , q , k , n ) : NEW_LINE INDENT ss = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE s = for j in range ( i , n ) : NEW_LINE INDENT pos = ord ( p [ j ] ) - ord ( 'a' ) NEW_LINE sum += q [ pos ] - ord ( '0' ) NEW_LINE s += p [ j ] NEW_LINE if ( sum <= k ) : NEW_LINE INDENT ss . add ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( ss ) NEW_LINE DEDENT
def UniqueMorseRep ( arr ) : NEW_LINE INDENT morseCode = [ ".-" , "-..." , "-.-." , "-.." , "." , "..-." , "--." , ".." , ".---" , "-.-" , ".-." , "..." , "-" , "..-" , "-.-" , "--.." ] NEW_LINE st = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = morseCode [ arr [ i ] [ j ] - 'a' ] NEW_LINE DEDENT st . add ( temp ) NEW_LINE DEDENT return len ( st ) NEW_LINE DEDENT
def CountSubstrings ( st , k ) : NEW_LINE INDENT n = len ( st ) NEW_LINE answer = 0 NEW_LINE map = { } NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( st [ i ] not in map ) : NEW_LINE INDENT map [ st [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT map [ st [ i ] ] += 1 NEW_LINE DEDENT DEDENT if ( map . size ( ) == k ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def CanConstruct ( s , k ) : NEW_LINE INDENT m = { } NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE p = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] = m [ s [ i ] ] + 1 NEW_LINE DEDENT if k > len ( s ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT for h in m : NEW_LINE INDENT if ( h . second % 2 != 0 ) : NEW_LINE INDENT p = p + 1 NEW_LINE DEDENT DEDENT DEDENT if ( k < p ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def EqualIgnoreCase ( str1 , str2 ) : NEW_LINE INDENT transform ( str1 [ 0 ] , str1 [ 0 ] , str1 [ 0 ] , :: toupper ) NEW_LINE transform ( str2 [ 0 ] , str2 [ 0 ] , :: toupper ) NEW_LINE return str1 == str2 NEW_LINE DEDENT
def FindLongestSub ( bin ) : NEW_LINE INDENT n = len ( bin ) NEW_LINE sum = 0 NEW_LINE prev_sum = { } NEW_LINE max_len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( bin [ i ] == '1' ) : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum -= 1 NEW_LINE DEDENT if ( sum > 0 ) : NEW_LINE INDENT max_len = i + 1 NEW_LINE DEDENT elif ( sum <= 0 ) : NEW_LINE INDENT if ( prev_sum [ sum - 1 ] != prev_sum [ sum - 1 ] ) : NEW_LINE INDENT curr_len = i - prev_sum [ sum - 1 ] NEW_LINE max_len = max ( max_len , curr_len ) NEW_LINE DEDENT DEDENT if ( prev_sum [ sum ] == prev_sum . end ( ) ) : NEW_LINE INDENT prev_sum [ sum ] = i NEW_LINE DEDENT DEDENT return max_len NEW_LINE DEDENT
def HasAllCodes ( s , k ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in range ( len ( s ) - k ) : NEW_LINE INDENT us . add ( s [ i + k ] ) NEW_LINE DEDENT return len ( us ) == 1 << k NEW_LINE DEDENT
def CheckPalin ( word ) : NEW_LINE INDENT n = len ( word ) NEW_LINE transform = [ 0 ] * ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( word [ i ] != word [ n - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def Convert ( st ) : NEW_LINE INDENT w = "" NEW_LINE z = "" NEW_LINE transform ( st . begin ( ) , st . end ( ) , st . begin ( ) , :: toupper ) NEW_LINE st += " " NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT ch = ord ( st [ i ] ) NEW_LINE if ( ch != ' ' ) : NEW_LINE INDENT w += ch NEW_LINE DEDENT else : NEW_LINE INDENT z += char ( tolower ( w [ 0 ] ) ) + w . substr ( 1 ) + " " ) NEW_LINE w = "" NEW_LINE DEDENT DEDENT return z NEW_LINE DEDENT
def MaxLines ( n , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT s = set ( ) NEW_LINE slope = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( x1 [ i ] == x2 [ i ] ) : NEW_LINE INDENT slope = 2147483647 NEW_LINE DEDENT else : NEW_LINE INDENT slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) NEW_LINE DEDENT s . add ( slope ) NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT
def PrimeFactor ( n ) : NEW_LINE INDENT primef = [ 0 ] * n NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT if ( primef [ 2 ] != primef [ 2 ] ) : NEW_LINE INDENT primef [ 2 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT primef [ 2 ] = 1 NEW_LINE DEDENT n //= 2 NEW_LINE DEDENT for i in range ( 3 , n ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT if ( primef [ i ] != primef [ end ( ) ) : NEW_LINE INDENT primef [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT primef [ i ] = 1 NEW_LINE DEDENT n //= i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT primef [ n ] = 1 NEW_LINE DEDENT return primef NEW_LINE DEDENT
def IsDivisibleByDivisor ( s , d ) : NEW_LINE INDENT s %= d NEW_LINE hash_map = set ( ) NEW_LINE hash_map . add ( s ) NEW_LINE for i in range ( 0 , d + 1 ) : NEW_LINE INDENT s += s % d NEW_LINE s %= d NEW_LINE if ( hash_map [ s ] != hash_map [ end ] ) : NEW_LINE INDENT if ( s == 0 ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT return "No" NEW_LINE DEDENT DEDENT
def OddSum ( a , n , k ) : NEW_LINE INDENT odd = set ( ) NEW_LINE even = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT even . add ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT odd . add ( a [ i ] ) NEW_LINE DEDENT DEDENT if ( odd . size ( ) >= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT flag = False NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT needed = k - i NEW_LINE if ( needed <= even . size ( ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return flag NEW_LINE DEDENT
def DayOfYear ( date ) : NEW_LINE INDENT days = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 30 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE year = stoi ( date [ 0 ] ) NEW_LINE month = stoi ( date [ 5 ] ) NEW_LINE day = stoi ( date [ 8 ] ) NEW_LINE if ( month > 2 and year % 4 == 0 and ( year % 100 != 0 or year % 400 == 0 ) : NEW_LINE INDENT day += days [ month - 2 ] NEW_LINE -- month NEW_LINE DEDENT return day NEW_LINE DEDENT
def IsPerfectSquare ( arr , n ) : NEW_LINE INDENT umap = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT umap [ arr [ i ] ] += 1 NEW_LINE DEDENT for auto in range ( umap ) : NEW_LINE INDENT if ( itr . second % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def MinMoves ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE ans = 10 ** 9 NEW_LINE length = len ( s ) NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT for j in range ( i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT t = s NEW_LINE cur = 0 NEW_LINE for k in range ( j - ( j > i ) , k < length - 2 ) : NEW_LINE INDENT t [ k ] , t [ k + 1 ] = t [ k + 1 ] , t [ k + 1 ] NEW_LINE break NEW_LINE DEDENT DEDENT if ( ans == 10 ** 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def MinimumOperations ( a , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for entry in sorted ( mp , reverse = True ) : NEW_LINE INDENT if ( entry . second > 1 ) : NEW_LINE INDENT count += entry . second - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def KaprekarRec ( n , prev ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT prev = n NEW_LINE digits = [ 4 ] * 4 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT digits [ i ] = n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT asc = 0 NEW_LINE for i in range ( 3 , - 1 ) : NEW_LINE INDENT asc = asc * 10 + digits [ i ] NEW_LINE DEDENT digits = sorted ( digits , reverse = True ) NEW_LINE desc = 0 NEW_LINE for i in range ( 3 , - 1 ) : NEW_LINE INDENT desc = abs ( asc - desc ) NEW_LINE if ( diff == prev ) : NEW_LINE INDENT return diff NEW_LINE DEDENT return KaprekarRec ( diff , prev ) NEW_LINE DEDENT
def FractionToDecimal ( numr , denr ) : NEW_LINE INDENT res = "" NEW_LINE mp = { } NEW_LINE rem = numr % denr NEW_LINE while ( rem != 0 and mp [ rem ] == mp [ end ] ) : NEW_LINE INDENT mp [ rem ] = res . length ( ) NEW_LINE rem = rem * 10 NEW_LINE res_part = rem // denr NEW_LINE res += str ( res_part ) NEW_LINE rem = rem % denr NEW_LINE DEDENT if ( rem == 0 ) : NEW_LINE INDENT return "" NEW_LINE DEDENT if ( mp [ rem ] != mp [ end ] ) : NEW_LINE INDENT return res . substr ( mp [ rem ] ) NEW_LINE DEDENT return "" NEW_LINE DEDENT
def IsFancy ( num ) : NEW_LINE INDENT fp = { '0' : '0' , '1' : '1' } NEW_LINE fp [ '6' ] = '9' NEW_LINE fp [ '8' ] = '8' NEW_LINE fp [ '9' ] = '9' NEW_LINE n = len ( num ) NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( fp [ num [ l ] not in fp ) : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def DistinctOddRatio ( numbers ) : NEW_LINE INDENT distinct_numbers = set ( ) NEW_LINE distinct_numbers . add ( numbers [ 0 ] ) NEW_LINE distinct_count = ranges :: distance ( distinct_numbers ) NEW_LINE distinct_odd_count = ranges :: distance ( distinct_numbers | views :: filter ( [ ] ( int ) { return n % 2 == 1 NEW_LINE DEDENT ) ) NEW_LINE return ( double ) distinct_odd_count / distinct_count NEW_LINE DEDENT
def CompareSum ( numbers , words ) : NEW_LINE INDENT int_sum = reduce ( numbers . begin ( ) , numbers . end ( ) ) NEW_LINE tmp = words | views :: transform ( [ ] ( string & w ) , { size : len ( w ) } ) NEW_LINE word_length_sum = reduce ( tmp . begin ( ) , tmp . end ( ) ) NEW_LINE if ( int_sum < word_length_sum ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( int_sum > word_length_sum ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def AllLongerThan ( short_words , long_words ) : NEW_LINE INDENT max_of_short = range ( short_words ) NEW_LINE min_of_long = ranges :: min ( long_words | views :: transform ( [ ] ( string & w ) , { return len ( w ) NEW_LINE DEDENT ) ) NEW_LINE return min_of_long > max_of_short NEW_LINE DEDENT
def CompareOddEvenRange ( numbers ) : NEW_LINE INDENT range_odd = ranges :: max ( numbers | views :: filter ( [ ] ( int n ) { return n % 2 == 1 NEW_LINE DEDENT ) ) NEW_LINE range_even = ranges :: max ( numbers | views :: filter ( [ ] ( int n ) { return n % 2 == 0 NEW_LINE DEDENT ) ) NEW_LINE if ( range_odd < range_even ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( range_odd > range_even ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def AverageDistinctLength ( words ) : NEW_LINE INDENT s = set ( words ) NEW_LINE s . add ( words [ 0 ] ) NEW_LINE s . add ( s [ 0 ] ) NEW_LINE distinct_words = set ( s [ 0 ] ) NEW_LINE s . add ( s [ 1 ] ) NEW_LINE auto distinct_size = distinct_words | views :: transform ( [ ] ( string & w ) , [ ] ( string & w ) { NEW_LINE INDENT return w [ 1 ] NEW_LINE DEDENT ) NEW_LINE average_len = ! distinct_size . empty ( ) ? ( double ) reduce ( distinct_size [ 0 ] , distinct_size [ 1 ] ) / ranges :: distance ( distinct_size ) : 0 NEW_LINE INDENT return average_len NEW_LINE DEDENT
def WithDrawBalance ( start , withdrawals ) : NEW_LINE INDENT end = accumulate ( withdrawals . begin ( ) , withdrawals . end ( ) , start , [ ] ( balance , next_withdrawal ) : NEW_LINE INDENT return next_withdrawal <= balance ? balance - next_withdrawal : balance NEW_LINE DEDENT DEDENT return end NEW_LINE DEDENT
def FirstShortAndStartsWithO ( words ) : NEW_LINE INDENT matched_view = words | views :: filter ( [ ] ( const string & w ) , { 0 : 'o' } ) | views :: take ( 1 ) NEW_LINE matched_element = matched_view [ 0 ] == 'o' ] NEW_LINE return matched_element NEW_LINE DEDENT
def BigNumberAtIndex ( numbers , index ) : NEW_LINE INDENT matched_view = numbers | views :: filter ( [ ] ( n ) : NEW_LINE INDENT return n > 5 NEW_LINE DEDENT
def ContainsSquareInRange ( range_start , range_length ) : NEW_LINE INDENT contains_square = ranges :: any_of ( views :: iota ( range_start , range_start + range_length ) , [ ] ( n ) : NEW_LINE INDENT return pow ( ( int ) sqrt ( n ) , 2 ) == n NEW_LINE DEDENT
def GroupNumbersByMod ( numbers , mod ) : NEW_LINE INDENT number_groups = [ ] NEW_LINE for n in range ( numbers ) : NEW_LINE INDENT key = n % mod NEW_LINE number_groups [ key ] . append ( n ) NEW_LINE DEDENT return number_groups NEW_LINE DEDENT
def GroupWordsByFirstChar ( words ) : NEW_LINE INDENT word_groups = { } NEW_LINE for word in words : NEW_LINE INDENT word_groups [ word [ 0 ] ] . append ( word ) NEW_LINE DEDENT return word_groups NEW_LINE DEDENT
def OrderByLengthAndDescending ( words ) : NEW_LINE INDENT sorted_words = [ ] NEW_LINE sorted_words . append ( " " ) NEW_LINE sorted_words . sort ( ) NEW_LINE sorted_words . sort ( ) NEW_LINE sorted_words . sort ( ) NEW_LINE for a in range ( sorted_words . begin ( ) , sorted_words . end ( ) , [ ] ( a , b ) : NEW_LINE INDENT if ( a . length ( ) == b . length ( ) ) : NEW_LINE INDENT return a > b NEW_LINE DEDENT return sorted_words NEW_LINE DEDENT
def OrderFirstCharDescendingReverse ( words ) : NEW_LINE INDENT sorted_words = [ ] NEW_LINE sorted_words . append ( " " ) NEW_LINE sorted_words . sort ( ) NEW_LINE for a in range ( sorted_words . begin ( ) , sorted_words . end ( ) , [ ] ( a , b ) : NEW_LINE INDENT if ( a [ 0 ] == b [ 0 ] ) : NEW_LINE INDENT return a < b NEW_LINE DEDENT return a [ 0 ] > b [ 0 ] NEW_LINE DEDENT
def GetSubListOfNegative ( numbers , start , length ) : NEW_LINE INDENT matched_view = numbers | views :: drop ( start ) | views :: filter ( [ ] ( n ) { NEW_LINE INDENT return n < 0 NEW_LINE DEDENT ) | views :: take ( length ) NEW_LINE sub_list = ranges :: copy ( matched_view , back_inserter ( sub_list ) ) NEW_LINE return sub_list NEW_LINE DEDENT
def GetPositiveSequence ( numbers ) : NEW_LINE INDENT matched_view = numbers | views :: drop_while ( [ ] ( n ) : NEW_LINE INDENT return n <= 0 NEW_LINE DEDENT ) | views :: take_while ( [ ] ( n ) : NEW_LINE INDENT return n >= 0 NEW_LINE DEDENT ) NEW_LINE sub_sequence = ranges :: copy ( matched_view , back_inserter ( sub_sequence ) ) NEW_LINE return sub_sequence NEW_LINE DEDENT
def GetLargerThanIndexSequence ( numbers ) : NEW_LINE INDENT matched_view = views :: iota ( 0 , ( int ) numbers . size ( ) ) | views :: drop_while ( [ & numbers ] ( int n ) : NEW_LINE INDENT return numbers [ n ] < n NEW_LINE DEDENT ) | views :: take_while ( [ & numbers ] ( int n ) : NEW_LINE INDENT return numbers [ n ] > n NEW_LINE DEDENT ) | views :: transform ( [ & numbers ] ( int n ) : NEW_LINE INDENT return numbers [ n ] NEW_LINE DEDENT
def RearrangeWordByIndexes ( words , indexes ) : NEW_LINE INDENT new_indexes = indexes | views :: filter ( [ & words ] ( int n ) : NEW_LINE INDENT return n >= len ( words ) NEW_LINE DEDENT ) | views :: transform ( [ & words ] ( int n ) : NEW_LINE INDENT return n % len ( words ) NEW_LINE DEDENT ) NEW_LINE DEDENT matched_view = new_indexes | views :: transform ( [ & words ] ( int n ) : NEW_LINE INDENT return words [ n ] NEW_LINE DEDENT
def GetWordsUpperLower ( words ) : NEW_LINE INDENT auto matched_view = words | views :: transform ( [ ] ( w ) : NEW_LINE INDENT upper = w NEW_LINE lower = w NEW_LINE ranges :: transform ( upper [ 0 ] , upper [ 0 ] , lower [ 0 ] , :: tolower ) NEW_LINE return vector < string > { upper , lower } NEW_LINE DEDENT
def SelectIfInPlace ( numbers ) : NEW_LINE INDENT matched_view = views :: iota ( 0 , ( int ) numbers . size ( ) ) | views :: transform ( [ & numbers ] ( int ) => numbers [ n ] == n NEW_LINE DEDENT ) NEW_LINE nums_in_place = ranges :: copy ( matched_view , back_inserter ( nums_in_place ) ) NEW_LINE return nums_in_place NEW_LINE DEDENT
def SelectPairs ( numbers_a , numbers_b ) : NEW_LINE INDENT auto matched_view = numbers_a | views :: transform ( [ & numbers_b ] ( a ) : NEW_LINE INDENT return numbers_b | views :: filter ( [ a ] ( auto b ) : NEW_LINE INDENT return a < b NEW_LINE DEDENT ) | views :: transform ( [ a ] ( auto b ) : NEW_LINE INDENT return vector < int > { a , b } NEW_LINE DEDENT ) NEW_LINE DEDENT pairs = ranges :: copy ( matched_view , back_inserter ( pairs ) ) NEW_LINE return pairs NEW_LINE DEDENT
def StringCrossJoin ( end_words , begin_words ) : NEW_LINE INDENT auto matched_view = begin_words | views :: transform ( [ & end_words ] ( string & b ) : NEW_LINE INDENT return end_words | views :: filter ( [ b ] ( string & e ) : NEW_LINE INDENT return b [ 0 ] == e [ len ( e ) - 1 ] NEW_LINE DEDENT ) | views :: transform ( [ b ] ( auto e ) : NEW_LINE INDENT return e + " " + b NEW_LINE DEDENT ) NEW_LINE DEDENT cross_strings = ranges :: copy ( matched_view , back_inserter ( cross_strings ) ) NEW_LINE return cross_strings NEW_LINE DEDENT
def ElementsContainSubword ( words , subword ) : NEW_LINE INDENT if ( ranges :: all_of ( words | views :: take ( 5 ) , [ & subword ] ( string & w ) , [ & subword ] ( string & w ) , [ & subword ] ( string & w ) , [ & subword ] ( string & w ) , [ & subword ] ( string & w ) , [ & subword ] ( string & w ) : NEW_LINE INDENT return w . find ( subword ) != string :: npos NEW_LINE DEDENT ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT
def ConcatLargeNumbers ( numbers_a , numbers_b , flag ) : NEW_LINE INDENT auto large_numbers_a = numbers_a | views :: filter ( [ flag ] ( int n ) : NEW_LINE INDENT return n > flag NEW_LINE DEDENT and auto large_numbers_b = numbers_b | views :: filter ( [ flag ] ( int n ) : NEW_LINE INDENT return n > flag NEW_LINE DEDENT
def DotProduct ( vector_a , vector_b ) : NEW_LINE INDENT dot_product = inner_product ( vector_a [ 0 ] , vector_a [ 1 ] , vector_b [ 0 ] , 0 ) NEW_LINE return dot_product NEW_LINE DEDENT
def SetDifference ( set_a , set_b ) : NEW_LINE INDENT difference = [ 0 ] * 3 NEW_LINE ranges :: sort ( set_a ) NEW_LINE ranges :: sort ( set_b ) NEW_LINE set_symmetric_difference ( set_a . begin ( ) , set_a . end ( ) , set_b . begin ( ) , set_b . end ( ) , back_inserter ( difference ) ) NEW_LINE return difference NEW_LINE DEDENT
