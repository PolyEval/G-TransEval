def distinct_odd_ratio ( numbers ) : NEW_LINE INDENT distinct_count = len ( set ( numbers ) ) NEW_LINE distinct_odd_count = len ( [ n for n in set ( numbers ) if n % 2 == 1 ] ) NEW_LINE return distinct_odd_count / distinct_count NEW_LINE DEDENT 
def compare_sum ( numbers , words ) : NEW_LINE INDENT int_sum = sum ( numbers ) NEW_LINE word_length_sum = sum ( len ( word ) for word in words ) NEW_LINE if int_sum < word_length_sum : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if int_sum > word_length_sum : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT 
def allLongerThan ( shortWords , longWords ) : NEW_LINE INDENT maxOfShort = max ( len ( word ) for word in shortWords ) NEW_LINE minOfLong = min ( len ( word ) for word in longWords ) NEW_LINE return minOfLong > maxOfShort NEW_LINE DEDENT 
def compareOddEvenRange ( numbers ) : NEW_LINE INDENT odd_numbers = list ( filter ( lambda n : n % 2 == 1 , numbers ) ) NEW_LINE even_numbers = list ( filter ( lambda n : n % 2 == 0 , numbers ) ) NEW_LINE range_odd = max ( odd_numbers ) - min ( odd_numbers ) if odd_numbers else 0 NEW_LINE range_even = max ( even_numbers ) - min ( even_numbers ) if even_numbers else 0 NEW_LINE if range_odd < range_even : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif range_odd > range_even : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT 
def averageDistinctLength ( words ) : NEW_LINE INDENT distinct_words = set ( words ) NEW_LINE average_len = sum ( len ( word ) for word in distinct_words ) / len ( distinct_words ) NEW_LINE return average_len NEW_LINE DEDENT 
def withDrawBalance ( start , withdrawals ) : NEW_LINE INDENT end = start NEW_LINE for nextWithdrawal in withdrawals : NEW_LINE INDENT if nextWithdrawal <= end : NEW_LINE INDENT end -= nextWithdrawal NEW_LINE DEDENT DEDENT return end NEW_LINE DEDENT 
def firstShortAndStartsWithO ( words ) : NEW_LINE INDENT matchedElement = next ( ( w for w in words if len ( w ) < 5 and w [ 0 ] == 'o' ) , "" ) NEW_LINE return matchedElement NEW_LINE DEDENT 
def bigNumberAtIndex ( numbers , index ) : NEW_LINE INDENT targetNum = next ( num for num in numbers if num > 5 , None ) NEW_LINE targetNum = next ( itertools . islice ( filter ( lambda x : x > 5 , numbers ) , index , None ) , None ) NEW_LINE return targetNum NEW_LINE DEDENT 
def containsSquareInRange ( rangeStart , rangeLength ) : NEW_LINE INDENT containsSquare = any ( ( int ( math . sqrt ( n ) ) ** 2 == n ) for n in range ( rangeStart , rangeStart + rangeLength ) ) NEW_LINE return containsSquare NEW_LINE DEDENT 
def groupNumbersByMod ( numbers , mod ) : NEW_LINE INDENT numberGroups = { } NEW_LINE for n in numbers : NEW_LINE INDENT remainder = n % mod NEW_LINE if remainder in numberGroups : NEW_LINE INDENT numberGroups [ remainder ] . append ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT numberGroups [ remainder ] = [ n ] NEW_LINE DEDENT DEDENT return numberGroups NEW_LINE DEDENT 
def groupWordsByFirstChar ( words ) : NEW_LINE INDENT wordGroups = { } NEW_LINE for word in words : NEW_LINE INDENT char = word [ 0 ] NEW_LINE if char not in wordGroups : NEW_LINE INDENT wordGroups [ char ] = [ ] NEW_LINE DEDENT wordGroups [ char ] . append ( word ) NEW_LINE DEDENT return wordGroups NEW_LINE DEDENT 
def orderByLengthAndDescending ( words ) : NEW_LINE INDENT sortedWords = sorted ( words , key = lambda x : ( len ( x ) , x ) , reverse = True ) NEW_LINE return sortedWords NEW_LINE DEDENT 
def orderFirstCharDescendingReverse ( words ) : NEW_LINE INDENT sortedWords = sorted ( words , key = cmp_to_key ( lambda w1 , w2 : ord ( w2 [ 0 ] ) - ord ( w1 [ 0 ] ) ) + cmp_to_key ( lambda w1 , w2 : - 1 if w1 == w2 else 1 ) ) NEW_LINE sortedWords . reverse ( ) NEW_LINE return sortedWords NEW_LINE DEDENT 
def getSubListOfNegative ( numbers , start , length ) : NEW_LINE INDENT subList = [ x for x in numbers [ start : ] if x < 0 ] [ : length ] NEW_LINE return subList NEW_LINE DEDENT 
def getPositiveSequence ( numbers ) : NEW_LINE INDENT subSequence = [ ] NEW_LINE for n in numbers : NEW_LINE INDENT if n <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT subSequence . append ( n ) NEW_LINE DEDENT return subSequence NEW_LINE DEDENT 
def getLargerThanIndexSequence ( numbers ) : NEW_LINE INDENT subSequence = [ numbers [ i ] for i in range ( len ( numbers ) ) if numbers [ i ] >= i ] NEW_LINE return subSequence NEW_LINE DEDENT 
def rearrangeWordByIndexes ( words , indexes ) : NEW_LINE INDENT newIndexes = [ n % len ( words ) for n in indexes if n >= len ( words ) ] NEW_LINE newWords = [ words [ n ] for n in newIndexes ] NEW_LINE return newWords NEW_LINE DEDENT 
def getWordsUpperLower ( words ) : NEW_LINE INDENT upperLowerWords = [ [ w . upper ( ) , w . lower ( ) ] for w in words ] NEW_LINE return upperLowerWords NEW_LINE DEDENT 
def selectIfInPlace ( numbers ) : NEW_LINE INDENT numsInPlace = [ numbers [ index ] == index for index in range ( len ( numbers ) ) ] NEW_LINE return numsInPlace NEW_LINE DEDENT 
def selectPairs ( numbersA , numbersB ) : NEW_LINE INDENT pairs = [ ] NEW_LINE for a in numbersA : NEW_LINE INDENT for b in numbersB : NEW_LINE INDENT if a < b : NEW_LINE INDENT pairs . append ( [ a , b ] ) NEW_LINE DEDENT DEDENT DEDENT return pairs NEW_LINE DEDENT 
def string_cross_join ( end_words , begin_words ) : NEW_LINE INDENT cross_strings = [ ] NEW_LINE for b in begin_words : NEW_LINE INDENT for e in end_words : NEW_LINE INDENT if b [ 0 ] == e [ - 1 ] : NEW_LINE INDENT cross_strings . append ( e + " " + b ) NEW_LINE DEDENT DEDENT DEDENT return cross_strings NEW_LINE DEDENT 
def elementsContainSubword ( words , subword ) : NEW_LINE INDENT if all ( w . contains ( subword ) for w in words [ : 5 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif any ( w . contains ( subword ) for w in words [ : 5 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT 
def concat_large_numbers ( numbersA , numbersB , flag ) : NEW_LINE INDENT allNumbers = [ ] NEW_LINE for num in numbersA : NEW_LINE INDENT if num > flag : NEW_LINE INDENT allNumbers . append ( num ) NEW_LINE DEDENT DEDENT for num in numbersB : NEW_LINE INDENT if num > flag : NEW_LINE INDENT allNumbers . append ( num ) NEW_LINE DEDENT DEDENT return allNumbers NEW_LINE DEDENT 
def dot_product ( vectorA , vectorB ) : NEW_LINE INDENT dotProduct = sum ( [ vectorA [ i ] * vectorB [ i ] for i in range ( len ( vectorA ) ) ] ) NEW_LINE return dotProduct NEW_LINE DEDENT 
def SetDifference ( setA , setB ) : NEW_LINE INDENT difference = setA + setB NEW_LINE intersection = list ( set ( setA ) & set ( setB ) ) NEW_LINE for num in intersection : NEW_LINE INDENT difference . remove ( num ) NEW_LINE DEDENT difference . sort ( ) NEW_LINE return difference NEW_LINE DEDENT 
