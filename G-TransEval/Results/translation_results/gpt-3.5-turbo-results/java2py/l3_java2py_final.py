def separateParenGroups ( parenString ) : NEW_LINE INDENT allParens = [ ] NEW_LINE currentParen = [ ] NEW_LINE currentDepth = 0 NEW_LINE for c in parenString : NEW_LINE INDENT if c == '(' : NEW_LINE INDENT currentDepth += 1 NEW_LINE currentParen . append ( c ) NEW_LINE DEDENT elif c == ')' : NEW_LINE INDENT currentDepth -= 1 NEW_LINE currentParen . append ( c ) NEW_LINE if currentDepth == 0 : NEW_LINE INDENT allParens . append ( '' . join ( currentParen ) ) NEW_LINE currentParen = [ ] NEW_LINE DEDENT DEDENT DEDENT return allParens NEW_LINE DEDENT 
def parseNestedParens ( parenString ) : NEW_LINE INDENT allLevels = [ ] NEW_LINE level = 0 NEW_LINE maxLevel = 0 NEW_LINE for i in range ( len ( parenString ) ) : NEW_LINE INDENT chr = parenString [ i ] NEW_LINE if chr == '(' : NEW_LINE INDENT level += 1 NEW_LINE if level > maxLevel : NEW_LINE INDENT maxLevel = level NEW_LINE DEDENT DEDENT if chr == ')' : NEW_LINE INDENT level -= 1 NEW_LINE if level == 0 : NEW_LINE INDENT allLevels . append ( maxLevel ) NEW_LINE maxLevel = 0 NEW_LINE DEDENT DEDENT DEDENT return allLevels NEW_LINE DEDENT 
def filterBySubstring ( strings , substring ) : NEW_LINE INDENT result = [ ] NEW_LINE for s in strings : NEW_LINE INDENT if substring in s : NEW_LINE INDENT result . append ( s ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def rollingMax ( numbers ) : NEW_LINE INDENT result = [ ] NEW_LINE runningMax = 0 NEW_LINE for n in numbers : NEW_LINE INDENT if n > runningMax : NEW_LINE INDENT runningMax = n NEW_LINE DEDENT result . append ( runningMax ) NEW_LINE DEDENT return result NEW_LINE DEDENT 
def makePalindrome ( s ) : NEW_LINE INDENT if len ( s ) == 0 : NEW_LINE INDENT return "" NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT rStr = s [ i : ] NEW_LINE if rStr == rStr [ : : - 1 ] : NEW_LINE INDENT nStr = s [ : i ] NEW_LINE n2Str = nStr [ : : - 1 ] NEW_LINE return s + n2Str NEW_LINE DEDENT DEDENT return s [ : - 1 ] + s [ : : - 1 ] NEW_LINE DEDENT 
def string_xor ( a , b ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] == b [ i ] : NEW_LINE INDENT result . append ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( '1' ) NEW_LINE DEDENT DEDENT return '' . join ( result ) NEW_LINE DEDENT 
def longest ( strings ) : NEW_LINE INDENT if not strings : NEW_LINE INDENT return "" NEW_LINE DEDENT max_len = max ( len ( s ) for s in strings ) NEW_LINE for s in strings : NEW_LINE INDENT if len ( s ) == max_len : NEW_LINE INDENT return s NEW_LINE DEDENT DEDENT return "" NEW_LINE DEDENT 
def string_sequence ( n ) : NEW_LINE INDENT s = "" NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += str ( i ) + " " NEW_LINE DEDENT s += str ( n ) NEW_LINE return s NEW_LINE DEDENT 
def countDistinctCharacters ( s ) : NEW_LINE INDENT distinct = set ( ) NEW_LINE for c in s . lower ( ) : NEW_LINE INDENT distinct . add ( c ) NEW_LINE DEDENT return len ( distinct ) NEW_LINE DEDENT 
def howManyTimes ( s , sub ) : NEW_LINE INDENT times = 0 NEW_LINE for i in range ( len ( s ) - len ( sub ) + 1 ) : NEW_LINE INDENT if s . startswith ( sub , i ) : NEW_LINE INDENT times += 1 NEW_LINE DEDENT DEDENT return times NEW_LINE DEDENT 
def sort_numbers ( numbers ) : NEW_LINE INDENT to_num = { "zero" : 0 , "one" : 1 , "two" : 2 , "three" : 3 , "four" : 4 , "five" : 5 , "six" : 6 , "seven" : 7 , "eight" : 8 , "nine" : 9 } NEW_LINE from_num = { 0 : "zero" , 1 : "one" , 2 : "two" , 3 : "three" , 4 : "four" , 5 : "five" , 6 : "six" , 7 : "seven" , 8 : "eight" , 9 : "nine" } NEW_LINE ints = [ ] NEW_LINE current = "" NEW_LINE for i in range ( len ( numbers ) ) : NEW_LINE INDENT if i == len ( numbers ) or numbers [ i ] == ' ' : NEW_LINE INDENT if current in to_num : NEW_LINE INDENT ints . append ( to_num [ current ] ) NEW_LINE current = "" NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT current += numbers [ i ] NEW_LINE DEDENT DEDENT ints . sort ( ) NEW_LINE result = "" NEW_LINE for i in range ( len ( ints ) ) : NEW_LINE INDENT result += from_num [ ints [ i ] ] NEW_LINE if i != len ( ints ) - 1 : NEW_LINE INDENT result += " " NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def find_closest_elements ( numbers ) : NEW_LINE INDENT closest_pair = [ numbers [ 0 ] , numbers [ 1 ] ] NEW_LINE distance = abs ( numbers [ 0 ] - numbers [ 1 ] ) NEW_LINE for i in range ( len ( numbers ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( numbers ) ) : NEW_LINE INDENT if abs ( numbers [ i ] - numbers [ j ] ) < distance : NEW_LINE INDENT closest_pair [ 0 ] = numbers [ i ] NEW_LINE closest_pair [ 1 ] = numbers [ j ] NEW_LINE distance = abs ( numbers [ i ] - numbers [ j ] ) NEW_LINE DEDENT DEDENT DEDENT closest_pair . sort ( ) NEW_LINE return closest_pair NEW_LINE DEDENT 
def rescaleToUnit ( numbers ) : NEW_LINE INDENT minNum = min ( numbers ) NEW_LINE maxNum = max ( numbers ) NEW_LINE result = [ ] NEW_LINE for n in numbers : NEW_LINE INDENT result . append ( ( n - minNum ) / ( maxNum - minNum ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT 
def filter_integers ( values ) : NEW_LINE INDENT result = [ ] NEW_LINE for e in values : NEW_LINE INDENT if isinstance ( e , int ) : NEW_LINE INDENT result . append ( e ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def remove_duplicates ( numbers ) : NEW_LINE INDENT c = { } NEW_LINE for i in numbers : NEW_LINE INDENT c [ i ] = c . get ( i , 0 ) + 1 NEW_LINE DEDENT result = [ ] NEW_LINE for i in numbers : NEW_LINE INDENT if c [ i ] == 1 : NEW_LINE INDENT result . append ( i ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def flipCase ( s ) : NEW_LINE INDENT result = "" NEW_LINE for c in s : NEW_LINE INDENT if c . islower ( ) : NEW_LINE INDENT result += c . upper ( ) NEW_LINE DEDENT else : NEW_LINE INDENT result += c . lower ( ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def filterByPrefix ( strings , prefix ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( strings ) ) : NEW_LINE INDENT if strings [ i ] . startswith ( prefix ) : NEW_LINE INDENT result . append ( strings [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def findZero ( xs ) : NEW_LINE INDENT ans = 0 NEW_LINE value = 0 NEW_LINE for i in range ( len ( xs ) ) : NEW_LINE INDENT value += xs [ i ] * ans ** i NEW_LINE DEDENT while abs ( value ) > 1e-6 : NEW_LINE INDENT driv = 0 NEW_LINE for i in range ( 1 , len ( xs ) ) : NEW_LINE INDENT driv += xs [ i ] * ans ** ( i - 1 ) * i NEW_LINE DEDENT ans -= value / driv NEW_LINE value = 0 NEW_LINE for i in range ( len ( xs ) ) : NEW_LINE INDENT value += xs [ i ] * ans ** i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def sortThird ( l ) : NEW_LINE INDENT thirds = [ ] NEW_LINE for i in range ( 0 , len ( l ) , 3 ) : NEW_LINE INDENT thirds . append ( l [ i ] ) NEW_LINE DEDENT thirds . sort ( ) NEW_LINE result = [ ] NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT if i % 3 == 0 : NEW_LINE INDENT result . append ( thirds [ i // 3 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( l [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def unique ( l ) : NEW_LINE INDENT result = sorted ( list ( set ( l ) ) ) NEW_LINE return result NEW_LINE DEDENT 
def maxElement ( l : List [ float ] ) -> float : NEW_LINE INDENT return max ( l ) NEW_LINE DEDENT 
def triplesSumToZero ( l ) : NEW_LINE INDENT for i in range ( len ( l ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( l ) ) : NEW_LINE INDENT for k in range ( j + 1 , len ( l ) ) : NEW_LINE INDENT if l [ i ] + l [ j ] + l [ k ] == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT 
def fib4 ( n ) : NEW_LINE INDENT results = [ 0 , 0 , 2 , 0 ] NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT results . append ( results [ i - 4 ] + results [ i - 3 ] + results [ i - 2 ] + results [ i - 1 ] ) NEW_LINE DEDENT return results [ n ] NEW_LINE DEDENT 
def isPalindrome ( text ) : NEW_LINE INDENT pr = text [ : : - 1 ] NEW_LINE return pr == text NEW_LINE DEDENT 
def remove_vowels ( text ) : NEW_LINE INDENT result = "" NEW_LINE vowels = "aeiou" NEW_LINE for ch in text : NEW_LINE INDENT if ch . lower ( ) not in vowels : NEW_LINE INDENT result += ch NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def same_chars ( s0 , s1 ) : NEW_LINE INDENT set0 = set ( s0 ) NEW_LINE set1 = set ( s1 ) NEW_LINE return set0 == set1 NEW_LINE DEDENT 
def common ( l1 , l2 ) : NEW_LINE INDENT us = set ( ) NEW_LINE for e1 in l1 : NEW_LINE INDENT for e2 in l2 : NEW_LINE INDENT if e1 == e2 : NEW_LINE INDENT us . add ( e1 ) NEW_LINE DEDENT DEDENT DEDENT ret = list ( us ) NEW_LINE ret . sort ( ) NEW_LINE return ret NEW_LINE DEDENT 
def correctBracketing ( brackets ) : NEW_LINE INDENT depth = 0 NEW_LINE for b in brackets : NEW_LINE INDENT if b == '(' : NEW_LINE INDENT depth += 1 NEW_LINE DEDENT if b == ')' : NEW_LINE INDENT depth -= 1 NEW_LINE DEDENT if depth < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return depth == 0 NEW_LINE DEDENT 
def circularShift ( x , shift ) : NEW_LINE INDENT xs = str ( x ) NEW_LINE if shift > len ( xs ) : NEW_LINE INDENT return xs [ : : - 1 ] NEW_LINE DEDENT return xs [ len ( xs ) - shift : ] + xs [ : len ( xs ) - shift ] NEW_LINE DEDENT 
def search ( lst ) : NEW_LINE INDENT counter = { } NEW_LINE for i in lst : NEW_LINE INDENT counter [ i ] = counter . get ( i , 0 ) + 1 NEW_LINE DEDENT ans = - 1 NEW_LINE for item in counter . items ( ) : NEW_LINE INDENT if item [ 1 ] >= item [ 0 ] and item [ 0 ] > ans : NEW_LINE INDENT ans = item [ 0 ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def smallestChange ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( arr ) // 2 ) : NEW_LINE INDENT if arr [ i ] != arr [ len ( arr ) - i - 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def totalMatch ( lst1 , lst2 ) : NEW_LINE INDENT sum1 = 0 NEW_LINE for st in lst1 : NEW_LINE INDENT sum1 += len ( st ) NEW_LINE DEDENT sum2 = 0 NEW_LINE for st in lst2 : NEW_LINE INDENT sum2 += len ( st ) NEW_LINE DEDENT return lst2 if sum1 > sum2 else lst1 NEW_LINE DEDENT 
def isHappy ( s ) : NEW_LINE INDENT if len ( s ) < 3 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( len ( s ) - 2 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] or s [ i ] == s [ i + 2 ] or s [ i + 1 ] == s [ i + 2 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def numericalLetterGrade ( grades ) : NEW_LINE INDENT letterGrade = [ ] NEW_LINE for gpa in grades : NEW_LINE INDENT if gpa == 4.0 : NEW_LINE INDENT letterGrade . append ( "A+" ) NEW_LINE DEDENT elif gpa > 3.7 : NEW_LINE INDENT letterGrade . append ( "A" ) NEW_LINE DEDENT elif gpa > 3.3 : NEW_LINE INDENT letterGrade . append ( "A-" ) NEW_LINE DEDENT elif gpa > 3.0 : NEW_LINE INDENT letterGrade . append ( "B+" ) NEW_LINE DEDENT elif gpa > 2.7 : NEW_LINE INDENT letterGrade . append ( "B" ) NEW_LINE DEDENT elif gpa > 2.3 : NEW_LINE INDENT letterGrade . append ( "B-" ) NEW_LINE DEDENT elif gpa > 2.0 : NEW_LINE INDENT letterGrade . append ( "C+" ) NEW_LINE DEDENT elif gpa > 1.7 : NEW_LINE INDENT letterGrade . append ( "C" ) NEW_LINE DEDENT elif gpa > 1.3 : NEW_LINE INDENT letterGrade . append ( "C-" ) NEW_LINE DEDENT elif gpa > 1.0 : NEW_LINE INDENT letterGrade . append ( "D+" ) NEW_LINE DEDENT elif gpa > 0.7 : NEW_LINE INDENT letterGrade . append ( "D" ) NEW_LINE DEDENT elif gpa > 0.0 : NEW_LINE INDENT letterGrade . append ( "D-" ) NEW_LINE DEDENT else : NEW_LINE INDENT letterGrade . append ( "E" ) NEW_LINE DEDENT DEDENT return letterGrade NEW_LINE DEDENT 
def solve ( n ) : NEW_LINE INDENT biStr = '' NEW_LINE sum = 0 NEW_LINE for c in str ( n ) : NEW_LINE INDENT sum += int ( c ) NEW_LINE DEDENT while sum > 0 : NEW_LINE INDENT biStr = str ( sum % 2 ) + biStr NEW_LINE sum //= 2 NEW_LINE DEDENT return biStr NEW_LINE DEDENT 
def anti_shuffle ( s ) : NEW_LINE INDENT ret = "" NEW_LINE current = "" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i == len ( s ) or s [ i ] == " " : NEW_LINE INDENT tmp = sorted ( list ( current ) ) NEW_LINE if ret : NEW_LINE INDENT ret += " " NEW_LINE DEDENT ret += "" . join ( tmp ) NEW_LINE current = "" NEW_LINE DEDENT else : NEW_LINE INDENT current += s [ i ] NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT 
def sortArray ( array ) : NEW_LINE INDENT if len ( array ) == 0 : NEW_LINE INDENT return array NEW_LINE DEDENT if ( array [ 0 ] + array [ - 1 ] ) % 2 == 1 : NEW_LINE INDENT array . sort ( ) NEW_LINE DEDENT else : NEW_LINE INDENT array . sort ( reverse = True ) NEW_LINE DEDENT return array NEW_LINE DEDENT 
def encrypt ( s ) : NEW_LINE INDENT ans = "" NEW_LINE for c in s : NEW_LINE INDENT if c . isalpha ( ) : NEW_LINE INDENT ans += chr ( ord ( 'a' ) + ( ord ( c ) - ord ( 'a' ) + 4 ) % 26 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += c NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def isBored ( s ) : NEW_LINE INDENT isStart = True NEW_LINE sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == '.' or s [ i ] == '?' or s [ i ] == '!' : NEW_LINE INDENT isStart = True NEW_LINE DEDENT elif isStart : NEW_LINE INDENT if s [ i ] == ' ' : NEW_LINE INDENT continue NEW_LINE DEDENT if s . startswith ( "I " , i ) : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT isStart = False NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT 
def encode ( message ) : NEW_LINE INDENT vowels = "aeiouAEIOU" NEW_LINE ret = "" NEW_LINE for c in message : NEW_LINE INDENT if c . isupper ( ) : NEW_LINE INDENT c = c . lower ( ) NEW_LINE if c in vowels : NEW_LINE INDENT c = chr ( ord ( 'a' ) + ( ord ( c ) - ord ( 'a' ) + 2 ) % 26 ) NEW_LINE DEDENT DEDENT elif c . islower ( ) : NEW_LINE INDENT c = c . upper ( ) NEW_LINE if c in vowels : NEW_LINE INDENT c = chr ( ord ( 'A' ) + ( ord ( c ) - ord ( 'A' ) + 2 ) % 26 ) NEW_LINE DEDENT DEDENT ret += c NEW_LINE DEDENT return ret NEW_LINE DEDENT 
def skjkasdkd ( lst ) : NEW_LINE INDENT largest = 0 NEW_LINE for n in lst : NEW_LINE INDENT if n > largest : NEW_LINE INDENT prime = True NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT prime = False NEW_LINE DEDENT DEDENT if prime : NEW_LINE INDENT largest = n NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE s = str ( largest ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT sum += int ( s [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT 
def checkDictCase ( dict ) : NEW_LINE INDENT if len ( dict ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT isLower = 0 NEW_LINE isUpper = 0 NEW_LINE for key in dict . keys ( ) : NEW_LINE INDENT for c in key : NEW_LINE INDENT if c . islower ( ) : NEW_LINE INDENT isLower = 1 NEW_LINE DEDENT elif c . isupper ( ) : NEW_LINE INDENT isUpper = 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return isLower + isUpper == 1 NEW_LINE DEDENT 
def multiply ( a , b ) : NEW_LINE INDENT return ( abs ( a ) % 10 ) * ( abs ( b ) % 10 ) NEW_LINE DEDENT 
def countUpper ( s ) : NEW_LINE INDENT uVowel = "AEIOU" NEW_LINE count = 0 NEW_LINE for i in range ( 0 , len ( s ) , 2 ) : NEW_LINE INDENT if s [ i ] in uVowel : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT 
def byLength ( arr ) : NEW_LINE INDENT numTo = { 1 : "One" , 2 : "Two" , 3 : "Three" , 4 : "Four" , 5 : "Five" , 6 : "Six" , 7 : "Seven" , 8 : "Eight" , 9 : "Nine" } NEW_LINE sortedArr = sorted ( arr , reverse = True ) NEW_LINE newArr = [ ] NEW_LINE for n in sortedArr : NEW_LINE INDENT if n >= 1 and n <= 9 : NEW_LINE INDENT newArr . append ( numTo [ n ] ) NEW_LINE DEDENT DEDENT return newArr NEW_LINE DEDENT 
def f ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE prod = 1 NEW_LINE result = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i NEW_LINE prod *= i NEW_LINE if i % 2 == 0 : NEW_LINE INDENT result . append ( prod ) NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( sum ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def evenOddPalindrome ( n ) : NEW_LINE INDENT evenCount = 0 NEW_LINE oddCount = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = str ( i ) NEW_LINE rStr = s [ : : - 1 ] NEW_LINE if s == rStr : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT oddCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT evenCount += 1 NEW_LINE DEDENT DEDENT DEDENT return [ evenCount , oddCount ] NEW_LINE DEDENT 
def histogram ( test ) : NEW_LINE INDENT count = { } NEW_LINE max = 0 NEW_LINE for i in range ( len ( test ) ) : NEW_LINE INDENT if test [ i ] != ' ' : NEW_LINE INDENT if test [ i ] in count : NEW_LINE INDENT count [ test [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ test [ i ] ] = 1 NEW_LINE DEDENT if count [ test [ i ] ] > max : NEW_LINE INDENT max = count [ test [ i ] ] NEW_LINE DEDENT DEDENT DEDENT result = { } NEW_LINE for key , value in count . items ( ) : NEW_LINE INDENT if value == max : NEW_LINE INDENT result [ key ] = value NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def reverseDelete ( s , c ) : NEW_LINE INDENT ret = [ ] NEW_LINE for ch in s : NEW_LINE INDENT if c . find ( ch ) == - 1 : NEW_LINE INDENT ret . append ( ch ) NEW_LINE DEDENT DEDENT flag = "False" NEW_LINE if "" . join ( ret ) == "" . join ( ret [ : : - 1 ] ) : NEW_LINE INDENT flag = "True" NEW_LINE DEDENT return [ "" . join ( ret ) , flag ] NEW_LINE DEDENT 
def sort_array ( arr ) : NEW_LINE INDENT bin = [ ] NEW_LINE for i in arr : NEW_LINE INDENT b = 0 NEW_LINE n = abs ( i ) NEW_LINE while n > 0 : NEW_LINE INDENT b += n % 2 NEW_LINE n //= 2 NEW_LINE DEDENT bin . append ( b ) NEW_LINE DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT for j in range ( 1 , len ( arr ) ) : NEW_LINE INDENT if bin [ j ] < bin [ j - 1 ] or ( bin [ j ] == bin [ j - 1 ] and arr [ j ] < arr [ j - 1 ] ) : NEW_LINE INDENT bin [ j ] , bin [ j - 1 ] = bin [ j - 1 ] , bin [ j ] NEW_LINE arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] NEW_LINE DEDENT DEDENT DEDENT return arr NEW_LINE DEDENT 
def getClosestVowel ( word ) : NEW_LINE INDENT vowels = "AEIOUaeiou" NEW_LINE for i in range ( len ( word ) - 2 , 0 , - 1 ) : NEW_LINE INDENT if ( vowels . find ( word [ i ] ) != - 1 and vowels . find ( word [ i + 1 ] ) == - 1 and vowels . find ( word [ i - 1 ] ) == - 1 ) : NEW_LINE INDENT return word [ i ] NEW_LINE DEDENT DEDENT return "" NEW_LINE DEDENT 
def matchParens ( lst ) : NEW_LINE INDENT strings = [ lst [ 0 ] + lst [ 1 ] , lst [ 1 ] + lst [ 0 ] ] NEW_LINE for l in strings : NEW_LINE INDENT count = 0 NEW_LINE for c in l : NEW_LINE INDENT if c == '(' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if count < 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if count == 0 : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT DEDENT return "No" NEW_LINE DEDENT 
def maximum ( arr , k ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE return arr [ len ( arr ) - k : len ( arr ) ] NEW_LINE DEDENT 
def validDate ( date ) : NEW_LINE INDENT if len ( date ) != 10 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT if i == 2 or i == 5 : NEW_LINE INDENT if date [ i ] != '-' : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif not date [ i ] . isdigit ( ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT month = int ( date [ 0 : 2 ] ) NEW_LINE day = int ( date [ 3 : 5 ] ) NEW_LINE year = int ( date [ 6 : 10 ] ) NEW_LINE if month < 1 or month > 12 : NEW_LINE INDENT return False NEW_LINE DEDENT if day < 1 or day > 31 : NEW_LINE INDENT return False NEW_LINE DEDENT if day == 31 and ( month == 4 or month == 6 or month == 9 or month == 11 or month == 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if day == 30 and month == 2 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT 
def splitWords ( txt ) : NEW_LINE INDENT current = "" NEW_LINE result = [ ] NEW_LINE if ' ' in txt : NEW_LINE INDENT for i in range ( len ( txt ) ) : NEW_LINE INDENT if i == len ( txt ) or txt [ i ] == ' ' : NEW_LINE INDENT if len ( current ) > 0 : NEW_LINE INDENT result . append ( current ) NEW_LINE DEDENT current = "" NEW_LINE DEDENT else : NEW_LINE INDENT current += txt [ i ] NEW_LINE DEDENT DEDENT DEDENT if ',' in txt : NEW_LINE INDENT for i in range ( len ( txt ) ) : NEW_LINE INDENT if i == len ( txt ) or txt [ i ] == ',' : NEW_LINE INDENT if len ( current ) > 0 : NEW_LINE INDENT result . append ( current ) NEW_LINE DEDENT current = "" NEW_LINE DEDENT else : NEW_LINE INDENT current += txt [ i ] NEW_LINE DEDENT DEDENT DEDENT num = 0 NEW_LINE for c in txt : NEW_LINE INDENT if c . islower ( ) and ord ( c ) % 2 == 0 : NEW_LINE INDENT num += 1 NEW_LINE DEDENT DEDENT return [ str ( num ) ] + result NEW_LINE DEDENT 
def tri ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return [ 1 ] NEW_LINE DEDENT tris = [ 1 , 3 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT tris . append ( i / 2 + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT tris . append ( tris [ i - 1 ] + tris [ i - 2 ] + ( i + 3 ) / 2 ) NEW_LINE DEDENT DEDENT return tris NEW_LINE DEDENT 
def check_if_last_char_is_a_letter ( txt ) : NEW_LINE INDENT if len ( txt ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return txt [ - 1 ] . isalpha ( ) and ( len ( txt ) == 1 or not txt [ - 2 ] . isalpha ( ) ) NEW_LINE DEDENT 
def orderByPoints ( nums ) : NEW_LINE INDENT result = [ ] NEW_LINE for num in nums : NEW_LINE INDENT w = str ( abs ( num ) ) NEW_LINE sum = 0 NEW_LINE for c in w : NEW_LINE INDENT sum += int ( c ) NEW_LINE DEDENT if num < 0 : NEW_LINE INDENT sum -= 2 * int ( w [ 0 ] ) NEW_LINE DEDENT result . append ( sum ) NEW_LINE DEDENT for i in range ( len ( nums ) ) : NEW_LINE INDENT for j in range ( 1 , len ( nums ) ) : NEW_LINE INDENT if result [ j - 1 ] > result [ j ] : NEW_LINE INDENT result [ j - 1 ] , result [ j ] = result [ j ] , result [ j - 1 ] NEW_LINE nums [ j - 1 ] , nums [ j ] = nums [ j ] , nums [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return nums NEW_LINE DEDENT 
def bf ( planet1 , planet2 ) : NEW_LINE INDENT planets = [ "Mercury" , "Venus" , "Earth" , "Mars" , "Jupiter" , "Saturn" , "Uranus" , "Neptune" ] NEW_LINE idx1 = planets . index ( planet1 ) NEW_LINE idx2 = planets . index ( planet2 ) NEW_LINE if idx1 == - 1 or idx2 == - 1 or idx1 == idx2 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT return planets [ idx2 + 1 : idx1 ] if idx1 > idx2 else planets [ idx1 + 1 : idx2 ] NEW_LINE DEDENT 
def sortedListSum ( lst ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in lst : NEW_LINE INDENT if len ( i ) % 2 == 0 : NEW_LINE INDENT result . append ( i ) NEW_LINE DEDENT DEDENT result . sort ( key = lambda x : ( len ( x ) , x ) ) NEW_LINE return result NEW_LINE DEDENT 
def cycpatternCheck ( a , b ) : NEW_LINE INDENT for i in range ( len ( b ) + 1 ) : NEW_LINE INDENT rotate = b [ i : ] + b [ : i ] NEW_LINE if a . find ( rotate ) != - 1 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT 
def even_odd_count ( num ) : NEW_LINE INDENT even_count = 0 NEW_LINE odd_count = 0 NEW_LINE for i in str ( abs ( num ) ) : NEW_LINE INDENT if int ( i ) % 2 == 0 : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT DEDENT return [ even_count , odd_count ] NEW_LINE DEDENT 
def findMax ( words ) : NEW_LINE INDENT max = "" NEW_LINE maxLength = 0 NEW_LINE for word in words : NEW_LINE INDENT unique = [ ] NEW_LINE for w in word : NEW_LINE INDENT if w not in unique : NEW_LINE INDENT unique . append ( w ) NEW_LINE DEDENT DEDENT if len ( unique ) > maxLength or ( len ( unique ) == maxLength and word < max ) : NEW_LINE INDENT max = word NEW_LINE maxLength = len ( unique ) NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT 
def solve ( s ) : NEW_LINE INDENT noLetter = True NEW_LINE result = [ ] NEW_LINE for ch in s : NEW_LINE INDENT if ch . isupper ( ) : NEW_LINE INDENT ch = ch . lower ( ) NEW_LINE noLetter = False NEW_LINE DEDENT elif ch . islower ( ) : NEW_LINE INDENT ch = ch . upper ( ) NEW_LINE noLetter = False NEW_LINE DEDENT result . append ( ch ) NEW_LINE DEDENT if noLetter : NEW_LINE INDENT return "" . join ( result [ : : - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return "" . join ( result ) NEW_LINE DEDENT DEDENT 
def mostFrequent ( arr , n ) : NEW_LINE INDENT hp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in hp : NEW_LINE INDENT hp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT maxCount = 0 NEW_LINE res = - 1 NEW_LINE for key , value in hp . items ( ) : NEW_LINE INDENT if maxCount < value : NEW_LINE INDENT res = key NEW_LINE maxCount = value NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT 
def find ( a , b , k , n1 , n2 ) : NEW_LINE INDENT s = set ( b ) NEW_LINE missing = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if a [ i ] not in s : NEW_LINE INDENT missing += 1 NEW_LINE DEDENT if missing == k : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT 
def solveQuery ( start , end , arr ) : NEW_LINE INDENT mp = defaultdict ( int ) NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if key == value : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT 
def segregate ( arr , size ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] <= 0 : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT 
def countTriplets ( a , n ) : NEW_LINE INDENT s = set ( a ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT xr = a [ i ] ^ a [ j ] NEW_LINE if xr in s and xr != a [ i ] and xr != a [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count // 3 NEW_LINE DEDENT 
def leastFrequent ( arr , n ) : NEW_LINE INDENT hp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in hp : NEW_LINE INDENT hp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT minCount = n + 1 NEW_LINE res = - 1 NEW_LINE for key , value in hp . items ( ) : NEW_LINE INDENT if minCount >= value : NEW_LINE INDENT res = key NEW_LINE minCount = value NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT 
def find_permutations ( arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE maxInd = - 1 NEW_LINE minInd = 10000000 NEW_LINE n = len ( arr ) NEW_LINE indexOf = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT indexOf [ arr [ i ] ] = i + 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT maxInd = max ( maxInd , indexOf . get ( i , 0 ) ) NEW_LINE minInd = min ( minInd , indexOf . get ( i , 0 ) ) NEW_LINE if ( maxInd - minInd + 1 == i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT 
def formQuadruplets ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE pairs = 0 NEW_LINE pairs = n // 4 NEW_LINE arr . sort ( reverse = True ) NEW_LINE for i in range ( 0 , n - pairs , 3 ) : NEW_LINE INDENT ans += arr [ i + 2 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT 
def lexicographicallyMaximum ( s , n ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] in m : NEW_LINE INDENT m [ s [ i ] ] = m [ s [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT v = [ ] NEW_LINE for i in range ( ord ( 'a' ) , ord ( 'a' ) + min ( n , 25 ) ) : NEW_LINE INDENT if chr ( i ) not in m : NEW_LINE INDENT v . append ( chr ( i ) ) NEW_LINE DEDENT DEDENT j = len ( v ) - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ord ( s [ i ] ) >= ord ( 'a' ) + min ( n , 25 ) or ( s [ i ] in m and m [ s [ i ] ] > 1 ) : NEW_LINE INDENT if v [ j ] < s [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT m [ s [ i ] ] = m [ s [ i ] ] - 1 NEW_LINE s = s [ : i ] + v [ j ] + s [ i + 1 : ] NEW_LINE j = j - 1 NEW_LINE DEDENT if j < 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if l > j : NEW_LINE INDENT break NEW_LINE DEDENT if ord ( s [ i ] ) >= ord ( 'a' ) + min ( n , 25 ) or ( s [ i ] in m and m [ s [ i ] ] > 1 ) : NEW_LINE INDENT m [ s [ i ] ] = m [ s [ i ] ] - 1 NEW_LINE s = s [ : i ] + v [ l ] + s [ i + 1 : ] NEW_LINE l = l + 1 NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT 
def noOfValidKbers ( k , arr ) : NEW_LINE INDENT s = set ( ) NEW_LINE while k != 0 : NEW_LINE INDENT s . add ( k % 10 ) NEW_LINE k = k // 10 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT no = arr [ i ] NEW_LINE flag = True NEW_LINE while no != 0 : NEW_LINE INDENT digit = no % 10 NEW_LINE if digit not in s : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT no = no // 10 NEW_LINE DEDENT if flag : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT 
def delCost ( s , cost ) : NEW_LINE INDENT ans = 0 NEW_LINE forMax = { } NEW_LINE forTot = { } NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] not in forMax : NEW_LINE INDENT forMax [ s [ i ] ] = cost [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT forMax [ s [ i ] ] = max ( cost [ i ] , forMax [ s [ i ] ] ) NEW_LINE DEDENT if s [ i ] not in forTot : NEW_LINE INDENT forTot [ s [ i ] ] = cost [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT forTot [ s [ i ] ] += cost [ i ] NEW_LINE DEDENT DEDENT for i in forMax . items ( ) : NEW_LINE INDENT ans += forTot [ i [ 0 ] ] - i [ 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT 
def replaceDuplicates ( names ) : NEW_LINE INDENT hash = { } NEW_LINE for i in range ( len ( names ) ) : NEW_LINE INDENT if names [ i ] not in hash : NEW_LINE INDENT hash [ names [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = hash [ names [ i ] ] NEW_LINE hash [ names [ i ] ] += 1 NEW_LINE names [ i ] = names [ i ] + str ( count ) NEW_LINE DEDENT DEDENT return names NEW_LINE DEDENT 
def minmaxNumbers ( matrix , res ) : NEW_LINE INDENT set = [ ] NEW_LINE for i in range ( len ( matrix ) ) : NEW_LINE INDENT minR = float ( 'inf' ) NEW_LINE for j in range ( len ( matrix [ i ] ) ) : NEW_LINE INDENT minR = min ( minR , matrix [ i ] [ j ] ) NEW_LINE DEDENT set . append ( minR ) NEW_LINE DEDENT for j in range ( len ( matrix [ 0 ] ) ) : NEW_LINE INDENT maxC = float ( '-inf' ) NEW_LINE for i in range ( len ( matrix ) ) : NEW_LINE INDENT maxC = max ( maxC , matrix [ i ] [ j ] ) NEW_LINE DEDENT if maxC in set : NEW_LINE INDENT res . append ( maxC ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT 
def lengthOfLongestAP ( a , n ) : NEW_LINE INDENT dp = { } NEW_LINE res = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT d = a [ j ] - a [ i ] NEW_LINE if d in dp : NEW_LINE INDENT if i in dp [ d ] : NEW_LINE INDENT dp [ d ] [ j ] = dp [ d ] [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ d ] [ j ] = 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ d ] = { } NEW_LINE dp [ d ] [ j ] = 2 NEW_LINE DEDENT res = max ( res , dp [ d ] [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT 
def findKthChar ( n , k ) : NEW_LINE INDENT prev = "A" NEW_LINE cur = "" NEW_LINE if n == 1 : NEW_LINE INDENT return 'A' NEW_LINE DEDENT for j in range ( 2 , n + 1 ) : NEW_LINE INDENT cur = prev + "B" NEW_LINE for i in range ( len ( prev ) ) : NEW_LINE INDENT if prev [ i ] == 'A' : NEW_LINE INDENT prev = prev [ : i ] + 'B' + prev [ i + 1 : ] NEW_LINE DEDENT else : NEW_LINE INDENT prev = prev [ : i ] + 'A' + prev [ i + 1 : ] NEW_LINE DEDENT DEDENT prev = prev [ : : - 1 ] NEW_LINE cur += prev NEW_LINE prev = cur NEW_LINE DEDENT return cur [ k - 1 ] NEW_LINE DEDENT 
def findKthLargest ( s , k ) : NEW_LINE INDENT tmp = list ( s ) NEW_LINE tmp . sort ( ) NEW_LINE tmp . reverse ( ) NEW_LINE return tmp [ k - 1 ] NEW_LINE DEDENT 
def subArraylen ( arr , n , k ) : NEW_LINE INDENT mp = { } NEW_LINE mp [ arr [ 0 ] ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] + arr [ i - 1 ] NEW_LINE mp [ arr [ i ] ] = i NEW_LINE DEDENT len = float ( 'inf' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < k : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT x = arr [ i ] - k NEW_LINE if x == 0 : NEW_LINE INDENT len = min ( len , i ) NEW_LINE DEDENT if x not in mp : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT len = min ( len , i - mp [ x ] ) NEW_LINE DEDENT DEDENT DEDENT return len NEW_LINE DEDENT 
def findMaxLen ( a , k ) : NEW_LINE INDENT n = len ( a ) NEW_LINE a . sort ( ) NEW_LINE vis = [ False ] * n NEW_LINE mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] = i NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if not vis [ i ] : NEW_LINE INDENT check = a [ i ] * k NEW_LINE if check in mp : NEW_LINE INDENT c += 1 NEW_LINE vis [ mp [ check ] ] = True NEW_LINE DEDENT DEDENT DEDENT return n - c NEW_LINE DEDENT 
def minDistancePoints ( a , k , n ) : NEW_LINE INDENT m = { } NEW_LINE q = deque ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ a [ i ] ] = 1 NEW_LINE q . append ( a [ i ] ) NEW_LINE DEDENT ans = [ ] NEW_LINE while k > 0 : NEW_LINE INDENT x = q . popleft ( ) NEW_LINE if ( x - 1 ) not in m and k > 0 : NEW_LINE INDENT m [ x - 1 ] = 1 NEW_LINE q . append ( x - 1 ) NEW_LINE ans . append ( x - 1 ) NEW_LINE k -= 1 NEW_LINE DEDENT if ( x + 1 ) not in m and k > 0 : NEW_LINE INDENT m [ x + 1 ] = 1 NEW_LINE q . append ( x + 1 ) NEW_LINE ans . append ( x + 1 ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def isValidLen ( s , length , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE mp = { } NEW_LINE right = 0 NEW_LINE while right < length : NEW_LINE INDENT if s [ right ] in mp : NEW_LINE INDENT mp [ s [ right ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ s [ right ] ] = 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT if len ( mp ) <= k : NEW_LINE INDENT return True NEW_LINE DEDENT while right < n : NEW_LINE INDENT if s [ right ] in mp : NEW_LINE INDENT mp [ s [ right ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ s [ right ] ] = 1 NEW_LINE DEDENT if s [ right - length ] in mp : NEW_LINE INDENT mp [ s [ right - length ] ] -= 1 NEW_LINE DEDENT if mp [ s [ right - length ] ] == 0 : NEW_LINE INDENT del mp [ s [ right - length ] ] NEW_LINE DEDENT if len ( mp ) <= k : NEW_LINE INDENT return True NEW_LINE DEDENT right += 1 NEW_LINE DEDENT return len ( mp ) <= k NEW_LINE DEDENT 
def partition ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ high ] NEW_LINE i = low - 1 NEW_LINE for j in range ( low , high ) : NEW_LINE INDENT if arr [ j ] <= pivot : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT arr [ i + 1 ] , arr [ high ] = arr [ high ] , arr [ i + 1 ] NEW_LINE return i + 1 NEW_LINE DEDENT 
def str_score ( strs , s , n ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ strs [ i ] ] = i + 1 NEW_LINE DEDENT if s not in m : NEW_LINE INDENT return 0 NEW_LINE DEDENT score = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT score += ord ( s [ i ] ) - ord ( 'a' ) + 1 NEW_LINE DEDENT score = score * m [ s ] NEW_LINE return score NEW_LINE DEDENT 
def countEle ( s , a , n ) : NEW_LINE INDENT mp = { } NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE if num in mp : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 0 NEW_LINE while s [ 0 ] != num : NEW_LINE INDENT mp [ s [ 0 ] ] = True NEW_LINE s . pop ( 0 ) NEW_LINE cnt += 1 NEW_LINE DEDENT s . pop ( 0 ) NEW_LINE cnt += 1 NEW_LINE ans . append ( cnt ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def maxDistinctChar ( s , n , k ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] in freq : NEW_LINE INDENT freq [ s [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT v = [ ] NEW_LINE for key , value in freq . items ( ) : NEW_LINE INDENT v . append ( value ) NEW_LINE DEDENT v . sort ( ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT mn = min ( v [ i ] - 1 , k ) NEW_LINE v [ i ] = v [ i ] - mn NEW_LINE k -= mn NEW_LINE DEDENT if k > 0 : NEW_LINE INDENT for i in range ( len ( v ) ) : NEW_LINE INDENT mn = min ( v [ i ] , k ) NEW_LINE v [ i ] = v [ i ] - mn NEW_LINE k -= mn NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if v [ i ] == 1 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT 
def findKth ( arr , n , k ) : NEW_LINE INDENT missing = set ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT missing . add ( arr [ i ] ) NEW_LINE DEDENT maxM = max ( arr ) NEW_LINE minM = min ( arr ) NEW_LINE for i in range ( minM + 1 , maxM ) : NEW_LINE INDENT if i not in missing : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == k : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT 
def almostSort ( a , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] > a [ i + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def maximumSum ( s , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE freq = [ 0 ] * 256 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT freq . sort ( reverse = True ) NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT if k > freq [ i ] : NEW_LINE INDENT sum += freq [ i ] * freq [ i ] NEW_LINE k -= freq [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += freq [ i ] * k NEW_LINE break NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT 
def findMinOperations ( arr , N , K ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT freq = { } NEW_LINE for j in range ( i , N , K ) : NEW_LINE INDENT freq [ arr [ j ] ] = freq . get ( arr [ j ] , 0 ) + 1 NEW_LINE DEDENT max1 = 0 NEW_LINE num = 0 NEW_LINE for entry in freq . items ( ) : NEW_LINE INDENT if entry [ 1 ] > max1 : NEW_LINE INDENT max1 = entry [ 1 ] NEW_LINE num = entry [ 0 ] NEW_LINE DEDENT DEDENT for entry in freq . items ( ) : NEW_LINE INDENT if entry [ 0 ] != num : NEW_LINE INDENT operations += entry [ 1 ] NEW_LINE DEDENT DEDENT DEDENT return operations NEW_LINE DEDENT 
def subString ( s , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for length in range ( 1 , n - i + 1 ) : NEW_LINE INDENT find = s [ i : i + length ] NEW_LINE v . append ( find ) NEW_LINE DEDENT DEDENT return v NEW_LINE DEDENT 
def checkUniqueFrequency ( arr , n ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in freq : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT uniqueFreq = set ( ) NEW_LINE for key , value in freq . items ( ) : NEW_LINE INDENT if value in uniqueFreq : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT uniqueFreq . add ( value ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def minCost ( str1 , str2 , n ) : NEW_LINE INDENT cost = 0 NEW_LINE tmp = list ( str1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if tmp [ i ] != str2 [ i ] : NEW_LINE INDENT if i < n - 1 and tmp [ i + 1 ] != str2 [ i + 1 ] : NEW_LINE INDENT c = tmp [ i ] NEW_LINE tmp [ i ] = tmp [ i + 1 ] NEW_LINE tmp [ i + 1 ] = c NEW_LINE cost += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cost += 1 NEW_LINE DEDENT DEDENT DEDENT return cost NEW_LINE DEDENT 
def isValidNum ( x ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT if ( x [ i ] ) in mp : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( int ( x [ i ] ) - 0 ) > 5 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT mp [ int ( x [ i ] ) ] = 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def minimize_diff ( arr , n , k ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE min_val = min ( arr ) NEW_LINE if max_val - min_val <= k : NEW_LINE INDENT return max_val - min_val NEW_LINE DEDENT avg = ( max_val + min_val ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > avg : NEW_LINE INDENT arr [ i ] -= k NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += k NEW_LINE DEDENT DEDENT max_val = max ( arr ) NEW_LINE min_val = min ( arr ) NEW_LINE return max_val - min_val NEW_LINE DEDENT 
def getMinCost ( arr , n ) : NEW_LINE INDENT minEle = min ( arr ) NEW_LINE return minEle * ( n - 1 ) NEW_LINE DEDENT 
def possibility ( m , length , s ) : NEW_LINE INDENT countOdd = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( m . get ( ord ( s [ i ] ) - 48 ) & 1 ) != 0 : NEW_LINE INDENT countOdd += 1 NEW_LINE DEDENT if countOdd > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def minimumCostOfBreaking ( x , y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE x . sort ( reverse = True ) NEW_LINE y . sort ( reverse = True ) NEW_LINE hzntl = 1 NEW_LINE vert = 1 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if x [ i ] > y [ j ] : NEW_LINE INDENT res += x [ i ] * vert NEW_LINE hzntl += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += y [ j ] * hzntl NEW_LINE vert += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE while i < m : NEW_LINE INDENT total += x [ i ] NEW_LINE i += 1 NEW_LINE DEDENT res += total * vert NEW_LINE total = 0 NEW_LINE while j < n : NEW_LINE INDENT total += y [ j ] NEW_LINE j += 1 NEW_LINE DEDENT res += total * hzntl NEW_LINE return res NEW_LINE DEDENT 
def findMaximumScore ( a , n ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in freq : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT dp = [ 0 ] * ( max ( a ) + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = freq . get ( 1 , 0 ) NEW_LINE for i in range ( 2 , len ( dp ) ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , dp [ i - 2 ] + freq . get ( i , 0 ) * i ) NEW_LINE DEDENT return dp [ - 1 ] NEW_LINE DEDENT 
def countWays ( s , t , k , mod ) : NEW_LINE INDENT n = len ( s ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT p = s [ i : n ] + s [ 0 : i ] NEW_LINE if p == t : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT dp1 = [ 0 ] * ( k + 1 ) NEW_LINE dp2 = [ 0 ] * ( k + 1 ) NEW_LINE if s == t : NEW_LINE INDENT dp1 [ 0 ] = 1 NEW_LINE dp2 [ 0 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp1 [ 0 ] = 0 NEW_LINE dp2 [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod NEW_LINE dp2 [ i ] = ( ( dp1 [ i - 1 ] * b ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod NEW_LINE DEDENT return dp1 [ k ] NEW_LINE DEDENT 
def findSubarraySum ( arr , n , k ) : NEW_LINE INDENT prevSum = { } NEW_LINE res = 0 NEW_LINE currSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT currSum += arr [ i ] NEW_LINE if currSum == k : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if currSum - k in prevSum : NEW_LINE INDENT res += prevSum [ currSum - k ] NEW_LINE DEDENT prevSum [ currSum ] = prevSum . get ( currSum , 0 ) + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT 
def maximum_occurrence ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = s [ i ] NEW_LINE if temp in freq : NEW_LINE INDENT freq [ temp ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ temp ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT temp = s [ i ] + s [ j ] NEW_LINE if temp in freq : NEW_LINE INDENT freq [ temp ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ temp ] = 1 NEW_LINE DEDENT DEDENT DEDENT answer = float ( '-inf' ) NEW_LINE for key , value in freq . items ( ) : NEW_LINE INDENT answer = max ( answer , value ) NEW_LINE DEDENT return answer NEW_LINE DEDENT 
def count_characters ( strings , chars ) : NEW_LINE INDENT res = 0 NEW_LINE freq = { } NEW_LINE for char in chars : NEW_LINE INDENT freq [ char ] = freq . get ( char , 0 ) + 1 NEW_LINE DEDENT for st in strings : NEW_LINE INDENT flag = True NEW_LINE for c in st : NEW_LINE INDENT if c not in freq : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT res += len ( st ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT 
def distinctSubstring ( p , q , k , n ) : NEW_LINE INDENT ss = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE s = "" NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT pos = ord ( p [ j ] ) - ord ( 'a' ) NEW_LINE sum += int ( q [ pos ] ) NEW_LINE s += p [ j ] NEW_LINE if sum <= k : NEW_LINE INDENT ss . add ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( ss ) NEW_LINE DEDENT 
def uniqueMorseRep ( arr ) : NEW_LINE INDENT morseCode = [ ".-" , "-..." , "-.-." , "-.." , "." , "..-." , "--." , "...." , ".." , ".---" , "-.-" , ".-.." , "--" , "-." , "---" , ".--." , "--.-" , ".-." , "..." , "-" , "..-" , "...-" , ".--" , "-..-" , "-.--" , "--.." ] NEW_LINE st = set ( ) NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = "" NEW_LINE m = len ( arr [ i ] ) NEW_LINE for j in range ( m ) : NEW_LINE INDENT temp += morseCode [ ord ( arr [ i ] [ j ] ) - ord ( 'a' ) ] NEW_LINE DEDENT st . add ( temp ) NEW_LINE DEDENT return len ( st ) NEW_LINE DEDENT 
def count_substrings ( st , k ) : NEW_LINE INDENT n = len ( st ) NEW_LINE answer = 0 NEW_LINE map = { } NEW_LINE for i in range ( k ) : NEW_LINE INDENT if st [ i ] not in map . keys ( ) : NEW_LINE INDENT map [ st [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT map [ st [ i ] ] += 1 NEW_LINE DEDENT DEDENT if len ( map ) == k : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT if st [ i ] not in map . keys ( ) : NEW_LINE INDENT map [ st [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT map [ st [ i ] ] += 1 NEW_LINE DEDENT map [ st [ i - k ] ] -= 1 NEW_LINE if map [ st [ i - k ] ] == 0 : NEW_LINE INDENT del map [ st [ i - k ] ] NEW_LINE DEDENT if len ( map ) == k : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT 
def can_construct ( s , k ) : NEW_LINE INDENT m = { } NEW_LINE p = 0 NEW_LINE if len ( s ) == k : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] in m : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT if k > len ( s ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT for key , value in m . items ( ) : NEW_LINE INDENT if value % 2 != 0 : NEW_LINE INDENT p += 1 NEW_LINE DEDENT DEDENT DEDENT if k < p : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT 
def equal_ignore_case ( str1 , str2 ) : NEW_LINE INDENT str1 = str1 . upper ( ) NEW_LINE str2 = str2 . upper ( ) NEW_LINE return str1 == str2 NEW_LINE DEDENT 
def findLongestSub ( bin ) : NEW_LINE INDENT n = len ( bin ) NEW_LINE sum = 0 NEW_LINE prevSum = { } NEW_LINE maxLen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if bin [ i ] == '1' : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum -= 1 NEW_LINE DEDENT if sum > 0 : NEW_LINE INDENT maxLen = i + 1 NEW_LINE DEDENT elif sum <= 0 : NEW_LINE INDENT if ( sum - 1 ) in prevSum : NEW_LINE INDENT currLen = i - prevSum [ sum - 1 ] NEW_LINE maxLen = max ( maxLen , currLen ) NEW_LINE DEDENT DEDENT if sum not in prevSum : NEW_LINE INDENT prevSum [ sum ] = i NEW_LINE DEDENT DEDENT return maxLen NEW_LINE DEDENT 
def hasAllCodes ( s , k ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in range ( len ( s ) - k + 1 ) : NEW_LINE INDENT us . add ( s [ i : i + k ] ) NEW_LINE DEDENT return len ( us ) == 1 << k NEW_LINE DEDENT 
def checkPalin ( word ) : NEW_LINE INDENT n = len ( word ) NEW_LINE word = word . lower ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if word [ i ] != word [ n - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT n -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT 
def convert ( st ) : NEW_LINE INDENT w = "" NEW_LINE z = "" NEW_LINE st = st . upper ( ) + " " NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT ch = st [ i ] NEW_LINE if ch != ' ' : NEW_LINE INDENT w += ch NEW_LINE DEDENT else : NEW_LINE INDENT z += w [ 0 ] . lower ( ) + w [ 1 : ] + " " NEW_LINE w = "" NEW_LINE DEDENT DEDENT return z NEW_LINE DEDENT 
def maxLines ( n , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x1 [ i ] == x2 [ i ] : NEW_LINE INDENT slope = float ( 'inf' ) NEW_LINE DEDENT else : NEW_LINE INDENT slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) NEW_LINE DEDENT s . add ( slope ) NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT 
def PrimeFactor ( n ) : NEW_LINE INDENT primef = { } NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT if 2 in primef : NEW_LINE INDENT primef [ 2 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT primef [ 2 ] = 1 NEW_LINE DEDENT n //= 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( i <= int ( n ** 0.5 ) ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT if i in primef : NEW_LINE INDENT primef [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT primef [ i ] = 1 NEW_LINE DEDENT n //= i NEW_LINE DEDENT i += 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT primef [ n ] = 1 NEW_LINE DEDENT return primef NEW_LINE DEDENT 
def isDivisibleByDivisor ( s , d ) : NEW_LINE INDENT s %= d NEW_LINE hashMap = set ( ) NEW_LINE hashMap . add ( s ) NEW_LINE for i in range ( d + 1 ) : NEW_LINE INDENT s += s % d NEW_LINE s %= d NEW_LINE if s in hashMap : NEW_LINE INDENT if s == 0 : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT return "No" NEW_LINE DEDENT else : NEW_LINE INDENT hashMap . add ( s ) NEW_LINE DEDENT DEDENT return "Yes" NEW_LINE DEDENT 
def oddSum ( a , n , k ) : NEW_LINE INDENT odd = set ( ) NEW_LINE even = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT even . add ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT odd . add ( a [ i ] ) NEW_LINE DEDENT DEDENT if len ( odd ) >= k : NEW_LINE INDENT return True NEW_LINE DEDENT flag = False NEW_LINE for i in range ( 1 , k , 2 ) : NEW_LINE INDENT needed = k - i NEW_LINE if needed <= len ( even ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return flag NEW_LINE DEDENT 
def dayOfYear ( date ) : NEW_LINE INDENT days = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE year = int ( date [ 0 : 4 ] ) NEW_LINE month = int ( date [ 5 : 7 ] ) NEW_LINE day = int ( date [ 8 : ] ) NEW_LINE if month > 2 and year % 4 == 0 and ( year % 100 != 0 or year % 400 == 0 ) : NEW_LINE INDENT day += 1 NEW_LINE DEDENT while month > 1 : NEW_LINE INDENT day += days [ month - 2 ] NEW_LINE month -= 1 NEW_LINE DEDENT return day NEW_LINE DEDENT 
def isPerfectSquare ( arr , n ) : NEW_LINE INDENT umap = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in umap : NEW_LINE INDENT umap [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT umap [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT for key , value in umap . items ( ) : NEW_LINE INDENT if value % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def min_moves ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE ans = float ( 'inf' ) NEW_LINE length = len ( s ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT for j in range ( length ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT continue NEW_LINE DEDENT t = list ( s ) NEW_LINE cur = 0 NEW_LINE for k in range ( i , length - 1 ) : NEW_LINE INDENT c = t [ k ] NEW_LINE t [ k ] = t [ k + 1 ] NEW_LINE t [ k + 1 ] = c NEW_LINE cur += 1 NEW_LINE DEDENT for k in range ( j - ( j > i ? 1 : 0 ) , length - 2 ) : NEW_LINE INDENT c = t [ k ] NEW_LINE t [ k ] = t [ k + 1 ] NEW_LINE t [ k + 1 ] = c NEW_LINE cur += 1 NEW_LINE DEDENT pos = - 1 NEW_LINE for k in range ( length ) : NEW_LINE INDENT if t [ k ] != '0' : NEW_LINE INDENT pos = k NEW_LINE break NEW_LINE DEDENT DEDENT for k in range ( pos , 0 , - 1 ) : NEW_LINE INDENT c = t [ k ] NEW_LINE t [ k ] = t [ k - 1 ] NEW_LINE t [ k - 1 ] = c NEW_LINE cur += 1 NEW_LINE DEDENT nn = int ( '' . join ( t ) ) NEW_LINE if nn % 25 == 0 : NEW_LINE INDENT ans = min ( ans , cur ) NEW_LINE DEDENT DEDENT DEDENT if ans == float ( 'inf' ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT 
def minimumOperations ( a , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] = mp . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT count = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if value > 1 : NEW_LINE INDENT count += value - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT 
def kaprekarRec ( n , prev ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT prev = n NEW_LINE digits = [ 0 ] * 4 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT digits [ i ] = n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT digits . sort ( ) NEW_LINE asc = 0 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT asc = asc * 10 + digits [ i ] NEW_LINE DEDENT digits . sort ( reverse = True ) NEW_LINE desc = 0 NEW_LINE for i in range ( 3 , - 1 , - 1 ) : NEW_LINE INDENT desc = desc * 10 + digits [ i ] NEW_LINE DEDENT diff = abs ( asc - desc ) NEW_LINE if diff == prev : NEW_LINE INDENT return diff NEW_LINE DEDENT return kaprekarRec ( diff , prev ) NEW_LINE DEDENT 
def fractionToDecimal ( numr , denr ) : NEW_LINE INDENT res = "" NEW_LINE mp = { } NEW_LINE rem = numr % denr NEW_LINE while rem != 0 and rem not in mp : NEW_LINE INDENT mp [ rem ] = len ( res ) NEW_LINE rem = rem * 10 NEW_LINE resPart = rem // denr NEW_LINE res += str ( resPart ) NEW_LINE rem = rem % denr NEW_LINE DEDENT if rem == 0 : NEW_LINE INDENT return "" NEW_LINE DEDENT if rem in mp : NEW_LINE INDENT return res [ mp [ rem ] : ] NEW_LINE DEDENT return "" NEW_LINE DEDENT 
def isFancy ( num ) : NEW_LINE INDENT fp = { '0' : '0' , '1' : '1' , '6' : '9' , '8' : '8' , '9' : '6' } NEW_LINE n = len ( num ) NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( num [ l ] not in fp ) or ( fp [ num [ l ] ] != num [ r ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT 
