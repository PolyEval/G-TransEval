def greatestCommonDivisor ( a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : NEW_LINE INDENT return a + b NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return greatestCommonDivisor ( a % b , b ) NEW_LINE DEDENT else : NEW_LINE INDENT return greatestCommonDivisor ( a , b % a ) NEW_LINE DEDENT DEDENT 
def largest_divisor ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return n // i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT 
def is_prime ( n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return False NEW_LINE DEDENT for k in range ( 2 , n ) : NEW_LINE INDENT if n % k == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def fizzBuzz ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if i % 11 == 0 or i % 13 == 0 : NEW_LINE INDENT q = i NEW_LINE while q > 0 : NEW_LINE INDENT if q % 10 == 7 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT q //= 10 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT 
def primeFib ( n ) : NEW_LINE INDENT f0 = 0 NEW_LINE f1 = 1 NEW_LINE while n > 0 : NEW_LINE INDENT p = f0 + f1 NEW_LINE isPrime = p >= 2 NEW_LINE for i in range ( 2 , p ) : NEW_LINE INDENT if p % i == 0 : NEW_LINE INDENT isPrime = False NEW_LINE break NEW_LINE DEDENT DEDENT if isPrime : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT f0 = f1 NEW_LINE f1 = p NEW_LINE DEDENT return f1 NEW_LINE DEDENT 
def triangleArea ( a , h ) : NEW_LINE INDENT return a * h / 2 NEW_LINE DEDENT 
def modP ( n , p ) : NEW_LINE INDENT ret = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ret = ( ret * 2 ) % p NEW_LINE DEDENT return ret NEW_LINE DEDENT 
def add ( x , y ) : NEW_LINE INDENT return x + y NEW_LINE DEDENT 
def fib ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT 
def largest_prime_factor ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while i < n : NEW_LINE INDENT while n % i == 0 and n > i : NEW_LINE INDENT n //= i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return n NEW_LINE DEDENT 
def sumToN ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT result += i NEW_LINE DEDENT return result NEW_LINE DEDENT 
def fibfib ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return fibfib ( n - 1 ) + fibfib ( n - 2 ) + fibfib ( n - 3 ) NEW_LINE DEDENT 
def isMultiplyPrime ( a ) : NEW_LINE INDENT num = 0 NEW_LINE i = 2 NEW_LINE while i <= a : NEW_LINE INDENT while a % i == 0 and a >= i : NEW_LINE INDENT a /= i NEW_LINE num += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return num == 3 NEW_LINE DEDENT 
def isSimplePower ( x , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return x == 1 NEW_LINE DEDENT power = 1 NEW_LINE while power < x : NEW_LINE INDENT power *= n NEW_LINE DEDENT return power == x NEW_LINE DEDENT 
def chooseNum ( x , y ) : NEW_LINE INDENT if x > y : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if y % 2 == 0 : NEW_LINE INDENT return y NEW_LINE DEDENT if x == y : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return y - 1 NEW_LINE DEDENT 
def is_equal_to_sum_even ( n ) : NEW_LINE INDENT return n % 2 == 0 and n >= 8 NEW_LINE DEDENT 
def specialFactorial ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE specialFact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE specialFact *= fact NEW_LINE DEDENT return specialFact NEW_LINE DEDENT 
def xOrY ( n , x , y ) : NEW_LINE INDENT isPrime = n >= 2 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT isPrime = False NEW_LINE break NEW_LINE DEDENT DEDENT if isPrime : NEW_LINE INDENT return x NEW_LINE DEDENT return y NEW_LINE DEDENT 
def rightAngleTriangle ( a , b , c ) : NEW_LINE INDENT return a * a == b * b + c * c or b * b == a * a + c * c or c * c == a * a + b * b NEW_LINE DEDENT 
def fastPow ( n , k ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = fastPow ( n , k // 2 ) NEW_LINE if k % 2 == 0 : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT return n * temp * temp NEW_LINE DEDENT DEDENT 
def is_palin ( s ) : NEW_LINE INDENT l = len ( s ) // 2 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if s [ i ] != s [ len ( s ) - i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def findSum ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if temp >= n : NEW_LINE INDENT break NEW_LINE DEDENT temp = i - 1 NEW_LINE num = 1 NEW_LINE while temp < n : NEW_LINE INDENT if temp + i <= n : NEW_LINE INDENT ans += i * num NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( n - temp ) * num NEW_LINE DEDENT temp += i NEW_LINE num += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def getNextGap ( gap ) : NEW_LINE INDENT gap = gap * 10 // 13 NEW_LINE if gap < 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return gap NEW_LINE DEDENT 
def countNonDecreasing ( n ) : NEW_LINE INDENT k = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count *= k + i - 1 NEW_LINE count //= i NEW_LINE DEDENT return count NEW_LINE DEDENT 
def power ( x , y ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif y % 2 == 0 : NEW_LINE INDENT return power ( x , y // 2 ) * power ( x , y // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return x * power ( x , y // 2 ) * power ( x , y // 2 ) NEW_LINE DEDENT DEDENT 
def power ( x , y ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = power ( x , y // 2 ) NEW_LINE if y % 2 == 0 : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT if y > 0 : NEW_LINE INDENT return x * temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT return temp * temp / x NEW_LINE DEDENT DEDENT DEDENT 
def multiply ( x , y ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif y > 0 : NEW_LINE INDENT return x + multiply ( x , y - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return - multiply ( x , - y ) NEW_LINE DEDENT DEDENT 
def smallest ( x , y , z ) : NEW_LINE INDENT if y // x == 0 : NEW_LINE INDENT return y // z if y % z == 0 else y NEW_LINE DEDENT return x // z if x % z == 0 else z NEW_LINE DEDENT 
def isPowerOfFour ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT while n != 1 : NEW_LINE INDENT if n % 4 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 4 NEW_LINE DEDENT return True NEW_LINE DEDENT 
def modInverse ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE x0 = 0 NEW_LINE x1 = 1 NEW_LINE if m == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT while a > 1 : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if x1 < 0 : NEW_LINE INDENT x1 += m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT 
def cntRotations ( s , n ) : NEW_LINE INDENT s2 = s + s NEW_LINE pre = [ 0 ] * ( 2 * n ) NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] NEW_LINE DEDENT if s2 [ i ] == 'a' or s2 [ i ] == 'e' or s2 [ i ] == 'i' or s2 [ i ] == 'o' or s2 [ i ] == 'u' : NEW_LINE INDENT pre [ i ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n - 1 , 2 * n - 1 ) : NEW_LINE INDENT r = i NEW_LINE l = i - n NEW_LINE x1 = pre [ r ] NEW_LINE if l >= 0 : NEW_LINE INDENT x1 -= pre [ l ] NEW_LINE DEDENT r = i - n // 2 NEW_LINE left = pre [ r ] NEW_LINE if l >= 0 : NEW_LINE INDENT left -= pre [ l ] NEW_LINE DEDENT right = x1 - left NEW_LINE if left > right : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if k > n - k : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= n - i NEW_LINE res //= i + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT 
def isPrefix ( temp , s ) : NEW_LINE INDENT if len ( temp ) < len ( s ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] != temp [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT 
def lexicographicallySmallestString ( s , n ) : NEW_LINE INDENT lastZe = - 1 NEW_LINE ans = "" NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT lastZe = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if i <= lastZe and s [ i ] == '0' : NEW_LINE INDENT ans += s [ i ] NEW_LINE DEDENT elif i > lastZe : NEW_LINE INDENT ans += s [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def calculate_max ( n , m , k ) : NEW_LINE INDENT ans = - 1 NEW_LINE low = 0 NEW_LINE high = m NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE val = 0 NEW_LINE l = k - 1 NEW_LINE r = n - k NEW_LINE val += mid NEW_LINE if mid >= l : NEW_LINE INDENT val += l * ( 2 * mid - l - 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT val += mid * ( mid - 1 ) // 2 + ( l - mid ) NEW_LINE DEDENT if mid >= r : NEW_LINE INDENT val += r * ( 2 * mid - r - 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT val += mid * ( mid - 1 ) // 2 + ( r - mid ) NEW_LINE DEDENT if val <= m : NEW_LINE INDENT ans = max ( ans , mid ) NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def findLength ( s : str , i : str , j : str ) -> int : NEW_LINE INDENT required = i NEW_LINE length = 0 NEW_LINE for curr in s : NEW_LINE INDENT if curr == required : NEW_LINE INDENT length += 1 NEW_LINE if required == i : NEW_LINE INDENT required = j NEW_LINE DEDENT else : NEW_LINE INDENT required = i NEW_LINE DEDENT DEDENT DEDENT return length NEW_LINE DEDENT 
def check_reverse ( left_sum , right_sum ) : NEW_LINE INDENT rev = 0 NEW_LINE temp = right_sum NEW_LINE while temp != 0 : NEW_LINE INDENT rev = rev * 10 + temp % 10 NEW_LINE temp //= 10 NEW_LINE DEDENT if rev == left_sum : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT 
def is_composite ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return False NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT 
def minDeletion ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE firstIdx1 = - 1 NEW_LINE lastIdx0 = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT firstIdx1 = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT lastIdx0 = i NEW_LINE break NEW_LINE DEDENT DEDENT if firstIdx1 == - 1 or lastIdx0 == - 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT count1 = 0 NEW_LINE count0 = 0 NEW_LINE for i in range ( lastIdx0 ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT DEDENT for i in range ( firstIdx1 + 1 , n ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT DEDENT return min ( count0 , count1 ) NEW_LINE DEDENT 
def minSteps ( s , n ) : NEW_LINE INDENT cost = 0 NEW_LINE f = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT currEle = ord ( s [ i ] ) - ord ( 'a' ) NEW_LINE smaller = 0 NEW_LINE for j in range ( currEle + 1 ) : NEW_LINE INDENT if f [ j ] != 0 : NEW_LINE INDENT smaller += f [ j ] NEW_LINE DEDENT DEDENT if smaller == 0 : NEW_LINE INDENT cost += i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT cost += i - smaller + 1 NEW_LINE DEDENT f [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT return cost NEW_LINE DEDENT 
def numberOfWays ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for a in range ( 1 , n ) : NEW_LINE INDENT for b in range ( n ) : NEW_LINE INDENT c = n - ( a + b ) NEW_LINE if a + b > c and a + c > b and b + c > a : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT 
def slopeOfNum ( num , n ) : NEW_LINE INDENT slope = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if num [ i ] > num [ i - 1 ] and num [ i ] > num [ i + 1 ] : NEW_LINE INDENT slope += 1 NEW_LINE DEDENT elif num [ i ] < num [ i - 1 ] and num [ i ] < num [ i + 1 ] : NEW_LINE INDENT slope += 1 NEW_LINE DEDENT DEDENT return slope NEW_LINE DEDENT 
def middleOfThree ( a , b , c ) : NEW_LINE INDENT x = a - b NEW_LINE y = b - c NEW_LINE z = a - c NEW_LINE if x * y > 0 : NEW_LINE INDENT return b NEW_LINE DEDENT elif x * z > 0 : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT 
def countMaxSetBits ( left , right ) : NEW_LINE INDENT while ( left | ( left + 1 ) ) <= right : NEW_LINE INDENT left |= left + 1 NEW_LINE DEDENT return left NEW_LINE DEDENT 
def findS ( s ) : NEW_LINE INDENT l = 1 NEW_LINE r = ( s // 2 ) + 1 NEW_LINE while l <= r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE sum = mid * ( mid + 1 ) // 2 NEW_LINE if sum == s : NEW_LINE INDENT return mid NEW_LINE DEDENT elif sum > s : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT 
def check ( s ) : NEW_LINE INDENT min_val = float ( 'inf' ) NEW_LINE max_val = float ( '-inf' ) NEW_LINE sum_val = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ascii_val = ord ( s [ i ] ) NEW_LINE if ascii_val < 96 or ascii_val > 122 : NEW_LINE INDENT return False NEW_LINE DEDENT sum_val += ascii_val NEW_LINE if min_val > ascii_val : NEW_LINE INDENT min_val = ascii_val NEW_LINE DEDENT if max_val < ascii_val : NEW_LINE INDENT max_val = ascii_val NEW_LINE DEDENT DEDENT min_val -= 1 NEW_LINE expected_sum = max_val * ( max_val + 1 ) / 2 - min_val * ( min_val + 1 ) / 2 NEW_LINE return sum_val == expected_sum NEW_LINE DEDENT 
def minimumPossibleProduct ( k ) : NEW_LINE INDENT res = 1 NEW_LINE r = ( 1 << k ) - 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT res *= r - 1 NEW_LINE DEDENT res *= r NEW_LINE return res NEW_LINE DEDENT 
def findInGrid ( i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return i * i - ( i - 1 ) NEW_LINE DEDENT elif i > j : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT return i * i - ( j - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( i - 1 ) * ( i - 1 ) + 1 + ( j - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if j % 2 == 0 : NEW_LINE INDENT return ( j - 1 ) * ( j - 1 ) + 1 + ( i - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return j * j - ( i - 1 ) NEW_LINE DEDENT DEDENT DEDENT 
def findMinOperationsReqEmpStr ( s ) : NEW_LINE INDENT cntOne = 0 NEW_LINE cntZero = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT if cntOne != 0 : NEW_LINE INDENT cntOne -= 1 NEW_LINE DEDENT cntZero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if cntZero != 0 : NEW_LINE INDENT cntZero -= 1 NEW_LINE DEDENT cntOne += 1 NEW_LINE DEDENT DEDENT return cntOne + cntZero NEW_LINE DEDENT 
def isReachable ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT while x2 > x1 and y2 > y1 : NEW_LINE INDENT if x2 > y2 : NEW_LINE INDENT x2 %= y2 NEW_LINE DEDENT else : NEW_LINE INDENT y2 %= x2 NEW_LINE DEDENT DEDENT if x2 == x1 : NEW_LINE INDENT return ( y2 - y1 ) >= 0 and ( y2 - y1 ) % x1 == 0 NEW_LINE DEDENT elif y2 == y1 : NEW_LINE INDENT return ( x2 - x1 ) >= 0 and ( x2 - x1 ) % y1 == 0 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT 
def find_max_soln ( n , x , y ) : NEW_LINE INDENT ans = float ( "-inf" ) NEW_LINE for k in range ( n + 1 ) : NEW_LINE INDENT if k % x == y : NEW_LINE INDENT ans = max ( ans , k ) NEW_LINE DEDENT DEDENT return ans if ans >= 0 and ans <= n else - 1 NEW_LINE DEDENT 
def numberOfPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE j = n - 1 NEW_LINE while i < j : NEW_LINE INDENT if i + j == n : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT 
def minChanges ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE zeros = 0 NEW_LINE ones = 0 NEW_LINE if s [ 0 ] != '1' : NEW_LINE INDENT count += 1 NEW_LINE ones += 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT if zeros > ones : NEW_LINE INDENT zeros -= 1 NEW_LINE ones += 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT 
def kVisibleFromLeft ( n , k ) : NEW_LINE INDENT if n == k : NEW_LINE INDENT return 1 NEW_LINE DEDENT if k == 1 : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans *= i NEW_LINE DEDENT return ans NEW_LINE DEDENT return kVisibleFromLeft ( n - 1 , k - 1 ) + ( n - 1 ) * kVisibleFromLeft ( n - 1 , k ) NEW_LINE DEDENT 
def find ( n , sum ) : NEW_LINE INDENT if sum > 6 * n or sum < n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT if sum >= 1 and sum <= 6 : NEW_LINE INDENT return 1.0 / 6 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT s = 0 NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT s += find ( n - 1 , sum - i ) / 6 NEW_LINE DEDENT return s NEW_LINE DEDENT 
def binCoff ( n , r ) : NEW_LINE INDENT val = 1 NEW_LINE if r > n - r : NEW_LINE INDENT r = n - r NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT val *= n - i NEW_LINE val //= i + 1 NEW_LINE DEDENT return val NEW_LINE DEDENT 
def getMask ( val ) : NEW_LINE INDENT mask = 0 NEW_LINE if val == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT while val > 0 : NEW_LINE INDENT d = val % 10 NEW_LINE mask |= 1 << d NEW_LINE val = val // 10 NEW_LINE DEDENT return mask NEW_LINE DEDENT 
def ways_to_k_adjacent_set_bits ( n , k , currentIndex , adjacentSetBits , lastBit ) : NEW_LINE INDENT if currentIndex == n : NEW_LINE INDENT if adjacentSetBits == k : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT noOfWays = 0 NEW_LINE if lastBit == 1 : NEW_LINE INDENT noOfWays += ways_to_k_adjacent_set_bits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) NEW_LINE noOfWays += ways_to_k_adjacent_set_bits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) NEW_LINE DEDENT elif lastBit == 0 : NEW_LINE INDENT noOfWays += ways_to_k_adjacent_set_bits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) NEW_LINE noOfWays += ways_to_k_adjacent_set_bits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) NEW_LINE DEDENT return noOfWays NEW_LINE DEDENT 
def checkFunc ( i , j , st ) : NEW_LINE INDENT if st [ i ] == '(' and st [ j ] == ')' : NEW_LINE INDENT return 1 NEW_LINE DEDENT if st [ i ] == '(' and st [ j ] == '?' : NEW_LINE INDENT return 1 NEW_LINE DEDENT if st [ i ] == '?' and st [ j ] == ')' : NEW_LINE INDENT return 1 NEW_LINE DEDENT if st [ i ] == '[' and st [ j ] == ']' : NEW_LINE INDENT return 1 NEW_LINE DEDENT if st [ i ] == '[' and st [ j ] == '?' : NEW_LINE INDENT return 1 NEW_LINE DEDENT if st [ i ] == '?' and st [ j ] == ']' : NEW_LINE INDENT return 1 NEW_LINE DEDENT if st [ i ] == '{' and st [ j ] == '}' : NEW_LINE INDENT return 1 NEW_LINE DEDENT if st [ i ] == '{' and st [ j ] == '?' : NEW_LINE INDENT return 1 NEW_LINE DEDENT if st [ i ] == '?' and st [ j ] == '}' : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT 
def findGolomb ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 1 + findGolomb ( n - findGolomb ( findGolomb ( n - 1 ) ) ) NEW_LINE DEDENT 
def allOnes ( s , n ) : NEW_LINE INDENT co = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT co += 1 NEW_LINE DEDENT DEDENT return co == n NEW_LINE DEDENT 
def pad ( n ) : NEW_LINE INDENT pPrevPrev = 1 NEW_LINE pPrev = 1 NEW_LINE pCurr = 1 NEW_LINE pNext = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT pNext = pPrevPrev + pPrev NEW_LINE pPrevPrev = pPrev NEW_LINE pPrev = pCurr NEW_LINE pCurr = pNext NEW_LINE DEDENT return pNext NEW_LINE DEDENT 
def oddLengthPalindrome ( k ) : NEW_LINE INDENT palin = k NEW_LINE k = k // 10 NEW_LINE while k > 0 : NEW_LINE INDENT rev = k % 10 NEW_LINE palin = palin * 10 + rev NEW_LINE k = k // 10 NEW_LINE DEDENT return palin NEW_LINE DEDENT 
def changeString ( s0 ) : NEW_LINE INDENT s = list ( s0 ) NEW_LINE n = len ( s0 ) NEW_LINE if s [ 0 ] == '?' : NEW_LINE INDENT s [ 0 ] = 'a' NEW_LINE if s [ 0 ] == s [ 1 ] : NEW_LINE INDENT s [ 0 ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if s [ i ] == '?' : NEW_LINE INDENT s [ i ] = 'a' NEW_LINE if s [ i ] == s [ i - 1 ] : NEW_LINE INDENT s [ i ] += 1 NEW_LINE DEDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT s [ i ] += 1 NEW_LINE DEDENT if s [ i ] == s [ i - 1 ] : NEW_LINE INDENT s [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT if s [ n - 1 ] == '?' : NEW_LINE INDENT s [ n - 1 ] = 'a' NEW_LINE if s [ n - 1 ] == s [ n - 2 ] : NEW_LINE INDENT s [ n - 1 ] += 1 NEW_LINE DEDENT DEDENT return '' . join ( s ) NEW_LINE DEDENT 
def totalHammingDistance ( n ) : NEW_LINE INDENT i = 1 NEW_LINE sum = 0 NEW_LINE while n / i > 0 : NEW_LINE INDENT sum += n / i NEW_LINE i *= 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT 
def checkBitonic ( s ) : NEW_LINE INDENT i = 1 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if s [ i ] > s [ i - 1 ] : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] <= s [ i - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i == len ( s ) - 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT j = i + 1 NEW_LINE while j < len ( s ) : NEW_LINE INDENT if s [ j ] < s [ j - 1 ] : NEW_LINE INDENT j += 1 NEW_LINE continue NEW_LINE DEDENT if s [ j ] >= s [ j - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i = j NEW_LINE if i != len ( s ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT 
def endsWith ( str , pat ) : NEW_LINE INDENT patLen = len ( pat ) NEW_LINE strLen = len ( str ) NEW_LINE if patLen > strLen : NEW_LINE INDENT return False NEW_LINE DEDENT patLen -= 1 NEW_LINE strLen -= 1 NEW_LINE while patLen >= 0 : NEW_LINE INDENT if pat [ patLen ] != str [ strLen ] : NEW_LINE INDENT return False NEW_LINE DEDENT patLen -= 1 NEW_LINE strLen -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT 
def getSum ( n , d ) : NEW_LINE INDENT if n < d : NEW_LINE INDENT return 0 NEW_LINE DEDENT while n % 10 != d : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT k = n // 10 NEW_LINE return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) // 2 NEW_LINE DEDENT 
def balancedStringBySwapping ( s ) : NEW_LINE INDENT unbalancedPair = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if unbalancedPair > 0 and s [ i ] == ']' : NEW_LINE INDENT unbalancedPair -= 1 NEW_LINE DEDENT elif s [ i ] == '[' : NEW_LINE INDENT unbalancedPair += 1 NEW_LINE DEDENT DEDENT return ( unbalancedPair + 1 ) // 2 NEW_LINE DEDENT 
def computeHash ( s ) : NEW_LINE INDENT p = 31 NEW_LINE mod = int ( 1e9 ) + 7 NEW_LINE hashVal = 0 NEW_LINE mul = 1 NEW_LINE for ch in s : NEW_LINE INDENT hashVal = ( hashVal + ( ord ( ch ) - ord ( 'a' ) + 1 ) * mul ) % mod NEW_LINE mul = mul * p % mod NEW_LINE DEDENT return int ( hashVal ) NEW_LINE DEDENT 
def countOfSubstringWithOnlyOnes ( s ) : NEW_LINE INDENT res = 0 NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT count = count + 1 if s [ i ] == '1' else 0 NEW_LINE res = res + count NEW_LINE DEDENT return res NEW_LINE DEDENT 
def composite ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE c = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % j == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if c >= 3 : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT return flag NEW_LINE DEDENT 
def isDivBySix ( s , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ord ( s [ i ] ) - ord ( 'a' ) + 1 NEW_LINE DEDENT if sum % 3 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT lastDigit = ( ord ( s [ n - 1 ] ) - ord ( 'a' ) + 1 ) % 10 NEW_LINE if lastDigit % 2 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT 
def IsRedundantBraces ( s ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == '(' and s [ i + 2 ] == ')' : NEW_LINE INDENT return True NEW_LINE DEDENT if s [ i ] == '*' or s [ i ] == '+' or s [ i ] == '-' or s [ i ] == '/' : NEW_LINE INDENT a += 1 NEW_LINE DEDENT if s [ i ] == '(' : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT if b > a : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT 
def countSubStr ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while i < n - 2 : NEW_LINE INDENT if s [ i ] == '0' and s [ i + 1 ] == '1' and s [ i + 2 ] == '0' : NEW_LINE INDENT count += 1 NEW_LINE i += 3 NEW_LINE DEDENT elif s [ i ] == '1' and s [ i + 1 ] == '0' and s [ i + 2 ] == '1' : NEW_LINE INDENT count += 1 NEW_LINE i += 3 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT 
def prefix_occurrences ( s ) : NEW_LINE INDENT c = s [ 0 ] NEW_LINE count_c = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == c : NEW_LINE INDENT count_c += 1 NEW_LINE DEDENT DEDENT return count_c NEW_LINE DEDENT 
def isValid ( s , length ) : NEW_LINE INDENT for i in range ( 1 , length ) : NEW_LINE INDENT if s [ i ] == s [ i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def count ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE d = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d += ord ( s [ i ] ) NEW_LINE DEDENT if d % k == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT prev = ord ( s [ i - k ] ) NEW_LINE d -= prev NEW_LINE d += ord ( s [ i ] ) NEW_LINE if d % k == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT 
def findSubstringCount ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if ord ( s [ i ] ) + 1 == ord ( s [ i + 1 ] ) : NEW_LINE INDENT result += 1 NEW_LINE while i < n - 1 and ord ( s [ i ] ) + 1 == ord ( s [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT 
def find ( s1 , s2 ) : NEW_LINE INDENT len1 = len ( s1 ) NEW_LINE len2 = len ( s2 ) NEW_LINE if len1 != len2 : NEW_LINE INDENT return False NEW_LINE DEDENT d = [ 0 ] * len1 NEW_LINE d [ 0 ] = ord ( s2 [ 0 ] ) - ord ( s1 [ 0 ] ) NEW_LINE for i in range ( 1 , len1 ) : NEW_LINE INDENT if ord ( s1 [ i ] ) > ord ( s2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = ord ( s2 [ i ] ) - ord ( s1 [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len1 - 1 ) : NEW_LINE INDENT if d [ i ] < d [ i + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def isInGivenBase ( s , bas ) : NEW_LINE INDENT if bas > 16 : NEW_LINE INDENT return False NEW_LINE DEDENT elif bas <= 10 : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if not ( s [ i ] >= '0' and s [ i ] < chr ( ord ( '0' ) + bas ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if not ( ( s [ i ] >= '0' and s [ i ] < chr ( ord ( '0' ) + bas ) ) or ( s [ i ] >= 'A' and s [ i ] < chr ( ord ( 'A' ) + bas - 10 ) ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT 
def countNonEmptySubstr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE return n * ( n + 1 ) // 2 NEW_LINE DEDENT 
def even_decimal_value ( s , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT decimal_value = 0 NEW_LINE power_of_2 = 1 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT decimal_value += ( int ( s [ k ] ) - 0 ) * power_of_2 NEW_LINE power_of_2 *= 2 NEW_LINE DEDENT if decimal_value % 2 == 0 : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT 
def calculate ( s ) : NEW_LINE INDENT ans = 6 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT for k in range ( 10 ) : NEW_LINE INDENT for l in range ( 10 ) : NEW_LINE INDENT for m in range ( 10 ) : NEW_LINE INDENT for n in range ( 10 ) : NEW_LINE INDENT if i + j + k == l + m + n : NEW_LINE INDENT c = 0 NEW_LINE if i != int ( s [ 0 ] ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if j != int ( s [ 1 ] ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if k != int ( s [ 2 ] ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if l != int ( s [ 3 ] ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if m != int ( s [ 4 ] ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if n != int ( s [ 5 ] ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if c < ans : NEW_LINE INDENT ans = c NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT 
def xorZero ( s ) : NEW_LINE INDENT oneCount = 0 NEW_LINE zeroCount = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT oneCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zeroCount += 1 NEW_LINE DEDENT DEDENT if oneCount % 2 == 0 : NEW_LINE INDENT return zeroCount NEW_LINE DEDENT return oneCount NEW_LINE DEDENT 
def evenLength ( n ) : NEW_LINE INDENT res = n NEW_LINE for j in range ( len ( n ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT res += n [ j ] NEW_LINE DEDENT return res NEW_LINE DEDENT 
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if s [ i ] == s [ j ] : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT 
def normalSlope ( a , b , x1 , y1 ) : NEW_LINE INDENT g = a / 2 NEW_LINE f = b / 2 NEW_LINE if g - x1 == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT slope = ( f - y1 ) / ( g - x1 ) NEW_LINE if slope == 0 : NEW_LINE INDENT return - 2 NEW_LINE DEDENT return slope NEW_LINE DEDENT 
def orthogonality ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT dsquare = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) NEW_LINE if dsquare == r1 * r1 + r2 * r2 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT 
def findAreaShaded ( a ) : NEW_LINE INDENT sqArea = a * a NEW_LINE semiCircleArea = 3.14 * ( a * a ) / 8 NEW_LINE shadedArea = 4 * semiCircleArea - sqArea NEW_LINE return shadedArea NEW_LINE DEDENT 
def factorial ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , a + b + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT for i in range ( 1 , a + 1 ) : NEW_LINE INDENT res = res // i NEW_LINE DEDENT for i in range ( 1 , b + 1 ) : NEW_LINE INDENT res = res // i NEW_LINE DEDENT return res NEW_LINE DEDENT 
def factorTree ( n ) : NEW_LINE INDENT height = 0 NEW_LINE while n > 1 : NEW_LINE INDENT flag = False NEW_LINE for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT n = n // i NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT height += 1 NEW_LINE if not flag : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return height NEW_LINE DEDENT 
def findIfPossible ( n , s , x ) : NEW_LINE INDENT if s >= x and s % 2 == x % 2 : NEW_LINE INDENT if n >= 3 : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT if s == x : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT else : NEW_LINE INDENT return "No" NEW_LINE DEDENT DEDENT if n == 2 : NEW_LINE INDENT c = ( s - x ) / 2 NEW_LINE a = c NEW_LINE b = c NEW_LINE a = a + x NEW_LINE if ( a ^ b ) == x : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT else : NEW_LINE INDENT return "No" NEW_LINE DEDENT DEDENT DEDENT return "No" NEW_LINE DEDENT 
def maximumTripletXor ( a , b , c ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 30 , - 1 , - 1 ) : NEW_LINE INDENT cur = 1 << i NEW_LINE if a >= cur : NEW_LINE INDENT ans += cur NEW_LINE a -= cur NEW_LINE DEDENT elif b >= cur : NEW_LINE INDENT ans += cur NEW_LINE b -= cur NEW_LINE DEDENT elif c >= cur : NEW_LINE INDENT ans += cur NEW_LINE c -= cur NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def itemType ( n ) : NEW_LINE INDENT count = 0 NEW_LINE day = 1 NEW_LINE while count + day * ( day + 1 ) // 2 < n : NEW_LINE INDENT count += day * ( day + 1 ) // 2 NEW_LINE day += 1 NEW_LINE DEDENT for type in range ( day , 0 , - 1 ) : NEW_LINE INDENT count += type NEW_LINE if count >= n : NEW_LINE INDENT return type NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT 
def maxGcdInRange ( l , r ) : NEW_LINE INDENT ans = 1 NEW_LINE for z in range ( r , 0 , - 1 ) : NEW_LINE INDENT if r // z - ( l - 1 ) // z > 1 : NEW_LINE INDENT ans = z NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def sum_of_digits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n != 0 : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT 
def isRepUnitNum ( n , b ) : NEW_LINE INDENT length = 0 NEW_LINE countOne = 0 NEW_LINE while n != 0 : NEW_LINE INDENT r = n % b NEW_LINE length += 1 NEW_LINE if r == 1 : NEW_LINE INDENT countOne += 1 NEW_LINE DEDENT n = n // b NEW_LINE DEDENT return countOne >= 3 and countOne == length NEW_LINE DEDENT 
def isStraightLineNum ( n ) : NEW_LINE INDENT if n <= 99 : NEW_LINE INDENT return False NEW_LINE DEDENT s = str ( n ) NEW_LINE d = int ( s [ 1 ] ) - int ( s [ 0 ] ) NEW_LINE for i in range ( 2 , len ( s ) ) : NEW_LINE INDENT if int ( s [ i ] ) - int ( s [ i - 1 ] ) != d : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def getCount ( d , n ) : NEW_LINE INDENT no = n // d NEW_LINE result = no NEW_LINE p = 2 NEW_LINE while p * p <= no : NEW_LINE INDENT if no % p == 0 : NEW_LINE INDENT while no % p == 0 : NEW_LINE INDENT no //= p NEW_LINE DEDENT result -= result // p NEW_LINE DEDENT p += 1 NEW_LINE DEDENT if no > 1 : NEW_LINE INDENT result -= result // no NEW_LINE DEDENT return result NEW_LINE DEDENT 
def isEvenParity ( x ) : NEW_LINE INDENT parity = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT if ( x % 2 == 1 ) : NEW_LINE INDENT parity += 1 NEW_LINE DEDENT x = x >> 1 NEW_LINE DEDENT if ( parity % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT 
def isPerfect ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if i * i != n : NEW_LINE INDENT sum = sum + i + n // i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT DEDENT if sum == n and n != 1 : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT 
def logAToBaseB ( a , b ) : NEW_LINE INDENT if a > b - 1 : NEW_LINE INDENT return 1 + logAToBaseB ( a // b , b ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT 
def usingBinarySearch ( start , end , n , s ) : NEW_LINE INDENT if start >= end : NEW_LINE INDENT return start NEW_LINE DEDENT mid = start + ( end - start ) // 2 NEW_LINE totalSum = n * ( n + 1 ) // 2 NEW_LINE midSum = mid * ( mid + 1 ) // 2 NEW_LINE if totalSum - midSum <= s : NEW_LINE INDENT return usingBinarySearch ( start , mid , n , s ) NEW_LINE DEDENT return usingBinarySearch ( mid + 1 , end , n , s ) NEW_LINE DEDENT 
def minInt ( s ) : NEW_LINE INDENT s1 = list ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s1 [ i ] >= '5' : NEW_LINE INDENT s1 [ i ] = chr ( ord ( '9' ) - ord ( s1 [ i ] ) + ord ( '0' ) ) NEW_LINE DEDENT DEDENT if s1 [ 0 ] == '0' : NEW_LINE INDENT s1 [ 0 ] = '9' NEW_LINE DEDENT return '' . join ( s1 ) NEW_LINE DEDENT 
def countTriplets ( a , b , c ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , a + 1 ) : NEW_LINE INDENT for j in range ( 1 , b + 1 ) : NEW_LINE INDENT for k in range ( 1 , c + 1 ) : NEW_LINE INDENT if i * k > j * j : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT 
def topsy_turvy ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == '2' or s [ i ] == '4' or s [ i ] == '5' or s [ i ] == '6' or s [ i ] == '7' or s [ i ] == '9' : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def sumOfLastDig ( n , m ) : NEW_LINE INDENT sum = 0 NEW_LINE k = n / m NEW_LINE arr = [ 0 ] * 10 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT arr [ i ] = m * ( i + 1 ) % 10 NEW_LINE sum += arr [ i ] NEW_LINE DEDENT rem = k % 10 NEW_LINE ans = k // 10 * sum NEW_LINE for i in range ( rem ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT 
def totalPay ( totalItems , priceOfOneItem , n , m ) : NEW_LINE INDENT freeItems = 0 NEW_LINE actual = 0 NEW_LINE freeItems = totalItems // ( n + m ) NEW_LINE actual = totalItems - freeItems NEW_LINE amount = actual * priceOfOneItem NEW_LINE return amount NEW_LINE DEDENT 
def minOperations ( x , y , p , q ) : NEW_LINE INDENT if y % x != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = y // x NEW_LINE a = 0 NEW_LINE while d % p == 0 : NEW_LINE INDENT d //= p NEW_LINE a += 1 NEW_LINE DEDENT b = 0 NEW_LINE while d % q == 0 : NEW_LINE INDENT d //= q NEW_LINE b += 1 NEW_LINE DEDENT if d != 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return a + b NEW_LINE DEDENT 
def isMersenne ( n ) : NEW_LINE INDENT while n != 0 : NEW_LINE INDENT r = n % 2 NEW_LINE if r == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT n //= 2 NEW_LINE DEDENT return True NEW_LINE DEDENT 
def findThirdDigit ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 if n & 1 else 6 NEW_LINE DEDENT 
def is_odd_length ( num ) : NEW_LINE INDENT count = 0 NEW_LINE while num > 0 : NEW_LINE INDENT num //= 10 NEW_LINE count += 1 NEW_LINE DEDENT if count % 2 != 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT 
def checkIsPossible ( l , r , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if i % k == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count > 1 NEW_LINE DEDENT 
def bytes ( kilobytes ) : NEW_LINE INDENT b = kilobytes * 1024 NEW_LINE return b NEW_LINE DEDENT 
def octahedral_num ( n ) : NEW_LINE INDENT return n * ( 2 * n * n + 1 ) // 3 NEW_LINE DEDENT 
def check_equal ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] != '1' and s [ i ] != '0' and s [ i ] != '8' : NEW_LINE INDENT return "No" NEW_LINE DEDENT DEDENT start = 0 NEW_LINE end = len ( s ) - 1 NEW_LINE while start < end : NEW_LINE INDENT if s [ start ] != s [ end ] : NEW_LINE INDENT return "No" NEW_LINE DEDENT start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT return "Yes" NEW_LINE DEDENT 
def is_undulating ( n ) : NEW_LINE INDENT if len ( n ) <= 2 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , len ( n ) ) : NEW_LINE INDENT if n [ i - 2 ] != n [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def firstDigit ( n ) : NEW_LINE INDENT while n >= 10 : NEW_LINE INDENT n //= 10 NEW_LINE DEDENT return n NEW_LINE DEDENT 
def count_digit ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 + count_digit ( n // 10 ) NEW_LINE DEDENT 
def isDivisibleBy5 ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE return int ( s [ n - 1 ] ) == 0 or int ( s [ n - 1 ] ) == 5 NEW_LINE DEDENT 
def inv ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE x0 = 0 NEW_LINE x1 = 1 NEW_LINE if m == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT while a > 1 : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if x1 < 0 : NEW_LINE INDENT x1 += m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT 
def onlyFirstAndLastAreSet ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return False NEW_LINE DEDENT return ( n - 1 ) & ( n - 2 ) == 0 NEW_LINE DEDENT 
def divide ( dividend , divisor ) : NEW_LINE INDENT sign = - 1 if ( dividend < 0 ) ^ ( divisor < 0 ) else 1 NEW_LINE dividend = abs ( dividend ) NEW_LINE divisor = abs ( divisor ) NEW_LINE quotient = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT if temp + ( divisor << i ) <= dividend : NEW_LINE INDENT temp += divisor << i NEW_LINE quotient |= 1 << i NEW_LINE DEDENT DEDENT if sign == - 1 : NEW_LINE INDENT quotient = - quotient NEW_LINE DEDENT return quotient NEW_LINE DEDENT 
def findProfession ( level , pos ) : NEW_LINE INDENT if level == 1 : NEW_LINE INDENT return 'e' NEW_LINE DEDENT if findProfession ( level - 1 , ( pos + 1 ) // 2 ) == 'd' : NEW_LINE INDENT return 'd' if pos % 2 != 0 else 'e' NEW_LINE DEDENT return 'e' if pos % 2 != 0 else 'd' NEW_LINE DEDENT 
