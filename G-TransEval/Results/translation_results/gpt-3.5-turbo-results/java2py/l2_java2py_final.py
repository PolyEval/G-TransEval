def hasCloseElements ( numbers , threshold ) : NEW_LINE INDENT for i in range ( len ( numbers ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( numbers ) ) : NEW_LINE INDENT distance = abs ( numbers [ i ] - numbers [ j ] ) NEW_LINE if distance < threshold : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT 
def truncateNumber ( number ) : NEW_LINE INDENT return number % 1.0 NEW_LINE DEDENT 
def belowZero ( operations ) : NEW_LINE INDENT balance = 0 NEW_LINE for op in operations : NEW_LINE INDENT balance += op NEW_LINE if balance < 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT 
def mean_absolute_deviation ( numbers ) : NEW_LINE INDENT sum_num = 0 NEW_LINE for num in numbers : NEW_LINE INDENT sum_num += num NEW_LINE DEDENT mean = sum_num / len ( numbers ) NEW_LINE sum_abs_diff = 0 NEW_LINE for num in numbers : NEW_LINE INDENT sum_abs_diff += abs ( num - mean ) NEW_LINE DEDENT return sum_abs_diff / len ( numbers ) NEW_LINE DEDENT 
def intersperse ( numbers , delimiter ) : NEW_LINE INDENT result = [ ] NEW_LINE if len ( numbers ) == 0 : NEW_LINE INDENT return result NEW_LINE DEDENT for i in range ( len ( numbers ) - 1 ) : NEW_LINE INDENT result . append ( numbers [ i ] ) NEW_LINE result . append ( delimiter ) NEW_LINE DEDENT result . append ( numbers [ - 1 ] ) NEW_LINE return result NEW_LINE DEDENT 
def sum_product ( numbers : List [ int ] ) -> List [ int ] : NEW_LINE INDENT sum_value = 0 NEW_LINE prod_value = 1 NEW_LINE for n in numbers : NEW_LINE INDENT sum_value += n NEW_LINE prod_value *= n NEW_LINE DEDENT return [ sum_value , prod_value ] NEW_LINE DEDENT 
def allPrefixes ( s ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( 1 , len ( s ) + 1 ) : NEW_LINE INDENT result . append ( s [ : i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT 
def parse_music ( music_string ) : NEW_LINE INDENT current = "" NEW_LINE result = [ ] NEW_LINE for i in range ( len ( music_string ) + 1 ) : NEW_LINE INDENT if i == len ( music_string ) or music_string [ i ] == ' ' : NEW_LINE INDENT if current == "o" : NEW_LINE INDENT result . append ( 4 ) NEW_LINE DEDENT if current == "o|" : NEW_LINE INDENT result . append ( 2 ) NEW_LINE DEDENT if current == ".|" : NEW_LINE INDENT result . append ( 1 ) NEW_LINE DEDENT current = "" NEW_LINE DEDENT else : NEW_LINE INDENT current += music_string [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def strlen ( s ) : NEW_LINE INDENT return len ( s ) NEW_LINE DEDENT 
def factorize ( n ) : NEW_LINE INDENT factors = [ ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT n //= i NEW_LINE factors . append ( i ) NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT return factors NEW_LINE DEDENT 
def concatenate ( strings ) : NEW_LINE INDENT result = "" NEW_LINE for s in strings : NEW_LINE INDENT result += s NEW_LINE DEDENT return result NEW_LINE DEDENT 
def getPositive ( l ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT if l [ i ] > 0 : NEW_LINE INDENT result . append ( l [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def sortEven ( l ) : NEW_LINE INDENT evens = [ ] NEW_LINE for i in range ( 0 , len ( l ) , 2 ) : NEW_LINE INDENT evens . append ( l [ i ] ) NEW_LINE DEDENT evens . sort ( ) NEW_LINE result = [ ] NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT result . append ( evens [ i // 2 ] ) NEW_LINE DEDENT if i % 2 == 1 : NEW_LINE INDENT result . append ( l [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT 
def decode_cyclic ( s ) : NEW_LINE INDENT output = "" NEW_LINE i = 0 NEW_LINE while i <= len ( s ) - 3 : NEW_LINE INDENT x = s [ i + 2 ] + s [ i : i + 2 ] NEW_LINE output += x NEW_LINE i += 3 NEW_LINE DEDENT return output + s [ i : ] NEW_LINE DEDENT 
def carRaceCollision ( n ) : NEW_LINE INDENT return int ( n ** 2 ) NEW_LINE DEDENT 
def incrList ( l ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in l : NEW_LINE INDENT result . append ( i + 1 ) NEW_LINE DEDENT return result NEW_LINE DEDENT 
def pairs_sum_to_zero ( l ) : NEW_LINE INDENT for i in range ( len ( l ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( l ) ) : NEW_LINE INDENT if l [ i ] + l [ j ] == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT 
def changeBase ( x , b ) : NEW_LINE INDENT ret = "" NEW_LINE while x > 0 : NEW_LINE INDENT ret = str ( x % b ) + ret NEW_LINE x //= b NEW_LINE DEDENT return ret NEW_LINE DEDENT 
def median ( l ) : NEW_LINE INDENT l . sort ( ) NEW_LINE if len ( l ) % 2 == 1 : NEW_LINE INDENT return l [ int ( len ( l ) / 2 ) ] NEW_LINE DEDENT return ( l [ int ( len ( l ) / 2 ) - 1 ] + l [ int ( len ( l ) / 2 ) ] ) / 2.0 NEW_LINE DEDENT 
def decodeShift ( s ) : NEW_LINE INDENT sb = "" NEW_LINE for ch in s : NEW_LINE INDENT w = chr ( ( ord ( ch ) + 21 - ord ( 'a' ) ) % 26 + ord ( 'a' ) ) NEW_LINE sb += w NEW_LINE DEDENT return sb NEW_LINE DEDENT 
def belowThreshold ( l , t ) : NEW_LINE INDENT for n in l : NEW_LINE INDENT if n >= t : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def correct_bracketing ( brackets ) : NEW_LINE INDENT depth = 0 NEW_LINE for b in brackets : NEW_LINE INDENT if b == '<' : NEW_LINE INDENT depth += 1 NEW_LINE DEDENT if b == '>' : NEW_LINE INDENT depth -= 1 NEW_LINE DEDENT if depth < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return depth == 0 NEW_LINE DEDENT 
def monotonic ( l ) : NEW_LINE INDENT incr = 0 NEW_LINE decr = 0 NEW_LINE for i in range ( 1 , len ( l ) ) : NEW_LINE INDENT if l [ i ] > l [ i - 1 ] : NEW_LINE INDENT incr = 1 NEW_LINE DEDENT if l [ i ] < l [ i - 1 ] : NEW_LINE INDENT decr = 1 NEW_LINE DEDENT DEDENT return incr + decr != 2 NEW_LINE DEDENT 
def derivative ( xs ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( 1 , len ( xs ) ) : NEW_LINE INDENT result . append ( i * xs [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT 
def vowelsCount ( s ) : NEW_LINE INDENT vowels = "aeiouAEIOU" NEW_LINE count = 0 NEW_LINE for ch in s : NEW_LINE INDENT if ch in vowels : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if s [ - 1 ] == 'y' or s [ - 1 ] == 'Y' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT 
def digitSum ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for c in s : NEW_LINE INDENT if c . isupper ( ) : NEW_LINE INDENT sum += ord ( c ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT 
def fruitDistribution ( s , n ) : NEW_LINE INDENT num1 = "" NEW_LINE num2 = "" NEW_LINE flag = False NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] . isdigit ( ) : NEW_LINE INDENT if not flag : NEW_LINE INDENT num1 += s [ i ] NEW_LINE DEDENT if flag : NEW_LINE INDENT num2 += s [ i ] NEW_LINE DEDENT DEDENT elif not flag and len ( num1 ) > 0 : NEW_LINE INDENT flag = True NEW_LINE DEDENT DEDENT return n - int ( num1 ) - int ( num2 ) NEW_LINE DEDENT 
def pluck ( arr ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT if len ( result ) == 0 : NEW_LINE INDENT result . append ( arr [ i ] ) NEW_LINE result . append ( i ) NEW_LINE DEDENT elif arr [ i ] < result [ 0 ] : NEW_LINE INDENT result [ 0 ] = arr [ i ] NEW_LINE result [ 1 ] = i NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT 
def strangeSortList ( lst ) : NEW_LINE INDENT res = [ ] NEW_LINE lst . sort ( ) NEW_LINE l = 0 NEW_LINE r = len ( lst ) - 1 NEW_LINE while l < r : NEW_LINE INDENT res . append ( lst [ l ] ) NEW_LINE l += 1 NEW_LINE res . append ( lst [ r ] ) NEW_LINE r -= 1 NEW_LINE DEDENT if l == r : NEW_LINE INDENT res . append ( lst [ l ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT 
def triangleArea ( a , b , c ) : NEW_LINE INDENT if a + b <= c or a + c <= b or b + c <= a : NEW_LINE INDENT return - 1 NEW_LINE DEDENT s = ( a + b + c ) / 2 NEW_LINE return math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) NEW_LINE DEDENT 
def willItFly ( q , w ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( q ) ) : NEW_LINE INDENT if q [ i ] != q [ len ( q ) - i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT sum += q [ i ] NEW_LINE DEDENT return sum <= w NEW_LINE DEDENT 
def is_cube ( a ) : NEW_LINE INDENT a = abs ( a ) NEW_LINE i = int ( round ( a ** ( 1 / 3 ) ) ) NEW_LINE return int ( i ** 3 ) == a NEW_LINE DEDENT 
def hexKey ( num ) : NEW_LINE INDENT key = "2357BD" NEW_LINE total = 0 NEW_LINE for c in num : NEW_LINE INDENT if c in key : NEW_LINE INDENT total += 1 NEW_LINE DEDENT DEDENT return total NEW_LINE DEDENT 
def decimalToBinary ( dec ) : NEW_LINE INDENT ans = "" NEW_LINE if dec != 0 : NEW_LINE INDENT while dec > 0 : NEW_LINE INDENT ans = str ( dec % 2 ) + ans NEW_LINE dec //= 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans += "0" NEW_LINE DEDENT return "db" + ans + "db" NEW_LINE DEDENT 
def primeLength ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE if l < 2 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , l ) : NEW_LINE INDENT if l % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def startsOneEnds ( n ) : NEW_LINE INDENT if n < 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return int ( 18 * 10 ** ( n - 2 ) ) NEW_LINE DEDENT 
def add ( lst ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , len ( lst ) , 2 ) : NEW_LINE INDENT if lst [ i ] % 2 == 0 : NEW_LINE INDENT sum += lst [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT 
def getRow ( lst , x ) : NEW_LINE INDENT coords = [ ] NEW_LINE for i in range ( len ( lst ) ) : NEW_LINE INDENT for j in range ( len ( lst [ i ] ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if lst [ i ] [ j ] == x : NEW_LINE INDENT coords . append ( [ i , j ] ) NEW_LINE DEDENT DEDENT DEDENT return coords NEW_LINE DEDENT 
def nextSmallest ( lst ) : NEW_LINE INDENT lst . sort ( ) NEW_LINE for i in range ( 1 , len ( lst ) ) : NEW_LINE INDENT if lst [ i ] != lst [ i - 1 ] : NEW_LINE INDENT return lst [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT 
def anyInt ( a , b , c ) : NEW_LINE INDENT if int ( a ) != a or int ( b ) != b or int ( c ) != c : NEW_LINE INDENT return False NEW_LINE DEDENT return a + b == c or a + c == b or b + c == a NEW_LINE DEDENT 
def countUpTo ( n ) : NEW_LINE INDENT primes = [ ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT isPrime = True NEW_LINE for j in range ( 2 , i ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT isPrime = False NEW_LINE break NEW_LINE DEDENT DEDENT if isPrime : NEW_LINE INDENT primes . append ( i ) NEW_LINE DEDENT DEDENT return primes NEW_LINE DEDENT 
def closestInteger ( value ) : NEW_LINE INDENT w = float ( value ) NEW_LINE return round ( w ) NEW_LINE DEDENT 
def makeAPile ( n ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT result . append ( n + 2 * i ) NEW_LINE DEDENT return result NEW_LINE DEDENT 
def wordStrings ( s ) : NEW_LINE INDENT current = '' NEW_LINE words = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i == len ( s ) or s [ i ] == ' ' or s [ i ] == ',' : NEW_LINE INDENT if len ( current ) > 0 : NEW_LINE INDENT words . append ( current ) NEW_LINE current = '' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT current += s [ i ] NEW_LINE DEDENT DEDENT return words NEW_LINE DEDENT 
def roundedAvg ( n , m ) : NEW_LINE INDENT if n > m : NEW_LINE INDENT return "-1" NEW_LINE DEDENT num = ( m + n ) // 2 NEW_LINE ret = "" NEW_LINE while num > 0 : NEW_LINE INDENT ret = str ( num % 2 ) + ret NEW_LINE num //= 2 NEW_LINE DEDENT return ret NEW_LINE DEDENT 
def uniqueDigits ( x ) : NEW_LINE INDENT digits = [ ] NEW_LINE for i in x : NEW_LINE INDENT isUnique = True NEW_LINE for c in str ( i ) : NEW_LINE INDENT if int ( c ) % 2 == 0 : NEW_LINE INDENT isUnique = False NEW_LINE break NEW_LINE DEDENT DEDENT if isUnique : NEW_LINE INDENT digits . append ( i ) NEW_LINE DEDENT DEDENT digits . sort ( ) NEW_LINE return digits NEW_LINE DEDENT 
def countNums ( arr ) : NEW_LINE INDENT num = 0 NEW_LINE for n in arr : NEW_LINE INDENT neg = - 1 if n < 0 else 1 NEW_LINE n = abs ( n ) NEW_LINE digits = [ ] NEW_LINE for c in str ( n ) : NEW_LINE INDENT digits . append ( int ( c ) ) NEW_LINE DEDENT digits [ 0 ] *= neg NEW_LINE sum = 0 NEW_LINE for d in digits : NEW_LINE INDENT sum += d NEW_LINE DEDENT if sum > 0 : NEW_LINE INDENT num += 1 NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT 
def move_one_ball ( arr ) : NEW_LINE INDENT if len ( arr ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT num = 0 NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT num += 1 NEW_LINE DEDENT DEDENT if arr [ - 1 ] > arr [ 0 ] : NEW_LINE INDENT num += 1 NEW_LINE DEDENT if num < 2 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT 
def exchange ( lst1 , lst2 ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for n in lst1 : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT for n in lst2 : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if even >= odd : NEW_LINE INDENT return "YES" NEW_LINE DEDENT return "NO" NEW_LINE DEDENT 
def oddCount ( lst ) : NEW_LINE INDENT results = [ ] NEW_LINE originalStr = "the number of odd elements in the string i of the input." NEW_LINE for s in lst : NEW_LINE INDENT sum = 0 NEW_LINE for d in s : NEW_LINE INDENT if d . isdigit ( ) and int ( d ) % 2 == 1 : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT DEDENT result = "" NEW_LINE for c in originalStr : NEW_LINE INDENT if c == 'i' : NEW_LINE INDENT result += str ( sum ) NEW_LINE DEDENT else : NEW_LINE INDENT result += c NEW_LINE DEDENT DEDENT results . append ( result ) NEW_LINE DEDENT return results NEW_LINE DEDENT 
def minSubArraySum ( nums ) : NEW_LINE INDENT minSum = float ( 'inf' ) NEW_LINE sum = 0 NEW_LINE for num in nums : NEW_LINE INDENT sum += num NEW_LINE if minSum > sum : NEW_LINE INDENT minSum = sum NEW_LINE DEDENT if sum > 0 : NEW_LINE INDENT sum = 0 NEW_LINE DEDENT DEDENT return minSum NEW_LINE DEDENT 
def maxFill ( grid , capacity ) : NEW_LINE INDENT res = 0 NEW_LINE for well in grid : NEW_LINE INDENT sum = 0 NEW_LINE for n in well : NEW_LINE INDENT sum += n NEW_LINE DEDENT if sum > 0 : NEW_LINE INDENT res += ( sum - 1 ) // capacity + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT 
def select_words ( s , n ) : NEW_LINE INDENT vowels = "aeiouAEIOU" NEW_LINE current = "" NEW_LINE result = [ ] NEW_LINE consonant_num = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i == len ( s ) or s [ i ] == ' ' : NEW_LINE INDENT if consonant_num == n : NEW_LINE INDENT result . append ( current ) NEW_LINE DEDENT current = "" NEW_LINE consonant_num = 0 NEW_LINE DEDENT else : NEW_LINE INDENT current += s [ i ] NEW_LINE if s [ i ] not in vowels : NEW_LINE INDENT consonant_num += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT 
def solution ( lst ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , len ( lst ) , 2 ) : NEW_LINE INDENT if lst [ i ] % 2 == 1 : NEW_LINE INDENT sum += lst [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT 
def addElements ( arr , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if - 99 <= arr [ i ] <= 99 : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT 
def getOddCollatz ( n ) : NEW_LINE INDENT oddCollatz = [ ] NEW_LINE while n != 1 : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT oddCollatz . append ( n ) NEW_LINE n = n * 3 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT n //= 2 NEW_LINE DEDENT DEDENT oddCollatz . append ( 1 ) NEW_LINE oddCollatz . sort ( ) NEW_LINE return oddCollatz NEW_LINE DEDENT 
def isSorted ( lst ) : NEW_LINE INDENT for i in range ( 1 , len ( lst ) ) : NEW_LINE INDENT if lst [ i ] < lst [ i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT if i >= 2 and lst [ i ] == lst [ i - 1 ] and lst [ i ] == lst [ i - 2 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def intersection ( interval1 , interval2 ) : NEW_LINE INDENT inter1 = max ( interval1 [ 0 ] , interval2 [ 0 ] ) NEW_LINE inter2 = min ( interval1 [ 1 ] , interval2 [ 1 ] ) NEW_LINE l = inter2 - inter1 NEW_LINE if l < 2 : NEW_LINE INDENT return "NO" NEW_LINE DEDENT for i in range ( 2 , l ) : NEW_LINE INDENT if l % i == 0 : NEW_LINE INDENT return "NO" NEW_LINE DEDENT DEDENT return "YES" NEW_LINE DEDENT 
def prodSigns ( arr ) : NEW_LINE INDENT if len ( arr ) == 0 : NEW_LINE INDENT return - 32768 NEW_LINE DEDENT sum = 0 NEW_LINE prods = 1 NEW_LINE for i in arr : NEW_LINE INDENT sum += abs ( i ) NEW_LINE if i == 0 : NEW_LINE INDENT prods = 0 NEW_LINE DEDENT if i < 0 : NEW_LINE INDENT prods = - prods NEW_LINE DEDENT DEDENT return sum * prods NEW_LINE DEDENT 
def minPath ( grid , k ) : NEW_LINE INDENT n = len ( grid ) NEW_LINE minNum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if grid [ i ] [ j ] == 1 : NEW_LINE INDENT tmp = [ ] NEW_LINE if i != 0 : NEW_LINE INDENT tmp . append ( grid [ i - 1 ] [ j ] ) NEW_LINE DEDENT if j != 0 : NEW_LINE INDENT tmp . append ( grid [ i ] [ j - 1 ] ) NEW_LINE DEDENT if i != n - 1 : NEW_LINE INDENT tmp . append ( grid [ i + 1 ] [ j ] ) NEW_LINE DEDENT if j != n - 1 : NEW_LINE INDENT tmp . append ( grid [ i ] [ j + 1 ] ) NEW_LINE DEDENT minNum = min ( tmp ) NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( minNum ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT 
def digits ( n ) : NEW_LINE INDENT prod = 0 NEW_LINE for digit in str ( n ) : NEW_LINE INDENT if int ( digit ) % 2 == 1 : NEW_LINE INDENT if prod == 0 : NEW_LINE INDENT prod = 1 NEW_LINE DEDENT prod *= int ( digit ) NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT 
def isNested ( s ) : NEW_LINE INDENT count = 0 NEW_LINE maxCount = 0 NEW_LINE for ch in s : NEW_LINE INDENT if ch == '[' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ch == ']' : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if count < 0 : NEW_LINE INDENT count = 0 NEW_LINE DEDENT if count > maxCount : NEW_LINE INDENT maxCount = count NEW_LINE DEDENT if count <= maxCount - 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT 
def sumSquares ( lst ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in lst : NEW_LINE INDENT sum += math . ceil ( i ) * math . ceil ( i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT 
def canArrange ( arr ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] <= i : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT 
def largest_smallest_integers ( lst ) : NEW_LINE INDENT max_neg = 0 NEW_LINE min_pos = 0 NEW_LINE for n in lst : NEW_LINE INDENT if n < 0 and ( max_neg == 0 or n > max_neg ) : NEW_LINE INDENT max_neg = n NEW_LINE DEDENT if n > 0 and ( min_pos == 0 or n < min_pos ) : NEW_LINE INDENT min_pos = n NEW_LINE DEDENT DEDENT return [ max_neg , min_pos ] NEW_LINE DEDENT 
def fixSpaces ( text ) : NEW_LINE INDENT res = '' NEW_LINE spaceLen = 0 NEW_LINE for i in range ( len ( text ) ) : NEW_LINE INDENT if i == len ( text ) or text [ i ] != ' ' : NEW_LINE INDENT if spaceLen == 1 : NEW_LINE INDENT res += '_' NEW_LINE DEDENT if spaceLen == 2 : NEW_LINE INDENT res += '__' NEW_LINE DEDENT if spaceLen > 2 : NEW_LINE INDENT res += '-' NEW_LINE DEDENT spaceLen = 0 NEW_LINE if i != len ( text ) : NEW_LINE INDENT res += text [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT spaceLen += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT 
def filenameCheck ( fileName ) : NEW_LINE INDENT digitNum = 0 NEW_LINE dotNum = 0 NEW_LINE if len ( fileName ) < 5 or not fileName [ 0 ] . isalpha ( ) : NEW_LINE INDENT return "No" NEW_LINE DEDENT suffix = fileName [ - 4 : ] NEW_LINE if suffix != ".txt" and suffix != ".exe" and suffix != ".dll" : NEW_LINE INDENT return "No" NEW_LINE DEDENT for c in fileName : NEW_LINE INDENT if c . isdigit ( ) : NEW_LINE INDENT digitNum += 1 NEW_LINE DEDENT if c == '.' : NEW_LINE INDENT dotNum += 1 NEW_LINE DEDENT DEDENT if digitNum > 3 or dotNum != 1 : NEW_LINE INDENT return "No" NEW_LINE DEDENT return "Yes" NEW_LINE DEDENT 
def sumSquares ( lst ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( lst ) ) : NEW_LINE INDENT if i % 3 == 0 : NEW_LINE INDENT sum += lst [ i ] * lst [ i ] NEW_LINE DEDENT elif i % 4 == 0 : NEW_LINE INDENT sum += lst [ i ] * lst [ i ] * lst [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += lst [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT 
def words_in_sentence ( sentence ) : NEW_LINE INDENT result = '' NEW_LINE current = '' NEW_LINE for i in range ( len ( sentence ) ) : NEW_LINE INDENT if i == len ( sentence ) or sentence [ i ] == ' ' : NEW_LINE INDENT is_prime = True NEW_LINE l = len ( current ) NEW_LINE if l < 2 : NEW_LINE INDENT is_prime = False NEW_LINE DEDENT for j in range ( 2 , l ) : NEW_LINE INDENT if l % j == 0 : NEW_LINE INDENT is_prime = False NEW_LINE break NEW_LINE DEDENT DEDENT if is_prime : NEW_LINE INDENT result += current + ' ' NEW_LINE DEDENT current = '' NEW_LINE DEDENT else : NEW_LINE INDENT current += sentence [ i ] NEW_LINE DEDENT DEDENT if len ( result ) > 0 : NEW_LINE INDENT result = result [ : - 1 ] NEW_LINE DEDENT return result NEW_LINE DEDENT 
def simplify ( x , n ) : NEW_LINE INDENT a , b , c , d = 0 , 0 , 0 , 0 NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT if x [ i ] == "/" : NEW_LINE INDENT a = int ( x [ : i ] ) NEW_LINE b = int ( x [ i + 1 : ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( n ) ) : NEW_LINE INDENT if n [ i ] == "/" : NEW_LINE INDENT c = int ( n [ : i ] ) NEW_LINE d = int ( n [ i + 1 : ] ) NEW_LINE DEDENT DEDENT return ( a * c ) % ( b * d ) == 0 NEW_LINE DEDENT 
def specialFilter ( nums ) : NEW_LINE INDENT count = 0 NEW_LINE for num in nums : NEW_LINE INDENT if num > 10 : NEW_LINE INDENT w = str ( num ) NEW_LINE if int ( w [ 0 ] ) % 2 == 1 and int ( w [ - 1 ] ) % 2 == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT 
def getMaxTriples ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr . append ( i * i - i + 1 ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] ) % 3 == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT 
def doubleTheDifference ( lst ) : NEW_LINE INDENT sum = 0 NEW_LINE for d in lst : NEW_LINE INDENT num = round ( d ) NEW_LINE if d == num : NEW_LINE INDENT if num > 0 and num % 2 == 1 : NEW_LINE INDENT sum += num * num NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT 
def compare ( game , guess ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( game ) ) : NEW_LINE INDENT result . append ( abs ( game [ i ] - guess [ i ] ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT 
def strongest_extension ( className , extensions ) : NEW_LINE INDENT strongest = "" NEW_LINE max_strength = float ( '-inf' ) NEW_LINE for extension in extensions : NEW_LINE INDENT strength = 0 NEW_LINE for chr in extension : NEW_LINE INDENT if chr . isupper ( ) : NEW_LINE INDENT strength += 1 NEW_LINE DEDENT if chr . islower ( ) : NEW_LINE INDENT strength -= 1 NEW_LINE DEDENT DEDENT if strength > max_strength : NEW_LINE INDENT max_strength = strength NEW_LINE strongest = extension NEW_LINE DEDENT DEDENT return className + '.' + strongest NEW_LINE DEDENT 
def intToMiniRoman ( number ) : NEW_LINE INDENT num = [ 1000 , 900 , 500 , 400 , 100 , 90 , 50 , 40 , 10 , 9 , 5 , 4 , 1 ] NEW_LINE sym = [ "m" , "cm" , "d" , "cd" , "c" , "xc" , "l" , "xl" , "x" , "ix" , "v" , "iv" , "i" ] NEW_LINE pos = 0 NEW_LINE res = '' NEW_LINE while number > 0 : NEW_LINE INDENT while number >= num [ pos ] : NEW_LINE INDENT res += sym [ pos ] NEW_LINE number -= num [ pos ] NEW_LINE DEDENT if number > 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT 
def eat ( number , need , remaining ) : NEW_LINE INDENT return [ number + remaining , 0 ] if need > remaining else [ number + need , remaining - need ] NEW_LINE DEDENT 
def doAlgebra ( ops , operands ) : NEW_LINE INDENT nums = list ( operands ) NEW_LINE currentOps = list ( ops ) NEW_LINE i = len ( currentOps ) - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if currentOps [ i ] == "**" : NEW_LINE INDENT nums [ i ] = nums [ i ] ** nums [ i + 1 ] NEW_LINE nums . pop ( i + 1 ) NEW_LINE currentOps . pop ( i ) NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( currentOps ) : NEW_LINE INDENT if currentOps [ i ] == "*" : NEW_LINE INDENT nums [ i ] = nums [ i ] * nums [ i + 1 ] NEW_LINE nums . pop ( i + 1 ) NEW_LINE currentOps . pop ( i ) NEW_LINE DEDENT elif currentOps [ i ] == "//" : NEW_LINE INDENT nums [ i ] = nums [ i ] // nums [ i + 1 ] NEW_LINE nums . pop ( i + 1 ) NEW_LINE currentOps . pop ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while i < len ( currentOps ) : NEW_LINE INDENT if currentOps [ i ] == "+" : NEW_LINE INDENT nums [ i ] = nums [ i ] + nums [ i + 1 ] NEW_LINE nums . pop ( i + 1 ) NEW_LINE currentOps . pop ( i ) NEW_LINE DEDENT elif currentOps [ i ] == "-" : NEW_LINE INDENT nums [ i ] = nums [ i ] - nums [ i + 1 ] NEW_LINE nums . pop ( i + 1 ) NEW_LINE currentOps . pop ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return nums [ 0 ] NEW_LINE DEDENT 
def generateIntegers ( a , b ) : NEW_LINE INDENT lower = max ( 2 , min ( a , b ) ) NEW_LINE upper = min ( 8 , max ( a , b ) ) NEW_LINE result = [ ] NEW_LINE for i in range ( lower , upper + 1 , 2 ) : NEW_LINE INDENT result . append ( i ) NEW_LINE DEDENT return result NEW_LINE DEDENT 
def isStepNum ( n ) : NEW_LINE INDENT prevDigit = - 1 NEW_LINE while n > 0 : NEW_LINE INDENT curDigit = n % 10 NEW_LINE if prevDigit != - 1 : NEW_LINE INDENT if abs ( curDigit - prevDigit ) != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n //= 10 NEW_LINE prevDigit = curDigit NEW_LINE DEDENT return True NEW_LINE DEDENT 
def numOfWays ( n , k ) : NEW_LINE INDENT p = 1 NEW_LINE if k % 2 != 0 : NEW_LINE INDENT p = - 1 NEW_LINE DEDENT return int ( ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ) NEW_LINE DEDENT 
def findDivisors ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n // i == i : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( i ) NEW_LINE v . append ( n // i ) NEW_LINE DEDENT DEDENT DEDENT return v NEW_LINE DEDENT 
def eggDrop ( n , k ) : NEW_LINE INDENT if k == 1 or k == 0 : NEW_LINE INDENT return k NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return k NEW_LINE DEDENT min_val = float ( "inf" ) NEW_LINE for x in range ( 1 , k + 1 ) : NEW_LINE INDENT res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) NEW_LINE if res < min_val : NEW_LINE INDENT min_val = res NEW_LINE DEDENT DEDENT return min_val + 1 NEW_LINE DEDENT 
def isPowerOfTwo ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return math . ceil ( math . log ( n , 2 ) ) == math . floor ( math . log ( n , 2 ) ) NEW_LINE DEDENT 
def shortestPalindrome ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l = i NEW_LINE r = i NEW_LINE ans1 = "" NEW_LINE ans2 = "" NEW_LINE while l >= 0 and r < n and s [ l ] == s [ r ] : NEW_LINE INDENT ans1 += s [ l ] NEW_LINE l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT l = i - 1 NEW_LINE r = i NEW_LINE while l >= 0 and r < n and s [ l ] == s [ r ] : NEW_LINE INDENT ans2 += s [ l ] NEW_LINE l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT v . append ( ans1 ) NEW_LINE v . append ( ans2 ) NEW_LINE DEDENT ans = v [ 0 ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if v [ i ] != "" : NEW_LINE INDENT if ans [ 0 ] >= v [ i ] [ 0 ] : NEW_LINE INDENT ans = v [ i ] NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT 
def minimumAdjacentDifference ( a , n , k ) : NEW_LINE INDENT minDiff = float ( 'inf' ) NEW_LINE for i in range ( 0 , k + 1 ) : NEW_LINE INDENT maxDiff = float ( '-inf' ) NEW_LINE for j in range ( 0 , n - k - 1 ) : NEW_LINE INDENT for p in range ( i , i + j + 1 ) : NEW_LINE INDENT maxDiff = max ( maxDiff , a [ p + 1 ] - a [ p ] ) NEW_LINE DEDENT DEDENT minDiff = min ( minDiff , maxDiff ) NEW_LINE DEDENT return minDiff NEW_LINE DEDENT 
def cal ( arr , mid ) : NEW_LINE INDENT chocolate = 0 NEW_LINE for i in arr : NEW_LINE INDENT if i >= mid : NEW_LINE INDENT chocolate += i - mid NEW_LINE DEDENT DEDENT return chocolate NEW_LINE DEDENT 
def check ( v , a , m ) : NEW_LINE INDENT tec = 0 NEW_LINE ans = 0 NEW_LINE b = [ 0 ] * ( len ( a ) + 3 ) NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT tec -= b [ i ] NEW_LINE if a [ i ] + tec < v : NEW_LINE INDENT mov = v - a [ i ] - tec NEW_LINE ans += mov NEW_LINE tec += mov NEW_LINE b [ i + 2 ] = mov NEW_LINE DEDENT DEDENT return ans <= m NEW_LINE DEDENT 
def largestNum ( arr ) : NEW_LINE INDENT res = 0 NEW_LINE arr . sort ( ) NEW_LINE l = 0 NEW_LINE r = len ( arr ) - 1 NEW_LINE while l < r : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if sum == 0 : NEW_LINE INDENT res = max ( res , max ( arr [ l ] , arr [ r ] ) ) NEW_LINE return res NEW_LINE DEDENT elif sum < 0 : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT 
def binarySearch ( p , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( p ) - 1 NEW_LINE index = - 1 NEW_LINE while i <= j : NEW_LINE INDENT mid = i + ( j - i ) // 2 NEW_LINE if p [ mid ] >= n : NEW_LINE INDENT index = mid NEW_LINE j = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = mid + 1 NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT 
def findMinLength ( arr ) : NEW_LINE INDENT index = len ( arr ) - 1 NEW_LINE while index > 0 and arr [ index ] >= arr [ index - 1 ] : NEW_LINE INDENT index -= 1 NEW_LINE DEDENT return index NEW_LINE DEDENT 
def minDigits ( n , k ) : NEW_LINE INDENT digitsNum = len ( str ( n ) ) NEW_LINE tempSum = 0 NEW_LINE temp = digitsNum NEW_LINE result = 0 NEW_LINE x , v = 0 , 0 NEW_LINE sum = 0 NEW_LINE num2 = n NEW_LINE while num2 != 0 : NEW_LINE INDENT sum += num2 % 10 NEW_LINE num2 //= 10 NEW_LINE DEDENT if sum <= k : NEW_LINE INDENT x = 0 NEW_LINE DEDENT else : NEW_LINE INDENT while temp > 0 : NEW_LINE INDENT v = n // ( 10 ** ( temp - 1 ) ) NEW_LINE tempSum += v % 10 NEW_LINE if tempSum >= k : NEW_LINE INDENT v //= 10 NEW_LINE v += 1 NEW_LINE result = v * ( 10 ** temp ) NEW_LINE break NEW_LINE DEDENT temp -= 1 NEW_LINE DEDENT x = result - n NEW_LINE DEDENT return x if x != 0 else - 1 NEW_LINE DEDENT 
def checkForPerfectSquare ( arr , i , j ) : NEW_LINE INDENT sum = 0 NEW_LINE for m in range ( i , j + 1 ) : NEW_LINE INDENT sum += arr [ m ] NEW_LINE DEDENT low = 0 NEW_LINE high = sum // 2 NEW_LINE while low <= high : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if mid * mid == sum : NEW_LINE INDENT return mid NEW_LINE DEDENT elif mid * mid > sum : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT 
def minFlips ( mat , s ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE m = len ( mat [ 0 ] ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if mat [ i ] [ j ] != int ( s [ i + j ] ) - 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT 
def constructTree ( n , edges ) : NEW_LINE INDENT adjl = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT adjl . append ( [ ] ) NEW_LINE DEDENT for e in edges : NEW_LINE INDENT u = e [ 0 ] NEW_LINE v = e [ 1 ] NEW_LINE adjl [ u ] . append ( v ) NEW_LINE adjl [ v ] . append ( u ) NEW_LINE DEDENT return adjl NEW_LINE DEDENT 
def findSumOfValues ( v , parent , valuesChildren ) : NEW_LINE INDENT curNode = v NEW_LINE sum = 0 NEW_LINE while curNode != - 1 : NEW_LINE INDENT sum += valuesChildren [ curNode ] NEW_LINE curNode = parent [ curNode ] NEW_LINE DEDENT return sum NEW_LINE DEDENT 
def getDistinct ( d , count ) : NEW_LINE INDENT num = 0 NEW_LINE count = int ( pow ( 10 , count - 1 ) ) NEW_LINE while ( count > 0 ) : NEW_LINE INDENT num += count * d NEW_LINE count //= 10 NEW_LINE DEDENT return num NEW_LINE DEDENT 
def isIncreasing ( arr ) : NEW_LINE INDENT for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT 
def minAdjSwaps ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE cntZero = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if mat [ i ] [ j ] == 0 : NEW_LINE INDENT cntZero [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT cntSwaps = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if cntZero [ i ] < ( n - i - 1 ) : NEW_LINE INDENT first = i NEW_LINE while first < n and cntZero [ first ] < ( n - i - 1 ) : NEW_LINE INDENT first += 1 NEW_LINE DEDENT if first == n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT while first > i : NEW_LINE INDENT cntZero [ first ] , cntZero [ first - 1 ] = cntZero [ first - 1 ] , cntZero [ first ] NEW_LINE first -= 1 NEW_LINE cntSwaps += 1 NEW_LINE DEDENT DEDENT DEDENT return cntSwaps NEW_LINE DEDENT 
def solve ( values , salary , mod ) : NEW_LINE INDENT ret = 1 NEW_LINE amt = 0 NEW_LINE values . sort ( ) NEW_LINE salary . sort ( ) NEW_LINE while len ( salary ) > 0 : NEW_LINE INDENT while len ( values ) > 0 and values [ - 1 ] >= salary [ - 1 ] : NEW_LINE INDENT amt += 1 NEW_LINE values . pop ( ) NEW_LINE DEDENT if amt == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ret *= amt NEW_LINE ret %= mod NEW_LINE salary . pop ( ) NEW_LINE DEDENT return ret NEW_LINE DEDENT 
def organizeInOrder ( vec , op , n ) : NEW_LINE INDENT result = [ 0 ] * n NEW_LINE vec . sort ( ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE k = 0 NEW_LINE while i <= j and k <= n - 2 : NEW_LINE INDENT if op [ k ] == '<' : NEW_LINE INDENT result [ k ] = vec [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result [ k ] = vec [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT k += 1 NEW_LINE DEDENT result [ n - 1 ] = vec [ i ] NEW_LINE return result NEW_LINE DEDENT 
def countPoints ( n , m , a , b , x , y ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE j = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while j < m : NEW_LINE INDENT if a [ i ] + y < b [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT if b [ j ] >= a [ i ] - x and b [ j ] <= a [ i ] + y : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT 
def areSame ( a , b ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE return a == b NEW_LINE DEDENT 
def count_number_of_strings ( s ) : NEW_LINE INDENT n = len ( s ) - 1 NEW_LINE count = 2 ** n NEW_LINE return count NEW_LINE DEDENT 
def primePower ( x ) : NEW_LINE INDENT primePow = [ ] NEW_LINE i = 2 NEW_LINE while i * i <= x : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT p = 1 NEW_LINE while x % i == 0 : NEW_LINE INDENT x //= i NEW_LINE p *= i NEW_LINE DEDENT primePow . append ( p ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if x > 1 : NEW_LINE INDENT primePow . append ( x ) NEW_LINE DEDENT return primePow NEW_LINE DEDENT 
def isPerfect ( n0 ) : NEW_LINE INDENT n = math . sqrt ( n0 ) NEW_LINE if math . floor ( n ) != math . ceil ( n ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT 
def findSum ( l , r ) : NEW_LINE INDENT arr = [ ] NEW_LINE i = 0 NEW_LINE x = 2 NEW_LINE while i <= r : NEW_LINE INDENT arr . append ( i + x ) NEW_LINE if i + 1 <= r : NEW_LINE INDENT arr . append ( i + 1 + x ) NEW_LINE DEDENT x *= - 1 NEW_LINE i += 2 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT 
def results ( n , k ) : NEW_LINE INDENT return int ( round ( n ** ( 1 / ( 2 ** k ) ) ) ) NEW_LINE DEDENT 
def factors ( n ) : NEW_LINE INDENT v = [ 1 ] NEW_LINE for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT v . append ( i ) NEW_LINE if n // i != i : NEW_LINE INDENT v . append ( n // i ) NEW_LINE DEDENT DEDENT DEDENT return v NEW_LINE DEDENT 
def smallestNum ( n ) : NEW_LINE INDENT import math NEW_LINE x = math . pow ( 10 , ( n - 1 ) / 2.0 ) NEW_LINE return int ( math . ceil ( x ) ) NEW_LINE DEDENT 
def smallest ( s ) : NEW_LINE INDENT a = [ 0 ] * len ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT a [ i ] = int ( s [ i ] ) NEW_LINE DEDENT b = [ ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] % 2 != 0 : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT DEDENT b . sort ( ) NEW_LINE if len ( b ) > 1 : NEW_LINE INDENT return b [ 0 ] * 10 + b [ 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT 
def diagonals ( a , b , c , d ) : NEW_LINE INDENT ans = [ ] NEW_LINE ans . append ( ( a * c + b * d ) * ( a * d + b * c ) / ( a * b + c * d ) ** 0.5 ) NEW_LINE ans . append ( ( a * c + b * d ) * ( a * b + c * d ) / ( a * d + b * c ) ** 0.5 ) NEW_LINE return ans NEW_LINE DEDENT 
def findNumberOfDigits ( n , bas ) : NEW_LINE INDENT dig = int ( math . floor ( math . log ( n ) / math . log ( bas ) ) ) + 1 NEW_LINE return dig NEW_LINE DEDENT 
def nGon ( n ) : NEW_LINE INDENT import math NEW_LINE proAngleVar = 0.0 NEW_LINE if n % 4 == 0 : NEW_LINE INDENT proAngleVar = math . pi * ( 180.0 / n ) / 180 NEW_LINE DEDENT else : NEW_LINE INDENT proAngleVar = math . pi * ( 180.0 / ( 2 * n ) ) / 180 NEW_LINE DEDENT negX = 1.0e+99 NEW_LINE posX = - 1.0e+99 NEW_LINE negY = 1.0e+99 NEW_LINE posY = - 1.0e+99 NEW_LINE for j in range ( n ) : NEW_LINE INDENT px = math . cos ( 2 * math . pi * j / n + proAngleVar ) NEW_LINE py = math . sin ( 2 * math . pi * j / n + proAngleVar ) NEW_LINE negX = min ( negX , px ) NEW_LINE posX = max ( posX , px ) NEW_LINE negY = min ( negY , py ) NEW_LINE posY = max ( posY , py ) NEW_LINE DEDENT opt2 = max ( posX - negX , posY - negY ) NEW_LINE return opt2 / math . sin ( math . pi / n ) / 2 NEW_LINE DEDENT 
def findMaxK ( n ) : NEW_LINE INDENT p = int ( math . log ( n ) / math . log ( 2 ) ) NEW_LINE return int ( math . pow ( 2 , p ) ) NEW_LINE DEDENT 
def nth_fibo ( n ) : NEW_LINE INDENT a = ( 5 ** 0.5 + 1 ) / 2 NEW_LINE b = ( - 1 * ( 5 ** 0.5 ) + 1 ) / 2 NEW_LINE r = 5 ** 0.5 NEW_LINE ans = ( a ** n - b ** n ) / r NEW_LINE return int ( ans ) NEW_LINE DEDENT 
def findProb ( l , r ) : NEW_LINE INDENT import math NEW_LINE countOfPs = math . floor ( math . sqrt ( r ) ) - math . ceil ( math . sqrt ( l ) ) + 1 NEW_LINE total = r - l + 1 NEW_LINE prob = countOfPs / total NEW_LINE return prob NEW_LINE DEDENT 
def previousFibonacci ( n ) : NEW_LINE INDENT a = n / ( ( 1 + math . sqrt ( 5 ) ) / 2.0 ) NEW_LINE return int ( round ( a ) ) NEW_LINE DEDENT 
def distPrime ( arr , allPrimes ) : NEW_LINE INDENT list1 = [ ] NEW_LINE for i in allPrimes : NEW_LINE INDENT for j in arr : NEW_LINE INDENT if j % i == 0 : NEW_LINE INDENT list1 . append ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return list1 NEW_LINE DEDENT 
def getArray ( n ) : NEW_LINE INDENT ans = [ ] NEW_LINE p2 = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT ans . append ( p2 ) NEW_LINE DEDENT n >>= 1 NEW_LINE p2 *= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT 
def maximumLength ( a ) : NEW_LINE INDENT counts = [ 0 ] * 11 NEW_LINE ans = 0 NEW_LINE for index in range ( len ( a ) ) : NEW_LINE INDENT counts [ a [ index ] ] += 1 NEW_LINE k = [ ] NEW_LINE for i in counts : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT k . append ( i ) NEW_LINE DEDENT DEDENT k . sort ( ) NEW_LINE if len ( k ) == 1 or ( k [ 0 ] == k [ - 2 ] and k [ - 1 ] - k [ - 2 ] == 1 ) or ( k [ 0 ] == 1 and k [ 1 ] == k [ - 1 ] ) : NEW_LINE INDENT ans = index NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT 
def maxEdges ( n ) : NEW_LINE INDENT edges = int ( n * n // 4 ) NEW_LINE return edges NEW_LINE DEDENT 
def findK ( n , k ) : NEW_LINE INDENT a = [ ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT return a [ k - 1 ] NEW_LINE DEDENT 
def isKeith ( x , temp ) : NEW_LINE INDENT terms = [ ] NEW_LINE n = 0 NEW_LINE while temp > 0 : NEW_LINE INDENT terms . append ( temp % 10 ) NEW_LINE temp = temp // 10 NEW_LINE n += 1 NEW_LINE DEDENT terms . reverse ( ) NEW_LINE nextTerm = 0 NEW_LINE i = n NEW_LINE while nextTerm < x : NEW_LINE INDENT nextTerm = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT nextTerm += terms [ i - j ] NEW_LINE DEDENT terms . append ( nextTerm ) NEW_LINE i += 1 NEW_LINE DEDENT return nextTerm == x NEW_LINE DEDENT 
def factors ( n , k ) : NEW_LINE INDENT v = [ ] NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT v . append ( 2 ) NEW_LINE n = n // 2 NEW_LINE DEDENT if ( len ( v ) >= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 3 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE v . append ( i ) NEW_LINE DEDENT if ( len ( v ) >= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT v . append ( n ) NEW_LINE DEDENT if ( len ( v ) >= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT 
