double distinctOddRatio ( int [ ] numbers ) { Set < Integer > distinctNumbers = new HashSet < > ( ) ; for ( int number : numbers ) { distinctNumbers . add ( number ) ; } int distinctCount = distinctNumbers . size ( ) ; List < Integer > oddNumbers = new ArrayList < > ( ) ; for ( int number : distinctNumbers ) { if ( number % 2 == 1 ) { oddNumbers . add ( number ) ; } } int distinctOddCount = oddNumbers . size ( ) ; return ( double ) distinctOddCount / distinctCount ; } 
int compareSum ( int [ ] numbers , String [ ] words ) { int intSum = 0 ; for ( int n : numbers ) { intSum += n ; } int wordLengthSum = 0 ; for ( String w : words ) { wordLengthSum += w . length ( ) ; } if ( intSum < wordLengthSum ) { return - 1 ; } else if ( intSum > wordLengthSum ) { return 1 ; } else { return 0 ; } } 
boolean allLongerThan ( List < String > shortWords , List < String > longWords ) { int maxOfShort = Collections . max ( shortWords , Comparator . comparing ( String :: length ) ) . length ( ) ; int minOfLong = Collections . min ( longWords , Comparator . comparing ( String :: length ) ) . length ( ) ; return minOfLong > maxOfShort ; } 
int compareOddEvenRange ( int [ ] numbers ) { int [ ] oddNumbers = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . toArray ( ) ; int [ ] evenNumbers = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . toArray ( ) ; int rangeOdd = Arrays . stream ( oddNumbers ) . max ( ) . orElse ( 0 ) - Arrays . stream ( oddNumbers ) . min ( ) . orElse ( 0 ) ; int rangeEven = Arrays . stream ( evenNumbers ) . max ( ) . orElse ( 0 ) - Arrays . stream ( evenNumbers ) . min ( ) . orElse ( 0 ) ; if ( rangeOdd < rangeEven ) { return - 1 ; } if ( rangeOdd > rangeEven ) { return 1 ; } return 0 ; } 
double averageDistinctLength ( String [ ] words ) { HashSet < String > distinctWords = new HashSet < > ( Arrays . asList ( words ) ) ; double averageLen = distinctWords . size ( ) > 0 ? distinctWords . stream ( ) . mapToInt ( String :: length ) . average ( ) . getAsDouble ( ) : 0 ; return averageLen ; } 
int withdrawBalance ( int start , int [ ] withdrawals ) { int end = start ; for ( int i = 0 ; i < withdrawals . length ; i ++ ) { if ( withdrawals [ i ] <= end ) { end -= withdrawals [ i ] ; } } return end ; } 
String firstShortAndStartsWithO ( String [ ] words ) { String matchedElement = Arrays . stream ( words ) . filter ( w -> w . length ( ) < 5 ) . filter ( w -> w . charAt ( 0 ) == 'o' ) . findFirst ( ) . orElse ( "" ) ; return matchedElement ; } 
int bigNumberAtIndex ( int [ ] numbers , int index ) { int [ ] filteredNumbers = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . toArray ( ) ; return filteredNumbers [ index ] ; } 
boolean containsSquareInRange ( int rangeStart , int rangeLength ) { boolean containsSquare = IntStream . range ( rangeStart , rangeStart + rangeLength ) . mapToObj ( n -> Math . pow ( Math . floor ( Math . sqrt ( n ) ) , 2 ) == n ) . anyMatch ( Boolean . TRUE :: equals ) ; return containsSquare ; } 
Map < Integer , List < Integer > > groupNumbersByMod ( List < Integer > numbers , int mod ) { Map < Integer , List < Integer > > numberGroups = numbers . stream ( ) . reduce ( new HashMap < Integer , List < Integer > > ( ) , ( acc , n ) -> { int key = n % mod ; if ( acc . containsKey ( key ) ) { acc . get ( key ) . add ( n ) ; } else { List < Integer > newList = new ArrayList < > ( ) ; newList . add ( n ) ; acc . put ( key , newList ) ; } return acc ; } , ( acc1 , acc2 ) -> { acc1 . putAll ( acc2 ) ; return acc1 ; } ) ; return numberGroups ; } 
Map < Character , List < String > > groupNumbersByFirstChar ( List < String > words ) { Map < Character , List < String > > wordsGroups = words . stream ( ) . reduce ( new HashMap < Character , List < String > > ( ) , ( acc , w ) -> { char key = w . charAt ( 0 ) ; if ( acc . containsKey ( key ) ) { acc . get ( key ) . add ( w ) ; } else { acc . put ( key , new ArrayList < > ( Arrays . asList ( w ) ) ) ; } return acc ; } , ( acc1 , acc2 ) -> { acc2 . forEach ( ( key , value ) -> { if ( acc1 . containsKey ( key ) ) { acc1 . get ( key ) . addAll ( value ) ; } else { acc1 . put ( key , value ) ; } } ) ; return acc1 ; } ) ; return wordsGroups ; } 
String [ ] orderByLengthAndDescending ( String [ ] words ) { Arrays . sort ( words , ( a , b ) -> { if ( a . length ( ) != b . length ( ) ) { return a . length ( ) - b . length ( ) ; } else { return b . compareTo ( a ) ; } } ) ; return words ; } 
String [ ] orderFirstCharDescendingReverse ( String [ ] words ) { Arrays . sort ( words , ( a , b ) -> { if ( b . charAt ( 0 ) - a . charAt ( 0 ) != 0 ) { return b . charAt ( 0 ) - a . charAt ( 0 ) ; } else { return a . compareTo ( b ) ; } } ) ; Collections . reverse ( Arrays . asList ( words ) ) ; return words ; } 
ArrayList < Integer > getSubListOfNegative ( ArrayList < Integer > numbers , int start , int length ) { ArrayList < Integer > subList = new ArrayList < Integer > ( ) ; for ( int i = start ; i < numbers . size ( ) ; i ++ ) { if ( numbers . get ( i ) < 0 ) { subList . add ( numbers . get ( i ) ) ; if ( subList . size ( ) == length ) { break ; } } } return subList ; } 
ArrayList < Integer > getPositiveSequence ( ArrayList < Integer > numbers ) { ArrayList < Integer > subSequence = new ArrayList < > ( ) ; for ( int i = 0 ; i < numbers . size ( ) ; i ++ ) { if ( numbers . get ( i ) <= 0 ) { continue ; } subSequence = numbers . subList ( i , numbers . size ( ) ) ; break ; } for ( int i = 0 ; i < subSequence . size ( ) ; i ++ ) { if ( subSequence . get ( i ) > 0 ) { continue ; } subSequence = subSequence . subList ( 0 , i ) ; break ; } return subSequence ; } 
ArrayList < Integer > getLargerThanIndexSequence ( ArrayList < Integer > numbers ) { ArrayList < ArrayList < Integer > > subSequence = new ArrayList < ArrayList < Integer > > ( ) ; for ( int i = 0 ; i < numbers . size ( ) ; i ++ ) { ArrayList < Integer > sub = new ArrayList < Integer > ( ) ; sub . add ( numbers . get ( i ) ) ; sub . add ( i ) ; subSequence . add ( sub ) ; } for ( int i = 0 ; i < subSequence . size ( ) ; i ++ ) { if ( subSequence . get ( i ) . get ( 0 ) < subSequence . get ( i ) . get ( 1 ) ) { continue ; } subSequence = new ArrayList < ArrayList < Integer > > ( subSequence . subList ( i , subSequence . size ( ) ) ) ; break ; } for ( int i = 0 ; i < subSequence . size ( ) ; i ++ ) { if ( subSequence . get ( i ) . get ( 0 ) >= subSequence . get ( i ) . get ( 1 ) ) { continue ; } subSequence = new ArrayList < ArrayList < Integer > > ( subSequence . subList ( 0 , i ) ) ; } ArrayList < Integer > result = new ArrayList < Integer > ( ) ; for ( ArrayList < Integer > sub : subSequence ) { result . add ( sub . get ( 0 ) ) ; } return result ; } 
List < String > rearrangeWordByIndexes ( List < String > words , List < Integer > indexes ) { List < Integer > newIndexes = indexes . stream ( ) . filter ( n -> n >= words . size ( ) ) . map ( n -> n % words . size ( ) ) . collect ( Collectors . toList ( ) ) ; List < String > newWords = newIndexes . stream ( ) . map ( n -> words . get ( n ) ) . collect ( Collectors . toList ( ) ) ; return newWords ; } 
ArrayList < String [ ] > getWordsUpperLower ( ArrayList < String > words ) { ArrayList < String [ ] > upperLowerWords = new ArrayList < > ( ) ; for ( String w : words ) { upperLowerWords . add ( new String [ ] { w . toUpperCase ( ) , w . toLowerCase ( ) } ) ; } return upperLowerWords ; } 
boolean [ ] selectIfInPlace ( int [ ] numbers ) { boolean [ ] numsInPlace = new boolean [ numbers . length ] ; for ( int i = 0 ; i < numbers . length ; i ++ ) { numsInPlace [ i ] = numbers [ i ] == i ; } return numsInPlace ; } 
List < int [ ] > selectPairs ( int [ ] numbersA , int [ ] numbersB ) { List < int [ ] > pairs = new ArrayList < int [ ] > ( ) ; for ( int a : numbersA ) { for ( int b : numbersB ) { if ( a < b ) { pairs . add ( new int [ ] { a , b } ) ; } } } return pairs ; } 
List < String > stringCrossJoin ( List < String > endWords , List < String > beginWords ) { List < String > crossStrings = new ArrayList < > ( ) ; for ( String b : beginWords ) { for ( String e : endWords ) { if ( b . charAt ( 0 ) == e . charAt ( e . length ( ) - 1 ) ) { crossStrings . add ( e + " " + b ) ; } } } return crossStrings ; } 
int elementsContainSubword ( String [ ] words , String subword ) { if ( Arrays . stream ( words ) . limit ( 5 ) . allMatch ( w -> w . contains ( subword ) ) ) { return 1 ; } else if ( Arrays . stream ( words ) . limit ( 5 ) . anyMatch ( w -> w . contains ( subword ) ) ) { return 0 ; } else { return - 1 ; } } 
List < Integer > concatLargeNumbers ( List < Integer > numbersA , List < Integer > numbersB , int flag ) { List < Integer > allNumbers = new ArrayList < > ( ) ; for ( Integer n : numbersA ) { if ( n > flag ) { allNumbers . add ( n ) ; } } for ( Integer n : numbersB ) { if ( n > flag ) { allNumbers . add ( n ) ; } } return allNumbers ; } 
double dotProduct ( double [ ] vectorA , double [ ] vectorB ) { double dotProduct = 0 ; for ( int i = 0 ; i < vectorA . length ; i ++ ) { dotProduct += vectorA [ i ] * vectorB [ i ] ; } return dotProduct ; } 
List < Integer > setDifference ( List < Integer > setA , List < Integer > setB ) { List < Integer > temp = new ArrayList < Integer > ( ) ; temp . addAll ( setA ) ; temp . addAll ( setB ) ; List < Integer > difference = temp . stream ( ) . distinct ( ) . filter ( x -> ! setA . contains ( x ) || ! setB . contains ( x ) ) . sorted ( ) . collect ( Collectors . toList ( ) ) ; return difference ; } 
