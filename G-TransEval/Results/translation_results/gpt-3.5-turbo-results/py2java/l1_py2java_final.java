int greatest_common_divisor ( int a , int b ) { if ( a == 0 || b == 0 ) { return a + b ; } if ( a == b ) { return a ; } if ( a > b ) { return greatest_common_divisor ( a % b , b ) ; } else { return greatest_common_divisor ( a , b % a ) ; } } 
int largestDivisor ( int n ) { for ( int i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 ) { return n / i ; } } return 1 ; } 
boolean isPrime ( int n ) { if ( n < 2 ) { return false ; } for ( int k = 2 ; k < n ; k ++ ) { if ( n % k == 0 ) { return false ; } } return true ; } 
int fizz_buzz ( int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 11 == 0 || i % 13 == 0 ) { int q = i ; while ( q > 0 ) { if ( q % 10 == 7 ) { count ++ ; } q /= 10 ; } } } return count ; } 
int prime_fib ( int n ) { int f0 = 0 ; int f1 = 1 ; while ( n > 0 ) { int p = f0 + f1 ; boolean is_prime = p >= 2 ; for ( int i = 2 ; i < p ; i ++ ) { if ( p % i == 0 ) { is_prime = false ; break ; } } if ( is_prime ) { n -- ; } f0 = f1 ; f1 = p ; } return f1 ; } 
double triangle_area ( double a , double h ) { return a * h / 2 ; } 
int modp ( int n , int p ) { int ret = 1 ; for ( int i = 0 ; i < n ; i ++ ) { ret = ( ret * 2 ) % p ; } return ret ; } 
int add ( int x , int y ) { return x + y ; } 
int fib ( int n ) { if ( n == 0 ) { return 0 ; } if ( n == 1 ) { return 1 ; } return fib ( n - 1 ) + fib ( n - 2 ) ; } 
int largest_prime_factor ( int n ) { for ( int i = 2 ; i < n ; i ++ ) { while ( n % i == 0 && n > i ) { n /= i ; } } return n ; } 
class SumToN { int sum_to_n ( int n ) { int result = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { result += i ; } return result ; } 
int fibfib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; return fibfib ( n - 1 ) + fibfib ( n - 2 ) + fibfib ( n - 3 ) ; } 
boolean is_multiply_prime ( int a ) { int num = 0 ; for ( int i = 2 ; i <= a ; i ++ ) { while ( a % i == 0 && a >= i ) { a /= i ; num ++ ; } } return num == 3 ; } 
boolean is_simple_power ( int x , int n ) { if ( n == 1 ) { return x == 1 ; } int power = 1 ; while ( power < x ) { power *= n ; } return power == x ; } 
int choose_num ( int x , int y ) { if ( x > y ) { return - 1 ; } if ( y % 2 == 0 ) { return y ; } if ( x == y ) { return - 1 ; } return y - 1 ; } 
boolean is_equal_to_sum_even ( int n ) { return n % 2 == 0 && n >= 8 ; } 
int specialFactorial ( int n ) { int fact = 1 ; int specialFact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { fact *= i ; specialFact *= fact ; } return specialFact ; } 
int x_or_y ( int n , int x , int y ) { boolean is_prime = n >= 2 ; for ( int i = 2 ; i < n ; i ++ ) { if ( n % i == 0 ) { is_prime = false ; break ; } } if ( is_prime ) { return x ; } else { return y ; } } 
boolean right_angle_triangle ( double a , double b , double c ) { return ( a * a == b * b + c * c ) || ( b * b == a * a + c * c ) || ( c * c == a * a + b * b ) ; } 
int fastPow ( int n , int k ) { if ( k == 0 ) { return 1 ; } int temp = fastPow ( n , k / 2 ) ; if ( k % 2 == 0 ) { return temp * temp ; } else { return n * temp * temp ; } } 
boolean is_palin ( String s ) { int l = s . length ( ) / 2 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( s . length ( ) - i - 1 ) ) { return false ; } } return true ; } 
int find_sum ( int n ) { int ans = 0 ; int temp = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! ( temp < n ) ) { break ; } temp = i - 1 ; int num = 1 ; while ( temp < n ) { if ( temp + i <= n ) { ans += i * num ; } else { ans += ( n - temp ) * num ; } temp += i ; num += 1 ; } } return ans ; } 
int getNextGap ( int gap ) { gap = ( int ) ( gap * 10 / 13 ) ; if ( gap < 1 ) { return 1 ; } return gap ; } 
int count_non_decreasing ( int n ) { int k = 10 ; int count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= k + i - 1 ; count /= i ; } return count ; } 
int power ( int x , int y ) { if ( y == 0 ) { return 1 ; } else if ( y % 2 == 0 ) { return power ( x , y / 2 ) * power ( x , y / 2 ) ; } else { return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; } } 
double power ( double x , int y ) { if ( y == 0 ) { return 1 ; } double temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) { return temp * temp ; } else { if ( y > 0 ) { return x * temp * temp ; } else { return temp * temp / x ; } } } 
int multiply ( int x , int y ) { if ( y == 0 ) { return 0 ; } if ( y > 0 ) { return x + multiply ( x , y - 1 ) ; } return - multiply ( x , - y ) ; } 
int smallest ( int x , int y , int z ) { if ( ! ( y / x != 0 ) ) { return y ; } else if ( ! ( y / z != 0 ) ) { return z ; } else if ( ! ( x / z != 0 ) ) { return x ; } } 
boolean is_power_of_four ( int n ) { if ( n == 0 ) { return false ; } while ( n != 1 ) { if ( n % 4 != 0 ) { return false ; } n = n / 4 ; } return true ; } 
int mod_inverse ( int a , int m ) { int m0 = m ; int x0 = 0 ; int x1 = 1 ; if ( m == 1 ) { return 0 ; } while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) { x1 += m0 ; } return x1 ; } 
int cntRotations ( String s , int n ) { String s2 = s + s ; int [ ] pre = new int [ 2 * n ] ; for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( i != 0 ) { pre [ i ] += pre [ i - 1 ] ; } if ( s2 . charAt ( i ) == 'a' || s2 . charAt ( i ) == 'e' || s2 . charAt ( i ) == 'i' || s2 . charAt ( i ) == 'o' || s2 . charAt ( i ) == 'u' ) { pre [ i ] += 1 ; } } int ans = 0 ; for ( int i = n - 1 ; i < 2 * n - 1 ; i ++ ) { int r = i , l = i - n ; int x1 = pre [ r ] ; if ( l >= 0 ) { x1 -= pre [ l ] ; } r = i - n / 2 ; int left = pre [ r ] ; if ( l >= 0 ) { left -= pre [ l ] ; } int right = x1 - left ; if ( left > right ) { ans ++ ; } } return ans ; } 
int binomial_coeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) { k = n - k ; } for ( int i = 0 ; i < k ; i ++ ) { res *= n - i ; res /= i + 1 ; } return res ; } 
boolean is_prefix ( String temp , String s ) { if ( temp . length ( ) < s . length ( ) ) { return false ; } else { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != temp . charAt ( i ) ) { return false ; } } return true ; } } 
String lexicographically_smallest_string ( String s , int n ) { int last_ze = - 1 ; String ans = "" ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '0' ) { last_ze = i ; break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( i <= last_ze && s . charAt ( i ) == '0' ) { ans += s . charAt ( i ) ; } else if ( i > last_ze ) { ans += s . charAt ( i ) ; } } return ans ; } 
int calculate_max ( int n , int m , int k ) { int ans = - 1 ; int low = 0 , high = m ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int val = 0 ; int l = k - 1 ; int r = n - k ; val += mid ; if ( mid >= l ) { val += l * ( 2 * mid - l - 1 ) / 2 ; } else { val += mid * ( mid - 1 ) / 2 + ( l - mid ) ; } if ( mid >= r ) { val += r * ( 2 * mid - r - 1 ) / 2 ; } else { val += mid * ( mid - 1 ) / 2 + ( r - mid ) ; } if ( val <= m ) { ans = Math . max ( ans , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } return ans ; } 
int find_length ( String s , char i , char j ) { int required = i ; int length = 0 ; for ( char curr : s . toCharArray ( ) ) { if ( curr == required ) { length ++ ; } if ( required == i ) { required = j ; } else { required = i ; } } return length ; } 
boolean checkReverse ( int leftSum , int rightSum ) { int rev = 0 ; int temp = rightSum ; while ( temp != 0 ) { rev = rev * 10 + temp % 10 ; temp /= 10 ; } if ( rev == leftSum ) { return true ; } return false ; } 
boolean isComposite ( int n ) { if ( n <= 1 ) { return false ; } if ( n <= 3 ) { return false ; } if ( n % 2 == 0 || n % 3 == 0 ) { return true ; } for ( int i = 5 ; i <= n + 1 ; i += 6 ) { if ( i * i > n ) { break ; } if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return true ; } } return false ; } 
int minDeletion ( String s ) { int n = s . length ( ) ; int firstIdx1 = - 1 ; int lastIdx0 = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) { firstIdx1 = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '0' ) { lastIdx0 = i ; break ; } } if ( firstIdx1 == - 1 || lastIdx0 == - 1 ) { return 0 ; } int count1 = 0 ; int count0 = 0 ; for ( int i = 0 ; i < lastIdx0 ; i ++ ) { if ( s . charAt ( i ) == '1' ) { count1 ++ ; } } for ( int i = firstIdx1 + 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' ) { count0 ++ ; } } return Math . min ( count0 , count1 ) ; } 
int min_steps ( String s , int n ) { int cost = 0 ; int [ ] f = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int curr_ele = s . charAt ( i ) - 'a' ; int smaller = 0 ; for ( int j = 0 ; j <= curr_ele ; j ++ ) { if ( f [ j ] != 0 ) { smaller += f [ j ] ; } } if ( smaller == 0 ) { cost += i + 1 ; } else { cost += i - smaller + 1 ; } f [ s . charAt ( i ) - 'a' ] += 1 ; } return cost ; } 
int numberOfWays ( int n ) { int count = 0 ; for ( int a = 1 ; a < n ; a ++ ) { for ( int b = 1 ; b < n ; b ++ ) { int c = n - ( a + b ) ; if ( a < b + c && b < a + c && c < a + b ) { count ++ ; } } } return count ; } 
int slope_of_num ( int [ ] num , int n ) { int slope = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( num [ i ] > num [ i - 1 ] && num [ i ] > num [ i + 1 ] ) { slope += 1 ; } else if ( num [ i ] < num [ i - 1 ] && num [ i ] < num [ i + 1 ] ) { slope += 1 ; } } return slope ; } 
int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) { return b ; } else if ( x * z > 0 ) { return c ; } else { return a ; } } 
int count_max_set_bits ( int left , int right ) { while ( ( left | ( left + 1 ) ) <= right ) { left |= left + 1 ; } return left ; } 
int find_s ( int s ) { int l = 1 ; int r = s / 2 + 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; int sum = mid * ( mid + 1 ) / 2 ; if ( sum == s ) { return mid ; } else if ( sum > s ) { r = mid - 1 ; } else { l = mid + 1 ; } } return - 1 ; } 
boolean check ( String s ) { int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; int sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int ascii = ( int ) s . charAt ( i ) ; if ( ascii < 96 || ascii > 122 ) { return false ; } sum += ascii ; if ( min > ascii ) { min = ascii ; } if ( max < ascii ) { max = ascii ; } } min -- ; int e_sum = ( max * ( max + 1 ) / 2 ) - ( min * ( min + 1 ) / 2 ) ; return sum == e_sum ; } 
int minimum_possible_product ( int k ) { int res = 1 ; int r = ( 1 << k ) - 1 ; for ( int i = 0 ; i < k ; i ++ ) { res *= r - 1 ; } res *= r ; return res ; } 
int find_in_grid ( int i , int j ) { if ( i == j ) { return i * i - ( i - 1 ) ; } else if ( i > j ) { if ( i % 2 == 0 ) { return i * i - ( j - 1 ) ; } else { return ( i - 1 ) * ( i - 1 ) + 1 + ( j - 1 ) ; } } else { if ( j % 2 == 0 ) { return ( j - 1 ) * ( j - 1 ) + 1 + ( i - 1 ) ; } else { return j * j - ( i - 1 ) ; } } } 
int find_min_operations_req_emp_str ( String s ) { int cnt_one = 0 ; int cnt_zero = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' ) { if ( cnt_one > 0 ) { cnt_one = cnt_one - 1 ; cnt_zero = cnt_zero + 1 ; } else { if ( cnt_zero > 0 ) { cnt_zero = cnt_zero - 1 ; } cnt_one = cnt_one + 1 ; } } } return cnt_one + cnt_zero ; } 
boolean is_reachable ( int x1 , int y1 , int x2 , int y2 ) { while ( x2 > x1 && y2 > y1 ) { if ( x2 > y2 ) { x2 %= y2 ; } else { y2 %= x2 ; } } if ( x2 == x1 ) { return y2 - y1 >= 0 && ( y2 - y1 ) % x1 == 0 ; } else if ( y2 == y1 ) { return x2 - x1 >= 0 && ( x2 - x1 ) % y1 == 0 ; } else { return false ; } } 
int findMaxSoln ( int n , int x , int y ) { int ans = Integer . MIN_VALUE ; for ( int k = 0 ; k <= n ; k ++ ) { if ( k % x == y ) { ans = Math . max ( ans , k ) ; } } return ( ans >= 0 && ans <= n ) ? ans : - 1 ; } 
int numberOfPairs ( int n ) { int count = 0 ; int i = 1 ; int j = n - 1 ; while ( i < j ) { if ( ( i + j ) == n ) { count ++ ; } i ++ ; j -- ; } return count ; } 
int minChanges ( String s , int n ) { int count = 0 , zeros = 0 , ones = 0 ; if ( s . charAt ( 0 ) != '1' ) { count += 1 ; ones += 1 ; } for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' ) { zeros += 1 ; } else { ones += 1 ; } if ( zeros > ones ) { zeros -= 1 ; ones += 1 ; count += 1 ; } } return count ; } 
int k_visible_from_left ( int n , int k ) { if ( n == k ) { return 1 ; } if ( k == 1 ) { int ans = 1 ; for ( int i = 1 ; i < n ; i ++ ) { ans *= i ; } return ans ; } return k_visible_from_left ( n - 1 , k - 1 ) + ( n - 1 ) * k_visible_from_left ( n - 1 , k ) ; } 
double find ( int n , int sum ) { if ( sum > 6 * n || sum < n ) { return 0 ; } if ( n == 1 ) { if ( sum >= 1 && sum <= 6 ) { return 1.0 / 6 ; } else { return 0 ; } } double s = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { s += find ( n - 1 , sum - i ) / 6 ; } return s ; } 
int bin_coff ( int n , int r ) { int val = 1 ; if ( r > ( n - r ) ) { r = n - r ; } for ( int i = 0 ; i < r ; i ++ ) { val *= n - i ; val /= i + 1 ; } return val ; } 
int getMask ( int val ) { int mask = 0 ; if ( val == 0 ) { return 1 ; } while ( val != 0 ) { int d = val % 10 ; mask |= ( 1 << d ) ; val /= 10 ; } return mask ; } 
int ways_to_k_adjacent_set_bits ( int n , int k , int current_index , int adjacent_set_bits , int last_bit ) { if ( current_index == n ) { if ( adjacent_set_bits == k ) { return 1 ; } return 0 ; } int no_of_ways = 0 ; if ( last_bit == 1 ) { no_of_ways += ways_to_k_adjacent_set_bits ( n , k , current_index + 1 , adjacent_set_bits + 1 , 1 ) ; no_of_ways += ways_to_k_adjacent_set_bits ( n , k , current_index + 1 , adjacent_set_bits , 0 ) ; } else if ( last_bit != 1 ) { no_of_ways += ways_to_k_adjacent_set_bits ( n , k , current_index + 1 , adjacent_set_bits , 1 ) ; no_of_ways += ways_to_k_adjacent_set_bits ( n , k , current_index + 1 , adjacent_set_bits , 0 ) ; } return no_of_ways ; } 
int check_func ( int i , int j , String st ) { if ( st . charAt ( i ) == '(' && st . charAt ( j ) == ')' ) { return 1 ; } if ( st . charAt ( i ) == '(' && st . charAt ( j ) == '?' ) { return 1 ; } if ( st . charAt ( i ) == '?' && st . charAt ( j ) == ')' ) { return 1 ; } if ( st . charAt ( i ) == '[' && st . charAt ( j ) == ']' ) { return 1 ; } if ( st . charAt ( i ) == '[' && st . charAt ( j ) == '?' ) { return 1 ; } if ( st . charAt ( i ) == '?' && st . charAt ( j ) == ']' ) { return 1 ; } if ( st . charAt ( i ) == '{' && st . charAt ( j ) == '}' ) { return 1 ; } if ( st . charAt ( i ) == '{' && st . charAt ( j ) == '?' ) { return 1 ; } if ( st . charAt ( i ) == '?' && st . charAt ( j ) == '}' ) { return 1 ; } return 0 ; } 
int find_golomb ( int n ) { if ( n == 1 ) { return 1 ; } return 1 + find_golomb ( n - find_golomb ( find_golomb ( n - 1 ) ) ) ; } 
boolean allOnes ( String s , int n ) { int co = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { co += ( s . charAt ( i ) == '1' ) ? 1 : 0 ; } return co == n ; } 
int pad ( int n ) { int p_prev_prev = 1 ; int p_prev = 1 ; int p_curr = 1 ; int p_next = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { p_next = p_prev_prev + p_prev ; p_prev_prev = p_prev ; p_prev = p_curr ; p_curr = p_next ; } return p_next ; } 
int odd_length_palindrome ( int k ) { int palin = k ; k = k / 10 ; while ( k > 0 ) { int rev = k % 10 ; palin = palin * 10 + rev ; k = k / 10 ; } return palin ; } 
String changeString ( String s0 ) { char [ ] s = s0 . toCharArray ( ) ; int n = s0 . length ( ) ; if ( s [ 0 ] == '?' ) { s [ 0 ] = 'a' ; } if ( s [ 0 ] == s [ 1 ] ) { s [ 0 ] = ( char ) ( s [ 0 ] + 1 ) ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( s [ i ] == '?' ) { s [ i ] = 'a' ; } if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = ( char ) ( s [ i ] + 1 ) ; } if ( s [ i ] == s [ i + 1 ] ) { s [ i ] = ( char ) ( s [ i ] + 1 ) ; } if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = ( char ) ( s [ i ] + 1 ) ; } } if ( s [ n - 1 ] == '?' ) { s [ n - 1 ] = 'a' ; } if ( s [ n - 1 ] == s [ n - 2 ] ) { s [ n - 1 ] = ( char ) ( s [ n - 1 ] + 1 ) ; } return new String ( s ) ; } 
int totalHammingDistance ( int n ) { int i = 1 ; int sum = 0 ; while ( n / i > 0 ) { sum += n / i ; i *= 2 ; } return sum ; } 
int check_bitonic ( String s ) { int i = 1 ; for ( i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) > s . charAt ( i - 1 ) ) { continue ; } if ( s . charAt ( i ) <= s . charAt ( i - 1 ) ) { break ; } } if ( i == s . length ( ) - 1 ) { return 1 ; } int j = i + 1 ; for ( j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) < s . charAt ( j - 1 ) ) { continue ; } if ( s . charAt ( j ) >= s . charAt ( j - 1 ) ) { break ; } } i = j ; if ( i != s . length ( ) - 1 ) { return 0 ; } return 1 ; } 
boolean endsWith ( String str , String pat ) { int pat_len = pat . length ( ) ; int str_len = str . length ( ) ; if ( pat_len > str_len ) { return false ; } pat_len -- ; str_len -- ; while ( pat_len >= 0 ) { if ( pat . charAt ( pat_len ) != str . charAt ( str_len ) ) { return false ; } pat_len -- ; str_len -- ; } return true ; } 
int getSum ( int n , int d ) { if ( n < d ) { return 0 ; } while ( n % 10 != d ) { n -- ; } int k = n / 10 ; return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ; } 
int balancedStringBySwapping ( String s ) { int unbalancedPair = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( unbalancedPair > 0 && s . charAt ( i ) == ']' ) { unbalancedPair -= 1 ; } else if ( s . charAt ( i ) == '[' ) { unbalancedPair += 1 ; } } return ( unbalancedPair + 1 ) / 2 ; } 
int computeHash ( String s ) { int p = 31 ; int mod = ( int ) Math . pow ( 10 , 9 ) + 7 ; int hash_val = 0 ; int mul = 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char ch = s . charAt ( i ) ; hash_val = ( hash_val + ( ch - 'a' + 1 ) * mul ) % mod ; mul = ( mul * p ) % mod ; } return hash_val ; } 
int count_of_substring_with_only_ones ( String s ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { count = s . charAt ( i ) == '1' ? count + 1 : 0 ; res += count ; } return res ; } 
int composite ( int n ) { int flag = 0 ; int c = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { if ( n % j == 0 ) { c ++ ; } } if ( c >= 3 ) { flag = 1 ; } return flag ; } 
boolean is_div_by_six ( String s , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += s . charAt ( i ) - 'a' + 1 ; } if ( sum % 3 != 0 ) { return false ; } int last_digit = ( s . charAt ( n - 1 ) - 'a' + 1 ) % 10 ; if ( last_digit % 2 != 0 ) { return false ; } return true ; } 
boolean is_redundant_braces ( String s ) { int a = 0 , b = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '(' && s . charAt ( i + 2 ) == ')' ) { return true ; } if ( s . charAt ( i ) == '*' || s . charAt ( i ) == '+' || s . charAt ( i ) == '-' || s . charAt ( i ) == '/' ) { a ++ ; } if ( s . charAt ( i ) == '(' ) { b ++ ; } } if ( b > a ) { return true ; } return false ; } 
int count_sub_str ( String s , int n ) { int count = 0 ; int i = 0 ; while ( i < ( n - 2 ) ) { if ( s . charAt ( i ) == '0' && s . charAt ( i + 1 ) == '1' && s . charAt ( i + 2 ) == '0' ) { count ++ ; i += 3 ; } else if ( s . charAt ( i ) == '1' && s . charAt ( i + 1 ) == '0' && s . charAt ( i + 2 ) == '1' ) { count ++ ; i += 3 ; } else { i ++ ; } } return count ; } 
int prefix_occurrences ( String s ) { char c = s . charAt ( 0 ) ; int count_c = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == c ) { count_c ++ ; } } return count_c ; } 
boolean isValid ( String s , int len ) { for ( int i = 1 ; i < len ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) { return false ; } } return true ; } 
int count ( String s , int k ) { int n = s . length ( ) ; int d = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d += s . charAt ( i ) ; if ( d % k == 0 ) { count ++ ; } } for ( int i = k ; i < n ; i ++ ) { int prev = s . charAt ( i - k ) ; d -= prev ; d += s . charAt ( i ) ; if ( d % k == 0 ) { count ++ ; } } return count ; } 
int findSubstringCount ( String s ) { int result = 0 ; int n = s . length ( ) ; int i = 0 ; while ( i < n - 1 ) { if ( ( int ) s . charAt ( i ) + 1 == ( int ) s . charAt ( i + 1 ) ) { result ++ ; while ( i < n - 1 && ( int ) s . charAt ( i ) + 1 == ( int ) s . charAt ( i + 1 ) ) { i ++ ; } } i ++ ; } return result ; } 
boolean find ( String s1 , String s2 ) { int len1 = s1 . length ( ) ; int len2 = s2 . length ( ) ; if ( len1 != len2 ) { return false ; } int [ ] d = new int [ len1 ] ; d [ 0 ] = s2 . charAt ( 0 ) - s1 . charAt ( 0 ) ; for ( int i = 1 ; i < len1 ; i ++ ) { if ( s1 . charAt ( i ) > s2 . charAt ( i ) ) { return false ; } else { d [ i ] = s2 . charAt ( i ) - s1 . charAt ( i ) ; } } for ( int i = 0 ; i < len1 - 1 ; i ++ ) { if ( d [ i ] < d [ i + 1 ] ) { return false ; } } return true ; } 
boolean is_in_given_base ( String s , int bas ) { if ( bas > 16 ) { return false ; } else if ( bas <= 10 ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! ( s . charAt ( i ) >= '0' && s . charAt ( i ) < ( '0' + bas ) ) ) { return false ; } } } else { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! ( ( s . charAt ( i ) >= '0' && s . charAt ( i ) < ( '0' + bas ) ) || ( s . charAt ( i ) >= 'A' && s . charAt ( i ) < ( 'A' + bas - 10 ) ) ) ) { return false ; } } } return true ; } 
int count_non_empty_substr ( String s ) { int n = s . length ( ) ; return n * ( n + 1 ) / 2 ; } 
int evenDecimalValue ( String s , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int decimalValue = 0 ; int powerOf2 = 1 ; for ( int k = i ; k <= j ; k ++ ) { decimalValue += ( int ) ( s . charAt ( k ) - '0' ) * powerOf2 ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) { result += 1 ; } } } return result ; } 
int calculate ( String s ) { int ans = 6 ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { for ( int k = 0 ; k < 10 ; k ++ ) { for ( int l = 0 ; l < 10 ; l ++ ) { for ( int m = 0 ; m < 10 ; m ++ ) { for ( int n = 0 ; n < 10 ; n ++ ) { if ( i + j + k == l + m + n ) { int c = 0 ; if ( i != s . charAt ( 0 ) - '0' ) { c += 1 ; } if ( j != s . charAt ( 1 ) - '0' ) { c += 1 ; } if ( k != s . charAt ( 2 ) - '0' ) { c += 1 ; } if ( l != s . charAt ( 3 ) - '0' ) { c += 1 ; } if ( m != s . charAt ( 4 ) - '0' ) { c += 1 ; } if ( n != s . charAt ( 5 ) - '0' ) { c += 1 ; } if ( c < ans ) { ans = c ; } } } } } } } } return ans ; } 
int xorZero ( String s ) { int one_count = 0 ; int zero_count = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) { one_count += 1 ; } else { zero_count += 1 ; } } if ( one_count % 2 == 0 ) { return zero_count ; } else { return one_count ; } } 
int even_length ( String n ) { int res = n . length ( ) ; for ( int j = n . length ( ) - 1 ; j >= 0 ; j -- ) { res += Integer . parseInt ( n . charAt ( j ) + "" ) ; } return res ; } 
int count_substring_with_equal_ends ( String s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { result = result + 1 ; } } } return result ; } 
double normal_slope ( double a , double b , double x1 , double y1 ) { double g = a / 2 ; double f = b / 2 ; if ( g - x1 == 0 ) { return - 1 ; } double slope = ( f - y1 ) / ( g - x1 ) ; if ( slope == 0 ) { return - 2 ; } return slope ; } 
boolean orthogonality ( double x1 , double y1 , double x2 , double y2 , double r1 , double r2 ) { double dsquare = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; if ( dsquare == r1 * r1 + r2 * r2 ) { return true ; } else { return false ; } } 
double find_area_shaded ( double a ) { double sq_area = a * a ; double semi_circle_area = ( 3.14 * ( a * a ) ) / 8 ; double shaded_area = 4 * semi_circle_area - sq_area ; return shaded_area ; } 
int factorial ( int a , int b ) { int res = 1 ; for ( int i = 1 ; i <= a + b ; i ++ ) { res *= i ; } for ( int i = 1 ; i <= a ; i ++ ) { res /= i ; } for ( int i = 1 ; i <= b ; i ++ ) { res /= i ; } return res ; } 
int factorTree ( int n ) { int height = 0 ; while ( n > 1 ) { boolean flag = false ; for ( int i = 2 ; i <= ( int ) Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { n = n / i ; flag = true ; break ; } } height ++ ; if ( ! flag ) { break ; } } return height ; } 
String findIfPossible ( int n , int s , int x ) { if ( s >= x && s % 2 == x % 2 ) { if ( n >= 3 ) { return "Yes" ; } if ( n == 1 ) { if ( s == x ) { return "Yes" ; } else { return "No" ; } } if ( n == 2 ) { int c = ( s - x ) / 2 ; int a = c ; int b = c ; a = a + x ; if ( ( a ^ b ) == x ) { return "Yes" ; } else { return "No" ; } } } return "No" ; } 
int maximum_triplet_xor ( int a , int b , int c ) { int ans = 0 ; for ( int i = 30 ; i >= 0 ; i -- ) { int cur = 1 << i ; if ( a >= cur ) { ans += cur ; a -= cur ; } else if ( b >= cur ) { ans += cur ; b -= cur ; } else if ( c >= cur ) { ans += cur ; c -= cur ; } } return ans ; } 
int item_type ( int n ) { int count = 0 ; int day = 1 ; while ( count + day * ( day + 1 ) / 2 < n ) { count += day * ( day + 1 ) / 2 ; day ++ ; } for ( int type = day ; type >= - 1 ; type -- ) { count += type ; if ( count >= n ) { return type ; } } return 0 ; } 
int max_gcd_in_range ( int l , int r ) { int ans = 1 ; for ( int z = r ; z > 0 ; z -- ) { if ( r / z - ( l - 1 ) / z > 1 ) { ans = z ; break ; } } return ans ; } 
int sum_of_digits ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += ( n % 10 ) ; n = n / 10 ; } return sum ; } 
boolean is_rep_unit_num ( int n , int b ) { int length = 0 ; int count_one = 0 ; while ( n != 0 ) { int r = n % b ; length += 1 ; if ( r == 1 ) { count_one += 1 ; } n = n / b ; } return ( count_one >= 3 ) && ( count_one == length ) ; } 
boolean is_straigh_line_num ( int n ) { if ( n <= 99 ) { return false ; } String s = Integer . toString ( n ) ; int d = s . charAt ( 1 ) - s . charAt ( 0 ) ; for ( int i = 2 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) - s . charAt ( i - 1 ) != d ) { return false ; } } return true ; } 
int get_count ( int d , int n ) { int no = n / d ; int result = no ; for ( int p = 2 ; p <= no ; p ++ ) { if ( p * p > no ) { break ; } if ( no % p == 0 ) { while ( no % p == 0 ) { no /= p ; } result -= result / p ; } } if ( no > 1 ) { result -= result / no ; } return result ; } 
boolean isEvenParity ( int x ) { int parity = 0 ; while ( x != 0 ) { if ( ( x & 1 ) != 0 ) { parity += 1 ; } x = x >> 1 ; } if ( parity % 2 == 0 ) { return true ; } else { return false ; } } 
int is_perfect ( int n ) { int sum = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i * i > n ) { break ; } if ( n % i == 0 ) { if ( i * i != n ) { sum = sum + i + n / i ; } else { sum = sum + i ; } } } if ( sum == n && n != 1 ) { return n ; } return 0 ; } 
double log_a_to_base_b ( double a , double b ) { if ( a <= 0 || b <= 0 || b == 1 ) { throw new IllegalArgumentException ( "Invalid input" ) ; //log is undefined for negative numbers, 0, and bases of 1  }  if(a < b){    return 0; //log of a to base b is undefined for a < b  }  if(a == b){    return 1; //log of a to base b is 1 if a = b  }  return 1 + log_a_to_base_b(Math.floorDiv(a,b), b); //recursive call to log_a_to_base_b using floor division in place of integer division} }  
int using_binary_search ( int start , int end , int n , int s ) { if ( start >= end ) { return start ; } int mid = start + ( end - start ) / 2 ; int total_sum = ( n * ( n + 1 ) ) / 2 ; int mid_sum = ( mid * ( mid + 1 ) ) / 2 ; if ( total_sum - mid_sum <= s ) { return using_binary_search ( start , mid , n , s ) ; } return using_binary_search ( mid + 1 , end , n , s ) ; } 
String minInt ( String s ) { char [ ] s1 = s . toCharArray ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( int ) s1 [ i ] >= ( int ) '5' ) { s1 [ i ] = ( char ) ( ( int ) '9' - ( int ) s1 [ i ] + ( int ) '0' ) ; } } if ( s1 [ 0 ] == '0' ) { s1 [ 0 ] = '9' ; } String result = new String ( s1 ) ; return result ; } 
int count_triplets ( int a , int b , int c ) { int ans = 0 ; for ( int i = 1 ; i <= a ; i ++ ) { for ( int j = 1 ; j <= b ; j ++ ) { for ( int k = 1 ; k <= c ; k ++ ) { if ( i * k > j * j ) { ans ++ ; } } } } return ans ; } 
boolean topsy_turvy ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '2' || s . charAt ( i ) == '4' || s . charAt ( i ) == '5' || s . charAt ( i ) == '6' || s . charAt ( i ) == '7' || s . charAt ( i ) == '9' ) { return false ; } } return true ; } 
int sum_of_last_dig ( int n , int m ) { int sum = 0 ; int k = n / m ; int [ ] arr = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { arr [ i ] = ( m * ( i + 1 ) ) % 10 ; sum += arr [ i ] ; } int rem = k % 10 ; int ans = ( k / 10 ) * sum ; for ( int i = 0 ; i < rem ; i ++ ) { ans += arr [ i ] ; } return ans ; } 
double total_pay ( int total_items , double price_of_one_item , int n , int m ) { int free_items = 0 ; double actual = 0 ; free_items = total_items / ( n + m ) ; actual = total_items - free_items ; double amount = actual * price_of_one_item ; return amount ; } 
int minOperations ( int x , int y , int p , int q ) { if ( y % x != 0 ) { return - 1 ; } int d = y / x ; int a = 0 ; while ( d % p == 0 ) { d /= p ; a ++ ; } int b = 0 ; while ( d % q == 0 ) { d /= q ; b ++ ; } if ( d != 1 ) { return - 1 ; } return a + b ; } 
boolean is_mersenne ( int n ) { while ( n != 0 ) { int r = n % 2 ; if ( r == 0 ) { return false ; } n /= 2 ; } return true ; } 
int find_third_digit ( int n ) { if ( n < 3 ) { return 0 ; } return ( n & 1 ) == 0 ? 6 : 1 ; } 
boolean is_odd_length ( int num ) { int count = 0 ; while ( num > 0 ) { num = num / 10 ; count ++ ; } if ( count % 2 != 0 ) { return true ; } else { return false ; } } 
boolean check_is_possible ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( i % k == 0 ) { count ++ ; } } return count > 1 ; } 
int bytes ( int kilobytes ) { int b = kilobytes * 1024 ; return b ; } 
int octahedral_num ( int n ) { return n * ( 2 * n * n + 1 ) / 3 ; } 
String checkEqual ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != '1' && s . charAt ( i ) != '0' && s . charAt ( i ) != '8' ) { return "No" ; } } int start = 0 ; int end = s . length ( ) - 1 ; while ( start < end ) { if ( s . charAt ( start ) != s . charAt ( end ) ) { return "No" ; } start ++ ; end -- ; } return "Yes" ; } 
boolean is_undulating ( String n ) { if ( n . length ( ) <= 2 ) { return false ; } for ( int i = 2 ; i < n . length ( ) ; i ++ ) { if ( n . charAt ( i - 2 ) != n . charAt ( i ) ) { return false ; } } return true ; } 
int first_digit ( int n ) { while ( n >= 10 ) { n /= 10 ; } return n ; } 
int countDigit ( int n ) { if ( n == 0 ) { return 0 ; } return 1 + countDigit ( n / 10 ) ; } 
boolean is_divisible_by_5 ( String s ) { int n = s . length ( ) ; return s . charAt ( n - 1 ) == '0' || s . charAt ( n - 1 ) == '5' ; } 
int inv ( int a , int m ) { int m0 = m ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) { return 0 ; } while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) { x1 = x1 + m0 ; } return x1 ; } 
boolean only_first_and_last_are_set ( int n ) { if ( n == 1 ) { return true ; } if ( n == 2 ) { return false ; } return ( ( n - 1 ) & ( n - 2 ) ) == 0 ; } 
int divide ( int dividend , int divisor ) { int sign = ( dividend < 0 ) ^ ( divisor < 0 ) ? - 1 : 1 ; dividend = Math . abs ( dividend ) ; divisor = Math . abs ( divisor ) ; int quotient = 0 ; int temp = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( temp + ( divisor << i ) <= dividend ) { temp += divisor << i ; quotient |= 1 << i ; } } if ( sign == - 1 ) { quotient = - quotient ; } return quotient ; } 
String find_profession ( int level , int pos ) { if ( level == 1 ) { return "e" ; } if ( find_profession ( level - 1 , ( pos + 1 ) / 2 ) . equals ( "d" ) ) { return ( pos % 2 == 0 ) ? "d" : "e" ; } else { return ( pos % 2 == 0 ) ? "e" : "d" ; } } 
