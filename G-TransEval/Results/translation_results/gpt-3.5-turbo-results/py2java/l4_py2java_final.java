double distinctOddRatio ( int [ ] numbers ) { Set < Integer > distinctNumbers = new HashSet < Integer > ( ) ; for ( int i : numbers ) { distinctNumbers . add ( i ) ; } int distinctCount = distinctNumbers . size ( ) ; List < Integer > oddNumbers = new ArrayList < Integer > ( ) ; for ( int i : distinctNumbers ) { if ( i % 2 == 1 ) { oddNumbers . add ( i ) ; } } int distinctOddCount = oddNumbers . size ( ) ; return ( double ) distinctOddCount / ( double ) distinctCount ; } 
int compare_sum ( int [ ] numbers , String [ ] words ) { int int_sum = 0 ; for ( int i = 0 ; i < numbers . length ; i ++ ) { int_sum += numbers [ i ] ; } int word_length_sum = 0 ; for ( int i = 0 ; i < words . length ; i ++ ) { word_length_sum += words [ i ] . length ( ) ; } if ( int_sum < word_length_sum ) { return - 1 ; } else if ( int_sum > word_length_sum ) { return 1 ; } else { return 0 ; } } 
boolean allLongerThan ( ArrayList < String > shortWords , ArrayList < String > longWords ) { int maxOfShort = shortWords . stream ( ) . mapToInt ( String :: length ) . max ( ) . getAsInt ( ) ; int minOfLong = longWords . stream ( ) . mapToInt ( String :: length ) . min ( ) . getAsInt ( ) ; return minOfLong > maxOfShort ; } 
int compareOddEvenRange ( int [ ] numbers ) { int rangeOdd = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . max ( ) . getAsInt ( ) - Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . min ( ) . getAsInt ( ) ; int rangeEven = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . max ( ) . getAsInt ( ) - Arrays . stream ( numbers ) . filter ( n -> n % 2 == 0 ) . min ( ) . getAsInt ( ) ; if ( rangeOdd < rangeEven ) { return - 1 ; } if ( rangeOdd > rangeEven ) { return 1 ; } return 0 ; } 
double averageDistinctLength ( String [ ] words ) { Set < String > distinctWords = new HashSet < > ( Arrays . asList ( words ) ) ; double averageLen = distinctWords . isEmpty ( ) ? 0 : distinctWords . stream ( ) . mapToInt ( String :: length ) . average ( ) . getAsDouble ( ) ; return averageLen ; } 
int withdrawBalance ( int start , int [ ] withdrawals ) { int end = start ; for ( int withdrawal : withdrawals ) { if ( withdrawal <= end ) { end -= withdrawal ; } } return end ; } 
String first_short_and_starts_with_o ( String [ ] words ) { String matched_element = "" ; for ( String w1 : words ) { if ( w1 . length ( ) < 5 && w1 . startsWith ( "o" ) ) { matched_element = w1 ; break ; } } return matched_element ; } 
int big_number_at_index ( int [ ] numbers , int index ) { int [ ] targetNum = Arrays . stream ( numbers ) . filter ( n -> n > 5 ) . toArray ( ) ; return targetNum [ index ] ; } 
boolean containsSquareInRange ( int rangeStart , int rangeLength ) { boolean containsSquare = false ; for ( int n = rangeStart ; n < rangeStart + rangeLength ; n ++ ) { if ( Math . sqrt ( n ) % 1 == 0 ) { containsSquare = true ; break ; } } return containsSquare ; } 
Map < Integer , List < Integer > > groupNumbersByMod ( int [ ] numbers , int mod ) { Map < Integer , List < Integer > > numberGroups = new HashMap < > ( ) ; int k ; List < Integer > g ; for ( int i = 0 ; i < numbers . length ; i += g . size ( ) ) { g = new ArrayList < > ( ) ; k = numbers [ i ] % mod ; for ( int j = i ; j < numbers . length && numbers [ j ] % mod == k ; j ++ ) { g . add ( numbers [ j ] ) ; } numberGroups . put ( k , numberGroups . getOrDefault ( k , new ArrayList < > ( ) ) . addAll ( g ) ) ; } return numberGroups ; } 
HashMap < Character , ArrayList < String > > groupWordsByFirstChar ( String [ ] words ) { HashMap < Character , ArrayList < String > > wordGroups = new HashMap < Character , ArrayList < String > > ( ) ; for ( Iterator < String > it = Arrays . asList ( words ) . iterator ( ) ; it . hasNext ( ) ; ) { String w = it . next ( ) ; char k = w . charAt ( 0 ) ; if ( wordGroups . containsKey ( k ) ) { wordGroups . get ( k ) . add ( w ) ; } else { wordGroups . put ( k , new ArrayList < String > ( Arrays . asList ( w ) ) ) ; } } return wordGroups ; } 
List < String > orderByLengthAndDescending ( List < String > words ) { List < String > sortedWords = words . stream ( ) . sorted ( ( w1 , w2 ) -> w2 . compareTo ( w1 ) ) . sorted ( Comparator . comparing ( String :: length ) ) . collect ( Collectors . toList ( ) ) ; return sortedWords ; } 
ArrayList < String > order_first_char_descending_reverse ( ArrayList < String > words ) { ArrayList < String > sorted_words = new ArrayList < String > ( ) ; sorted_words = words . stream ( ) . sorted ( ( w1 , w2 ) -> { if ( w1 . charAt ( 0 ) == w2 . charAt ( 0 ) ) return w2 . compareTo ( w1 ) ; else return Character . compare ( w2 . charAt ( 0 ) , w1 . charAt ( 0 ) ) ; } ) . collect ( Collectors . toCollection ( ArrayList < String > :: new ) ) ; return sorted_words ; } 
List < Integer > getSublistOfNegative ( List < Integer > numbers , int start , int length ) { List < Integer > subList = new ArrayList < > ( ) ; for ( int i = start ; i < numbers . size ( ) ; i ++ ) { if ( numbers . get ( i ) < 0 ) { subList . add ( numbers . get ( i ) ) ; } if ( subList . size ( ) == length ) { break ; } } return subList ; } 
ArrayList < Integer > getPositiveSequence ( Integer [ ] numbers ) { ArrayList < Integer > subSequence = new ArrayList < > ( ) ; int idx = 0 ; while ( idx < numbers . length && numbers [ idx ] <= 0 ) idx ++ ; while ( idx < numbers . length && numbers [ idx ] > 0 ) { subSequence . add ( numbers [ idx ] ) ; idx ++ ; } return subSequence ; } 
List < Integer > getLargerThanIndexSequence ( List < Integer > numbers ) { List < Integer > subSequence = new ArrayList < > ( ) ; for ( Pair < Integer , Integer > pair : Iterables . takewhile ( Iterables . filter ( Iterables . dropWhile ( Iterables . enumerate ( numbers ) , new Predicate < Pair < Integer , Integer > > ( ) { boolean applies ( Pair < Integer , Integer > x ) { return x . getSecond ( ) < x . getFirst ( ) ; } 
List < String > rearrangeWordByIndexes ( List < String > words , List < Integer > indexes ) { List < Integer > newIndexes = new ArrayList < Integer > ( ) ; for ( int n : indexes ) { if ( n >= words . size ( ) ) { newIndexes . add ( n % words . size ( ) ) ; } } List < String > newWords = new ArrayList < String > ( ) ; for ( int n : newIndexes ) { newWords . add ( words . get ( n ) ) ; } return newWords ; } 
String [ ] [ ] getWordsUpperLower ( String [ ] words ) { String [ ] [ ] upperLowerWords = new String [ words . length ] [ 2 ] ; for ( int i = 0 ; i < words . length ; i ++ ) { upperLowerWords [ i ] [ 0 ] = words [ i ] . toUpperCase ( ) ; upperLowerWords [ i ] [ 1 ] = words [ i ] . toLowerCase ( ) ; } return upperLowerWords ; } 
boolean [ ] select_if_in_place ( int [ ] numbers ) { boolean [ ] nums_in_place = new boolean [ numbers . length ] ; // initialize the array    for (int i = 0; i < numbers.length; i++) {        nums_in_place[i] = numbers[i] == i; // check if number is at its index    }    return nums_in_place;} } 
List < int [ ] > selectPairs ( int [ ] numbersA , int [ ] numbersB ) { List < int [ ] > pairs = new ArrayList < > ( ) ; for ( int a : numbersA ) { for ( int b : numbersB ) { if ( a < b ) { int [ ] pair = { a , b } ; pairs . add ( pair ) ; } } } return pairs ; } 
ArrayList < String > stringCrossJoin ( ArrayList < String > endWords , ArrayList < String > beginWords ) { ArrayList < String > crossStrings = new ArrayList < String > ( ) ; for ( String b : beginWords ) { for ( String e : endWords ) { if ( b . charAt ( 0 ) == e . charAt ( e . length ( ) - 1 ) ) crossStrings . add ( e + " " + b ) ; } } return crossStrings ; } 
int elements_contain_subword ( String [ ] words , String subword ) { if ( Arrays . stream ( words ) . limit ( 5 ) . allMatch ( w -> w . contains ( subword ) ) ) { return 1 ; } else if ( Arrays . stream ( words ) . limit ( 5 ) . anyMatch ( w -> w . contains ( subword ) ) ) { return 0 ; } else { return - 1 ; } } 
List < Integer > concatLargeNumbers ( List < Integer > numbers_a , List < Integer > numbers_b , int flag ) { List < Integer > allNumbers = new ArrayList < Integer > ( ) ; for ( int n : numbers_a ) { if ( n > flag ) { allNumbers . add ( n ) ; } } for ( int n : numbers_b ) { if ( n > flag ) { allNumbers . add ( n ) ; } } return allNumbers ; } 
double dotProduct ( double [ ] vector_a , double [ ] vector_b ) { double dot_product = 0 ; for ( int i = 0 ; i < vector_a . length ; i ++ ) { dot_product += vector_a [ i ] * vector_b [ i ] ; } return dot_product ; } 
ArrayList < Integer > setDifference ( HashSet < Integer > setA , HashSet < Integer > setB ) { ArrayList < Integer > difference = new ArrayList < Integer > ( setA ) ; difference . addAll ( setB ) ; HashSet < Integer > intersection = new HashSet < Integer > ( setA ) ; intersection . retainAll ( setB ) ; difference . removeAll ( intersection ) ; Collections . sort ( difference ) ; return difference ; } 
