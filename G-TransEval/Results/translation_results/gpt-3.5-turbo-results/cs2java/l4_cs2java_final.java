double distinctOddRatio ( List < Integer > numbers ) { int distinctCount = ( int ) numbers . stream ( ) . distinct ( ) . count ( ) ; int distinctOddCount = ( int ) numbers . stream ( ) . distinct ( ) . filter ( n -> n % 2 == 1 ) . count ( ) ; return ( double ) distinctOddCount / distinctCount ; } 
int compareSum ( List < Integer > numbers , List < String > words ) { int intSum = numbers . stream ( ) . mapToInt ( Integer :: intValue ) . sum ( ) ; int wordLengthSum = words . stream ( ) . mapToInt ( String :: length ) . sum ( ) ; if ( intSum < wordLengthSum ) { return - 1 ; } if ( intSum > wordLengthSum ) { return 1 ; } return 0 ; } 
boolean allLongerThan ( List < String > shortWords , List < String > longWords ) { int maxOfShort = Collections . max ( shortWords , Comparator . comparingInt ( String :: length ) ) . length ( ) ; int minOfLong = Collections . min ( longWords , Comparator . comparingInt ( String :: length ) ) . length ( ) ; return minOfLong > maxOfShort ; } 
int compareOddEvenRange ( List < Integer > numbers ) { int rangeOdd = Collections . max ( numbers . stream ( ) . filter ( n -> ( n % 2 ) == 1 ) . collect ( Collectors . toList ( ) ) ) - Collections . min ( numbers . stream ( ) . filter ( n -> ( n % 2 ) == 1 ) . collect ( Collectors . toList ( ) ) ) ; int rangeEven = Collections . max ( numbers . stream ( ) . filter ( n -> ( n % 2 ) == 0 ) . collect ( Collectors . toList ( ) ) ) - Collections . min ( numbers . stream ( ) . filter ( n -> ( n % 2 ) == 0 ) . collect ( Collectors . toList ( ) ) ) ; if ( rangeOdd < rangeEven ) { return - 1 ; } if ( rangeOdd > rangeEven ) { return 1 ; } return 0 ; } 
double averageDistinctLength ( List < String > words ) { double averageLen = words . stream ( ) . distinct ( ) . mapToDouble ( w -> w . length ( ) ) . average ( ) . orElse ( 0 ) ; return averageLen ; } 
int WithDrawBalance ( int start , List < Integer > withdrawals ) { int end = withdrawals . stream ( ) . reduce ( start , ( balance , nextWithdrawal ) -> nextWithdrawal <= balance ? balance - nextWithdrawal : balance ) ; return end ; } 
String firstShortAndStartsWithO ( List < String > words ) { String matchedElement = words . stream ( ) . filter ( w -> w . length ( ) < 5 ) . filter ( w -> w . charAt ( 0 ) == 'o' ) . findFirst ( ) . orElse ( "" ) ; return matchedElement ; } 
int bigNumberAtIndex ( List < Integer > numbers , int index ) { int targetNum = numbers . stream ( ) . filter ( n -> n > 5 ) . collect ( Collectors . toList ( ) ) . get ( index ) ; return targetNum ; } 
boolean containsSquareInRange ( int rangeStart , int rangeLength ) { boolean containsSquare = IntStream . range ( rangeStart , rangeStart + rangeLength ) . anyMatch ( n -> ( int ) Math . pow ( Math . sqrt ( n ) , 2 ) == n ) ; return containsSquare ; } 
Map < Integer , List < Integer > > groupNumbersByMod ( List < Integer > numbers , int mod ) { Map < Integer , List < Integer > > numberGroups = numbers . stream ( ) . collect ( Collectors . groupingBy ( n -> n % mod , Collectors . toList ( ) ) ) ; return numberGroups ; } 
Map < Character , List < String > > groupWordsByFirstChar ( List < String > words ) { Map < Character , List < String > > wordGroups = words . stream ( ) . collect ( Collectors . groupingBy ( w -> w . charAt ( 0 ) , Collectors . toList ( ) ) ) ; return wordGroups ; } 
List < String > orderByLengthAndDescending ( List < String > words ) { List < String > sortedWords = words . stream ( ) . sorted ( ( w1 , w2 ) -> { if ( w1 . length ( ) == w2 . length ( ) ) { return w2 . compareTo ( w1 ) ; } else { return Integer . compare ( w1 . length ( ) , w2 . length ( ) ) ; } } ) . collect ( Collectors . toList ( ) ) ; return sortedWords ; } 
List < String > orderFirstCharDescendingReverse ( List < String > words ) { List < String > sortedWords = words . stream ( ) . sorted ( Comparator . comparing ( String :: charAt ) . reversed ( ) . thenComparing ( String :: compareTo ) ) . collect ( Collectors . toList ( ) ) ; Collections . reverse ( sortedWords ) ; return sortedWords ; } 
List < Integer > getSubListOfNegative ( List < Integer > numbers , int start , int length ) { List < Integer > subList = numbers . subList ( start , numbers . size ( ) ) . stream ( ) . filter ( n -> n < 0 ) . limit ( length ) . collect ( Collectors . toList ( ) ) ; return subList ; } 
List < Integer > getPositiveSequence ( List < Integer > numbers ) { List < Integer > subSequence = numbers . stream ( ) . dropWhile ( n -> n <= 0 ) . takeWhile ( n -> n >= 0 ) . collect ( Collectors . toList ( ) ) ; return subSequence ; } 
List < Integer > getLargerThanIndexSequence ( List < Integer > numbers ) { List < Integer > subSequence = IntStream . range ( 0 , numbers . size ( ) ) . filter ( i -> numbers . get ( i ) >= i ) . map ( numbers :: get ) . collect ( Collectors . toList ( ) ) ; return subSequence ; } 
List < String > rearrangeWordByIndexes ( List < String > words , List < Integer > indexes ) { List < Integer > newIndexes = indexes . stream ( ) . filter ( n -> n >= words . size ( ) ) . map ( n -> n % words . size ( ) ) . collect ( Collectors . toList ( ) ) ; List < String > newWords = newIndexes . stream ( ) . map ( n -> words . get ( n ) ) . collect ( Collectors . toList ( ) ) ; return newWords ; } 
List < List < String > > getWordsUpperLower ( List < String > words ) { List < List < String > > upperLowerWords = words . stream ( ) . map ( w -> Arrays . asList ( w . toUpperCase ( ) , w . toLowerCase ( ) ) ) . collect ( Collectors . toList ( ) ) ; return upperLowerWords ; } 
List < Boolean > SelectIfInPlace ( List < Integer > numbers ) { List < Boolean > numsInPlace = numbers . stream ( ) . map ( num -> num . equals ( numbers . indexOf ( num ) ) ) . collect ( Collectors . toList ( ) ) ; return numsInPlace ; } 
List < List < Integer > > SelectPairs ( List < Integer > numbersA , List < Integer > numbersB ) { List < List < Integer > > pairs = numbersA . stream ( ) . flatMap ( a -> numbersB . stream ( ) . filter ( b -> a < b ) . map ( b -> Arrays . asList ( a , b ) ) ) . collect ( Collectors . toList ( ) ) ; return pairs ; } 
List < String > stringCrossJoin ( List < String > endWords , List < String > beginWords ) { List < String > crossStrings = beginWords . stream ( ) . flatMap ( b -> endWords . stream ( ) . filter ( e -> b . charAt ( 0 ) == e . charAt ( e . length ( ) - 1 ) ) . map ( e -> e + " " + b ) ) . collect ( Collectors . toList ( ) ) ; return crossStrings ; } 
int ElementsContainSubword ( List < String > words , String subword ) { if ( words . stream ( ) . limit ( 5 ) . allMatch ( w -> w . contains ( subword ) ) ) { return 1 ; } if ( words . stream ( ) . limit ( 5 ) . anyMatch ( w -> w . contains ( subword ) ) ) { return 0 ; } return - 1 ; } 
List < Integer > concatLargeNumbers ( List < Integer > numbersA , List < Integer > numbersB , int flag ) { List < Integer > allNumbers = new ArrayList < > ( ) ; for ( int i = 0 ; i < numbersA . size ( ) ; i ++ ) { if ( numbersA . get ( i ) > flag ) { allNumbers . add ( numbersA . get ( i ) ) ; } } for ( int i = 0 ; i < numbersB . size ( ) ; i ++ ) { if ( numbersB . get ( i ) > flag ) { allNumbers . add ( numbersB . get ( i ) ) ; } } return allNumbers ; } 
int dotProduct ( List < Integer > vectorA , List < Integer > vectorB ) { int dotProduct = IntStream . range ( 0 , vectorA . size ( ) ) . map ( i -> vectorA . get ( i ) * vectorB . get ( i ) ) . sum ( ) ; return dotProduct ; } 
List < Integer > setDifference ( List < Integer > setA , List < Integer > setB ) { List < Integer > difference = new ArrayList < > ( setA ) ; difference . addAll ( setB ) ; difference . removeAll ( setA . retainAll ( setB ) ) ; difference . sort ( null ) ; return difference ; } 
