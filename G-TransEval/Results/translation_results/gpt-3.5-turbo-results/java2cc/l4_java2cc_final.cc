double distinctOddRatio ( vector < int > numbers ) { unordered_set < int > distinct ( numbers . begin ( ) , numbers . end ( ) ) ; int distinctCount = distinct . size ( ) ; int distinctOddCount = count_if ( distinct . begin ( ) , distinct . end ( ) , [ ] ( int n ) { return n % 2 == 1 ; } ) ; return ( double ) distinctOddCount / distinctCount ; } 
int compareSum ( vector < int > numbers , vector < string > words ) { int intSum = accumulate ( numbers . begin ( ) , numbers . end ( ) , 0 ) ; int wordLengthSum = 0 ; for ( auto str : words ) { wordLengthSum += str . length ( ) ; } if ( intSum < wordLengthSum ) { return -1 ; } if ( intSum > wordLengthSum ) { return 1 ; } return 0 ; } 
bool allLongerThan ( vector < string > shortWords , vector < string > longWords ) { int maxOfShort = * max_element ( shortWords . begin ( ) , shortWords . end ( ) , [ ] ( string a , string b ) { return a . length ( ) < b . length ( ) ; } ) . length ( ) ; int minOfLong = * min_element ( longWords . begin ( ) , longWords . end ( ) , [ ] ( string a , string b ) { return a . length ( ) < b . length ( ) ; } ) . length ( ) ; return minOfLong > maxOfShort ; } 
int compareOddEvenRange ( vector < int > numbers ) { auto oddNumbers = numbers | std :: views :: filter ( [ ] ( int n ) { return n % 2 == 1 ; } ) | std :: views :: transform ( [ ] ( int n ) { return n ; } ) ; int rangeOdd = * std :: max_element ( std :: begin ( oddNumbers ) , std :: end ( oddNumbers ) ) - * std :: min_element ( std :: begin ( oddNumbers ) , std :: end ( oddNumbers ) ) ; auto evenNumbers = numbers | std :: views :: filter ( [ ] ( int n ) { return n % 2 == 0 ; } ) | std :: views :: transform ( [ ] ( int n ) { return n ; } ) ; int rangeEven = * std :: max_element ( std :: begin ( evenNumbers ) , std :: end ( evenNumbers ) ) - * std :: min_element ( std :: begin ( evenNumbers ) , std :: end ( evenNumbers ) ) ; if ( rangeOdd < rangeEven ) { return -1 ; } if ( rangeOdd > rangeEven ) { return 1 ; } return 0 ; } 
double averageDistinctLength ( vector < string > words ) { double averageLen = 0.0 ; set < string > distinctWords ( words . begin ( ) , words . end ( ) ) ; int sum = 0 ; for ( auto & word : distinctWords ) { sum += word . length ( ) ; } if ( ! distinctWords . empty ( ) ) { averageLen = static_cast < double > ( sum ) / distinctWords . size ( ) ; } return averageLen ; } 
int withDrawBalance ( int start , vector < int > withdrawals ) { int end = start ; for ( int withdrawal : withdrawals ) { if ( withdrawal <= end ) { end -= withdrawal ; } } return end ; } 
std :: string firstShortAndStartsWithO ( std :: vector < std :: string > words ) { std :: string matchedElement = * std :: find_if ( words . begin ( ) , words . end ( ) , [ ] ( std :: string w ) { return w . length ( ) < 5 && w [ 0 ] == 'o' ; } ) ; return matchedElement ; } 
int bigNumberAtIndex ( vector < int > numbers , int index ) { int targetNum = * std :: find_if ( numbers . begin ( ) , numbers . end ( ) , [ ] ( int n ) { return ( n > 5 ) ; } ) ; std :: advance ( numbers . begin ( ) , index ) ; while ( numbers . front ( ) <= targetNum ) { ++ numbers ; } return numbers . front ( ) ; } 
bool containsSquareInRange ( int rangeStart , int rangeLength ) { bool containsSquare = false ; for ( int i = rangeStart ; i < rangeStart + rangeLength ; i ++ ) { int sqrt_i = sqrt ( i ) ; if ( sqrt_i * sqrt_i == i ) { containsSquare = true ; break ; } } return containsSquare ; } 
std :: map < int , std :: vector < int > > groupNumbersByMod ( std :: vector < int > numbers , int mod ) { std :: map < int , std :: vector < int > > numberGroups ; for ( auto n : numbers ) { numberGroups [ n % mod ] . push_back ( n ) ; } return numberGroups ; } 
std :: map < char , std :: vector < std :: string > > groupWordsByFirstChar ( std :: vector < std :: string > words ) { std :: map < char , std :: vector < std :: string > > wordGroups ; for ( auto & word : words ) { wordGroups [ word [ 0 ] ] . push_back ( word ) ; } return wordGroups ; } 
std :: vector < std :: string > orderByLengthAndDescending ( std :: vector < std :: string > words ) { sort ( words . begin ( ) , words . end ( ) , [ ] ( const std :: string & s1 , const std :: string & s2 ) { return s1 . length ( ) > s2 . length ( ) || ( s1 . length ( ) == s2 . length ( ) && s1 > s2 ) ; } ) ; return words ; } 
vector < string > orderFirstCharDescendingReverse ( vector < string > words ) { sort ( words . begin ( ) , words . end ( ) , [ ] ( string a , string b ) { if ( a [ 0 ] == b [ 0 ] ) { return a < b ; } return a [ 0 ] > b [ 0 ] ; } ) ; reverse ( words . begin ( ) , words . end ( ) ) ; return words ; } 
std :: vector < int > getSubvectorOfNegative ( std :: vector < int > numbers , int start , int length ) { std :: vector < int > subvector ; auto it = std :: next ( numbers . begin ( ) , start ) ; while ( length > 0 && it != numbers . end ( ) ) { if ( * it < 0 ) { subvector . push_back ( * it ) ; length -- ; } it ++ ; } return subvector ; } 
vector < int > getPositiveSequence ( vector < int > numbers ) { vector < int > subSequence ; auto it1 = find_if ( numbers . begin ( ) , numbers . end ( ) , [ ] ( int n ) { return n > 0 ; } ) ; auto it2 = find_if_not ( it1 , numbers . end ( ) , [ ] ( int n ) { return n > 0 ; } ) ; for ( auto it = it1 ; it != it2 ; it ++ ) { subSequence . push_back ( * it ) ; } return subSequence ; } 
vector < int > getLargerThanIndexSequence ( vector < int > numbers ) { vector < int > subSequence ; for ( int i = 0 ; i < numbers . size ( ) ; i ++ ) { if ( numbers [ i ] < i ) { continue ; } subSequence . push_back ( numbers [ i ] ) ; if ( numbers [ i ] >= i + 1 ) { break ; } } return subSequence ; } 
vector < string > rearrangeWordByIndexes ( vector < string > words , vector < int > indexes ) { vector < int > newIndexes ; for ( int n : indexes ) { if ( n >= words . size ( ) ) { newIndexes . push_back ( n % words . size ( ) ) ; } } vector < string > newWords ; for ( int n : newIndexes ) { newWords . push_back ( words [ n ] ) ; } return newWords ; } 
vector < vector < string > > getWordsUpperLower ( vector < string > words ) { vector < vector < string > > upperLowerWords ; for ( string w : words ) { vector < string > casevector ; casevector . push_back ( toupper ( w ) ) ; casevector . push_back ( tolower ( w ) ) ; upperLowerWords . push_back ( casevector ) ; } return upperLowerWords ; } 
std :: vector < bool > selectIfInPlace ( std :: vector < int > numbers ) { std :: vector < bool > numsInPlace ; int index = 0 ; for ( auto num : numbers ) { numsInPlace . push_back ( num == index ) ; index ++ ; } return numsInPlace ; } 
std :: vector < std :: vector < int > > selectPairs ( std :: vector < int > numbersA , std :: vector < int > numbersB ) { std :: vector < std :: vector < int > > pairs ; for ( int a : numbersA ) { for ( int b : numbersB ) { if ( a < b ) { pairs . push_back ( { a , b } ) ; } } } return pairs ; } 
vector < string > stringCrossJoin ( vector < string > endWords , vector < string > beginWords ) { vector < string > crossStrings ; for ( auto b : beginWords ) { for ( auto e : endWords ) { if ( b [ 0 ] == e [ e . length ( ) - 1 ] ) { crossStrings . push_back ( e + " " + b ) ; } } } return crossStrings ; } 
int elementsContainSubword ( std :: vector < std :: string > words , std :: string subword ) { int count = 0 ; for ( auto w : words ) { if ( count >= 5 ) break ; if ( w . find ( subword ) != std :: string :: npos ) { count ++ ; } } if ( count == 5 ) return 1 ; else if ( count > 0 ) return 0 ; else return -1 ; } 
vector < int > ConcatLargeNumbers ( vector < int > numbersA , vector < int > numbersB , int flag ) { vector < int > allNumbers ; for ( int i = 0 ; i < numbersA . size ( ) ; i ++ ) { if ( numbersA [ i ] > flag ) { allNumbers . push_back ( numbersA [ i ] ) ; } } for ( int j = 0 ; j < numbersB . size ( ) ; j ++ ) { if ( numbersB [ j ] > flag ) { allNumbers . push_back ( numbersB [ j ] ) ; } } return allNumbers ; } 
int DotProduct ( vector < int > vectorA , vector < int > vectorB ) { int dotProduct = 0 ; vector < int > :: iterator it1 = vectorA . begin ( ) ; vector < int > :: iterator it2 = vectorB . begin ( ) ; while ( it1 != vectorA . end ( ) && it2 != vectorB . end ( ) ) { dotProduct += ( * it1 ) * ( * it2 ) ; it1 ++ ; it2 ++ ; } return dotProduct ; } 
vector < int > SetDifference ( vector < int > setA , vector < int > setB ) { vector < int > difference = setA ; difference . insert ( difference . end ( ) , setB . begin ( ) , setB . end ( ) ) ; vector < int > intersection = setA ; sort ( intersection . begin ( ) , intersection . end ( ) ) ; sort ( setB . begin ( ) , setB . end ( ) ) ; set_intersection ( intersection . begin ( ) , intersection . end ( ) , setB . begin ( ) , setB . end ( ) , intersection . begin ( ) ) ; sort ( difference . begin ( ) , difference . end ( ) ) ; difference . erase ( unique ( difference . begin ( ) , difference . end ( ) ) , difference . end ( ) ) ; difference . erase ( remove_if ( difference . begin ( ) , difference . end ( ) , [ & ] ( int x ) { return binary_search ( intersection . begin ( ) , intersection . end ( ) , x ) ; } ) , difference . end ( ) ) ; return difference ; } 
