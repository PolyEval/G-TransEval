double DistinctOddRatio ( List < Integer > numbers ) { HashSet < Integer > distinct_numbers = new HashSet < Integer > ( numbers ) ; int distinct_count = distinct_numbers . size ( ) ; int distinct_odd_count = ( int ) distinct_numbers . stream ( ) . filter ( n -> n % 2 == 1 ) . count ( ) ; return ( double ) distinct_odd_count / distinct_count ; } 
int compareSum ( List < Integer > numbers , List < String > words ) { int int_sum = numbers . stream ( ) . reduce ( 0 , Integer :: sum ) ; int word_length_sum = words . stream ( ) . mapToInt ( String :: length ) . reduce ( 0 , Integer :: sum ) ; if ( int_sum < word_length_sum ) { return - 1 ; } if ( int_sum > word_length_sum ) { return 1 ; } return 0 ; } 
boolean allLongerThan ( List < String > shortWords , List < String > longWords ) { int maxOfShort = shortWords . stream ( ) . mapToInt ( String :: length ) . max ( ) . orElse ( 0 ) ; int minOfLong = longWords . stream ( ) . mapToInt ( String :: length ) . min ( ) . orElse ( Integer . MAX_VALUE ) ; return minOfLong > maxOfShort ; } 
int compareOddEvenRange ( List < Integer > numbers ) { int range_odd = Collections . max ( numbers . stream ( ) . filter ( n -> n % 2 == 1 ) . collect ( Collectors . toList ( ) ) ) - Collections . min ( numbers . stream ( ) . filter ( n -> n % 2 == 1 ) . collect ( Collectors . toList ( ) ) ) ; int range_even = Collections . max ( numbers . stream ( ) . filter ( n -> n % 2 == 0 ) . collect ( Collectors . toList ( ) ) ) - Collections . min ( numbers . stream ( ) . filter ( n -> n % 2 == 0 ) . collect ( Collectors . toList ( ) ) ) ; if ( range_odd < range_even ) { return - 1 ; } else if ( range_odd > range_even ) { return 1 ; } else { return 0 ; } } 
double AverageDistinctLength ( List < String > words ) { HashSet < String > s = new HashSet < > ( words ) ; List < String > distinct_words = new ArrayList < > ( s ) ; Stream < Integer > distinct_size = distinct_words . stream ( ) . map ( String :: length ) ; double average_len = ! distinct_size . isEmpty ( ) ? distinct_size . mapToInt ( Integer :: intValue ) . sum ( ) / ( double ) distinct_size . count ( ) : 0 ; return average_len ; } 
int withDrawBalance ( int start , List < Integer > withdrawals ) { int end = withdrawals . stream ( ) . reduce ( start , ( balance , nextWithdrawal ) -> nextWithdrawal <= balance ? balance - nextWithdrawal : balance ) ; return end ; } 
String firstShortAndStartsWithO ( List < String > words ) { Optional < String > matchedView = words . stream ( ) . filter ( w -> w . length ( ) < 5 ) . filter ( w -> w . charAt ( 0 ) == 'o' ) . findFirst ( ) ; String matchedElement = matchedView . isPresent ( ) ? matchedView . get ( ) : "" ; return matchedElement ; } 
int bigNumberAtIndex ( ArrayList < Integer > numbers , int index ) { Stream < Integer > stream = numbers . stream ( ) . filter ( n -> n > 5 ) ; List < Integer > filteredList = stream . skip ( index ) . collect ( Collectors . toList ( ) ) ; int target_num = filteredList . get ( 0 ) ; return target_num ; } 
boolean containsSquareInRange ( int range_start , int range_length ) { boolean contains_square = Arrays . stream ( IntStream . range ( range_start , range_start + range_length ) . toArray ( ) ) . anyMatch ( n -> Math . pow ( Math . sqrt ( n ) , 2 ) == n ) ; return contains_square ; } 
HashMap < Integer , ArrayList < Integer > > groupNumbersByMod ( ArrayList < Integer > numbers , int mod ) { HashMap < Integer , ArrayList < Integer > > numberGroups = new HashMap < Integer , ArrayList < Integer > > ( ) ; for ( int n : numbers ) { int key = n % mod ; if ( ! numberGroups . containsKey ( key ) ) { numberGroups . put ( key , new ArrayList < Integer > ( ) ) ; } numberGroups . get ( key ) . add ( n ) ; } return numberGroups ; } 
HashMap < Character , ArrayList < String > > groupWordsByFirstChar ( ArrayList < String > words ) { HashMap < Character , ArrayList < String > > wordGroups = new HashMap < Character , ArrayList < String > > ( ) ; for ( String word : words ) { char firstChar = word . charAt ( 0 ) ; if ( ! wordGroups . containsKey ( firstChar ) ) { wordGroups . put ( firstChar , new ArrayList < String > ( ) ) ; } wordGroups . get ( firstChar ) . add ( word ) ; } return wordGroups ; } 
ArrayList < String > orderByLengthAndDescending ( ArrayList < String > words ) { ArrayList < String > sortedWords = new ArrayList < > ( words ) ; Collections . sort ( sortedWords , new Comparator < String > ( ) { int compare ( String a , String b ) { if ( a . length ( ) == b . length ( ) ) { return b . compareTo ( a ) ; } return a . length ( ) - b . length ( ) ; } 
List < String > orderFirstCharDescendingReverse ( List < String > words ) { List < String > sorted_words = new ArrayList < > ( words ) ; Collections . sort ( sorted_words , new Comparator < String > ( ) { @ Override int compare ( String a , String b ) { if ( a . charAt ( 0 ) == b . charAt ( 0 ) ) { return a . compareTo ( b ) ; } return Character . compare ( b . charAt ( 0 ) , a . charAt ( 0 ) ) ; } 
ArrayList < Integer > getSubListOfNegative ( ArrayList < Integer > numbers , int start , int length ) { ArrayList < Integer > subList = new ArrayList < > ( ) ; Iterable < Integer > matchedView = numbers . subList ( start , numbers . size ( ) ) . stream ( ) . filter ( n -> n < 0 ) . limit ( length ) . collect ( Collectors . toList ( ) ) ; for ( Integer i : matchedView ) { subList . add ( i ) ; } return subList ; } 
import java . util . * ; 
import java . util . ArrayList ; 
List < String > RearrangeWordByIndexes ( List < String > words , List < Integer > indexes ) { List < Integer > new_indexes = indexes . stream ( ) . filter ( n -> n >= words . size ( ) ) . map ( n -> n % words . size ( ) ) . collect ( Collectors . toList ( ) ) ; List < String > matched_view = new_indexes . stream ( ) . map ( n -> words . get ( n ) ) . collect ( Collectors . toList ( ) ) ; List < String > new_words = new ArrayList < > ( ) ; matched_view . forEach ( new_words :: add ) ; return new_words ; } 
List < List < String > > getWordsUpperLower ( List < String > words ) { Iterable < List < String > > matchedView = words . stream ( ) . map ( w -> { String upper = w ; String lower = w ; upper = upper . toUpperCase ( ) ; lower = lower . toLowerCase ( ) ; return Arrays . asList ( upper , lower ) ; } ) . collect ( Collectors . toList ( ) ) ; List < List < String > > upperLowerWords = new ArrayList < > ( ) ; for ( List < String > wordPair : matchedView ) { upperLowerWords . add ( wordPair ) ; } return upperLowerWords ; } 
import java . util . ArrayList ; 
List < List < Integer > > SelectPairs ( List < Integer > numbers_a , List < Integer > numbers_b ) { List < List < Integer > > pairs = new ArrayList < > ( ) ; for ( int a : numbers_a ) { for ( int b : numbers_b ) { if ( a < b ) { List < Integer > pair = new ArrayList < > ( ) ; pair . add ( a ) ; pair . add ( b ) ; pairs . add ( pair ) ; } } } return pairs ; } 
List < String > StringCrossJoin ( List < String > end_words , List < String > begin_words ) { List < String > cross_strings = new ArrayList < > ( ) ; for ( String b : begin_words ) { List < String > filtered_words = end_words . stream ( ) . filter ( e -> b . charAt ( 0 ) == e . charAt ( e . length ( ) - 1 ) ) . map ( e -> e + " " + b ) . collect ( Collectors . toList ( ) ) ; cross_strings . addAll ( filtered_words ) ; } return cross_strings ; } 
int ElementsContainSubword ( ArrayList < String > words , String subword ) { if ( words . stream ( ) . limit ( 5 ) . allMatch ( w -> w . contains ( subword ) ) ) return 1 ; if ( words . stream ( ) . limit ( 5 ) . anyMatch ( w -> w . contains ( subword ) ) ) return 0 ; return - 1 ; } 
List < Integer > ConcatLargeNumbers ( List < Integer > numbers_a , List < Integer > numbers_b , int flag ) { List < Integer > large_numbers_a = numbers_a . stream ( ) . filter ( num -> num > flag ) . collect ( Collectors . toList ( ) ) ; List < Integer > large_numbers_b = numbers_b . stream ( ) . filter ( num -> num > flag ) . collect ( Collectors . toList ( ) ) ; List < Integer > all_numbers = new ArrayList < > ( ) ; all_numbers . addAll ( large_numbers_a ) ; all_numbers . addAll ( large_numbers_b ) ; return all_numbers ; } 
int DotProduct ( List < Integer > vector_a , List < Integer > vector_b ) { int dot_product = 0 ; for ( int i = 0 ; i < vector_a . size ( ) ; i ++ ) { dot_product += vector_a . get ( i ) * vector_b . get ( i ) ; } return dot_product ; } 
List < Integer > setDifference ( List < Integer > set_a , List < Integer > set_b ) { List < Integer > difference = new ArrayList < Integer > ( ) ; Collections . sort ( set_a ) ; Collections . sort ( set_b ) ; int i = 0 , j = 0 ; while ( i < set_a . size ( ) && j < set_b . size ( ) ) { if ( set_a . get ( i ) < set_b . get ( j ) ) { difference . add ( set_a . get ( i ) ) ; i ++ ; } else if ( set_b . get ( j ) < set_a . get ( i ) ) { j ++ ; } else { i ++ ; j ++ ; } } while ( i < set_a . size ( ) ) { difference . add ( set_a . get ( i ) ) ; i ++ ; } return difference ; } 
