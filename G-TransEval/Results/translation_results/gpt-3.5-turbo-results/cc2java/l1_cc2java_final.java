int GreatestCommonDivisor ( int a , int b ) { if ( a == 0 || b == 0 ) { return a + b ; } if ( a == b ) { return a ; } if ( a > b ) { return GreatestCommonDivisor ( a % b , b ) ; } else { return GreatestCommonDivisor ( a , b % a ) ; } } 
int largestDivisor ( int n ) { for ( int i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 ) { return n / i ; } } return 1 ; } 
boolean isPrime ( int n ) { if ( n < 2 ) { return false ; } for ( int k = 2 ; k < n ; k ++ ) { if ( n % k == 0 ) { return false ; } } return true ; } 
int FizzBuzz ( int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 11 == 0 || i % 13 == 0 ) { int q = i ; while ( q > 0 ) { if ( q % 10 == 7 ) { count += 1 ; } q /= 10 ; } } } return count ; } 
int PrimeFib ( int n ) { int f0 = 0 ; int f1 = 1 ; while ( n > 0 ) { int p = f0 + f1 ; boolean is_prime = p >= 2 ; for ( int i = 2 ; i < p ; i ++ ) { if ( p % i == 0 ) { is_prime = false ; break ; } } if ( is_prime ) { n -= 1 ; } f0 = f1 ; f1 = p ; } return f1 ; } 
double TriangleArea ( double a , double h ) { return a * h / 2 ; } 
int modP ( int n , int p ) { int ret = 1 ; for ( int i = 0 ; i < n ; i ++ ) { ret = ( ret * 2 ) % p ; } return ret ; } 
int Add ( int x , int y ) { return x + y ; } 
int fib ( int n ) { if ( n == 0 ) { return 0 ; } if ( n == 1 ) { return 1 ; } return fib ( n - 1 ) + fib ( n - 2 ) ; } 
int LargestPrimeFactor ( int n ) { for ( int i = 2 ; i < n ; i ++ ) { while ( n % i == 0 && n > i ) { n /= i ; } } return n ; } 
int SumToN ( int n ) { int result = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { result += i ; } return result ; } 
int FibFib ( int n ) { if ( n == 0 ) { return 0 ; } if ( n == 1 ) { return 0 ; } if ( n == 2 ) { return 1 ; } return FibFib ( n - 1 ) + FibFib ( n - 2 ) + FibFib ( n - 3 ) ; } 
boolean isMultiplyPrime ( int a ) { int num = 0 ; for ( int i = 2 ; i <= a ; i ++ ) { while ( a % i == 0 && a >= i ) { a /= i ; num += 1 ; } } return num == 3 ; } 
boolean IsSimplePower ( int x , int n ) { if ( n == 1 ) { return x == 1 ; } int power = 1 ; while ( power < x ) { power *= n ; } return power == x ; } 
int chooseNum ( int x , int y ) { if ( x > y ) { return - 1 ; } if ( y % 2 == 0 ) { return y ; } if ( x == y ) { return - 1 ; } return y - 1 ; } 
boolean isEqualToSumEven ( int n ) { return n % 2 == 0 && n >= 8 ; } 
int SpecialFactorial ( int n ) { int fact = 1 ; int special_fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { fact *= i ; special_fact *= fact ; } return special_fact ; } 
int XOrY ( int n , int x , int y ) { boolean is_prime = n >= 2 ; for ( int i = 2 ; i < n ; i ++ ) { if ( n % i == 0 ) { is_prime = false ; break ; } } if ( is_prime ) { return x ; } return y ; } 
boolean RightAngleTriangle ( int a , int b , int c ) { return ( a * a == b * b + c * c ) || ( b * b == a * a + c * c ) || ( c * c == a * a + b * b ) ; } 
int FastPow ( int n , int k ) { if ( k == 0 ) { return 1 ; } int temp = FastPow ( n , k / 2 ) ; if ( k % 2 == 0 ) { return temp * temp ; } else { return n * temp * temp ; } } 
boolean isPalin ( String s ) { int l = s . length ( ) / 2 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( s . length ( ) - i - 1 ) ) { return false ; } } return true ; } 
int FindSum ( int n ) { int ans = 0 , temp = 0 ; for ( int i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; int num = 1 ; while ( temp < n ) { if ( temp + i <= n ) { ans += i * num ; } else { ans += ( n - temp ) * num ; } temp += i ; num += 1 ; } } return ans ; } 
int getNextGap ( int gap ) { gap = gap * 10 / 13 ; if ( gap < 1 ) { return 1 ; } return gap ; } 
int countNonDecreasing ( int n ) { int k = 10 ; int count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= k + i - 1 ; count /= i ; } return count ; } 
int Power ( int x , int y ) { if ( y == 0 ) { return 1 ; } else if ( y % 2 == 0 ) { int halfPower = Power ( x , y / 2 ) ; return halfPower * halfPower ; } else { int halfPower = Power ( x , y / 2 ) ; return x * halfPower * halfPower ; } } 
double power ( double x , int y ) { if ( y == 0 ) { return 1 ; } double temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) { return temp * temp ; } else { if ( y > 0 ) { return x * temp * temp ; } else { return temp * temp / x ; } } } 
int Multiply ( int x , int y ) { if ( y == 0 ) { return 0 ; } else if ( y > 0 ) { return x + Multiply ( x , y - 1 ) ; } else { return - Multiply ( x , - y ) ; } } 
int smallest ( int x , int y , int z ) { if ( ! ( y / x ) ) { return ! ( y / z ) ? y : z ; } return ! ( x / z ) ? x : z ; } 
boolean isPowerOfFour ( int n ) { if ( n == 0 ) { return false ; } while ( n != 1 ) { if ( n % 4 != 0 ) { return false ; } n = n / 4 ; } return true ; } 
int ModInverse ( int a , int m ) { int m0 = m ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) { return 0 ; } while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) { x1 += m0 ; } return x1 ; } 
int cntRotations ( String s , int n ) { String s2 = s + s ; int [ ] pre = new int [ 2 * n ] ; for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( i != 0 ) { pre [ i ] += pre [ i - 1 ] ; } if ( s2 . charAt ( i ) == 'a' || s2 . charAt ( i ) == 'e' || s2 . charAt ( i ) == 'i' || s2 . charAt ( i ) == 'o' || s2 . charAt ( i ) == 'u' ) { pre [ i ] ++ ; } } int ans = 0 ; for ( int i = n - 1 ; i < 2 * n - 1 ; i ++ ) { int r = i , l = i - n ; int x1 = pre [ r ] ; if ( l >= 0 ) { x1 -= pre [ l ] ; } r = i - n / 2 ; int left = pre [ r ] ; if ( l >= 0 ) { left -= pre [ l ] ; } int right = x1 - left ; if ( left > right ) { ans ++ ; } } return ans ; } 
int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) { k = n - k ; } for ( int i = 0 ; i < k ; ++ i ) { res *= n - i ; res /= i + 1 ; } return res ; } 
boolean IsPrefix ( String temp , String s ) { if ( temp . length ( ) < s . length ( ) ) { return false ; } else { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != temp . charAt ( i ) ) { return false ; } } return true ; } } 
String LexicographicallySmallestString ( String s , int n ) { int last_ze = - 1 ; String ans = "" ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '0' ) { last_ze = i ; break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( i <= last_ze && s . charAt ( i ) == '0' ) { ans += s . charAt ( i ) ; } else if ( i > last_ze ) { ans += s . charAt ( i ) ; } } return ans ; } 
int calculateMax ( int n , int m , int k ) { int ans = - 1 ; int low = 0 ; int high = m ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int val = 0 ; int l = k - 1 ; int r = n - k ; val += mid ; if ( mid >= l ) { val += l * ( 2 * mid - l - 1 ) / 2 ; } else { val += mid * ( mid - 1 ) / 2 + ( l - mid ) ; } if ( mid >= r ) { val += r * ( 2 * mid - r - 1 ) / 2 ; } else { val += mid * ( mid - 1 ) / 2 + ( r - mid ) ; } if ( val <= m ) { ans = Math . max ( ans , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } return ans ; } 
int findLength ( String s , char i , char j ) { char required = i ; int length = 0 ; for ( char curr : s . toCharArray ( ) ) { if ( curr == required ) { length += 1 ; if ( required == i ) { required = j ; } else { required = i ; } } } return length ; } 
boolean checkReverse ( int left_sum , int right_sum ) { int rev = 0 ; int temp = right_sum ; while ( temp != 0 ) { rev = rev * 10 + temp % 10 ; temp /= 10 ; } if ( rev == left_sum ) { return true ; } else { return false ; } } 
boolean isComposite ( int n ) { if ( n <= 1 ) { return false ; } if ( n <= 3 ) { return false ; } if ( n % 2 == 0 || n % 3 == 0 ) { return true ; } for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return true ; } } return false ; } 
int MinDeletion ( String s ) { int n = s . length ( ) ; int first_idx1 = - 1 ; int last_idx0 = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) { first_idx1 = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '0' ) { last_idx0 = i ; break ; } } if ( first_idx1 == - 1 || last_idx0 == - 1 ) { return 0 ; } int count1 = 0 , count0 = 0 ; for ( int i = 0 ; i < last_idx0 ; i ++ ) { if ( s . charAt ( i ) == '1' ) { count1 ++ ; } } for ( int i = first_idx1 + 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) { count0 ++ ; } } return Math . min ( count0 , count1 ) ; } 
int MinSteps ( String s , int n ) { int smaller , cost = 0 ; ArrayList < Integer > f = new ArrayList < > ( 26 ) ; for ( int i = 0 ; i < 26 ; i ++ ) { f . add ( 0 ) ; } for ( int i = 0 ; i < n ; i ++ ) { int curr_ele = s . charAt ( i ) - 'a' ; smaller = 0 ; for ( int j = 0 ; j <= curr_ele ; j ++ ) { if ( f . get ( j ) != 0 ) { smaller += f . get ( j ) ; } } if ( smaller == 0 ) { cost += i + 1 ; } else { cost += i - smaller + 1 ; } f . set ( s . charAt ( i ) - 'a' , f . get ( s . charAt ( i ) - 'a' ) + 1 ) ; } return cost ; } 
int NumberOfWays ( int n ) { int count = 0 ; for ( int a = 1 ; a < n ; a ++ ) { for ( int b = 1 ; b < n ; b ++ ) { int c = n - ( a + b ) ; if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } } return count ; } 
int slopeOfNum ( String num , int n ) { int slope = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( num . charAt ( i ) > num . charAt ( i - 1 ) && num . charAt ( i ) > num . charAt ( i + 1 ) ) { slope ++ ; } else if ( num . charAt ( i ) < num . charAt ( i - 1 ) && num . charAt ( i ) < num . charAt ( i + 1 ) ) { slope ++ ; } } return slope ; } 
int MiddleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) { return b ; } else if ( x * z > 0 ) { return c ; } else { return a ; } } 
int countMaxSetBits ( int left , int right ) { while ( ( left | ( left + 1 ) ) <= right ) { left |= left + 1 ; } return left ; } 
int FindS ( int s ) { int l = 1 ; int r = ( s / 2 ) + 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; int sum = mid * ( mid + 1 ) / 2 ; if ( sum == s ) { return mid ; } else if ( sum > s ) { r = mid - 1 ; } else { l = mid + 1 ; } } return - 1 ; } 
boolean check ( String s ) { int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; int sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int ascii = ( int ) s . charAt ( i ) ; if ( ascii < 96 || ascii > 122 ) { return false ; } sum += ascii ; if ( min > ascii ) { min = ascii ; } if ( max < ascii ) { max = ascii ; } } min -= 1 ; int eSum = max * ( max + 1 ) / 2 - min * ( min + 1 ) / 2 ; return sum == eSum ; } 
int MinimumPossibleProduct ( int k ) { int res = 1 ; int r = ( 1 << k ) - 1 ; for ( int i = 0 ; i < k ; i ++ ) { res *= r - 1 ; } res *= r ; return res ; } 
int FindInGrid ( int i , int j ) { if ( i == j ) { return i * i - ( i - 1 ) ; } else if ( i > j ) { if ( i % 2 == 0 ) { return i * i - ( j - 1 ) ; } else { return ( i - 1 ) * ( i - 1 ) + 1 + ( j - 1 ) ; } } else { if ( j % 2 == 0 ) { return ( j - 1 ) * ( j - 1 ) + 1 + ( i - 1 ) ; } else { return j * j - ( i - 1 ) ; } } } 
int FindMinOperationsReqEmpStr ( String s ) { int cnt_one = 0 ; int cnt_zero = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' ) { if ( cnt_one > 0 ) { cnt_one -- ; } cnt_zero ++ ; } else { if ( cnt_zero > 0 ) { cnt_zero -- ; } cnt_one ++ ; } } return cnt_one + cnt_zero ; } 
boolean IsReachable ( int x1 , int y1 , int x2 , int y2 ) { while ( x2 > x1 && y2 > y1 ) { if ( x2 > y2 ) { x2 %= y2 ; } else { y2 %= x2 ; } } if ( x2 == x1 ) { return y2 - y1 >= 0 && ( y2 - y1 ) % x1 == 0 ; } else if ( y2 == y1 ) { return x2 - x1 >= 0 && ( x2 - x1 ) % y1 == 0 ; } else { return false ; } } 
int FindMaxSoln ( int n , int x , int y ) { int ans = Integer . MIN_VALUE ; for ( int k = 0 ; k <= n ; k ++ ) { if ( k % x == y ) { ans = Math . max ( ans , k ) ; } } return ( ans >= 0 && ans <= n ) ? ans : - 1 ; } 
int numberOfPairs ( int n ) { int count = 0 ; int i = 1 ; int j = n - 1 ; while ( i < j ) { if ( i + j == n ) { count ++ ; } i ++ ; j -- ; } return count ; } 
int MinChanges ( String s , int n ) { int count = 0 ; int zeros = 0 ; int ones = 0 ; if ( s . charAt ( 0 ) != '1' ) { count ++ ; ones ++ ; } for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' ) { zeros ++ ; } else { ones ++ ; } if ( zeros > ones ) { zeros -- ; ones ++ ; count ++ ; } } return count ; } 
int KVisibleFromLeft ( int n , int k ) { if ( n == k ) { return 1 ; } if ( k == 1 ) { int ans = 1 ; for ( int i = 1 ; i < n ; i ++ ) { ans *= i ; } return ans ; } return KVisibleFromLeft ( n - 1 , k - 1 ) + ( n - 1 ) * KVisibleFromLeft ( n - 1 , k ) ; } 
double find ( int n , int sum ) { if ( sum > 6 * n || sum < n ) { return 0 ; } if ( n == 1 ) { if ( sum >= 1 && sum <= 6 ) { return 1.0 / 6 ; } else { return 0 ; } } double s = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { s += find ( n - 1 , sum - i ) / 6 ; } return s ; } 
int BinCoff ( int n , int r ) { int val = 1 ; if ( r > n - r ) { r = n - r ; } for ( int i = 0 ; i < r ; i ++ ) { val *= n - i ; val /= i + 1 ; } return val ; } 
int getMask ( int val ) { int mask = 0 ; if ( val == 0 ) { return 1 ; } while ( val != 0 ) { int d = val % 10 ; mask |= 1 << d ; val /= 10 ; } return mask ; } 
int waysToKAdjacentSetBits ( int n , int k , int currentIndex , int adjacentSetBits , int lastBit ) { if ( currentIndex == n ) { if ( adjacentSetBits == k ) { return 1 ; } return 0 ; } int noOfWays = 0 ; if ( lastBit == 1 ) { noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ; noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } else if ( ! lastBit ) { noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } return noOfWays ; } 
int checkFunc ( int i , int j , String st ) { if ( st . charAt ( i ) == '(' && st . charAt ( j ) == ')' ) { return 1 ; } if ( st . charAt ( i ) == '(' && st . charAt ( j ) == '?' ) { return 1 ; } if ( st . charAt ( i ) == '?' && st . charAt ( j ) == ')' ) { return 1 ; } if ( st . charAt ( i ) == '[' && st . charAt ( j ) == ']' ) { return 1 ; } if ( st . charAt ( i ) == '[' && st . charAt ( j ) == '?' ) { return 1 ; } if ( st . charAt ( i ) == '?' && st . charAt ( j ) == ']' ) { return 1 ; } if ( st . charAt ( i ) == '{' && st . charAt ( j ) == '}' ) { return 1 ; } if ( st . charAt ( i ) == '{' && st . charAt ( j ) == '?' ) { return 1 ; } if ( st . charAt ( i ) == '?' && st . charAt ( j ) == '}' ) { return 1 ; } return 0 ; } 
int FindGolomb ( int n ) { if ( n == 1 ) { return 1 ; } return 1 + FindGolomb ( n - FindGolomb ( FindGolomb ( n - 1 ) ) ) ; } 
boolean allOnes ( String s , int n ) { int co = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { co += s . charAt ( i ) == '1' ? 1 : 0 ; } return co == n ; } 
int Pad ( int n ) { int pPrevPrev = 1 , pPrev = 1 , pCurr = 1 , pNext = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { pNext = pPrevPrev + pPrev ; pPrevPrev = pPrev ; pPrev = pCurr ; pCurr = pNext ; } return pNext ; } 
int OddLengthPalindrome ( int k ) { int palin = k ; k = k / 10 ; while ( k > 0 ) { int rev = k % 10 ; palin = palin * 10 + rev ; k = k / 10 ; } return palin ; } 
String ChangeString ( String s0 ) { String s = s0 ; int n = s . length ( ) ; if ( s . charAt ( 0 ) == '?' ) { s = 'a' + s . substring ( 1 ) ; if ( s . charAt ( 0 ) == s . charAt ( 1 ) ) { s = ( char ) ( s . charAt ( 0 ) + 1 ) + s . substring ( 1 ) ; } } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( s . charAt ( i ) == '?' ) { s = s . substring ( 0 , i ) + 'a' + s . substring ( i + 1 ) ; if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) { s = s . substring ( 0 , i ) + ( char ) ( s . charAt ( i ) + 1 ) + s . substring ( i + 1 ) ; } if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) { s = s . substring ( 0 , i ) + ( char ) ( s . charAt ( i ) + 1 ) + s . substring ( i + 1 ) ; } if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) { s = s . substring ( 0 , i ) + ( char ) ( s . charAt ( i ) + 1 ) + s . substring ( i + 1 ) ; } } } if ( s . charAt ( n - 1 ) == '?' ) { s = s . substring ( 0 , n - 1 ) + 'a' ; if ( s . charAt ( n - 1 ) == s . charAt ( n - 2 ) ) { s = s . substring ( 0 , n - 1 ) + ( char ) ( s . charAt ( n - 1 ) + 1 ) ; } } return s ; } 
int TotalHammingDistance ( int n ) { int i = 1 ; int sum = 0 ; while ( n / i > 0 ) { sum = sum + n / i ; i = i * 2 ; } return sum ; } 
int CheckBitonic ( String s ) { int i = 1 ; for ( ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) > s . charAt ( i - 1 ) ) { continue ; } if ( s . charAt ( i ) <= s . charAt ( i - 1 ) ) { break ; } } if ( i == s . length ( ) - 1 ) { return 1 ; } int j = i + 1 ; for ( ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) < s . charAt ( j - 1 ) ) { continue ; } if ( s . charAt ( j ) >= s . charAt ( j - 1 ) ) { break ; } } i = j ; if ( i != s . length ( ) ) { return 0 ; } return 1 ; } 
boolean endsWith ( String str , String pat ) { int pat_len = pat . length ( ) ; int str_len = str . length ( ) ; if ( pat_len > str_len ) { return false ; } pat_len -- ; str_len -- ; while ( pat_len >= 0 ) { if ( pat . charAt ( pat_len ) != str . charAt ( str_len ) ) { return false ; } pat_len -- ; str_len -- ; } return true ; } 
int GetSum ( int n , int d ) { if ( n < d ) { return 0 ; } while ( n % 10 != d ) { n -- ; } int k = n / 10 ; return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ; } 
int BalancedStringBySwapping ( String s ) { int unbalanced_pair = 0 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( unbalanced_pair > 0 && s . charAt ( i ) == ']' ) { -- unbalanced_pair ; } else if ( s . charAt ( i ) == '[' ) { ++ unbalanced_pair ; } } return ( unbalanced_pair + 1 ) / 2 ; } 
int ComputeHash ( String s ) { int p = 31 ; long mod = ( long ) Math . pow ( 10 , 9 ) + 7 ; long hash_val = 0 ; long mul = 1 ; for ( char ch : s . toCharArray ( ) ) { hash_val = ( hash_val + ( ch - 'a' + 1 ) * mul ) % mod ; mul = mul * p % mod ; } return ( int ) hash_val ; } 
int CountOfSubstringWithOnlyOnes ( String s ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { count = s . charAt ( i ) == '1' ? count + 1 : 0 ; res = res + count ; } return res ; } 
int Composite ( int n ) { int flag = 0 ; int c = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { if ( n % j == 0 ) { c += 1 ; } } if ( c >= 3 ) { flag = 1 ; } return flag ; } 
boolean isDivBySix ( String s , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += s . charAt ( i ) - 'a' + 1 ; } if ( sum % 3 != 0 ) { return false ; } int last_digit = ( s . charAt ( n - 1 ) - 'a' + 1 ) % 10 ; if ( last_digit % 2 != 0 ) { return false ; } return true ; } 
boolean IsRedundantBraces ( String s ) { int a = 0 , b = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '(' && s . charAt ( i + 2 ) == ')' ) { return true ; } if ( s . charAt ( i ) == '*' || s . charAt ( i ) == '+' || s . charAt ( i ) == '-' || s . charAt ( i ) == '/' ) { a ++ ; } if ( s . charAt ( i ) == '(' ) { b ++ ; } } if ( b > a ) { return true ; } return false ; } 
int countSubStr ( String s , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 2 ; ) { if ( s . charAt ( i ) == '0' && s . charAt ( i + 1 ) == '1' && s . charAt ( i + 2 ) == '0' ) { count ++ ; i += 3 ; } else if ( s . charAt ( i ) == '1' && s . charAt ( i + 1 ) == '0' && s . charAt ( i + 2 ) == '1' ) { count ++ ; i += 3 ; } else { i ++ ; } } return count ; } 
int PrefixOccurrences ( String s ) { char c = s . charAt ( 0 ) ; int count_c = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == c ) { count_c ++ ; } } return count_c ; } 
boolean isValid ( String s , int len ) { for ( int i = 1 ; i < len ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) { return false ; } } return true ; } 
int Count ( String s , int k ) { int n = s . length ( ) ; int d = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d += s . charAt ( i ) ; } if ( d % k == 0 ) { count += 1 ; } for ( int i = k ; i < n ; i ++ ) { int prev = s . charAt ( i - k ) ; d -= prev ; d += s . charAt ( i ) ; if ( d % k == 0 ) { count += 1 ; } } return count ; } 
int FindSubstringCount ( String s ) { int result = 0 ; int n = s . length ( ) ; int i = 0 ; while ( i < n - 1 ) { if ( s . charAt ( i ) + 1 == s . charAt ( i + 1 ) ) { result ++ ; while ( i < n - 1 && s . charAt ( i ) + 1 == s . charAt ( i + 1 ) ) { i ++ ; } } i ++ ; } return result ; } 
boolean find ( String s1 , String s2 ) { int len1 = s1 . length ( ) , len2 = s2 . length ( ) ; if ( len1 != len2 ) { return false ; } List < Integer > d = new ArrayList < > ( len1 ) ; d . add ( s2 . charAt ( 0 ) - s1 . charAt ( 0 ) ) ; for ( int i = 1 ; i < len1 ; i ++ ) { if ( s1 . charAt ( i ) > s2 . charAt ( i ) ) { return false ; } else { d . add ( s2 . charAt ( i ) - s1 . charAt ( i ) ) ; } } for ( int i = 0 ; i < len1 - 1 ; i ++ ) { if ( d . get ( i ) < d . get ( i + 1 ) ) { return false ; } } return true ; } 
boolean IsInGivenBase ( String s , int bas ) { if ( bas > 16 ) { return false ; } else if ( bas <= 10 ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! ( s . charAt ( i ) >= '0' && s . charAt ( i ) < '0' + bas ) ) { return false ; } } } else { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! ( ( s . charAt ( i ) >= '0' && s . charAt ( i ) < '0' + bas ) || ( s . charAt ( i ) >= 'A' && s . charAt ( i ) < ( 'A' + bas - 10 ) ) ) ) { return false ; } } } return true ; } 
int CountNonEmptySubstr ( String s ) { int n = s . length ( ) ; return n * ( n + 1 ) / 2 ; } 
int EvenDecimalValue ( String s , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int decimal_value = 0 ; int power_of_2 = 1 ; for ( int k = i ; k <= j ; k ++ ) { decimal_value += ( s . charAt ( k ) - '0' ) * power_of_2 ; power_of_2 *= 2 ; } if ( decimal_value % 2 == 0 ) { result ++ ; } } } return result ; } 
int calculate ( String s ) { int ans = 6 ; for ( int i = 0 ; i < 10 ; ++ i ) { for ( int j = 0 ; j < 10 ; ++ j ) { for ( int k = 0 ; k < 10 ; ++ k ) { for ( int l = 0 ; l < 10 ; ++ l ) { for ( int m = 0 ; m < 10 ; ++ m ) { for ( int n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { int c = 0 ; if ( i != s . charAt ( 0 ) - '0' ) { c ++ ; } if ( j != s . charAt ( 1 ) - '0' ) { c ++ ; } if ( k != s . charAt ( 2 ) - '0' ) { c ++ ; } if ( l != s . charAt ( 3 ) - '0' ) { c ++ ; } if ( m != s . charAt ( 4 ) - '0' ) { c ++ ; } if ( n != s . charAt ( 5 ) - '0' ) { c ++ ; } if ( c < ans ) { ans = c ; } } } } } } } } return ans ; } 
int XorZero ( String s ) { int one_count = 0 , zero_count = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) { one_count ++ ; } else { zero_count ++ ; } } if ( one_count % 2 == 0 ) { return zero_count ; } return one_count ; } 
String EvenLength ( String n ) { String res = n ; for ( int j = n . length ( ) - 1 ; j >= 0 ; -- j ) { res += n . charAt ( j ) ; } return res ; } 
int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { result ++ ; } } } return result ; } 
double normalSlope ( double a , double b , double x1 , double y1 ) { double g = a / 2 ; double f = b / 2 ; if ( g - x1 == 0 ) { return - 1 ; } double slope = ( f - y1 ) / ( g - x1 ) ; if ( slope == 0 ) { return - 2 ; } return slope ; } 
boolean Orthogonality ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int dsquare = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; if ( dsquare == r1 * r1 + r2 * r2 ) { return true ; } else { return false ; } } 
double FindAreaShaded ( double a ) { double sq_area = a * a ; double semi_circle_area = 3.14 * ( a * a ) / 8 ; double shaded_area = 4 * semi_circle_area - sq_area ; return shaded_area ; } 
int Factorial ( int a , int b ) { int res = 1 ; for ( int i = 1 ; i <= a + b ; i ++ ) { res = res * i ; } for ( int i = 1 ; i <= a ; i ++ ) { res = res / i ; } for ( int i = 1 ; i <= b ; i ++ ) { res = res / i ; } return res ; } 
int FactorTree ( int n ) { int height = 0 ; while ( n > 1 ) { boolean flag = false ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { n = n / i ; flag = true ; break ; } } height ++ ; if ( ! flag ) { break ; } } return height ; } 
String findIfPossible ( int n , int s , int x ) { if ( s >= x && s % 2 == x % 2 ) { if ( n >= 3 ) { return "Yes" ; } if ( n == 1 ) { if ( s == x ) { return "Yes" ; } else { return "No" ; } } if ( n == 2 ) { int c = ( s - x ) / 2 ; int a = c ; int b = c ; a = a + x ; if ( ( a ^ b ) == x ) { return "Yes" ; } else { return "No" ; } } } return "No" ; } 
int MaximumTripletXor ( int a , int b , int c ) { int ans = 0 ; for ( int i = 30 ; i >= 0 ; i -- ) { int cur = 1 << i ; if ( a >= cur ) { ans += cur ; a -= cur ; } else if ( b >= cur ) { ans += cur ; b -= cur ; } else if ( c >= cur ) { ans += cur ; c -= cur ; } } return ans ; } 
int ItemType ( int n ) { int count = 0 ; int day = 1 ; while ( count + day * ( day + 1 ) / 2 < n ) { count += day * ( day + 1 ) / 2 ; day ++ ; } for ( int type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) { return type ; } } return 0 ; } 
int maxGcdInRange ( int l , int r ) { int ans = 1 ; for ( int z = r ; z >= 1 ; z -- ) { if ( r / z - ( l - 1 ) / z > 1 ) { ans = z ; break ; } } return ans ; } 
int sumOfDigits ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } return sum ; } 
boolean IsRepUnitNum ( int n , int b ) { int length = 0 ; int count_one = 0 ; while ( n != 0 ) { int r = n % b ; length ++ ; if ( r == 1 ) { count_one ++ ; } n = n / b ; } return count_one >= 3 && count_one == length ; } 
boolean IsStraightLineNum ( int n ) { if ( n <= 99 ) { return false ; } String s = String . valueOf ( n ) ; int d = s . charAt ( 1 ) - s . charAt ( 0 ) ; for ( int i = 2 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) - s . charAt ( i - 1 ) != d ) { return false ; } } return true ; } 
int getCount ( int d , int n ) { int no = n / d ; int result = no ; for ( int p = 2 ; p * p <= no ; ++ p ) { if ( no % p == 0 ) { while ( no % p == 0 ) { no /= p ; } result -= result / p ; } } if ( no > 1 ) { result -= result / no ; } return result ; } 
boolean isEvenParity ( int x ) { int parity = 0 ; while ( x != 0 ) { if ( ( x & 1 ) == 1 ) { parity ++ ; } x = x >> 1 ; } if ( parity % 2 == 0 ) { return true ; } else { return false ; } } 
int IsPerfect ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) { sum = sum + i + n / i ; } else { sum = sum + i ; } } } if ( sum == n && n != 1 ) { return n ; } return 0 ; } 
int logAToBaseB ( int a , int b ) { return a > b - 1 ? 1 + logAToBaseB ( a / b , b ) : 0 ; } 
int usingBinarySearch ( int start , int end , int n , int s ) { if ( start >= end ) { return start ; } int mid = start + ( end - start ) / 2 ; int total_sum = n * ( n + 1 ) / 2 ; int mid_sum = mid * ( mid + 1 ) / 2 ; if ( total_sum - mid_sum <= s ) { return usingBinarySearch ( start , mid , n , s ) ; } return usingBinarySearch ( mid + 1 , end , n , s ) ; } 
String MinInt ( String s ) { String s1 = s ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s1 . charAt ( i ) >= '5' ) { s1 = s1 . substring ( 0 , i ) + ( char ) ( '9' - s1 . charAt ( i ) + '0' ) + s1 . substring ( i + 1 ) ; } } if ( s1 . charAt ( 0 ) == '0' ) { s1 = '9' + s1 . substring ( 1 ) ; } return s1 ; } 
int CountTriplets ( int a , int b , int c ) { int ans = 0 ; for ( int i = 1 ; i <= a ; i ++ ) { for ( int j = 1 ; j <= b ; j ++ ) { for ( int k = 1 ; k <= c ; k ++ ) { if ( i * k > j * j ) { ans ++ ; } } } } return ans ; } 
boolean TopsyTurvy ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '2' || s . charAt ( i ) == '4' || s . charAt ( i ) == '5' || s . charAt ( i ) == '6' || s . charAt ( i ) == '7' || s . charAt ( i ) == '9' ) { return false ; } } return true ; } 
int SumOfLastDig ( int n , int m ) { int sum = 0 ; int k = n / m ; ArrayList < Integer > arr = new ArrayList < Integer > ( 10 ) ; for ( int i = 0 ; i < 10 ; i ++ ) { arr . add ( m * ( i + 1 ) % 10 ) ; sum += arr . get ( i ) ; } int rem = k % 10 ; int ans = k / 10 * sum ; for ( int i = 0 ; i < rem ; i ++ ) { ans += arr . get ( i ) ; } return ans ; } 
int TotalPay ( int total_items , int price_of_one_item , int n , int m ) { int freeItems = 0 , actual = 0 ; freeItems = total_items / ( n + m ) ; actual = total_items - freeItems ; int amount = actual * price_of_one_item ; return amount ; } 
int MinOperations ( int x , int y , int p , int q ) { if ( y % x != 0 ) { return - 1 ; } int d = y / x ; int a = 0 ; while ( d % p == 0 ) { d /= p ; a += 1 ; } int b = 0 ; while ( d % q == 0 ) { d /= q ; b += 1 ; } if ( d != 1 ) { return - 1 ; } return a + b ; } 
boolean isMersenne ( int n ) { while ( n != 0 ) { int r = n % 2 ; if ( r == 0 ) { return false ; } n /= 2 ; } return true ; } 
int FindThirdDigit ( int n ) { if ( n < 3 ) { return 0 ; } return ( n & 1 ) == 1 ? 1 : 6 ; } 
boolean isOddLength ( int num ) { int count = 0 ; while ( num > 0 ) { num /= 10 ; count ++ ; } return count % 2 != 0 ; } 
boolean checkIsPossible ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( i % k == 0 ) { count ++ ; } } return count > 1 ; } 
int bytes ( int kilobytes ) { int b = kilobytes * 1024 ; return b ; } 
int OctahedralNum ( int n ) { return n * ( 2 * n * n + 1 ) / 3 ; } 
String checkEqual ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != '1' && s . charAt ( i ) != '0' && s . charAt ( i ) != '8' ) { return "No" ; } } int start = 0 , end = s . length ( ) - 1 ; while ( start < end ) { if ( s . charAt ( start ) != s . charAt ( end ) ) { return "No" ; } start ++ ; end -- ; } return "Yes" ; } 
boolean isUndulating ( String n ) { if ( n . length ( ) <= 2 ) { return false ; } for ( int i = 2 ; i < n . length ( ) ; i ++ ) { if ( n . charAt ( i - 2 ) != n . charAt ( i ) ) { return false ; } } return true ; } 
int FirstDigit ( int n ) { while ( n >= 10 ) { n /= 10 ; } return n ; } 
int countDigit ( int n ) { if ( n == 0 ) { return 0 ; } return 1 + countDigit ( n / 10 ) ; } 
boolean isDivisibleBy5 ( String s ) { int n = s . length ( ) ; return s . charAt ( n - 1 ) - '0' == 0 || s . charAt ( n - 1 ) - '0' == 5 ; } 
int Inv ( int a , int m ) { int m0 = m ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) { return 0 ; } while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) { x1 += m0 ; } return x1 ; } 
boolean onlyFirstAndLastAreSet ( int n ) { if ( n == 1 ) { return true ; } if ( n == 2 ) { return false ; } return ( ( n - 1 ) & ( n - 2 ) ) == 0 ; } 
int Divide ( int dividend , int divisor ) { int sign = ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? - 1 : 1 ; dividend = Math . abs ( dividend ) ; divisor = Math . abs ( divisor ) ; int quotient = 0 ; long temp = 0 ; for ( int i = 31 ; i >= 0 ; -- i ) { if ( temp + ( ( long ) divisor << i ) <= dividend ) { temp += ( ( long ) divisor << i ) ; quotient |= 1 << i ; } } if ( sign == - 1 ) { quotient = - quotient ; } return quotient ; } 
char findProfession ( int level , int pos ) { if ( level == 1 ) { return 'e' ; } if ( findProfession ( level - 1 , ( pos + 1 ) / 2 ) == 'd' ) { return pos % 2 == 0 ? 'e' : 'd' ; } return pos % 2 == 0 ? 'd' : 'e' ; } 
