function distinctOddRatio ( numbers ) { let distinctCount = [ ... new Set ( numbers ) ] . length ; let distinctOddCount = [ ... new Set ( numbers ) ] . filter ( ( n ) => n % 2 === 1 ) . length ; return distinctOddCount / distinctCount ; } 
function compareSum ( numbers , words ) { let intSum = numbers . reduce ( ( acc , curr ) => acc + curr , 0 ) ; let wordLengthSum = words . reduce ( ( acc , curr ) => acc + curr . length , 0 ) ; if ( intSum < wordLengthSum ) { return - 1 ; } else if ( intSum > wordLengthSum ) { return 1 ; } return 0 ; } 
function allLongerThan ( shortWords , longWords ) { let maxOfShort = Math . max ( ... shortWords . map ( word => word . length ) ) ; let minOfLong = Math . min ( ... longWords . map ( word => word . length ) ) ; return minOfLong > maxOfShort ; } 
function compareOddEvenRange ( numbers ) { const rangeOdd = Math . max ( ... numbers . filter ( n => n % 2 === 1 ) ) - Math . min ( ... numbers . filter ( n => n % 2 === 1 ) ) ; const rangeEven = Math . max ( ... numbers . filter ( n => n % 2 === 0 ) ) - Math . min ( ... numbers . filter ( n => n % 2 === 0 ) ) ; if ( rangeOdd < rangeEven ) { return - 1 ; } else if ( rangeOdd > rangeEven ) { return 1 ; } else { return 0 ; } } 
function averageDistinctLength ( words ) { const distinctWords = [ ... new Set ( words ) ] ; // Get distinct words  const wordLengths = distinctWords.map(word => word.length);  // Get lengths of each distinct word  const totalLength = wordLengths.reduce((acc, curr) => acc + curr, 0);  // Get total length of all words  const averageLen = totalLength / wordLengths.length;  // Get the average length  return averageLen;}  
function withDrawBalance ( start , withdrawals ) { let end = withdrawals . reduce ( ( balance , nextWithdrawal ) => { return nextWithdrawal <= balance ? balance - nextWithdrawal : balance ; } , start ) ; return end ; } 
function firstShortAndStartsWithO ( words ) { let matchedElement = words . find ( ( w ) => w . length < 5 && w . charAt ( 0 ) === 'o' ) || "" ; return matchedElement ; } 
function bigNumberAtIndex ( numbers , index ) { let targetNum = numbers . filter ( n => n > 5 ) . slice ( index ) . find ( n => true ) ; return targetNum ; } 
function containsSquareInRange ( rangeStart , rangeLength ) { const containsSquare = [ ... Array ( rangeLength ) . keys ( ) ] . map ( ( n ) => n + rangeStart ) . some ( ( n ) => Math . pow ( parseInt ( Math . sqrt ( n ) ) , 2 ) == n ) ; return containsSquare ; } 
function groupNumbersByMod ( numbers , mod ) { var numberGroups = numbers . reduce ( function ( acc , n ) { var remainder = n % mod ; if ( ! acc [ remainder ] ) acc [ remainder ] = [ ] ; acc [ remainder ] . push ( n ) ; return acc ; } , { } ) ; return numberGroups ; } 
function groupWordsByFirstChar ( words ) { var wordGroups = words . reduce ( function ( acc , cur ) { var firstChar = cur . charAt ( 0 ) ; if ( ! acc [ firstChar ] ) { acc [ firstChar ] = [ ] ; } acc [ firstChar ] . push ( cur ) ; return acc ; } , { } ) ; return wordGroups ; } 
function orderByLengthAndDescending ( words ) { var sortedWords = words . sort ( function ( a , b ) { if ( a . length > b . length ) { return 1 ; } else if ( a . length < b . length ) { return - 1 ; } else { return b . localeCompare ( a ) ; } } ) ; return sortedWords ; } 
function orderFirstCharDescendingReverse ( words ) { var sortedWords = words . sort ( function ( a , b ) { if ( a . charAt ( 0 ) === b . charAt ( 0 ) ) { return a . localeCompare ( b ) ; } else { return b . charAt ( 0 ) . localeCompare ( a . charAt ( 0 ) ) ; } } ) ; return sortedWords . reverse ( ) ; } 
function getSubListOfNegative ( numbers , start , length ) { const subList = numbers . slice ( start ) . filter ( n => n < 0 ) . slice ( 0 , length ) ; return subList ; } 
function getPositiveSequence ( numbers ) { const subSequence = numbers . filter ( n => n > 0 && n < Number . MAX_VALUE ) ; return subSequence ; } 
function getLargerThanIndexSequence ( numbers ) { var subSequence = numbers . filter ( function ( val , index ) { return val >= index ; } ) ; return subSequence ; } 
function rearrangeWordByIndexes ( words , indexes ) { const newIndexes = indexes . filter ( n => n >= words . length ) . map ( n => n % words . length ) ; const newWords = newIndexes . map ( n => words [ n ] ) ; return newWords ; } 
function getWordsUpperLower ( words ) { var upperLowerWords = words . map ( w => [ w . toUpperCase ( ) , w . toLowerCase ( ) ] ) ; return upperLowerWords ; } 
function selectIfInPlace ( numbers ) { const numsInPlace = numbers . map ( ( num , index ) => num === index ) ; return numsInPlace ; } 
function selectPairs ( numbersA , numbersB ) { let pairs = numbersA . flatMap ( a => numbersB . filter ( b => a < b ) . map ( b => [ a , b ] ) ) ; return pairs ; } 
function stringCrossJoin ( endWords , beginWords ) { const crossStrings = beginWords . flatMap ( b => endWords . filter ( e => b . charAt ( 0 ) === e . charAt ( e . length - 1 ) ) . map ( e => ` ${ e } ${ b } ` ) ) ; return crossStrings ; } 
function elementsContainSubword ( words , subword ) { if ( words . slice ( 0 , 5 ) . every ( w => w . includes ( subword ) ) ) { return 1 ; } else if ( words . slice ( 0 , 5 ) . some ( w => w . includes ( subword ) ) ) { return 0 ; } else { return - 1 ; } } 
function ConcatLargeNumbers ( numbersA , numbersB , flag ) { let allNumbers = numbersA . filter ( n => n > flag ) . concat ( numbersB . filter ( n => n > flag ) ) ; return allNumbers ; } 
function dotProduct ( vectorA , vectorB ) { let dotProduct = vectorA . map ( ( element , index ) => { return element * vectorB [ index ] ; } ) . reduce ( ( accumulator , currentValue ) => { return accumulator + currentValue ; } ) ; return dotProduct ; } 
function setDifference ( setA , setB ) { let difference = [ ... setA ] ; difference . push ( ... setB ) ; let intersection = [ ... setA ] ; intersection = intersection . filter ( ( val ) => setB . includes ( val ) ) ; difference = difference . filter ( ( val ) => ! intersection . includes ( val ) ) ; difference . sort ( ( a , b ) => a - b ) ; return difference ; } 
