def greatestCommonDivisor ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return a + b NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return greatestCommonDivisor ( a % b , b ) NEW_LINE DEDENT else : NEW_LINE INDENT return greatestCommonDivisor ( a , b % a ) NEW_LINE DEDENT DEDENT
def largestDivisor ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return n // i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return False NEW_LINE DEDENT for k in range ( 2 , n ) : NEW_LINE INDENT if n % k == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def fizzBuzz ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 11 == 0 or i % 13 == 0 ) : NEW_LINE INDENT q = i NEW_LINE while ( q > 0 ) : NEW_LINE INDENT if ( q % 10 == 7 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT q = trunc ( q / 10 ) NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def primeFib ( n ) : NEW_LINE INDENT f0 = 0 NEW_LINE f1 = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT p = f0 + f1 NEW_LINE isPrime = p >= 2 NEW_LINE for i in range ( 2 , p ) : NEW_LINE INDENT if ( p % i == 0 ) : NEW_LINE INDENT isPrime = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( isPrime ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT f0 = f1 NEW_LINE f1 = p NEW_LINE DEDENT return f1 NEW_LINE DEDENT
def triangleArea ( a , h ) : NEW_LINE INDENT return a * h / 2 NEW_LINE DEDENT
def modp ( n , p ) : NEW_LINE INDENT ret = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ret = ( ret * 2 ) % p NEW_LINE DEDENT return ret NEW_LINE DEDENT
def add ( x , y ) : NEW_LINE INDENT return x + y NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT
def largestPrimeFactor ( n ) : NEW_LINE INDENT for i in range ( 2 , n ) : NEW_LINE INDENT while ( n % i == 0 and n > i ) : NEW_LINE INDENT n //= i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def sumToN ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT result += i NEW_LINE DEDENT return result NEW_LINE DEDENT
def fibfib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return fibfib ( n - 1 ) + fibfib ( n - 2 ) + fibfib ( n - 3 ) NEW_LINE DEDENT
def isMultiplyPrime ( a ) : NEW_LINE INDENT num = 0 NEW_LINE for i in range ( 2 , a + 1 ) : NEW_LINE INDENT while ( a % i == 0 and a >= i ) : NEW_LINE INDENT a //= i NEW_LINE num += 1 NEW_LINE DEDENT DEDENT return num == 3 NEW_LINE DEDENT
def isSimplePower ( x , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return x == 1 NEW_LINE DEDENT power = 1 NEW_LINE while ( power < x ) : NEW_LINE INDENT power *= n NEW_LINE DEDENT return power == x NEW_LINE DEDENT
def chooseNum ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( y % 2 == 0 ) : NEW_LINE INDENT return y NEW_LINE DEDENT if ( x == y ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return y - 1 NEW_LINE DEDENT
def isEqualToSumEven ( n ) : NEW_LINE INDENT return n % 2 == 0 and n >= 8 NEW_LINE DEDENT
def specialFactorial ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE specialFact = 1 NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT fact *= i NEW_LINE specialFact *= fact NEW_LINE DEDENT return specialFact NEW_LINE DEDENT
def xOrY ( n , x , y ) : NEW_LINE INDENT isPrime = n >= 2 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT isPrime = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( isPrime ) : NEW_LINE INDENT return x NEW_LINE DEDENT return y NEW_LINE DEDENT
def rightAngleTriangle ( a , b , c ) : NEW_LINE INDENT return ( a * a == b * b + c * c or b * b == a * a + c * c ) NEW_LINE DEDENT
def fastPow ( n , k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = fastPow ( n , k // 2 ) NEW_LINE if ( k % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT return n * temp * temp NEW_LINE DEDENT DEDENT
def isPalin ( s ) : NEW_LINE INDENT l = len ( s ) // 2 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] != s [ len ( s ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = i - 1 NEW_LINE num = 1 NEW_LINE while ( temp < n ) : NEW_LINE INDENT if ( temp + i <= n ) : NEW_LINE INDENT ans += i * num NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( n - temp ) * num NEW_LINE DEDENT temp += i NEW_LINE num += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def getNextGap ( gap ) : NEW_LINE INDENT gap = gap * 10 // 13 NEW_LINE if ( gap < 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return gap NEW_LINE DEDENT
def countNonDecreasing ( n ) : NEW_LINE INDENT k = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count *= k + i - 1 NEW_LINE count = count // i NEW_LINE DEDENT return count NEW_LINE DEDENT
def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y % 2 == 0 ) : NEW_LINE INDENT return power ( x , trunc ( y / 2 ) ) * power ( x , trunc ( y / 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return x * power ( x , trunc ( y / 2 ) ) * power ( x , trunc ( y / 2 ) ) NEW_LINE DEDENT DEDENT
def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = power ( x , y // 2 ) NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT if ( y > 0 ) : NEW_LINE INDENT return x * temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT return temp * temp // x NEW_LINE DEDENT DEDENT DEDENT
def multiply ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( y > 0 ) : NEW_LINE INDENT return x + multiply ( x , y - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return - multiply ( x , - y ) NEW_LINE DEDENT DEDENT
def smallest ( x , y , z ) : NEW_LINE INDENT if ( not trunc ( y / x ) ) : NEW_LINE INDENT return not trunc ( y / z ) ? y : z NEW_LINE DEDENT return not trunc ( x / z ) ? x : z NEW_LINE DEDENT
def isPowerOfFour ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 4 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 4 NEW_LINE DEDENT return True NEW_LINE DEDENT
def modInverse ( a , m ) : NEW_LINE INDENT m0 , x0 , x1 = m , 0 , 1 NEW_LINE if m == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT while a > 1 : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m , a = a % m , t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if x1 < 0 : NEW_LINE INDENT x1 += m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT
def cntRotations ( s , n ) : NEW_LINE INDENT s2 = s + s NEW_LINE pre = [ 0 for i in range ( 2 * n ) ] NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] NEW_LINE DEDENT if ( s2 [ i ] == 'a' or s2 [ i ] == 'e' or s2 [ i ] == 'i' or s2 [ i ] == 'o' or s2 [ i ] == 'u' ) : NEW_LINE INDENT pre [ i ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n - 1 , 2 * n - 1 ) : NEW_LINE INDENT r = i NEW_LINE l = i - n NEW_LINE x1 = pre [ r ] NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT x1 -= pre [ l ] NEW_LINE DEDENT right = x1 - left NEW_LINE if ( left > right ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT res *= n - i NEW_LINE res = trunc ( res / ( i + 1 ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def isPrefix ( temp , s ) : NEW_LINE INDENT if ( len ( temp ) < len ( s ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != temp [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
def lexicographicallySmallestString ( s , n ) : NEW_LINE INDENT lastZe = - 1 NEW_LINE ans = "" NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT lastZe = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i <= lastZe and s [ i ] == '0' ) : NEW_LINE INDENT ans += s [ i ] NEW_LINE DEDENT elif ( i > lastZe ) : NEW_LINE INDENT ans += s [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def calculateMax ( n , m , k ) : NEW_LINE INDENT ans = - 1 NEW_LINE low , high = 0 , m NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = trunc ( ( low + high ) / 2 ) NEW_LINE val = 0 NEW_LINE l = k - 1 NEW_LINE r = n - k NEW_LINE val += mid NEW_LINE if ( mid >= l ) : NEW_LINE INDENT val += l * ( 2 * mid - l - 1 ) / 2 NEW_LINE DEDENT else : NEW_LINE INDENT val += mid * ( mid - 1 ) / 2 + ( l - mid ) NEW_LINE DEDENT if ( mid >= r ) : NEW_LINE INDENT val += r * ( 2 * mid - r - 1 ) / 2 NEW_LINE DEDENT else : NEW_LINE INDENT val += mid * ( mid - 1 ) / 2 + ( r - mid ) NEW_LINE DEDENT if ( val <= m ) : NEW_LINE INDENT ans = max ( ans , mid ) NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def findLength ( s , i , j ) : NEW_LINE INDENT required = i NEW_LINE length = 0 NEW_LINE for curr in s : NEW_LINE INDENT if ( curr == required ) : NEW_LINE INDENT length += 1 NEW_LINE if ( required == i ) : NEW_LINE INDENT required = j NEW_LINE DEDENT else : NEW_LINE INDENT required = i NEW_LINE DEDENT DEDENT DEDENT return length NEW_LINE DEDENT
def checkReverse ( leftSum , rightSum ) : NEW_LINE INDENT rev = 0 NEW_LINE temp = rightSum NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT rev = rev * 10 + temp % 10 NEW_LINE temp = temp // 10 NEW_LINE DEDENT if ( rev == leftSum ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT
def minDeletion ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE firstIdx1 = - 1 NEW_LINE lastIdx0 = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT firstIdx1 = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT lastIdx0 = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( firstIdx1 == - 1 or lastIdx0 == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count1 = 0 NEW_LINE count0 = 0 NEW_LINE for i in range ( firstIdx1 + 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT DEDENT for i in range ( firstIdx1 + 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT DEDENT return min ( count0 , count1 ) NEW_LINE DEDENT
def minSteps ( s , n ) : NEW_LINE INDENT smaller = 0 NEW_LINE cost = 0 NEW_LINE f = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT currEle = ord ( s [ i ] ) - ord ( 'a' ) NEW_LINE smaller = 0 NEW_LINE for j in range ( currEle + 1 ) : NEW_LINE INDENT if ( f [ j ] != 0 ) : NEW_LINE INDENT smaller += f [ j ] NEW_LINE DEDENT DEDENT if ( smaller == 0 ) : NEW_LINE INDENT cost += i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT cost += ( i - smaller + 1 ) NEW_LINE DEDENT f [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1 NEW_LINE DEDENT return cost NEW_LINE DEDENT
def numberOfWays ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for a in range ( 1 , n ) : NEW_LINE INDENT for b in range ( 1 , n ) : NEW_LINE INDENT c = n - ( a + b ) NEW_LINE if ( a + b > c and a + c > b and b + c > a ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def slopeOfNum ( num , n ) : NEW_LINE INDENT slope = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( num [ i ] > num [ i - 1 ] and num [ i ] > num [ i + 1 ] ) : NEW_LINE INDENT slope += 1 NEW_LINE DEDENT elif ( num [ i ] < num [ i - 1 ] and num [ i ] < num [ i + 1 ] ) : NEW_LINE INDENT slope += 1 NEW_LINE DEDENT DEDENT return slope NEW_LINE DEDENT
def middleOfThree ( a , b , c ) : NEW_LINE INDENT x = a - b NEW_LINE y = b - c NEW_LINE z = a - c NEW_LINE if ( x * y > 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT elif ( x * z > 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT
def countMaxSetBits ( left , right ) : NEW_LINE INDENT while ( ( left | ( left + 1 ) ) <= right ) : NEW_LINE INDENT left |= left + 1 NEW_LINE DEDENT return left NEW_LINE DEDENT
def findS ( s ) : NEW_LINE INDENT l = 1 NEW_LINE r = int ( s / 2 ) + 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE sum = mid * ( mid + 1 ) // 2 NEW_LINE if ( sum == s ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( sum > s ) : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def check ( s ) : NEW_LINE INDENT min = sys . maxsize NEW_LINE max = - sys . maxsize NEW_LINE sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ascii = ord ( s [ i ] ) NEW_LINE if ( ascii < 96 or ascii > 122 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += ascii NEW_LINE if ( min > ascii ) : NEW_LINE INDENT min = ascii NEW_LINE DEDENT if ( max < ascii ) : NEW_LINE INDENT max = ascii NEW_LINE DEDENT DEDENT min -= 1 NEW_LINE eSum = max * ( max + 1 ) // 2 - min * ( min + 1 ) // 2 NEW_LINE return sum == eSum NEW_LINE DEDENT
def minimumPossibleProduct ( k ) : NEW_LINE INDENT res = 1 NEW_LINE r = ( 1 << k ) - 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT res *= r - 1 NEW_LINE DEDENT res *= r NEW_LINE return res NEW_LINE DEDENT
def findInGrid ( i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return i * i - ( i - 1 ) NEW_LINE DEDENT elif ( i > j ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT return i * i - ( j - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( i - 1 ) * ( i - 1 ) + 1 + ( j - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( j % 2 == 0 ) : NEW_LINE INDENT return ( j - 1 ) * ( j - 1 ) + 1 + ( i - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( j * j - ( i - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT
def findMinOperationsReqEmpStr ( s ) : NEW_LINE INDENT cntOne = 0 NEW_LINE cntZero = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT if ( cntOne != 0 ) : NEW_LINE INDENT cntOne -= 1 NEW_LINE DEDENT cntZero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( cntZero != 0 ) : NEW_LINE INDENT cntZero -= 1 NEW_LINE DEDENT cntOne += 1 NEW_LINE DEDENT DEDENT return cntOne + cntZero NEW_LINE DEDENT
def isReachable ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT while ( x2 > x1 and y2 > y1 ) : NEW_LINE INDENT if ( x2 > y2 ) : NEW_LINE INDENT x2 %= y2 NEW_LINE DEDENT else : NEW_LINE INDENT y2 %= x2 NEW_LINE DEDENT DEDENT if ( x2 == x1 ) : NEW_LINE INDENT return ( y2 - y1 ) >= 0 and ( y2 - y1 ) % x1 == 0 NEW_LINE DEDENT elif ( y2 == y1 ) : NEW_LINE INDENT return ( x2 - x1 ) >= 0 and ( x2 - x1 ) % y1 == 0 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def findMaxSoln ( n , x , y ) : NEW_LINE INDENT ans = - sys . maxsize - 1 NEW_LINE for k in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( k % x == y ) : NEW_LINE INDENT ans = max ( ans , k ) NEW_LINE DEDENT DEDENT if ans >= 0 and ans <= n : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def numberOfPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( i + j == n ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def minChanges ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE zeros = 0 NEW_LINE ones = 0 NEW_LINE if ( s [ 0 ] != '1' ) : NEW_LINE INDENT count += 1 NEW_LINE ones += 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT if ( zeros > ones ) : NEW_LINE INDENT zeros -= 1 NEW_LINE ones += 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def kVisibleFromLeft ( n , k ) : NEW_LINE INDENT if ( n == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 1 ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans *= i NEW_LINE DEDENT return ans NEW_LINE DEDENT
def find ( n , sum ) : NEW_LINE INDENT if ( sum > 6 * n or sum < n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT if ( sum >= 1 and sum <= 6 ) : NEW_LINE INDENT return 1.0 / 6 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT s = 0 NEW_LINE for i in range ( 1 , 6 ) : NEW_LINE INDENT s += find ( n - 1 , sum - i ) // 6 NEW_LINE DEDENT return s NEW_LINE DEDENT
def binCoff ( n , r ) : NEW_LINE INDENT val = 1 NEW_LINE if ( r > n - r ) : NEW_LINE INDENT r = n - r NEW_LINE DEDENT for i in range ( 0 , r , 1 ) : NEW_LINE INDENT val *= n - i NEW_LINE val //= i + 1 NEW_LINE DEDENT return val NEW_LINE DEDENT
def getMask ( val ) : NEW_LINE INDENT mask = 0 NEW_LINE if ( val == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( val != 0 ) : NEW_LINE INDENT d = val % 10 NEW_LINE mask |= ( 1 << d ) NEW_LINE val //= 10 NEW_LINE DEDENT return mask NEW_LINE DEDENT
def waysToKAdjacentSetBits ( n , k , currentIndex , adjacentSetBits , lastBit ) : NEW_LINE INDENT if ( currentIndex == n ) : NEW_LINE INDENT if ( adjacentSetBits == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT noOfWays = 0 NEW_LINE if ( lastBit == 1 ) : NEW_LINE INDENT noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) NEW_LINE noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) NEW_LINE DEDENT elif ( not lastBit ) : NEW_LINE INDENT noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) NEW_LINE noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) NEW_LINE DEDENT return noOfWays NEW_LINE DEDENT
def checkFunc ( i , j , st ) : NEW_LINE INDENT if ( st [ i ] == "(" and st [ j ] == ")" ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( st [ i ] == "?" and st [ j ] == ")" ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( st [ i ] == "[" and st [ j ] == "]" ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( st [ i ] == "?" and st [ j ] == "?" ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( st [ i ] == "[" and st [ j ] == "?" ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( st [ i ] == "?" and st [ j ] == "]" ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( st [ i ] == "{" and st [ j ] == "}" ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( st [ i ] == "?" and st [ j ] == ")" ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def findGolomb ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( 1 + findGolomb ( n - findGolomb ( findGolomb ( n - 1 ) ) ) NEW_LINE DEDENT
def allOnes ( s , n ) : NEW_LINE INDENT co = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT co += 1 NEW_LINE DEDENT return co == n NEW_LINE DEDENT
def pad ( n ) : NEW_LINE INDENT pPrevPrev = 1 NEW_LINE pPrev = 1 NEW_LINE pCurr = 1 NEW_LINE pNext = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT pNext = pPrevPrev + pPrev NEW_LINE pPrevPrev = pPrev NEW_LINE pPrev = pCurr NEW_LINE pCurr = pNext NEW_LINE DEDENT return pNext NEW_LINE DEDENT
def oddLengthPalindrome ( k ) : NEW_LINE INDENT palin = k NEW_LINE k = trunc ( k / 10 ) NEW_LINE while ( k > 0 ) : NEW_LINE INDENT rev = k % 10 NEW_LINE palin = palin * 10 + rev NEW_LINE k = trunc ( k / 10 ) NEW_LINE DEDENT return palin NEW_LINE DEDENT
def changeString ( s0 ) : NEW_LINE INDENT s = list ( s0 ) NEW_LINE n = len ( s0 ) NEW_LINE if ( s [ 0 ] == "?" ) : NEW_LINE INDENT s [ 0 ] = 'a' NEW_LINE if ( s [ 0 ] == s [ 1 ] ) : NEW_LINE INDENT s [ 0 ] = chr ( s [ 0 ] + 1 ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( s [ i ] == "?" ) : NEW_LINE INDENT s [ i ] = 'a' NEW_LINE if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT s [ i ] = chr ( s [ i ] + 1 ) NEW_LINE DEDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT s [ i ] = chr ( s [ i ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT if ( s [ n - 1 ] == "?" ) : NEW_LINE INDENT s [ n - 1 ] = 'a' NEW_LINE if ( s [ n - 1 ] == s [ n - 2 ] ) : NEW_LINE INDENT s [ n - 1 ] = chr ( s [ n - 1 ] ) + 1 NEW_LINE DEDENT DEDENT return s [ 0 ] NEW_LINE DEDENT
def totalHammingDistance ( n ) : NEW_LINE INDENT i = 1 NEW_LINE sum = 0 NEW_LINE while ( n // i > 0 ) : NEW_LINE INDENT sum = sum + n // i NEW_LINE i = i * 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def checkBitonic ( s ) : NEW_LINE INDENT i = 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] > s [ i - 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] <= s [ i - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == len ( s ) - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT j = i + 1 NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ j ] < s [ j - 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ j ] >= s [ j - 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT i = j NEW_LINE if ( i != len ( s ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT
def endsWith ( str , pat ) : NEW_LINE INDENT patLen = len ( pat ) NEW_LINE strLen = len ( str ) NEW_LINE if ( patLen > strLen ) : NEW_LINE INDENT return False NEW_LINE DEDENT patLen -= 1 NEW_LINE strLen -= 1 NEW_LINE while ( patLen >= 0 ) : NEW_LINE INDENT if ( pat [ patLen ] != str [ strLen ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT patLen -= 1 NEW_LINE strLen -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def getSum ( n , d ) : NEW_LINE INDENT if ( n < d ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n % 10 != d ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT k = int ( n / 10 ) NEW_LINE return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) // 2 NEW_LINE DEDENT
def balancedStringBySwapping ( s ) : NEW_LINE INDENT unbalancedPair = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( unbalancedPair > 0 and s [ i ] == "]" ) : NEW_LINE INDENT unbalancedPair -= 1 NEW_LINE DEDENT elif ( s [ i ] == "[" ) : NEW_LINE INDENT unbalancedPair += 1 NEW_LINE DEDENT DEDENT return ( unbalancedPair + 1 ) // 2 NEW_LINE DEDENT
def computeHash ( s ) : NEW_LINE INDENT p = 31 NEW_LINE mod = 1e9 + 7 NEW_LINE hashVal = 0 NEW_LINE mul = 1 NEW_LINE for ch in s : NEW_LINE INDENT hashVal = ( hashVal + ( ord ( ch ) - ord ( 'a' ) + 1 ) * mul ) % mod NEW_LINE mul = mul * p % mod NEW_LINE DEDENT return hashVal NEW_LINE DEDENT
def countOfSubstringWithOnlyOnes ( s ) : NEW_LINE INDENT res = 0 NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT res = res + count NEW_LINE DEDENT return res NEW_LINE DEDENT
def composite ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE c = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % j == 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if c >= 3 : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT return flag NEW_LINE DEDENT
def isDivBySix ( s , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ord ( s [ i ] ) - ord ( 'a' ) + 1 NEW_LINE DEDENT if ( sum % 3 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT lastDigit = ( ord ( s [ n - 1 ] ) - ord ( 'a' ) + 1 ) % 10 NEW_LINE if ( lastDigit % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def isRedundantBraces ( s ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == "(" and s [ i + 2 ] == ")" ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( s [ i ] == "*" or s [ i ] == "+" or s [ i ] == "-" or s [ i ] == "/" ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT if ( s [ i ] == "(" ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT if ( b > a ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def countSubStr ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( s [ i ] == '0' and s [ i + 1 ] == '1' and s [ i + 2 ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE i += 3 NEW_LINE DEDENT elif ( s [ i ] == '1' and s [ i + 1 ] == '0' and s [ i + 2 ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE i += 3 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def prefixOccurrences ( s ) : NEW_LINE INDENT c = s [ 0 ] NEW_LINE countC = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == c ) : NEW_LINE INDENT countC += 1 NEW_LINE DEDENT DEDENT return countC NEW_LINE DEDENT
def isValid ( s , lenn ) : NEW_LINE INDENT for i in range ( 1 , lenn ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def count ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE d = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d += ord ( s [ i ] ) NEW_LINE DEDENT if ( d % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT prev = s [ i - k ] NEW_LINE d -= prev [ 0 ] NEW_LINE d += ord ( s [ i ] ) NEW_LINE if ( d % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def findSubstringCount ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE i = 0 NEW_LINE while ( i < n - 1 ) : NEW_LINE INDENT if ( s [ i ] [ 0 ] + 1 == s [ i + 1 ] [ 0 ] ) : NEW_LINE INDENT result += 1 NEW_LINE while ( i < n - 1 and s [ i ] [ 0 ] + 1 == s [ i + 1 ] [ 0 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT
def find ( s1 , s2 ) : NEW_LINE INDENT len1 = len ( s1 ) NEW_LINE len2 = len ( s2 ) NEW_LINE if ( len1 != len2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d = [ 0 ] * len1 NEW_LINE d [ 0 ] = s2 [ 0 ] - s1 [ 0 ] NEW_LINE for i in range ( 1 , len1 ) : NEW_LINE INDENT if ( s1 [ i ] > s2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = ( ord ( s2 [ i ] ) - ord ( s1 [ i ] ) ) NEW_LINE DEDENT DEDENT for i in range ( len1 - 1 ) : NEW_LINE INDENT if ( d [ i ] < d [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def isInGivenBase ( s , bas ) : NEW_LINE INDENT if ( bas > 16 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( bas <= 10 ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( not ( ord ( s [ i ] ) >= ord ( '0' ) and s [ i ] < ord ( '0' ) + bas ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( not ( ( ord ( s [ i ] ) >= ord ( '0' ) and s [ i ] < ord ( '0' ) + bas ) or ( ord ( s [ i ] ) >= ord ( 'A' ) and s [ i ] < ord ( 'A' ) + bas - 10 ) ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def countNonEmptySubstr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE return n * ( n + 1 ) // 2 NEW_LINE DEDENT
def evenDecimalValue ( s , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT decimalValue = 0 NEW_LINE powerOf2 = 1 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT decimalValue += ( ord ( s [ k ] ) - ord ( '0' ) ) * powerOf2 NEW_LINE powerOf2 *= 2 NEW_LINE DEDENT if ( decimalValue % 2 == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def calculate ( s ) : NEW_LINE INDENT ans = 6 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT for k in range ( 10 ) : NEW_LINE INDENT for l in range ( 10 ) : NEW_LINE INDENT for m in range ( 10 ) : NEW_LINE INDENT for n in range ( 10 ) : NEW_LINE INDENT if ( i + j + k == l + m + n ) : NEW_LINE INDENT c = 0 NEW_LINE if ( j != s [ 1 ] [ 0 ] - '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( k != s [ 2 ] [ 0 ] - '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( l != s [ 4 ] [ 0 ] - '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( n != s [ 5 ] [ 0 ] - '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( c < ans ) : NEW_LINE INDENT ans = c NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def xorZero ( s ) : NEW_LINE INDENT oneCount = 0 NEW_LINE zeroCount = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT oneCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zeroCount += 1 NEW_LINE DEDENT DEDENT if ( oneCount % 2 == 0 ) : NEW_LINE INDENT return zeroCount NEW_LINE DEDENT return oneCount NEW_LINE DEDENT
def evenLength ( n ) : NEW_LINE INDENT res = n NEW_LINE for j in range ( len ( n ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT res += n [ j ] NEW_LINE DEDENT return res NEW_LINE DEDENT
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def normalSlope ( a , b , x1 , y1 ) : NEW_LINE INDENT g = a / 2 NEW_LINE f = b / 2 NEW_LINE if ( g - x1 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT slope = ( f - y1 ) / ( g - x1 ) NEW_LINE if ( slope == 0 ) : NEW_LINE INDENT return - 2 NEW_LINE DEDENT return slope NEW_LINE DEDENT
def orthogonality ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT dsquare = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) NEW_LINE if ( dsquare == r1 * r1 + r2 * r2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def findAreaShaded ( a ) : NEW_LINE INDENT sqArea = a * a NEW_LINE semiCircleArea = 3.14 * ( a * a ) / 8 NEW_LINE shadedArea = 4 * semiCircleArea - sqArea NEW_LINE return shadedArea NEW_LINE DEDENT
def factorial ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , a + b + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT for i in range ( 1 , a + 1 ) : NEW_LINE INDENT res = res // i NEW_LINE DEDENT for i in range ( 1 , b + 1 ) : NEW_LINE INDENT res = res // i NEW_LINE DEDENT return res NEW_LINE DEDENT
def factorTree ( n ) : NEW_LINE INDENT height = 0 NEW_LINE while ( n > 1 ) : NEW_LINE INDENT flag = False NEW_LINE for i in range ( 2 , int ( n ** ( 0.5 ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT height += 1 NEW_LINE if ( flag ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return height NEW_LINE DEDENT
def findIfPossible ( n , s , x ) : NEW_LINE INDENT if ( s >= x and s % 2 == x % 2 ) : NEW_LINE INDENT if ( n >= 3 ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT if ( s == x ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT else : NEW_LINE INDENT return "No" NEW_LINE DEDENT DEDENT if ( n == 2 ) : NEW_LINE INDENT c = ( s - x ) // 2 NEW_LINE a = c NEW_LINE b = c NEW_LINE a = a + x NEW_LINE if ( ( a ^ b ) == x ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT else : NEW_LINE INDENT return "No" NEW_LINE DEDENT DEDENT DEDENT return 'Yes' NEW_LINE DEDENT
def maximumTripletXor ( a , b , c ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 30 , - 1 , - 1 ) : NEW_LINE INDENT cur = 1 << i NEW_LINE if ( a >= cur ) : NEW_LINE INDENT ans += cur NEW_LINE a -= cur NEW_LINE DEDENT elif ( b >= cur ) : NEW_LINE INDENT ans += cur NEW_LINE b -= cur NEW_LINE DEDENT elif ( c >= cur ) : NEW_LINE INDENT ans += cur NEW_LINE c -= cur NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def itemType ( n ) : NEW_LINE INDENT count = 0 NEW_LINE day = 1 NEW_LINE while ( count + day * ( day + 1 ) // 2 < n ) : NEW_LINE INDENT count += day * ( day + 1 ) // 2 NEW_LINE day += 1 NEW_LINE DEDENT for type in range ( day , 0 , - 1 ) : NEW_LINE INDENT count += type NEW_LINE if ( count >= n ) : NEW_LINE INDENT return type NEW_LINE DEDENT DEDENT DEDENT
def maxGcdInRange ( l , r ) : NEW_LINE INDENT ans = 1 NEW_LINE for z in range ( r , 0 , - 1 ) : NEW_LINE INDENT if ( ( r // z ) - ( l - 1 ) / z ) > 1 ) : NEW_LINE INDENT ans = z NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def sumOfDigits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def isRepUnitNum ( n , b ) : NEW_LINE INDENT length = 0 NEW_LINE countOne = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % b NEW_LINE length += 1 NEW_LINE if ( r == 1 ) : NEW_LINE INDENT countOne += 1 NEW_LINE DEDENT n = n // b NEW_LINE DEDENT return countOne >= 3 and countOne == length NEW_LINE DEDENT
def isStraightLineNum ( n ) : NEW_LINE INDENT if ( n <= 99 ) : NEW_LINE INDENT return False NEW_LINE DEDENT s = str ( n ) NEW_LINE d = s [ 1 ] - s [ 0 ] NEW_LINE for i in range ( 2 , len ( s ) ) : NEW_LINE INDENT if ( ( s [ i ] - s [ i - 1 ] ) != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def getCount ( d , n ) : NEW_LINE INDENT no = n // d NEW_LINE result = no NEW_LINE for p in range ( 2 , no + 1 ) : NEW_LINE INDENT if p * p > no : NEW_LINE INDENT break NEW_LINE DEDENT if ( no % p == 0 ) : NEW_LINE INDENT while ( no % p == 0 ) : NEW_LINE INDENT no = trunc ( no // p ) NEW_LINE DEDENT result = trunc ( result - result / p ) NEW_LINE DEDENT DEDENT if ( no > 1 ) : NEW_LINE INDENT result = trunc ( result - result / no ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def isEvenParity ( x ) : NEW_LINE INDENT parity = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT if ( x % 2 == 1 ) : NEW_LINE INDENT parity += 1 NEW_LINE DEDENT x = x >> 1 NEW_LINE DEDENT if ( parity % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def isPerfect ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i * i != n ) : NEW_LINE INDENT sum = sum + i + n // i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT DEDENT if ( sum == n and n != 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def logAToBaseB ( a , b ) : NEW_LINE INDENT return a > b - 1 ? 1 + logAToBaseB ( a // b , b ) : 0 NEW_LINE DEDENT
def usingBinarySearch ( start , end , n , s ) : NEW_LINE INDENT if start >= end : NEW_LINE INDENT return start NEW_LINE DEDENT mid = start + ( end - start ) // 2 NEW_LINE totalSum = n * ( n + 1 ) // 2 NEW_LINE midSum = mid * ( mid + 1 ) // 2 NEW_LINE if ( totalSum - midSum <= s ) : NEW_LINE INDENT return usingBinarySearch ( start , mid , n , s ) NEW_LINE DEDENT return usingBinarySearch ( mid + 1 , end , n , s ) NEW_LINE DEDENT
def minInt ( s ) : NEW_LINE INDENT s1 = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s1 [ i ] >= '5' ) : NEW_LINE INDENT s1 [ i ] = chr ( ord ( '9' ) - ord ( s1 [ i ] ) + ord ( '0' ) ) NEW_LINE DEDENT DEDENT if ( s1 [ 0 ] == '0' ) : NEW_LINE INDENT s1 [ 0 ] = '9' NEW_LINE DEDENT return s1 [ 0 ] NEW_LINE DEDENT
def countTriplets ( a , b , c ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , a + 1 ) : NEW_LINE INDENT for j in range ( 1 , b + 1 ) : NEW_LINE INDENT for k in range ( 1 , c + 1 ) : NEW_LINE INDENT if ( i * k > j * j ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def topsyTurvy ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '2' or s [ i ] == '4' or s [ i ] == '5' or s [ i ] == '6' or s [ i ] == '7' or s [ i ] == '9' ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def sumOfLastDig ( n , m ) : NEW_LINE INDENT sum = 0 NEW_LINE k = n // m NEW_LINE arr = [ 0 ] * 10 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT arr [ i ] = m * ( i + 1 ) % 10 NEW_LINE sum += arr [ i ] NEW_LINE DEDENT rem = k % 10 NEW_LINE ans = trunc ( k // 10 ) * sum NEW_LINE for i in range ( rem ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def totalPay ( totalItems , priceOfOneItem , n , m ) : NEW_LINE INDENT freeItems = 0 NEW_LINE actual = 0 NEW_LINE freeItems = totalItems // ( n + m ) NEW_LINE actual = totalItems - freeItems NEW_LINE amount = actual * priceOfOneItem NEW_LINE return amount NEW_LINE DEDENT
def minOperations ( x , y , p , q ) : NEW_LINE INDENT if ( y % x != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = y // x NEW_LINE a = 0 NEW_LINE while ( d % p == 0 ) : NEW_LINE INDENT d = trunc ( d / p ) NEW_LINE a += 1 NEW_LINE DEDENT b = 0 NEW_LINE while ( d % q == 0 ) : NEW_LINE INDENT d = trunc ( d / q ) NEW_LINE b += 1 NEW_LINE DEDENT if ( d != 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return a + b NEW_LINE DEDENT
def isMersenne ( n ) : NEW_LINE INDENT while ( n != 0 ) : NEW_LINE INDENT r = n % 2 NEW_LINE if ( r == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 2 NEW_LINE DEDENT return True NEW_LINE DEDENT
def findThirdDigit ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return n & 1 ? 1 : 6 NEW_LINE DEDENT
def isOddLength ( num ) : NEW_LINE INDENT count = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT num = num // 10 NEW_LINE count += 1 NEW_LINE DEDENT if ( count % 2 != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def Check_is_possible ( l , r , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count > 1 NEW_LINE DEDENT
def bytes ( kilobytes ) : NEW_LINE INDENT b = kilobytes * 1024 NEW_LINE return b NEW_LINE DEDENT
def octahedralNum ( n ) : NEW_LINE INDENT return n * ( 2 * n * n + 1 ) // 3 NEW_LINE DEDENT
def checkEqual ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != '1' and s [ i ] != '0' and s [ i ] != '8' ) : NEW_LINE INDENT return 'No' NEW_LINE DEDENT DEDENT start = 0 NEW_LINE end = len ( s ) - 1 NEW_LINE while ( start < end ) : NEW_LINE INDENT if ( s [ start ] != s [ end ] ) : NEW_LINE INDENT return 'No' NEW_LINE DEDENT start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT return 'Yes' NEW_LINE DEDENT
def isUndulating ( n ) : NEW_LINE INDENT if ( len ( n ) <= 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , len ( n ) ) : NEW_LINE INDENT if ( n [ i - 2 ] != n [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def firstDigit ( n ) : NEW_LINE INDENT while ( n >= 10 ) : NEW_LINE INDENT n = trunc ( n / 10 ) NEW_LINE DEDENT return n NEW_LINE DEDENT
def countDigit ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 1 + countDigit ( n // 10 ) ) NEW_LINE DEDENT
def isDivisibleBy5 ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE return ( s [ n - 1 ] == '0' or s [ n - 1 ] == '5' ) NEW_LINE DEDENT
def inv ( a , m ) : NEW_LINE INDENT m0 , x0 , x1 = m , 0 , 1 NEW_LINE if m == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT while a > 1 : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m , a = a % m , t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if x1 < 0 : NEW_LINE INDENT x1 += m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT
def onlyFirstAndLastAreSet ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( n - 1 ) & ( n - 2 ) ) == 0 NEW_LINE DEDENT
def divide ( dividend , divisor ) : NEW_LINE INDENT sign = ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? - 1 : 1 NEW_LINE dividend = abs ( dividend ) NEW_LINE divisor = abs ( divisor ) NEW_LINE quotient = 0 NEW_LINE temp = BigInt ( 0 ) NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT if ( ( temp + ( BigInt ( divisor ) << BigInt ( i ) ) <= dividend ) : NEW_LINE INDENT temp += BigInt ( divisor ) << BigInt ( i ) NEW_LINE quotient |= 1 << i NEW_LINE DEDENT DEDENT if ( sign == - 1 ) : NEW_LINE INDENT quotient = - quotient NEW_LINE DEDENT return quotient NEW_LINE DEDENT
def findProfession ( level , pos ) : NEW_LINE INDENT if ( level == 1 ) : NEW_LINE INDENT return 'e' NEW_LINE DEDENT if ( findProfession ( level - 1 , ( pos + 1 ) // 2 ) == 'd' ) : NEW_LINE INDENT return pos % 2 ? 'd' : 'e' NEW_LINE DEDENT return pos % 2 ? 'e' : 'd' NEW_LINE DEDENT
def hasCloseElements ( numbers , threshold ) : NEW_LINE INDENT for i in range ( len ( numbers ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( numbers ) ) : NEW_LINE INDENT distance = abs ( numbers [ i ] - numbers [ j ] ) NEW_LINE if ( distance < threshold ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def truncateNumber ( number ) : NEW_LINE INDENT return number % 1 NEW_LINE DEDENT
def belowZero ( operations ) : NEW_LINE INDENT balance = 0 NEW_LINE for op in operations : NEW_LINE INDENT balance += op NEW_LINE if ( balance < 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def meanAbsoluteDeviation ( numbers ) : NEW_LINE INDENT sumNum = 0 NEW_LINE for num in numbers : NEW_LINE INDENT sumNum += num NEW_LINE DEDENT mean = sumNum / len ( numbers ) NEW_LINE sumAbsDiff = 0 NEW_LINE for num in numbers : NEW_LINE INDENT sumAbsDiff += abs ( num - mean ) NEW_LINE DEDENT return sumAbsDiff / len ( numbers ) NEW_LINE DEDENT
def intersperse ( numbers , delimiter ) : NEW_LINE INDENT result = [ ] NEW_LINE if len ( numbers ) <= 1 : NEW_LINE INDENT return result NEW_LINE DEDENT for i in range ( len ( numbers ) - 1 ) : NEW_LINE INDENT result . append ( numbers [ i ] , delimiter ) NEW_LINE DEDENT result . append ( numbers [ - 1 ] ) NEW_LINE return result NEW_LINE DEDENT
def sumProduct ( numbers ) : NEW_LINE INDENT sumValue = 0 NEW_LINE prodValue = 1 NEW_LINE for n in numbers : NEW_LINE INDENT sumValue += n NEW_LINE prodValue *= n NEW_LINE DEDENT return [ sumValue , prodValue ] NEW_LINE DEDENT
def allPrefixes ( string ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( 1 , len ( string ) + 1 ) : NEW_LINE INDENT result . append ( string [ 0 : i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def parseMusic ( musicString ) : NEW_LINE INDENT current = [ ] NEW_LINE result = [ ] NEW_LINE for i in range ( len ( musicString ) ) : NEW_LINE INDENT if ( i == len ( musicString ) or musicString [ i ] == ' ' ) : NEW_LINE INDENT if ( current [ 0 ] == 'o' ) : NEW_LINE INDENT result . append ( 4 ) NEW_LINE DEDENT if ( current [ 0 ] == 'o|' ) : NEW_LINE INDENT result . append ( 2 ) NEW_LINE DEDENT if ( current [ 0 ] == ".|" ) : NEW_LINE INDENT result . append ( 1 ) NEW_LINE DEDENT current . length = 0 NEW_LINE DEDENT else : NEW_LINE INDENT current . append ( musicString [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def strlen ( s ) : NEW_LINE INDENT return len ( s ) NEW_LINE DEDENT
def factorize ( n ) : NEW_LINE INDENT factors = [ ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT n //= i NEW_LINE factors . append ( i ) NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT return factors NEW_LINE DEDENT
def concatenate ( strings ) : NEW_LINE INDENT result = [ ] NEW_LINE for s in strings : NEW_LINE INDENT result . append ( s ) NEW_LINE DEDENT return result . join ( "" ) NEW_LINE DEDENT
def getPositive ( l ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT if ( l [ i ] > 0 ) : NEW_LINE INDENT result . append ( l [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def sortEven ( l ) : NEW_LINE INDENT evens = [ ] NEW_LINE for i in range ( len ( l ) , 2 ) : NEW_LINE INDENT evens . append ( l [ i ] ) NEW_LINE DEDENT evens = sorted ( evens ) NEW_LINE result = [ ] NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT result . append ( evens [ i // 2 ] ) NEW_LINE DEDENT if ( i % 2 == 1 ) : NEW_LINE INDENT result . append ( l [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def decodeCyclic ( s ) : NEW_LINE INDENT output = [ ] NEW_LINE i = 0 NEW_LINE while ( i <= len ( s ) - 3 ) : NEW_LINE INDENT x = s [ i + 2 ] + s [ i : i + 2 ] NEW_LINE output . append ( x ) NEW_LINE i += 3 NEW_LINE DEDENT return join ( "" ) + s [ i : ] NEW_LINE DEDENT
def carRaceCollision ( n ) : NEW_LINE INDENT return pow ( n , 2 ) NEW_LINE DEDENT
def incrList ( l ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in l : NEW_LINE INDENT result . append ( i + 1 ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def pairsSumToZero ( l ) : NEW_LINE INDENT for i in range ( len ( l ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( l ) ) : NEW_LINE INDENT if ( l [ i ] + l [ j ] == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def changeBase ( x , b ) : NEW_LINE INDENT ret = [ ] NEW_LINE while ( x > 0 ) : NEW_LINE INDENT ret . append ( str ( x % b ) ) NEW_LINE x //= b NEW_LINE DEDENT return ret . join ( "" ) NEW_LINE DEDENT
def median ( l ) : NEW_LINE INDENT l = sorted ( l ) NEW_LINE if ( len ( l ) % 2 == 1 ) : NEW_LINE INDENT return l [ int ( length / 2 ) ] NEW_LINE DEDENT else : NEW_LINE INDENT return ( l [ length / 2 - 1 ] + l [ length / 2 ] ) / 2.0 NEW_LINE DEDENT DEDENT
def decodeShift ( s ) : NEW_LINE INDENT result = [ ] NEW_LINE for ch in s : NEW_LINE INDENT w = ord ( ch ) + 21 - ord ( 'a' ) NEW_LINE result . append ( chr ( w ) ) NEW_LINE DEDENT return result . join ( "" ) NEW_LINE DEDENT
def belowThreshold ( l , t ) : NEW_LINE INDENT for n in l : NEW_LINE INDENT if ( n >= t ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def correctBracketing ( brackets ) : NEW_LINE INDENT depth = 0 NEW_LINE for b in brackets : NEW_LINE INDENT if ( b == "<" ) : NEW_LINE INDENT depth += 1 NEW_LINE DEDENT else : NEW_LINE INDENT depth -= 1 NEW_LINE DEDENT if ( depth < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return depth == 0 NEW_LINE DEDENT
def monotonic ( l ) : NEW_LINE INDENT incr = 0 NEW_LINE decr = 0 NEW_LINE for i in range ( 1 , len ( l ) ) : NEW_LINE INDENT if ( l [ i ] > l [ i - 1 ] ) : NEW_LINE INDENT incr = 1 NEW_LINE DEDENT if ( l [ i ] < l [ i - 1 ] ) : NEW_LINE INDENT decr = 1 NEW_LINE DEDENT DEDENT return ( incr + decr ) != 2 NEW_LINE DEDENT
def derivative ( xs ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( 1 , len ( xs ) ) : NEW_LINE INDENT result . append ( i * xs [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def vowelsCount ( s ) : NEW_LINE INDENT vowels = 'aeiouAEIOU' NEW_LINE count = 0 NEW_LINE for ch in s : NEW_LINE INDENT if ( vowels . includes ( ch ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( s [ - 1 ] == 'y' or s [ - 1 ] == 'Y' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def digitSum ( s ) : NEW_LINE INDENT sum = 0 NEW_LINE for c in s : NEW_LINE INDENT if ( c == c and c != c ) : NEW_LINE INDENT sum += ord ( c ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def fruitDistribution ( s , n ) : NEW_LINE INDENT num1 = [ ] NEW_LINE num2 = [ ] NEW_LINE flag = False NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( '0' <= s [ i ] and s [ i ] <= '9' ) : NEW_LINE INDENT if ( flag == False ) : NEW_LINE INDENT num1 . append ( s [ i ] ) NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT num2 . append ( s [ i ] ) NEW_LINE DEDENT DEDENT elif ( flag and len ( num1 ) > 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT DEDENT return n - int ( num1 [ 0 ] ) - int ( num2 [ 0 ] ) NEW_LINE DEDENT
def pluck ( arr ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT if ( not result . length ) : NEW_LINE INDENT result . append ( arr [ i ] ) NEW_LINE result . append ( i ) NEW_LINE DEDENT elif ( arr [ i ] < result [ 0 ] ) : NEW_LINE INDENT result [ 0 ] = arr [ i ] NEW_LINE result [ 1 ] = i NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def strangeSortList ( lst ) : NEW_LINE INDENT res = [ ] NEW_LINE lst = sorted ( lst ) NEW_LINE l = 0 NEW_LINE r = len ( lst ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT res . append ( lst [ l ] ) NEW_LINE l += 1 NEW_LINE res . append ( lst [ r ] ) NEW_LINE r -= 1 NEW_LINE DEDENT if ( l == r ) : NEW_LINE INDENT res . append ( lst [ l ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def triangleArea ( a , b , c ) : NEW_LINE INDENT if ( a + b <= c or a + c <= b or b + c <= a ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT s = ( a + b + c ) // 2 NEW_LINE area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) NEW_LINE return area NEW_LINE DEDENT
def willItFly ( q , w ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( q ) ) : NEW_LINE INDENT if ( q [ i ] != q [ len ( q ) - 1 - i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum += q [ i ] NEW_LINE DEDENT return sum <= w NEW_LINE DEDENT
def isCube ( a ) : NEW_LINE INDENT a = abs ( a ) NEW_LINE i = round ( a ** ( 1.0 / 3. ) ) NEW_LINE return ( i ** ( 1.0 / 3. ) ) == a NEW_LINE DEDENT
def hexKey ( num ) : NEW_LINE INDENT key = "2357BD" NEW_LINE total = 0 NEW_LINE for c in range ( num ) : NEW_LINE INDENT if ( key [ c ] in key ) : NEW_LINE INDENT total += 1 NEW_LINE DEDENT DEDENT return total NEW_LINE DEDENT
def decimalToBinary ( dec ) : NEW_LINE INDENT ans = [ ] NEW_LINE if ( dec != 0 ) : NEW_LINE INDENT while ( dec > 0 ) : NEW_LINE INDENT ans . append ( ( dec % 2 ) . toString ( ) ) NEW_LINE dec //= 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans . append ( "0" ) NEW_LINE DEDENT return 'db' + ans [ 0 ] + 'db' NEW_LINE DEDENT
def primeLength ( s ) : NEW_LINE INDENT len = len ( s ) NEW_LINE if ( len < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , len ) : NEW_LINE INDENT if ( len % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def startsOneEnds ( n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 18 * pow ( 10 , n - 2 ) NEW_LINE DEDENT
def add ( lst ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , len ( lst ) , 2 ) : NEW_LINE INDENT if ( lst [ i ] % 2 == 0 ) : NEW_LINE INDENT sum += lst [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def getRow ( lst , x ) : NEW_LINE INDENT coords = [ ] NEW_LINE for i in range ( len ( lst ) ) : NEW_LINE INDENT for j in range ( len ( lst [ i ] ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( lst [ i ] [ j ] == x ) : NEW_LINE INDENT coords . append ( [ i , j ] ) NEW_LINE DEDENT DEDENT DEDENT return coords NEW_LINE DEDENT
def nextSmallest ( lst ) : NEW_LINE INDENT lst = sorted ( lst ) NEW_LINE for i in range ( 1 , len ( lst ) ) : NEW_LINE INDENT if ( lst [ i ] != lst [ i - 1 ] ) : NEW_LINE INDENT return lst [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def anyInt ( a , b , c ) : NEW_LINE INDENT if ( ( a ) != a or ( b ) != b or ( c ) != c ) : NEW_LINE INDENT return False NEW_LINE DEDENT return a + b == c or a + c == b or b + c == a NEW_LINE DEDENT
def countUpTo ( n ) : NEW_LINE INDENT primes = [ ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT p = 1 NEW_LINE for j in range ( 2 , i ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT p = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( p == 1 ) : NEW_LINE INDENT primes . append ( i ) NEW_LINE DEDENT DEDENT return primes NEW_LINE DEDENT
def closestInteger ( value ) : NEW_LINE INDENT w = float ( value ) NEW_LINE return round ( w ) NEW_LINE DEDENT
def makeAPile ( n ) : NEW_LINE INDENT reuslt = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT reuslt . append ( n + 2 * i ) NEW_LINE DEDENT return reuslt NEW_LINE DEDENT
def wordsString ( s ) : NEW_LINE INDENT current = [ ] NEW_LINE words = [ ] NEW_LINE for i in range ( len ( s ) + 1 ) : NEW_LINE INDENT if ( i == len ( s ) or s [ i ] == ' ' or s [ i ] == ',' ) : NEW_LINE INDENT if ( current . length > 0 ) : NEW_LINE INDENT words . append ( current . join ( "" ) ) NEW_LINE current . length = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT current . append ( s [ i ] ) NEW_LINE DEDENT DEDENT return words NEW_LINE DEDENT
def roundedAvg ( n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT num = ( n + m ) // 2 NEW_LINE ret = [ ] NEW_LINE while ( num > 0 ) : NEW_LINE INDENT ret . append ( str ( num % 2 ) ) NEW_LINE num //= 2 NEW_LINE DEDENT return ret . join ( "" ) NEW_LINE DEDENT
def uniqueDigits ( x ) : NEW_LINE INDENT digits = [ ] NEW_LINE for n in x : NEW_LINE INDENT isUnique = True NEW_LINE for c in n : NEW_LINE INDENT if ( ord ( c ) % 2 == 0 ) : NEW_LINE INDENT isUnique = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( isUnique ) : NEW_LINE INDENT digits . append ( n ) NEW_LINE DEDENT DEDENT digits . sort ( ) NEW_LINE return digits NEW_LINE DEDENT
def countNums ( arr ) : NEW_LINE INDENT num = 0 NEW_LINE for n in arr : NEW_LINE INDENT neg = n < 0 ? - 1 : 1 NEW_LINE n = abs ( n ) NEW_LINE digits = [ ] NEW_LINE for c in range ( len ( n ) ) : NEW_LINE INDENT digits . append ( ord ( c ) - ord ( '0' ) ) NEW_LINE DEDENT digits [ 0 ] *= neg NEW_LINE sum = 0 NEW_LINE for d in digits : NEW_LINE INDENT sum += d NEW_LINE DEDENT if ( sum > 0 ) : NEW_LINE INDENT num += 1 NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT
def moveOneBall ( arr ) : NEW_LINE INDENT if ( not len ( arr ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT num = 0 NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT num += 1 NEW_LINE DEDENT DEDENT if ( arr [ - 1 ] > arr [ 0 ] ) : NEW_LINE INDENT num += 1 NEW_LINE DEDENT if ( num < 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def exchange ( lst1 , lst2 ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for n in lst1 : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT for n in lst2 : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if ( even >= odd ) : NEW_LINE INDENT return "YES" NEW_LINE DEDENT return "NO" NEW_LINE DEDENT
def oddCount ( lst ) : NEW_LINE INDENT results = [ ] NEW_LINE originalStr = "the number of odd elements in the string i of the input." NEW_LINE for s in lst : NEW_LINE INDENT sum = 0 NEW_LINE for d in s : NEW_LINE INDENT if ( '0' <= d and d <= '9' and d % 2 == 1 ) : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT DEDENT result = [ ] NEW_LINE for c in originalStr : NEW_LINE INDENT if ( c == 'i' ) : NEW_LINE INDENT result . append ( sum ) NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( c ) NEW_LINE DEDENT DEDENT results . append ( result [ 0 ] ) NEW_LINE DEDENT return results NEW_LINE DEDENT
def minSubArraySum ( nums ) : NEW_LINE INDENT minSum = sys . maxsize NEW_LINE sum = 0 NEW_LINE for num in nums : NEW_LINE INDENT sum += num NEW_LINE if ( minSum > sum ) : NEW_LINE INDENT minSum = sum NEW_LINE DEDENT if ( sum > 0 ) : NEW_LINE INDENT sum = 0 NEW_LINE DEDENT DEDENT return minSum NEW_LINE DEDENT
def maxFill ( grid , capacity ) : NEW_LINE INDENT res = 0 NEW_LINE for well in grid : NEW_LINE INDENT sum = 0 NEW_LINE for n in well : NEW_LINE INDENT sum += n NEW_LINE DEDENT if ( sum > 0 ) : NEW_LINE INDENT res += ( trunc ( ( sum - 1 ) // capacity ) + 1 ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def selectWords ( s , n ) : NEW_LINE INDENT vowels = "aeiouAEIOU" NEW_LINE current = [ ] NEW_LINE result = [ ] NEW_LINE consonantNum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( i == len ( s ) or s [ i ] == " " ) : NEW_LINE INDENT if ( consonantNum == n ) : NEW_LINE INDENT result . append ( current . join ( "" ) ) NEW_LINE DEDENT current . length = 0 NEW_LINE consonantNum = 0 NEW_LINE DEDENT else : NEW_LINE INDENT current . append ( s [ i ] ) NEW_LINE if ( not vowels . contains ( s [ i ] ) ) : NEW_LINE INDENT consonantNum += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def solution ( lst ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( lst ) ) : NEW_LINE INDENT if ( lst [ i ] % 2 == 1 ) : NEW_LINE INDENT sum += lst [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def addElements ( arr , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( arr [ i ] >= - 99 and arr [ i ] <= 99 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def getOddCollatz ( n ) : NEW_LINE INDENT oddCollatz = [ ] NEW_LINE while ( n != 1 ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT oddCollatz . append ( n ) NEW_LINE n = n * 3 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT n //= 2 NEW_LINE DEDENT DEDENT oddCollatz . append ( 1 ) NEW_LINE oddCollatz . sort ( ) NEW_LINE return oddCollatz NEW_LINE DEDENT
def isSorted ( lst ) : NEW_LINE INDENT for i in range ( 1 , len ( lst ) ) : NEW_LINE INDENT if ( lst [ i ] < lst [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i >= 2 and lst [ i ] == lst [ i - 1 ] and lst [ i ] == lst [ i - 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def intersection ( interval1 , interval2 ) : NEW_LINE INDENT inter1 = max ( interval1 [ 0 ] , interval2 [ 0 ] ) NEW_LINE inter2 = min ( interval1 [ 1 ] , interval2 [ 1 ] ) NEW_LINE l = inter2 - inter1 NEW_LINE if ( l < 2 ) : NEW_LINE INDENT return 'NO' NEW_LINE DEDENT for i in range ( 2 , l ) : NEW_LINE INDENT if ( l % i == 0 ) : NEW_LINE INDENT return 'NO' NEW_LINE DEDENT DEDENT return 'YES' NEW_LINE DEDENT
def prodSigns ( arr ) : NEW_LINE INDENT if ( not len ( arr ) ) : NEW_LINE INDENT return - 32768 NEW_LINE DEDENT sum = 0 NEW_LINE prods = 1 NEW_LINE for i in arr : NEW_LINE INDENT sum += abs ( i ) NEW_LINE if ( i == 0 ) : NEW_LINE INDENT prods = 0 NEW_LINE DEDENT if ( i < 0 ) : NEW_LINE INDENT prods = - prods NEW_LINE DEDENT DEDENT return sum * prods NEW_LINE DEDENT
def minPath ( grid , k ) : NEW_LINE INDENT n = len ( grid ) NEW_LINE minNum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( grid [ i ] [ j ] == 1 ) : NEW_LINE INDENT tmp = [ ] NEW_LINE if ( i != 0 ) : NEW_LINE INDENT tmp . append ( grid [ i - 1 ] [ j ] ) NEW_LINE DEDENT if ( j != 0 ) : NEW_LINE INDENT tmp . append ( grid [ i ] [ j - 1 ] ) NEW_LINE DEDENT if ( i != n - 1 ) : NEW_LINE INDENT tmp . append ( grid [ i + 1 ] [ j ] ) NEW_LINE DEDENT if ( j != n - 1 ) : NEW_LINE INDENT tmp . append ( grid [ i ] [ j + 1 ] ) NEW_LINE DEDENT minNum = min ( tmp ) NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( minNum ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def digits ( n ) : NEW_LINE INDENT prod = 0 NEW_LINE for digit in string . digits ( ) : NEW_LINE INDENT if ( digit [ 0 ] % 2 == 1 ) : NEW_LINE INDENT if ( prod == 0 ) : NEW_LINE INDENT prod = 1 NEW_LINE DEDENT prod *= digit [ 0 ] - '0' NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT
def isNested ( s ) : NEW_LINE INDENT count = 0 NEW_LINE maxCount = 0 NEW_LINE for ch in s : NEW_LINE INDENT if ( ch == "[" ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( ch == "]" ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if ( count < 0 ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT if ( count > maxCount ) : NEW_LINE INDENT maxCount = count NEW_LINE DEDENT if ( count <= maxCount - 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def sumSquares ( lst ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in lst : NEW_LINE INDENT sum += ( ceil ( i ) * ceil ( i ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def canArrange ( arr ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] <= i : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
def largestSmallestIntegers ( lst ) : NEW_LINE INDENT maxNeg = 0 NEW_LINE minPos = 0 NEW_LINE for n in lst : NEW_LINE INDENT if ( n < 0 and ( maxNeg == 0 or n > maxNeg ) ) : NEW_LINE INDENT maxNeg = n NEW_LINE DEDENT if ( n > 0 and ( minPos == 0 or n < minPos ) ) : NEW_LINE INDENT minPos = n NEW_LINE DEDENT DEDENT return ( maxNeg , minPos ) NEW_LINE DEDENT
def fixSpaces ( text ) : NEW_LINE INDENT res = [ ] NEW_LINE spaceLen = 0 NEW_LINE for i in range ( len ( text ) ) : NEW_LINE INDENT if ( i == len ( text ) or text [ i ] != ' ' ) : NEW_LINE INDENT if ( spaceLen == 1 ) : NEW_LINE INDENT res . append ( "_" ) NEW_LINE DEDENT if ( spaceLen == 2 ) : NEW_LINE INDENT res . append ( "__" ) NEW_LINE DEDENT if ( spaceLen > 2 ) : NEW_LINE INDENT res . append ( "-" ) NEW_LINE DEDENT spaceLen = 0 NEW_LINE if ( i != len ( text ) ) : NEW_LINE INDENT res . append ( text [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT spaceLen += 1 NEW_LINE DEDENT DEDENT return res . join ( "" ) NEW_LINE DEDENT
def fileNameCheck ( fileName ) : NEW_LINE INDENT digitNum = 0 NEW_LINE dotNum = 0 NEW_LINE if ( len ( fileName ) < 5 or fileName [ 0 ] == fileName [ 0 ] ) : NEW_LINE INDENT return 'No' NEW_LINE DEDENT suffix = fileName [ - 4 ] NEW_LINE if ( suffix != ".txt" and suffix != ".exe" and suffix != ".dll" ) : NEW_LINE INDENT return 'No' NEW_LINE DEDENT for c in fileName : NEW_LINE INDENT if ( '0' <= c and c <= '9' ) : NEW_LINE INDENT digitNum += 1 NEW_LINE DEDENT if ( c == '.' ) : NEW_LINE INDENT dotNum += 1 NEW_LINE DEDENT DEDENT if ( digitNum > 3 or dotNum != 1 ) : NEW_LINE INDENT return 'No' NEW_LINE DEDENT return "Yes" NEW_LINE DEDENT
def sumSquares ( lst ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( lst ) ) : NEW_LINE INDENT if ( i % 3 == 0 ) : NEW_LINE INDENT sum += lst [ i ] * lst [ i ] NEW_LINE DEDENT elif ( i % 4 == 0 ) : NEW_LINE INDENT sum += lst [ i ] * lst [ i ] * lst [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += lst [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def wordsInSentence ( sentence ) : NEW_LINE INDENT result = [ ] NEW_LINE current = [ ] NEW_LINE for i in range ( len ( sentence ) ) : NEW_LINE INDENT if ( i == len ( sentence ) or sentence [ i ] == " " ) : NEW_LINE INDENT isPrime = True NEW_LINE l = len ( current ) NEW_LINE if ( l < 2 ) : NEW_LINE INDENT isPrime = False NEW_LINE DEDENT for j in range ( 2 , l ) : NEW_LINE INDENT if ( l % j == 0 ) : NEW_LINE INDENT isPrime = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( isPrime ) : NEW_LINE INDENT result . append ( current [ 0 ] , " " ) NEW_LINE DEDENT current . length = 0 NEW_LINE DEDENT else : NEW_LINE INDENT current . append ( sentence [ i ] ) NEW_LINE DEDENT DEDENT result = str ( result ) NEW_LINE if ( len ( result ) > 0 ) : NEW_LINE INDENT result = result [ 0 : - 1 ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def simplify ( x , n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT if ( x [ i ] == "/" ) : NEW_LINE INDENT a = int ( x [ 0 ] ) NEW_LINE b = int ( x [ i + 1 ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( n ) ) : NEW_LINE INDENT if ( n [ i ] == "/" ) : NEW_LINE INDENT c = int ( n [ 0 ] ) NEW_LINE d = int ( n [ i + 1 ] ) NEW_LINE DEDENT DEDENT return ( a * c ) % ( b * d ) == 0 NEW_LINE DEDENT
def specialFilter ( nums ) : NEW_LINE INDENT count = 0 NEW_LINE for num in nums : NEW_LINE INDENT if ( num > 10 ) : NEW_LINE INDENT w = str ( num ) NEW_LINE if ( w [ 0 ] % 2 == 1 and w [ len ( w ) - 1 ] % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def getMaxTriples ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr . append ( i * i - i + 1 ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] + arr [ j ] + arr [ k ] ) % 3 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def doubleTheDifference ( lst ) : NEW_LINE INDENT sum = 0 NEW_LINE for d in lst : NEW_LINE INDENT num = int ( d ) NEW_LINE if ( d == num ) : NEW_LINE INDENT if ( num > 0 and num % 2 == 1 ) : NEW_LINE INDENT sum += num * num NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT
def compare ( game , guess ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( game ) ) : NEW_LINE INDENT result . append ( abs ( game [ i ] - guess [ i ] ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def strongestExtension ( className , extensions ) : NEW_LINE INDENT strongest = "" NEW_LINE max = - sys . maxsize NEW_LINE for extension in extensions : NEW_LINE INDENT strength = 0 NEW_LINE for chr in extension : NEW_LINE INDENT if ( chr == chr and chr . toLowerCase ( ) != chr ) : NEW_LINE INDENT strength += 1 NEW_LINE DEDENT if ( chr == chr and chr . toLowerCase ( ) == chr ) : NEW_LINE INDENT strength -= 1 NEW_LINE DEDENT DEDENT if ( strength > max ) : NEW_LINE INDENT max = strength NEW_LINE strongest = extension NEW_LINE DEDENT DEDENT return className + "." + strongest NEW_LINE DEDENT
def intToMiniRoman ( number ) : NEW_LINE INDENT num = [ 1000 , 900 , 500 , 400 , 100 , 90 , 50 , 40 , 10 , 9 , 5 , 4 , 1 ] NEW_LINE sym = [ 'm' , 'cm' , 'd' , 'cd' , 'c' , 'xc' , 'l' , 'xl' , 'x' , 'iv' , 'i' ] NEW_LINE pos = 0 NEW_LINE res = [ ] NEW_LINE while ( number > 0 ) : NEW_LINE INDENT while ( number >= num [ pos ] ) : NEW_LINE INDENT res . append ( sym [ pos ] ) NEW_LINE number -= num [ pos ] NEW_LINE DEDENT if ( number > 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT DEDENT return str ( res ) NEW_LINE DEDENT
def eat ( number , need , remaining ) : NEW_LINE INDENT if ( need > remaining ) : NEW_LINE INDENT return ( number + remaining , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( number + need , remaining - need ) NEW_LINE DEDENT DEDENT
def doAlgebra ( ops , operands ) : NEW_LINE INDENT nums = [ operands ] NEW_LINE currentOps = [ ops ] NEW_LINE i = len ( currentOps ) - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( currentOps [ i ] == "**" ) : NEW_LINE INDENT nums [ i ] = pow ( nums [ i ] , nums [ i + 1 ] ) NEW_LINE nums [ i + 1 ] = 1 NEW_LINE currentOps . pop ( i ) NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT i = 0 NEW_LINE while ( i < len ( currentOps ) ) : NEW_LINE INDENT if ( currentOps [ i ] == "*" ) : NEW_LINE INDENT nums [ i ] *= nums [ i + 1 ] NEW_LINE nums [ i + 1 ] = 1 NEW_LINE currentOps . pop ( i , 1 ) NEW_LINE DEDENT elif ( currentOps [ i ] == "//" ) : NEW_LINE INDENT nums [ i ] = trunc ( nums [ i ] // nums [ i + 1 ] ) NEW_LINE nums . append ( i + 1 , 1 ) NEW_LINE currentOps . remove ( i , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( i < len ( currentOps ) ) : NEW_LINE INDENT if ( currentOps [ i ] == "+" ) : NEW_LINE INDENT nums [ i ] += nums [ i + 1 ] NEW_LINE nums . append ( i + 1 ) NEW_LINE currentOps . append ( i + 1 ) NEW_LINE DEDENT elif ( currentOps [ i ] == "-" ) : NEW_LINE INDENT nums [ i ] -= nums [ i + 1 ] NEW_LINE nums . append ( i + 1 ) NEW_LINE DEDENT DEDENT return nums [ 0 ] NEW_LINE DEDENT
def generateIntegers ( a , b ) : NEW_LINE INDENT lower = max ( 2 , min ( a , b ) ) NEW_LINE upper = min ( 8 , max ( a , b ) ) NEW_LINE result = [ ] NEW_LINE for i in range ( lower , upper + 1 , 2 ) : NEW_LINE INDENT result . append ( i ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def isStepNum ( n ) : NEW_LINE INDENT prevDigit = - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT curDigit = n % 10 NEW_LINE if ( prevDigit == - 1 ) : NEW_LINE INDENT prevDigit = curDigit NEW_LINE DEDENT else : NEW_LINE INDENT if ( abs ( prevDigit - curDigit ) != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT prevDigit = curDigit NEW_LINE n = trunc ( n / 10 ) NEW_LINE DEDENT return True NEW_LINE DEDENT
def numOfWays ( n , k ) : NEW_LINE INDENT p = 1 NEW_LINE if ( k % 2 != 0 ) : NEW_LINE INDENT p = - 1 NEW_LINE DEDENT return ( ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ) NEW_LINE DEDENT
def findDivisors ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( i ) NEW_LINE v . append ( n // i ) NEW_LINE DEDENT DEDENT DEDENT return v NEW_LINE DEDENT
def eggDrop ( n , k ) : NEW_LINE INDENT if ( k == 1 or k == 0 ) : NEW_LINE INDENT return k NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return k NEW_LINE DEDENT min = sys . maxsize NEW_LINE for x in range ( 1 , k + 1 ) : NEW_LINE INDENT res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) NEW_LINE if ( res < min ) : NEW_LINE INDENT min = res NEW_LINE DEDENT DEDENT return min + 1 NEW_LINE DEDENT
def isPowerOfTwo ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return log2 ( n ) == log2 ( n ) NEW_LINE DEDENT
def shortestPalindrome ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l = i NEW_LINE r = i NEW_LINE ans1 = "" NEW_LINE ans2 = "" NEW_LINE while ( l >= 0 and r < n and s [ l ] == s [ r ] ) : NEW_LINE INDENT ans1 += s [ l ] NEW_LINE l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT l = i - 1 NEW_LINE r = i NEW_LINE while ( l >= 0 and r < n and s [ l ] == s [ r ] ) : NEW_LINE INDENT ans2 += s [ l ] NEW_LINE l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT v . append ( ans1 ) NEW_LINE v . append ( ans2 ) NEW_LINE DEDENT ans = v [ 0 ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( v [ i ] != "" ) : NEW_LINE INDENT if ( ans [ 0 ] >= v [ i ] [ 0 ] ) : NEW_LINE INDENT ans = v [ i ] NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT
def minimumAdjacentDifference ( a , n , k ) : NEW_LINE INDENT minDiff = sys . maxsize NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT maxDiff = - sys . maxsize - 1 NEW_LINE for j in range ( n - k - 1 ) : NEW_LINE INDENT for p in range ( i , i + j + 1 ) : NEW_LINE INDENT maxDiff = max ( maxDiff , a [ p + 1 ] - a [ p ] ) NEW_LINE DEDENT DEDENT minDiff = min ( minDiff , maxDiff ) NEW_LINE DEDENT return minDiff NEW_LINE DEDENT
def cal ( arr , mid ) : NEW_LINE INDENT chocolate = 0 NEW_LINE for i in arr : NEW_LINE INDENT if ( i >= mid ) : NEW_LINE INDENT chocolate += i - mid NEW_LINE DEDENT DEDENT return chocolate NEW_LINE DEDENT
def check ( v , a , m ) : NEW_LINE INDENT tec = 0 NEW_LINE ans = 0 NEW_LINE b = [ 0 ] * ( len ( a ) + 3 ) NEW_LINE for i in range ( 0 , len ( a ) ) : NEW_LINE INDENT tec -= b [ i ] NEW_LINE if ( a [ i ] + tec < v ) : NEW_LINE INDENT mov = v - a [ i ] - tec NEW_LINE ans = ans + mov NEW_LINE tec += mov NEW_LINE b [ i + 2 ] = mov NEW_LINE DEDENT DEDENT return ans <= m NEW_LINE DEDENT
def largestNum ( arr ) : NEW_LINE INDENT res = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE l = 0 NEW_LINE r = len ( arr ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if ( sum == 0 ) : NEW_LINE INDENT res = max ( res , max ( arr [ l ] , arr [ r ] ) ) NEW_LINE return res NEW_LINE DEDENT elif ( sum < 0 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def binarySearch ( p , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( p ) - 1 NEW_LINE index = - 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT mid = i + ( j - i ) // 2 NEW_LINE if ( p [ mid ] >= n ) : NEW_LINE INDENT index = mid NEW_LINE j = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = mid + 1 NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
def findMinLength ( arr ) : NEW_LINE INDENT index = len ( arr ) - 1 NEW_LINE while ( index > 0 and arr [ index ] >= arr [ index - 1 ] ) : NEW_LINE INDENT index -= 1 NEW_LINE DEDENT return index NEW_LINE DEDENT
def minDigits ( n , k ) : NEW_LINE INDENT digits_num = int ( math . log10 ( n ) + 1 ) NEW_LINE temp_sum = 0 NEW_LINE temp = digits_num NEW_LINE result = 0 NEW_LINE sum = 0 NEW_LINE num2 = n NEW_LINE while ( num2 != 0 ) : NEW_LINE INDENT sum += num2 % 10 NEW_LINE num2 = num2 // 10 NEW_LINE DEDENT if ( sum <= k ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT else : NEW_LINE INDENT while ( temp > 0 ) : NEW_LINE INDENT v = trunc ( n // pow ( 10 , temp - 1 ) ) NEW_LINE temp_sum += v % 10 NEW_LINE if ( temp_sum >= k ) : NEW_LINE INDENT v = trunc ( v // 10 ) NEW_LINE v += 1 NEW_LINE result = v * pow ( 10 , temp ) NEW_LINE break NEW_LINE DEDENT temp -= 1 NEW_LINE DEDENT x = result - n NEW_LINE return x NEW_LINE DEDENT
def checkForPerfectSquare ( arr , i , j ) : NEW_LINE INDENT sum = 0 NEW_LINE for m in range ( i , j + 1 ) : NEW_LINE INDENT sum += arr [ m ] NEW_LINE DEDENT low = 0 NEW_LINE high = trunc ( sum / 2 ) NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + trunc ( ( high - low ) / 2 ) NEW_LINE if ( mid * mid == sum ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( mid * mid > sum ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def minFlips ( mat , s ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE m = len ( mat [ 0 ] ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != s [ ( i + j ) ] - '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def constructTree ( n , edges ) : NEW_LINE INDENT adjl = [ [ ] for i in range ( n ) ] NEW_LINE for e in edges : NEW_LINE INDENT u = e [ 0 ] NEW_LINE v = e [ 1 ] NEW_LINE adjl [ u ] . append ( v ) NEW_LINE adjl [ v ] . append ( u ) NEW_LINE DEDENT return adjl NEW_LINE DEDENT
def findSumOfValues ( v , parent , valuesChildren ) : NEW_LINE INDENT curNode = v NEW_LINE sum = 0 NEW_LINE while ( curNode != - 1 ) : NEW_LINE INDENT sum += valuesChildren [ curNode ] NEW_LINE curNode = parent [ curNode ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def getDistinct ( d , count ) : NEW_LINE INDENT num = 0 NEW_LINE count = pow ( 10 , count - 1 ) NEW_LINE while ( count > 0 ) : NEW_LINE INDENT num += count * d NEW_LINE count //= 10 NEW_LINE DEDENT return num NEW_LINE DEDENT
def isIncreasing ( arr ) : NEW_LINE INDENT for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def minAdjSwaps ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE cntZero = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT cntZero [ i ] += 1 NEW_LINE DEDENT DEDENT cntSwaps = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( cntZero [ i ] < ( n - i - 1 ) ) : NEW_LINE INDENT first = i NEW_LINE while ( first < n and cntZero [ first ] < ( n - i - 1 ) ) : NEW_LINE INDENT first += 1 NEW_LINE DEDENT if ( first == n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT while ( first > i ) : NEW_LINE INDENT temp = cntZero [ first ] NEW_LINE cntZero [ first - 1 ] = temp NEW_LINE first -= 1 NEW_LINE cntSwaps += 1 NEW_LINE DEDENT DEDENT DEDENT return cntSwaps NEW_LINE DEDENT
def solve ( values , salary , mod ) : NEW_LINE INDENT ret = 1 NEW_LINE amt = 0 NEW_LINE values . sort ( ) NEW_LINE salary . sort ( ) NEW_LINE while ( len ( salary ) > 0 ) : NEW_LINE INDENT while ( len ( values ) > 0 and values [ - 1 ] >= salary [ - 1 ] ) : NEW_LINE INDENT amt += 1 NEW_LINE values . pop ( ) NEW_LINE DEDENT if ( amt == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ret *= amt -= 1 NEW_LINE ret %= mod NEW_LINE salary . pop ( ) NEW_LINE DEDENT return ret NEW_LINE DEDENT
def organizeInOrder ( vec , op , n ) : NEW_LINE INDENT result = [ 0 for i in range ( n ) ] NEW_LINE vec . sort ( ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE k = 0 NEW_LINE while ( i <= j and k <= n - 2 ) : NEW_LINE INDENT if ( op [ k ] == "<" ) : NEW_LINE INDENT result [ k ] = vec [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result [ k ] = vec [ j ] NEW_LINE k -= 1 NEW_LINE DEDENT k += 1 NEW_LINE DEDENT result [ n - 1 ] = vec [ i ] NEW_LINE return result NEW_LINE DEDENT
def countPoints ( n , m , a , b , x , y ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE j = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( j < m ) : NEW_LINE INDENT if ( a [ i ] + y < b [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( b [ j ] >= a [ i ] - x and b [ j ] <= a [ i ] + y ) : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT
def areSame ( a , b ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE return ( str ( a ) == str ( b ) ) NEW_LINE DEDENT
def countNumberOfStrings ( s ) : NEW_LINE INDENT n = len ( s ) - 1 NEW_LINE count = pow ( 2 , n ) NEW_LINE return count NEW_LINE DEDENT
def primePower ( x ) : NEW_LINE INDENT primePow = [ ] NEW_LINE for i in range ( 2 , int ( x ** ( 1 / 2 ) ) ) : NEW_LINE INDENT if i * i > x : NEW_LINE INDENT break NEW_LINE DEDENT if ( x % i == 0 ) : NEW_LINE INDENT p = 1 NEW_LINE while ( x % i == 0 ) : NEW_LINE INDENT x //= i NEW_LINE p *= i NEW_LINE DEDENT primePow . append ( p ) NEW_LINE DEDENT DEDENT if ( x > 1 ) : NEW_LINE INDENT primePow . append ( x ) NEW_LINE DEDENT return primePow NEW_LINE DEDENT
def isPerfect ( n0 ) : NEW_LINE INDENT n = math . sqrt ( n0 ) NEW_LINE if ( n != math . ceil ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def findSum ( l , r ) : NEW_LINE INDENT arr = [ ] NEW_LINE i = 0 NEW_LINE x = 2 NEW_LINE while ( i <= r ) : NEW_LINE INDENT arr . append ( i + x ) NEW_LINE if ( i + 1 <= r ) : NEW_LINE INDENT arr . append ( i + 1 + x ) NEW_LINE DEDENT x *= - 1 NEW_LINE i += 2 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def results ( n , k ) : NEW_LINE INDENT return round ( n ** ( 1.0 / 2.0 ) ) NEW_LINE DEDENT
def factors ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE v . append ( 1 ) NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE if ( n // i != i ) : NEW_LINE INDENT v . append ( n // i ) NEW_LINE DEDENT DEDENT DEDENT return v NEW_LINE DEDENT
def smallestNum ( n ) : NEW_LINE INDENT x = pow ( 10.0 , ( n - 1 ) // 2.0 ) NEW_LINE return math . ceil ( x ) NEW_LINE DEDENT
def smallest ( s ) : NEW_LINE INDENT a = [ 0 ] * len ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT a [ i ] = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE DEDENT b = [ ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if ( ( a [ i ] ) % 2 != 0 ) : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE DEDENT DEDENT b . sort ( ) NEW_LINE if ( len ( b ) > 1 ) : NEW_LINE INDENT return b [ 0 ] * 10 + b [ 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def Diagonals ( a , b , c , d ) : NEW_LINE INDENT ans = [ ] NEW_LINE ans . append ( math . sqrt ( ( a * c + b * d ) * ( a * d + b * c ) / ( a * b + c * d ) ) ) NEW_LINE ans . append ( math . sqrt ( ( a * c + b * d ) * ( a * d + b * c ) / ( a * d + b * c ) ) ) NEW_LINE return ans NEW_LINE DEDENT
def findNumberOfDigits ( n , bas ) : NEW_LINE INDENT dig = log2 ( n ) + 1 NEW_LINE return dig NEW_LINE DEDENT
def nGon ( n ) : NEW_LINE INDENT proAngleVar = 0 NEW_LINE if ( n % 4 == 0 ) : NEW_LINE INDENT proAngleVar = 180 * ( 180.0 / n ) / 180 NEW_LINE DEDENT else : NEW_LINE INDENT proAngleVar = 180 * ( 180.0 / ( 2 * n ) ) / 180 NEW_LINE DEDENT negX = 1.0e + 99 NEW_LINE posX = - 1.0e +99 NEW_LINE negY = 1.0e +99 NEW_LINE posY = - 1.0e +99 NEW_LINE for j in range ( n ) : NEW_LINE INDENT px = cos ( 2 * math . pi * j / n + proAngleVar ) NEW_LINE py = sin ( 2 * math . pi * j / n + proAngleVar ) NEW_LINE negX = min ( negX , px ) NEW_LINE posX = max ( posX , px ) NEW_LINE negY = min ( negY , py ) NEW_LINE posY = max ( posY , py ) NEW_LINE DEDENT opt2 = max ( posX - negX , posY - negY ) NEW_LINE return opt2 // math . sin ( math . radians ( n ) ) / 2 NEW_LINE DEDENT
def findMaxK ( n ) : NEW_LINE INDENT p = int ( math . log2 ( n ) ) NEW_LINE return pow ( 2 , p ) NEW_LINE DEDENT
def nthFibo ( n ) : NEW_LINE INDENT a = ( pow ( 5 , 0.5 ) + 1 ) // 2 NEW_LINE b = ( - 1 * pow ( 5 , 0.5 ) + 1 ) // 2 NEW_LINE r = pow ( 5 , 0.5 ) NEW_LINE ans = ( pow ( a , n ) - pow ( b , n ) ) / r NEW_LINE return ans NEW_LINE DEDENT
def findProb ( l , r ) : NEW_LINE INDENT countOfPs = int ( math . sqrt ( r ) ) - math . ceil ( math . sqrt ( l ) ) + 1 NEW_LINE total = r - l + 1 NEW_LINE prob = countOfPs // total NEW_LINE return prob NEW_LINE DEDENT
def previousFibonacci ( n ) : NEW_LINE INDENT a = n / ( ( 1 + sqrt ( 5 ) ) / 2.0 ) NEW_LINE return round ( a ) NEW_LINE DEDENT
def distPrime ( arr , allPrimes ) : NEW_LINE INDENT list1 = [ ] NEW_LINE for i in allPrimes : NEW_LINE INDENT for j in arr : NEW_LINE INDENT if ( j % i == 0 ) : NEW_LINE INDENT list1 . append ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return list1 NEW_LINE DEDENT
def getArray ( n ) : NEW_LINE INDENT ans = [ ] NEW_LINE p2 = 1 NEW_LINE while ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT ans . append ( p2 ) NEW_LINE DEDENT n >>= 1 NEW_LINE p2 *= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def maximumLength ( a ) : NEW_LINE INDENT counts = [ 0 ] * 11 NEW_LINE ans = 0 NEW_LINE for index in range ( len ( a ) ) : NEW_LINE INDENT counts [ a [ index ] ] += 1 NEW_LINE k = [ ] NEW_LINE for i in counts : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT k . append ( i ) NEW_LINE DEDENT DEDENT k . sort ( ) NEW_LINE if ( len ( k ) == 1 or ( k [ 0 ] == k [ - 2 ] and k [ - 1 ] - k [ - 2 ] == 1 ) or ( k [ 0 ] == 1 and k [ 1 ] == k [ - 1 ] ) ) : NEW_LINE INDENT ans = index NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT
def maxEdges ( n ) : NEW_LINE INDENT edges = n * n // 4 NEW_LINE return edges NEW_LINE DEDENT
def findK ( n , k ) : NEW_LINE INDENT a = [ ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT return a [ k - 1 ] NEW_LINE DEDENT
def isKeith ( x , temp ) : NEW_LINE INDENT terms = [ ] NEW_LINE n = 0 NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT terms . append ( temp % 10 ) NEW_LINE temp //= 10 NEW_LINE n += 1 NEW_LINE DEDENT terms = terms . reverse ( ) NEW_LINE nextTerm = 0 NEW_LINE i = n NEW_LINE while ( nextTerm < x ) : NEW_LINE INDENT nextTerm = 0 NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT nextTerm += terms [ i - j ] NEW_LINE DEDENT terms . append ( nextTerm ) NEW_LINE i += 1 NEW_LINE DEDENT return nextTerm == x NEW_LINE DEDENT
def factors ( n , k ) : NEW_LINE INDENT v = [ ] NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT v . append ( 2 ) NEW_LINE n = n // 2 NEW_LINE DEDENT if ( len ( v ) >= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 3 NEW_LINE while i * i <= n : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE v . append ( i ) NEW_LINE DEDENT if ( len ( v ) >= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT v . append ( n ) NEW_LINE DEDENT if ( len ( v ) >= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def separateParenGroups ( parenString ) : NEW_LINE INDENT allParens = [ ] NEW_LINE currentParen = [ ] NEW_LINE currentDepth = 0 NEW_LINE for c in parenString : NEW_LINE INDENT if ( c == "(" ) : NEW_LINE INDENT currentDepth += 1 NEW_LINE currentParen . append ( c ) NEW_LINE DEDENT elif ( c == ")" ) : NEW_LINE INDENT currentDepth -= 1 NEW_LINE currentParen . append ( c ) NEW_LINE if ( currentDepth == 0 ) : NEW_LINE INDENT allParens . append ( currentParen [ 0 ] ) NEW_LINE currentParen . length = 0 NEW_LINE DEDENT DEDENT DEDENT return allParens NEW_LINE DEDENT
def parseNestedParens ( parenString ) : NEW_LINE INDENT allLevels = [ ] NEW_LINE level = 0 NEW_LINE maxLevel = 0 NEW_LINE for i in range ( len ( parenString ) ) : NEW_LINE INDENT chr = parenString [ i ] NEW_LINE if ( chr == "(" ) : NEW_LINE INDENT level += 1 NEW_LINE if ( level > maxLevel ) : NEW_LINE INDENT maxLevel = level NEW_LINE DEDENT DEDENT if ( chr == ")" ) : NEW_LINE INDENT level -= 1 NEW_LINE if ( level == 0 ) : NEW_LINE INDENT allLevels . append ( maxLevel ) NEW_LINE maxLevel = 0 NEW_LINE DEDENT DEDENT DEDENT return allLevels NEW_LINE DEDENT
def filterBySubstring ( strings , substring ) : NEW_LINE INDENT result = [ ] NEW_LINE for s in strings : NEW_LINE INDENT if ( s . includes ( substring ) ) : NEW_LINE INDENT result . append ( s ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def rollingMax ( numbers ) : NEW_LINE INDENT runningMax = 0 NEW_LINE result = [ ] NEW_LINE for n in numbers : NEW_LINE INDENT if ( n > runningMax ) : NEW_LINE INDENT runningMax = n NEW_LINE DEDENT result . append ( runningMax ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def makePalindrome ( s ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT return "" NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT rStr = s [ i ] NEW_LINE if ( rStr == rStr . split ( "" ) [ 0 ] ) : NEW_LINE INDENT nStr = s [ 0 : i ] NEW_LINE n2Str = nStr . split ( "" ) [ 0 ] NEW_LINE return s + n2Str NEW_LINE DEDENT DEDENT return s [ 0 : - 1 ] + s [ 0 : - 1 ] NEW_LINE DEDENT
def stringXor ( a , b ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if ( a [ i ] == b [ i ] ) : NEW_LINE INDENT result . append ( "0" ) NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( "1" ) NEW_LINE DEDENT DEDENT return string ( result ) NEW_LINE DEDENT
def longest ( strings ) : NEW_LINE INDENT if ( not len ( strings ) ) : NEW_LINE INDENT return "" NEW_LINE DEDENT maxLen = max ( strings ) NEW_LINE for s in strings : NEW_LINE INDENT if ( len ( s ) == maxLen ) : NEW_LINE INDENT return s NEW_LINE DEDENT DEDENT return "" NEW_LINE DEDENT
def stringSequence ( n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . append ( i ) NEW_LINE s . append ( " " ) NEW_LINE DEDENT s . append ( n ) NEW_LINE return join ( s ) NEW_LINE DEDENT
def countDistinctCharacters ( s ) : NEW_LINE INDENT distinct = set ( ) NEW_LINE for c in s : NEW_LINE INDENT distinct . add ( c ) NEW_LINE DEDENT return len ( distinct ) NEW_LINE DEDENT
def howManyTimes ( s , sub ) : NEW_LINE INDENT times = 0 NEW_LINE for i in range ( len ( s ) - sub . length + 1 ) : NEW_LINE INDENT if ( s [ i ] == sub ) : NEW_LINE INDENT times += 1 NEW_LINE DEDENT DEDENT return times NEW_LINE DEDENT
def sortNumbers ( numbers ) : NEW_LINE INDENT toNum = { } NEW_LINE fromNum = { } NEW_LINE for i in range ( 0 , len ( numbers ) ) : NEW_LINE INDENT if ( i == len ( numbers ) or numbers [ i ] == ' ' ) : NEW_LINE INDENT ints . append ( toNum [ current [ 0 ] ] ) NEW_LINE current . length = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT current . append ( numbers [ i ] ) NEW_LINE DEDENT DEDENT ints = [ ] NEW_LINE current = [ ] NEW_LINE for i in range ( len ( numbers ) ) : NEW_LINE INDENT if ( i == len ( numbers ) or numbers [ i ] == ' ' ) : NEW_LINE INDENT if ( toNum [ current [ 0 ] in toNum ) : NEW_LINE INDENT ints . append ( toNum [ current [ 0 ] ] ) NEW_LINE current . length = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT current . append ( numbers [ i ] ) NEW_LINE DEDENT DEDENT ints . sort ( ) NEW_LINE result = [ ] NEW_LINE for i in range ( len ( ints ) ) : NEW_LINE INDENT result . append ( fromNum [ ints [ i ] ] ) NEW_LINE if ( i != len ( ints ) - 1 ) : NEW_LINE INDENT result . append ( " " ) NEW_LINE DEDENT DEDENT return result . join ( "" ) NEW_LINE DEDENT
def findClosestElements ( numbers ) : NEW_LINE INDENT closestPair = [ numbers [ 0 ] , numbers [ 1 ] ] NEW_LINE distance = abs ( closestPair [ 0 ] - closestPair [ 1 ] ) NEW_LINE for i in range ( len ( numbers ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( numbers ) ) : NEW_LINE INDENT if ( abs ( numbers [ i ] - numbers [ j ] ) < distance ) : NEW_LINE INDENT closestPair [ 0 ] = numbers [ i ] NEW_LINE closestPair [ 1 ] = numbers [ j ] NEW_LINE distance = abs ( numbers [ i ] - numbers [ j ] ) NEW_LINE DEDENT DEDENT DEDENT closestPair . sort ( ) NEW_LINE return closestPair NEW_LINE DEDENT
def rescaleToUnit ( numbers ) : NEW_LINE INDENT minNum = min ( numbers ) NEW_LINE maxNum = max ( numbers ) NEW_LINE result = [ ] NEW_LINE for n in numbers : NEW_LINE INDENT result . append ( ( n - minNum ) // ( maxNum - minNum ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def filterIntegers ( values ) : NEW_LINE INDENT result = [ ] NEW_LINE for e in values : NEW_LINE INDENT if ( isInteger ( e ) ) : NEW_LINE INDENT result . append ( e ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def removeDuplicates ( numbers ) : NEW_LINE INDENT counter = { } NEW_LINE for i in numbers : NEW_LINE INDENT counter [ i ] = counter . get ( i , 0 ) + 1 NEW_LINE DEDENT result = [ ] NEW_LINE for i in numbers : NEW_LINE INDENT if counter [ i ] == 0 : NEW_LINE INDENT result . append ( i ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def flipCase ( s ) : NEW_LINE INDENT result = [ ] NEW_LINE for c in s : NEW_LINE INDENT if ( c == c . toLowerCase ( ) and c != c . toUpperCase ( ) ) : NEW_LINE INDENT result . append ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( c ) NEW_LINE DEDENT DEDENT return result . join ( "" ) NEW_LINE DEDENT
def filterByPrefix ( strings , prefix ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in range ( len ( strings ) ) : NEW_LINE INDENT if ( strings [ i ] [ 0 ] == prefix ) : NEW_LINE INDENT result . append ( strings [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def findZero ( xs ) : NEW_LINE INDENT ans = 0 NEW_LINE value = 0 NEW_LINE for i in range ( len ( xs ) ) : NEW_LINE INDENT value += xs [ i ] * pow ( ans , i ) NEW_LINE DEDENT while ( abs ( value ) > 1e-6 ) : NEW_LINE INDENT driv = 0 NEW_LINE for i in range ( 1 , len ( xs ) ) : NEW_LINE INDENT driv += xs [ i ] * pow ( ans , i - 1 ) * i NEW_LINE DEDENT ans -= value // driv NEW_LINE value = 0 NEW_LINE for i in range ( len ( xs ) ) : NEW_LINE INDENT value += xs [ i ] * pow ( ans , i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def sortThird ( l ) : NEW_LINE INDENT thirds = [ ] NEW_LINE for i in range ( len ( l ) , 3 ) : NEW_LINE INDENT thirds . append ( l [ i ] ) NEW_LINE DEDENT thirds = sorted ( thirds ) NEW_LINE result = [ ] NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT if ( i % 3 == 0 ) : NEW_LINE INDENT result . append ( thirds [ i // 3 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( l [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def unique ( l ) : NEW_LINE INDENT result = set ( l ) NEW_LINE result = sorted ( result ) NEW_LINE return result NEW_LINE DEDENT
def maxElement ( l ) : NEW_LINE INDENT return max ( l ) NEW_LINE DEDENT
def triplesSumToZero ( l ) : NEW_LINE INDENT for i in range ( len ( l ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( l ) ) : NEW_LINE INDENT for k in range ( j + 1 , len ( l ) ) : NEW_LINE INDENT if ( l [ i ] + l [ j ] + l [ k ] == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def fib4 ( n ) : NEW_LINE INDENT results = [ 0 , 0 , 2 , 0 ] NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT results . append ( results [ i - 4 ] + results [ i - 3 ] + results [ i - 2 ] + results [ i - 1 ] ) NEW_LINE DEDENT return results [ n ] NEW_LINE DEDENT
def isPalindrome ( text ) : NEW_LINE INDENT pr = text . split ( "" ) [ 0 ] NEW_LINE return pr == text NEW_LINE DEDENT
def removeVowels ( text ) : NEW_LINE INDENT result = [ ] NEW_LINE vowels = 'aeiou' NEW_LINE for ch in text : NEW_LINE INDENT if ( not vowels . includes ( ch ) ) : NEW_LINE INDENT result . append ( ch ) NEW_LINE DEDENT DEDENT return result . join ( "" ) NEW_LINE DEDENT
def sameChars ( s0 , s1 ) : NEW_LINE INDENT set0 = set ( ) NEW_LINE for c in s0 : NEW_LINE INDENT set0 . add ( c ) NEW_LINE DEDENT set1 = set ( ) NEW_LINE for c in s1 : NEW_LINE INDENT set1 . add ( c ) NEW_LINE DEDENT return ( set0 . sort ( ) . join ( "" ) == ( set1 . sort ( ) ) ) NEW_LINE DEDENT
def common ( l1 , l2 ) : NEW_LINE INDENT us = set ( ) NEW_LINE for e1 in l1 : NEW_LINE INDENT for e2 in l2 : NEW_LINE INDENT if ( e1 == e2 ) : NEW_LINE INDENT us . add ( e1 ) NEW_LINE DEDENT DEDENT DEDENT ret = [ ] NEW_LINE ret . sort ( ) NEW_LINE return ret NEW_LINE DEDENT
def correctBracketing ( brackets ) : NEW_LINE INDENT depth = 0 NEW_LINE for b in brackets : NEW_LINE INDENT if ( b == "(" ) : NEW_LINE INDENT depth += 1 NEW_LINE DEDENT else : NEW_LINE INDENT depth -= 1 NEW_LINE DEDENT if ( depth < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return depth == 0 NEW_LINE DEDENT
def circularShift ( x , shift ) : NEW_LINE INDENT s = str ( x ) NEW_LINE if ( shift > len ( s ) ) : NEW_LINE INDENT return s . reverse ( ) . join ( "" ) NEW_LINE DEDENT return s [ - shift ] + s [ 0 : - shift ] NEW_LINE DEDENT
def search ( lst ) : NEW_LINE INDENT counter = { } NEW_LINE for i in lst : NEW_LINE INDENT counter [ i ] = counter . get ( i , 0 ) + 1 NEW_LINE DEDENT ans = - 1 NEW_LINE for i in counter : NEW_LINE INDENT if ( value >= key and key > ans ) : NEW_LINE INDENT ans = key NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def smallestChange ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( arr ) // 2 ) : NEW_LINE INDENT if arr [ i ] != arr [ len ( arr ) - i - 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def totalMatch ( lst1 , lst2 ) : NEW_LINE INDENT sum1 = 0 NEW_LINE for st in lst1 : NEW_LINE INDENT sum1 += len ( st ) NEW_LINE DEDENT sum2 = 0 NEW_LINE for st in lst2 : NEW_LINE INDENT sum2 += len ( st ) NEW_LINE DEDENT return sum1 > sum2 ? lst2 : lst1 NEW_LINE DEDENT
def isHappy ( s ) : NEW_LINE INDENT if ( len ( s ) < 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( len ( s ) - 2 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] or s [ i + 1 ] == s [ i + 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def numericalLetterGrade ( grades ) : NEW_LINE INDENT letterGrade = [ ] NEW_LINE for i in range ( len ( grades ) ) : NEW_LINE INDENT gpa = grades [ i ] NEW_LINE if ( gpa == 4.0 ) : NEW_LINE INDENT letterGrade . append ( "A+" ) NEW_LINE DEDENT elif ( gpa > 3.7 ) : NEW_LINE INDENT letterGrade . append ( "A" ) NEW_LINE DEDENT elif ( gpa > 3.3 ) : NEW_LINE INDENT letterGrade . append ( "A-" ) NEW_LINE DEDENT elif ( gpa > 3.0 ) : NEW_LINE INDENT letterGrade . append ( "B+" ) NEW_LINE DEDENT elif ( gpa > 2.7 ) : NEW_LINE INDENT letterGrade . append ( "B" ) NEW_LINE DEDENT elif ( gpa > 2.3 ) : NEW_LINE INDENT letterGrade . append ( "B-" ) NEW_LINE DEDENT elif ( gpa > 2.0 ) : NEW_LINE INDENT letterGrade . append ( "C+" ) NEW_LINE DEDENT elif ( gpa > 1.7 ) : NEW_LINE INDENT letterGrade . append ( "C" ) NEW_LINE DEDENT elif ( gpa > 1.3 ) : NEW_LINE INDENT letterGrade . append ( "C-" ) NEW_LINE DEDENT elif ( gpa > 1.0 ) : NEW_LINE INDENT letterGrade . append ( "D+" ) NEW_LINE DEDENT elif ( gpa > 0.7 ) : NEW_LINE INDENT letterGrade . append ( "D" ) NEW_LINE DEDENT elif ( gpa > 0.0 ) : NEW_LINE INDENT letterGrade . append ( "D-" ) NEW_LINE DEDENT else : NEW_LINE INDENT letterGrade . append ( "E" ) NEW_LINE DEDENT DEDENT return letterGrade NEW_LINE DEDENT
def solve ( n ) : NEW_LINE INDENT biStr = [ ] NEW_LINE sum = 0 NEW_LINE for c in range ( len ( n ) ) : NEW_LINE INDENT sum += ord ( c ) - ord ( '0' ) NEW_LINE DEDENT while ( sum > 0 ) : NEW_LINE INDENT biStr . append ( ( sum % 2 ) . toString ( ) ) NEW_LINE sum //= 2 NEW_LINE DEDENT return join ( biStr ) NEW_LINE DEDENT
def antiShuffle ( s ) : NEW_LINE INDENT ret = [ ] NEW_LINE current = [ ] NEW_LINE for i in range ( len ( s ) + 1 ) : NEW_LINE INDENT if ( i == len ( s ) or s [ i ] == " " ) : NEW_LINE INDENT current . sort ( ) NEW_LINE if ( len ( ret ) ) : NEW_LINE INDENT ret . append ( " " ) NEW_LINE DEDENT ret . append ( current . join ( "" ) ) NEW_LINE current . length = 0 NEW_LINE DEDENT else : NEW_LINE INDENT current . append ( s [ i ] ) NEW_LINE DEDENT DEDENT return str ( ret ) NEW_LINE DEDENT
def sortArray ( array ) : NEW_LINE INDENT if ( not len ( array ) ) : NEW_LINE INDENT return array NEW_LINE DEDENT if ( ( array [ 0 ] + array [ - 1 ] ) % 2 == 1 ) : NEW_LINE INDENT array . sort ( ) NEW_LINE DEDENT else : NEW_LINE INDENT array . sort ( ) NEW_LINE DEDENT DEDENT
def encrypt ( s ) : NEW_LINE INDENT ans = [ ] NEW_LINE for c in s : NEW_LINE INDENT if ( c . toUpperCase ( ) != c . toLowerCase ( ) ) : NEW_LINE INDENT ans . append ( chr ( ord ( 'a' ) + ( ord ( c ) - ord ( 'a' ) + 4 ) % 26 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( c ) NEW_LINE DEDENT DEDENT return ans . join ( "" ) NEW_LINE DEDENT
def isBored ( s ) : NEW_LINE INDENT isStart = True NEW_LINE sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == "." or s [ i ] == "?" or s [ i ] == "!" ) : NEW_LINE INDENT isStart = True NEW_LINE DEDENT elif ( isStart ) : NEW_LINE INDENT if ( s [ i ] == ' ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == 'I' ) : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT isStart = False NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def encode ( message ) : NEW_LINE INDENT vowels = "aeiouAEIOU" NEW_LINE ret = [ ] NEW_LINE for c in message : NEW_LINE INDENT if ( c . toUpperCase ( ) == c and c . toLowerCase ( ) != c ) : NEW_LINE INDENT c = c . toLowerCase ( ) NEW_LINE if ( vowels . includes ( c ) ) : NEW_LINE INDENT c = chr ( ord ( 'a' ) + ( ord ( c ) - ord ( 'a' ) + 2 ) % 26 ) NEW_LINE DEDENT DEDENT elif ( c . toUpperCase ( ) != c and c . toLowerCase ( ) == c ) : NEW_LINE INDENT c = c . toUpperCase ( ) NEW_LINE if ( vowels . includes ( c ) ) : NEW_LINE INDENT c = chr ( ord ( 'A' ) + ( ord ( c ) - ord ( 'A' ) + 2 ) % 26 ) NEW_LINE DEDENT DEDENT ret . append ( c ) NEW_LINE DEDENT return str ( ret ) NEW_LINE DEDENT
def skjkasdkd ( lst ) : NEW_LINE INDENT largest = 0 NEW_LINE for n in lst : NEW_LINE INDENT if n > largest : NEW_LINE INDENT prime = True NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT prime = False NEW_LINE DEDENT DEDENT if prime : NEW_LINE INDENT largest = n NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE s = str ( largest ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT sum += ord ( s [ i ] ) - ord ( '0' ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def checkDictCase ( dict ) : NEW_LINE INDENT if ( len ( dict ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT isLower = 0 NEW_LINE isUpper = 0 NEW_LINE for i in dict : NEW_LINE INDENT if ( c [ 0 ] == c and c [ 1 ] != c ) : NEW_LINE INDENT isLower = 1 NEW_LINE DEDENT elif ( c [ 0 ] != c and c [ 1 ] == c ) : NEW_LINE INDENT isUpper = 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return isLower + isUpper == 1 NEW_LINE DEDENT
def multiply ( a , b ) : NEW_LINE INDENT return ( abs ( a ) % 10 ) * ( abs ( b ) % 10 ) NEW_LINE DEDENT
def countUpper ( s ) : NEW_LINE INDENT uVowel = 'AEIOU' NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) , 2 ) : NEW_LINE INDENT if ( uVowel [ ord ( s [ i ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def byLength ( arr ) : NEW_LINE INDENT numTo = { } NEW_LINE for i in range ( 1 , 'One' ) : NEW_LINE INDENT numTo [ i ] = i NEW_LINE DEDENT sortedArr = sorted ( arr ) NEW_LINE newArr = [ ] NEW_LINE for i in range ( sortedArr ) : NEW_LINE INDENT if ( i >= 1 and i <= 9 ) : NEW_LINE INDENT newArr . append ( numTo [ i ] ) NEW_LINE DEDENT DEDENT return newArr NEW_LINE DEDENT
def f ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE prod = 0 NEW_LINE result = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prod += i NEW_LINE sum *= i NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT result . append ( sum ) NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( prod ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def evenOddPalindrome ( n ) : NEW_LINE INDENT evenCount = 0 NEW_LINE oddCount = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = str ( i ) NEW_LINE rStr = str ( s ) NEW_LINE if ( s == rStr ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT oddCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT evenCount += 1 NEW_LINE DEDENT DEDENT DEDENT return ( evenCount , oddCount ) NEW_LINE DEDENT
def histogram ( test ) : NEW_LINE INDENT count = { } NEW_LINE max = 0 NEW_LINE for i in range ( len ( test ) ) : NEW_LINE INDENT if ( test [ i ] != ' ' ) : NEW_LINE INDENT count [ test [ i ] ] += 1 NEW_LINE if ( count [ test [ i ] ] > max ) : NEW_LINE INDENT max = count [ test [ i ] ] NEW_LINE DEDENT DEDENT DEDENT result = defaultdict ( int ) NEW_LINE for i in count : NEW_LINE INDENT if ( value == max ) : NEW_LINE INDENT result [ i ] = value NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def reverseDelete ( s , c ) : NEW_LINE INDENT ret = [ ] NEW_LINE for ch in s : NEW_LINE INDENT if ( not in c ) : NEW_LINE INDENT ret . append ( ch ) NEW_LINE DEDENT DEDENT flag = "False" NEW_LINE if ( ret . join ( "" ) == [ ... ret ] . reverse ( ) ) : NEW_LINE INDENT flag = "True" NEW_LINE DEDENT return [ ret . join ( "" ) , flag ] NEW_LINE DEDENT
def sortArray ( arr ) : NEW_LINE INDENT bin = [ ] NEW_LINE for i in arr : NEW_LINE INDENT b = 0 NEW_LINE n = abs ( i ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT b += n % 2 NEW_LINE n = n // 2 NEW_LINE DEDENT bin . append ( b ) NEW_LINE DEDENT for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT for j in range ( 1 , len ( arr ) ) : NEW_LINE INDENT if ( ( bin [ j ] < bin [ j - 1 ] ) or ( bin [ j ] == bin [ j - 1 ] and arr [ j ] < arr [ j - 1 ] ) ) : NEW_LINE INDENT temp = bin [ j ] NEW_LINE bin [ j ] = bin [ j - 1 ] NEW_LINE arr [ j - 1 ] = temp NEW_LINE DEDENT DEDENT DEDENT return arr NEW_LINE DEDENT
def getClosestVowel ( word ) : NEW_LINE INDENT vowels = 'AEIOUaeiou' NEW_LINE for i in range ( len ( word ) - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( ( vowels [ word [ i ] ) and not vowels [ word [ i + 1 ] ) and not vowels [ word [ i - 1 ] ) ) : NEW_LINE INDENT return word [ i ] NEW_LINE DEDENT DEDENT return "" NEW_LINE DEDENT
def matchParens ( lst ) : NEW_LINE INDENT strings = [ lst [ 0 ] + lst [ 1 ] , lst [ 1 ] + lst [ 0 ] ] NEW_LINE for l in strings : NEW_LINE INDENT count = 0 NEW_LINE for c in l : NEW_LINE INDENT if ( c == "(" ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( c == ")" ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if ( count < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT DEDENT return "No" NEW_LINE DEDENT
def maximum ( arr , k ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT arr = sorted ( arr ) NEW_LINE return arr [ - k ] NEW_LINE DEDENT
def validDate ( date ) : NEW_LINE INDENT if ( len ( date ) != 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT if ( i == 2 or i == 5 ) : NEW_LINE INDENT if ( date [ i ] != '-' ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif ( '0' > date [ i ] and date [ i ] > '9' ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT month = int ( date [ 0 ] ) NEW_LINE day = int ( date [ 3 ] 5 ) NEW_LINE year = int ( date [ 6 ] ) NEW_LINE if ( month < 1 or month > 12 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( day < 1 or day > 31 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( day == 31 and month == 4 or month == 6 or month == 9 or month == 11 or month == 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( day == 30 and month == 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def splitWords ( txt ) : NEW_LINE INDENT current = [ ] NEW_LINE result = [ ] NEW_LINE if ( txt . includes ( " " ) ) : NEW_LINE INDENT for i in range ( len ( txt ) ) : NEW_LINE INDENT if ( i == len ( txt ) or txt [ i ] == " " ) : NEW_LINE INDENT if ( current . length > 0 ) : NEW_LINE INDENT result . append ( current . join ( "" ) ) NEW_LINE DEDENT current . length = 0 NEW_LINE DEDENT else : NEW_LINE INDENT current . append ( txt [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if ( txt [ includes ( "," ) ) : NEW_LINE INDENT for i in range ( i == len ( txt ) or txt [ i ] == "," ) : NEW_LINE INDENT if ( current . length > 0 ) : NEW_LINE INDENT result . append ( current . join ( "" ) ) NEW_LINE DEDENT current . length = 0 NEW_LINE DEDENT else : NEW_LINE INDENT current . append ( txt [ i ] ) NEW_LINE DEDENT DEDENT num = 0 NEW_LINE for c in txt : NEW_LINE INDENT if ( c == c and c . toUpperCase ( ) != c and c . charCodeAt ( 0 ) % 2 == 0 ) : NEW_LINE INDENT num += 1 NEW_LINE DEDENT DEDENT return [ str ( num ) ] NEW_LINE DEDENT
def tri ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT tris = [ 1 , 3 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT tris . append ( 1 + i // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT tris . append ( tris [ i - 2 ] + tris [ i - 1 ] + ( i + 3 ) // 2 ) NEW_LINE DEDENT DEDENT return tris NEW_LINE DEDENT
def checkIfLastCharIsALetter ( txt ) : NEW_LINE INDENT if ( len ( txt ) <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( txt [ - 1 ] . toUpperCase ( ) != txt [ - 1 ] . toLowerCase ( ) and ( len ( txt ) == 1 or txt [ - 2 ] ) == txt [ - 2 ] ) ) NEW_LINE DEDENT
def orderByPoints ( nums ) : NEW_LINE INDENT result = [ ] NEW_LINE for num in nums : NEW_LINE INDENT w = abs ( num ) NEW_LINE sum = 0 NEW_LINE for c in w : NEW_LINE INDENT sum += ord ( c ) - ord ( '0' ) NEW_LINE DEDENT if ( num < 0 ) : NEW_LINE INDENT sum -= 2 * ( w [ 0 ] - ord ( '0' ) ) NEW_LINE DEDENT result . append ( sum ) NEW_LINE DEDENT for i in range ( len ( nums ) ) : NEW_LINE INDENT for j in range ( 1 , len ( nums ) ) : NEW_LINE INDENT if ( result [ j - 1 ] > result [ j ] ) : NEW_LINE INDENT temp = result [ j ] NEW_LINE result [ j ] = result [ j - 1 ] NEW_LINE result [ j - 1 ] = temp NEW_LINE DEDENT NEW_LINE nums [ j ] = nums [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return nums NEW_LINE DEDENT
def bf ( planet1 , planet2 ) : NEW_LINE INDENT planets = [ 'Mercury' , 'Venus' , 'Earth' , 'Mars' , 'Jupiter' , 'Saturn' , 'Uranus' , 'Neptune' ] NEW_LINE idx1 = len ( planets ) NEW_LINE idx2 = len ( planets ) NEW_LINE if ( idx1 == - 1 or idx2 == - 1 or idx1 == idx2 ) : NEW_LINE INDENT return [ ] NEW_LINE DEDENT return planets [ idx2 + 1 ] NEW_LINE DEDENT
def sortedListSum ( lst ) : NEW_LINE INDENT result = [ ] NEW_LINE for i in lst : NEW_LINE INDENT if ( len ( i ) % 2 == 0 ) : NEW_LINE INDENT result . append ( i ) NEW_LINE DEDENT DEDENT result = sorted ( result ) NEW_LINE return result NEW_LINE DEDENT
def cycpatternCheck ( a , b ) : NEW_LINE INDENT for i in range ( len ( b ) ) : NEW_LINE INDENT rotate = b [ i ] + b [ 0 : i ] NEW_LINE if ( a . includes ( rotate ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def evenOddCount ( num ) : NEW_LINE INDENT evenCount = 0 NEW_LINE oddCount = 0 NEW_LINE for i in range ( abs ( num ) ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT evenCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT oddCount += 1 NEW_LINE DEDENT DEDENT return ( evenCount , oddCount ) NEW_LINE DEDENT
def findMax ( words ) : NEW_LINE INDENT max = "" NEW_LINE maxLength = 0 NEW_LINE for word in words : NEW_LINE INDENT unique = [ ] NEW_LINE for w in word : NEW_LINE INDENT if ( w not in unique ) : NEW_LINE INDENT unique . append ( w ) NEW_LINE DEDENT DEDENT if ( len ( unique ) > maxLength or ( len ( unique ) == maxLength and word < max ) ) : NEW_LINE INDENT max = word NEW_LINE maxLength = len ( unique ) NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT
def solve ( s ) : NEW_LINE INDENT noLetter = True NEW_LINE result = [ ] NEW_LINE for ch in s : NEW_LINE INDENT if ( ch . toUpperCase ( ) == ch and ch . toLowerCase ( ) != ch ) : NEW_LINE INDENT ch = ch . toLowerCase ( ) NEW_LINE noLetter = False NEW_LINE DEDENT elif ( ch . toUpperCase ( ) != ch and ch . toLowerCase ( ) == ch ) : NEW_LINE INDENT ch = ch . toUpperCase ( ) NEW_LINE noLetter = False NEW_LINE DEDENT result . append ( ch ) NEW_LINE DEDENT if ( noLetter ) : NEW_LINE INDENT return result . reverse ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return result . join ( "" ) NEW_LINE DEDENT DEDENT
def mostFrequent ( arr , n ) : NEW_LINE INDENT hp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT hp [ arr [ i ] ] = hp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT maxCount = 0 NEW_LINE res = - 1 NEW_LINE for entry in hp : NEW_LINE INDENT if ( maxCount < entry [ 1 ] ) : NEW_LINE INDENT res = entry [ 0 ] NEW_LINE maxCount = entry [ 1 ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def find ( a , b , k , n1 , n2 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT missing = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if ( not s [ a [ i ] ] ) : NEW_LINE INDENT missing += 1 NEW_LINE DEDENT if ( missing == k ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def solveQuery ( start , end , arr ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in mp : NEW_LINE INDENT if ( i == arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def segregate ( arr , size ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] <= 0 ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT
def countTriplets ( a , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT s . add ( a [ i ] ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT xr = a [ i ] ^ a [ j ] NEW_LINE if ( xr in s and xr != a [ i ] and xr != a [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count // 3 NEW_LINE DEDENT
def leastFrequent ( arr , n ) : NEW_LINE INDENT hp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT hp [ arr [ i ] ] = hp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT minCount = n + 1 NEW_LINE res = - 1 NEW_LINE for entry in hp : NEW_LINE INDENT if ( minCount >= entry [ 1 ] ) : NEW_LINE INDENT res = entry [ 0 ] NEW_LINE minCount = entry [ 1 ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findPermutations ( arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE maxInd = - 1 NEW_LINE minInd = 10000000 NEW_LINE n = len ( arr ) NEW_LINE indexOf = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT indexOf [ arr [ i ] ] = i + 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT maxInd = max ( maxInd , indexOf [ i ] ) NEW_LINE minInd = min ( minInd , indexOf [ i ] ) NEW_LINE if ( maxInd - minInd + 1 == i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT
def formQuadruplets ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE pairs = 0 NEW_LINE arr = sorted ( arr ) NEW_LINE for i in range ( n - pairs ) : NEW_LINE INDENT ans += arr [ i + 2 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def lexicographicallyMaximum ( s , n ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE DEDENT v = [ ] NEW_LINE for i in range ( ord ( 'a' ) ) : NEW_LINE INDENT if ( m [ chr ( i ) ] == False ) : NEW_LINE INDENT v . append ( chr ( i ) ) NEW_LINE DEDENT DEDENT j = len ( v ) - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( v [ j ] [ 0 ] < s [ i ] ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT m [ s [ i ] ] = m . get ( s [ i ] , 0 ) - 1 NEW_LINE s = slice ( 0 , i ) + v [ j ] + s [ i + 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT if ( j < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( l > j ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( s [ i ] >= ord ( 'a' ) + min ( n , 25 ) or m [ s [ i ] ] > 1 ) : NEW_LINE INDENT m [ s [ i ] ] -= 1 NEW_LINE s = s [ 0 : i ] NEW_LINE l += 1 NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def noOfValidKbers ( k , arr ) : NEW_LINE INDENT set = set ( ) NEW_LINE while ( k != 0 ) : NEW_LINE INDENT set . add ( k % 10 ) NEW_LINE k = trunc ( k / 10 ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT no = arr [ i ] NEW_LINE flag = True NEW_LINE while ( no != 0 ) : NEW_LINE INDENT digit = no % 10 NEW_LINE if ( flag ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def delCost ( s , cost ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT forMax [ s [ i ] ] = cost [ i ] NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT forMax [ s [ i ] ] = max ( forMax [ s [ i ] ] , cost [ i ] ) NEW_LINE DEDENT if ( not forTot [ s [ i ] ] ) : NEW_LINE INDENT forTot [ s [ i ] ] += cost [ i ] NEW_LINE DEDENT DEDENT for i in forMax : NEW_LINE INDENT ans += forTot [ i [ 0 ] ] - i [ 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT
def replaceDuplicates ( names ) : NEW_LINE INDENT Hash = dict ( ) NEW_LINE for i in range ( len ( names ) ) : NEW_LINE INDENT Hash [ names [ i ] ] = Hash . get ( names [ i ] , 0 ) + 1 NEW_LINE DEDENT return names NEW_LINE DEDENT
def minmaxNumbers ( matrix , res ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( len ( matrix ) ) : NEW_LINE INDENT minR = min ( matrix [ i ] ) NEW_LINE for j in range ( len ( matrix [ i ] ) ) : NEW_LINE INDENT minR = min ( minR , matrix [ i ] [ j ] ) NEW_LINE DEDENT s . add ( minR ) NEW_LINE DEDENT for j in range ( len ( matrix [ 0 ] ) ) : NEW_LINE INDENT maxC = - sys . maxsize NEW_LINE for i in range ( len ( matrix ) ) : NEW_LINE INDENT maxC = max ( maxC , matrix [ i ] [ j ] ) NEW_LINE DEDENT if ( maxC in s ) : NEW_LINE INDENT res . append ( maxC ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def lengthOfLongestAP ( a , n ) : NEW_LINE INDENT dp = { } NEW_LINE res = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT d = a [ j ] - a [ i ] NEW_LINE if ( d in dp ) : NEW_LINE INDENT dp [ d ] [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ d ] [ j ] = 2 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findKthChar ( n , k ) : NEW_LINE INDENT prev = 'A' NEW_LINE cur = "" NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 'A' NEW_LINE DEDENT for j in range ( 2 , n + 1 ) : NEW_LINE INDENT cur = prev + "B" NEW_LINE for i in range ( len ( prev ) ) : NEW_LINE INDENT if ( prev [ i ] == 'A' ) : NEW_LINE INDENT prev = prev [ 0 : i ] + "B" + prev [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT prev = prev [ 0 : i ] + "A" + prev [ i + 1 ] NEW_LINE DEDENT DEDENT prev = prev . replace ( "" , "" ) NEW_LINE cur += prev NEW_LINE prev = cur NEW_LINE DEDENT return cur [ k - 1 ] NEW_LINE DEDENT
def findKthLargest ( s , k ) : NEW_LINE INDENT tmp = sorted ( s ) NEW_LINE tmp . sort ( ) NEW_LINE tmp . reverse ( ) NEW_LINE return tmp [ k - 1 ] NEW_LINE DEDENT
def subArraylen ( arr , n , K ) : NEW_LINE INDENT mp = { } NEW_LINE mp [ arr [ 0 ] ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] + arr [ i - 1 ] NEW_LINE mp [ arr [ i ] ] = i NEW_LINE DEDENT len = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < K ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT x = arr [ i ] - K NEW_LINE if ( x == 0 ) : NEW_LINE INDENT len = min ( len , i ) NEW_LINE DEDENT if ( mp [ x ] not in mp ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT len = min ( len , i - mp [ x ] ) NEW_LINE DEDENT DEDENT DEDENT return len NEW_LINE DEDENT
def findMaxLen ( a , k ) : NEW_LINE INDENT n = len ( a ) NEW_LINE a . sort ( ) NEW_LINE vis = [ False for i in range ( n ) ] NEW_LINE mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] = i NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( not vis [ i ] ) : NEW_LINE INDENT check = a [ i ] * k NEW_LINE if ( check in mp ) : NEW_LINE INDENT c += 1 NEW_LINE vis [ check ] = True NEW_LINE DEDENT DEDENT DEDENT return n - c NEW_LINE DEDENT
def minDistancePoints ( a , k , n ) : NEW_LINE INDENT m = { } NEW_LINE q = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ a [ i ] ] += 1 NEW_LINE q . append ( a [ i ] ) NEW_LINE DEDENT ans = [ ] NEW_LINE while ( k > 0 ) : NEW_LINE INDENT x = q . pop ( 0 ) NEW_LINE if ( x - 1 in m and k > 0 ) : NEW_LINE INDENT m [ x - 1 ] = 1 NEW_LINE q . append ( x - 1 ) NEW_LINE ans . append ( x - 1 ) NEW_LINE k -= 1 NEW_LINE DEDENT if ( x + 1 not in m and k > 0 ) : NEW_LINE INDENT m [ x + 1 ] = 1 NEW_LINE q . append ( x + 1 ) NEW_LINE ans . append ( x + 1 ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def isValidLen ( s , length , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE mp = { } NEW_LINE right = 0 NEW_LINE while ( right < length ) : NEW_LINE INDENT mp [ s [ right ] ] += 1 NEW_LINE DEDENT if ( mp . size <= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT while ( right < n ) : NEW_LINE INDENT if ( s [ right ] in mp ) : NEW_LINE INDENT mp [ s [ right ] ] += 1 NEW_LINE DEDENT if ( mp [ right - length ] not in mp ) : NEW_LINE INDENT mp [ s [ right - length ] ] += 1 NEW_LINE DEDENT if ( mp [ size <= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT right += 1 NEW_LINE DEDENT return mp . size <= k NEW_LINE DEDENT
def partition ( arr , low , high ) : NEW_LINE INDENT pivot = ord ( arr [ high ] ) NEW_LINE i = ( low - 1 ) NEW_LINE for j in range ( low , high ) : NEW_LINE INDENT if ( arr [ j ] <= pivot ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT [ arr [ i + 1 ] , arr [ high ] = [ arr [ high ] , arr [ i + 1 ] ] NEW_LINE return ( i + 1 ) NEW_LINE DEDENT
def strScore ( strs , s , n ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ strs [ i ] ] = i + 1 NEW_LINE DEDENT if ( s not in m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT score = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT score += ord ( s [ i ] ) - ord ( 'a' ) + 1 NEW_LINE DEDENT score = score * m [ s ] NEW_LINE return score NEW_LINE DEDENT
def countEle ( s , a , n ) : NEW_LINE INDENT mp = { } NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE if ( num in mp ) : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 0 NEW_LINE while ( s [ 0 ] != num ) : NEW_LINE INDENT mp [ s [ 0 ] ] = True NEW_LINE s . remove ( s [ 0 ] ) NEW_LINE cnt += 1 NEW_LINE DEDENT s . remove ( s [ 0 ] ) NEW_LINE cnt += 1 NEW_LINE ans . append ( cnt ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT
def maxDistinctChar ( s , n , k ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ s [ i ] ] += 1 NEW_LINE DEDENT v = [ ] NEW_LINE for it in freq : NEW_LINE INDENT v . append ( it [ 1 ] ) NEW_LINE DEDENT v . sort ( reverse = False ) NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT mn = min ( v [ i ] - 1 , k ) NEW_LINE v [ i ] -= mn NEW_LINE k -= mn NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT for i in range ( len ( v ) ) : NEW_LINE INDENT mn = min ( v [ i ] , k ) NEW_LINE v [ i ] -= mn NEW_LINE k -= mn NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( v [ i ] == 1 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def findKth ( arr , n , k ) : NEW_LINE INDENT missing = set ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT missing . add ( arr [ i ] ) NEW_LINE DEDENT maxM = max ( arr ) NEW_LINE minM = min ( arr ) NEW_LINE for i in range ( minM + 1 , maxM ) : NEW_LINE INDENT if ( not missing [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def almostSort ( a , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT [ a [ i ] , a [ i + 1 ] ] = ( a [ i + 1 ] , a [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] > a [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def maximumSum ( s , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE freq = [ 0 ] * 256 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT freq . sort ( ) NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT if ( k > freq [ i ] ) : NEW_LINE INDENT sum += freq [ i ] * freq [ i ] NEW_LINE k -= freq [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += freq [ i ] * k NEW_LINE break NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def findMinOperations ( arr , n , k ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT freq = { } NEW_LINE for j in range ( i , n , k ) : NEW_LINE INDENT freq [ arr [ j ] ] = freq . get ( arr [ j ] , 0 ) + 1 NEW_LINE DEDENT max1 = 0 NEW_LINE num = 0 NEW_LINE for i in freq : NEW_LINE INDENT if ( value > max1 ) : NEW_LINE INDENT max1 = value NEW_LINE num = key NEW_LINE DEDENT DEDENT for i in freq : NEW_LINE INDENT if ( key != num ) : NEW_LINE INDENT operations += value NEW_LINE DEDENT DEDENT DEDENT return operations NEW_LINE DEDENT
def subString ( s , n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for len in range ( 1 , n - i + 1 ) : NEW_LINE INDENT find = s [ i : i + len ] NEW_LINE v . append ( find ) NEW_LINE DEDENT DEDENT return v NEW_LINE DEDENT
def checkUniqueFrequency ( arr , n ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] = freq . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT uniqueFreq = set ( ) NEW_LINE for i in freq : NEW_LINE INDENT if ( arr [ i ] in uniqueFreq ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT uniqueFreq . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def minCost ( str1 , str2 , n ) : NEW_LINE INDENT cost = 0 NEW_LINE tmp = str1 . split ( "" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( tmp [ i ] != str2 [ i ] ) : NEW_LINE INDENT if ( i < n - 1 and tmp [ i + 1 ] != str2 [ i + 1 ] ) : NEW_LINE INDENT temp [ i ] , tmp [ i + 1 ] = temp [ i + 1 ] , tmp [ i ] NEW_LINE cost += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cost += 1 NEW_LINE DEDENT DEDENT DEDENT return cost NEW_LINE DEDENT
def isValidNum ( x ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT if ( x [ i ] - '0' ) in mp ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( x [ i ] - '0' > 5 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT mp [ x [ i ] - '0' ] = 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def minimizeDiff ( arr , n , k ) : NEW_LINE INDENT max = max ( arr ) NEW_LINE min = min ( arr ) NEW_LINE if ( max - min <= k ) : NEW_LINE INDENT return max - min NEW_LINE DEDENT avg = ( max + min ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > avg ) : NEW_LINE INDENT arr [ i ] -= k NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += k NEW_LINE DEDENT DEDENT max = max ( arr ) NEW_LINE min = min ( arr ) NEW_LINE return max - min NEW_LINE DEDENT
def getMinCost ( arr , n ) : NEW_LINE INDENT minEle = min ( arr ) NEW_LINE return minEle * ( n - 1 ) NEW_LINE DEDENT
def possibility ( m , length , s ) : NEW_LINE INDENT countOdd = 0 NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( m [ ord ( s [ i ] ) - 48 ] & 1 ) : NEW_LINE INDENT countOdd += 1 NEW_LINE DEDENT if ( countOdd > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def minimumCostOfBreaking ( x , y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE x . sort ( ) NEW_LINE y . sort ( ) NEW_LINE hzntl = 1 NEW_LINE vert = 1 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( x [ i ] > y [ j ] ) : NEW_LINE INDENT res += x [ i ] * vert NEW_LINE hzntl += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += y [ j ] * hzntl NEW_LINE vert += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT total = 0 NEW_LINE while ( i < m ) : NEW_LINE INDENT total += x [ i ] NEW_LINE DEDENT res += total * vert NEW_LINE total = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT total += y [ j ] NEW_LINE DEDENT res += total * hzntl NEW_LINE return res NEW_LINE DEDENT
def findMaximumScore ( a , n ) : NEW_LINE INDENT freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT dp = [ 0 ] * ( max ( a ) + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = freq [ 1 ] ?? 0 NEW_LINE for i in range ( 2 , len ( dp ) ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , dp [ i - 2 ] + ( freq [ i ] ?? 0 ) * i ) NEW_LINE DEDENT return dp [ - 1 ] NEW_LINE DEDENT
def countWays ( s , t , k , mod ) : NEW_LINE INDENT n = len ( s ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT p = s [ i ] + s [ 0 : i ] NEW_LINE if ( p == t ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT dp1 = [ 0 ] * ( k + 1 ) NEW_LINE dp2 = [ 0 ] * ( k + 1 ) NEW_LINE if ( s == t ) : NEW_LINE INDENT dp1 [ 0 ] = 1 NEW_LINE dp2 [ 0 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp1 [ 0 ] = 0 NEW_LINE dp2 [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod NEW_LINE dp2 [ i ] = ( ( dp1 [ i - 1 ] * b ) ) % mod ) % mod NEW_LINE DEDENT return dp1 [ k ] NEW_LINE DEDENT
def findSubarraySum ( arr , n , k ) : NEW_LINE INDENT prevSum = { } NEW_LINE res = 0 NEW_LINE currSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT currSum += arr [ i ] NEW_LINE if ( currSum == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( prevSum [ currSum - k ] not in prevSum ) : NEW_LINE INDENT res += ( prevSum [ currSum - k ] ) NEW_LINE DEDENT prevSum [ currSum ] = ( prevSum [ currSum ] or 0 ) + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def maximumOccurrence ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE freq = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = "" NEW_LINE temp += s [ i ] NEW_LINE freq [ temp ] = freq . get ( temp , 0 ) + 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT temp = "" NEW_LINE temp += s [ i ] NEW_LINE temp += s [ j ] NEW_LINE freq [ temp ] = freq . get ( temp , 0 ) + 1 NEW_LINE DEDENT DEDENT answer = - sys . maxsize NEW_LINE for entry in freq : NEW_LINE INDENT answer = max ( answer , entry [ 1 ] ) NEW_LINE DEDENT return answer NEW_LINE DEDENT
def countCharacters ( strings , chars ) : NEW_LINE INDENT res = 0 NEW_LINE freq = { } NEW_LINE for i in range ( len ( chars ) ) : NEW_LINE INDENT freq [ chars [ i ] ] = freq . get ( chars [ i ] , 0 ) + 1 NEW_LINE DEDENT for st in strings : NEW_LINE INDENT flag = True NEW_LINE for c in st : NEW_LINE INDENT if ( freq [ c ] not in freq ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT res += len ( st ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def distinctSubstring ( p , q , k , n ) : NEW_LINE INDENT ss = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE s = "" NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT pos = ord ( p [ j ] ) - ord ( 'a' ) NEW_LINE sum += q [ pos ] - ord ( '0' ) NEW_LINE s += p [ j ] NEW_LINE if ( sum <= k ) : NEW_LINE INDENT ss . add ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return len ( ss ) NEW_LINE DEDENT
def uniqueMorseRep ( arr ) : NEW_LINE INDENT morseCode = [ ".-" , "-..." , "-. -." , "-.." , "." , "..-." , "--." , "...." , ".." , ".---" ] NEW_LINE st = set ( ) NEW_LINE N = len ( arr ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT temp = "" NEW_LINE M = len ( arr [ i ] ) NEW_LINE for j in range ( M ) : NEW_LINE INDENT temp += morseCode [ ord ( arr [ i ] [ j ] ) - ord ( 'a' ) ] NEW_LINE DEDENT st . add ( temp ) NEW_LINE DEDENT return len ( st ) NEW_LINE DEDENT
def countSubstrings ( st , k ) : NEW_LINE INDENT n = len ( st ) NEW_LINE answer = 0 NEW_LINE map = { } NEW_LINE for i in range ( k ) : NEW_LINE INDENT map [ st [ i ] ] += 1 NEW_LINE DEDENT if ( len ( map ) == k ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT map [ st [ i ] ] += 1 NEW_LINE DEDENT map [ st [ i - k ] ] += 1 NEW_LINE if ( len ( map ) == k ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT
def canConstruct ( s , k ) : NEW_LINE INDENT m = { } NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE p = 0 NEW_LINE if ( len ( s ) == k ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] = m . get ( s [ i ] , 0 ) + 1 NEW_LINE DEDENT if ( k > len ( s ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT for h in m : NEW_LINE INDENT if ( h [ 1 ] % 2 != 0 ) : NEW_LINE INDENT p = p + 1 NEW_LINE DEDENT DEDENT DEDENT if ( k < p ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def equalIgnoreCase ( str1 , str2 ) : NEW_LINE INDENT str1 = str1 . toUpperCase ( ) NEW_LINE str2 = str2 . toUpperCase ( ) NEW_LINE return str1 == str2 NEW_LINE DEDENT
def findLongestSub ( bin ) : NEW_LINE INDENT n = len ( bin ) NEW_LINE sum = 0 NEW_LINE prevSum = { } NEW_LINE maxlen = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( bin [ i ] == '1' ) : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum -= 1 NEW_LINE DEDENT if ( sum > 0 ) : NEW_LINE INDENT maxlen = i + 1 NEW_LINE DEDENT elif ( sum <= 0 ) : NEW_LINE INDENT if ( prevSum [ sum - 1 ] in prevSum ) : NEW_LINE INDENT currLen = i - prevSum [ sum - 1 ] NEW_LINE maxlen = max ( maxlen , currLen ) NEW_LINE DEDENT DEDENT if ( sum not in prevSum ) : NEW_LINE INDENT prevSum [ sum ] = i NEW_LINE DEDENT DEDENT return maxlen NEW_LINE DEDENT
def hasAllCodes ( s , k ) : NEW_LINE INDENT us = set ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT us . add ( s [ i : i + k ] ) NEW_LINE DEDENT return len ( us ) == 1 << k NEW_LINE DEDENT
def checkPalin ( word ) : NEW_LINE INDENT n = len ( word ) NEW_LINE word = lower ( word ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( word [ i ] != word [ n - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def convert ( st ) : NEW_LINE INDENT w = "" NEW_LINE z = "" NEW_LINE st = st . toUpperCase ( ) + " " NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT ch = st [ i ] NEW_LINE if ( ch != ' ' ) : NEW_LINE INDENT w += ch NEW_LINE DEDENT else : NEW_LINE INDENT z += w [ 0 ] + w [ 1 ] + " " NEW_LINE w = "" NEW_LINE DEDENT DEDENT return z NEW_LINE DEDENT
def maxLines ( n , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT s = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( x1 [ i ] == x2 [ i ] ) : NEW_LINE INDENT slope = sys . maxsize NEW_LINE DEDENT else : NEW_LINE INDENT slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) NEW_LINE DEDENT s [ slope ] = slope NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT
def PrimeFactor ( n ) : NEW_LINE INDENT primef = { } NEW_LINE while n % 2 == 0 : NEW_LINE INDENT primef [ 2 ] += 1 NEW_LINE DEDENT n = n // 2 NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT primef [ i ] += 1 NEW_LINE DEDENT n = n // i NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT primef [ n ] = 1 NEW_LINE DEDENT return primef NEW_LINE DEDENT
def isDivisibleByDivisor ( s , d ) : NEW_LINE INDENT s %= d NEW_LINE hashMap = [ ] NEW_LINE hashMap . append ( s ) NEW_LINE for i in range ( d + 1 ) : NEW_LINE INDENT s += s % d NEW_LINE s %= d NEW_LINE if ( s in hashMap ) : NEW_LINE INDENT if ( s == 0 ) : NEW_LINE INDENT return "Yes" NEW_LINE DEDENT return "No" NEW_LINE DEDENT else : NEW_LINE INDENT hashMap . append ( s ) NEW_LINE DEDENT DEDENT return "Yes" NEW_LINE DEDENT
def oddSum ( a , n , k ) : NEW_LINE INDENT odd = set ( ) NEW_LINE even = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT even . add ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT odd . add ( a [ i ] ) NEW_LINE DEDENT DEDENT if ( odd . size >= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT flag = False NEW_LINE for i in range ( 1 , k , 2 ) : NEW_LINE INDENT needed = k - i NEW_LINE if ( needed <= even . size ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return flag NEW_LINE DEDENT
def dayOfYear ( date ) : NEW_LINE INDENT days = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE year = int ( date [ 0 ] ) NEW_LINE month = int ( date [ 5 : 7 ] ) NEW_LINE day = int ( date [ 8 ] ) NEW_LINE if ( month > 2 and year % 4 == 0 and ( year % 100 != 0 or year % 400 == 0 ) ) : NEW_LINE INDENT day += 1 NEW_LINE DEDENT while ( month > 1 ) : NEW_LINE INDENT day = day + days [ month - 2 ] NEW_LINE -- month NEW_LINE DEDENT return day NEW_LINE DEDENT
def isPerfectSquare ( arr , n ) : NEW_LINE INDENT umap = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT umap [ arr [ i ] ] = umap . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT for itr in umap : NEW_LINE INDENT if ( itr [ 1 ] % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def minMoves ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE ans = sys . maxsize NEW_LINE length = len ( s ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT for j in range ( length ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT t = s . split ( "" ) NEW_LINE cur = 0 NEW_LINE for k in range ( i , length - 1 ) : NEW_LINE INDENT [ t [ k ] , t [ k + 1 ] ] = [ t [ k + 1 ] , t [ k ] ] NEW_LINE cur += 1 NEW_LINE DEDENT for k in range ( j - ( j > i ? 1 : 0 ) , length - 2 ) : NEW_LINE INDENT if ( t [ k ] != "" ) : NEW_LINE INDENT pos = k NEW_LINE break NEW_LINE DEDENT DEDENT for k in range ( pos , length ) : NEW_LINE INDENT [ t [ k ] , t [ k - 1 ] ] = [ t [ k - 1 ] , t [ k ] ] NEW_LINE cur += 1 NEW_LINE DEDENT nn = int ( t [ k ] ) NEW_LINE if ( nn % 25 == 0 ) : NEW_LINE INDENT ans = min ( ans , cur ) NEW_LINE DEDENT DEDENT DEDENT if ( ans == sys . maxsize ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT
def minimumOperations ( a , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] = mp . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT count = 0 NEW_LINE for entry in mp : NEW_LINE INDENT if ( entry [ 1 ] > 1 ) : NEW_LINE INDENT count += entry [ 1 ] - 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def kaprekarRec ( n , prev ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT prev = n NEW_LINE digits = [ 0 ] * 4 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT digits [ i ] = n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT digits . sort ( ) NEW_LINE asc = 0 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT asc = asc * 10 + digits [ i ] NEW_LINE DEDENT digits . sort ( ) NEW_LINE desc = 0 NEW_LINE for i in range ( 3 , - 1 , - 1 ) : NEW_LINE INDENT desc = desc * 10 + digits [ i ] NEW_LINE DEDENT diff = abs ( asc - desc ) NEW_LINE if ( diff == prev ) : NEW_LINE INDENT return diff NEW_LINE DEDENT return kaprekarRec ( diff , prev ) NEW_LINE DEDENT
def fractionToDecimal ( numr , denr ) : NEW_LINE INDENT res = "" NEW_LINE mp = { } NEW_LINE mp [ numr % denr ] = 0 NEW_LINE rem = numr % denr NEW_LINE while ( ( rem != 0 ) and ( rem not in mp ) ) : NEW_LINE INDENT mp [ rem ] = len ( res ) NEW_LINE rem = rem * 10 NEW_LINE res_part = rem // denr NEW_LINE res += res_part . toString ( ) NEW_LINE rem = rem % denr NEW_LINE DEDENT if ( rem == 0 ) : NEW_LINE INDENT return "" NEW_LINE DEDENT if ( mp [ rem ] in mp ) : NEW_LINE INDENT return res [ mp [ rem ] NEW_LINE DEDENT return "" NEW_LINE DEDENT
def isFancy ( num ) : NEW_LINE INDENT fp = { } NEW_LINE fp [ "0" ] = "0" NEW_LINE fp [ "1" ] = "1" NEW_LINE fp [ "6" ] = "9" NEW_LINE fp [ "8" ] = "8" NEW_LINE fp [ "9" ] = "6" NEW_LINE n = len ( num ) NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( ( num [ l ] not in fp ) or fp [ num [ l ] ] != num [ r ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def distinctOddRatio ( numbers ) : NEW_LINE INDENT distinctCount = len ( numbers ) NEW_LINE distinctOddCount = len ( numbers ) NEW_LINE return distinctOddCount // distinctCount NEW_LINE DEDENT
def compareSum ( numbers , words ) : NEW_LINE INDENT intSum = sum ( numbers ) NEW_LINE wordLengthSum = sum ( words ) NEW_LINE if ( intSum < wordLengthSum ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( intSum > wordLengthSum ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def allLongerThan ( shortWords , longWords ) : NEW_LINE INDENT maxOfShort = max ( shortWords ) NEW_LINE minOfLong = min ( longWords ) NEW_LINE return minOfLong > maxOfShort NEW_LINE DEDENT
def compareOddEvenRange ( numbers ) : NEW_LINE INDENT rangeOdd = max ( numbers . filter ( n => n % 2 == 1 ) ) - min ( numbers . filter ( n => n % 2 == 1 ) ) NEW_LINE rangeEven = max ( numbers . filter ( n => n % 2 == 0 ) ) - min ( numbers . filter ( n => n % 2 == 0 ) ) NEW_LINE if ( rangeOdd < rangeEven ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( rangeOdd > rangeEven ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def averageDistinctLength ( words ) : NEW_LINE INDENT distinctWords = set ( words ) NEW_LINE averageLen = distinctWords ? len ( distinctWords ) : 0 NEW_LINE return averageLen NEW_LINE DEDENT
def withdrawBalance ( start , withdrawals ) : NEW_LINE INDENT end = withdrawals [ 0 ] NEW_LINE return end NEW_LINE DEDENT
def firstShortAndStartsWithO ( words ) : NEW_LINE INDENT matchedElement = words [ 0 ] NEW_LINE return matchedElement NEW_LINE DEDENT
def bigNumberAtIndex ( numbers , index ) : NEW_LINE INDENT targetNum = numbers [ index ] NEW_LINE return targetNum NEW_LINE DEDENT
def containsSquareInRange ( rangeStart , rangeLength ) : NEW_LINE INDENT containsSquare = [ 0 ] * ( rangeStart + rangeLength ) NEW_LINE return containsSquare NEW_LINE DEDENT
def groupNumbersByMod ( numbers , mod ) : NEW_LINE INDENT numberGroups = { } NEW_LINE for n in numbers : NEW_LINE INDENT key = n % mod NEW_LINE if key in acc : NEW_LINE INDENT acc [ key ] . append ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT acc [ key ] = [ n ] NEW_LINE DEDENT return numberGroups NEW_LINE DEDENT
def groupNumbersByFirstChar ( words ) : NEW_LINE INDENT wordsGroups = { } NEW_LINE for w in words : NEW_LINE INDENT key = w [ 0 ] NEW_LINE if ( key in acc ) : NEW_LINE INDENT acc [ key ] . append ( w ) NEW_LINE DEDENT else : NEW_LINE INDENT acc [ key ] = [ w ] NEW_LINE DEDENT return wordsGroups NEW_LINE DEDENT
def orderByLengthAndDescending ( words ) : NEW_LINE INDENT sortedWords = sorted ( words ) NEW_LINE return sortedWords NEW_LINE DEDENT
def orderFirstCharDescendingReverse ( words ) : NEW_LINE INDENT sortedWords = sorted ( words ) NEW_LINE return sortedWords NEW_LINE DEDENT
def getSubListOfNegative ( numbers , start , length ) : NEW_LINE INDENT subList = numbers [ start ] NEW_LINE return subList NEW_LINE DEDENT
def getPositiveSequence ( numbers ) : NEW_LINE INDENT subSequence = [ ] NEW_LINE for i in range ( len ( numbers ) ) : NEW_LINE INDENT if ( numbers [ i ] <= 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT subSequence = numbers [ i ] NEW_LINE break NEW_LINE DEDENT for i in range ( len ( subSequence ) ) : NEW_LINE INDENT if ( subSequence [ i ] > 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT subSequence = subSequence [ 0 : i ] NEW_LINE break NEW_LINE DEDENT return subSequence NEW_LINE DEDENT
def getLargerThanIndexSequence ( numbers ) : NEW_LINE INDENT subSequence = [ [ n , index ] for i in range ( len ( numbers ) ) ] NEW_LINE for i in range ( len ( subSequence ) ) : NEW_LINE INDENT if ( subSequence [ i ] [ 0 ] < subSequence [ i ] [ 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT subSequence = subSequence [ i ] NEW_LINE break NEW_LINE DEDENT for i in range ( len ( subSequence ) ) : NEW_LINE INDENT if ( subSequence [ i ] [ 0 ] >= subSequence [ i ] [ 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT subSequence = subSequence [ 0 : i ] NEW_LINE DEDENT subSequence = list ( subSequence ) NEW_LINE return subSequence NEW_LINE DEDENT
def rearrangeWordByIndexes ( words , indexes ) : NEW_LINE INDENT newIndexes = indexes . filter ( n >= len ( words ) ) NEW_LINE newWords = newIndexes . map ( n => words [ n ] ) NEW_LINE return newWords NEW_LINE DEDENT
def getWordsUpperLower ( words ) : NEW_LINE INDENT upperLowerWords = [ 'Upper' , 'Lower' ] NEW_LINE return upperLowerWords NEW_LINE DEDENT
def selectIfInPlace ( numbers ) : NEW_LINE INDENT numsInPlace = numbers NEW_LINE return numsInPlace NEW_LINE DEDENT
def selectPairs ( numbersA , numbersB ) : NEW_LINE INDENT pairs = numbersA . flatMap ( a => numbersB ) NEW_LINE return pairs NEW_LINE DEDENT
def stringCrossJoin ( endWords , beginWords ) : NEW_LINE INDENT crossStrings = beginWords . flatMap ( b => endWords [ 0 ] == e [ - 1 ] ) NEW_LINE return crossStrings NEW_LINE DEDENT
def elementsContainSubword ( words , subword ) : NEW_LINE INDENT if ( words [ 0 : 5 ] . every ( subword ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( words [ 0 : 5 ] . some ( subword ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT
def concatLargeNumbers ( numbersA , numbersB , flag ) : NEW_LINE INDENT allNumbers = [ ] NEW_LINE for n in range ( len ( numbersA ) ) : NEW_LINE INDENT allNumbers . append ( n ) NEW_LINE DEDENT return allNumbers NEW_LINE DEDENT
def dotProduct ( vectorA , vectorB ) : NEW_LINE INDENT dotProduct = dot ( vectorA , vectorB ) NEW_LINE return dotProduct NEW_LINE DEDENT
def setDifference ( setA , setB ) : NEW_LINE INDENT difference = [ ] NEW_LINE for x in set ( setA ) : NEW_LINE INDENT difference . append ( x ) NEW_LINE DEDENT difference . sort ( ) NEW_LINE return difference NEW_LINE DEDENT
