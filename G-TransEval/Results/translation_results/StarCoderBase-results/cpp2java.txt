int greatestCommonDivisor(int a, int b) {
    if (a == 0 || b == 0) {
        return a + b;
    }
    if (a == b) {
        return a;
    }
    if (a > b) {
        return greatestCommonDivisor(a % b, b);
    } else {
        return greatestCommonDivisor(a, b % a);
    }
}
--------------------------------
int largestDivisor(int n) {
    for (int i = 2; i <= n; i++) {
        if (n % i == 0) {
            return n / i;
        }
    }
    return 1;
}
--------------------------------
boolean isPrime(int n) {
    if (n < 2) {
        return false;
    }
    for (int k = 2; k < n; k++) {
        if (n % k == 0) {
            return false;
        }
    }
    return true;
}
--------------------------------
int fizzBuzz(int n) {
    int count = 0;
    for (int i = 0; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            int q = i;
            while (q > 0) {
                if (q % 10 == 7) {
                    count += 1;
                }
                q /= 10;
            }
        }
    }
    return count;
}
--------------------------------
int primeFib(int n) {
    int f0 = 0;
    int f1 = 1;
    while (n > 0) {
        int p = f0 + f1;
        boolean isPrime = p >= 2;
        for (int i = 2; i < p; i++) {
            if (p % i == 0) {
                isPrime = false;
                break;
            }
        }
        if (isPrime) {
            n -= 1;
        }
        f0 = f1;
        f1 = p;
    }
    return f1;
}
--------------------------------
double triangleArea(double a, double h) {
    return a * h / 2;
}
--------------------------------
int modP(int n, int p) {
    int ret = 1;
    for (int i = 0; i < n; i++) {
        ret = (ret * 2) % p;
    }
    return ret;
}
--------------------------------
int add(int x, int y) {
    return x + y;
}
--------------------------------
int fib(int n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    return fib(n - 1) + fib(n - 2);
}
--------------------------------
int largestPrimeFactor(int n) {
    for (int i = 2; i < n; i++) {
        while (n % i == 0 && n > i) {
            n /= i;
        }
    }
    return n;
}
--------------------------------
int sumToN(int n) {
    int result = 0;
    for (int i = 1; i <= n; i++) {
        result += i;
    }
    return result;
}
--------------------------------
int fibfib(int n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 0;
    }
    if (n == 2) {
        return 1;
    }
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);
}
--------------------------------
boolean isMultiplyPrime(int a) {
    int num = 0;
    for (int i = 2; i <= a; i++) {
        while (a % i == 0 && a >= i) {
            a /= i;
            num += 1;
        }
    }
    return num == 3;
}
--------------------------------
boolean isSimplePower(int x, int n) {
    if (n == 1) {
        return x == 1;
    }
    int power = 1;
    while (power < x) {
        power *= n;
    }
    return power == x;
}
--------------------------------
int chooseNum(int x, int y) {
    if (x > y) {
        return -1;
    }
    if (y % 2 == 0) {
        return y;
    }
    if (x == y) {
        return -1;
    }
    return y - 1;
}
--------------------------------
boolean isEqualToSumEven(int n) {
    return n % 2 == 0 && n >= 8;
}
--------------------------------
int specialFactorial(int n) {
    int fact = 1;
    int specialFact = 1;
    for (int i = 1; i <= n; i++) {
        fact *= i;
        specialFact *= fact;
    }
    return specialFact;
}
--------------------------------
int xOrY(int n, int x, int y) {
    boolean isPrime = n >= 2;
    for (int i = 2; i < n; i++) {
        if (n % i == 0) {
            isPrime = false;
            break;
        }
    }
    if (isPrime) {
        return x;
    }
    return y;
}
--------------------------------
boolean rightAngleTriangle(int a, int b, int c) {
    return a * a == b * b + c * c || b * b == a * a + c * c || c * c == a * a + b * b;
}
--------------------------------
int fastPow(int n, int k) {
    if (k == 0) {
        return 1;
    }
    int temp = fastPow(n, k / 2);
    if (k % 2 == 0) {
        return temp * temp;
    } else {
        return n * temp * temp;
    }
}
--------------------------------
boolean isPalin(String s) {
    int l = s.length() / 2;
    for (int i = 0; i < l; i++) {
        if (s.charAt(i)!= s.charAt(s.length() - i - 1)) {
            return false;
        }
    }
    return true;
}
--------------------------------
int findSum(int n) {
    int ans = 0, temp = 0;
    for (int i = 1; i <= n && temp < n; i++) {
        temp = i - 1;
        int num = 1;
        while (temp < n) {
            if (temp + i <= n) {
                ans += i * num;
            } else {
                ans += (n - temp) * num;
            }
            temp += i;
            num += 1;
        }
    }
    return ans;
}
--------------------------------
int getNextGap(int gap) {
    gap = (int) (gap * 10 / 13);
    if (gap < 1) {
        return 1;
    }
    return gap;
}
--------------------------------
int countNonDecreasing(int n) {
    int k = 10;
    int count = 1;
    for (int i = 1; i <= n; i++) {
        count *= k + i - 1;
        count /= i;
    }
    return count;
}
--------------------------------
int power(int x, int y) {
    if (y == 0) {
        return 1;
    } else if (y % 2 == 0) {
        return power(x, y / 2) * power(x, y / 2);
    } else {
        return x * power(x, y / 2) * power(x, y / 2);
    }
}
--------------------------------
double power(double x, int y) {
    if (y == 0) {
        return 1;
    }
    double temp = power(x, y / 2);
    if (y % 2 == 0) {
        return temp * temp;
    } else {
        if (y > 0) {
            return x * temp * temp;
        } else {
            return temp * temp / x;
        }
    }
}
--------------------------------
int multiply(int x, int y) {
    if (y == 0) {
        return 0;
    } else if (y > 0) {
        return x + multiply(x, y - 1);
    } else {
        return -multiply(x, -y);
    }
}
--------------------------------
int smallest(int x, int y, int z) {
    if (!(y / x)) {
        return!(y / z)? y : z;
    }
    return!(x / z)? x : z;
}
--------------------------------
boolean isPowerOfFour(int n) {
    if (n == 0) {
        return false;
    }
    while (n!= 1) {
        if (n % 4!= 0) {
            return false;
        }
        n = n / 4;
    }
    return true;
}
--------------------------------
int modInverse(int a, int m) {
    int m0 = m;
    int x0 = 0, x1 = 1;
    if (m == 1) {
        return 0;
    }
    while (a > 1) {
        int q = a / m;
        int t = m;
        m = a % m;
        a = t;
        t = x0;
        x0 = x1 - q * x0;
        x1 = t;
    }
    if (x1 < 0) {
        x1 += m0;
    }
    return x1;
}
--------------------------------
int cntRotations(String s, int n) {
    String s2 = s + s;
    int[] pre = new int[2 * n];
    for (int i = 0; i < 2 * n; i++) {
        if (i!= 0) {
            pre[i] += pre[i - 1];
        }
        if (s2.charAt(i) == 'a' || s2.charAt(i) == 'e' || s2.charAt(i) == 'i' || s2.charAt(i) == 'o' || s2.charAt(i) == 'u') {
            pre[i]++;
        }
    }
    int ans = 0;
    for (int i = n - 1; i < 2 * n - 1; i++) {
        int r = i, l = i - n;
        int x1 = pre[r];
        if (l >= 0) {
            x1 -= pre[l];
        }
        r = i - n / 2;
        int left = pre[r];
        if (l >= 0) {
            left -= pre[l];
        }
        int right = x1 - left;
        if (left > right) {
            ans++;
        }
    }
    return ans;
}
--------------------------------
int binomialCoeff(int n, int k) {
    int res = 1;
    if (k > n - k) {
        k = n - k;
    }
    for (int i = 0; i < k; ++i) {
        res *= n - i;
        res /= i + 1;
    }
    return res;
}
--------------------------------
boolean isPrefix(String temp, String s) {
    if (temp.length() < s.length()) {
        return false;
    } else {
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i)!= temp.charAt(i)) {
                return false;
            }
        }
        return true;
    }
}
--------------------------------
String lexicographicallySmallestString(String s, int n) {
    int lastZe = -1;
    String ans = "";
    for (int i = n - 1; i >= 0; i--) {
        if (s.charAt(i) == '0') {
            lastZe = i;
            break;
        }
    }
    for (int i = 0; i < n; i++) {
        if (i <= lastZe && s.charAt(i) == '0') {
            ans += s.charAt(i);
        } else if (i > lastZe) {
            ans += s.charAt(i);
        }
    }
    return ans;
}
--------------------------------
int calculateMax(int n, int m, int k) {
    int ans = -1;
    int low = 0, high = m;
    while (low <= high) {
        int mid = (low + high) / 2;
        int val = 0;
        int l = k - 1;
        int r = n - k;
        val += mid;
        if (mid >= l) {
            val += l * (2 * mid - l - 1) / 2;
        } else {
            val += mid * (mid - 1) / 2 + (l - mid);
        }
        if (mid >= r) {
            val += r * (2 * mid - r - 1) / 2;
        } else {
            val += mid * (mid - 1) / 2 + (r - mid);
        }
        if (val <= m) {
            ans = Math.max(ans, mid);
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return ans;
}
--------------------------------
int findLength(String s, char i, char j) {
    char required = i;
    int length = 0;
    for (char curr : s) {
        if (curr == required) {
            length += 1;
            if (required == i) {
                required = j;
            } else {
                required = i;
            }
        }
    }
    return length;
}
--------------------------------
boolean checkReverse(int leftSum, int rightSum) {
    int rev = 0;
    int temp = rightSum;
    while (temp!= 0) {
        rev = rev * 10 + temp % 10;
        temp /= 10;
    }
    return rev == leftSum;
}
--------------------------------
boolean isComposite(int n) {
    if (n <= 1) {
        return false;
    }
    if (n <= 3) {
        return false;
    }
    if (n % 2 == 0 || n % 3 == 0) {
        return true;
    }
    for (int i = 5; i * i <= n; i = i + 6) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return true;
        }
    }
    return false;
}
--------------------------------
int minDeletion(String s) {
    int n = s.length();
    int first_idx1 = -1;
    int last_idx0 = -1;
    for (int i = 0; i < n; i++) {
        if (s.charAt(i) == '1') {
            first_idx1 = i;
            break;
        }
    }
    for (int i = n - 1; i >= 0; i--) {
        if (s.charAt(i) == '0') {
            last_idx0 = i;
            break;
        }
    }
    if (first_idx1 == -1 || last_idx0 == -1) {
        return 0;
    }
    int count1 = 0, count0 = 0;
    for (int i = 0; i < last_idx0; i++) {
        if (s.charAt(i) == '1') {
            count1++;
        }
    }
    for (int i = first_idx1 + 1; i < n; i++) {
        if (s.charAt(i) == '1') {
            count0++;
        }
    }
    return Math.min(count0, count1);
}
--------------------------------
int minSteps(String s, int n) {
    int cost = 0;
    int[] f = new int[26];
    for (int i = 0; i < n; i++) {
        int curr_ele = s.charAt(i) - 'a';
        int smaller = 0;
        for (int j = 0; j <= curr_ele; j++) {
            if (f[j]!= 0) {
                smaller += f[j];
            }
        }
        if (smaller == 0) {
            cost += i + 1;
        } else {
            cost += i - smaller + 1;
        }
        f[s.charAt(i) - 'a']++;
    }
    return cost;
}
--------------------------------
int numberOfWays(int n) {
    int count = 0;
    for (int a = 1; a < n; a++) {
        for (int b = 1; b < n; b++) {
            int c = n - (a + b);
            if (a + b > c && a + c > b && b + c > a) {
                count++;
            }
        }
    }
    return count;
}
--------------------------------
int slopeOfNum(String num, int n) {
    int slope = 0;
    for (int i = 1; i < n - 1; i++) {
        if (num.charAt(i) > num.charAt(i - 1) && num.charAt(i) > num.charAt(i + 1)) {
            slope++;
        } else if (num.charAt(i) < num.charAt(i - 1) && num.charAt(i) < num.charAt(i + 1)) {
            slope++;
        }
    }
    return slope;
}
--------------------------------
int middleOfThree(int a, int b, int c) {
    int x = a - b;
    int y = b - c;
    int z = a - c;
    if (x * y > 0) {
        return b;
    } else if (x * z > 0) {
        return c;
    } else {
        return a;
    }
}
--------------------------------
int countMaxSetBits(int left, int right) {
    while ((left | (left + 1)) <= right) {
        left |= left + 1;
    }
    return left;
}
--------------------------------
int findS(int s) {
    int l = 1, r = (s / 2) + 1;
    while (l <= r) {
        int mid = (l + r) / 2;
        int sum = mid * (mid + 1) / 2;
        if (sum == s) {
            return mid;
        } else if (sum > s) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return -1;
}
--------------------------------
boolean check(String s) {
    int min = Integer.MAX_VALUE;
    int max = Integer.MIN_VALUE;
    int sum = 0;
    for (int i = 0; i < s.length(); i++) {
        int ascii = s.charAt(i);
        if (ascii < 96 || ascii > 122) {
            return false;
        }
        sum += ascii;
        if (min > ascii) {
            min = ascii;
        }
        if (max < ascii) {
            max = ascii;
        }
    }
    min -= 1;
    int eSum = max * (max + 1) / 2 - min * (min + 1) / 2;
    return sum == eSum;
}
--------------------------------
int minimumPossibleProduct(int k) {
    int res = 1;
    int r = (1 << k) - 1;
    for (int i = 0; i < k; i++) {
        res *= r - 1;
    }
    res *= r;
    return res;
}
--------------------------------
int findInGrid(int i, int j) {
    if (i == j) {
        return i * i - (i - 1);
    } else if (i > j) {
        if (i % 2 == 0) {
            return i * i - (j - 1);
        } else {
            return (i - 1) * (i - 1) + 1 + (j - 1);
        }
    } else {
        if (j % 2 == 0) {
            return (j - 1) * (j - 1) + 1 + (i - 1);
        } else {
            return j * j - (i - 1);
        }
    }
}
--------------------------------
int findMinOperationsReqEmpStr(String s) {
    int cnt_one = 0;
    int cnt_zero = 0;
    int n = s.length();
    for (int i = 0; i < n; i++) {
        if (s.charAt(i) == '0') {
            if (cnt_one > 0) {
                cnt_one--;
            }
            cnt_zero++;
        } else {
            if (cnt_zero > 0) {
                cnt_zero--;
            }
            cnt_one++;
        }
    }
    return cnt_one + cnt_zero;
}
--------------------------------
boolean isReachable(int x1, int y1, int x2, int y2) {
    while (x2 > x1 && y2 > y1) {
        if (x2 > y2) {
            x2 %= y2;
        } else {
            y2 %= x2;
        }
    }
    if (x2 == x1) {
        return y2 - y1 >= 0 && (y2 - y1) % x1 == 0;
    } else if (y2 == y1) {
        return x2 - x1 >= 0 && (x2 - x1) % y1 == 0;
    } else {
        return false;
    }
}
--------------------------------
int findMaxSoln(int n, int x, int y) {
    int ans = Integer.MIN_VALUE;
    for (int k = 0; k <= n; k++) {
        if (k % x == y) {
            ans = Math.max(ans, k);
        }
    }
    return ans >= 0 && ans <= n? ans : -1;
}
--------------------------------
int numberOfPairs(int n) {
    int count = 0;
    int i = 1, j = n - 1;
    while (i < j) {
        if (i + j == n) {
            count++;
        }
        i++;
        j--;
    }
    return count;
}
--------------------------------
int minChanges(String s, int n) {
    int count = 0, zeros = 0, ones = 0;
    if (s.charAt(0)!= '1') {
        count++;
        ones++;
    }
    for (int i = 1; i < n; i++) {
        if (s.charAt(i) == '0') {
            zeros++;
        } else {
            ones++;
        }
        if (zeros > ones) {
            zeros--;
            ones++;
            count++;
        }
    }
    return count;
}
--------------------------------
int kVisibleFromLeft(int n, int k) {
    if (n == k) {
        return 1;
    }
    if (k == 1) {
        int ans = 1;
        for (int i = 1; i < n; i++) {
            ans *= i;
        }
        return ans;
    }
    return kVisibleFromLeft(n - 1, k - 1) + (n - 1) * kVisibleFromLeft(n - 1, k);
}
--------------------------------
double find(int n, int sum) {
    if (sum > 6 * n || sum < n) {
        return 0;
    }
    if (n == 1) {
        if (sum >= 1 && sum <= 6) {
            return 1.0 / 6;
        } else {
            return 0;
        }
    }
    double s = 0;
    for (int i = 1; i <= 6; i++) {
        s += find(n - 1, sum - i) / 6;
    }
    return s;
}
--------------------------------
int binCoff(int n, int r) {
    int val = 1;
    if (r > n - r) {
        r = n - r;
    }
    for (int i = 0; i < r; i++) {
        val *= n - i;
        val /= i + 1;
    }
    return val;
}
--------------------------------
int getMask(int val) {
    int mask = 0;
    if (val == 0) {
        return 1;
    }
    while (val) {
        int d = val % 10;
        mask |= 1 << d;
        val /= 10;
    }
    return mask;
}
--------------------------------
int waysToKAdjacentSetBits(int n, int k, int currentIndex, int adjacentSetBits, int lastBit) {
    if (currentIndex == n) {
        if (adjacentSetBits == k) {
            return 1;
        }
        return 0;
    }
    int noOfWays = 0;
    if (lastBit == 1) {
        noOfWays += waysToKAdjacentSetBits(n, k, currentIndex + 1, adjacentSetBits + 1, 1);
        noOfWays += waysToKAdjacentSetBits(n, k, currentIndex + 1, adjacentSetBits, 0);
    } else if (!lastBit) {
        noOfWays += waysToKAdjacentSetBits(n, k, currentIndex + 1, adjacentSetBits, 1);
        noOfWays += waysToKAdjacentSetBits(n, k, currentIndex + 1, adjacentSetBits, 0);
    }
    return noOfWays;
}
--------------------------------
int checkFunc(int i, int j, String st) {
    if (st.charAt(i) == '(' && st.charAt(j) == ')') {
        return 1;
    }
    if (st.charAt(i) == '(' && st.charAt(j) == '?') {
        return 1;
    }
    if (st.charAt(i) == '?' && st.charAt(j) == ')') {
        return 1;
    }
    if (st.charAt(i) == '[' && st.charAt(j) == ']') {
        return 1;
    }
    if (st.charAt(i) == '[' && st.charAt(j) == '?') {
        return 1;
    }
    if (st.charAt(i) == '?' && st.charAt(j) == ']') {
        return 1;
    }
    if (st.charAt(i) == '{' && st.charAt(j) == '}') {
        return 1;
    }
    if (st.charAt(i) == '{' && st.charAt(j) == '?') {
        return 1;
    }
    if (st.charAt(i) == '?' && st.charAt(j) == '}') {
        return 1;
    }
    return 0;
}
--------------------------------
int findGolomb(int n) {
    if (n == 1) {
        return 1;
    }
    return 1 + findGolomb(n - findGolomb(findGolomb(n - 1)));
}
--------------------------------
boolean allOnes(String s, int n) {
    int co = 0;
    for (int i = 0; i < s.length(); i++) {
        co += s.charAt(i) == '1'? 1 : 0;
    }
    return co == n;
}
--------------------------------
int pad(int n) {
    int p_prev_prev = 1, p_prev = 1, p_curr = 1, p_next = 1;
    for (int i = 3; i <= n; i++) {
        p_next = p_prev_prev + p_prev;
        p_prev_prev = p_prev;
        p_prev = p_curr;
        p_curr = p_next;
    }
    return p_next;
}
--------------------------------
int oddLengthPalindrome(int k) {
    int palin = k;
    k = k / 10;
    while (k > 0) {
        int rev = k % 10;
        palin = palin * 10 + rev;
        k = k / 10;
    }
    return palin;
}
--------------------------------
String changeString(String s0) {
    String s = s0;
    int n = s.length();
    if (s.charAt(0) == '?') {
        s = s.substring(0, 1) + 'a' + s.substring(2);
        if (s.charAt(0) == s.charAt(1)) {
            s = s.substring(0, 1) + (char)(s.charAt(0) + 1) + s.substring(2);
        }
    }
    for (int i = 1; i < n - 1; i++) {
        if (s.charAt(i) == '?') {
            s = s.substring(0, i) + 'a' + s.substring(i + 1);
            if (s.charAt(i) == s.charAt(i - 1)) {
                s = s.substring(0, i) + (char)(s.charAt(i) + 1) + s.substring(i + 1);
            }
            if (s.charAt(i) == s.charAt(i + 1)) {
                s = s.substring(0, i) + (char)(s.charAt(i) + 1) + s.substring(i + 1);
            }
            if (s.charAt(i) == s.charAt(i - 1)) {
                s = s.substring(0, i) + (char)(s.charAt(i) + 1) + s.substring(i + 1);
            }
        }
    }
    if (s.charAt(n - 1) == '?') {
        s = s.substring(0, n - 1) + 'a' + s.substring(n);
        if (s.charAt(n - 1) == s.charAt(n - 2)) {
            s = s.substring(0, n - 1) + (char)(s.charAt(n - 1) + 1) + s.substring(n);
        }
    }
    return s;
}
--------------------------------
int totalHammingDistance(int n) {
    int i = 1, sum = 0;
    while (n / i > 0) {
        sum = sum + n / i;
        i = i * 2;
    }
    return sum;
}
--------------------------------
int checkBitonic(String s) {
    int i = 1;
    for (; i < s.length(); i++) {
        if (s.charAt(i) > s.charAt(i - 1)) {
            continue;
        }
        if (s.charAt(i) <= s.charAt(i - 1)) {
            break;
        }
    }
    if (i == s.length() - 1) {
        return 1;
    }
    int j = i + 1;
    for (; j < s.length(); j++) {
        if (s.charAt(j) < s.charAt(j - 1)) {
            continue;
        }
        if (s.charAt(j) >= s.charAt(j - 1)) {
            break;
        }
    }
    i = j;
    if (i!= s.length()) {
        return 0;
    }
    return 1;
}
--------------------------------
boolean endsWith(String str, String pat) {
    int pat_len = pat.length();
    int str_len = str.length();
    if (pat_len > str_len) {
        return false;
    }
    pat_len--;
    str_len--;
    while (pat_len >= 0) {
        if (pat[pat_len]!= str[str_len]) {
            return false;
        }
        pat_len--;
        str_len--;
    }
    return true;
}
--------------------------------
int getSum(int n, int d) {
    if (n < d) {
        return 0;
    }
    while (n % 10!= d) {
        n--;
    }
    int k = n / 10;
    return (k + 1) * d + (k * 10 + 10 * k * k) / 2;
}
--------------------------------
int balancedStringBySwapping(String s) {
    int unbalanced_pair = 0;
    for (int i = 0; i < s.length(); ++i) {
        if (unbalanced_pair > 0 && s.charAt(i) == ']') {
            --unbalanced_pair;
        } else if (s.charAt(i) == '[') {
            ++unbalanced_pair;
        }
    }
    return (unbalanced_pair + 1) / 2;
}
--------------------------------
int computeHash(String s) {
    int p = 31;
    long mod = 1e9 + 7;
    long hash_val = 0;
    long mul = 1;
    for (char ch : s) {
        hash_val = (hash_val + (ch - 'a' + 1) * mul) % mod;
        mul = mul * p % mod;
    }
    return hash_val;
}
--------------------------------
int countOfSubstringWithOnlyOnes(String s) {
    int res = 0, count = 0;
    for (int i = 0; i < s.length(); i++) {
        count = s.charAt(i) == '1'? count + 1 : 0;
        res = res + count;
    }
    return res;
}
--------------------------------
int composite(int n) {
    int flag = 0;
    int c = 0;
    for (int j = 1; j <= n; j++) {
        if (n % j == 0) {
            c += 1;
        }
    }
    if (c >= 3) {
        flag = 1;
    }
    return flag;
}
--------------------------------
boolean isDivBySix(String s, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += s.charAt(i) - 'a' + 1;
    }
    if (sum % 3!= 0) {
        return false;
    }
    int last_digit = (s.charAt(n - 1) - 'a' + 1) % 10;
    if (last_digit % 2!= 0) {
        return false;
    }
    return true;
}
--------------------------------
boolean IsRedundantBraces(String s) {
    int a = 0, b = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '(' && s.charAt(i + 2) == ')') {
            return true;
        }
        if (s.charAt(i) == '*' || s.charAt(i) == '+' || s.charAt(i) == '-' || s.charAt(i) == '/') {
            a++;
        }
        if (s.charAt(i) == '(') {
            b++;
        }
    }
    if (b > a) {
        return true;
    }
    return false;
}
--------------------------------
int countSubStr(String s, int n) {
    int count = 0;
    for (int i = 0; i < n - 2;) {
        if (s.charAt(i) == '0' && s.charAt(i + 1) == '1' && s.charAt(i + 2) == '0') {
            count++;
            i += 3;
        } else if (s.charAt(i) == '1' && s.charAt(i + 1) == '0' && s.charAt(i + 2) == '1') {
            count++;
            i += 3;
        } else {
            i++;
        }
    }
    return count;
}
--------------------------------
int prefixOccurrences(String s) {
    char c = s.charAt(0);
    int count_c = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == c) {
            count_c++;
        }
    }
    return count_c;
}
--------------------------------
boolean isValid(String s, int len) {
    for (int i = 1; i < len; i++) {
        if (s.charAt(i) == s.charAt(i - 1)) {
            return false;
        }
    }
    return true;
}
--------------------------------
int count(String s, int k) {
    int n = s.length();
    int d = 0;
    int count = 0;
    for (int i = 0; i < n; i++) {
        d += s.charAt(i);
    }
    if (d % k == 0) {
        count += 1;
    }
    for (int i = k; i < n; i++) {
        int prev = s.charAt(i - k);
        d -= prev;
        d += s.charAt(i);
        if (d % k == 0) {
            count += 1;
        }
    }
    return count;
}
--------------------------------
int findSubstringCount(String s) {
    int result = 0;
    int n = s.length();
    int i = 0;
    while (i < n - 1) {
        if (s.charAt(i) + 1 == s.charAt(i + 1)) {
            result++;
            while (i < n - 1 && s.charAt(i) + 1 == s.charAt(i + 1)) {
                i++;
            }
        }
        i++;
    }
    return result;
}
--------------------------------
boolean find(String s1, String s2) {
    int len1 = s1.length(), len2 = s2.length();
    if (len1!= len2) {
        return false;
    }
    int[] d = new int[len1];
    d[0] = s2.charAt(0) - s1.charAt(0);
    for (int i = 1; i < len1; i++) {
        if (s1.charAt(i) > s2.charAt(i)) {
            return false;
        } else {
            d[i] = s2.charAt(i) - s1.charAt(i);
        }
    }
    for (int i = 0; i < len1 - 1; i++) {
        if (d[i] < d[i + 1]) {
            return false;
        }
    }
    return true;
}
--------------------------------
boolean isInGivenBase(String s, int bas) {
    if (bas > 16) {
        return false;
    } else if (bas <= 10) {
        for (int i = 0; i < s.length(); i++) {
            if (!(s.charAt(i) >= '0' && s.charAt(i) < '0' + bas)) {
                return false;
            }
        }
    } else {
        for (int i = 0; i < s.length(); i++) {
            if (!((s.charAt(i) >= '0' && s.charAt(i) < '0' + bas) || (s.charAt(i) >= 'A' && s.charAt(i) < ('A' + bas - 10)))) {
                return false;
            }
        }
    }
    return true;
}
--------------------------------
int countNonEmptySubstr(String s) {
    int n = s.length();
    return n * (n + 1) / 2;
}
--------------------------------
int evenDecimalValue(String s, int n) {
    int result = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            int decimal_value = 0;
            int power_of_2 = 1;
            for (int k = i; k <= j; k++) {
                decimal_value += (s.charAt(k) - '0') * power_of_2;
                power_of_2 *= 2;
            }
            if (decimal_value % 2 == 0) {
                result++;
            }
        }
    }
    return result;
}
--------------------------------
int calculate(String s) {
    int ans = 6;
    for (int i = 0; i < 10; ++i) {
        for (int j = 0; j < 10; ++j) {
            for (int k = 0; k < 10; ++k) {
                for (int l = 0; l < 10; ++l) {
                    for (int m = 0; m < 10; ++m) {
                        for (int n = 0; n < 10; ++n) {
                            if (i + j + k == l + m + n) {
                                int c = 0;
                                if (i!= s.charAt(0) - '0') {
                                    c++;
                                }
                                if (j!= s.charAt(1) - '0') {
                                    c++;
                                }
                                if (k!= s.charAt(2) - '0') {
                                    c++;
                                }
                                if (l!= s.charAt(3) - '0') {
                                    c++;
                                }
                                if (m!= s.charAt(4) - '0') {
                                    c++;
                                }
                                if (n!= s.charAt(5) - '0') {
                                    c++;
                                }
                                if (c < ans) {
                                    ans = c;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return ans;
}
--------------------------------
int xorZero(String s) {
    int oneCount = 0, zeroCount = 0;
    int n = s.length();
    for (int i = 0; i < n; i++) {
        if (s.charAt(i) == '1') {
            oneCount++;
        } else {
            zeroCount++;
        }
    }
    if (oneCount % 2 == 0) {
        return zeroCount;
    }
    return oneCount;
}
--------------------------------
String evenLength(String n) {
    String res = n;
    for (int j = n.length() - 1; j >= 0; --j) {
        res += n.charAt(j);
    }
    return res;
}
--------------------------------
int countSubstringWithEqualEnds(String s) {
    int result = 0;
    int n = s.length();
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            if (s.charAt(i) == s.charAt(j)) {
                result++;
            }
        }
    }
    return result;
}
--------------------------------
double normalSlope(double a, double b, double x1, double y1) {
    double g = a / 2;
    double f = b / 2;
    if (g - x1 == 0) {
        return -1;
    }
    double slope = (f - y1) / (g - x1);
    if (slope == 0) {
        return -2;
    }
    return slope;
}
--------------------------------
boolean orthogonality(int x1, int y1, int x2, int y2, int r1, int r2) {
    int dsquare = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
    if (dsquare == r1 * r1 + r2 * r2) {
        return true;
    } else {
        return false;
    }
}
--------------------------------
double findAreaShaded(double a) {
    double sq_area = a * a;
    double semi_circle_area = 3.14 * (a * a) / 8;
    double shaded_area = 4 * semi_circle_area - sq_area;
    return shaded_area;
}
--------------------------------
int factorial(int a, int b) {
    int res = 1;
    for (int i = 1; i <= a + b; i++) {
        res = res * i;
    }
    for (int i = 1; i <= a; i++) {
        res = res / i;
    }
    for (int i = 1; i <= b; i++) {
        res = res / i;
    }
    return res;
}
--------------------------------
int factorTree(int n) {
    int height = 0;
    while (n > 1) {
        boolean flag = false;
        for (int i = 2; i <= Math.sqrt(n); i++) {
            if (n % i == 0) {
                n = n / i;
                flag = true;
                break;
            }
        }
        height++;
        if (!flag) {
            break;
        }
    }
    return height;
}
--------------------------------
String findIfPossible(int n, int s, int x) {
    if (s >= x && s % 2 == x % 2) {
        if (n >= 3) {
            return "Yes";
        }
        if (n == 1) {
            if (s == x) {
                return "Yes";
            } else {
                return "No";
            }
        }
        if (n == 2) {
            int c = (s - x) / 2;
            int a = c;
            int b = c;
            a = a + x;
            if ((a ^ b) == x) {
                return "Yes";
            } else {
                return "No";
            }
        }
    }
    return "No";
}
--------------------------------
int maximumTripletXor(int a, int b, int c) {
    int ans = 0;
    for (int i = 30; i >= 0; i--) {
        int cur = 1 << i;
        if (a >= cur) {
            ans += cur;
            a -= cur;
        } else if (b >= cur) {
            ans += cur;
            b -= cur;
        } else if (c >= cur) {
            ans += cur;
            c -= cur;
        }
    }
    return ans;
}
--------------------------------
int itemType(int n) {
    int count = 0;
    int day = 1;
    while (count + day * (day + 1) / 2 < n) {
        count += day * (day + 1) / 2;
        day++;
    }
    for (int type = day; type > 0; type--) {
        count += type;
        if (count >= n) {
            return type;
        }
    }
    return 0;
}
--------------------------------
int maxGcdInRange(int l, int r) {
    int ans = 1;
    for (int z = r; z >= 1; z--) {
        if (r / z - (l - 1) / z > 1) {
            ans = z;
            break;
        }
    }
    return ans;
}
--------------------------------
int sumOfDigits(int n) {
    int sum = 0;
    while (n!= 0) {
        sum += n % 10;
        n = n / 10;
    }
    return sum;
}
--------------------------------
boolean isRepUnitNum(int n, int b) {
    int length = 0;
    int count_one = 0;
    while (n!= 0) {
        int r = n % b;
        length++;
        if (r == 1) {
            count_one++;
        }
        n = n / b;
    }
    return count_one >= 3 && count_one == length;
}
--------------------------------
boolean isStraightLineNum(int n) {
    if (n <= 99) {
        return false;
    }
    String s = Integer.toString(n);
    int d = s.charAt(1) - s.charAt(0);
    for (int i = 2; i < s.length(); i++) {
        if (s.charAt(i) - s.charAt(i - 1)!= d) {
            return false;
        }
    }
    return true;
}
--------------------------------
int getCount(int d, int n) {
    int no = n / d;
    int result = no;
    for (int p = 2; p * p <= no; ++p) {
        if (no % p == 0) {
            while (no % p == 0) {
                no /= p;
            }
            result -= result / p;
        }
    }
    if (no > 1) {
        result -= result / no;
    }
    return result;
}
--------------------------------
boolean isEvenParity(int x) {
    int parity = 0;
    while (x!= 0) {
        if (x & 1) {
            parity++;
        }
        x = x >> 1;
    }
    if (parity % 2 == 0) {
        return true;
    } else {
        return false;
    }
}
--------------------------------
int isPerfect(int n) {
    int sum = 1;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            if (i * i!= n) {
                sum = sum + i + n / i;
            } else {
                sum = sum + i;
            }
        }
    }
    if (sum == n && n!= 1) {
        return n;
    }
    return 0;
}
--------------------------------
int logAToBaseB(int a, int b) {
    return a > b - 1? 1 + logAToBaseB(a / b, b) : 0;
}
--------------------------------
int usingBinarySearch(int start, int end, int n, int s) {
    if (start >= end) {
        return start;
    }
    int mid = start + (end - start) / 2;
    int totalSum = n * (n + 1) / 2;
    int midSum = mid * (mid + 1) / 2;
    if (totalSum - midSum <= s) {
        return usingBinarySearch(start, mid, n, s);
    }
    return usingBinarySearch(mid + 1, end, n, s);
}
--------------------------------
String minInt(String s) {
    String s1 = s;
    for (int i = 0; i < s.length(); i++) {
        if (s1.charAt(i) >= '5') {
            s1 = s1.substring(0, i) + (char) (9 - s1.charAt(i) + '0') + s1.substring(i + 1);
        }
    }
    if (s1.charAt(0) == '0') {
        s1 = s1.substring(1);
    }
    return s1;
}
--------------------------------
int countTriplets(int a, int b, int c) {
    int ans = 0;
    for (int i = 1; i <= a; i++) {
        for (int j = 1; j <= b; j++) {
            for (int k = 1; k <= c; k++) {
                if (i * k > j * j) {
                    ans++;
                }
            }
        }
    }
    return ans;
}
--------------------------------
boolean topsyTurvy(String s) {
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '2' || s.charAt(i) == '4' || s.charAt(i) == '5' || s.charAt(i) == '6' || s.charAt(i) == '7' || s.charAt(i) == '9') {
            return false;
        }
    }
    return true;
}
--------------------------------
int sumOfLastDig(int n, int m) {
    int sum = 0;
    int k = n / m;
    int[] arr = new int[10];
    for (int i = 0; i < 10; i++) {
        arr[i] = (m * (i + 1)) % 10;
        sum += arr[i];
    }
    int rem = k % 10;
    int ans = k / 10 * sum;
    for (int i = 0; i < rem; i++) {
        ans += arr[i];
    }
    return ans;
}
--------------------------------
int totalPay(int totalItems, int priceOfOneItem, int n, int m) {
    int freeItems = 0, actual = 0;
    freeItems = totalItems / (n + m);
    actual = totalItems - freeItems;
    int amount = actual * priceOfOneItem;
    return amount;
}
--------------------------------
int minOperations(int x, int y, int p, int q) {
    if (y % x!= 0) {
        return -1;
    }
    int d = y / x;
    int a = 0;
    while (d % p == 0) {
        d /= p;
        a += 1;
    }
    int b = 0;
    while (d % q == 0) {
        d /= q;
        b += 1;
    }
    if (d!= 1) {
        return -1;
    }
    return a + b;
}
--------------------------------
boolean isMersenne(int n) {
    while (n!= 0) {
        int r = n % 2;
        if (r == 0) {
            return false;
        }
        n /= 2;
    }
    return true;
}
--------------------------------
int findThirdDigit(int n) {
    if (n < 3) {
        return 0;
    }
    return (n & 1)? 1 : 6;
}
--------------------------------
boolean isOddLength(int num) {
    int count = 0;
    while (num > 0) {
        num /= 10;
        count++;
    }
    if (count % 2!= 0) {
        return true;
    }
    return false;
}
--------------------------------
boolean checkIsPossible(int l, int r, int k) {
    int count = 0;
    for (int i = l; i <= r; i++) {
        if (i % k == 0) {
            count++;
        }
    }
    return count > 1;
}
--------------------------------
int bytes(int kilobytes) {
    int b = kilobytes * 1024;
    return b;
}
--------------------------------
int octahedralNum(int n) {
    return n * (2 * n * n + 1) / 3;
}
--------------------------------
String checkEqual(String s) {
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i)!= '1' && s.charAt(i)!= '0' && s.charAt(i)!= '8') {
            return "No";
        }
    }
    int start = 0, end = s.length() - 1;
    while (start < end) {
        if (s.charAt(start)!= s.charAt(end)) {
            return "No";
        }
        start++;
        end--;
    }
    return "Yes";
}
--------------------------------
boolean isUndulating(String n) {
    if (n.length() <= 2) {
        return false;
    }
    for (int i = 2; i < n.length(); i++) {
        if (n.charAt(i - 2)!= n.charAt(i)) {
            return false;
        }
    }
    return true;
}
--------------------------------
int firstDigit(int n) {
    while (n >= 10) {
        n /= 10;
    }
    return n;
}
--------------------------------
int countDigit(int n) {
    if (n == 0) {
        return 0;
    }
    return 1 + countDigit(n / 10);
}
--------------------------------
boolean isDivisibleBy5(String s) {
    int n = s.length();
    return s.charAt(n - 1) - '0' == 0 || s.charAt(n - 1) - '0' == 5;
}
--------------------------------
int inv(int a, int m) {
    int m0 = m;
    int x0 = 0, x1 = 1;
    if (m == 1) {
        return 0;
    }
    while (a > 1) {
        int q = a / m;
        int t = m;
        m = a % m;
        a = t;
        t = x0;
        x0 = x1 - q * x0;
        x1 = t;
    }
    if (x1 < 0) {
        x1 += m0;
    }
    return x1;
}
--------------------------------
boolean onlyFirstAndLastAreSet(int n) {
    if (n == 1) {
        return true;
    }
    if (n == 2) {
        return false;
    }
    return ((n - 1) & (n - 2)) == 0;
}
--------------------------------
int divide(int dividend, int divisor) {
    int sign = ((dividend < 0) ^ (divisor < 0))? -1 : 1;
    dividend = Math.abs(dividend);
    divisor = Math.abs(divisor);
    int quotient = 0;
    long temp = 0;
    for (int i = 31; i >= 0; --i) {
        if (temp + ((long)divisor << i) <= dividend) {
            temp += (long)divisor << i;
            quotient |= 1 << i;
        }
    }
    if (sign == -1) {
        quotient = -quotient;
    }
    return quotient;
}
--------------------------------
char findProfession(int level, int pos) {
    if (level == 1) {
        return 'e';
    }
    if (findProfession(level - 1, (pos + 1) / 2) == 'd') {
        return pos % 2? 'd' : 'e';
    }
    return pos % 2? 'e' : 'd';
}
--------------------------------
boolean hasCloseElements(List<Double> numbers, double threshold) {
    for (int i = 0; i < numbers.size(); i++) {
        for (int j = i + 1; j < numbers.size(); j++) {
            double distance = Math.abs(numbers.get(i) - numbers.get(j));
            if (distance < threshold) {
                return true;
            }
        }
    }
    return false;
}
--------------------------------
double truncateNumber(double number) {
    return number % 1;
}
--------------------------------
boolean belowZero(List<Integer> operations) {
    int balance = 0;
    for (int op : operations) {
        balance += op;
        if (balance < 0) {
            return true;
        }
    }
    return false;
}
--------------------------------
double meanAbsoluteDeviation(List<Double> numbers) {
    double sum_num = 0;
    for (double num : numbers) {
        sum_num += num;
    }
    double mean = sum_num / numbers.size();
    double sum_abs_diff = 0;
    for (double num : numbers) {
        sum_abs_diff += Math.abs(num - mean);
    }
    return sum_abs_diff / numbers.size();
}
--------------------------------
List<Integer> intersperse(List<Integer> numbers, int delimiter) {
    List<Integer> result = new ArrayList<>();
    if (numbers.isEmpty()) {
        return result;
    }
    for (int i = 0; i < numbers.size() - 1; i++) {
        result.add(numbers.get(i));
        result.add(delimiter);
    }
    result.add(numbers.get(numbers.size() - 1));
    return result;
}
--------------------------------
List<Integer> sumProduct(List<Integer> numbers) {
    int sumValue = 0;
    int prodValue = 1;
    for (int n : numbers) {
        sumValue += n;
        prodValue *= n;
    }
    return Arrays.asList(sumValue, prodValue);
}
--------------------------------
List<String> allPrefixes(String s) {
    List<String> result = new ArrayList<>();
    for (int i = 1; i <= s.length(); i++) {
        result.add(s.substring(0, i));
    }
    return result;
}
--------------------------------
List<Integer> parseMusic(String musicString) {
    String current = "";
    List<Integer> result = new ArrayList<>();
    for (int i = 0; i <= musicString.length(); i++) {
        if (i == musicString.length() || musicString.charAt(i) =='') {
            if (current.equals("o")) {
                result.add(4);
            }
            if (current.equals("o|")) {
                result.add(2);
            }
            if (current.equals(".|")) {
                result.add(1);
            }
            current = "";
        } else {
            current += musicString.charAt(i);
        }
    }
    return result;
}
--------------------------------
int strlen(String s) {
    return s.length();
}
--------------------------------
List<Integer> factorize(int n) {
    List<Integer> factors = new ArrayList<>();
    for (int i = 2; i <= n; i++) {
        if (n % i == 0) {
            n /= i;
            factors.add(i);
            i--;
        }
    }
    return factors;
}
--------------------------------
String concatenate(List<String> strings) {
    String result = "";
    for (String s : strings) {
        result += s;
    }
    return result;
}
--------------------------------
List<Double> getPositive(List<Double> l) {
    List<Double> result = new ArrayList<>();
    for (int i = 0; i < l.size(); i++) {
        if (l.get(i) > 0) {
            result.add(l.get(i));
        }
    }
    return result;
}
--------------------------------
List<Double> sortEven(List<Double> l) {
    List<Double> evens = new ArrayList<>();
    for (int i = 0; i < l.size(); i += 2) {
        evens.add(l.get(i));
    }
    Collections.sort(evens);
    List<Double> result = new ArrayList<>();
    for (int i = 0; i < l.size(); i++) {
        if (i % 2 == 0) {
            result.add(evens.get(i / 2));
        }
        if (i % 2 == 1) {
            result.add(l.get(i));
        }
    }
    return result;
}
--------------------------------
String decodeCyclic(String s) {
    String output = "";
    int i = 0;
    while (i <= s.length() - 3) {
        String x = s.substring(i + 2, i + 4);
        output += x;
        i += 3;
    }
    return output + s.substring(i);
}
--------------------------------
int carRaceCollision(int n) {
    return Math.pow(n, 2);
}
--------------------------------
List<Integer> incrList(List<Integer> l) {
    List<Integer> result = new ArrayList<Integer>();
    for (int i : l) {
        result.add(i + 1);
    }
    return result;
}
--------------------------------
boolean pairsSumToZero(List<Integer> l) {
    for (int i = 0; i < l.size(); i++) {
        for (int j = i + 1; j < l.size(); j++) {
            if (l.get(i) + l.get(j) == 0) {
                return true;
            }
        }
    }
    return false;
}
--------------------------------
String changeBase(int x, int b) {
    String ret = "";
    while (x > 0) {
        ret = ret + x % b;
        x = x / b;
    }
    return ret;
}
--------------------------------
double median(List<Double> l) {
    Collections.sort(l);
    if (l.size() % 2 == 1) {
        return l.get(l.size() / 2);
    }
    return (l.get(l.size() / 2) + l.get(l.size() / 2 - 1)) / 2;
}
--------------------------------
String decodeShift(String s) {
    String result = "";
    for (char ch : s.toCharArray()) {
        char w = (char) ((ch + 21 - 'a') % 26 + 'a');
        result += w;
    }
    return result;
}
--------------------------------
boolean belowThreshold(List<Integer> l, int t) {
    for (int n : l) {
        if (n >= t) {
            return false;
        }
    }
    return true;
}
--------------------------------
boolean correctBracketing(String brackets) {
    int depth = 0;
    for (char b : brackets) {
        if (b == '<') {
            depth += 1;
        }
        if (b == '>') {
            depth -= 1;
        }
        if (depth < 0) {
            return false;
        }
    }
    return depth == 0;
}
--------------------------------
boolean monotonic(List<Double> l) {
    int incr = 0;
    int decr = 0;
    for (int i = 1; i < l.size(); i++) {
        if (l.get(i) > l.get(i - 1)) {
            incr = 1;
        }
        if (l.get(i) < l.get(i - 1)) {
            decr = 1;
        }
    }
    return incr + decr!= 2;
}
--------------------------------
List<Double> derivative(List<Double> xs) {
    List<Double> result = new ArrayList<>();
    for (int i = 1; i < xs.size(); i++) {
        result.add(i * xs.get(i));
    }
    return result;
}
--------------------------------
int vowelsCount(String s) {
    String vowels = "aeiouAEIOU";
    int count = 0;
    for (char ch : s.toCharArray()) {
        if (vowels.indexOf(ch)!= -1) {
            count += 1;
        }
    }
    if (s.charAt(s.length() - 1) == 'y' || s.charAt(s.length() - 1) == 'Y') {
        count += 1;
    }
    return count;
}
--------------------------------
int digitSum(String s) {
    int sum = 0;
    for (char c : s.toCharArray()) {
        if (Character.isUpperCase(c)) {
            sum += c;
        }
    }
    return sum;
}
--------------------------------
int fruitDistribution(String s, int n) {
    String num1 = "";
    String num2 = "";
    boolean flag = false;
    for (int i = 0; i < s.length(); i++) {
        if (Character.isDigit(s.charAt(i))) {
            if (!flag) {
                num1 += s.charAt(i);
            }
            if (flag) {
                num2 += s.charAt(i);
            }
        } else if (!flag && num1.length() > 0) {
            flag = true;
        }
    }
    return n - Integer.parseInt(num1) - Integer.parseInt(num2);
}
--------------------------------
List<Integer> pluck(List<Integer> arr) {
    List<Integer> result = new ArrayList<>();
    for (int i = 0; i < arr.size(); i++) {
        if (arr.get(i) % 2 == 0) {
            if (result.isEmpty()) {
                result.add(arr.get(i));
                result.add(i);
            } else if (arr.get(i) < result.get(0)) {
                result.set(0, arr.get(i));
                result.set(1, i);
            }
        }
    }
    return result;
}
--------------------------------
List<Integer> strangeSortList(List<Integer> lst) {
    List<Integer> res = new ArrayList<>();
    lst.sort(Comparator.naturalOrder());
    int l = 0;
    int r = lst.size() - 1;
    while (l < r) {
        res.add(lst.get(l));
        l += 1;
        res.add(lst.get(r));
        r -= 1;
    }
    if (l == r) {
        res.add(lst.get(l));
    }
    return res;
}
--------------------------------
double triangleArea(double a, double b, double c) {
    if (a + b <= c || a + c <= b || b + c <= a) {
        return -1;
    }
    double s = (a + b + c) / 2;
    return Math.sqrt(s * (s - a) * (s - b) * (s - c));
}
--------------------------------
boolean willItFly(List<Integer> q, int w) {
    int sum = 0;
    for (int i = 0; i < q.size(); i++) {
        if (q.get(i)!= q.get(q.size() - i - 1)) {
            return false;
        }
        sum += q.get(i);
    }
    return sum <= w;
}
--------------------------------
boolean isCube(int a) {
    a = Math.abs(a);
    int i = (int) Math.round(Math.pow(a, 1.0 / 3));
    return Math.pow(i, 3) == a;
}
--------------------------------
int hexKey(String num) {
    String key = "2357BD";
    int total = 0;
    for (char c : num.toCharArray()) {
        if (key.indexOf(c)!= -1) {
            total += 1;
        }
    }
    return total;
}
--------------------------------
String decimalToBinary(int dec) {
    String ans = "";
    if (dec!= 0) {
        while (dec > 0) {
            ans = ans + dec % 2;
            dec /= 2;
        }
    } else {
        ans += "0";
    }
    return "db" + ans + "db";
}
--------------------------------
boolean primeLength(String s) {
    int l = s.length();
    if (l < 2) {
        return false;
    }
    for (int i = 2; i < l; i++) {
        if (l % i == 0) {
            return false;
        }
    }
    return true;
}
--------------------------------
int startsOneEnds(int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    return 18 * Math.pow(10, n - 2);
}
--------------------------------
int add(List<Integer> lst) {
    int sum = 0;
    for (int i = 1; i < lst.size(); i += 2) {
        if (lst.get(i) % 2 == 0) {
            sum += lst.get(i);
        }
    }
    return sum;
}
--------------------------------
List<List<Integer> > getRow(List<List<Integer> > lst, int x) {
 List<List<Integer> > coords = new ArrayList<>();
 for (int i = 0; i < lst.size(); i++) {
   for (int j = lst.get(i).size() - 1; j >= 0; j--) {
     if (lst.get(i).get(j) == x) {
       coords.add(Arrays.asList(i, j));
     }
   }
 }
 return coords;
}
--------------------------------
int nextSmallest(List<Integer> lst) {
    lst.sort(Comparator.naturalOrder());
    for (int i = 1; i < lst.size(); i++) {
        if (lst.get(i)!= lst.get(i - 1)) {
            return lst.get(i);
        }
    }
    return -1;
}
--------------------------------
boolean anyInt(double a, double b, double c) {
    return (Math.round(a) == a && Math.round(b) == b && Math.round(c) == c) && (a + b == c || a + c == b || b + c == a);
}
--------------------------------
List<Integer> countUpTo(int n) {
    List<Integer> primes = new ArrayList<>();
    for (int i = 2; i < n; i++) {
        boolean isPrime = true;
        for (int j = 2; j < i; j++) {
            if (i % j == 0) {
                isPrime = false;
                break;
            }
        }
        if (isPrime) {
            primes.add(i);
        }
    }
    return primes;
}
--------------------------------
int closestInteger(String value) {
    double w = Double.parseDouble(value);
    return Math.round(w);
}
--------------------------------
List<Integer> makeAPile(int n) {
    List<Integer> result = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        result.add(n + 2 * i);
    }
    return result;
}
--------------------------------
List<String> wordStrings(String s) {
    List<String> words = new ArrayList<>();
    StringBuilder current = new StringBuilder();
    for (int i = 0; i <= s.length(); i++) {
        if (i == s.length() || s.charAt(i) =='' || s.charAt(i) == ',') {
            if (current.length() > 0) {
                words.add(current.toString());
                current.setLength(0);
            }
        } else {
            current.append(s.charAt(i));
        }
    }
    return words;
}
--------------------------------
String roundedAvg(int n, int m) {
    if (n > m) {
        return "-1";
    }
    int num = (m + n) / 2;
    String ret = "";
    while (num > 0) {
        ret = ret + num % 2;
        num /= 2;
    }
    return ret;
}
--------------------------------
List<Integer> uniqueDigits(List<Integer> x) {
    List<Integer> digits = new ArrayList<>();
    for (int n : x) {
        boolean isUnique = true;
        for (char c : Integer.toString(n).toCharArray()) {
            if (c % 2 == 0) {
                isUnique = false;
                break;
            }
        }
        if (isUnique) {
            digits.add(n);
        }
    }
    Collections.sort(digits);
    return digits;
}
--------------------------------
int countNums(List<Integer> arr) {
    int num = 0;
    for (int n : arr) {
        int neg = n < 0? -1 : 1;
        n = Math.abs(n);
        List<Integer> digits = new ArrayList<>();
        for (char c : String.valueOf(n).toCharArray()) {
            digits.add(c - '0');
        }
        digits.set(0, digits.get(0) * neg);
        int sum = 0;
        for (int d : digits) {
            sum += d;
        }
        if (sum > 0) {
            num += 1;
        }
    }
    return num;
}
--------------------------------
boolean moveOneBall(List<Integer> arr) {
    if (arr.isEmpty()) {
        return true;
    }
    int num = 0;
    for (int i = 1; i < arr.size(); i++) {
        if (arr.get(i) < arr.get(i - 1)) {
            num += 1;
        }
    }
    if (arr.get(arr.size() - 1) > arr.get(0)) {
        num += 1;
    }
    if (num < 2) {
        return true;
    }
    return false;
}
--------------------------------
String exchange(List<Integer> lst1, List<Integer> lst2) {
    int odd = 0;
    int even = 0;
    for (int n : lst1) {
        if (n % 2 == 1) {
            odd += 1;
        }
    }
    for (int n : lst2) {
        if (n % 2 == 0) {
            even += 1;
        }
    }
    if (even >= odd) {
        return "YES";
    }
    return "NO";
}
--------------------------------
List<String> oddCount(List<String> lst) {
    List<String> results = new ArrayList<>();
    String originalStr = "the number of odd elements in the string i of the input.";
    for (String s : lst) {
        int sum = 0;
        for (char d : s.toCharArray()) {
            if (Character.isDigit(d) && d % 2 == 1) {
                sum += 1;
            }
        }
        String result = "";
        for (char c : originalStr.toCharArray()) {
            if (c == 'i') {
                result += sum;
            } else {
                result += c;
            }
        }
        results.add(result);
    }
    return results;
}
--------------------------------
int minSubArraySum(List<Integer> nums) {
    int minSum = Integer.MAX_VALUE;
    int sum = 0;
    for (int num : nums) {
        sum += num;
        if (minSum > sum) {
            minSum = sum;
        }
        if (sum > 0) {
            sum = 0;
        }
    }
    return minSum;
}
--------------------------------
int maxFill(List<List<Integer> > grid, int capacity) {
    int res = 0;
    for (List<Integer> well : grid) {
        int sum = 0;
        for (int n : well) {
            sum += n;
        }
        if (sum > 0) {
            res += (sum - 1) / capacity + 1;
        }
    }
    return res;
}
--------------------------------
List<String> selectWords(String s, int n) {
    String vowels = "aeiouAEIOU";
    String current = "";
    List<String> result = new ArrayList<>();
    int consonantNum = 0;
    for (int i = 0; i <= s.length(); i++) {
        if (i == s.length() || s.charAt(i) =='') {
            if (consonantNum == n) {
                result.add(current);
            }
            current = "";
            consonantNum = 0;
        } else {
            current += s.charAt(i);
            if (vowels.indexOf(s.charAt(i)) == -1) {
                consonantNum += 1;
            }
        }
    }
    return result;
}
--------------------------------
int solution(List<Integer> lst) {
    int sum = 0;
    for (int i = 0; i < lst.size(); i += 2) {
        if (lst.get(i) % 2 == 1) {
            sum += lst.get(i);
        }
    }
    return sum;
}
--------------------------------
int addElements(List<Integer> arr, int k) {
    int sum = 0;
    for (int i = 0; i < k; i++) {
        if (arr.get(i) >= -99 && arr.get(i) <= 99) {
            sum += arr.get(i);
        }
    }
    return sum;
}
--------------------------------
List<Integer> getOddCollatz(int n) {
    List<Integer> oddCollatz = new ArrayList<>();
    while (n!= 1) {
        if (n % 2 == 1) {
            oddCollatz.add(n);
            n = n * 3 + 1;
        } else {
            n /= 2;
        }
    }
    oddCollatz.add(1);
    oddCollatz.sort(Comparator.naturalOrder());
    return oddCollatz;
}
--------------------------------
boolean isSorted(List<Integer> lst) {
    for (int i = 1; i < lst.size(); i++) {
        if (lst.get(i) < lst.get(i - 1)) {
            return false;
        }
        if (i >= 2 && lst.get(i) == lst.get(i - 1) && lst.get(i) == lst.get(i - 2)) {
            return false;
        }
    }
    return true;
}
--------------------------------
String intersection(List<Integer> interval1, List<Integer> interval2) {
    int inter1 = Math.max(interval1.get(0), interval2.get(0));
    int inter2 = Math.min(interval1.get(1), interval2.get(1));
    int l = inter2 - inter1;
    if (l < 2) {
        return "NO";
    }
    for (int i = 2; i < l; i++) {
        if (l % i == 0) {
            return "NO";
        }
    }
    return "YES";
}
--------------------------------
int prodSigns(List<Integer> arr) {
    if (arr.isEmpty()) {
        return -32768;
    }
    int sum = 0;
    int prods = 1;
    for (int i : arr) {
        sum += Math.abs(i);
        if (i == 0) {
            prods = 0;
        }
        if (i < 0) {
            prods = -prods;
        }
    }
    return sum * prods;
}
--------------------------------
List<Integer> minPath(List<List<Integer> > grid, int k) {
    int n = grid.size();
    int minNum = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (grid.get(i).get(j) == 1) {
                List<Integer> tmp = new ArrayList<>();
                if (i!= 0) {
                    tmp.add(grid.get(i - 1).get(j));
                }
                if (j!= 0) {
                    tmp.add(grid.get(i).get(j - 1));
                }
                if (i!= n - 1) {
                    tmp.add(grid.get(i + 1).get(j));
                }
                if (j!= n - 1) {
                    tmp.add(grid.get(i).get(j + 1));
                }
                minNum = Collections.min(tmp);
            }
        }
    }
    List<Integer> ans = new ArrayList<>();
    for (int i = 0; i < k; i++) {
        if (i % 2 == 0) {
            ans.add(1);
        } else {
            ans.add(minNum);
        }
    }
    return ans;
}
--------------------------------
int digits(int n) {
    int prod = 0;
    for (char digit : Integer.toString(n).toCharArray()) {
        if (digit % 2 == 1) {
            if (prod == 0) {
                prod = 1;
            }
            prod *= digit - '0';
        }
    }
    return prod;
}
--------------------------------
boolean isNested(String s) {
    int count = 0;
    int max_count = 0;
    for (char ch : s.toCharArray()) {
        if (ch == '[') {
            count += 1;
        }
        if (ch == ']') {
            count -= 1;
        }
        if (count < 0) {
            count = 0;
        }
        if (count > max_count) {
            max_count = count;
        }
        if (count <= max_count - 2) {
            return true;
        }
    }
    return false;
}
--------------------------------
int sumSquares(List<Double> lst) {
    int sum = 0;
    for (double i : lst) {
        sum += Math.ceil(i) * Math.ceil(i);
    }
    return sum;
}
--------------------------------
int canArrange(List<Integer> arr) {
    int index = -1;
    for (int i = 0; i < arr.size(); i++) {
        if (arr.get(i) <= i) {
            index = i;
        }
    }
    return index;
}
--------------------------------
List<Integer> largestSmallestIntegers(List<Integer> lst) {
    int maxNeg = 0, minPos = 0;
    for (int n : lst) {
        if (n < 0 && (maxNeg == 0 || n > maxNeg)) {
            maxNeg = n;
        }
        if (n > 0 && (minPos == 0 || n < minPos)) {
            minPos = n;
        }
    }
    return Arrays.asList(maxNeg, minPos);
}
--------------------------------
String fixSpaces(String text) {
    String res = "";
    int space_len = 0;
    for (int i = 0; i <= text.length(); i++) {
        if (i == text.length() || text.charAt(i)!='') {
            if (space_len == 1) {
                res += '_';
            }
            if (space_len == 2) {
                res += "__";
            }
            if (space_len > 2) {
                res += '-';
            }
            space_len = 0;
            if (i!= text.length()) {
                res += text.charAt(i);
            }
        } else {
            space_len += 1;
        }
    }
    return res;
}
--------------------------------
String filenameCheck(String fileName) {
    int digitNum = 0, dotNum = 0;
    if (fileName.length() < 5 ||!Character.isLetter(fileName.charAt(0))) {
        return "No";
    }
    String suffix = fileName.substring(fileName.length() - 4);
    if (!suffix.equals(".txt") &&!suffix.equals(".exe") &&!suffix.equals(".dll")) {
        return "No";
    }
    for (char c : fileName.toCharArray()) {
        if (Character.isDigit(c)) {
            digitNum += 1;
        }
        if (c == '.') {
            dotNum += 1;
        }
    }
    if (digitNum > 3 || dotNum!= 1) {
        return "No";
    }
    return "Yes";
}
--------------------------------
int sumSquares(List<Integer> lst) {
    int sum = 0;
    for (int i = 0; i < lst.size(); i++) {
        if (i % 3 == 0) {
            sum += lst.get(i) * lst.get(i);
        } else if (i % 4 == 0) {
            sum += lst.get(i) * lst.get(i) * lst.get(i);
        } else {
            sum += lst.get(i);
        }
    }
    return sum;
}
--------------------------------
String wordsInSentence(String sentence) {
    String result = "";
    String current = "";
    for (int i = 0; i <= sentence.length(); i++) {
        if (i == sentence.length() || sentence.charAt(i) =='') {
            boolean isPrime = true;
            int l = current.length();
            if (l < 2) {
                isPrime = false;
            }
            for (int j = 2; j < l; j++) {
                if (l % j == 0) {
                    isPrime = false;
                    break;
                }
            }
            if (isPrime) {
                result += current +'';
            }
            current = "";
        } else {
            current += sentence.charAt(i);
        }
    }
    if (result.length() > 0) {
        result = result.substring(0, result.length() - 1);
    }
    return result;
}
--------------------------------
boolean simplify(String x, String n) {
    int a = 0, b = 0, c = 0, d = 0;
    for (int i = 0; i < x.length(); i++) {
        if (x.charAt(i) == '/') {
            a = Integer.parseInt(x.substring(0, i));
            b = Integer.parseInt(x.substring(i + 1));
        }
    }
    for (int i = 0; i < n.length(); i++) {
        if (n.charAt(i) == '/') {
            c = Integer.parseInt(n.substring(0, i));
            d = Integer.parseInt(n.substring(i + 1));
        }
    }
    return (a * c) % (b * d) == 0;
}
--------------------------------
int specialFilter(List<Integer> nums) {
    int count = 0;
    for (int num : nums) {
        if (num > 10) {
            String w = Integer.toString(num);
            if (w.charAt(0) % 2 == 1 && w.charAt(w.length() - 1) % 2 == 1) {
                count += 1;
            }
        }
    }
    return count;
}
--------------------------------
int getMaxTriples(int n) {
    int count = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = i + 1; j <= n; j++) {
            for (int k = j + 1; k <= n; k++) {
                if ((i * i + j * j + k * k) % 3 == 0) {
                    count += 1;
                }
            }
        }
    }
    return count;
}
--------------------------------
int doubleTheDifference(List<Double> lst) {
    int sum = 0;
    for (double d : lst) {
        int num = Math.round(d);
        if (d == num) {
            if (num > 0 && num % 2 == 1) {
                sum += num * num;
            }
        }
    }
    return sum;
}
--------------------------------
List<Integer> compare(List<Integer> game, List<Integer> guess) {
    List<Integer> result = new ArrayList<>();
    for (int i = 0; i < game.size(); i++) {
        result.add(Math.abs(game.get(i) - guess.get(i)));
    }
    return result;
}
--------------------------------
String strongestExtension(String className, List<String> extensions) {
    String strongest = "";
    int max = Integer.MIN_VALUE;
    for (String extension : extensions) {
        int strength = 0;
        for (char chr : extension.toCharArray()) {
            if (Character.isUpperCase(chr)) {
                strength += 1;
            }
            if (Character.isLowerCase(chr)) {
                strength -= 1;
            }
        }
        if (strength > max) {
            max = strength;
            strongest = extension;
        }
    }
    return className + "." + strongest;
}
--------------------------------
String intToMiniRoman(int number) {
    String[] num = {"m", "cm", "d", "cd", "c", "xc", "l", "xl", "x", "ix", "v", "iv", "i"};
    String[] sym = {"m", "cm", "d", "cd", "c", "xc", "l", "xl", "x", "ix", "v", "iv", "i"};
    int pos = 0;
    String res = "";
    while (number > 0) {
        while (number >= num[pos].length()) {
            res += sym[pos];
            number -= num[pos].length();
        }
        if (number > 0) {
            pos += 1;
        }
    }
    return res;
}
--------------------------------
List<Integer> eat(int number, int need, int remaining) {
    return need > remaining? Arrays.asList(number + remaining, 0) : Arrays.asList(number + need, remaining - need);
}
--------------------------------
int doAlgebra(List<String> ops, List<Integer> operands) {
    List<Integer> nums = new ArrayList<>(operands);
    List<String> currentOps = new ArrayList<>(ops);
    int i = currentOps.size() - 1;
    while (i >= 0) {
        if (currentOps.get(i).equals("**")) {
            nums.set(i, (int) Math.pow(nums.get(i), nums.get(i + 1)));
            nums.remove(i + 1);
            currentOps.remove(i);
        }
        i--;
    }
    i = 0;
    while (i < currentOps.size()) {
        if (currentOps.get(i).equals("*")) {
            nums.set(i, nums.get(i) * nums.get(i + 1));
            nums.remove(i + 1);
            currentOps.remove(i);
        } else if (currentOps.get(i).equals("//")) {
            nums.set(i, nums.get(i) / nums.get(i + 1));
            nums.remove(i + 1);
            currentOps.remove(i);
        } else {
            i++;
        }
    }
    i = 0;
    while (i < currentOps.size()) {
        if (currentOps.get(i).equals("+")) {
            nums.set(i, nums.get(i) + nums.get(i + 1));
            nums.remove(i + 1);
            currentOps.remove(i);
        } else if (currentOps.get(i).equals("-")) {
            nums.set(i, nums.get(i) - nums.get(i + 1));
            nums.remove(i + 1);
            currentOps.remove(i);
        } else {
            i++;
        }
    }
    return nums.get(0);
}
--------------------------------
List<Integer> generateIntegers(int a, int b) {
    int lower = Math.max(2, Math.min(a, b));
    int upper = Math.min(8, Math.max(a, b));
    List<Integer> result = new ArrayList<>();
    for (int i = lower; i <= upper; i += 2) {
        result.add(i);
    }
    return result;
}
--------------------------------
boolean isStepNum(int n) {
    int prevDigit = -1;
    while (n > 0) {
        int curDigit = n % 10;
        if (prevDigit == -1) {
            prevDigit = curDigit;
        } else {
            if (Math.abs(prevDigit - curDigit)!= 1) {
                return false;
            }
        }
        prevDigit = curDigit;
        n /= 10;
    }
    return true;
}
--------------------------------
int numOfWays(int n, int k) {
    int p = 1;
    if (k % 2) {
        p = -1;
    }
    return (int) Math.round((Math.pow(n - 1, k) + p * (n - 1)) / n);
}
--------------------------------
List<Integer> findDivisors(int n) {
    List<Integer> v = new ArrayList<>();
    for (int i = 1; i <= Math.sqrt(n); i++) {
        if (n % i == 0) {
            if (n / i == i) {
                v.add(i);
            } else {
                v.add(i);
                v.add(n / i);
            }
        }
    }
    return v;
}
--------------------------------
int eggDrop(int n, int k) {
    if (k == 1 || k == 0) {
        return k;
    }
    if (n == 1) {
        return k;
    }
    int min = Integer.MAX_VALUE;
    for (int x = 1; x <= k; x++) {
        int res = Math.max(eggDrop(n - 1, x - 1), eggDrop(n, k - x));
        if (res < min) {
            min = res;
        }
    }
    return min + 1;
}
--------------------------------
boolean isPowerOfTwo(int n) {
    if (n == 0) {
        return false;
    }
    return Math.ceil(Math.log(n) / Math.log(2)) == Math.floor(Math.log(n) / Math.log(2));
}
--------------------------------
String shortestPalindrome(String s) {
    int n = s.length();
    String[] v = new String[n * 2];
    for (int i = 0; i < n; i++) {
        int l = i;
        int r = i;
        String ans1 = "";
        String ans2 = "";
        while (l >= 0 && r < n && s.charAt(l) == s.charAt(r)) {
            ans1 += s.charAt(l);
            l--;
            r++;
        }
        l = i - 1;
        r = i;
        while (l >= 0 && r < n && s.charAt(l) == s.charAt(r)) {
            ans2 += s.charAt(l);
            l--;
            r++;
        }
        v[i * 2] = ans1;
        v[i * 2 + 1] = ans2;
    }
    String ans = v[0];
    for (int i = 0; i < v.length; i++) {
        if (!v[i].isEmpty()) {
            ans = min(ans, v[i]);
        }
    }
    return ans;
}
--------------------------------
int minimumAdjacentDifference(List<Integer> a, int n, int k) {
    int minDiff = Integer.MAX_VALUE;
    for (int i = 0; i <= k; i++) {
        int maxDiff = Integer.MIN_VALUE;
        for (int j = 0; j < n - k - 1; j++) {
            for (int p = i; p <= i + j; p++) {
                maxDiff = Math.max(maxDiff, a.get(p + 1) - a.get(p));
            }
        }
        minDiff = Math.min(minDiff, maxDiff);
    }
    return minDiff;
}
--------------------------------
int cal(List<Integer> arr, int mid) {
    int chocolate = 0;
    for (int i : arr) {
        if (i >= mid) {
            chocolate += i - mid;
        }
    }
    return chocolate;
}
--------------------------------
boolean check(int v, List<Integer> a, int m) {
    int tec = 0, ans = 0;
    List<Integer> b = new ArrayList<>(a.size() + 3);
    for (int i = 0; i < a.size(); i++) {
        tec -= b.get(i);
        if (a.get(i) + tec < v) {
            int mov = v - a.get(i) - tec;
            ans += mov;
            tec += mov;
            b.set(i + 2, mov);
        }
    }
    return ans <= m;
}
--------------------------------
int largestNum(List<Integer> arr) {
    int res = 0;
    arr.sort(Comparator.naturalOrder());
    int l = 0, r = arr.size() - 1;
    while (l < r) {
        int sum = arr.get(l) + arr.get(r);
        if (sum == 0) {
            res = Math.max(res, Math.max(arr.get(l), arr.get(r)));
            return res;
        } else if (sum < 0) {
            l++;
        } else {
            r--;
        }
    }
    return res;
}
--------------------------------
int binarySearch(List<Integer> p, int n) {
    int i = 0;
    int j = p.size() - 1;
    int index = -1;
    while (i <= j) {
        int mid = i + (j - i) / 2;
        if (p.get(mid) >= n) {
            index = mid;
            j = mid - 1;
        } else {
            i = mid + 1;
        }
    }
    return index;
}
--------------------------------
int findMinLength(List<Integer> arr) {
    int index = arr.size() - 1;
    while (index > 0 && arr.get(index) >= arr.get(index - 1)) {
        index--;
    }
    return index;
}
--------------------------------
int minDigits(int n, int k) {
    int digitsNum = (int) Math.floor(Math.log10(n) + 1);
    int tempSum = 0;
    int temp = digitsNum;
    int result = 0;
    int x, v;
    int sum = 0;
    int num2 = n;
    while (num2!= 0) {
        sum += num2 % 10;
        num2 /= 10;
    }
    if (sum <= k) {
        x = 0;
    } else {
        while (temp > 0) {
            v = n / (int) Math.pow(10, temp - 1);
            tempSum += v % 10;
            if (tempSum >= k) {
                v /= 10;
                v++;
                result = v * (int) Math.pow(10, temp);
                break;
            }
            temp--;
        }
        x = result - n;
        return x;
    }
    return -1;
}
--------------------------------
int checkForPerfectSquare(List<Integer> arr, int i, int j) {
    int mid, sum = 0;
    for (int m = i; m <= j; m++) {
        sum += arr.get(m);
    }
    int low = 0, high = sum / 2;
    while (low <= high) {
        mid = low + (high - low) / 2;
        if (mid * mid == sum) {
            return mid;
        } else if (mid * mid > sum) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return -1;
}
--------------------------------
int minFlips(List<List<Integer> > mat, String s) {
    int n = mat.size();
    int m = mat.get(0).size();
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (mat.get(i).get(j)!= s.charAt(i + j) - '0') {
                count++;
            }
        }
    }
    return count;
}
--------------------------------
List<List<Integer> > constructTree(int n, List<List<Integer> > edges) {
    List<List<Integer> > adjl = new ArrayList<List<Integer> >();
    for (int i = 0; i < n; i++) {
        adjl.add(new ArrayList<Integer>());
    }
    for (List<Integer> e : edges) {
        int u = e.get(0);
        int v = e.get(1);
        adjl.get(u).add(v);
        adjl.get(v).add(u);
    }
    return adjl;
}
--------------------------------
int findSumOfValues(int v, List<Integer> parent, List<Integer> valuesChildren) {
    int curNode = v;
    int sum = 0;
    while (curNode!= -1) {
        sum += valuesChildren.get(curNode);
        curNode = parent.get(curNode);
    }
    return sum;
}
--------------------------------
int getDistinct(int d, int count) {
    int num = 0;
    count = Math.pow(10, count - 1);
    while (count > 0) {
        num += count * d;
        count /= 10;
    }
    return num;
}
--------------------------------
boolean isIncreasing(List<Integer> arr) {
    for (int i = 0; i < arr.size() - 1; i++) {
        if (arr.get(i) > arr.get(i + 1)) {
            return false;
        }
    }
    return true;
}
--------------------------------
int minAdjSwaps(List<List<Integer> > mat) {
    int n = mat.size();
    List<Integer> cntZero = new ArrayList<>(n);
    for (int i = 0; i < n; i++) {
        for (int j = n - 1; j >= 0 && mat.get(i).get(j) == 0; j--) {
            cntZero.add(i, cntZero.get(i) + 1);
        }
    }
    int cntSwaps = 0;
    for (int i = 0; i < n; i++) {
        if (cntZero.get(i) < (n - i - 1)) {
            int first = i;
            while (first < n && cntZero.get(first) < (n - i - 1)) {
                first++;
            }
            if (first == n) {
                return -1;
            }
            while (first > i) {
                Collections.swap(cntZero, first, first - 1);
                first--;
                cntSwaps++;
            }
        }
    }
    return cntSwaps;
}
--------------------------------
int solve(List<Integer> values, List<Integer> salary, int mod) {
    int ret = 1;
    int amt = 0;
    Collections.sort(values);
    Collections.sort(salary);
    while (!salary.isEmpty()) {
        while (!values.isEmpty() && values.get(values.size() - 1) >= salary.get(salary.size() - 1)) {
            amt++;
            values.remove(values.size() - 1);
        }
        if (amt == 0) {
            return 0;
        }
        ret *= amt--;
        ret %= mod;
        salary.remove(salary.size() - 1);
    }
    return ret;
}
--------------------------------
List<Integer> organizeInOrder(List<Integer> vec, List<Character> op, int n) {
    List<Integer> result = new ArrayList<>(n);
    vec.sort(Comparator.naturalOrder());
    int i = 0, j = n - 1, k = 0;
    while (i <= j && k <= n - 2) {
        if (op.get(k) == '<') {
            result.add(vec.get(i++));
        } else {
            result.add(vec.get(j--));
        }
        k++;
    }
    result.add(vec.get(i));
    return result;
}
--------------------------------
int countPoints(int n, int m, List<Integer> a, List<Integer> b, int x, int y) {
    a.sort(Comparator.naturalOrder());
    b.sort(Comparator.naturalOrder());
    int j = 0;
    int count = 0;
    for (int i = 0; i < n; i++) {
        while (j < m) {
            if (a.get(i) + y < b.get(j)) {
                break;
            }
            if (b.get(j) >= a.get(i) - x && b.get(j) <= a.get(i) + y) {
                count++;
                j++;
                break;
            } else {
                j++;
            }
        }
    }
    return count;
}
--------------------------------
boolean areSame(List<Integer> a, List<Integer> b) {
    Collections.sort(a);
    Collections.sort(b);
    return a.equals(b);
}
--------------------------------
int countNumberOfStrings(String s) {
    int n = s.length() - 1;
    int count = (int) Math.pow(2, n);
    return count;
}
--------------------------------
List<Integer> primePower(int x) {
    List<Integer> primePow = new ArrayList<>();
    for (int i = 2; i * i <= x; i++) {
        if (x % i == 0) {
            int p = 1;
            while (x % i == 0) {
                x /= i;
                p *= i;
            }
            primePow.add(p);
        }
    }
    if (x > 1) {
        primePow.add(x);
    }
    return primePow;
}
--------------------------------
boolean isPerfect(int n0) {
    double n = Math.sqrt(n0);
    if (Math.floor(n)!= Math.ceil(n)) {
        return false;
    }
    return true;
}
--------------------------------
int findSum(int l, int r) {
    List<Integer> arr = new ArrayList<>();
    int i = 0;
    int x = 2;
    while (i <= r) {
        arr.add(i + x);
        if (i + 1 <= r) {
            arr.add(i + 1 + x);
        }
        x *= -1;
        i += 2;
    }
    int sum = 0;
    for (i = l; i <= r; ++i) {
        sum += arr.get(i);
    }
    return sum;
}
--------------------------------
int results(int n, int k) {
    return Math.round(Math.pow(n, 1.0 / Math.pow(2, k)));
}
--------------------------------
List<Integer> factors(int n) {
    List<Integer> v = new ArrayList<>();
    v.add(1);
    for (int i = 2; i <= Math.sqrt(n); i++) {
        if (n % i == 0) {
            v.add(i);
            if (n / i!= i) {
                v.add(n / i);
            }
        }
    }
    return v;
}
--------------------------------
int smallestNum(int n) {
    double x = Math.pow(10.0, (n - 1) / 2.0);
    return (int) Math.ceil(x);
}
--------------------------------
int smallest(String s) {
    int[] a = new int[s.length()];
    for (int i = 0; i < s.length(); i++) {
        a[i] = s.charAt(i) - '0';
    }
    List<Integer> b = new ArrayList<>();
    for (int i = 0; i < a.length; i++) {
        if ((a[i]) % 2!= 0) {
            b.add(a[i]);
        }
    }
    Collections.sort(b);
    if (b.size() > 1) {
        return b.get(0) * 10 + b.get(1);
    }
    return -1;
}
--------------------------------
List<Double> Diagonals(double a, double b, double c, double d) {
    List<Double> ans = new ArrayList<>();
    ans.add(Math.sqrt((a * c + b * d) * (a * d + b * c) / (a * b + c * d)));
    ans.add(Math.sqrt((a * c + b * d) * (a * b + c * d) / (a * d + b * c)));
    return ans;
}
--------------------------------
int findNumberOfDigits(int n, int bas) {
    int dig = (int) Math.floor(Math.log(n) / Math.log(bas)) + 1;
    return dig;
}
--------------------------------
double nGon(int n) {
    double proAngleVar;
    if (n % 4 == 0) {
        proAngleVar = numbers.pi * (180.0 / n) / 180;
    } else {
        proAngleVar = numbers.pi * (180.0 / (2 * n)) / 180;
    }
    double negX = 1.0e+99, posX = -1.0e+99, negY = 1.0e+99, posY = -1.0e+99;
    for (int j = 0; j < n; ++j) {
        double px = Math.cos(2 * numbers.pi * j / n + proAngleVar);
        double py = Math.sin(2 * numbers.pi * j / n + proAngleVar);
        negX = Math.min(negX, px);
        posX = Math.max(posX, px);
        negY = Math.min(negY, py);
        posY = Math.max(posY, py);
    }
    double opt2 = Math.max(posX - negX, posY - negY);
    return opt2 / Math.sin(numbers.pi / n) / 2;
}
--------------------------------
int findMaxK(int n) {
    int p = (int) Math.log(n) / (int) Math.log(2);
    return (int) Math.pow(2, p);
}
--------------------------------
int nthFibo(int n) {
    double a = (Math.pow(5, 0.5) + 1) / 2;
    double b = (-1 * Math.pow(5, 0.5) + 1) / 2;
    double r = Math.pow(5, 0.5);
    double ans = (Math.pow(a, n) - Math.pow(b, n)) / r;
    return ans;
}
--------------------------------
double findProb(int l, int r) {
    double count_of_ps = Math.floor(Math.sqrt(r)) - Math.ceil(Math.sqrt(l)) + 1;
    double total = r - l + 1;
    double prob = count_of_ps / total;
    return prob;
}
--------------------------------
int previousFibonacci(int n) {
    double a = n / ((1 + Math.sqrt(5)) / 2.0);
    return Math.round(a);
}
--------------------------------
List<Integer> distPrime(List<Integer> arr, List<Integer> allPrimes) {
    List<Integer> list1 = new ArrayList<>();
    for (int i : allPrimes) {
        for (int j : arr) {
            if (j % i == 0) {
                list1.add(i);
                break;
            }
        }
    }
    return list1;
}
--------------------------------
List<Integer> getArray(int n) {
    List<Integer> ans = new ArrayList<>();
    int p2 = 1;
    while (n > 0) {
        if (n % 2 == 1) {
            ans.add(p2);
        }
        n >>= 1;
        p2 *= 2;
    }
    return ans;
}
--------------------------------
int maximumLength(List<Integer> a) {
    int[] counts = new int[11];
    int ans = 0;
    for (int index = 0; index < a.size(); index++) {
        counts[a.get(index)] += 1;
        List<Integer> k = new ArrayList<>();
        for (int i : counts) {
            if (i!= 0) {
                k.add(i);
            }
        }
        Collections.sort(k);
        if (k.size() == 1 || (k.get(0) == k.get(k.size() - 2) && k.get(k.size() - 1) - k.get(k.size() - 2) == 1) || (k.get(0) == 1 && k.get(1) == k.get(k.size() - 1))) {
            ans = index;
        }
    }
    return ans + 1;
}
--------------------------------
int maxEdges(double n) {
    int edges = (int) Math.floor(n * n / 4);
    return edges;
}
--------------------------------
int findK(int n, int k) {
    List<Integer> a = new ArrayList<>();
    for (int i = 1; i < n; i++) {
        if (i % 2 == 1) {
            a.add(i);
        }
    }
    for (int i = 1; i < n; i++) {
        if (i % 2 == 0) {
            a.add(i);
        }
    }
    return a.get(k - 1);
}
--------------------------------
boolean isKeith(int x, int temp) {
    List<Integer> terms = new ArrayList<>();
    int n = 0;
    while (temp > 0) {
        terms.add(temp % 10);
        temp = temp / 10;
        n++;
    }
    Collections.reverse(terms);
    int nextTerm = 0, i = n;
    while (nextTerm < x) {
        nextTerm = 0;
        for (int j = 1; j <= n; j++) {
            nextTerm += terms.get(i - j);
        }
        terms.add(nextTerm);
        i++;
    }
    return nextTerm == x;
}
--------------------------------
boolean factors(int n, int k) {
    List<Integer> v = new ArrayList<>();
    while (n % 2 == 0) {
        v.add(2);
        n /= 2;
    }
    if (v.size() >= k) {
        return true;
    }
    for (int i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            n = n / i;
            v.add(i);
        }
        if (v.size() >= k) {
            return true;
        }
    }
    if (n > 2) {
        v.add(n);
    }
    if (v.size() >= k) {
        return true;
    }
    return false;
}
--------------------------------
List<String> separateParenGroups(String parenString) {
    List<String> allParens = new ArrayList<>();
    String currentParen = "";
    int currentDepth = 0;
    for (char c : parenString.toCharArray()) {
        if (c == '(') {
            currentDepth += 1;
            currentParen += c;
        } else if (c == ')') {
            currentDepth -= 1;
            currentParen += c;
            if (currentDepth == 0) {
                allParens.add(currentParen);
                currentParen = "";
            }
        }
    }
    return allParens;
}
--------------------------------
List<Integer> parseNestedParens(String parenString) {
    List<Integer> allLevels = new ArrayList<>();
    int level = 0;
    int maxLevel = 0;
    for (int i = 0; i < parenString.length(); i++) {
        char chr = parenString.charAt(i);
        if (chr == '(') {
            level += 1;
            if (level > maxLevel) {
                maxLevel = level;
            }
        }
        if (chr == ')') {
            level -= 1;
            if (level == 0) {
                allLevels.add(maxLevel);
                maxLevel = 0;
            }
        }
    }
    return allLevels;
}
--------------------------------
List<String> filterBySubstring(List<String> strings, String substring) {
    List<String> result = new ArrayList<>();
    for (String s : strings) {
        if (s.contains(substring)) {
            result.add(s);
        }
    }
    return result;
}
--------------------------------
List<Integer> rollingMax(List<Integer> numbers) {
    int runningMax = 0;
    List<Integer> result = new ArrayList<>();
    for (int n : numbers) {
        if (n > runningMax) {
            runningMax = n;
        }
        result.add(runningMax);
    }
    return result;
}
--------------------------------
String makePalindrome(String s) {
    if (s.isEmpty()) {
        return "";
    }
    for (int i = 0; i < s.length(); i++) {
        String r_str = s.substring(i);
        if (r_str.equals(new StringBuilder(r_str).reverse().toString())) {
            String n_str = s.substring(0, i);
            String n2_str = new StringBuilder(n_str).reverse().toString();
            return s + n2_str;
        }
    }
    return s.substring(0, s.length() - 1) + new StringBuilder(s).reverse().toString();
}
--------------------------------
String stringXor(String a, String b) {
    String result = "";
    for (int i = 0; i < a.length(); i++) {
        if (a.charAt(i) == b.charAt(i)) {
            result += '0';
        } else {
            result += '1';
        }
    }
    return result;
}
--------------------------------
String longest(List<String> strings) {
    if (strings.isEmpty()) {
        return "";
    }
    int max_len = IntStream.of(strings.stream().mapToInt(String::length).toArray()).max().getAsInt();
    for (String s : strings) {
        if (s.length() == max_len) {
            return s;
        }
    }
    return "";
}
--------------------------------
String StringSequence(int n) {
    String s = "";
    for (int i = 0; i < n; i++) {
        s += i;
        s += " ";
    }
    s += n;
    return s;
}
--------------------------------
int countDistinctCharacters(String s) {
    Set<Character> distinct = new HashSet<>();
    for (char c : s.toLowerCase().toCharArray()) {
        distinct.add(c);
    }
    return distinct.size();
}
--------------------------------
int howManyTimes(String s, String sub) {
    int times = 0;
    for (int i = 0; i <= s.length() - sub.length(); i++) {
        if (s.substring(i, i + sub.length()).equals(sub)) {
            times += 1;
        }
    }
    return times;
}
--------------------------------
String sortNumbers(String numbers) {
    Map<String, Integer> toNum = new HashMap<>();
    toNum.put("zero", 0);
    toNum.put("one", 1);
    toNum.put("two", 2);
    toNum.put("three", 3);
    toNum.put("four", 4);
    toNum.put("five", 5);
    toNum.put("six", 6);
    toNum.put("seven", 7);
    toNum.put("eight", 8);
    toNum.put("nine", 9);
    Map<Integer, String> fromNum = new HashMap<>();
    fromNum.put(0, "zero");
    fromNum.put(1, "one");
    fromNum.put(2, "two");
    fromNum.put(3, "three");
    fromNum.put(4, "four");
    fromNum.put(5, "five");
    fromNum.put(6, "six");
    fromNum.put(7, "seven");
    fromNum.put(8, "eight");
    fromNum.put(9, "nine");
    List<Integer> ints = new ArrayList<>();
    String current = "";
    for (int i = 0; i <= numbers.length(); i++) {
        if (i == numbers.length() || numbers.charAt(i) =='') {
            if (toNum.containsKey(current)) {
                ints.add(toNum.get(current));
                current = "";
            }
        } else {
            current += numbers.charAt(i);
        }
    }
    Collections.sort(ints);
    String result = "";
    for (int i = 0; i < ints.size(); i++) {
        result += fromNum.get(ints.get(i));
        if (i!= ints.size() - 1) {
            result += " ";
        }
    }
    return result;
}
--------------------------------
List<Double> findClosestElements(List<Double> numbers) {
    List<Double> closestPair = new ArrayList<>();
    closestPair.add(numbers.get(0));
    closestPair.add(numbers.get(1));
    double distance = Math.abs(closestPair.get(0) - closestPair.get(1));
    for (int i = 0; i < numbers.size(); i++) {
        for (int j = i + 1; j < numbers.size(); j++) {
            if (Math.abs(numbers.get(i) - numbers.get(j)) < distance) {
                closestPair.set(0, numbers.get(i));
                closestPair.set(1, numbers.get(j));
                distance = Math.abs(numbers.get(i) - numbers.get(j));
            }
        }
    }
    Collections.sort(closestPair);
    return closestPair;
}
--------------------------------
List<Double> rescaleToUnit(List<Double> numbers) {
    double min_num = Collections.min(numbers);
    double max_num = Collections.max(numbers);
    List<Double> result = new ArrayList<>();
    for (double n : numbers) {
        result.add((n - min_num) / (max_num - min_num));
    }
    return result;
}
--------------------------------
List<Integer> filterIntegers(List<Object> values) {
    List<Integer> result = new ArrayList<>();
    for (Object e : values) {
        if (e.getClass() == Integer.class) {
            result.add((Integer) e);
        }
    }
    return result;
}
--------------------------------
List<Integer> removeDuplicates(List<Integer> numbers) {
    Map<Integer, Integer> counter = new HashMap<>();
    for (int i : numbers) {
        counter.put(i, counter.getOrDefault(i, 0) + 1);
    }
    List<Integer> result = new ArrayList<>();
    for (int i : numbers) {
        if (counter.get(i) == 1) {
            result.add(i);
        }
    }
    return result;
}
--------------------------------
String flipCase(String s) {
    String result = "";
    for (char c : s.toCharArray()) {
        if (Character.isLowerCase(c)) {
            result += Character.toUpperCase(c);
        } else {
            result += Character.toLowerCase(c);
        }
    }
    return result;
}
--------------------------------
List<String> filterByPrefix(List<String> strings, String prefix) {
    List<String> result = new ArrayList<>();
    for (int i = 0; i < strings.size(); i++) {
        if (strings.get(i).startsWith(prefix)) {
            result.add(strings.get(i));
        }
    }
    return result;
}
--------------------------------
double findZero(List<Double> xs) {
    double ans = 0;
    double value = 0;
    for (int i = 0; i < xs.size(); i++) {
        value += xs.get(i) * Math.pow(ans, i);
    }
    while (Math.abs(value) > 1e-6) {
        double driv = 0;
        for (int i = 1; i < xs.size(); i++) {
            driv += xs.get(i) * Math.pow(ans, i - 1) * i;
        }
        ans -= value / driv;
        value = 0;
        for (int i = 0; i < xs.size(); i++) {
            value += xs.get(i) * Math.pow(ans, i);
        }
    }
    return ans;
}
--------------------------------
List<Integer> sortThird(List<Integer> l) {
    List<Integer> thirds = new ArrayList<>();
    for (int i = 0; i < l.size(); i += 3) {
        thirds.add(l.get(i));
    }
    Collections.sort(thirds);
    List<Integer> result = new ArrayList<>();
    for (int i = 0; i < l.size(); i++) {
        if (i % 3 == 0) {
            result.add(thirds.get(i / 3));
        } else {
            result.add(l.get(i));
        }
    }
    return result;
}
--------------------------------
List<Integer> unique(List<Integer> l) {
    Set<Integer> s = new HashSet<>(l);
    List<Integer> result = new ArrayList<>(s);
    Collections.sort(result);
    return result;
}
--------------------------------
double maxElement(List<Double> l) {
    return Collections.max(l);
}
--------------------------------
boolean triplesSumToZero(List<Integer> l) {
    for (int i = 0; i < l.size(); i++) {
        for (int j = i + 1; j < l.size(); j++) {
            for (int k = j + 1; k < l.size(); k++) {
                if (l.get(i) + l.get(j) + l.get(k) == 0) {
                    return true;
                }
            }
        }
    }
    return false;
}
--------------------------------
int fib4(int n) {
    int[] results = {0, 0, 2, 0};
    for (int i = 4; i <= n; i++) {
        results[i] = results[i - 4] + results[i - 3] + results[i - 2] + results[i - 1];
    }
    return results[n];
}
--------------------------------
boolean isPalindrome(String text) {
    String pr = new StringBuilder(text).reverse().toString();
    return pr.equals(text);
}
--------------------------------
String removeVowels(String text) {
    String result = "";
    String vowels = "aeiou";
    for (char ch : text.toCharArray()) {
        if (vowels.indexOf(Character.toLowerCase(ch)) == -1) {
            result += ch;
        }
    }
    return result;
}
--------------------------------
boolean sameChars(String s0, String s1) {
    Set<Character> set0 = new HashSet<>();
    for (char c : s0.toCharArray()) {
        set0.add(c);
    }
    Set<Character> set1 = new HashSet<>();
    for (char c : s1.toCharArray()) {
        set1.add(c);
    }
    return set0.equals(set1);
}
--------------------------------
List<Integer> common(List<Integer> l1, List<Integer> l2) {
    Set<Integer> us = new HashSet<>();
    for (int e1 : l1) {
        for (int e2 : l2) {
            if (e1 == e2) {
                us.add(e1);
            }
        }
    }
    List<Integer> ret = new ArrayList<>(us);
    Collections.sort(ret);
    return ret;
}
--------------------------------
boolean correctBracketing(String brackets) {
    int depth = 0;
    for (char b : brackets) {
        if (b == '(') {
            depth += 1;
        }
        if (b == ')') {
            depth -= 1;
        }
        if (depth < 0) {
            return false;
        }
    }
    return depth == 0;
}
--------------------------------
String circularShift(int x, int shift) {
    String xs = Integer.toString(x);
    if (shift > xs.length()) {
        return new StringBuilder(xs).reverse().toString();
    }
    return xs.substring(xs.length() - shift) + xs.substring(0, xs.length() - shift);
}
--------------------------------
int search(List<Integer> lst) {
    Map<Integer, Integer> counter = new HashMap<>();
    for (int i : lst) {
        counter.put(i, counter.getOrDefault(i, 0) + 1);
    }
    int ans = -1;
    for (Map.Entry<Integer, Integer> entry : counter.entrySet()) {
        if (entry.getValue() >= entry.getKey() && entry.getKey() > ans) {
            ans = entry.getKey();
        }
    }
    return ans;
}
--------------------------------
int smallestChange(List<Integer> arr) {
    int ans = 0;
    for (int i = 0; i < arr.size() / 2; i++) {
        if (arr.get(i)!= arr.get(arr.size() - i - 1)) {
            ans += 1;
        }
    }
    return ans;
}
--------------------------------
List<String> totalMatch(List<String> lst1, List<String> lst2) {
    int sum1 = 0;
    for (String st : lst1) {
        sum1 += st.length();
    }
    int sum2 = 0;
    for (String st : lst2) {
        sum2 += st.length();
    }
    return sum1 > sum2? lst2 : lst1;
}
--------------------------------
boolean isHappy(String s) {
    if (s.length() < 3) {
        return false;
    }
    for (int i = 0; i < s.length() - 2; i++) {
        if (s.charAt(i) == s.charAt(i + 1) || s.charAt(i) == s.charAt(i + 2) || s.charAt(i + 1) == s.charAt(i + 2)) {
            return false;
        }
    }
    return true;
}
--------------------------------
List<String> numericalLetterGrade(List<Double> grades) {
    List<String> letter_grade = new ArrayList<>();
    for (double gpa : grades) {
        if (gpa == 4.0) {
            letter_grade.add("A+");
        } else if (gpa > 3.7) {
            letter_grade.add("A");
        } else if (gpa > 3.3) {
            letter_grade.add("A-");
        } else if (gpa > 3.0) {
            letter_grade.add("B+");
        } else if (gpa > 2.7) {
            letter_grade.add("B");
        } else if (gpa > 2.3) {
            letter_grade.add("B-");
        } else if (gpa > 2.0) {
            letter_grade.add("C+");
        } else if (gpa > 1.7) {
            letter_grade.add("C");
        } else if (gpa > 1.3) {
            letter_grade.add("C-");
        } else if (gpa > 1.0) {
            letter_grade.add("D+");
        } else if (gpa > 0.7) {
            letter_grade.add("D");
        } else if (gpa > 0.0) {
            letter_grade.add("D-");
        } else {
            letter_grade.add("E");
        }
    }
    return letter_grade;
}
--------------------------------
String solve(int n) {
    String biStr = "";
    int sum = 0;
    for (char c : Integer.toString(n).toCharArray()) {
        sum += c - '0';
    }
    while (sum > 0) {
        biStr = sum % 2 + biStr;
        sum /= 2;
    }
    return biStr;
}
--------------------------------
String antiShuffle(String s) {
    String ret = "";
    String current = "";
    for (int i = 0; i <= s.length(); i++) {
        if (i == s.length() || s.charAt(i) =='') {
            Collections.sort(current.toCharArray());
            if (!ret.isEmpty()) {
                ret +='';
            }
            ret += current;
            current = "";
        } else {
            current += s.charAt(i);
        }
    }
    return ret;
}
--------------------------------
List<Integer> sortArray(List<Integer> array) {
    if (array.isEmpty()) {
        return array;
    }
    if ((array.get(0) + array.get(array.size() - 1)) % 2 == 1) {
        Collections.sort(array);
    } else {
        Collections.sort(array, Collections.reverseOrder());
    }
    return array;
}
--------------------------------
String encrypt(String s) {
    String ans = "";
    for (char c : s.toCharArray()) {
        if (Character.isLetter(c)) {
            ans += (char) ('a' + (c - 'a' + 4) % 26);
        } else {
            ans += c;
        }
    }
    return ans;
}
--------------------------------
int isBored(String s) {
    boolean isStart = true;
    int sum = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '.' || s.charAt(i) == '?' || s.charAt(i) == '!') {
            isStart = true;
        } else if (isStart) {
            if (s.charAt(i) =='') {
                continue;
            }
            if (s.substring(i, i + 2).equals("I ")) {
                sum += 1;
            }
            isStart = false;
        }
    }
    return sum;
}
--------------------------------
String encode(String message) {
    String vowels = "aeiouAEIOU";
    String ret = "";
    for (char c : message.toCharArray()) {
        if (Character.isUpperCase(c)) {
            c = Character.toLowerCase(c);
            if (vowels.indexOf(c)!= -1) {
                c = (char) ('a' + (c - 'a' + 2) % 26);
            }
        } else if (Character.isLowerCase(c)) {
            c = Character.toUpperCase(c);
            if (vowels.indexOf(c)!= -1) {
                c = (char) ('A' + (c - 'A' + 2) % 26);
            }
        }
        ret += c;
    }
    return ret;
}
--------------------------------
int skjkasdkd(List<Integer> lst) {
    int largest = 0;
    for (int n : lst) {
        if (n > largest) {
            boolean prime = true;
            for (int i = 2; i < n; i++) {
                if (n % i == 0) {
                    prime = false;
                }
            }
            if (prime) {
                largest = n;
            }
        }
    }
    int sum = 0;
    String s = Integer.toString(largest);
    for (int i = 0; i < s.length(); i++) {
        sum += s.charAt(i) - '0';
    }
    return sum;
}
--------------------------------
boolean checkDictCase(Map<String, String> dict) {
    if (dict.isEmpty()) {
        return false;
    }
    int isLower = 0;
    int isUpper = 0;
    for (Map.Entry<String, String> entry : dict.entrySet()) {
        for (char c : entry.getKey().toCharArray()) {
            if (Character.isLowerCase(c)) {
                isLower = 1;
            } else if (Character.isUpperCase(c)) {
                isUpper = 1;
            } else {
                return false;
            }
        }
    }
    return isLower + isUpper == 1;
}
--------------------------------
int multiply(int a, int b) {
    return Math.abs(a % 10) * Math.abs(b % 10);
}
--------------------------------
int countUpper(String s) {
    String u_vowel = "AEIOU";
    int count = 0;
    for (int i = 0; i < s.length(); i += 2) {
        if (u_vowel.indexOf(s.charAt(i))!= -1) {
            count += 1;
        }
    }
    return count;
}
--------------------------------
List<String> byLength(List<Integer> arr) {
    Map<Integer, String> numTo = new HashMap<>();
    numTo.put(1, "One");
    numTo.put(2, "Two");
    numTo.put(3, "Three");
    numTo.put(4, "Four");
    numTo.put(5, "Five");
    numTo.put(6, "Six");
    numTo.put(7, "Seven");
    numTo.put(8, "Eight");
    numTo.put(9, "Nine");
    List<Integer> sortedArr = new ArrayList<>(arr);
    Collections.sort(sortedArr, Collections.reverseOrder());
    List<String> newArr = new ArrayList<>();
    for (int n : sortedArr) {
        if (n >= 1 && n <= 9) {
            newArr.add(numTo.get(n));
        }
    }
    return newArr;
}
--------------------------------
List<Integer> f(int n) {
    int sum = 0;
    int prod = 1;
    List<Integer> result = new ArrayList<>();
    for (int i = 1; i <= n; i++) {
        sum += i;
        prod *= i;
        if (i % 2 == 0) {
            result.add(prod);
        } else {
            result.add(sum);
        }
    }
    return result;
}
--------------------------------
List<Integer> evenOddPalindrome(int n) {
    int even_count = 0, odd_count = 0;
    for (int i = 1; i <= n; i++) {
        String s = Integer.toString(i);
        String r_str = new StringBuilder(s).reverse().toString();
        if (s.equals(r_str)) {
            if (i % 2 == 1) {
                odd_count += 1;
            } else {
                even_count += 1;
            }
        }
    }
    return Arrays.asList(even_count, odd_count);
}
--------------------------------
Map<Character, Integer> histogram(String test) {
    Map<Character, Integer> count = new HashMap<>();
    int max = 0;
    for (int i = 0; i < test.length(); i++) {
        if (test.charAt(i)!='') {
            count.put(test.charAt(i), count.getOrDefault(test.charAt(i), 0) + 1);
            if (count.get(test.charAt(i)) > max) {
                max = count.get(test.charAt(i));
            }
        }
    }
    Map<Character, Integer> result = new HashMap<>();
    for (Map.Entry<Character, Integer> entry : count.entrySet()) {
        if (entry.getValue() == max) {
            result.put(entry.getKey(), entry.getValue());
        }
    }
    return result;
}
--------------------------------
List<String> reverseDelete(String s, String c) {
    String ret = "";
    for (char ch : s.toCharArray()) {
        if (c.indexOf(ch) == -1) {
            ret += ch;
        }
    }
    String flag = "False";
    if (ret.equals(new StringBuilder(ret).reverse().toString())) {
        flag = "True";
    }
    return Arrays.asList(ret, flag);
}
--------------------------------
List<Integer> sortArray(List<Integer> arr) {
    List<Integer> bin = new ArrayList<>();
    for (int i : arr) {
        int b = 0;
        int n = Math.abs(i);
        while (n > 0) {
            b += n % 2;
            n /= 2;
        }
        bin.add(b);
    }
    for (int i = 0; i < arr.size(); i++) {
        for (int j = 1; j < arr.size(); j++) {
            if (bin.get(j) < bin.get(j - 1) || (bin.get(j) == bin.get(j - 1) && arr.get(j) < arr.get(j - 1))) {
                Collections.swap(bin, j, j - 1);
                Collections.swap(arr, j, j - 1);
            }
        }
    }
    return arr;
}
--------------------------------
String getClosestVowel(String word) {
    String vowels = "AEIOUaeiou";
    for (int i = word.length() - 2; i > 0; i--) {
        if (vowels.indexOf(word.charAt(i))!= -1 && vowels.indexOf(word.charAt(i + 1)) == -1 && vowels.indexOf(word.charAt(i - 1)) == -1) {
            return word.substring(i, i + 1);
        }
    }
    return "";
}
--------------------------------
String matchParens(List<String> lst) {
    List<String> strings = Arrays.asList(lst.get(0) + lst.get(1), lst.get(1) + lst.get(0));
    for (String l : strings) {
        int count = 0;
        for (char c : l.toCharArray()) {
            if (c == '(') {
                count += 1;
            }
            if (c == ')') {
                count -= 1;
            }
            if (count < 0) {
                break;
            }
        }
        if (count == 0) {
            return "Yes";
        }
    }
    return "No";
}
--------------------------------
List<Integer> maximum(List<Integer> arr, int k) {
    if (k == 0) {
        return new ArrayList<>();
    }
    Collections.sort(arr);
    return arr.subList(arr.size() - k, arr.size());
}
--------------------------------
boolean validDate(String date) {
    if (date.length()!= 10) {
        return false;
    }
    for (int i = 0; i < 10; i++) {
        if (i == 2 || i == 5) {
            if (date.charAt(i)!= '-') {
                return false;
            }
        } else if (!Character.isDigit(date.charAt(i))) {
            return false;
        }
    }
    int month = Integer.parseInt(date.substring(0, 2));
    int day = Integer.parseInt(date.substring(3, 2));
    int year = Integer.parseInt(date.substring(6, 4));
    if (month < 1 || month > 12) {
        return false;
    }
    if (day < 1 || day > 31) {
        return false;
    }
    if (day == 31 && (month == 4 || month == 6 || month == 9 || month == 11 || month == 2)) {
        return false;
    }
    if (day == 30 && month == 2) {
        return false;
    }
    return true;
}
--------------------------------
Object splitWords(String txt) {
    List<String> result = new ArrayList<>();
    String current = "";
    if (txt.indexOf(' ')!= -1) {
        for (int i = 0; i < txt.length(); i++) {
            if (i == txt.length() - 1 || txt.charAt(i) =='') {
                if (current.length() > 0) {
                    result.add(current);
                }
                current = "";
            } else {
                current += txt.charAt(i);
            }
        }
        return result;
    }
    if (txt.indexOf(',')!= -1) {
        for (int i = 0; i < txt.length(); i++) {
            if (i == txt.length() - 1 || txt.charAt(i) == ',') {
                if (current.length() > 0) {
                    result.add(current);
                }
                current = "";
            } else {
                current += txt.charAt(i);
            }
        }
        return result;
    }
    int num = 0;
    for (char c : txt.toCharArray()) {
        if (Character.isLowerCase(c) && c % 2 == 0) {
            num += 1;
        }
    }
    return Collections.singletonList(Integer.toString(num));
}
--------------------------------
List<Integer> tri(int n) {
    if (n == 0) {
        return Arrays.asList(1);
    }
    List<Integer> tris = Arrays.asList(1, 3);
    for (int i = 2; i <= n; i++) {
        if (i % 2 == 0) {
            tris.add(i / 2 + 1);
        } else {
            tris.add(tris.get(i - 1) + tris.get(i - 2) + (i + 3) / 2);
        }
    }
    return tris;
}
--------------------------------
boolean checkIfLastCharIsALetter(String txt) {
    if (txt.isEmpty()) {
        return false;
    }
    return Character.isLetter(txt.charAt(txt.length() - 1)) && (txt.length() == 1 ||!Character.isLetter(txt.charAt(txt.length() - 2)));
}
--------------------------------
List<Integer> orderByPoints(List<Integer> nums) {
    List<Integer> result = new ArrayList<>();
    for (int num : nums) {
        String w = String.valueOf(Math.abs(num));
        int sum = 0;
        for (char c : w.toCharArray()) {
            sum += c - '0';
        }
        if (num < 0) {
            sum -= 2 * (w.charAt(0) - '0');
        }
        result.add(sum);
    }
    for (int i = 0; i < nums.size(); i++) {
        for (int j = 1; j < nums.size(); j++) {
            if (result.get(j - 1) > result.get(j)) {
                Collections.swap(result, j, j - 1);
                Collections.swap(nums, j, j - 1);
            }
        }
    }
    return nums;
}
--------------------------------
List<String> bf(String planet1, String planet2) {
    List<String> planets = Arrays.asList("Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune");
    int idx1 = planets.indexOf(planet1);
    int idx2 = planets.indexOf(planet2);
    if (idx1 == -1 || idx2 == -1 || idx1 == idx2) {
        return Collections.emptyList();
    }
    return idx1 > idx2? planets.subList(idx2 + 1, idx1) : planets.subList(idx1 + 1, idx2);
}
--------------------------------
List<String> sortedListSum(List<String> lst) {
    List<String> result = new ArrayList<>();
    for (String i : lst) {
        if (i.length() % 2 == 0) {
            result.add(i);
        }
    }
    result.sort((l, r) -> {
        if (l.length() == r.length()) {
            return l.compareTo(r);
        }
        return l.length() - r.length();
    });
    return result;
}
--------------------------------
boolean cycpatternCheck(String a, String b) {
    for (int i = 0; i < b.length(); i++) {
        String rotate = b.substring(i) + b.substring(0, i);
        if (a.contains(rotate)) {
            return true;
        }
    }
    return false;
}
--------------------------------
List<Integer> evenOddCount(int num) {
    int evenCount = 0, oddCount = 0;
    for (char c : String.valueOf(Math.abs(num)).toCharArray()) {
        if (c % 2 == 0) {
            evenCount++;
        } else {
            oddCount++;
        }
    }
    return Arrays.asList(evenCount, oddCount);
}
--------------------------------
String findMax(List<String> words) {
    String max = "";
    int max_length = 0;
    for (String word : words) {
        List<Character> unique = new ArrayList<>();
        for (char w : word.toCharArray()) {
            if (!unique.contains(w)) {
                unique.add(w);
            }
        }
        if (unique.size() > max_length || (unique.size() == max_length && word.compareTo(max) < 0)) {
            max = word;
            max_length = unique.size();
        }
    }
    return max;
}
--------------------------------
String solve(String s) {
    boolean noLetter = true;
    String result = "";
    for (char ch : s.toCharArray()) {
        if (Character.isUpperCase(ch)) {
            ch = Character.toLowerCase(ch);
            noLetter = false;
        } else if (Character.isLowerCase(ch)) {
            ch = Character.toUpperCase(ch);
            noLetter = false;
        }
        result += ch;
    }
    if (noLetter) {
        return new StringBuilder(s).reverse().toString();
    } else {
        return result;
    }
}
--------------------------------
int mostFrequent(List<Integer> arr, int n) {
    Map<Integer, Integer> hp = new HashMap<>();
    for (int i = 0; i < n; i++) {
        if (hp.containsKey(arr.get(i))) {
            hp.put(arr.get(i), hp.get(arr.get(i)) + 1);
        } else {
            hp.put(arr.get(i), 1);
        }
    }
    int maxCount = 0, res = -1;
    for (Map.Entry<Integer, Integer> entry : hp.entrySet()) {
        if (maxCount < entry.getValue()) {
            res = entry.getKey();
            maxCount = entry.getValue();
        }
    }
    return res;
}
--------------------------------
int find(List<Integer> a, List<Integer> b, int k, int n1, int n2) {
    Set<Integer> s = new HashSet<>();
    for (int i = 0; i < n2; i++) {
        s.add(b.get(i));
    }
    int missing = 0;
    for (int i = 0; i < n1; i++) {
        if (!s.contains(a.get(i))) {
            missing++;
        }
        if (missing == k) {
            return a.get(i);
        }
    }
    return -1;
}
--------------------------------
int solveQuery(int start, int end, List<Integer> arr) {
    Map<Integer, Integer> mp = new HashMap<>();
    for (int i = start; i <= end; i++) {
        mp.put(arr.get(i), mp.getOrDefault(arr.get(i), 0) + 1);
    }
    int count = 0;
    for (Map.Entry<Integer, Integer> entry : mp.entrySet()) {
        if (entry.getKey() == entry.getValue()) {
            count++;
        }
    }
    return count;
}
--------------------------------
int segregate(List<Integer> arr, int size) {
    int j = 0;
    for (int i = 0; i < size; i++) {
        if (arr.get(i) <= 0) {
            Collections.swap(arr, i, j);
            j++;
        }
    }
    return j;
}
--------------------------------
int countTriplets(List<Integer> a, int n) {
    Set<Integer> s = new HashSet<>();
    for (int i = 0; i < n; i++) {
        s.add(a.get(i));
    }
    int count = 0;
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            int xr = a.get(i) ^ a.get(j);
            if (s.contains(xr) && xr!= a.get(i) && xr!= a.get(j)) {
                count++;
            }
        }
    }
    return count / 3;
}
--------------------------------
int leastFrequent(List<Integer> arr, int n) {
    Map<Integer, Integer> hp = new HashMap<>();
    for (int i = 0; i < n; i++) {
        if (hp.containsKey(arr.get(i))) {
            hp.put(arr.get(i), hp.get(arr.get(i)) + 1);
        } else {
            hp.put(arr.get(i), 1);
        }
    }
    int minCount = n + 1, res = -1;
    for (Map.Entry<Integer, Integer> entry : hp.entrySet()) {
        if (minCount >= entry.getValue()) {
            res = entry.getKey();
            minCount = entry.getValue();
        }
    }
    return res;
}
--------------------------------
int findPermutations(List<Integer> arr) {
    int cnt = 0;
    int max_ind = -1, min_ind = 10000000;
    int n = arr.size();
    Map<Integer, Integer> index_of = new HashMap<>();
    for (int i = 0; i < n; i++) {
        index_of.put(arr.get(i), i + 1);
    }
    for (int i = 1; i <= n; i++) {
        max_ind = Math.max(max_ind, index_of.get(i));
        min_ind = Math.min(min_ind, index_of.get(i));
        if (max_ind - min_ind + 1 == i) {
            cnt++;
        }
    }
    return cnt;
}
--------------------------------
int formQuadruplets(List<Integer> arr, int n) {
    int ans = 0, pairs = 0;
    pairs = n / 4;
    arr.sort(Collections.reverseOrder());
    for (int i = 0; i < n - pairs; i += 3) {
        ans += arr.get(i + 2);
    }
    return ans;
}
--------------------------------
String lexicographicallyMaximum(String s, int n) {
    Map<Character, Integer> m = new HashMap<>();
    for (int i = 0; i < n; ++i) {
        if (m.containsKey(s.charAt(i))) {
            m.put(s.charAt(i), m.get(s.charAt(i)) + 1);
        } else {
            m.put(s.charAt(i), 1);
        }
    }
    List<Character> v = new ArrayList<>();
    for (char i = 'a'; i < 'a' + Math.min(n, 25); ++i) {
        if (!m.containsKey(i)) {
            v.add(i);
        }
    }
    int j = v.size() - 1;
    for (int i = 0; i < n; ++i) {
        if (s.charAt(i) >= 'a' + Math.min(n, 25) || (m.containsKey(s.charAt(i)) && m.get(s.charAt(i)) > 1)) {
            if (v.get(j) < s.charAt(i)) {
                continue;
            }
            m.put(s.charAt(i), m.get(s.charAt(i)) - 1);
            s = s.substring(0, i) + v.get(j) + s.substring(i + 1);
            j--;
        }
        if (j < 0) {
            break;
        }
    }
    int l = 0;
    for (int i = n - 1; i >= 0; i--) {
        if (l > j) {
            break;
        }
        if (s.charAt(i) >= 'a' + Math.min(n, 25) || (m.containsKey(s.charAt(i)) && m.get(s.charAt(i)) > 1)) {
            m.put(s.charAt(i), m.get(s.charAt(i)) - 1);
            s = s.substring(0, i) + v.get(l) + s.substring(i + 1);
            l++;
        --------------------------------
int noOfValidKbers(int k, List<Integer> arr) {
    Set<Integer> s = new HashSet<>();
    while (k!= 0) {
        s.add(k % 10);
        k = k / 10;
    }
    int count = 0;
    for (int i = 0; i < arr.size(); i++) {
        int no = arr.get(i);
        boolean flag = true;
        while (no!= 0) {
            int digit = no % 10;
            if (!s.contains(digit)) {
                flag = false;
                break;
            }
            no = no / 10;
        }
        if (flag) {
            count++;
        }
    }
    return count;
}
--------------------------------
int delCost(String s, List<Integer> cost) {
    int ans = 0;
    Map<Character, Integer> forMax = new HashMap<>();
    Map<Character, Integer> forTot = new HashMap<>();
    for (int i = 0; i < s.length(); i++) {
        if (!forMax.containsKey(s.charAt(i))) {
            forMax.put(s.charAt(i), cost.get(i));
        } else {
            forMax.put(s.charAt(i), Math.max(cost.get(i), forMax.get(s.charAt(i))));
        }
        if (!forTot.containsKey(s.charAt(i))) {
            forTot.put(s.charAt(i), cost.get(i));
        } else {
            forTot.put(s.charAt(i), forTot.get(s.charAt(i)) + cost.get(i));
        }
    }
    for (Map.Entry<Character, Integer> i : forMax.entrySet()) {
        ans += forTot.get(i.getKey()) - i.getValue();
    }
    return ans;
}
--------------------------------
List<String> replaceDuplicates(List<String> names) {
    Map<String, Integer> hash = new HashMap<>();
    for (int i = 0; i < names.size(); i++) {
        if (!hash.containsKey(names.get(i))) {
            hash.put(names.get(i), 1);
        } else {
            int count = hash.get(names.get(i));
            hash.put(names.get(i), count + 1);
            names.set(i, names.get(i) + count);
        }
    }
    return names;
}
--------------------------------
List<Integer> minmaxNumbers(List<List<Integer> > matrix, List<Integer> res) {
    Set<Integer> s = new HashSet<>();
    for (int i = 0; i < matrix.size(); i++) {
        int min_r = Integer.MAX_VALUE;
        for (int j = 0; j < matrix.get(i).size(); j++) {
            min_r = Math.min(min_r, matrix.get(i).get(j));
        }
        s.add(min_r);
    }
    for (int j = 0; j < matrix.get(0).size(); j++) {
        int max_c = Integer.MIN_VALUE;
        for (int i = 0; i < matrix.size(); i++) {
            max_c = Math.max(max_c, matrix.get(i).get(j));
        }
        if (s.contains(max_c)) {
            res.add(max_c);
        }
    }
    return res;
}
--------------------------------
int lengthOfLongestAP(List<Integer> a, int n) {
    Map<Integer, Map<Integer, Integer>> dp = new HashMap<>();
    int res = 2;
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            int d = a.get(j) - a.get(i);
            if (dp.containsKey(d)) {
                if (dp.get(d).containsKey(i)) {
                    dp.get(d).put(j, dp.get(d).get(i) + 1);
                } else {
                    dp.get(d).put(j, 2);
                }
            } else {
                dp.put(d, new HashMap<>());
                dp.get(d).put(j, 2);
            }
            res = Math.max(res, dp.get(d).get(j));
        }
    }
    return res;
}
--------------------------------
char findKthChar(int n, int k) {
    String prev = "A";
    String cur;
    if (n == 1) {
        return 'A';
    }
    for (int j = 2; j <= n; j++) {
        cur = prev + "B";
        for (int i = 0; i < prev.length(); i++) {
            if (prev.charAt(i) == 'A') {
                prev = prev.substring(0, i) + "B" + prev.substring(i + 1);
            } else {
                prev = prev.substring(0, i) + "A" + prev.substring(i + 1);
            }
        }
        prev = new StringBuilder(cur).reverse().toString();
        cur += prev;
        prev = cur;
    }
    return cur.charAt(k - 1);
}
--------------------------------
char findKthLargest(String s, int k) {
    String tmp = s;
    Arrays.sort(tmp.toCharArray());
    return tmp.charAt(tmp.length() - k);
}
--------------------------------
int subArraylen(List<Integer> arr, int n, int k) {
    Map<Integer, Integer> mp = new HashMap<>();
    mp.put(arr.get(0), 0);
    for (int i = 1; i < n; i++) {
        arr.set(i, arr.get(i) + arr.get(i - 1));
        mp.put(arr.get(i), i);
    }
    int length = Integer.MAX_VALUE;
    for (int i = 0; i < n; i++) {
        if (arr.get(i) < k) {
            continue;
        } else {
            int x = arr.get(i) - k;
            if (x == 0) {
                length = Math.min(length, i);
            }
            if (!mp.containsKey(x)) {
                continue;
            } else {
                length = Math.min(length, i - mp.get(x));
            }
        }
    }
    return length;
}
--------------------------------
int findMaxLen(List<Integer> a, int k) {
    int n = a.size();
    a.sort(Comparator.naturalOrder());
    List<Boolean> vis = new ArrayList<>(n);
    Map<Integer, Integer> mp = new HashMap<>();
    for (int i = 0; i < n; i++) {
        mp.put(a.get(i), i);
    }
    int c = 0;
    for (int i = 0; i < n; ++i) {
        if (!vis.get(i)) {
            int check = a.get(i) * k;
            if (mp.containsKey(check)) {
                c++;
                vis.set(mp.get(check), true);
            }
        }
    }
    return n - c;
}
--------------------------------
List<Integer> minDistancePoints(List<Integer> a, int k, int n) {
    Map<Integer, Integer> m = new HashMap<>();
    Queue<Integer> q = new LinkedList<>();
    for (int i = 0; i < n; ++i) {
        m.put(a.get(i), 1);
        q.add(a.get(i));
    }
    List<Integer> ans = new ArrayList<>();
    while (k > 0) {
        int x = q.poll();
        if (!m.containsKey(x - 1) && k > 0) {
            m.put(x - 1, 1);
            q.add(x - 1);
            ans.add(x - 1);
            k--;
        }
        if (!m.containsKey(x + 1) && k > 0) {
            m.put(x + 1, 1);
            q.add(x + 1);
            ans.add(x + 1);
            k--;
        }
    }
    return ans;
}
--------------------------------
boolean isValidLen(String s, int len, int k) {
    int n = s.length();
    Map<Character, Integer> mp = new HashMap<>();
    int right = 0;
    while (right < len) {
        if (mp.containsKey(s.charAt(right))) {
            mp.put(s.charAt(right), mp.get(s.charAt(right)) + 1);
        } else {
            mp.put(s.charAt(right), 1);
        }
        right++;
    }
    if (mp.size() <= k) {
        return true;
    }
    while (right < n) {
        if (mp.containsKey(s.charAt(right))) {
            mp.put(s.charAt(right), mp.get(s.charAt(right)) + 1);
        } else {
            mp.put(s.charAt(right), 1);
        }
        if (mp.containsKey(s.charAt(right - len))) {
            mp.put(s.charAt(right - len), mp.get(s.charAt(right - len)) - 1);
        }
        if (mp.get(s.charAt(right - len)) == 0) {
            mp.remove(s.charAt(right - len));
        }
        if (mp.size() <= k) {
            return true;
        }
        right++;
    }
    return mp.size() <= k;
}
--------------------------------
int partition(List<Integer> arr, int low, int high) {
    int pivot = arr.get(high);
    int i = low - 1;
    for (int j = low; j <= high - 1; j++) {
        if (arr.get(j) <= pivot) {
            i++;
            Collections.swap(arr, i, j);
        }
    }
    Collections.swap(arr, i + 1, high);
    return i + 1;
}
--------------------------------
int strScore(List<String> strs, String s, int n) {
    Map<String, Integer> m = new HashMap<>();
    for (int i = 0; i < n; i++) {
        m.put(strs.get(i), i + 1);
    }
    if (!m.containsKey(s)) {
        return 0;
    }
    int score = 0;
    for (int i = 0; i < s.length(); i++) {
        score += s.charAt(i) - 'a' + 1;
    }
    score = score * m.get(s);
    return score;
}
--------------------------------
List<Integer> countEle(List<Integer> s, List<Integer> a, int n) {
    Map<Integer, Boolean> mp = new HashMap<>();
    List<Integer> ans = new ArrayList<>();
    for (int i = 0; i < n; ++i) {
        int num = a.get(i);
        if (mp.containsKey(num)) {
            ans.add(0);
        } else {
            int cnt = 0;
            while (s.get(0)!= num) {
                mp.put(s.get(0), true);
                s.remove(0);
                cnt++;
            }
            s.remove(0);
            cnt++;
            ans.add(cnt);
        }
    }
    return ans;
}
--------------------------------
int maxDistinctChar(String s, int n, int k) {
    Map<Character, Integer> freq = new HashMap<>();
    for (int i = 0; i < n; i++) {
        freq.put(s.charAt(i), freq.getOrDefault(s.charAt(i), 0) + 1);
    }
    List<Integer> v = new ArrayList<>();
    for (Map.Entry<Character, Integer> it : freq.entrySet()) {
        v.add(it.getValue());
    }
    Collections.sort(v);
    for (int i = 0; i < v.size(); i++) {
        int mn = Math.min(v.get(i) - 1, k);
        v.set(i, v.get(i) - mn);
        k -= mn;
    }
    if (k > 0) {
        for (int i = 0; i < v.size(); i++) {
            int mn = Math.min(v.get(i), k);
            v.set(i, v.get(i) - mn);
            k -= mn;
        }
    }
    int res = 0;
    for (int i = 0; i < v.size(); i++) {
        if (v.get(i) == 1) {
            res++;
        }
    }
    return res;
}
--------------------------------
int findKth(List<Integer> arr, int n, int k) {
    Set<Integer> missing = new HashSet<>();
    int count = 0;
    for (int i = 0; i < n; i++) {
        missing.add(arr.get(i));
    }
    int max_m = Collections.max(arr);
    int min_m = Collections.min(arr);
    for (int i = min_m + 1; i < max_m; i++) {
        if (!missing.contains(i)) {
            count++;
        }
        if (count == k) {
            return i;
        }
    }
    return -1;
}
--------------------------------
boolean almostSort(List<Integer> a, int n) {
    for (int i = 0; i < n - 1; i++) {
        if (a.get(i) > a.get(i + 1)) {
            Collections.swap(a, i, i + 1);
            i++;
        }
    }
    for (int i = 0; i < n - 1; i++) {
        if (a.get(i) > a.get(i + 1)) {
            return false;
        }
    }
    return true;
}
--------------------------------
int maximumSum(String s, int n, int k) {
    int sum = 0;
    int[] freq = new int[256];
    for (int i = 0; i < n; i++) {
        freq[s.charAt(i)]++;
    }
    Arrays.sort(freq);
    for (int i = 255; i >= 0; i--) {
        if (k > freq[i]) {
            sum += freq[i] * freq[i];
            k -= freq[i];
        } else {
            sum += freq[i] * k;
            break;
        }
    }
    return sum;
}
--------------------------------
int findMinOperations(List<Integer> arr, int N, int K) {
    int operations = 0;
    for (int i = 0; i < K; i++) {
        Map<Integer, Integer> freq = new HashMap<>();
        for (int j = i; j < N; j += K) {
            freq.put(arr.get(j), freq.getOrDefault(arr.get(j), 0) + 1);
        }
        int max1 = 0, num = 0;
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            if (entry.getValue() > max1) {
                max1 = entry.getValue();
                num = entry.getKey();
            }
        }
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            if (entry.getKey()!= num) {
                operations += entry.getValue();
            }
        }
    }
    return operations;
}
--------------------------------
List<String> subString(String s, int n) {
    List<String> v = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        for (int length = 1; length <= n - i; length++) {
            String find = s.substring(i, i + length);
            v.add(find);
        }
    }
    return v;
}
--------------------------------
boolean checkUniqueFrequency(List<Integer> arr, int n) {
    Map<Integer, Integer> freq = new HashMap<>();
    for (int i = 0; i < n; i++) {
        freq.put(arr.get(i), freq.getOrDefault(arr.get(i), 0) + 1);
    }
    Set<Integer> uniqueFreq = new HashSet<>();
    for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
        if (uniqueFreq.contains(entry.getValue())) {
            return false;
        } else {
            uniqueFreq.add(entry.getValue());
        }
    }
    return true;
}
--------------------------------
int minCost(String str1, String str2, int n) {
    int cost = 0;
    String tmp = str1;
    for (int i = 0; i < n; i++) {
        if (tmp.charAt(i)!= str2.charAt(i)) {
            if (i < n - 1 && tmp.charAt(i + 1)!= str2.charAt(i + 1)) {
                char c = tmp.charAt(i);
                tmp = tmp.substring(0, i) + tmp.substring(i + 1);
                tmp = tmp.substring(0, i) + c + tmp.substring(i);
                cost++;
            } else {
                cost++;
            }
        }
    }
    return cost;
}
--------------------------------
boolean isValidNum(String x) {
    Map<Integer, Integer> mp = new HashMap<>();
    for (int i = 0; i < x.length(); i++) {
        if (mp.containsKey(x.charAt(i) - '0')) {
            return false;
        } else if (x.charAt(i) - '0' > 5) {
            return false;
        } else {
            mp.put(x.charAt(i) - '0', 1);
        }
    }
    return true;
}
--------------------------------
int minimizeDiff(List<Integer> arr, int n, int k) {
    int max = Collections.max(arr);
    int min = Collections.min(arr);
    if (max - min <= k) {
        return max - min;
    }
    int avg = (max + min) / 2;
    for (int i = 0; i < n; i++) {
        if (arr.get(i) > avg) {
            arr.set(i, arr.get(i) - k);
        } else {
            arr.set(i, arr.get(i) + k);
        }
    }
    max = Collections.max(arr);
    min = Collections.min(arr);
    return max - min;
}
--------------------------------
int getMinCost(List<Integer> arr, int n) {
    int minEle = Collections.min(arr);
    return minEle * (n - 1);
}
--------------------------------
boolean possibility(Map<Integer, Integer> m, int length, String s) {
    int count_odd = 0;
    for (int i = 0; i < length; i++) {
        if ((m.get(s.charAt(i) - '0') & 1) == 1) {
            count_odd++;
        }
        if (count_odd > 1) {
            return false;
        }
    }
    return true;
}
--------------------------------
int minimumCostOfBreaking(List<Integer> x, List<Integer> y, int m, int n) {
    int res = 0;
    Collections.sort(x, Collections.reverseOrder());
    Collections.sort(y, Collections.reverseOrder());
    int hzntl = 1, vert = 1;
    int i = 0, j = 0;
    while (i < m && j < n) {
        if (x.get(i) > y.get(j)) {
            res += x.get(i) * vert;
            hzntl++;
            i++;
        } else {
            res += y.get(j) * hzntl;
            vert++;
            j++;
        }
    }
    int total = 0;
    while (i < m) {
        total += x.get(i++);
    }
    res += total * vert;
    total = 0;
    while (j < n) {
        total += y.get(j++);
    }
    res += total * hzntl;
    return res;
}
--------------------------------
int findMaximumScore(List<Integer> a, int n) {
    Map<Integer, Integer> freq = new HashMap<>();
    for (int i = 0; i < n; i++) {
        if (freq.containsKey(a.get(i))) {
            freq.put(a.get(i), freq.get(a.get(i)) + 1);
        } else {
            freq.put(a.get(i), 1);
        }
    }
    int[] dp = new int[Collections.max(a) + 1];
    dp[0] = 0;
    dp[1] = freq.getOrDefault(1, 0);
    for (int i = 2; i < dp.length; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + freq.getOrDefault(i, 0) * i);
    }
    return dp[dp.length - 1];
}
--------------------------------
int countWays(String s, String t, int k, int mod) {
    int n = s.length();
    int a = 0, b = 0;
    for (int i = 0; i < n; i++) {
        String p = s.substring(i, n - i) + s.substring(0, i);
        if (p.equals(t)) {
            a++;
        } else {
            b++;
        }
    }
    int[] dp1 = new int[k + 1], dp2 = new int[k + 1];
    if (s.equals(t)) {
        dp1[0] = 1;
        dp2[0] = 0;
    } else {
        dp1[0] = 0;
        dp2[0] = 1;
    }
    for (int i = 1; i <= k; i++) {
        dp1[i] = ((dp1[i - 1] * (a - 1)) % mod + (dp2[i - 1] * a) % mod) % mod;
        dp2[i] = ((dp1[i - 1] * (b)) % mod + (dp2[i - 1] * (b - 1)) % mod) % mod;
    }
    return dp1[k];
}
--------------------------------
int findSubarraySum(List<Integer> arr, int n, int k) {
    Map<Integer, Integer> prevSum = new HashMap<>();
    int res = 0;
    int currSum = 0;
    for (int i = 0; i < n; i++) {
        currSum += arr.get(i);
        if (currSum == k) {
            res++;
        }
        if (prevSum.containsKey(currSum - k)) {
            res += prevSum.get(currSum - k);
        }
        prevSum.put(currSum, prevSum.getOrDefault(currSum, 0) + 1);
    }
    return res;
}
--------------------------------
int maximumOccurrence(String s) {
    int n = s.length();
    Map<String, Integer> freq = new HashMap<>();
    for (int i = 0; i < n; i++) {
        String temp = "";
        temp += s.charAt(i);
        freq.put(temp, freq.getOrDefault(temp, 0) + 1);
    }
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            String temp = "";
            temp += s.charAt(i);
            temp += s.charAt(j);
            freq.put(temp, freq.getOrDefault(temp, 0) + 1);
        }
    }
    int answer = Integer.MIN_VALUE;
    for (Map.Entry<String, Integer> entry : freq.entrySet()) {
        answer = Math.max(answer, entry.getValue());
    }
    return answer;
}
--------------------------------
int countCharacters(List<String> strings, String chars) {
    int res = 0;
    Map<Character, Integer> freq = new HashMap<>();
    for (int i = 0; i < chars.length(); i++) {
        freq.put(chars.charAt(i), freq.getOrDefault(chars.charAt(i), 0) + 1);
    }
    for (String st : strings) {
        boolean flag = true;
        for (char c : st.toCharArray()) {
            if (!freq.containsKey(c)) {
                flag = false;
                break;
            }
        }
        if (flag) {
            res += st.length();
        }
    }
    return res;
}
--------------------------------
int distinctSubstring(String p, String q, int k, int n) {
    Set<String> ss = new HashSet<>();
    for (int i = 0; i < n; ++i) {
        int sum = 0;
        String s = "";
        for (int j = i; j < n; ++j) {
            int pos = p.charAt(j) - 'a';
            sum += q.charAt(pos) - '0';
            s += p.charAt(j);
            if (sum <= k) {
                ss.add(s);
            } else {
                break;
            }
        }
    }
    return ss.size();
}
--------------------------------
int uniqueMorseRep(List<String> arr) {
    List<String> morseCode = Arrays.asList(".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-", "..-", "...-", ".--", "-..-", "-.--", "--..");
    Set<String> st = new HashSet<>();
    for (String s : arr) {
        StringBuilder sb = new StringBuilder();
        for (char c : s.toCharArray()) {
            sb.append(morseCode.get(c - 'a'));
        }
        st.add(sb.toString());
    }
    return st.size();
}
--------------------------------
int countSubstrings(String st, int k) {
    int n = st.length();
    int answer = 0;
    Map<Character, Integer> map = new HashMap<>();
    for (int i = 0; i < k; i++) {
        if (!map.containsKey(st.charAt(i))) {
            map.put(st.charAt(i), 1);
        } else {
            map.put(st.charAt(i), map.get(st.charAt(i)) + 1);
        }
    }
    if (map.size() == k) {
        answer++;
    }
    for (int i = k; i < n; i++) {
        if (!map.containsKey(st.charAt(i))) {
            map.put(st.charAt(i), 1);
        } else {
            map.put(st.charAt(i), map.get(st.charAt(i)) + 1);
        }
        map.put(st.charAt(i - k), map.get(st.charAt(i - k)) - 1);
        if (map.get(st.charAt(i - k)) == 0) {
            map.remove(st.charAt(i - k));
        }
        if (map.size() == k) {
            answer++;
        }
    }
    return answer;
}
--------------------------------
boolean canConstruct(String s, int k) {
    Map<Character, Integer> m = new HashMap<>();
    int i = 0, j = 0, p = 0;
    if (s.length() == k) {
        return true;
    }
    for (i = 0; i < s.length(); i++) {
        m.put(s.charAt(i), m.getOrDefault(s.charAt(i), 0) + 1);
    }
    if (k > s.length()) {
        return false;
    } else {
        for (Map.Entry<Character, Integer> h : m.entrySet()) {
            if (h.getValue() % 2!= 0) {
                p = p + 1;
            }
        }
    }
    if (k < p) {
        return false;
    }
    return true;
}
--------------------------------
boolean equalIgnoreCase(String str1, String str2) {
    return str1.toUpperCase().equals(str2.toUpperCase());
}
--------------------------------
int findLongestSub(String bin) {
    int n = bin.length(), i;
    int sum = 0;
    Map<Integer, Integer> prev_sum = new HashMap<>();
    int max_len = 0;
    for (i = 0; i < n; i++) {
        if (bin.charAt(i) == '1') {
            sum++;
        } else {
            sum--;
        }
        if (sum > 0) {
            max_len = i + 1;
        } else if (sum <= 0) {
            if (prev_sum.containsKey(sum - 1)) {
                int curr_len = i - prev_sum.get(sum - 1);
                max_len = Math.max(max_len, curr_len);
            }
        }
        if (!prev_sum.containsKey(sum)) {
            prev_sum.put(sum, i);
        }
    }
    return max_len;
}
--------------------------------
boolean hasAllCodes(String s, int k) {
    Set<String> set = new HashSet<>();
    for (int i = 0; i + k <= s.length(); i++) {
        set.add(s.substring(i, i + k));
    }
    return set.size() == (1 << k);
}
--------------------------------
boolean checkPalin(String word) {
    int n = word.length();
    word = word.toLowerCase();
    for (int i = 0; i < n; i++, n--) {
        if (word.charAt(i)!= word.charAt(n - 1)) {
            return false;
        }
    }
    return true;
}
--------------------------------
String convert(String st) {
    String w, z;
    st = st.toUpperCase();
    st += " ";
    for (int i = 0; i < st.length(); i++) {
        char ch = st.charAt(i);
        if (ch!='') {
            w += ch;
        } else {
            z += Character.toLowerCase(w.charAt(0)) + w.substring(1) + " ";
            w = "";
        }
    }
    return z;
}
--------------------------------
int maxLines(int n, List<Integer> x1, List<Integer> y1, List<Integer> x2, List<Integer> y2) {
    Set<Double> s = new HashSet<>();
    double slope;
    for (int i = 0; i < n; ++i) {
        if (x1.get(i) == x2.get(i)) {
            slope = Integer.MAX_VALUE;
        } else {
            slope = (y2.get(i) - y1.get(i)) * 1.0 / (x2.get(i) - x1.get(i));
        }
        s.add(slope);
    }
    return s.size();
}
--------------------------------
HashMap<Integer, Integer> PrimeFactor(int n) {
    HashMap<Integer, Integer> primef = new HashMap<Integer, Integer>();
    while (n % 2 == 0) {
        if (primef.containsKey(2)) {
            primef.put(2, primef.get(2) + 1);
        } else {
            primef.put(2, 1);
        }
        n /= 2;
    }
    for (int i = 3; i <= Math.sqrt(n); i++) {
        while (n % i == 0) {
            if (primef.containsKey(i)) {
                primef.put(i, primef.get(i) + 1);
            } else {
                primef.put(i, 1);
            }
            n /= i;
        }
    }
    if (n > 2) {
        primef.put(n, 1);
    }
    return primef;
}
--------------------------------
String isDivisibleByDivisor(int s, int d) {
    s %= d;
    Set<Integer> hashMap = new HashSet<>();
    hashMap.add(s);
    for (int i = 0; i <= d; i++) {
        s += s % d;
        s %= d;
        if (hashMap.contains(s)) {
            if (s == 0) {
                return "Yes";
            }
            return "No";
        } else {
            hashMap.add(s);
        }
    }
    return "Yes";
}
--------------------------------
boolean oddSum(List<Integer> a, int n, int k) {
    Set<Integer> odd = new HashSet<>();
    Set<Integer> even = new HashSet<>();
    for (int i = 0; i < n; i++) {
        if (a.get(i) % 2 == 0) {
            even.add(a.get(i));
        } else {
            odd.add(a.get(i));
        }
    }
    if (odd.size() >= k) {
        return true;
    }
    boolean flag = false;
    for (int i = 1; i < k; i += 2) {
        int needed = k - i;
        if (needed <= even.size()) {
            return true;
        }
    }
    return flag;
}
--------------------------------
int dayOfYear(String date) {
    int year = Integer.parseInt(date.substring(0, 4));
    int month = Integer.parseInt(date.substring(5, 7));
    int day = Integer.parseInt(date.substring(8));
    if (month > 2 && (year % 4 == 0 && (year % 100!= 0 || year % 400 == 0))) {
        day++;
    }
    while (month > 1) {
        day = day + 31;
        month--;
    }
    return day;
}
--------------------------------
boolean isPerfectSquare(List<Integer> arr, int n) {
    Map<Integer, Integer> umap = new HashMap<>();
    for (int i = 0; i < n; i++) {
        umap.put(arr.get(i), umap.getOrDefault(arr.get(i), 0) + 1);
    }
    for (Map.Entry<Integer, Integer> itr : umap.entrySet()) {
        if (itr.getValue() % 2 == 1) {
            return false;
        }
    }
    return true;
}
--------------------------------
int minMoves(int n) {
    String s = Integer.toString(n);
    int ans = Integer.MAX_VALUE;
    int length = s.length();
    for (int i = 0; i < length; ++i) {
        for (int j = 0; j < length; ++j) {
            if (i == j) {
                continue;
            }
            String t = s;
            int cur = 0;
            for (int k = i; k < length - 1; ++k) {
                char temp = t.charAt(k);
                t = t.substring(0, k) + t.substring(k + 1);
                t = t.substring(0, k) + temp + t.substring(k);
                ++cur;
            }
            for (int k = j - (j > i); k < length - 2; ++k) {
                char temp = t.charAt(k);
                t = t.substring(0, k) + t.substring(k + 1);
                t = t.substring(0, k) + temp + t.substring(k);
                ++cur;
            }
            int pos = -1;
            for (int k = 0; k < length; ++k) {
                if (t.charAt(k)!= '0') {
                    pos = k;
                    break;
                }
            }
            for (int k = pos; k > 0; --k) {
                char temp = t.charAt(k);
                t = t.substring(0, k) + t.substring(k + 1);
                t = t.substring(0, k) + temp + t.substring(k);
                ++cur;
            }
            int nn = Integer.parseInt(t);
            if (nn % 25 == 0) {
                ans = Math.min(ans, cur);
            }
        }
    }
    if (ans == Integer.MAX_VALUE) {
        return -1;
    }
    return ans;
}
--------------------------------
int minimumOperations(List<Integer> a, int n) {
    Map<Integer, Integer> mp = new HashMap<>();
    for (int i = 0; i < n; i++) {
        mp.put(a.get(i), mp.getOrDefault(a.get(i), 0) + 1);
    }
    int count = 0;
    for (Map.Entry<Integer, Integer> entry : mp.entrySet()) {
        if (entry.getValue() > 1) {
            count += entry.getValue() - 1;
        }
    }
    return count;
}
--------------------------------
int kaprekarRec(int n, int prev) {
    if (n == 0) {
        return 0;
    }
    prev = n;
    int digits[] = new int[4];
    for (int i = 0; i < 4; i++) {
        digits[i] = n % 10;
        n = n / 10;
    }
    Arrays.sort(digits);
    int asc = 0;
    for (int i = 0; i < 4; i++) {
        asc = asc * 10 + digits[i];
    }
    Arrays.sort(digits);
    int desc = 0;
    for (int i = 3; i >= 0; i--) {
        desc = desc * 10 + digits[i];
    }
    int diff = Math.abs(asc - desc);
    if (diff == prev) {
        return diff;
    }
    return kaprekarRec(diff, prev);
}
--------------------------------
String fractionToDecimal(int numr, int denr) {
    String res = "";
    Map<Integer, Integer> mp = new HashMap<>();
    int rem = numr % denr;
    while (rem!= 0 &&!mp.containsKey(rem)) {
        mp.put(rem, res.length());
        rem = rem * 10;
        int res_part = rem / denr;
        res += res_part;
        rem = rem % denr;
    }
    if (rem == 0) {
        return "";
    }
    if (mp.containsKey(rem)) {
        return res.substring(mp.get(rem));
    }
    return "";
}
--------------------------------
boolean isFancy(String num) {
    Map<Character, Character> fp = new HashMap<>();
    fp.put('0', '0');
    fp.put('1', '1');
    fp.put('6', '9');
    fp.put('8', '8');
    fp.put('9', '6');
    int n = num.length();
    int l = 0, r = n - 1;
    while (l <= r) {
        if (!fp.containsKey(num.charAt(l)) || fp.get(num.charAt(l))!= num.charAt(r)) {
            return false;
        }
        l++;
        r--;
    }
    return true;
}
--------------------------------
double distinctOddRatio(List<Integer> numbers) {
    Set<Integer> distinctNumbers = new HashSet<>(numbers);
    int distinctCount = distinctNumbers.size();
    int distinctOddCount = (int) distinctNumbers.stream().filter(n -> n % 2 == 1).count();
    return (double) distinctOddCount / distinctCount;
}
--------------------------------
int compareSum(List<Integer> numbers, List<String> words) {
    int intSum = numbers.stream().reduce(0, Integer::sum);
    int wordLengthSum = words.stream().mapToInt(String::length).sum();
    if (intSum < wordLengthSum) {
        return -1;
    }
    if (intSum > wordLengthSum) {
        return 1;
    }
    return 0;
}
--------------------------------
boolean allLongerThan(List<String> shortWords, List<String> longWords) {
    int maxOfShort = IntStream.of(shortWords.stream().mapToInt(String::length).toArray()).max().getAsInt();
    int minOfLong = IntStream.of(longWords.stream().mapToInt(String::length).toArray()).min().getAsInt();
    return minOfLong > maxOfShort;
}
--------------------------------
int compareOddEvenRange(List<Integer> numbers) {
    int rangeOdd = IntStream.of(numbers.stream().filter(n -> n % 2 == 1).toArray()).max().getAsInt() - IntStream.of(numbers.stream().filter(n -> n % 2 == 1).toArray()).min().getAsInt();
    int rangeEven = IntStream.of(numbers.stream().filter(n -> n % 2 == 0).toArray()).max().getAsInt() - IntStream.of(numbers.stream().filter(n -> n % 2 == 0).toArray()).min().getAsInt();
    if (rangeOdd < rangeEven) {
        return -1;
    }
    if (rangeOdd > rangeEven) {
        return 1;
    }
    return 0;
}
--------------------------------
double averageDistinctLength(List<String> words) {
    Set<String> distinctWords = new HashSet<>(words);
    List<Integer> distinctWordLengths = distinctWords.stream().map(String::length).collect(Collectors.toList());
    double averageLen = distinctWordLengths.isEmpty()? 0 : (double) distinctWordLengths.stream().reduce(0, Integer::sum) / distinctWordLengths.size();
    return averageLen;
}
--------------------------------
int withDrawBalance(int start, List<Integer> withdrawals) {
    int end = IntStream.range(0, withdrawals.size()).map(i -> withdrawals.get(i)).reduce(start, (balance, nextWithdrawal) -> nextWithdrawal <= balance? balance - nextWithdrawal : balance);
    return end;
}
--------------------------------
String firstShortAndStartsWithO(List<String> words) {
    return words.stream()
        .filter(w -> w.length() < 5)
        .filter(w -> w.charAt(0) == 'o')
        .findFirst()
        .orElse("");
}
--------------------------------
int bigNumberAtIndex(List<Integer> numbers, int index) {
    List<Integer> matched_view = numbers.stream()
        .filter(n -> n > 5)
        .skip(index)
        .collect(Collectors.toList());
    int target_num = matched_view.get(0);
    return target_num;
}
--------------------------------
boolean containsSquareInRange(int rangeStart, int rangeLength) {
    return ranges.anyMatch(IntStream.range(rangeStart, rangeStart + rangeLength).boxed(), n -> Math.pow(Math.sqrt(n), 2) == n);
}
--------------------------------
Map<Integer, List<Integer> > groupNumbersByMod(List<Integer> numbers, int mod) {
    Map<Integer, List<Integer> > numberGroups = new HashMap<>();
    for (int n : numbers) {
        int key = n % mod;
        numberGroups.computeIfAbsent(key, k -> new ArrayList<>()).add(n);
    }
    return numberGroups;
}
--------------------------------
Map<Character, List<String> > groupWordsByFirstChar(List<String> words) {
    Map<Character, List<String> > wordGroups = new HashMap<>();
    for (String word : words) {
        char firstChar = word.charAt(0);
        if (!wordGroups.containsKey(firstChar)) {
            wordGroups.put(firstChar, new ArrayList<>());
        }
        wordGroups.get(firstChar).add(word);
    }
    return wordGroups;
}
--------------------------------
List<String> orderByLengthAndDescending(List<String> words) {
    List<String> sortedWords = new ArrayList<>(words);
    sortedWords.sort((a, b) -> {
        if (a.length() == b.length()) {
            return a.compareTo(b);
        }
        return a.length() - b.length();
    });
    return sortedWords;
}
--------------------------------
List<String> orderFirstCharDescendingReverse(List<String> words) {
    List<String> sortedWords = new ArrayList<>(words);
    sortedWords.sort((a, b) -> {
        if (a.charAt(0) == b.charAt(0)) {
            return a.compareTo(b);
        }
        return a.charAt(0) > b.charAt(0)? -1 : 1;
    });
    Collections.reverse(sortedWords);
    return sortedWords;
}
--------------------------------
List<Integer> getSubListOfNegative(List<Integer> numbers, int start, int length) {
    return numbers.stream().skip(start).filter(n -> n < 0).limit(length).collect(Collectors.toList());
}
--------------------------------
List<Integer> getPositiveSequence(List<Integer> numbers) {
    List<Integer> subSequence = new ArrayList<>();
    for (int n : numbers) {
        if (n > 0) {
            subSequence.add(n);
        }
    }
    return subSequence;
}
--------------------------------
List<Integer> getLargerThanIndexSequence(List<Integer> numbers) {
    List<Integer> subSequence = new ArrayList<>();
    for (int i = 0; i < numbers.size(); i++) {
        if (numbers.get(i) > i) {
            subSequence.add(numbers.get(i));
        }
    }
    return subSequence;
}
--------------------------------
List<String> rearrangeWordByIndexes(List<String> words, List<Integer> indexes) {
    List<Integer> new_indexes = indexes.stream().filter(n -> n >= words.size()).map(n -> n % words.size());
    List<String> matched_view = new_indexes.stream().map(n -> words.get(n));
    List<String> new_words = new ArrayList<>();
    new_words.addAll(matched_view);
    return new_words;
}
--------------------------------
List<List<String> > getWordsUpperLower(List<String> words) {
    List<List<String> > upperLowerWords = new ArrayList<>();
    for (String word : words) {
        String upper = word.toUpperCase();
        String lower = word.toLowerCase();
        upperLowerWords.add(Arrays.asList(upper, lower));
    }
    return upperLowerWords;
}
--------------------------------
List<Boolean> selectIfInPlace(List<Integer> numbers) {
    List<Boolean> numsInPlace = new ArrayList<>();
    for (int i = 0; i < numbers.size(); i++) {
        numsInPlace.add(numbers.get(i) == i);
    }
    return numsInPlace;
}
--------------------------------
List<List<Integer> > selectPairs(List<Integer> numbersA, List<Integer> numbersB) {
    List<List<Integer> > pairs = new ArrayList<>();
    for (Integer a : numbersA) {
        for (Integer b : numbersB) {
            if (a < b) {
                pairs.add(Arrays.asList(a, b));
            }
        }
    }
    return pairs;
}
--------------------------------
List<String> stringCrossJoin(List<String> endWords, List<String> beginWords) {
    List<String> matchedView = beginWords.stream()
        .map(b -> endWords.stream()
            .filter(e -> b.charAt(0) == e.charAt(e.length() - 1))
            .map(e -> e + " " + b)
        ).flatMap(Function.identity()).collect(Collectors.toList());
    return matchedView;
}
--------------------------------
int elementsContainSubword(List<String> words, String subword) {
    if (words.stream().limit(5).allMatch(w -> w.contains(subword))) return 1;
    if (words.stream().limit(5).anyMatch(w -> w.contains(subword))) return 0;
    return -1;
}
--------------------------------
List<Integer> ConcatLargeNumbers(List<Integer> numbersA, List<Integer> numbersB, int flag) {
    List<Integer> largeNumbersA = numbersA.stream().filter(n -> n > flag).collect(Collectors.toList());
    List<Integer> largeNumbersB = numbersB.stream().filter(n -> n > flag).collect(Collectors.toList());
    List<Integer> allNumbers = new ArrayList<>();
    allNumbers.addAll(largeNumbersA);
    allNumbers.addAll(largeNumbersB);
    return allNumbers;
}
--------------------------------
int DotProduct(List<Integer> vectorA, List<Integer> vectorB) {
    int dotProduct = 0;
    for (int i = 0; i < vectorA.size(); i++) {
        dotProduct += vectorA.get(i) * vectorB.get(i);
    }
    return dotProduct;
}
--------------------------------
List<Integer> SetDifference(List<Integer> setA, List<Integer> setB) {
    List<Integer> difference = new ArrayList<>();
    Collections.sort(setA);
    Collections.sort(setB);
    Collections.setSymmetricDifference(setA, setB, difference);
    return difference;
}
--------------------------------
