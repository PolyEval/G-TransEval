int GreatestCommonDivisor(int a, int b) {
    if (a == 0 || b == 0) {
        return a + b;
    }
    if (a == b) {
        return a;
    }
    if (a > b) {
        return GreatestCommonDivisor(a % b, b);
    } else {
        return GreatestCommonDivisor(a, b % a);
    }
}
--------------------------------
int LargestDivisor(int n) {
    for (int i = 2; i <= n; i++) {
        if (n % i == 0) {
            return n / i;
        }
    }
    return 1;
}
--------------------------------
bool IsPrime(int n) {
    if (n < 2) {
        return false;
    }
    for (int k = 2; k < n; k++) {
        if (n % k == 0) {
            return false;
        }
    }
    return true;
}
--------------------------------
int FizzBuzz(int n) {
    int count = 0;
    for (int i = 1; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            int q = i;
            while (q > 0) {
                if (q % 10 == 7) {
                    count += 1;
                }
                q /= 10;
            }
        }
    }
    return count;
}
--------------------------------
int PrimeFib(int n) {
    int f0 = 0;
    int f1 = 1;
    while (n > 0) {
        int p = f0 + f1;
        bool isPrime = p >= 2;
        for (int i = 2; i < p; i++) {
            if (p % i == 0) {
                isPrime = false;
                break;
            }
        }
        if (isPrime) {
            n -= 1;
        }
        f0 = f1;
        f1 = p;
    }
    return f1;
}
--------------------------------
double TriangleArea(double a, double h) {
    return a * h / 2;
}
--------------------------------
int ModP(int n, int p) {
    int ret = 1;
    for (int i = 0; i < n; i++) {
        ret = (ret * 2) % p;
    }
    return ret;
}
--------------------------------
int Add(int x, int y) {
    return x + y;
}
--------------------------------
int Fib(int n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    return Fib(n - 1) + Fib(n - 2);
}
--------------------------------
int LargestPrimeFactor(int n) {
    for (int i = 2; i < n; i++) {
        while (n % i == 0 && n > i) {
            n /= i;
        }
    }
    return n;
}
--------------------------------
int SumToN(int n) {
    int result = 0;
    for (int i = 1; i <= n; i++) {
        result += i;
    }
    return result;
}
--------------------------------
int Fibfib(int n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 0;
    }
    if (n == 2) {
        return 1;
    }
    return Fibfib(n - 1) + Fibfib(n - 2) + Fibfib(n - 3);
}
--------------------------------
bool IsMultiplyPrime(int a) {
    int num = 0;
    for (int i = 2; i <= a; i++) {
        while (a % i == 0 && a >= i) {
            a /= i;
            num += 1;
        }
    }
    return num == 3;
}
--------------------------------
bool IsSimplePower(int x, int n) {
    if (n == 1) {
        return x == 1;
    }
    int power = 1;
    while (power < x) {
        power *= n;
    }
    return power == x;
}
--------------------------------
int ChooseNum(int x, int y) {
    if (x > y) {
        return -1;
    }
    if (y % 2 == 0) {
        return y;
    }
    if (x == y) {
        return -1;
    }
    return y - 1;
}
--------------------------------
bool IsEqualToSumEven(int n) {
    return (n % 2 == 0) && (n >= 8);
}
--------------------------------
int SpecialFactorial(int n) {
    int fact = 1, specialFact = 1;
    for (int i = 1; i <= n; i++) {
        fact *= i;
        specialFact *= fact;
    }
    return specialFact;
}
--------------------------------
int XOrY(int n, int x, int y) {
    bool isPrime = n >= 2;
    for (int i = 2; i < n; i++) {
        if (n % i == 0) {
            isPrime = false;
            break;
        }
    }
    if (isPrime) {
        return x;
    }
    return y;
}
--------------------------------
bool RightAngleTriangle(int a, int b, int c) {
    return (a * a == b * b + c * c) || (b * b == a * a + c * c) || (c * c == a * a + b * b);
}
--------------------------------
int FastPow(int n, int k) {
    if (k == 0) {
        return 1;
    }
    int temp = FastPow(n, k / 2);
    if (k % 2 == 0) {
        return temp * temp;
    } else {
        return n * temp * temp;
    }
}
--------------------------------
bool IsPalin(string s) {
    int l = s.length() / 2;
    for (int i = 0; i < l; i++) {
        if (s[i]!= s[s.length() - i - 1]) {
            return false;
        }
    }
    return true;
}
--------------------------------
int FindSum(int n) {
    int ans = 0, temp = 0;
    for (int i = 1; i <= n && temp < n; i++) {
        temp = i - 1;
        int num = 1;
        while (temp < n) {
            if (temp + i <= n) {
                ans += i * num;
            } else {
                ans += (n - temp) * num;
            }
            temp += i;
            num++;
        }
    }
    return ans;
}
--------------------------------
int GetNextGap(int gap) {
    gap = gap * 10 / 13;
    if (gap < 1) {
        return 1;
    }
    return gap;
}
--------------------------------
int CountNonDecreasing(int n) {
    int k = 10;
    int count = 1;
    for (int i = 1; i <= n; i++) {
        count *= k + i - 1;
        count /= i;
    }
    return count;
}
--------------------------------
int Power(int x, int y) {
    if (y == 0) {
        return 1;
    } else if (y % 2 == 0) {
        return Power(x, y / 2) * Power(x, y / 2);
    } else {
        return x * Power(x, y / 2) * Power(x, y / 2);
    }
}
--------------------------------
double Power(double x, int y) {
    if (y == 0) {
        return 1;
    }
    double temp = Power(x, y / 2);
    if (y % 2 == 0) {
        return temp * temp;
    } else {
        if (y > 0) {
            return x * temp * temp;
        } else {
            return temp * temp / x;
        }
    }
}
--------------------------------
int Multiply(int x, int y) {
    if (y == 0) {
        return 0;
    } else if (y > 0) {
        return x + Multiply(x, y - 1);
    } else {
        return -Multiply(x, -y);
    }
}
--------------------------------
int Smallest(int x, int y, int z) {
    if (y / x == 0) {
        return y / z == 0? y : z;
    }
    return x / z == 0? x : z;
}
--------------------------------
bool IsPowerOfFour(int n) {
    if (n == 0) {
        return false;
    }
    while (n!= 1) {
        if (n % 4!= 0) {
            return false;
        }
        n = n / 4;
    }
    return true;
}
--------------------------------
int ModInverse(int a, int m) {
    int m0 = m;
    int x0 = 0, x1 = 1;
    if (m == 1) {
        return 0;
    }
    while (a > 1) {
        int q = a / m;
        int t = m;
        m = a % m;
        a = t;
        t = x0;
        x0 = x1 - q * x0;
        x1 = t;
    }
    if (x1 < 0) {
        x1 += m0;
    }
    return x1;
}
--------------------------------
int CntRotations(string s, int n) {
    string s2 = s + s;
    int pre[2 * n];
    for (int i = 0; i < 2 * n; i++) {
        if (i!= 0) {
            pre[i] += pre[i - 1];
        }
        if (s2[i] == 'a' || s2[i] == 'e' || s2[i] == 'i' || s2[i] == 'o' || s2[i] == 'u') {
            pre[i]++;
        }
    }
    int ans = 0;
    for (int i = n - 1; i < 2 * n - 1; i++) {
        int r = i, l = i - n;
        int x1 = pre[r];
        if (l >= 0) {
            x1 -= pre[l];
        }
        r = i - n / 2;
        int left = pre[r];
        if (l >= 0) {
            left -= pre[l];
        }
        int right = x1 - left;
        if (left > right) {
            ans++;
        }
    }
    return ans;
}
--------------------------------
int BinomialCoeff(int n, int k) {
    int res = 1;
    if (k > n - k) {
        k = n - k;
    }
    for (int i = 0; i < k; ++i) {
        res *= n - i;
        res /= i + 1;
    }
    return res;
}
--------------------------------
bool IsPrefix(string temp, string s) {
    if (temp.length() < s.length()) {
        return false;
    } else {
        for (int i = 0; i < s.length(); i++) {
            if (s[i]!= temp[i]) {
                return false;
            }
        }
        return true;
    }
}
--------------------------------
string LexicographicallySmallestString(string s, int n) {
    int lastZe = -1;
    string ans = "";
    for (int i = n - 1; i >= 0; i--) {
        if (s[i] == '0') {
            lastZe = i;
            break;
        }
    }
    for (int i = 0; i < n; i++) {
        if (i <= lastZe && s[i] == '0') {
            ans += s[i];
        } else if (i > lastZe) {
            ans += s[i];
        }
    }
    return ans;
}
--------------------------------
int CalculateMax(int n, int m, int k) {
    int ans = -1;
    int low = 0, high = m;
    while (low <= high) {
        int mid = (low + high) / 2;
        int val = 0;
        int l = k - 1;
        int r = n - k;
        val += mid;
        if (mid >= l) {
            val += l * (2 * mid - l - 1) / 2;
        } else {
            val += mid * (mid - 1) / 2 + (l - mid);
        }
        if (mid >= r) {
            val += r * (2 * mid - r - 1) / 2;
        } else {
            val += mid * (mid - 1) / 2 + (r - mid);
        }
        if (val <= m) {
            ans = max(ans, mid);
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return ans;
}
--------------------------------
int FindLength(string s, char i, char j) {
    char required = i;
    int length = 0;
    for (char curr : s.toCharArray()) {
        if (curr == required) {
            length += 1;
            if (required == i) {
                required = j;
            } else {
                required = i;
            }
        }
    }
    return length;
}
--------------------------------
bool CheckReverse(int left_sum, int right_sum) {
    int rev = 0;
    int temp = right_sum;
    while (temp!= 0) {
        rev = rev * 10 + temp % 10;
        temp /= 10;
    }
    if (rev == left_sum) {
        return true;
    }
    return false;
}
--------------------------------
bool IsComposite(int n) {
    if (n <= 1) {
        return false;
    }
    if (n <= 3) {
        return false;
    }
    if (n % 2 == 0 || n % 3 == 0) {
        return true;
    }
    for (int i = 5; i * i <= n; i = i + 6) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return true;
        }
    }
    return false;
}
--------------------------------
int MinDeletion(string s) {
    int n = s.size();
    int firstIdx1 = -1;
    int lastIdx0 = -1;
    for (int i = 0; i < n; i++) {
        if (s[i] == '1') {
            firstIdx1 = i;
            break;
        }
    }
    for (int i = n - 1; i >= 0; i--) {
        if (s[i] == '0') {
            lastIdx0 = i;
            break;
        }
    }
    if (firstIdx1 == -1 || lastIdx0 == -1) {
        return 0;
    }
    int count1 = 0, count0 = 0;
    for (int i = 0; i < lastIdx0; i++) {
        if (s[i] == '1') {
            count1++;
        }
    }
    for (int i = firstIdx1 + 1; i < n; i++) {
        if (s[i] == '1') {
            count0++;
        }
    }
    return min(count0, count1);
}
--------------------------------
int MinSteps(string s, int n) {
    int cost = 0;
    int[] f = new int[26];
    for (int i = 0; i < n; i++) {
        int currEle = s[i] - 'a';
        int smaller = 0;
        for (int j = 0; j <= currEle; j++) {
            if (f[j]!= 0) {
                smaller += f[j];
            }
        }
        if (smaller == 0) {
            cost += i + 1;
        } else {
            cost += i - smaller + 1;
        }
        f[s[i] - 'a']++;
    }
    return cost;
}
--------------------------------
int NumberOfWays(int n) {
    int count = 0;
    for (int a = 1; a < n; a++) {
        for (int b = 0; b < n; b++) {
            int c = n - (a + b);
            if (a + b > c && a + c > b && b + c > a) {
                count++;
            }
        }
    }
    return count;
}
--------------------------------
int SlopeOfNum(string num, int n) {
    int slope = 0;
    for (int i = 1; i < n - 1; i++) {
        if (num[i] > num[i - 1] && num[i] > num[i + 1]) {
            slope++;
        } else if (num[i] < num[i - 1] && num[i] < num[i + 1]) {
            slope++;
        }
    }
    return slope;
}
--------------------------------
int MiddleOfThree(int a, int b, int c) {
    int x = a - b;
    int y = b - c;
    int z = a - c;
    if (x * y > 0) {
        return b;
    } else if (x * z > 0) {
        return c;
    } else {
        return a;
    }
}
--------------------------------
int CountMaxSetBits(int left, int right) {
    while ((left | (left + 1)) <= right) {
        left |= left + 1;
    }
    return left;
}
--------------------------------
int FindS(int s) {
    int l = 1, r = (s / 2) + 1;
    while (l <= r) {
        int mid = (l + r) / 2;
        int sum = mid * (mid + 1) / 2;
        if (sum == s) {
            return mid;
        } else if (sum > s) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return -1;
}
--------------------------------
bool Check(string s) {
    int min = INT_MAX;
    int max = INT_MIN;
    int sum = 0;
    for (int i = 0; i < s.length(); i++) {
        int ascii = s[i];
        if (ascii < 96 || ascii > 122) {
            return false;
        }
        sum += ascii;
        if (min > ascii) {
            min = ascii;
        }
        if (max < ascii) {
            max = ascii;
        }
    }
    min -= 1;
    int eSum = max * (max + 1) / 2 - min * (min + 1) / 2;
    return sum == eSum;
}
--------------------------------
int MinimumPossibleProduct(int k) {
    int res = 1;
    int r = (1 << k) - 1;
    for (int i = 0; i < k; i++) {
        res *= r - 1;
    }
    res *= r;
    return res;
}
--------------------------------
int FindInGrid(int i, int j) {
    if (i == j) {
        return i * i - (i - 1);
    } else if (i > j) {
        if (i % 2 == 0) {
            return i * i - (j - 1);
        } else {
            return (i - 1) * (i - 1) + 1 + (j - 1);
        }
    } else {
        if (j % 2 == 0) {
            return (j - 1) * (j - 1) + 1 + (i - 1);
        } else {
            return j * j - (i - 1);
        }
    }
}
--------------------------------
int FindMinOperationsReqEmpStr(string s) {
    int cntOne = 0;
    int cntZero = 0;
    int n = s.length();
    for (int i = 0; i < n; i++) {
        if (s[i] == '0') {
            if (cntOne!= 0) {
                cntOne--;
            }
            cntZero++;
        } else {
            if (cntZero!= 0) {
                cntZero--;
            }
            cntOne++;
        }
    }
    return cntOne + cntZero;
}
--------------------------------
bool IsReachable(int x1, int y1, int x2, int y2) {
    while (x2 > x1 && y2 > y1) {
        if (x2 > y2) {
            x2 %= y2;
        } else {
            y2 %= x2;
        }
    }
    if (x2 == x1) {
        return (y2 - y1) >= 0 && (y2 - y1) % x1 == 0;
    } else if (y2 == y1) {
        return (x2 - x1) >= 0 && (x2 - x1) % y1 == 0;
    } else {
        return false;
    }
}
--------------------------------
int FindMaxSoln(int n, int x, int y) {
    int ans = INT_MIN;
    for (int k = 0; k <= n; k++) {
        if (k % x == y) {
            ans = max(ans, k);
        }
    }
    return ans >= 0 && ans <= n? ans : -1;
}
--------------------------------
int NumberOfPairs(int n) {
    int count = 0;
    int i = 1, j = n - 1;
    while (i < j) {
        if (i + j == n) {
            count++;
        }
        i++;
        j--;
    }
    return count;
}
--------------------------------
int MinChanges(string s, int n) {
    int count = 0, zeros = 0, ones = 0;
    if (s[0]!= '1') {
        count++;
        ones++;
    }
    for (int i = 1; i < n; i++) {
        if (s[i] == '0') {
            zeros++;
        } else {
            ones++;
        }
        if (zeros > ones) {
            zeros--;
            ones++;
            count++;
        }
    }
    return count;
}
--------------------------------
int KVisibleFromLeft(int n, int k) {
    if (n == k) {
        return 1;
    }
    if (k == 1) {
        int ans = 1;
        for (int i = 1; i < n; i++) {
            ans *= i;
        }
        return ans;
    }
    return KVisibleFromLeft(n - 1, k - 1) + (n - 1) * KVisibleFromLeft(n - 1, k);
}
--------------------------------
double Find(int n, int sum) {
    if (sum > 6 * n || sum < n) {
        return 0;
    }
    if (n == 1) {
        if (sum >= 1 && sum <= 6) {
            return 1.0 / 6;
        } else {
            return 0;
        }
    }
    double s = 0;
    for (int i = 1; i <= 6; i++) {
        s += Find(n - 1, sum - i) / 6;
    }
    return s;
}
--------------------------------
int BinCoff(int n, int r) {
    int val = 1;
    if (r > n - r) {
        r = n - r;
    }
    for (int i = 0; i < r; i++) {
        val *= n - i;
        val /= i + 1;
    }
    return val;
}
--------------------------------
int GetMask(int val) {
    int mask = 0;
    if (val == 0) {
        return 1;
    }
    while (val > 0) {
        int d = val % 10;
        mask |= 1 << d;
        val /= 10;
    }
    return mask;
}
--------------------------------
int WaysToKAdjacentSetBits(int n, int k, int current_index, int adjacent_set_bits, int last_bit) {
    if (current_index == n) {
        if (adjacent_set_bits == k) {
            return 1;
        }
        return 0;
    }
    int no_of_ways = 0;
    if (last_bit == 1) {
        no_of_ways += WaysToKAdjacentSetBits(n, k, current_index + 1, adjacent_set_bits + 1, 1);
        no_of_ways += WaysToKAdjacentSetBits(n, k, current_index + 1, adjacent_set_bits, 0);
    } else if (last_bit == 0) {
        no_of_ways += WaysToKAdjacentSetBits(n, k, current_index + 1, adjacent_set_bits, 1);
        no_of_ways += WaysToKAdjacentSetBits(n, k, current_index + 1, adjacent_set_bits, 0);
    }
    return no_of_ways;
}
--------------------------------
int CheckFunc(int i, int j, string st) {
    if (st[i] == '(' && st[j] == ')') {
        return 1;
    }
    if (st[i] == '(' && st[j] == '?') {
        return 1;
    }
    if (st[i] == '?' && st[j] == ')') {
        return 1;
    }
    if (st[i] == '[' && st[j] == ']') {
        return 1;
    }
    if (st[i] == '[' && st[j] == '?') {
        return 1;
    }
    if (st[i] == '?' && st[j] == ']') {
        return 1;
    }
    if (st[i] == '{' && st[j] == '}') {
        return 1;
    }
    if (st[i] == '{' && st[j] == '?') {
        return 1;
    }
    if (st[i] == '?' && st[j] == '}') {
        return 1;
    }
    return 0;
}
--------------------------------
int FindGolomb(int n) {
    if (n == 1) {
        return 1;
    }
    return 1 + FindGolomb(n - FindGolomb(FindGolomb(n - 1)));
}
--------------------------------
bool AllOnes(string s, int n) {
    int co = 0;
    for (int i = 0; i < s.length(); i++) {
        co += s[i] == '1'? 1 : 0;
    }
    return co == n;
}
--------------------------------
int Pad(int n) {
    int pPrevPrev = 1, pPrev = 1, pCurr = 1, pNext = 1;
    for (int i = 3; i <= n; i++) {
        pNext = pPrevPrev + pPrev;
        pPrevPrev = pPrev;
        pPrev = pCurr;
        pCurr = pNext;
    }
    return pNext;
}
--------------------------------
int OddLengthPalindrome(int k) {
    int palin = k;
    k = k / 10;
    while (k > 0) {
        int rev = k % 10;
        palin = palin * 10 + rev;
        k = k / 10;
    }
    return palin;
}
--------------------------------
string ChangeString(string s0) {
    char s[s0.length() + 1];
    strcpy(s, s0.c_str());
    int n = s0.length();
    if (s[0] == '?') {
        s[0] = 'a';
        if (s[0] == s[1]) {
            s[0]++;
        }
    }
    for (int i = 1; i < n - 1; i++) {
        if (s[i] == '?') {
            s[i] = 'a';
            if (s[i] == s[i - 1]) {
                s[i]++;
            }
            if (s[i] == s[i + 1]) {
                s[i]++;
            }
            if (s[i] == s[i - 1]) {
                s[i]++;
            }
        }
    }
    if (s[n - 1] == '?') {
        s[n - 1] = 'a';
        if (s[n - 1] == s[n - 2]) {
            s[n - 1]++;
        }
    }
    return string(s);
}
--------------------------------
int TotalHammingDistance(int n) {
    int sum = 0;
    for (int i = 1; n / i > 0; i *= 2) {
        sum += n / i;
    }
    return sum;
}
--------------------------------
int CheckBitonic(string s) {
    int i = 1;
    for (; i < s.length(); i++) {
        if (s[i] > s[i - 1]) {
            continue;
        }
        if (s[i] <= s[i - 1]) {
            break;
        }
    }
    if (i == s.length() - 1) {
        return 1;
    }
    int j = i + 1;
    for (; j < s.length(); j++) {
        if (s[j] < s[j - 1]) {
            continue;
        }
        if (s[j] >= s[j - 1]) {
            break;
        }
    }
    i = j;
    if (i!= s.length()) {
        return 0;
    }
    return 1;
}
--------------------------------
bool EndsWith(string str, string pat) {
    int patLen = pat.length();
    int strLen = str.length();
    if (patLen > strLen) {
        return false;
    }
    patLen--;
    strLen--;
    while (patLen >= 0) {
        if (pat[patLen]!= str[strLen]) {
            return false;
        }
        patLen--;
        strLen--;
    }
    return true;
}
--------------------------------
int GetSum(int n, int d) {
    if (n < d) {
        return 0;
    }
    while (n % 10!= d) {
        n--;
    }
    int k = n / 10;
    return (k + 1) * d + (k * 10 + 10 * k * k) / 2;
}
--------------------------------
int BalancedStringBySwapping(string s) {
    int unbalancedPair = 0;
    for (int i = 0; i < s.length(); ++i) {
        if (unbalancedPair > 0 && s[i] == ']') {
            --unbalancedPair;
        } else if (s[i] == '[') {
            ++unbalancedPair;
        }
    }
    return (unbalancedPair + 1) / 2;
}
--------------------------------
int ComputeHash(string s) {
    int p = 31;
    long mod = (int)1e9 + 7;
    long hashVal = 0;
    long mul = 1;
    for (char ch : s) {
        hashVal = (hashVal + (ch - 'a' + 1) * mul) % mod;
        mul = mul * p % mod;
    }
    return (int)hashVal;
}
--------------------------------
int CountOfSubstringWithOnlyOnes(string s) {
    int res = 0, count = 0;
    for (int i = 0; i < s.length(); i++) {
        count = s[i] == '1'? count + 1 : 0;
        res = res + count;
    }
    return res;
}
--------------------------------
int Composite(int n) {
    int flag = 0;
    int c = 0;
    for (int j = 1; j <= n; j++) {
        if (n % j == 0) {
            c += 1;
        }
    }
    if (c >= 3) {
        flag = 1;
    }
    return flag;
}
--------------------------------
bool IsDivBySix(string s, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += s[i] - 'a' + 1;
    }
    if (sum % 3!= 0) {
        return false;
    }
    int lastDigit = (s[n - 1] - 'a' + 1) % 10;
    if (lastDigit % 2!= 0) {
        return false;
    }
    return true;
}
--------------------------------
bool IsRedundantBraces(string s) {
    int a = 0, b = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == '(' && s[i + 2] == ')') {
            return true;
        }
        if (s[i] == '*' || s[i] == '+' || s[i] == '-' || s[i] == '/') {
            a++;
        }
        if (s[i] == '(') {
            b++;
        }
    }
    if (b > a) {
        return true;
    }
    return false;
}
--------------------------------
int CountSubStr(string s, int n) {
    int count = 0;
    for (int i = 0; i < n - 2;) {
        if (s[i] == '0' && s[i + 1] == '1' && s[i + 2] == '0') {
            count++;
            i += 3;
        } else if (s[i] == '1' && s[i + 1] == '0' && s[i + 2] == '1') {
            count++;
            i += 3;
        } else {
            i++;
        }
    }
    return count;
}
--------------------------------
int PrefixOccurrences(string s) {
    char c = s[0];
    int countC = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == c) {
            countC++;
        }
    }
    return countC;
}
--------------------------------
bool IsValid(string s, int len) {
 for (int i = 1; i < len; i++) {
   if (s[i] == s[i - 1]) {
     return false;
   }
 }
 return true;
}
--------------------------------
int Count(string s, int k) {
    int n = s.length();
    int d = 0;
    int count = 0;
    for (int i = 0; i < n; i++) {
        d += s[i];
    }
    if (d % k == 0) {
        count += 1;
    }
    for (int i = k; i < n; i++) {
        int prev = s[i - k];
        d -= prev;
        d += s[i];
        if (d % k == 0) {
            count += 1;
        }
    }
    return count;
}
--------------------------------
int FindSubstringCount(string s) {
    int result = 0;
    int n = s.length();
    int i = 0;
    while (i < n - 1) {
        if (s[i] + 1 == s[i + 1]) {
            result++;
            while (i < n - 1 && s[i] + 1 == s[i + 1]) {
                i++;
            }
        }
        i++;
    }
    return result;
}
--------------------------------
bool Find(string s1, string s2) {
    int len1 = s1.length(), len2 = s2.length();
    if (len1!= len2) {
        return false;
    }
    int d[len1];
    d[0] = s2[0] - s1[0];
    for (int i = 1; i < len1; i++) {
        if (s1[i] > s2[i]) {
            return false;
        } else {
            d[i] = s2[i] - s1[i];
        }
    }
    for (int i = 0; i < len1 - 1; i++) {
        if (d[i] < d[i + 1]) {
            return false;
        }
    }
    return true;
}
--------------------------------
bool IsInGivenBase(string s, int bas) {
    if (bas > 16) {
        return false;
    } else if (bas <= 10) {
        for (int i = 0; i < s.length(); i++) {
            if (!(s[i] >= '0' && s[i] < '0' + bas)) {
                return false;
            }
        }
    } else {
        for (int i = 0; i < s.length(); i++) {
            if (!((s[i] >= '0' && s[i] < '0' + bas) || (s[i] >= 'A' && s[i] < 'A' + bas - 10))) {
                return false;
            }
        }
    }
    return true;
}
--------------------------------
int CountNonEmptySubstr(string s) {
    int n = s.length();
    return n * (n + 1) / 2;
}
--------------------------------
int EvenDecimalValue(string s, int n) {
    int result = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            int decimalValue = 0;
            int powerOf2 = 1;
            for (int k = i; k <= j; k++) {
                decimalValue += (s[k] - '0') * powerOf2;
                powerOf2 *= 2;
            }
            if (decimalValue % 2 == 0) {
                result++;
            }
        }
    }
    return result;
}
--------------------------------
int Calculate(string s) {
    int ans = 6;
    for (int i = 0; i < 10; ++i) {
        for (int j = 0; j < 10; ++j) {
            for (int k = 0; k < 10; ++k) {
                for (int l = 0; l < 10; ++l) {
                    for (int m = 0; m < 10; ++m) {
                        for (int n = 0; n < 10; ++n) {
                            if (i + j + k == l + m + n) {
                                int c = 0;
                                if (i!= s[0] - '0') {
                                    c++;
                                }
                                if (j!= s[1] - '0') {
                                    c++;
                                }
                                if (k!= s[2] - '0') {
                                    c++;
                                }
                                if (l!= s[3] - '0') {
                                    c++;
                                }
                                if (m!= s[4] - '0') {
                                    c++;
                                }
                                if (n!= s[5] - '0') {
                                    c++;
                                }
                                if (c < ans) {
                                    ans = c;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return ans;
}
--------------------------------
int XorZero(string s) {
    int oneCount = 0, zeroCount = 0;
    int n = s.length();
    for (int i = 0; i < n; i++) {
        if (s[i] == '1') {
            oneCount++;
        } else {
            zeroCount++;
        }
    }
    if (oneCount % 2 == 0) {
        return zeroCount;
    }
    return oneCount;
}
--------------------------------
string EvenLength(string n) {
    string res = n;
    for (int j = n.length() - 1; j >= 0; --j) {
        res += n.charAt(j);
    }
    return res;
}
--------------------------------
int CountSubstringWithEqualEnds(string s) {
    int result = 0;
    int n = s.length();
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            if (s[i] == s[j]) {
                result++;
            }
        }
    }
    return result;
}
--------------------------------
double NormalSlope(double a, double b, double x1, double y1) {
    double g = a / 2;
    double f = b / 2;
    if (g - x1 == 0) {
        return -1;
    }
    double slope = (f - y1) / (g - x1);
    if (slope == 0) {
        return -2;
    }
    return slope;
}
--------------------------------
bool Orthogonality(int x1, int y1, int x2, int y2, int r1, int r2) {
    int dsquare = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
    if (dsquare == r1 * r1 + r2 * r2) {
        return true;
    } else {
        return false;
    }
}
--------------------------------
double FindAreaShaded(double a) {
    double sqArea = a * a;
    double semiCircleArea = 3.14 * (a * a) / 8;
    double shadedArea = 4 * semiCircleArea - sqArea;
    return shadedArea;
}
--------------------------------
int Factorial(int a, int b) {
    int res = 1;
    for (int i = 1; i <= a + b; i++) {
        res = res * i;
    }
    for (int i = 1; i <= a; i++) {
        res = res / i;
    }
    for (int i = 1; i <= b; i++) {
        res = res / i;
    }
    return res;
}
--------------------------------
int FactorTree(int n) {
    int height = 0;
    while (n > 1) {
        bool flag = false;
        for (int i = 2; i <= sqrt(n); i++) {
            if (n % i == 0) {
                n = n / i;
                flag = true;
                break;
            }
        }
        height++;
        if (!flag) {
            break;
        }
    }
    return height;
}
--------------------------------
string FindIfPossible(int n, int s, int x) {
    if (s >= x && s % 2 == x % 2) {
        if (n >= 3) {
            return "Yes";
        }
        if (n == 1) {
            if (s == x) {
                return "Yes";
            } else {
                return "No";
            }
        }
        if (n == 2) {
            int c = (s - x) / 2;
            int a = c;
            int b = c;
            a = a + x;
            if ((a ^ b) == x) {
                return "Yes";
            } else {
                return "No";
            }
        }
    }
    return "No";
}
--------------------------------
int MaximumTripletXor(int a, int b, int c) {
    int ans = 0;
    for (int i = 30; i >= 0; i--) {
        int cur = 1 << i;
        if (a >= cur) {
            ans += cur;
            a -= cur;
        } else if (b >= cur) {
            ans += cur;
            b -= cur;
        } else if (c >= cur) {
            ans += cur;
            c -= cur;
        }
    }
    return ans;
}
--------------------------------
int ItemType(int n) {
    int count = 0;
    int day = 1;
    while (count + day * (day + 1) / 2 < n) {
        count += day * (day + 1) / 2;
        day++;
    }
    for (int type = day; type > 0; type--) {
        count += type;
        if (count >= n) {
            return type;
        }
    }
    return 0;
}
--------------------------------
int MaxGcdInRange(int l, int r) {
    int ans = 1;
    for (int z = r; z >= 1; z--) {
        if (r / z - (l - 1) / z > 1) {
            ans = z;
            break;
        }
    }
    return ans;
}
--------------------------------
int SumOfDigits(int n) {
    int sum = 0;
    while (n!= 0) {
        sum += n % 10;
        n = n / 10;
    }
    return sum;
}
--------------------------------
bool IsRepUnitNum(int n, int b) {
    int length = 0;
    int countOne = 0;
    while (n!= 0) {
        int r = n % b;
        length++;
        if (r == 1) {
            countOne++;
        }
        n = n / b;
    }
    return countOne >= 3 && countOne == length;
}
--------------------------------
bool IsStraightLineNum(int n) {
    if (n <= 99) {
        return false;
    }
    string s = to_string(n);
    int d = s[1] - s[0];
    for (int i = 2; i < s.length(); i++) {
        if (s[i] - s[i - 1]!= d) {
            return false;
        }
    }
    return true;
}
--------------------------------
int GetCount(int d, int n) {
    int no = n / d;
    int result = no;
    for (int p = 2; p * p <= no; ++p) {
        if (no % p == 0) {
            while (no % p == 0) {
                no /= p;
            }
            result -= result / p;
        }
    }
    if (no > 1) {
        result -= result / no;
    }
    return result;
}
--------------------------------
bool IsEvenParity(int x) {
    int parity = 0;
    while (x!= 0) {
        if (x % 2 == 1) {
            parity++;
        }
        x = x >> 1;
    }
    if (parity % 2 == 0) {
        return true;
    } else {
        return false;
    }
}
--------------------------------
int IsPerfect(int n) {
    int sum = 1;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            if (i * i!= n) {
                sum = sum + i + n / i;
            } else {
                sum = sum + i;
            }
        }
    }
    if (sum == n && n!= 1) {
        return n;
    }
    return 0;
}
--------------------------------
int LogAToBaseB(int a, int b) {
    return a > b - 1? 1 + LogAToBaseB(a / b, b) : 0;
}
--------------------------------
int UsingBinarySearch(int start, int end, int n, int s) {
    if (start >= end) {
        return start;
    }
    int mid = start + (end - start) / 2;
    int totalSum = n * (n + 1) / 2;
    int midSum = mid * (mid + 1) / 2;
    if (totalSum - midSum <= s) {
        return UsingBinarySearch(start, mid, n, s);
    }
    return UsingBinarySearch(mid + 1, end, n, s);
}
--------------------------------
string MinInt(string s) {
    char s1[s.size()];
    for (int i = 0; i < s.size(); i++) {
        if (s[i] >= '5') {
            s1[i] = (char)('9' - s[i] + '0');
        }
        else {
            s1[i] = s[i];
        }
    }
    if (s1[0] == '0') {
        s1[0] = '9';
    }
    return string(s1);
}
--------------------------------
int CountTriplets(int a, int b, int c) {
    int ans = 0;
    for (int i = 1; i <= a; i++) {
        for (int j = 1; j <= b; j++) {
            for (int k = 1; k <= c; k++) {
                if (i * k > j * j) {
                    ans++;
                }
            }
        }
    }
    return ans;
}
--------------------------------
bool TopsyTurvy(string s) {
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == '2' || s[i] == '4' || s[i] == '5' || s[i] == '6' || s[i] == '7' || s[i] == '9') {
            return false;
        }
    }
    return true;
}
--------------------------------
int SumOfLastDig(int n, int m) {
    int sum = 0;
    int k = n / m;
    int arr[10] = {0};
    for (int i = 0; i < 10; i++) {
        arr[i] = (m * (i + 1)) % 10;
        sum += arr[i];
    }
    int rem = k % 10;
    int ans = k / 10 * sum;
    for (int i = 0; i < rem; i++) {
        ans += arr[i];
    }
    return ans;
}
--------------------------------
int TotalPay(int total_items, int price_of_one_item, int n, int m) {
    int free_items = 0, actual = 0;
    free_items = total_items / (n + m);
    actual = total_items - free_items;
    int amount = actual * price_of_one_item;
    return amount;
}
--------------------------------
int MinOperations(int x, int y, int p, int q) {
    if (y % x!= 0) {
        return -1;
    }
    int d = y / x;
    int a = 0;
    while (d % p == 0) {
        d /= p;
        a += 1;
    }
    int b = 0;
    while (d % q == 0) {
        d /= q;
        b += 1;
    }
    if (d!= 1) {
        return -1;
    }
    return a + b;
}
--------------------------------
bool IsMersenne(int n) {
    while (n!= 0) {
        int r = n % 2;
        if (r == 0) {
            return false;
        }
        n /= 2;
    }
    return true;
}
--------------------------------
int FindThirdDigit(int n) {
    if (n < 3) {
        return 0;
    }
    return (n & 1)!= 0? 1 : 6;
}
--------------------------------
bool IsOddLength(int num) {
    int count = 0;
    while (num > 0) {
        num /= 10;
        count++;
    }
    if (count % 2!= 0) {
        return true;
    }
    return false;
}
--------------------------------
bool CheckIsPossible(int l, int r, int k) {
    int count = 0;
    for (int i = l; i <= r; i++) {
        if (i % k == 0) {
            count++;
        }
    }
    return count > 1;
}
--------------------------------
int Bytes(int kilobytes) {
    int b = kilobytes * 1024;
    return b;
}
--------------------------------
int OctahedralNum(int n) {
    return n * (2 * n * n + 1) / 3;
}
--------------------------------
string CheckEqual(string s) {
    for (int i = 0; i < s.length(); i++) {
        if (s[i]!= '1' && s[i]!= '0' && s[i]!= '8') {
            return "No";
        }
    }
    int start = 0, end = s.length() - 1;
    while (start < end) {
        if (s[start]!= s[end]) {
            return "No";
        }
        start++;
        end--;
    }
    return "Yes";
}
--------------------------------
bool IsUndulating(string n) {
    if (n.length() <= 2) {
        return false;
    }
    for (int i = 2; i < n.length(); i++) {
        if (n[i - 2]!= n[i]) {
            return false;
        }
    }
    return true;
}
--------------------------------
int FirstDigit(int n) {
    while (n >= 10) {
        n /= 10;
    }
    return n;
}
--------------------------------
int CountDigit(int n) {
    if (n == 0) {
        return 0;
    }
    return 1 + CountDigit(n / 10);
}
--------------------------------
bool IsDivisibleBy5(string s) {
    int n = s.size();
    return (s[n - 1] - '0') == 0 || (s[n - 1] - '0') == 5;
}
--------------------------------
int Inv(int a, int m) {
    int m0 = m;
    int x0 = 0, x1 = 1;
    if (m == 1) {
        return 0;
    }
    while (a > 1) {
        int q = a / m;
        int t = m;
        m = a % m;
        a = t;
        t = x0;
        x0 = x1 - q * x0;
        x1 = t;
    }
    if (x1 < 0) {
        x1 += m0;
    }
    return x1;
}
--------------------------------
bool OnlyFirstAndLastAreSet(int n) {
    if (n == 1) {
        return true;
    }
    if (n == 2) {
        return false;
    }
    return ((n - 1) & (n - 2)) == 0;
}
--------------------------------
int Divide(int dividend, int divisor) {
    int sign = ((dividend < 0) ^ (divisor < 0))? -1 : 1;
    dividend = abs(dividend);
    divisor = abs(divisor);
    int quotient = 0;
    long temp = 0;
    for (int i = 31; i >= 0; --i) {
        if (temp + ((long)divisor << i) <= dividend) {
            temp += (long)divisor << i;
            quotient |= 1 << i;
        }
    }
    if (sign == -1) {
        quotient = -quotient;
    }
    return quotient;
}
--------------------------------
char FindProfession(int level, int pos) {
    if (level == 1) {
        return 'e';
    }
    if (FindProfession(level - 1, (pos + 1) / 2) == 'd') {
        return pos % 2!= 0? 'd' : 'e';
    }
    return pos % 2!= 0? 'e' : 'd';
}
--------------------------------
bool HasCloseElements(vector<double> numbers, double threshold) {
    for (int i = 0; i < numbers.size(); i++) {
        for (int j = i + 1; j < numbers.size(); j++) {
            double distance = abs(numbers[i] - numbers[j]);
            if (distance < threshold) return true;
        }
    }
    return false;
}
--------------------------------
double TruncateNumber(double number) {
    return number % 1.0;
}
--------------------------------
bool BelowZero(vector<int> operations) {
    int balance = 0;
    for (auto op : operations) {
        balance += op;
        if (balance < 0) {
            return true;
        }
    }
    return false;
}
--------------------------------
double MeanAbsoluteDeviation(vector<double> numbers) {
    double sumNum = 0;
    for (auto num : numbers) {
        sumNum += num;
    }
    double mean = sumNum / numbers.size();
    double sumAbsDiff = 0;
    for (auto num : numbers) {
        sumAbsDiff += abs(num - mean);
    }
    return sumAbsDiff / numbers.size();
}
--------------------------------
vector<int> Intersperse(vector<int> numbers, int delimiter) {
    vector<int> result;
    if (numbers.empty()) {
        return result;
    }
    for (int i = 0; i < numbers.size() - 1; i++) {
        result.push_back(numbers[i]);
        result.push_back(delimiter);
    }
    result.push_back(numbers[numbers.size() - 1]);
    return result;
}
--------------------------------
vector<int> SumProduct(vector<int> numbers) {
    int sumValue = 0;
    int prodValue = 1;
    for (int n : numbers) {
        sumValue += n;
        prodValue *= n;
    }
    return {sumValue, prodValue};
}
--------------------------------
vector<string> AllPrefixes(string s) {
    vector<string> result;
    for (int i = 1; i <= s.length(); i++) {
        result.push_back(s.substr(0, i));
    }
    return result;
}
--------------------------------
vector<int> ParseMusic(string music_string) {
    vector<int> result;
    string current;
    for (int i = 0; i <= music_string.length(); i++) {
        if (i == music_string.length() || music_string.at(i) =='') {
            if (current == "o") {
                result.push_back(4);
            }
            if (current == "o|") {
                result.push_back(2);
            }
            if (current == ".|") {
                result.push_back(1);
            }
            current.clear();
        } else {
            current.push_back(music_string.at(i));
        }
    }
    return result;
}
--------------------------------
int Strlen(string s) {
    return s.length();
}
--------------------------------
vector<int> Factorize(int n) {
    vector<int> factors;
    for (int i = 2; i <= n; i++) {
        if (n % i == 0) {
            n /= i;
            factors.push_back(i);
            i--;
        }
    }
    return factors;
}
--------------------------------
string Concatenate(vector<string> strings) {
    string result = "";
    for (auto s : strings) {
        result += s;
    }
    return result;
}
--------------------------------
vector<double> GetPositive(vector<double> l) {
    vector<double> result;
    for (int i = 0; i < l.size(); i++) {
        if (l[i] > 0) {
            result.push_back(l[i]);
        }
    }
    return result;
}
--------------------------------
vector<double> SortEven(vector<double> l) {
    vector<double> evens;
    for (int i = 0; i < l.size(); i += 2) {
        evens.push_back(l[i]);
    }
    sort(evens.begin(), evens.end());
    vector<double> result;
    for (int i = 0; i < l.size(); i++) {
        if (i % 2 == 0) {
            result.push_back(evens[i / 2]);
        }
        if (i % 2 == 1) {
            result.push_back(l[i]);
        }
    }
    return result;
}
--------------------------------
string DecodeCyclic(string s) {
    string output = "";
    int i = 0;
    while (i <= s.length() - 3) {
        string x = s.substr(i + 2, 2) + s.substr(i, 2);
        output += x;
        i += 3;
    }
    return output + s.substr(i);
}
--------------------------------
int CarRaceCollision(int n) {
    return (int)pow(n, 2);
}
--------------------------------
vector<int> IncrList(vector<int> l) {
    vector<int> result;
    for (int i : l) {
        result.push_back(i + 1);
    }
    return result;
}
--------------------------------
bool PairsSumToZero(vector<int> l) {
    for (int i = 0; i < l.size(); i++) {
        for (int j = i + 1; j < l.size(); j++) {
            if (l[i] + l[j] == 0) {
                return true;
            }
        }
    }
    return false;
}
--------------------------------
string ChangeBase(int x, int b) {
    string ret;
    while (x > 0) {
        ret = to_string(x % b) + ret;
        x /= b;
    }
    return ret;
}
--------------------------------
double Median(vector<double> l) {
    sort(l.begin(), l.end());
    if (l.size() % 2 == 1) {
        return l[l.size() / 2];
    }
    return (l[l.size() / 2 - 1] + l[l.size() / 2]) / 2.0;
}
--------------------------------
string DecodeShift(string s) {
    string result;
    for (char ch : s) {
        char w = (char)((ch + 21 - 'a') % 26 + 'a');
        result += w;
    }
    return result;
}
--------------------------------
bool BelowThreshold(vector<int> l, int t) {
    for (int n : l) {
        if (n >= t) {
            return false;
        }
    }
    return true;
}
--------------------------------
bool CorrectBracketing(string brackets) {
    int depth = 0;
    for (char b : brackets) {
        if (b == '<') {
            depth += 1;
        }
        if (b == '>') {
            depth -= 1;
        }
        if (depth < 0) {
            return false;
        }
    }
    return depth == 0;
}
--------------------------------
bool Monotonic(vector<double> l) {
    int incr = 0;
    int decr = 0;
    for (int i = 1; i < l.size(); i++) {
        if (l[i] > l[i - 1]) {
            incr = 1;
        }
        if (l[i] < l[i - 1]) {
            decr = 1;
        }
    }
    return incr + decr!= 2;
}
--------------------------------
vector<double> Derivative(vector<double> xs) {
    vector<double> result;
    for (int i = 1; i < xs.size(); i++) {
        result.push_back(i * xs.at(i));
    }
    return result;
}
--------------------------------
int VowelsCount(string s) {
    string vowels = "aeiouAEIOU";
    int count = 0;
    for (char ch : s) {
        if (vowels.find(ch)!= string::npos) {
            count += 1;
        }
    }
    if (s[s.length() - 1] == 'y' || s[s.length() - 1] == 'Y') {
        count += 1;
    }
    return count;
}
--------------------------------
int DigitSum(string s) {
    int sum = 0;
    for (char c : s) {
        if (isupper(c)) {
            sum += c;
        }
    }
    return sum;
}
--------------------------------
int FruitDistribution(string s, int n) {
    string num1 = "";
    string num2 = "";
    bool flag = false;
    for (int i = 0; i < s.length(); i++) {
        if (isdigit(s[i])) {
            if (!flag) {
                num1 += s[i];
            }
            if (flag) {
                num2 += s[i];
            }
        } else if (!flag && num1.length() > 0) {
            flag = true;
        }
    }
    return n - stoi(num1) - stoi(num2);
}
--------------------------------
vector<int> Pluck(vector<int> arr) {
    vector<int> result;
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] % 2 == 0) {
            if (result.empty()) {
                result.push_back(arr[i]);
                result.push_back(i);
            } else if (arr[i] < result[0]) {
                result[0] = arr[i];
                result[1] = i;
            }
        }
    }
    return result;
}
--------------------------------
vector<int> StrangeSortList(vector<int> lst) {
    vector<int> res;
    sort(lst.begin(), lst.end());
    int l = 0;
    int r = lst.size() - 1;
    while (l < r) {
        res.push_back(lst[l]);
        l += 1;
        res.push_back(lst[r]);
        r -= 1;
    }
    if (l == r) {
        res.push_back(lst[l]);
    }
    return res;
}
--------------------------------
double TriangleArea(double a, double b, double c) {
    if (a + b <= c || a + c <= b || b + c <= a) {
        return -1;
    }
    double s = (a + b + c) / 2;
    return sqrt(s * (s - a) * (s - b) * (s - c));
}
--------------------------------
bool WillItFly(vector<int> q, int w) {
    int sum = 0;
    for (int i = 0; i < q.size(); i++) {
        if (q[i]!= q[q.size() - i - 1]) {
            return false;
        }
        sum += q[i];
    }
    return sum <= w;
}
--------------------------------
bool IsCube(int a) {
    a = abs(a);
    int i = round(pow(a, 1.0 / 3));
    return pow(i, 3) == a;
}
--------------------------------
int HexKey(string num) {
    string key = "2357BD";
    int total = 0;
    for (char c : num) {
        if (key.find(c)!= string::npos) {
            total += 1;
        }
    }
    return total;
}
--------------------------------
string DecimalToBinary(int dec) {
    string ans = "";
    if (dec!= 0) {
        while (dec > 0) {
            ans.insert(0, dec % 2);
            dec /= 2;
        }
    } else {
        ans.append("0");
    }
    return "db" + ans + "db";
}
--------------------------------
bool PrimeLength(string s) {
    int l = s.length();
    if (l < 2) {
        return false;
    }
    for (int i = 2; i < l; i++) {
        if (l % i == 0) {
            return false;
        }
    }
    return true;
}
--------------------------------
int StartsOneEnds(int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    return (int)(18 * pow(10, n - 2));
}
--------------------------------
int Add(vector<int> lst) {
    int sum = 0;
    for (int i = 1; i < lst.size(); i += 2) {
        if (lst[i] % 2 == 0) {
            sum += lst[i];
        }
    }
    return sum;
}
--------------------------------
vector<vector<int> > GetRow(vector<vector<int> > lst, int x) {
    vector<vector<int> > coords;
    for (int i = 0; i < lst.size(); i++) {
        for (int j = lst[i].size() - 1; j >= 0; j--) {
            if (lst[i][j] == x) {
                coords.push_back({ i, j });
            }
        }
    }
    return coords;
}
--------------------------------
int NextSmallest(vector<int> lst) {
    sort(lst.begin(), lst.end());
    for (int i = 1; i < lst.size(); i++) {
        if (lst[i]!= lst[i - 1]) {
            return lst[i];
        }
    }
    return -1;
}
--------------------------------
bool AnyInt(double a, double b, double c) {
    if (round(a)!= a || round(b)!= b || round(c)!= c) {
        return false;
    }
    return a + b == c || a + c == b || b + c == a;
}
--------------------------------
vector<int> CountUpTo(int n) {
    vector<int> primes;
    for (int i = 2; i < n; i++) {
        bool isPrime = true;
        for (int j = 2; j < i; j++) {
            if (i % j == 0) {
                isPrime = false;
                break;
            }
        }
        if (isPrime) {
            primes.push_back(i);
        }
    }
    return primes;
}
--------------------------------
int ClosestInteger(string value) {
    double w = stod(value);
    return (int)round(w);
}
--------------------------------
vector<int> MakeAPile(int n) {
    vector<int> result;
    for (int i = 0; i < n; i++) {
        result.push_back(n + 2 * i);
    }
    return result;
}
--------------------------------
vector<string> WordsString(string s) {
    vector<string> words;
    string current;
    for (int i = 0; i < s.length(); i++) {
        if (s[i] =='' || s[i] == ',') {
            if (current.length() > 0) {
                words.push_back(current);
                current = "";
            }
        } else {
            current += s[i];
        }
    }
    if (current.length() > 0) {
        words.push_back(current);
    }
    return words;
}
--------------------------------
string RoundedAvg(int n, int m) {
    if (n > m) {
        return "-1";
    }
    int num = (m + n) / 2;
    string ret = "";
    while (num > 0) {
        ret = to_string(num % 2) + ret;
        num /= 2;
    }
    return ret;
}
--------------------------------
vector<int> UniqueDigits(vector<int> x) {
    vector<int> digits;
    for (int i : x) {
        bool isUnique = true;
        for (char c : to_string(i).c_str()) {
            if (c % 2 == 0) {
                isUnique = false;
                break;
            }
        }
        if (isUnique) {
            digits.push_back(i);
        }
    }
    sort(digits.begin(), digits.end());
    return digits;
}
--------------------------------
int CountNums(vector<int> arr) {
    int num = 0;
    for (int n : arr) {
        int neg = n < 0? -1 : 1;
        n = abs(n);
        vector<int> digits;
        for (char c : to_string(n).c_str()) {
            digits.push_back(c - '0');
        }
        digits[0] *= neg;
        int sum = 0;
        for (int d : digits) {
            sum += d;
        }
        if (sum > 0) {
            num += 1;
        }
    }
    return num;
}
--------------------------------
bool MoveOneBall(vector<int> arr) {
    if (arr.empty()) {
        return true;
    }
    int num = 0;
    for (int i = 1; i < arr.size(); i++) {
        if (arr[i] < arr[i - 1]) {
            num += 1;
        }
    }
    if (arr[arr.size() - 1] > arr[0]) {
        num += 1;
    }
    if (num < 2) {
        return true;
    }
    return false;
}
--------------------------------
string Exchange(vector<int> lst1, vector<int> lst2) {
    int odd = 0;
    int even = 0;
    for (int n : lst1) {
        if (n % 2 == 1) {
            odd += 1;
        }
    }
    for (int n : lst2) {
        if (n % 2 == 0) {
            even += 1;
        }
    }
    if (even >= odd) {
        return "YES";
    }
    return "NO";
}
--------------------------------
vector<string> OddCount(vector<string> lst) {
    vector<string> results;
    string originalStr = "the number of odd elements in the string i of the input.";
    for (string s : lst) {
        int sum = 0;
        for (char d : s.toCharArray()) {
            if (isdigit(d) && d % 2 == 1) {
                sum += 1;
            }
        }
        string result = "";
        for (char c : originalStr.toCharArray()) {
            if (c == 'i') {
                result += to_string(sum);
            } else {
                result += c;
            }
        }
        results.push_back(result);
    }
    return results;
}
--------------------------------
int MinSubArraySum(vector<int> nums) {
    int minSum = INT_MAX;
    int sum = 0;
    for (int num : nums) {
        sum += num;
        if (minSum > sum) {
            minSum = sum;
        }
        if (sum > 0) {
            sum = 0;
        }
    }
    return minSum;
}
--------------------------------
int MaxFill(vector<vector<int> > grid, int capacity) {
    int res = 0;
    for (auto well : grid) {
        int sum = 0;
        for (int n : well) {
            sum += n;
        }
        if (sum > 0) {
            res += (sum - 1) / capacity + 1;
        }
    }
    return res;
}
--------------------------------
vector<string> SelectWords(string s, int n) {
    string vowels = "aeiouAEIOU";
    string current = "";
    vector<string> result;
    int consonantNum = 0;
    for (int i = 0; i <= s.length(); i++) {
        if (i == s.length() || s[i] =='') {
            if (consonantNum == n) {
                result.push_back(current);
            }
            current = "";
            consonantNum = 0;
        } else {
            current += s[i];
            if (vowels.find(s[i]) == -1) {
                consonantNum += 1;
            }
        }
    }
    return result;
}
--------------------------------
int Solution(vector<int> lst) {
    int sum = 0;
    for (int i = 0; i < lst.size(); i += 2) {
        if ((lst[i] % 2) == 1) {
            sum += lst[i];
        }
    }
    return sum;
}
--------------------------------
int AddElements(vector<int> arr, int k) {
    int sum = 0;
    for (int i = 0; i < k; i++) {
        if (arr[i] >= -99 && arr[i] <= 99) {
            sum += arr[i];
        }
    }
    return sum;
}
--------------------------------
vector<int> GetOddCollatz(int n) {
    vector<int> oddCollatz;
    while (n!= 1) {
        if (n % 2 == 1) {
            oddCollatz.push_back(n);
            n = n * 3 + 1;
        } else {
            n /= 2;
        }
    }
    oddCollatz.push_back(1);
    sort(oddCollatz.begin(), oddCollatz.end());
    return oddCollatz;
}
--------------------------------
bool IsSorted(vector<int> lst) {
    for (int i = 1; i < lst.size(); i++) {
        if (lst[i] < lst[i - 1]) {
            return false;
        }
        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) {
            return false;
        }
    }
    return true;
}
--------------------------------
string Intersection(vector<int> interval1, vector<int> interval2) {
    int inter1 = max(interval1[0], interval2[0]);
    int inter2 = min(interval1[1], interval2[1]);
    int l = inter2 - inter1;
    if (l < 2) {
        return "NO";
    }
    for (int i = 2; i < l; i++) {
        if (l % i == 0) {
            return "NO";
        }
    }
    return "YES";
}
--------------------------------
int ProdSigns(vector<int> arr) {
    if (arr.empty()) {
        return -32768;
    }
    int sum = 0;
    int prods = 1;
    for (int i : arr) {
        sum += abs(i);
        if (i == 0) {
            prods = 0;
        }
        if (i < 0) {
            prods = -prods;
        }
    }
    return sum * prods;
}
--------------------------------
vector<int> MinPath(vector<vector<int> > grid, int k) {
    int n = grid.size();
    int minNum = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                vector<int> tmp;
                if (i!= 0) {
                    tmp.push_back(grid[i - 1][j]);
                }
                if (j!= 0) {
                    tmp.push_back(grid[i][j - 1]);
                }
                if (i!= n - 1) {
                    tmp.push_back(grid[i + 1][j]);
                }
                if (j!= n - 1) {
                    tmp.push_back(grid[i][j + 1]);
                }
                minNum = *min_element(tmp.begin(), tmp.end());
            }
        }
    }
    vector<int> ans;
    for (int i = 0; i < k; i++) {
        if (i % 2 == 0) {
            ans.push_back(1);
        } else {
            ans.push_back(minNum);
        }
    }
    return ans;
}
--------------------------------
int Digits(int n) {
    int prod = 0;
    for (char digit : std::to_string(n).c_str()) {
        if (digit % 2 == 1) {
            if (prod == 0) {
                prod = 1;
            }
            prod *= digit - '0';
        }
    }
    return prod;
}
--------------------------------
bool IsNested(string s) {
    int count = 0;
    int maxCount = 0;
    for (char ch : s) {
        if (ch == '[') {
            count += 1;
        }
        if (ch == ']') {
            count -= 1;
        }
        if (count < 0) {
            count = 0;
        }
        if (count > maxCount) {
            maxCount = count;
        }
        if (count <= maxCount - 2) {
            return true;
        }
    }
    return false;
}
--------------------------------
int SumSquares(vector<double> lst) {
    int sum = 0;
    for (double i : lst) {
        sum += ceil(i) * ceil(i);
    }
    return sum;
}
--------------------------------
int CanArrange(vector<int> arr) {
    int index = -1;
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] <= i) {
            index = i;
        }
    }
    return index;
}
--------------------------------
vector<int> LargestSmallestIntegers(vector<int> lst) {
    int maxNeg = 0, minPos = 0;
    for (int n : lst) {
        if (n < 0 && (maxNeg == 0 || n > maxNeg)) {
            maxNeg = n;
        }
        if (n > 0 && (minPos == 0 || n < minPos)) {
            minPos = n;
        }
    }
    return {maxNeg, minPos};
}
--------------------------------
string FixSpaces(string text) {
    string res;
    int spaceLen = 0;
    for (int i = 0; i <= text.length(); i++) {
        if (i == text.length() || text[i]!='') {
            if (spaceLen == 1) {
                res += '_';
            }
            if (spaceLen == 2) {
                res += "__";
            }
            if (spaceLen > 2) {
                res += '-';
            }
            spaceLen = 0;
            if (i!= text.length()) {
                res += text[i];
            }
        } else {
            spaceLen += 1;
        }
    }
    return res;
}
--------------------------------
string FileNameCheck(string file_name) {
    int digit_num = 0, dot_num = 0;
    if (file_name.length() < 5 ||!isalpha(file_name[0])) {
        return "No";
    }
    string suffix = file_name.substr(file_name.length() - 4);
    if (!suffix.compare(".txt") &&!suffix.compare(".exe") &&!suffix.compare(".dll")) {
        return "No";
    }
    for (char c : file_name) {
        if (isdigit(c)) {
            digit_num += 1;
        }
        if (c == '.') {
            dot_num += 1;
        }
    }
    if (digit_num > 3 || dot_num!= 1) {
        return "No";
    }
    return "Yes";
}
--------------------------------
int SumSquares(vector<int> lst) {
    int sum = 0;
    for (int i = 0; i < lst.size(); i++) {
        if (i % 3 == 0) {
            sum += lst[i] * lst[i];
        } else if (i % 4 == 0) {
            sum += lst[i] * lst[i] * lst[i];
        } else {
            sum += lst[i];
        }
    }
    return sum;
}
--------------------------------
string WordsInSentence(string sentence) {
    string result = "";
    string current = "";
    for (int i = 0; i <= sentence.length(); i++) {
        if (i == sentence.length() || sentence[i] =='') {
            bool isPrime = true;
            int l = current.length();
            if (l < 2) {
                isPrime = false;
            }
            for (int j = 2; j < l; j++) {
                if (l % j == 0) {
                    isPrime = false;
                    break;
                }
            }
            if (isPrime) {
                result += current + " ";
            }
            current = "";
        } else {
            current += sentence[i];
        }
    }
    if (result.length() > 0) {
        result.erase(result.length() - 1);
    }
    return result;
}
--------------------------------
bool Simplify(string x, string n) {
    int a = 0, b = 0, c = 0, d = 0;
    for (int i = 0; i < x.length(); i++) {
        if (x[i] == '/') {
            a = stoi(x.substr(0, i));
            b = stoi(x.substr(i + 1));
        }
    }
    for (int i = 0; i < n.length(); i++) {
        if (n[i] == '/') {
            c = stoi(n.substr(0, i));
            d = stoi(n.substr(i + 1));
        }
    }
    return (a * c) % (b * d) == 0;
}
--------------------------------
int SpecialFilter(vector<int> nums) {
    int count = 0;
    for (int num : nums) {
        if (num > 10) {
            string w = to_string(num);
            if (w[0] % 2 == 1 && w[w.size() - 1] % 2 == 1) {
                count += 1;
            }
        }
    }
    return count;
}
--------------------------------
int GetMatrixTriples(int n) {
    vector<int> arr;
    for (int i = 1; i <= n; i++) {
        arr.push_back(i * i - i + 1);
    }
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            for (int k = j + 1; k < n; k++) {
                if ((arr[i] + arr[j] + arr[k]) % 3 == 0) {
                    count += 1;
                }
            }
        }
    }
    return count;
}
--------------------------------
int DoubleTheDifference(vector<double> lst) {
    int sum = 0;
    for (double d : lst) {
        int num = (int)round(d);
        if (d == num) {
            if (num > 0 && num % 2 == 1) {
                sum += num * num;
            }
        }
    }
    return sum;
}
--------------------------------
vector<int> Compare(vector<int> game, vector<int> guess) {
    vector<int> result;
    for (int i = 0; i < game.size(); i++) {
        result.push_back(abs(game[i] - guess[i]));
    }
    return result;
}
--------------------------------
string StrongestExtension(string class_name, vector<string> extensions) {
    string strongest = "";
    int max = INT_MIN;
    for (auto extension : extensions) {
        int strength = 0;
        for (auto chr : extension) {
            if (isupper(chr)) {
                strength += 1;
            }
            if (islower(chr)) {
                strength -= 1;
            }
        }
        if (strength > max) {
            max = strength;
            strongest = extension;
        }
    }
    return class_name + "." + strongest;
}
--------------------------------
string IntToMiniRoman(int number) {
    vector<int> num = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    vector<string> sym = {"m", "cm", "d", "cd", "c", "xc", "l", "xl", "x", "ix", "v", "iv", "i"};
    int pos = 0;
    string res = "";
    while (number > 0) {
        while (number >= num[pos]) {
            res += sym[pos];
            number -= num[pos];
        }
        if (number > 0) {
            pos += 1;
        }
    }
    return res;
}
--------------------------------
vector<int> Eat(int number, int need, int remaining) {
    return need > remaining? vector<int>{number + remaining, 0} : vector<int>{number + need, remaining - need};
}
--------------------------------
int DoAlgebra(vector<string> ops, vector<int> operands) {
    vector<int> nums = operands;
    vector<string> currentOps = ops;
    int i = currentOps.size() - 1;
    while (i >= 0) {
        if (currentOps[i] == "**") {
            nums[i] = pow(nums[i], nums[i + 1]);
            nums.erase(nums.begin() + i + 1);
            currentOps.erase(currentOps.begin() + i);
        }
        i--;
    }
    i = 0;
    while (i < currentOps.size()) {
        if (currentOps[i] == "*") {
            nums[i] = nums[i] * nums[i + 1];
            nums.erase(nums.begin() + i + 1);
            currentOps.erase(currentOps.begin() + i);
        } else if (currentOps[i] == "//") {
            nums[i] = nums[i] / nums[i + 1];
            nums.erase(nums.begin() + i + 1);
            currentOps.erase(currentOps.begin() + i);
        } else {
            i++;
        }
    }
    i = 0;
    while (i < currentOps.size()) {
        if (currentOps[i] == "+") {
            nums[i] = nums[i] + nums[i + 1];
            nums.erase(nums.begin() + i + 1);
            currentOps.erase(currentOps.begin() + i);
        } else if (currentOps[i] == "-") {
            nums[i] = nums[i] - nums[i + 1];
            nums.erase(nums.begin() + i + 1);
            currentOps.erase(currentOps.begin() + i);
        } else {
            i++;
        }
    }
    return nums[0];
}
--------------------------------
vector<int> GenerateIntegers(int a, int b) {
    int lower = max(2, min(a, b));
    int upper = min(8, max(a, b));
    vector<int> result;
    for (int i = lower; i <= upper; i += 2) {
        result.push_back(i);
    }
    return result;
}
--------------------------------
bool IsStepNum(int n) {
    int prevDigit = -1;
    while (n > 0) {
        int curDigit = n % 10;
        if (prevDigit!= -1) {
            if (abs(curDigit - prevDigit)!= 1) {
                return false;
            }
        }
        n /= 10;
        prevDigit = curDigit;
    }
    return true;
}
--------------------------------
int NumOfWays(int n, int k) {
    int p = 1;
    if (k % 2!= 0) {
        p = -1;
    }
    return (int)(pow(n - 1, k) + p * (n - 1)) / n;
}
--------------------------------
vector<int> FindDivisors(int n) {
    vector<int> v;
    for (int i = 1; i <= sqrt(n); i++) {
        if (n % i == 0) {
            if (n / i == i) {
                v.push_back(i);
            } else {
                v.push_back(i);
                v.push_back(n / i);
            }
        }
    }
    return v;
}
--------------------------------
int EggDrop(int n, int k) {
    if (k == 1 || k == 0) {
        return k;
    }
    if (n == 1) {
        return k;
    }
    int min = INT_MAX;
    int x, res;
    for (x = 1; x <= k; x++) {
        res = max(EggDrop(n - 1, x - 1), EggDrop(n, k - x));
        if (res < min) {
            min = res;
        }
    }
    return min + 1;
}
--------------------------------
bool IsPowerOfTwo(int n) {
    if (n == 0) {
        return false;
    }
    return ceil(log(n) / log(2)) == floor(log(n) / log(2));
}
--------------------------------
string ShortestPalindrome(string s) {
    int n = s.length();
    vector<string> v;
    for (int i = 0; i < n; i++) {
        int l = i;
        int r = i;
        string ans1 = "";
        string ans2 = "";
        while (l >= 0 && r < n && s[l] == s[r]) {
            ans1 += s[l];
            l--;
            r++;
        }
        l = i - 1;
        r = i;
        while (l >= 0 && r < n && s[l] == s[r]) {
            ans2 += s[l];
            l--;
            r++;
        }
        v.push_back(ans1);
        v.push_back(ans2);
    }
    string ans = v[0];
    for (int i = 0; i < v.size(); i++) {
        if (v[i]!= "") {
            if (ans[0] >= v[i][0]) {
                ans = v[i];
            }
        }
    }
    return ans;
}
--------------------------------
int MinimumAdjacentDifference(vector<int> a, int n, int k) {
    int minDiff = INT_MAX;
    for (int i = 0; i <= k; i++) {
        int maxDiff = INT_MIN;
        for (int j = 0; j < n - k - 1; j++) {
            for (int p = i; p <= i + j; p++) {
                maxDiff = max(maxDiff, a[p + 1] - a[p]);
            }
        }
        minDiff = min(minDiff, maxDiff);
    }
    return minDiff;
}
--------------------------------
int Cal(vector<int> a, int mid) {
    int chocolate = 0;
    for (int i : a) {
        if (i >= mid) {
            chocolate += i - mid;
        }
    }
    return chocolate;
}
--------------------------------
bool Check(int v, vector<int> a, int m) {
    int tec = 0, ans = 0;
    vector<int> b(a.size() + 3, 0);
    for (int i = 0; i < a.size(); i++) {
        tec -= b[i];
        if (a[i] + tec < v) {
            int mov = v - a[i] - tec;
            ans += mov;
            tec += mov;
            b[i + 2] = mov;
        }
    }
    return ans <= m;
}
--------------------------------
int LargestNum(vector<int> arr) {
    int res = 0;
    sort(arr.begin(), arr.end());
    int l = 0, r = arr.size() - 1;
    while (l < r) {
        int sum = arr[l] + arr[r];
        if (sum == 0) {
            res = max(res, max(arr[l], arr[r]));
            return res;
        } else if (sum < 0) {
            l++;
        } else {
            r--;
        }
    }
    return res;
}
--------------------------------
int BinarySearch(vector<int> p, int n) {
    int i = 0;
    int j = p.size() - 1;
    int index = -1;
    while (i <= j) {
        int mid = i + (j - i) / 2;
        if (p[mid] >= n) {
            index = mid;
            j = mid - 1;
        } else {
            i = mid + 1;
        }
    }
    return index;
}
--------------------------------
int FindMinLength(vector<int> arr) {
    int index = arr.size() - 1;
    while (index > 0 && arr[index] >= arr[index - 1]) {
        index--;
    }
    return index;
}
--------------------------------
int MinDigits(int n, int k) {
    int digitsNum = (int)floor(log(n) + 1);
    int tempSum = 0;
    int temp = digitsNum;
    int result = 0;
    int x, v;
    int sum = 0;
    int num2 = n;
    while (num2!= 0) {
        sum += num2 % 10;
        num2 /= 10;
    }
    if (sum <= k) {
        x = 0;
    } else {
        while (temp > 0) {
            v = n / (int)pow(10, temp - 1);
            tempSum += v % 10;
            if (tempSum >= k) {
                v /= 10;
                v++;
                result = v * (int)pow(10, temp);
                break;
            }
            temp--;
        }
        x = result - n;
        return x;
    }
    return -1;
}
--------------------------------
int CheckForPerfectSquare(vector<int> arr, int i, int j) {
    int mid, sum = 0;
    for (int m = i; m <= j; m++) {
        sum += arr[m];
    }
    int low = 0, high = sum / 2;
    while (low <= high) {
        mid = low + (high - low) / 2;
        if (mid * mid == sum) {
            return mid;
        } else if (mid * mid > sum) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return -1;
}
--------------------------------
int MinFlips(vector<vector<int> > mat, string s) {
    int n = mat.size();
    int m = mat.front().size();
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (mat[i][j]!= s[i + j] - '0') {
                count++;
            }
        }
    }
    return count;
}
--------------------------------
vector<vector<int> > ConstructTree(int n, vector<vector<int> > edges) {
    vector<vector<int> > adjl;
    for (int i = 0; i < n; i++) {
        adjl.push_back(vector<int>());
    }
    for (auto e : edges) {
        int u = e[0];
        int v = e[1];
        adjl[u].push_back(v);
        adjl[v].push_back(u);
    }
    return adjl;
}
--------------------------------
int FindSumOfValues(int v, vector<int> parent, vector<int> values_children) {
    int cur_node = v;
    int sum = 0;
    while (cur_node!= -1) {
        sum += values_children[cur_node];
        cur_node = parent[cur_node];
    }
    return sum;
}
--------------------------------
int GetDistinct(int d, int count) {
    int num = 0;
    count = (int)pow(10, count - 1);
    while (count > 0) {
        num += count * d;
        count /= 10;
    }
    return num;
}
--------------------------------
bool IsIncreasing(vector<int> arr) {
    for (int i = 0; i < arr.size() - 1; i++) {
        if (arr[i] > arr[i + 1]) {
            return false;
        }
    }
    return true;
}
--------------------------------
int MinAdjSwaps(vector<vector<int> > mat) {
    int n = mat.size();
    vector<int> cntZero(n, 0);
    for (int i = 0; i < n; i++) {
        for (int j = n - 1; j >= 0 && mat[i][j] == 0; j--) {
            cntZero[i]++;
        }
    }
    int cntSwaps = 0;
    for (int i = 0; i < n; i++) {
        if (cntZero[i] < (n - i - 1)) {
            int first = i;
            while (first < n && cntZero[first] < (n - i - 1)) {
                first++;
            }
            if (first == n) {
                return -1;
            }
            while (first > i) {
                swap(cntZero[first], cntZero[first - 1]);
                first--;
                cntSwaps++;
            }
        }
    }
    return cntSwaps;
}
--------------------------------
int Solve(vector<int> values, vector<int> salary, int mod) {
    int ret = 1;
    int amt = 0;
    sort(values.begin(), values.end());
    sort(salary.begin(), salary.end());
    while (salary.size() > 0) {
        while (values.size() > 0 && values.back() >= salary.back()) {
            amt++;
            values.pop_back();
        }
        if (amt == 0) {
            return 0;
        }
        ret *= amt--;
        ret %= mod;
        salary.pop_back();
    }
    return ret;
}
--------------------------------
vector<int> OrganizeInOrder(vector<int> vec, vector<char> op, int n) {
    vector<int> result(n, 0);
    sort(vec.begin(), vec.end());
    int i = 0, j = n - 1, k = 0;
    while (i <= j && k <= n - 2) {
        if (op[k] == '<') {
            result[k] = vec[i++];
        } else {
            result[k] = vec[j--];
        }
        k++;
    }
    result[n - 1] = vec[i];
    return result;
}
--------------------------------
int CountPoints(int n, int m, vector<int> a, vector<int> b, int x, int y) {
    sort(a.begin(), a.end());
    sort(b.begin(), b.end());
    int j = 0;
    int count = 0;
    for (int i = 0; i < n; i++) {
        while (j < m) {
            if (a[i] + y < b[j]) {
                break;
            }
            if (b[j] >= a[i] - x && b[j] <= a[i] + y) {
                count++;
                j++;
                break;
            } else {
                j++;
            }
        }
    }
    return count;
}
--------------------------------
bool AreSame(vector<int> a, vector<int> b) {
    sort(a.begin(), a.end());
    sort(b.begin(), b.end());
    return a == b;
}
--------------------------------
int CountNumberOfStrings(string s) {
    int n = s.length() - 1;
    int count = (int)pow(2, n);
    return count;
}
--------------------------------
vector<int> PrimePower(int x) {
    vector<int> primePow;
    for (int i = 2; i * i <= x; i++) {
        if (x % i == 0) {
            int p = 1;
            while (x % i == 0) {
                x /= i;
                p *= i;
            }
            primePow.push_back(p);
        }
    }
    if (x > 1) {
        primePow.push_back(x);
    }
    return primePow;
}
--------------------------------
bool IsPerfect(int n0) {
    double n = sqrt(n0);
    if (floor(n)!= ceil(n)) {
        return false;
    }
    return true;
}
--------------------------------
int FindSum(int l, int r) {
    vector<int> arr;
    int i = 0;
    int x = 2;
    while (i <= r) {
        arr.push_back(i + x);
        if (i + 1 <= r) {
            arr.push_back(i + 1 + x);
        }
        x *= -1;
        i += 2;
    }
    int sum = 0;
    for (i = l; i <= r; ++i) {
        sum += arr[i];
    }
    return sum;
}
--------------------------------
int Results(int n, int k) {
    return (int)round(pow(n, 1.0 / pow(2.0, k)));
}
--------------------------------
vector<int> Factors(int n) {
    vector<int> v;
    v.push_back(1);
    for (int i = 2; i <= sqrt(n); i++) {
        if (n % i == 0) {
            v.push_back(i);
            if (n / i!= i) {
                v.push_back(n / i);
            }
        }
    }
    return v;
}
--------------------------------
int SmallestNum(int n) {
    double x = pow(10, (n - 1) / 2.0);
    return ceil(x);
}
--------------------------------
int Smallest(string s) {
    vector<int> a(s.length(), 0);
    for (int i = 0; i < s.length(); i++) {
        a[i] = s[i] - '0';
    }
    vector<int> b;
    for (int i = 0; i < a.size(); i++) {
        if (a[i] % 2!= 0) {
            b.push_back(a[i]);
        }
    }
    sort(b.begin(), b.end());
    if (b.size() > 1) {
        return b[0] * 10 + b[1];
    }
    return -1;
}
--------------------------------
vector<double> Diagonals(double a, double b, double c, double d) {
    vector<double> ans;
    ans.push_back(sqrt((a * c + b * d) * (a * d + b * c) / (a * b + c * d)));
    ans.push_back(sqrt((a * c + b * d) * (a * b + c * d) / (a * d + b * c)));
    return ans;
}
--------------------------------
int FindNumberOfDigits(int n, int bas) {
    int dig = (int)floor(log(n) / log(bas)) + 1;
    return dig;
}
--------------------------------
double NGon(int n) {
    double proAngleVar;
    if (n % 4 == 0) {
        proAngleVar = M_PI * (180.0 / n) / 180;
    } else {
        proAngleVar = M_PI * (180.0 / (2 * n)) / 180;
    }
    double negX = 1.0e+99, posX = -1.0e+99, negY = 1.0e+99, posY = -1.0e+99;
    for (int j = 0; j < n; ++j) {
        double px = cos(2 * M_PI * j / n + proAngleVar);
        double py = sin(2 * M_PI * j / n + proAngleVar);
        negX = min(negX, px);
        posX = max(posX, px);
        negY = min(negY, py);
        posY = max(posY, py);
    }
    double opt2 = max(posX - negX, posY - negY);
    return opt2 / sin(M_PI / n) / 2;
}
--------------------------------
int FindMaxK(int n) {
    int p = (int)(log(n) / log(2));
    return (int)pow(2, p);
}
--------------------------------
int NthFibo(int n) {
    double a = (pow(5, 0.5) + 1) / 2;
    double b = (-1 * pow(5, 0.5) + 1) / 2;
    double r = pow(5, 0.5);
    double ans = (pow(a, n) - pow(b, n)) / r;
    return (int)ans;
}
--------------------------------
double FindProb(int l, int r) {
    double countOfPs = floor(sqrt(r)) - ceil(sqrt(l)) + 1;
    double total = r - l + 1;
    double prob = countOfPs / total;
    return prob;
}
--------------------------------
int PreviousFibonacci(int n) {
    double a = n / ((1 + sqrt(5)) / 2.0);
    return (int)round(a);
}
--------------------------------
vector<int> DistPrime(vector<int> arr, vector<int> all_primes) {
    vector<int> list1;
    for (int i : all_primes) {
        for (int j : arr) {
            if (j % i == 0) {
                list1.push_back(i);
                break;
            }
        }
    }
    return list1;
}
--------------------------------
vector<int> GetArray(int n) {
    vector<int> ans;
    int p2 = 1;
    while (n > 0) {
        if (n % 2 == 1) {
            ans.push_back(p2);
        }
        n >>= 1;
        p2 *= 2;
    }
    return ans;
}
--------------------------------
int MaximumLength(vector<int> a) {
    vector<int> counts = vector<int>(11, 0);
    int ans = 0;
    for (int index = 0; index < a.size(); index++) {
        counts[a[index]]++;
        vector<int> k;
        for (int i : counts) {
            if (i!= 0) {
                k.push_back(i);
            }
        }
        sort(k.begin(), k.end());
        if (k.size() == 1 || (k[0] == k[k.size() - 2] && k[k.size() - 1] - k[k.size() - 2] == 1) || (k[0] == 1 && k[1] == k[k.size() - 1])) {
            ans = index;
        }
    }
    return ans + 1;
}
--------------------------------
int MaxEdges(int n) {
    return (int)floor(n * n / 4);
}
--------------------------------
int FindK(int n, int k) {
    vector<int> a;
    for (int i = 1; i < n; i++) {
        if (i % 2 == 1) {
            a.push_back(i);
        }
    }
    for (int i = 1; i < n; i++) {
        if (i % 2 == 0) {
            a.push_back(i);
        }
    }
    return a[k - 1];
}
--------------------------------
bool IsKeith(int x, int temp) {
    std::vector<int> terms;
    int n = 0;
    while (temp > 0) {
        terms.push_back(temp % 10);
        temp = temp / 10;
        n++;
    }
    std::reverse(terms.begin(), terms.end());
    int nextTerm = 0, i = n;
    while (nextTerm < x) {
        nextTerm = 0;
        for (int j = 1; j <= n; j++) {
            nextTerm += terms[i - j];
        }
        terms.push_back(nextTerm);
        i++;
    }
    return nextTerm == x;
}
--------------------------------
bool Factors(int n, int k) {
    vector<int> v;
    while (n % 2 == 0) {
        v.push_back(2);
        n /= 2;
    }
    if (v.size() >= k) {
        return true;
    }
    for (int i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            n = n / i;
            v.push_back(i);
        }
        if (v.size() >= k) {
            return true;
        }
    }
    if (n > 2) {
        v.push_back(n);
    }
    if (v.size() >= k) {
        return true;
    }
    return false;
}
--------------------------------
vector<string> SeparateParenGroups(string paren_string) {
    vector<string> all_parens;
    string current_paren;
    int current_depth = 0;
    for (char c : paren_string) {
        if (c == '(') {
            current_depth += 1;
            current_paren += c;
        } else if (c == ')') {
            current_depth -= 1;
            current_paren += c;
            if (current_depth == 0) {
                all_parens.push_back(current_paren);
                current_paren = "";
            }
        }
    }
    return all_parens;
}
--------------------------------
vector<int> ParseNestedParens(string paren_string) {
    vector<int> all_levels;
    int level = 0;
    int max_level = 0;
    for (int i = 0; i < paren_string.length(); i++) {
        char chr = paren_string.at(i);
        if (chr == '(') {
            level += 1;
            if (level > max_level) {
                max_level = level;
            }
        }
        if (chr == ')') {
            level -= 1;
            if (level == 0) {
                all_levels.push_back(max_level);
                max_level = 0;
            }
        }
    }
    return all_levels;
}
--------------------------------
vector<string> FilterBySubstring(vector<string> strings, string substring) {
    vector<string> result;
    for (auto s : strings) {
        if (s.find(substring)!= string::npos) {
            result.push_back(s);
        }
    }
    return result;
}
--------------------------------
vector<int> RollingMax(vector<int> numbers) {
    vector<int> result;
    int runningMax = 0;
    for (int n : numbers) {
        if (n > runningMax) {
            runningMax = n;
        }
        result.push_back(runningMax);
    }
    return result;
}
--------------------------------
string MakePalindrome(string s) {
    if (s.empty()) {
        return "";
    }
    for (int i = 0; i < s.size(); i++) {
        string rStr = s.substr(i);
        if (rStr == reverse(rStr)) {
            string nStr = s.substr(0, i);
            string n2Str = reverse(nStr);
            return s + n2Str;
        }
    }
    return s.substr(0, s.size() - 1) + reverse(s);
}
--------------------------------
string StringXor(string a, string b) {
    string result;
    for (int i = 0; i < a.length(); i++) {
        if (a[i] == b[i]) {
            result += '0';
        } else {
            result += '1';
        }
    }
    return result;
}
--------------------------------
string Longest(vector<string> strings) {
    if (strings.empty()) return "";
    int maxLen = *max_element(strings.begin(), strings.end(), [](const string& a, const string& b) {
        return a.length() < b.length();
    });
    for (const string& s : strings) {
        if (s.length() == maxLen) {
            return s;
        }
    }
    return "";
}
--------------------------------
string StringSequence(int n) {
    string s;
    for (int i = 0; i < n; i++) {
        s += to_string(i) + " ";
    }
    s += to_string(n);
    return s;
}
--------------------------------
int CountDistinctCharacter(string s) {
    set<char> distinct;
    for (char c : s.tolower().c_str()) {
        distinct.insert(c);
    }
    return distinct.size();
}
--------------------------------
int HowManyTimes(string s, string sub) {
    int times = 0;
    for (int i = 0; i <= s.length() - sub.length(); i++) {
        if (s.substr(i, sub.length()) == sub) {
            times += 1;
        }
    }
    return times;
}
--------------------------------
string SortNumbers(string numbers) {
    map<string, int> toNum = {{"zero", 0}, {"one", 1}, {"two", 2}, {"three", 3}, {"four", 4}, {"five", 5}, {"six", 6}, {"seven", 7}, {"eight", 8}, {"nine", 9}};
    map<int, string> fromNum = {{0, "zero"}, {1, "one"}, {2, "two"}, {3, "three"}, {4, "four"}, {5, "five"}, {6, "six"}, {7, "seven"}, {8, "eight"}, {9, "nine"}};
    vector<int> ints;
    string current;
    for (int i = 0; i <= numbers.length(); i++) {
        if (i == numbers.length() || numbers[i] =='') {
            if (toNum.count(current)) {
                ints.push_back(toNum[current]);
                current = "";
            }
        } else {
            current += numbers[i];
        }
    }
    sort(ints.begin(), ints.end());
    string result;
    for (int i = 0; i < ints.size(); i++) {
        result += fromNum[ints[i]];
        if (i!= ints.size() - 1) {
            result += " ";
        }
    }
    return result;
}
--------------------------------
vector<double> FindClosestElements(vector<double> numbers) {
    vector<double> closestPair = {numbers[0], numbers[1]};
    double distance = abs(numbers[0] - numbers[1]);
    for (int i = 0; i < numbers.size(); i++) {
        for (int j = i + 1; j < numbers.size(); j++) {
            if (abs(numbers[i] - numbers[j]) < distance) {
                closestPair[0] = numbers[i];
                closestPair[1] = numbers[j];
                distance = abs(numbers[i] - numbers[j]);
            }
        }
    }
    sort(closestPair.begin(), closestPair.end());
    return closestPair;
}
--------------------------------
vector<double> RescaleToUnit(vector<double> numbers) {
    double minNum = *min_element(numbers.begin(), numbers.end());
    double maxNum = *max_element(numbers.begin(), numbers.end());
    vector<double> result;
    for (double n : numbers) {
        result.push_back((n - minNum) / (maxNum - minNum));
    }
    return result;
}
--------------------------------
vector<int> FilterIntegers(vector<any> values) {
    vector<int> result;
    for (auto e : values) {
        if (e is int) {
            result.push_back(e);
        }
    }
    return result;
}
--------------------------------
vector<int> removeDuplicates(vector<int> numbers) {
    unordered_map<int, int> c;
    for (int i : numbers) {
        c[i]++;
    }
    vector<int> result;
    for (int i : numbers) {
        if (c[i] == 1) {
            result.push_back(i);
        }
    }
    return result;
}
--------------------------------
string FlipCase(string s) {
    string result = "";
    for (char c : s) {
        if (islower(c)) {
            result += toupper(c);
        } else {
            result += tolower(c);
        }
    }
    return result;
}
--------------------------------
vector<string> FilterByPrefix(vector<string> strings, string prefix) {
    vector<string> result;
    for (int i = 0; i < strings.size(); i++) {
        if (strings[i].find(prefix) == 0) {
            result.push_back(strings[i]);
        }
    }
    return result;
}
--------------------------------
double FindZero(vector<double> xs) {
    double ans = 0;
    double value = 0;
    for (int i = 0; i < xs.size(); i++) {
        value += xs[i] * pow(ans, i);
    }
    while (abs(value) > 1e-6) {
        double driv = 0;
        for (int i = 1; i < xs.size(); i++) {
            driv += xs[i] * pow(ans, i - 1) * i;
        }
        ans -= value / driv;
        value = 0;
        for (int i = 0; i < xs.size(); i++) {
            value += xs[i] * pow(ans, i);
        }
    }
    return ans;
}
--------------------------------
vector<int> SortThird(vector<int> l) {
    vector<int> thirds;
    for (int i = 0; i < l.size(); i += 3) {
        thirds.push_back(l[i]);
    }
    sort(thirds.begin(), thirds.end());
    vector<int> result;
    for (int i = 0; i < l.size(); i++) {
        if (i % 3 == 0) {
            result.push_back(thirds[i / 3]);
        } else {
            result.push_back(l[i]);
        }
    }
    return result;
}
--------------------------------
vector<int> Unique(vector<int> l) {
    vector<int> result(set<int>(l.begin(), l.end()).begin(), set<int>(l.begin(), l.end()).end());
    sort(result.begin(), result.end());
    return result;
}
--------------------------------
double MaxElement(vector<double> l) {
    return *max_element(l.begin(), l.end());
}
--------------------------------
bool TriplesSumToZero(vector<int> l) {
    for (int i = 0; i < l.size(); i++) {
        for (int j = i + 1; j < l.size(); j++) {
            for (int k = j + 1; k < l.size(); k++) {
                if (l[i] + l[j] + l[k] == 0) {
                    return true;
                }
            }
        }
    }
    return false;
}
--------------------------------
int Fib4(int n) {
    std::vector<int> results = {0, 0, 2, 0};
    for (int i = 4; i <= n; i++) {
        results.push_back(results[i - 4] + results[i - 3] + results[i - 2] + results[i - 1]);
    }
    return results[n];
}
--------------------------------
bool IsPalindrome(string text) {
    string pr = string(text.rbegin(), text.rend());
    return pr == text;
}
--------------------------------
string RemoveVowels(string text) {
    string result;
    string vowels = "aeiou";
    for (char ch : text) {
        if (vowels.find(tolower(ch)) == string::npos) {
            result += ch;
        }
    }
    return result;
}
--------------------------------
bool SameChars(string s0, string s1) {
    set<char> set0;
    for (char c : s0) {
        set0.insert(c);
    }
    set<char> set1;
    for (char c : s1) {
        set1.insert(c);
    }
    return set0 == set1;
}
--------------------------------
vector<int> Common(vector<int> l1, vector<int> l2) {
    set<int> us;
    for (int e1 : l1) {
        for (int e2 : l2) {
            if (e1 == e2) {
                us.insert(e1);
            }
        }
    }
    vector<int> ret(us.begin(), us.end());
    sort(ret.begin(), ret.end());
    return ret;
}
--------------------------------
bool CorrectBracketing(string brackets) {
    int depth = 0;
    for (char b : brackets) {
        if (b == '(') {
            depth += 1;
        }
        if (b == ')') {
            depth -= 1;
        }
        if (depth < 0) {
            return false;
        }
    }
    return depth == 0;
}
--------------------------------
string CircularShift(int x, int shift) {
    string xs = to_string(x);
    if (shift > xs.length()) {
        return string(xs.rbegin(), xs.rend());
    }
    return xs.substr(xs.length() - shift) + xs.substr(0, xs.length() - shift);
}
--------------------------------
int Search(vector<int> lst) {
    unordered_map<int, int> counter;
    for (int i : lst) {
        counter[i]++;
    }
    int ans = -1;
    for (auto item : counter) {
        if (item.second >= item.first && item.first > ans) {
            ans = item.first;
        }
    }
    return ans;
}
--------------------------------
int SmallestChange(vector<int> arr) {
    int ans = 0;
    for (int i = 0; i < arr.size() / 2; i++) {
        if (arr[i]!= arr[arr.size() - i - 1]) {
            ans += 1;
        }
    }
    return ans;
}
--------------------------------
vector<string> TotalMatch(vector<string> lst1, vector<string> lst2) {
    int sum1 = 0;
    for (auto st : lst1) {
        sum1 += st.length();
    }
    int sum2 = 0;
    for (auto st : lst2) {
        sum2 += st.length();
    }
    return sum1 > sum2? lst2 : lst1;
}
--------------------------------
bool IsHappy(string s) {
    if (s.length() < 3) {
        return false;
    }
    for (int i = 0; i < s.length() - 2; i++) {
        if (s[i] == s[i + 1] || s[i] == s[i + 2] || s[i + 1] == s[i + 2]) {
            return false;
        }
    }
    return true;
}
--------------------------------
vector<string> NumericalLetterGrade(vector<double> grades) {
    vector<string> letterGrade;
    for (double gpa : grades) {
        if (gpa == 4.0) {
            letterGrade.push_back("A+");
        } else if (gpa > 3.7) {
            letterGrade.push_back("A");
        } else if (gpa > 3.3) {
            letterGrade.push_back("A-");
        } else if (gpa > 3.0) {
            letterGrade.push_back("B+");
        } else if (gpa > 2.7) {
            letterGrade.push_back("B");
        } else if (gpa > 2.3) {
            letterGrade.push_back("B-");
        } else if (gpa > 2.0) {
            letterGrade.push_back("C+");
        } else if (gpa > 1.7) {
            letterGrade.push_back("C");
        } else if (gpa > 1.3) {
            letterGrade.push_back("C-");
        } else if (gpa > 1.0) {
            letterGrade.push_back("D+");
        } else if (gpa > 0.7) {
            letterGrade.push_back("D");
        } else if (gpa > 0.0) {
            letterGrade.push_back("D-");
        } else {
            letterGrade.push_back("E");
        }
    }
    return letterGrade;
}
--------------------------------
string Solve(int n) {
    string biStr = "";
    int sum = 0;
    for (char c : to_string(n).c_str()) {
        sum += c - '0';
    }
    while (sum > 0) {
        biStr = to_string(sum % 2) + biStr;
        sum /= 2;
    }
    return biStr;
}
--------------------------------
string AntiShuffle(string s) {
    string ret = "";
    string current = "";
    for (int i = 0; i <= s.length(); i++) {
        if (i == s.length() || s[i] =='') {
            char tmp[26] = {0};
            for (int j = 0; j < current.length(); j++) {
                tmp[current[j] - 'a']++;
            }
            for (int j = 0; j < 26; j++) {
                if (tmp[j]!= 0) {
                    if (!ret.empty()) {
                        ret +='';
                    }
                    ret += string(tmp[j], 'a' + j);
                }
            }
            current = "";
        } else {
            current += s[i];
        }
    }
    return ret;
}
--------------------------------
vector<int> SortArray(vector<int> array) {
    if (array.empty()) {
        return array;
    }
    if ((array[0] + array[array.size() - 1]) % 2 == 1) {
        sort(array.begin(), array.end());
    } else {
        sort(array.begin(), array.end(), greater<int>());
    }
    return array;
}
--------------------------------
string Encrypt(string s) {
    string ans;
    for (char c : s) {
        if (isalpha(c)) {
            ans += (char)('a' + (c - 'a' + 4) % 26);
        } else {
            ans += c;
        }
    }
    return ans;
}
--------------------------------
int IsBored(string s) {
    bool isStart = true;
    int sum = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == '.' || s[i] == '?' || s[i] == '!') {
            isStart = true;
        } else if (isStart) {
            if (s[i] =='') {
                continue;
            }
            if (s.substr(i, 2) == "I ") {
                sum += 1;
            }
            isStart = false;
        }
    }
    return sum;
}
--------------------------------
string Encode(string message) {
    string vowels = "aeiouAEIOU";
    string ret = "";
    for (char c : message.c_str()) {
        if (isupper(c)) {
            c = tolower(c);
            if (vowels.find(c)!= -1) {
                c = (char)('a' + (c - 'a' + 2) % 26);
            }
        } else if (islower(c)) {
            c = toupper(c);
            if (vowels.find(c)!= -1) {
                c = (char)('A' + (c - 'A' + 2) % 26);
            }
        }
        ret += c;
    }
    return ret;
}
--------------------------------
int Skjkasdkd(vector<int> lst) {
    int largest = 0;
    for (int n : lst) {
        if (n > largest) {
            bool prime = true;
            for (int i = 2; i < n; i++) {
                if (n % i == 0) {
                    prime = false;
                }
            }
            if (prime) {
                largest = n;
            }
        }
    }
    int sum = 0;
    string s = to_string(largest);
    for (int i = 0; i < s.length(); i++) {
        sum += s[i] - '0';
    }
    return sum;
}
--------------------------------
bool CheckDictCase(unordered_map<string, string> dict) {
    if (dict.empty()) {
        return false;
    }
    int isLower = 0;
    int isUpper = 0;
    for (auto key : dict.keys()) {
        for (char c : key) {
            if (islower(c)) {
                isLower = 1;
            } else if (isupper(c)) {
                isUpper = 1;
            } else {
                return false;
            }
        }
    }
    return isLower + isUpper == 1;
}
--------------------------------
int Multiply(int a, int b) {
    return (abs(a) % 10) * (abs(b) % 10);
}
--------------------------------
int CountUpper(string s) {
    string uVowel = "AEIOU";
    int count = 0;
    for (int i = 0; i < s.length(); i += 2) {
        if (uVowel.find(s[i])!= string::npos) {
            count += 1;
        }
    }
    return count;
}
--------------------------------
vector<string> ByLength(vector<int> arr) {
    map<int, string> numTo = { { 1, "One" }, { 2, "Two" }, { 3, "Three" }, { 4, "Four" }, { 5, "Five" }, { 6, "Six" }, { 7, "Seven" }, { 8, "Eight" }, { 9, "Nine" } };
    vector<int> sortedArr = arr;
    sort(sortedArr.begin(), sortedArr.end(), greater<int>());
    vector<string> newArr;
    for (int n : sortedArr) {
        if (n >= 1 && n <= 9) {
            newArr.push_back(numTo[n]);
        }
    }
    return newArr;
}
--------------------------------
vector<int> f(int n) {
    int sum = 0;
    int prod = 1;
    vector<int> result;
    for (int i = 1; i <= n; i++) {
        sum += i;
        prod *= i;
        if (i % 2 == 0) {
            result.push_back(prod);
        } else {
            result.push_back(sum);
        }
    }
    return result;
}
--------------------------------
vector<int> EvenOddPalindrome(int n) {
    int evenCount = 0, oddCount = 0;
    for (int i = 1; i <= n; i++) {
        string s = to_string(i);
        string rStr = string(s.rbegin(), s.rend());
        if (s == rStr) {
            if (i % 2 == 1) {
                oddCount += 1;
            } else {
                evenCount += 1;
            }
        }
    }
    return {evenCount, oddCount};
}
--------------------------------
unordered_map<char, int> Histogram(string test) {
    unordered_map<char, int> count;
    int max = 0;
    for (int i = 0; i < test.length(); i++) {
        if (test[i]!='') {
            count[test[i]]++;
            if (count[test[i]] > max) {
                max = count[test[i]];
            }
        }
    }
    unordered_map<char, int> result;
    for (auto item : count) {
        if (item.second == max) {
            result[item.first] = item.second;
        }
    }
    return result;
}
--------------------------------
vector<string> ReverseDelete(string s, string c) {
    string ret = "";
    for (char ch : s.c_str()) {
        if (c.find(ch) == string::npos) {
            ret += ch;
        }
    }
    string flag = "False";
    if (ret == string(ret.rbegin(), ret.rend())) {
        flag = "True";
    }
    return {ret, flag};
}
--------------------------------
vector<int> SortArray(vector<int> arr) {
    vector<int> bin;
    for (int i : arr) {
        int b = 0;
        int n = abs(i);
        while (n > 0) {
            b += n % 2;
            n /= 2;
        }
        bin.push_back(b);
    }
    for (int i = 0; i < arr.size(); i++) {
        for (int j = 1; j < arr.size(); j++) {
            if (bin[j] < bin[j - 1] || (bin[j] == bin[j - 1] && arr[j] < arr[j - 1])) {
                swap(bin[j], bin[j - 1]);
                swap(arr[j], arr[j - 1]);
            }
        }
    }
    return arr;
}
--------------------------------
string GetClosestVowel(string word) {
    string vowels = "AEIOUaeiou";
    for (int i = word.length() - 2; i > 0; i--) {
        if (vowels.find(word[i])!= string::npos && vowels.find(word[i + 1]) == string::npos && vowels.find(word[i - 1]) == string::npos) {
            return string(1, word[i]);
        }
    }
    return "";
}
--------------------------------
string MatchParens(vector<string> lst) {
    vector<string> strings = {lst[0] + lst[1], lst[1] + lst[0]};
    for (auto l : strings) {
        int count = 0;
        for (char c : l.c_str()) {
            if (c == '(') {
                count += 1;
            } else {
                count -= 1;
            }
            if (count < 0) {
                break;
            }
        }
        if (count == 0) {
            return "Yes";
        }
    }
    return "No";
}
--------------------------------
vector<int> Maximum(vector<int> arr, int k) {
    if (k == 0) {
        return vector<int>();
    }
    sort(arr.begin(), arr.end());
    return vector<int>(arr.end() - k, arr.end());
}
--------------------------------
bool ValidDate(string date) {
    if (date.length()!= 10) {
        return false;
    }
    for (int i = 0; i < 10; i++) {
        if (i == 2 || i == 5) {
            if (date.charAt(i)!= '-') {
                return false;
            }
        } else if (!isdigit(date.charAt(i))) {
            return false;
        }
    }
    int month = stoi(date.substr(0, 2));
    int day = stoi(date.substr(3, 5));
    int year = stoi(date.substr(6, 10));
    if (month < 1 || month > 12) {
        return false;
    }
    if (day < 1 || day > 31) {
        return false;
    }
    if (day == 31 && (month == 4 || month == 6 || month == 9 || month == 11 || month == 2)) {
        return false;
    }
    if (day == 30 && month == 2) {
        return false;
    }
    return true;
}
--------------------------------
vector<string> SplitWords(string txt) {
    vector<string> result;
    if (txt.find(' ')!= string::npos) {
        string current;
        for (int i = 0; i < txt.length(); i++) {
            if (txt[i] =='') {
                if (current.length() > 0) {
                    result.push_back(current);
                }
                current.clear();
            } else {
                current += txt[i];
            }
        }
        if (current.length() > 0) {
            result.push_back(current);
        }
        return result;
    }
    if (txt.find(',')!= string::npos) {
        string current;
        for (int i = 0; i < txt.length(); i++) {
            if (txt[i] == ',') {
                if (current.length() > 0) {
                    result.push_back(current);
                }
                current.clear();
            } else {
                current += txt[i];
            }
        }
        if (current.length() > 0) {
            result.push_back(current);
        }
        return result;
    }
    int num = 0;
    for (char c : txt) {
        if (islower(c) && c % 2 == 0) {
            num += 1;
        }
    }
    return {to_string(num)};
}
--------------------------------
vector<int> Tri(int n) {
    if (n == 0) {
        return {1};
    }
    vector<int> tris = {1, 3};
    for (int i = 2; i <= n; i++) {
        if (i % 2 == 0) {
            tris.push_back(i / 2 + 1);
        } else {
            tris.push_back(tris[i - 1] + tris[i - 2] + (i + 3) / 2);
        }
    }
    return tris;
}
--------------------------------
bool CheckIfLastCharIsALetter(string txt) {
    if (txt.empty()) {
        return false;
    }
    return isalpha(txt[txt.size() - 1]) && (txt.size() == 1 ||!isalpha(txt[txt.size() - 2]));
}
--------------------------------
vector<int> OrderByPoints(vector<int> nums) {
    vector<int> result;
    for (int num : nums) {
        string w = to_string(abs(num));
        int sum = 0;
        for (char c : w) {
            sum += c - '0';
        }
        if (num < 0) {
            sum -= 2 * (w[0] - '0');
        }
        result.push_back(sum);
    }
    for (int i = 0; i < nums.size(); i++) {
        for (int j = 1; j < nums.size(); j++) {
            if (result[j - 1] > result[j]) {
                swap(result[j], result[j - 1]);
                swap(nums[j], nums[j - 1]);
            }
        }
    }
    return nums;
}
--------------------------------
vector<string> Bf(string planet1, string planet2) {
    vector<string> planets = {"Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"};
    int idx1 = find(planets.begin(), planets.end(), planet1) - planets.begin();
    int idx2 = find(planets.begin(), planets.end(), planet2) - planets.begin();
    if (idx1 == -1 || idx2 == -1 || idx1 == idx2) {
        return {};
    }
    return idx1 > idx2? vector<string>(planets.begin() + idx2 + 1, planets.begin() + idx1) : vector<string>(planets.begin() + idx1 + 1, planets.begin() + idx2);
}
--------------------------------
vector<string> SortedListSum(vector<string> lst) {
    vector<string> result;
    for (auto i : lst) {
        if (i.length() % 2 == 0) {
            result.push_back(i);
        }
    }
    sort(result.begin(), result.end(), [](string l, string r) {
        if (l.length() == r.length()) {
            return l.compare(r);
        }
        return l.length() - r.length();
    });
    return result;
}
--------------------------------
bool CycpatternCheck(string a, string b) {
    for (int i = 0; i <= b.length(); i++) {
        string rotate = b.substr(i) + b.substr(0, i);
        if (a.find(rotate)!= string::npos) {
            return true;
        }
    }
    return false;
}
--------------------------------
vector<int> EvenOddCount(int num) {
    int evenCount = 0, oddCount = 0;
    for (char i : to_string(abs(num)).c_str()) {
        if (i % 2 == 0) {
            evenCount += 1;
        } else {
            oddCount += 1;
        }
    }
    return {evenCount, oddCount};
}
--------------------------------
string FindMax(vector<string> words) {
    string max = "";
    int maxLength = 0;
    for (auto word : words) {
        vector<char> unique;
        for (char w : word) {
            if (find(unique.begin(), unique.end(), w) == unique.end()) {
                unique.push_back(w);
            }
        }
        if (unique.size() > maxLength || (unique.size() == maxLength && word < max)) {
            max = word;
            maxLength = unique.size();
        }
    }
    return max;
}
--------------------------------
string Solve(string s) {
    bool noLetter = true;
    string result = "";
    for (char ch : s) {
        if (isupper(ch)) {
            ch = tolower(ch);
            noLetter = false;
        } else if (islower(ch)) {
            ch = toupper(ch);
            noLetter = false;
        }
        result += ch;
    }
    if (noLetter) {
        return reverse(result);
    } else {
        return result;
    }
}
--------------------------------
int MostFrequent(vector<int> arr, int n) {
    map<int, int> hp;
    for (int i = 0; i < n; i++) {
        if (hp.find(arr[i])!= hp.end()) {
            hp[arr[i]]++;
        } else {
            hp[arr[i]] = 1;
        }
    }
    int maxCount = 0, res = -1;
    for (auto entry : hp) {
        if (maxCount < entry.second) {
            res = entry.first;
            maxCount = entry.second;
        }
    }
    return res;
}
--------------------------------
int Find(vector<int> a, vector<int> b, int k, int n1, int n2) {
    set<int> s;
    for (int i = 0; i < n2; i++) {
        s.insert(b[i]);
    }
    int missing = 0;
    for (int i = 0; i < n1; i++) {
        if (!s.count(a[i])) {
            missing++;
        }
        if (missing == k) {
            return a[i];
        }
    }
    return -1;
}
--------------------------------
int SolveQuery(int start, int end, vector<int> arr) {
    map<int, int> mp;
    for (int i = start; i <= end; i++) {
        mp[arr[i]]++;
    }
    int count = 0;
    for (auto entry : mp) {
        if (entry.first == entry.second) {
            count++;
        }
    }
    return count;
}
--------------------------------
int Segregate(vector<int> arr, int size) {
    int j = 0;
    for (int i = 0; i < size; i++) {
        if (arr[i] <= 0) {
            swap(arr[i], arr[j]);
            j++;
        }
    }
    return j;
}
--------------------------------
int CountTriplets(vector<int> a, int n) {
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int xr = a[i] ^ a[j];
            if (__builtin_popcount(xr) == 1) {
                count++;
            }
        }
    }
    return count / 3;
}
--------------------------------
int LeastFrequent(vector<int> arr, int n) {
    unordered_map<int, int> hp;
    for (int i = 0; i < n; i++) {
        if (hp.find(arr[i])!= hp.end()) {
            hp[arr[i]]++;
        } else {
            hp[arr[i]] = 1;
        }
    }
    int minCount = n + 1, res = -1;
    for (auto entry : hp) {
        if (minCount >= entry.second) {
            res = entry.first;
            minCount = entry.second;
        }
    }
    return res;
}
--------------------------------
int FindPermutations(vector<int> arr) {
    int cnt = 0;
    int maxInd = -1, minInd = 10000000;
    int n = arr.size();
    map<int, int> indexOf;
    for (int i = 0; i < n; i++) {
        indexOf[arr[i]] = i + 1;
    }
    for (int i = 1; i <= n; i++) {
        maxInd = max(maxInd, indexOf[i]);
        minInd = min(minInd, indexOf[i]);
        if (maxInd - minInd + 1 == i) {
            cnt++;
        }
    }
    return cnt;
}
--------------------------------
int FormQuadruplets(vector<int> arr, int n) {
    int ans = 0, pairs = 0;
    pairs = n / 4;
    sort(arr.begin(), arr.end(), greater<int>());
    for (int i = 0; i < n - pairs; i += 3) {
        ans += arr[i + 2];
    }
    return ans;
}
--------------------------------
string LexicographicallyMaximum(string s, int n) {
    map<char, int> m;
    for (int i = 0; i < n; ++i) {
        if (m.find(s[i])!= m.end()) {
            m[s[i]]++;
        } else {
            m[s[i]] = 1;
        }
    }
    vector<char> v;
    for (char i = 'a'; i < 'a' + min(n, 25); ++i) {
        if (m.find(i) == m.end()) {
            v.push_back(i);
        }
    }
    int j = v.size() - 1;
    for (int i = 0; i < n; ++i) {
        if (s[i] >= 'a' + min(n, 25) || (m.find(s[i])!= m.end() && m[s[i]] > 1)) {
            if (v[j] < s[i]) {
                continue;
            }
            m[s[i]]--;
            s = s.substr(0, i) + v[j] + s.substr(i + 1);
            j--;
        }
        if (j < 0) {
            break;
        }
    }
    int l = 0;
    for (int i = n - 1; i >= 0; i--) {
        if (l > j) {
            break;
        }
        if (s[i] >= 'a' + min(n, 25) || m.find(s[i])!= m.end() && m[s[i]] > 1) {
            m[s[i]]--;
            s = s.substr(0, i) + v[l] + s.substr(i + 1);
            l++;
        }
    }
    return s;
}
--------------------------------
int NoOfValidKbers(int k, vector<int> arr) {
    set<int> s;
    while (k!= 0) {
        s.insert(k % 10);
        k = k / 10;
    }
    int count = 0;
    for (int i = 0; i < arr.size(); i++) {
        int no = arr.at(i);
        bool flag = true;
        while (no!= 0) {
            int digit = no % 10;
            if (s.find(digit) == s.end()) {
                flag = false;
                break;
            }
            no = no / 10;
        }
        if (flag) {
            count++;
        }
    }
    return count;
}
--------------------------------
int DelCost(string s, vector<int> cost) {
    int ans = 0;
    map<char, int> forMax;
    map<char, int> forTot;
    for (int i = 0; i < s.length(); i++) {
        if (!forMax.count(s[i])) {
            forMax[s[i]] = cost[i];
        } else {
            forMax[s[i]] = max(cost[i], forMax[s[i]]);
        }
        if (!forTot.count(s[i])) {
            forTot[s[i]] = cost[i];
        } else {
            forTot[s[i]] = forTot[s[i]] + cost[i];
        }
    }
    for (auto i : forMax) {
        ans += forTot[i.first] - i.second;
    }
    return ans;
}
--------------------------------
vector<string> ReplaceDuplicates(vector<string> names) {
    unordered_map<string, int> hash;
    for (int i = 0; i < names.size(); i++) {
        if (!hash.count(names[i])) {
            hash[names[i]] = 1;
        } else {
            int count = hash[names[i]];
            hash[names[i]] = hash[names[i]] + 1;
            names[i] = names[i] + to_string(count);
        }
    }
    return names;
}
--------------------------------
vector<int> minmaxNumbers(vector<vector<int> > matrix, vector<int> res) {
    set<int> set;
    for (int i = 0; i < matrix.size(); i++) {
        int minR = INT_MAX;
        for (int j = 0; j < matrix[i].size(); j++) {
            minR = min(minR, matrix[i][j]);
        }
        set.insert(minR);
    }
    for (int j = 0; j < matrix[0].size(); j++) {
        int maxC = INT_MIN;
        for (int i = 0; i < matrix.size(); i++) {
            maxC = max(maxC, matrix[i][j]);
        }
        if (set.find(maxC)!= set.end()) {
            res.push_back(maxC);
        }
    }
    return res;
}
--------------------------------
int LengthOfLongestAp(vector<int> a, int n) {
    map<int, map<int, int>> dp;
    int res = 2;
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            int d = a[j] - a[i];
            if (dp.count(d)) {
                if (dp[d].count(i)) {
                    dp[d][j] = dp[d][i] + 1;
                } else {
                    dp[d][j] = 2;
                }
            } else {
                dp[d] = map<int, int>();
                dp[d][j] = 2;
            }
            res = max(res, dp[d][j]);
        }
    }
    return res;
}
--------------------------------
char FindKthChar(int n, int k) {
    string prev = "A";
    string cur = "";
    if (n == 1) {
        return 'A';
    }
    for (int j = 2; j <= n; j++) {
        cur = prev + "B";
        for (int i = 0; i < prev.length(); i++) {
            if (prev[i] == 'A') {
                prev = prev.substr(0, i) + 'B' + prev.substr(i + 1);
            } else {
                prev = prev.substr(0, i) + 'A' + prev.substr(i + 1);
            }
        }
        prev = prev.substr(0, prev.length() / 2) + prev.substr(prev.length() / 2 + 1, prev.length() / 2) + prev.substr(0, prev.length() / 2);
        cur += prev;
        prev = cur;
    }
    return cur[k - 1];
}
--------------------------------
char FindKthLargest(string s, int k) {
    vector<char> tmp;
    for (int i = 0; i < s.size(); i++) {
        tmp.push_back(s[i]);
    }
    sort(tmp.begin(), tmp.end(), greater<char>());
    return tmp[k - 1];
}
--------------------------------
int SubArraylen(vector<int> arr, int n, int k) {
    unordered_map<int, int> mp;
    mp[arr[0]] = 0;
    for (int i = 1; i < n; i++) {
        arr[i] += arr[i - 1];
        mp[arr[i]] = i;
    }
    int len = INT_MAX;
    for (int i = 0; i < n; i++) {
        if (arr[i] < k) {
            continue;
        } else {
            int x = arr[i] - k;
            if (x == 0) {
                len = min(len, i);
            }
            if (mp.find(x) == mp.end()) {
                continue;
            } else {
                len = min(len, i - mp[x]);
            }
        }
    }
    return len;
}
--------------------------------
int FindMaxLen(vector<int> a, int k) {
    int n = a.size();
    sort(a.begin(), a.end());
    vector<bool> vis(n, false);
    map<int, int> mp;
    for (int i = 0; i < n; i++) {
        mp[a[i]] = i;
    }
    int c = 0;
    for (int i = 0; i < n; ++i) {
        if (!vis[i]) {
            int check = a[i] * k;
            if (mp.find(check)!= mp.end()) {
                c++;
                vis[mp[check]] = true;
            }
        }
    }
    return n - c;
}
--------------------------------
vector<int> MinDistancePoints(vector<int> a, int k, int n) {
    map<int, int> m;
    queue<int> q;
    for (int i = 0; i < n; ++i) {
        m.insert(pair<int, int>(a[i], 1));
        q.push(a[i]);
    }
    vector<int> ans;
    while (k > 0) {
        int x = q.front();
        q.pop();
        if (m.find(x - 1) == m.end() && k > 0) {
            m.insert(pair<int, int>(x - 1, 1));
            q.push(x - 1);
            ans.push_back(x - 1);
            k--;
        }
        if (m.find(x + 1) == m.end() && k > 0) {
            m.insert(pair<int, int>(x + 1, 1));
            q.push(x + 1);
            ans.push_back(x + 1);
            k--;
        }
    }
    return ans;
}
--------------------------------
bool IsValidLen(string s, int length, int k) {
    int n = s.size();
    map<char, int> mp;
    int right = 0;
    while (right < length) {
        if (mp.find(s[right])!= mp.end()) {
            mp[s[right]]++;
        } else {
            mp[s[right]] = 1;
        }
        right++;
    }
    if (mp.size() <= k) {
        return true;
    }
    while (right < n) {
        if (mp.find(s[right])!= mp.end()) {
            mp[s[right]]++;
        } else {
            mp[s[right]] = 1;
        }
        if (mp.find(s[right - length])!= mp.end()) {
            mp[s[right - length]]--;
        }
        if (mp[s[right - length]] == 0) {
            mp.erase(s[right - length]);
        }
        if (mp.size() <= k) {
            return true;
        }
        right++;
    }
    return mp.size() <= k;
}
--------------------------------
int Partition(vector<int> arr, int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return (i + 1);
}
--------------------------------
int StrScore(vector<string> strs, string s, int n) {
    unordered_map<string, int> m;
    for (int i = 0; i < n; i++) {
        m[strs[i]] = i + 1;
    }
    if (m.find(s) == m.end()) {
        return 0;
    }
    int score = 0;
    for (int i = 0; i < s.length(); i++) {
        score += s[i] - 'a' + 1;
    }
    score = score * m[s];
    return score;
}
--------------------------------
vector<int> CountEle(vector<int> s, vector<int> a, int n) {
    map<int, bool> mp;
    vector<int> ans;
    for (int i = 0; i < n; ++i) {
        int num = a[i];
        if (mp.find(num)!= mp.end()) {
            ans.push_back(0);
        } else {
            int cnt = 0;
            while (s[0]!= num) {
                mp[s[0]] = true;
                s.erase(s.begin());
                cnt++;
            }
            s.erase(s.begin());
            cnt++;
            ans.push_back(cnt);
        }
    }
    return ans;
}
--------------------------------
int MaxDistinctChar(string s, int n, int k) {
    map<char, int> freq;
    for (int i = 0; i < n; i++) {
        if (freq.find(s[i])!= freq.end()) {
            freq[s[i]]++;
        } else {
            freq[s[i]] = 1;
        }
    }
    vector<int> v;
    for (auto it : freq) {
        v.push_back(it.second);
    }
    sort(v.begin(), v.end());
    for (int i = 0; i < v.size(); i++) {
        int mn = min(v[i] - 1, k);
        v[i] -= mn;
        k -= mn;
    }
    if (k > 0) {
        for (int i = 0; i < v.size(); i++) {
            int mn = min(v[i], k);
            v[i] -= mn;
            k -= mn;
        }
    }
    int res = 0;
    for (int i = 0; i < v.size(); i++) {
        if (v[i] == 1) {
            res++;
        }
    }
    return res;
}
--------------------------------
int FindKth(vector<int> arr, int n, int k) {
    set<int> missing;
    int count = 0;
    for (int i = 0; i < n; i++) {
        missing.insert(arr[i]);
    }
    int maxM = *max_element(arr.begin(), arr.end());
    int minM = *min_element(arr.begin(), arr.end());
    for (int i = minM + 1; i < maxM; i++) {
        if (missing.find(i) == missing.end()) {
            count++;
        }
        if (count == k) {
            return i;
        }
    }
    return -1;
}
--------------------------------
bool AlmostSort(vector<int> a, int n) {
    for (int i = 0; i < n - 1; i++) {
        if (a[i] > a[i + 1]) {
            swap(a[i], a[i + 1]);
            i++;
        }
    }
    for (int i = 0; i < n - 1; i++) {
        if (a[i] > a[i + 1]) {
            return false;
        }
    }
    return true;
}
--------------------------------
int MaximumSum(string s, int n, int k) {
    int sum = 0;
    vector<int> freq(256, 0);
    for (int i = 0; i < n; i++) {
        freq[s[i]]++;
    }
    sort(freq.rbegin(), freq.rend());
    for (int i = 0; i < 256; i++) {
        if (k > freq[i]) {
            sum += freq[i] * freq[i];
            k -= freq[i];
        } else {
            sum += freq[i] * k;
            break;
        }
    }
    return sum;
}
--------------------------------
int FindMinOperations(vector<int> arr, int n, int k) {
    int operations = 0;
    for (int i = 0; i < k; i++) {
        map<int, int> freq;
        for (int j = i; j < n; j += k) {
            freq[arr[j]]++;
        }
        int max1 = 0, num = 0;
        for (auto entry : freq) {
            if (entry.second > max1) {
                max1 = entry.second;
                num = entry.first;
            }
        }
        for (auto entry : freq) {
            if (entry.first!= num) {
                operations += entry.second;
            }
        }
    }
    return operations;
}
--------------------------------
vector<string> SubString(string s, int n) {
    vector<string> v;
    for (int i = 0; i < n; i++) {
        for (int len = 1; len <= n - i; len++) {
            string find = s.substr(i, len);
            v.push_back(find);
        }
    }
    return v;
}
--------------------------------
bool CheckUniqueFrequency(vector<int> arr, int n) {
    unordered_map<int, int> freq;
    for (int i = 0; i < n; i++) {
        freq[arr[i]]++;
    }
    unordered_set<int> uniqueFreq;
    for (auto entry : freq) {
        if (uniqueFreq.count(entry.second)) {
            return false;
        } else {
            uniqueFreq.insert(entry.second);
        }
    }
    return true;
}
--------------------------------
int MinCost(string str1, string str2, int n) {
    int cost = 0;
    char tmp[n];
    for (int i = 0; i < n; i++) {
        tmp[i] = str1[i];
    }
    for (int i = 0; i < n; i++) {
        if (tmp[i]!= str2[i]) {
            if (i < n - 1 && tmp[i + 1]!= str2[i + 1]) {
                char c = tmp[i];
                tmp[i] = tmp[i + 1];
                tmp[i + 1] = c;
                cost++;
            } else {
                cost++;
            }
        }
    }
    return cost;
}
--------------------------------
bool IsValidNum(string x) {
    map<int, int> mp;
    for (int i = 0; i < x.length(); i++) {
        if (mp.find(x[i] - '0')!= mp.end()) {
            return false;
        } else if (x[i] - '0' > 5) {
            return false;
        } else {
            mp.insert(make_pair(x[i] - '0', 1));
        }
    }
    return true;
}
--------------------------------
int MinimizeDiff(vector<int> arr, int n, int k) {
    int max = *max_element(arr.begin(), arr.end());
    int min = *min_element(arr.begin(), arr.end());
    if (max - min <= k) {
        return max - min;
    }
    int avg = (max + min) / 2;
    for (int i = 0; i < n; i++) {
        if (arr[i] > avg) {
            arr[i] -= k;
        } else {
            arr[i] += k;
        }
    }
    max = *max_element(arr.begin(), arr.end());
    min = *min_element(arr.begin(), arr.end());
    return max - min;
}
--------------------------------
int GetMinCost(vector<int> arr, int n) {
    int min_ele = *min_element(arr.begin(), arr.end());
    return min_ele * (n - 1);
}
--------------------------------
bool Possibility(unordered_map<int, int> m, int length, string s) {
    int countOdd = 0;
    for (int i = 0; i < length; i++) {
        if ((m[s[i] - '0'] & 1)!= 0) {
            countOdd++;
        }
        if (countOdd > 1) {
            return false;
        }
    }
    return true;
}
--------------------------------
int MinimumCostOfBreaking(vector<int> x, vector<int> y, int m, int n) {
    int res = 0;
    sort(x.begin(), x.end(), greater<int>());
    sort(y.begin(), y.end(), greater<int>());
    int hzntl = 1, vert = 1;
    int i = 0, j = 0;
    while (i < m && j < n) {
        if (x[i] > y[j]) {
            res += x[i] * vert;
            hzntl++;
            i++;
        } else {
            res += y[j] * hzntl;
            vert++;
            j++;
        }
    }
    int total = 0;
    while (i < m) {
        total += x[i++];
    }
    res += total * vert;
    total = 0;
    while (j < n) {
        total += y[j++];
    }
    res += total * hzntl;
    return res;
}
--------------------------------
int FindMaximumScore(vector<int> a, int n) {
    map<int, int> freq;
    for (int i = 0; i < n; i++) {
        if (freq.find(a[i])!= freq.end()) {
            freq[a[i]]++;
        } else {
            freq[a[i]] = 1;
        }
    }
    int dp[Collections.max(a) + 1];
    dp[0] = 0;
    dp[1] = freq.find(1)!= freq.end()? freq[1] : 0;
    for (int i = 2; i < dp.length; i++) {
        dp[i] = max(dp[i - 1], dp[i - 2] + (freq.find(i)!= freq.end()? freq[i] : 0) * i);
    }
    return dp[dp.length - 1];
}
--------------------------------
int CountWays(string s, string t, int k, int mod) {
    int n = s.length();
    int a = 0, b = 0;
    for (int i = 0; i < n; i++) {
        string p = s.substr(i, n) + s.substr(0, i);
        if (p == t) {
            a++;
        } else {
            b++;
        }
    }
    int dp1[k + 1], dp2[k + 1];
    if (s == t) {
        dp1[0] = 1;
        dp2[0] = 0;
    } else {
        dp1[0] = 0;
        dp2[0] = 1;
    }
    for (int i = 1; i <= k; i++) {
        dp1[i] = ((dp1[i - 1] * (a - 1)) % mod + (dp2[i - 1] * a) % mod) % mod;
        dp2[i] = ((dp1[i - 1] * (b)) % mod + (dp2[i - 1] * (b - 1)) % mod) % mod;
    }
    return dp1[k];
}
--------------------------------
int FindSubarraySum(vector<int> arr, int n, int k) {
    map<int, int> prevSum;
    int res = 0;
    int currSum = 0;
    for (int i = 0; i < n; i++) {
        currSum += arr[i];
        if (currSum == k) {
            res++;
        }
        if (prevSum.find(currSum - k)!= prevSum.end()) {
            res += prevSum[currSum - k];
        }
        prevSum[currSum]++;
    }
    return res;
}
--------------------------------
int MaximumOccurrence(string s) {
    int n = s.length();
    map<string, int> freq;
    int i, j;
    for (i = 0; i < n; i++) {
        string temp = "";
        temp += s[i];
        freq[temp] = freq.count(temp) + 1;
    }
    for (i = 0; i < n; i++) {
        for (j = i + 1; j < n; j++) {
            string temp = "";
            temp += s[i];
            temp += s[j];
            freq[temp] = freq.count(temp) + 1;
        }
    }
    int answer = INT_MIN;
    for (auto entry : freq) {
        answer = max(answer, entry.second);
    }
    return answer;
}
--------------------------------
int CountCharacters(vector<string> strings, string chars) {
    int res = 0;
    unordered_map<char, int> freq;
    for (int i = 0; i < chars.length(); i++) {
        freq[chars[i]]++;
    }
    for (string st : strings) {
        bool flag = true;
        for (char c : st.c_str()) {
            if (!freq.count(c)) {
                flag = false;
                break;
            }
        }
        if (flag) {
            res += st.length();
        }
    }
    return res;
}
--------------------------------
int DistinctSubstring(string p, string q, int k, int n) {
    set<string> ss;
    for (int i = 0; i < n; ++i) {
        int sum = 0;
        string s = "";
        for (int j = i; j < n; ++j) {
            int pos = p[j] - 'a';
            sum += q[pos] - '0';
            s += p[j];
            if (sum <= k) {
                ss.insert(s);
            } else {
                break;
            }
        }
    }
    return ss.size();
}
--------------------------------
int UniqueMorseRep(vector<string> arr) {
    vector<string> morseCode = {".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."};
    set<string> st;
    int n = arr.size();
    for (int i = 0; i < n; i++) {
        string temp = "";
        int m = arr.at(i).length();
        for (int j = 0; j < m; j++) {
            temp += morseCode.at(arr.at(i).at(j) - 'a');
        }
        st.insert(temp);
    }
    return st.size();
}
--------------------------------
int CountSubstrings(string st, int k) {
    int n = st.size();
    int answer = 0;
    map<char, int> map;
    for (int i = 0; i < k; i++) {
        if (!map.count(st[i])) {
            map[st[i]] = 1;
        } else {
            map[st[i]]++;
        }
    }
    if (map.size() == k) {
        answer++;
    }
    for (int i = k; i < n; i++) {
        if (!map.count(st[i])) {
            map[st[i]] = 1;
        } else {
            map[st[i]]++;
        }
        map[st[i - k]]--;
        if (map[st[i - k]] == 0) {
            map.erase(st[i - k]);
        }
        if (map.size() == k) {
            answer++;
        }
    }
    return answer;
}
--------------------------------
bool CanConstruct(string s, int k) {
    map<char, int> m;
    int p = 0;
    if (s.length() == k) {
        return true;
    }
    for (int i = 0; i < s.length(); i++) {
        m[s[i]]++;
    }
    if (k > s.length()) {
        return false;
    } else {
        for (auto h : m) {
            if (h.second % 2!= 0) {
                p++;
            }
        }
    }
    if (k < p) {
        return false;
    }
    return true;
}
--------------------------------
bool EqualIgnoreCase(string str1, string str2) {
    str1 = str1.toupper();
    str2 = str2.toupper();
    return str1.equals(str2);
}
--------------------------------
int FindLongestSub(string bin) {
    int n = bin.length(), i;
    int sum = 0;
    map<int, int> prevSum;
    int maxLen = 0;
    for (i = 0; i < n; i++) {
        if (bin[i] == '1') {
            sum++;
        } else {
            sum--;
        }
        if (sum > 0) {
            maxLen = i + 1;
        } else if (sum <= 0) {
            if (prevSum.find(sum - 1)!= prevSum.end()) {
                int currLen = i - prevSum[sum - 1];
                maxLen = max(maxLen, currLen);
            }
        }
        if (prevSum.find(sum) == prevSum.end()) {
            prevSum[sum] = i;
        }
    }
    return maxLen;
}
--------------------------------
bool HasAllCodes(string s, int k) {
    set<string> us;
    for (int i = 0; i + k <= s.length(); i++) {
        us.insert(s.substr(i, k));
    }
    return us.size() == (1 << k);
}
--------------------------------
bool CheckPalin(string word) {
    int n = word.length();
    word = word.tolower();
    for (int i = 0; i < n; i++, n--) {
        if (word.charAt(i)!= word.charAt(n - 1)) {
            return false;
        }
    }
    return true;
}
--------------------------------
string Convert(string st) {
    string w = "", z = "";
    st = st.toupper() + " ";
    for (int i = 0; i < st.length(); i++) {
        char ch = st.at(i);
        if (ch!='') {
            w += ch;
        } else {
            z += tolower(w.at(0)) + w.substr(1) + " ";
            w = "";
        }
    }
    return z;
}
--------------------------------
int MaxLines(int n, vector<int> x1, vector<int> y1, vector<int> x2, vector<int> y2) {
    set<double> s;
    double slope;
    for (int i = 0; i < n; ++i) {
        if (x1[i] == x2[i]) {
            slope = INT_MAX;
        } else {
            slope = (y2[i] - y1[i]) * 1.0 / (x2[i] - x1[i]);
        }
        s.insert(slope);
    }
    return s.size();
}
--------------------------------
unordered_map<int, int> PrimeFactor(int n) {
    unordered_map<int, int> primef;
    while (n % 2 == 0) {
        if (primef.count(2)) {
            primef[2] += 1;
        } else {
            primef[2] = 1;
        }
        n /= 2;
    }
    for (int i = 3; i <= sqrt(n); i += 2) {
        while (n % i == 0) {
            if (primef.count(i)) {
                primef[i] += 1;
            } else {
                primef[i] = 1;
            }
            n /= i;
        }
    }
    if (n > 2) {
        primef[n] = 1;
    }
    return primef;
}
--------------------------------
string IsDivisibleByDivisor(int s, int d) {
    s %= d;
    set<int> hashMap;
    hashMap.insert(s);
    for (int i = 0; i <= d; i++) {
        s += s % d;
        s %= d;
        if (hashMap.find(s)!= hashMap.end()) {
            if (s == 0) {
                return "Yes";
            }
            return "No";
        } else {
            hashMap.insert(s);
        }
    }
    return "Yes";
}
--------------------------------
bool OddSum(vector<int> a, int n, int k) {
    set<int> odd;
    set<int> even;
    for (int i = 0; i < n; i++) {
        if (a[i] % 2 == 0) {
            even.insert(a[i]);
        } else {
            odd.insert(a[i]);
        }
    }
    if (odd.size() >= k) {
        return true;
    }
    bool flag = false;
    for (int i = 1; i < k; i += 2) {
        int needed = k - i;
        if (needed <= even.size()) {
            return true;
        }
    }
    return flag;
}
--------------------------------
int DayOfYear(string date) {
    vector<int> days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    int year = stoi(date.substr(0, 4));
    int month = stoi(date.substr(5, 7));
    int day = stoi(date.substr(8));
    if (month > 2 && (year % 4 == 0 && (year % 100!= 0 || year % 400 == 0))) {
        ++day;
    }
    while (month > 1) {
        day = day + days[month - 2];
        --month;
    }
    return day;
}
--------------------------------
bool IsPerfectSquare(vector<int> arr, int n) {
    unordered_map<int, int> umap;
    for (int i = 0; i < n; i++) {
        umap[arr[i]]++;
    }
    for (auto itr : umap) {
        if (itr.second % 2 == 1) {
            return false;
        }
    }
    return true;
}
--------------------------------
int MinMoves(int n) {
    string s = to_string(n);
    int ans = INT_MAX;
    int length = s.length();
    for (int i = 0; i < length; ++i) {
        for (int j = 0; j < length; ++j) {
            if (i == j) {
                continue;
            }
            char t[length];
            int cur = 0;
            for (int k = i; k < length - 1; ++k) {
                char c = s[k];
                t[k] = s[k + 1];
                t[k + 1] = c;
                ++cur;
            }
            for (int k = j - (j > i? 1 : 0); k < length - 2; ++k) {
                char c = t[k];
                t[k] = t[k + 1];
                t[k + 1] = c;
                ++cur;
            }
            int pos = -1;
            for (int k = 0; k < length; ++k) {
                if (t[k]!= '0') {
                    pos = k;
                    break;
                }
            }
            for (int k = pos; k > 0; --k) {
                char c = t[k];
                t[k] = t[k - 1];
                t[k - 1] = c;
                ++cur;
            }
            int nn = stoi(string(t));
            if (nn % 25 == 0) {
                ans = min(ans, cur);
            }
        }
    }
    if (ans == INT_MAX) {
        return -1;
    }
    return ans;
}
--------------------------------
int MinimumOperations(vector<int> a, int n) {
    unordered_map<int, int> mp;
    for (int i = 0; i < n; i++) {
        mp[a[i]]++;
    }
    int count = 0;
    for (auto entry : mp) {
        if (entry.second > 1) {
            count += entry.second - 1;
        }
    }
    return count;
}
--------------------------------
int KaprekarRec(int n, int prev) {
    if (n == 0) {
        return 0;
    }
    prev = n;
    int digits[4];
    for (int i = 0; i < 4; i++) {
        digits[i] = n % 10;
        n = n / 10;
    }
    sort(digits, 0, 4);
    int asc = 0;
    for (int i = 0; i < 4; i++) {
        asc = asc * 10 + digits[i];
    }
    sort(digits, 0, 4);
    int desc = 0;
    for (int i = 3; i >= 0; i--) {
        desc = desc * 10 + digits[i];
    }
    int diff = abs(asc - desc);
    if (diff == prev) {
        return diff;
    }
    return KaprekarRec(diff, prev);
}
--------------------------------
string FractionToDecimal(int numr, int denr) {
    string res = "";
    unordered_map<int, int> mp;
    int rem = numr % denr;
    while (rem!= 0 && mp.find(rem) == mp.end()) {
        mp[rem] = res.size();
        rem = rem * 10;
        int resPart = rem / denr;
        res += to_string(resPart);
        rem = rem % denr;
    }
    if (rem == 0) {
        return "";
    }
    if (mp.find(rem)!= mp.end()) {
        return res.substr(mp[rem]);
    }
    return "";
}
--------------------------------
bool IsFancy(string num) {
    map<char, char> fp;
    fp['0'] = '0';
    fp['1'] = '1';
    fp['6'] = '9';
    fp['8'] = '8';
    fp['9'] = '6';
    int n = num.length();
    int l = 0, r = n - 1;
    while (l <= r) {
        if (fp.find(num[l]) == fp.end() || fp[num[l]]!= num[r]) {
            return false;
        }
        l++;
        r--;
    }
    return true;
}
--------------------------------
double DistinctOddRatio(vector<int> numbers) {
    int distinctCount = (int)numbers.size();
    int distinctOddCount = 0;
    for (int n : numbers) {
        if (n % 2 == 1) {
            distinctOddCount++;
        }
    }
    return (double)distinctOddCount / distinctCount;
}
--------------------------------
int CompareSum(vector<int> numbers, vector<string> words) {
    int intSum = accumulate(numbers.begin(), numbers.end(), 0);
    int wordLengthSum = accumulate(words.begin(), words.end(), 0, [](int a, string b) { return a + b.length(); });
    if (intSum < wordLengthSum) {
        return -1;
    }
    if (intSum > wordLengthSum) {
        return 1;
    }
    return 0;
}
--------------------------------
bool AllLongerThan(vector<string> short_words, vector<string> long_words) {
    int max_of_short = *max_element(short_words.begin(), short_words.end(), [](const string& a, const string& b) { return a.length() < b.length(); });
    int min_of_long = *min_element(long_words.begin(), long_words.end(), [](const string& a, const string& b) { return a.length() < b.length(); });
    return min_of_long > max_of_short;
}
--------------------------------
int CompareOddEvenRange(vector<int> numbers) {
    int rangeOdd = *max_element(numbers.begin(), numbers.end(), [](int a, int b) { return a % 2!= b % 2; }) - *min_element(numbers.begin(), numbers.end(), [](int a, int b) { return a % 2!= b % 2; });
    int rangeEven = *max_element(numbers.begin(), numbers.end(), [](int a, int b) { return a % 2 == b % 2; }) - *min_element(numbers.begin(), numbers.end(), [](int a, int b) { return a % 2 == b % 2; });
    if (rangeOdd < rangeEven) {
        return -1;
    }
    if (rangeOdd > rangeEven) {
        return 1;
    }
    return 0;
}
--------------------------------
double AverageDistinctLength(vector<string> words) {
    double averageLen = 0;
    for (string word : words) {
        if (find(words.begin(), words.end(), word) == words.end()) {
            averageLen += word.length();
        }
    }
    return averageLen / words.size();
}
--------------------------------
int WithDrawBalance(int start, vector<int> withdrawals) {
    int end = accumulate(withdrawals.begin(), withdrawals.end(), start, [](int balance, int nextWithdrawal) {
        return nextWithdrawal <= balance? balance - nextWithdrawal : balance;
    });
    return end;
}
--------------------------------
string FirstShortAndStartsWithO(vector<string> words) {
    string matchedElement = "";
    for (string w : words) {
        if (w.length() < 5 && w[0] == 'o') {
            matchedElement = w;
            break;
        }
    }
    return matchedElement;
}
--------------------------------
int BigNumberAtIndex(vector<int> numbers, int index) {
    int targetNum = *find_if(numbers.begin() + index, numbers.end(), [](int n) { return n > 5; });
    return targetNum;
}
--------------------------------
bool ContainsSquareInRange(int range_start, int range_length) {
    return std::any_of(range_start, range_start + range_length, [](int n) {
        return std::pow(std::sqrt(n), 2) == n;
    });
}
--------------------------------
unordered_map<int, vector<int> > GroupNumbersByMod(vector<int> numbers, int mod) {
    unordered_map<int, vector<int> > numberGroups;
    for (int number : numbers) {
        int remainder = number % mod;
        if (numberGroups.find(remainder) == numberGroups.end()) {
            numberGroups[remainder] = vector<int>();
        }
        numberGroups[remainder].push_back(number);
    }
    return numberGroups;
}
--------------------------------
unordered_map<char, vector<string> > GroupWordsByFirstChar(vector<string> words) {
    unordered_map<char, vector<string> > wordGroups;
    for (string word : words) {
        char firstChar = word[0];
        if (wordGroups.find(firstChar) == wordGroups.end()) {
            wordGroups[firstChar] = vector<string>();
        }
        wordGroups[firstChar].push_back(word);
    }
    return wordGroups;
}
--------------------------------
vector<string> OrderByLengthAndDescending(vector<string> words) {
    vector<string> sortedWords = words;
    sort(sortedWords.begin(), sortedWords.end(), [](string a, string b) {
        return a.length() < b.length();
    });
    return sortedWords;
}
--------------------------------
vector<string> OrderFirstCharDescendingReverse(vector<string> words) {
    vector<string> sortedWords = words;
    sort(sortedWords.begin(), sortedWords.end(), [](string a, string b) {
        return a[0] > b[0] || (a[0] == b[0] && a > b);
    });
    reverse(sortedWords.begin(), sortedWords.end());
    return sortedWords;
}
--------------------------------
vector<int> GetSubListOfNegative(vector<int> numbers, int start, int length) {
    vector<int> subList;
    for (int i = start; i < start + length; i++) {
        if (numbers[i] < 0) {
            subList.push_back(numbers[i]);
        }
    }
    return subList;
}
--------------------------------
vector<int> GetPositiveSequence(vector<int> numbers) {
    vector<int> subSequence;
    for (int i = 0; i < numbers.size(); i++) {
        if (numbers[i] > 0) {
            subSequence.push_back(numbers[i]);
        }
    }
    return subSequence;
}
--------------------------------
vector<int> GetLargerThanIndexSequence(vector<int> numbers) {
    vector<int> subSequence;
    for (int i = 0; i < numbers.size(); i++) {
        if (numbers[i] >= i) {
            subSequence.push_back(numbers[i]);
        }
    }
    return subSequence;
}
--------------------------------
vector<string> RearrangeWordByIndexes(vector<string> words, vector<int> indexes) {
    vector<int> newIndexes;
    for (int i = 0; i < indexes.size(); i++) {
        if (indexes[i] >= words.size()) {
            newIndexes.push_back(indexes[i] % words.size());
        }
    }
    vector<string> newWords;
    for (int i = 0; i < newIndexes.size(); i++) {
        newWords.push_back(words[newIndexes[i]]);
    }
    return newWords;
}
--------------------------------
vector<vector<string> > GetWordsUpperLower(vector<string> words) {
    vector<vector<string> > upperLowerWords;
    for (string word : words) {
        upperLowerWords.push_back({word.upper(), word.lower()});
    }
    return upperLowerWords;
}
--------------------------------
vector<bool> SelectIfInPlace(vector<int> numbers) {
    vector<bool> numsInPlace;
    for (int index = 0; index < numbers.size(); index++) {
        numsInPlace.push_back(numbers[index] == index);
    }
    return numsInPlace;
}
--------------------------------
vector<vector<int> > SelectPairs(vector<int> numbers_a, vector<int> numbers_b) {
    vector<vector<int> > pairs;
    for (int a : numbers_a) {
        for (int b : numbers_b) {
            if (a < b) {
                pairs.push_back({a, b});
            }
        }
    }
    return pairs;
}
--------------------------------
vector<string> StringCrossJoin(vector<string> end_words, vector<string> begin_words) {
    vector<string> cross_strings;
    for (auto b : begin_words) {
        for (auto e : end_words) {
            if (b[0] == e[e.size() - 1]) {
                cross_strings.push_back(e + " " + b);
            }
        }
    }
    return cross_strings;
}
--------------------------------
int ElementsContainSubword(vector<string> words, string subword) {
    if (words.size() > 5) {
        return -1;
    }
    for (string word : words) {
        if (!word.contains(subword)) {
            return 0;
        }
    }
    return 1;
}
--------------------------------
vector<int> ConcatLargeNumbers(vector<int> numbers_a, vector<int> numbers_b, int flag) {
    vector<int> all_numbers;
    for (int number_a : numbers_a) {
        if (number_a > flag) {
            all_numbers.push_back(number_a);
        }
    }
    for (int number_b : numbers_b) {
        if (number_b > flag) {
            all_numbers.push_back(number_b);
        }
    }
    return all_numbers;
}
--------------------------------
int DotProduct(vector<int> vector_a, vector<int> vector_b) {
    int dot_product = 0;
    for (int i = 0; i < vector_a.size(); i++) {
        dot_product += vector_a[i] * vector_b[i];
    }
    return dot_product;
}
--------------------------------
vector<int> SetDifference(vector<int> set_a, vector<int> set_b) {
    vector<int> difference = set_a;
    difference.insert(difference.end(), set_b.begin(), set_b.end());
    vector<int> intersection = set_a;
    intersection.erase(std::remove_if(intersection.begin(), intersection.end(), [&set_b](int i) { return std::find(set_b.begin(), set_b.end(), i) == set_b.end(); }), intersection.end());
    difference.erase(std::remove_if(difference.begin(), difference.end(), [&intersection](int i) { return std::find(intersection.begin(), intersection.end(), i)!= intersection.end(); }), difference.end());
    std::sort(difference.begin(), difference.end());
    return difference;
}
--------------------------------
