int greatestCommonDivisor(int a, int b) {
    if (a == 0 || b == 0) {
        return a + b;
    }
    if (a == b) {
        return a;
    }
    if (a > b) {
        return greatestCommonDivisor(a % b, b);
    } else {
        return greatestCommonDivisor(a, b % a);
    }
}
--------------------------------
int largestDivisor(int n) {
    for (int i = 2; i <= n; i++) {
        if (n % i == 0) {
            return i;
        }
    }
    return 1;
}
--------------------------------
boolean isPrime(int n) {
    if (n < 2) {
        return false;
    }
    for (int k = 2; k < n; k++) {
        if (n % k == 0) {
            return false;
        }
    }
    return true;
}
--------------------------------
int fizzBuzz(int n) {
    int count = 0;
    for (int i = 0; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            int q = i;
            while (q > 0) {
                if (q % 10 == 7) {
                    count++;
                }
                q /= 10;
            }
        }
    }
    return count;
}
--------------------------------
int primeFib(int n) {
    int f0 = 0;
    int f1 = 1;
    while (n > 0) {
        int p = f0 + f1;
        boolean isPrime = p >= 2;
        for (int i = 2; i < p; i++) {
            if (p % i == 0) {
                isPrime = false;
                break;
            }
        }
        if (isPrime) {
            n -= 1;
        }
        f0 = f1;
        f1 = p;
    }
    return f1;
}
--------------------------------
double triangleArea(double a, double h) {
    return a * h / 2;
}
--------------------------------
int modP(int n, int p) {
    int ret = 1;
    for (int i = 0; i < n; i++) {
        ret = (ret * 2) % p;
    }
    return ret;
}
--------------------------------
int add(int x, int y) {
    return x + y;
}
--------------------------------
int fib(int n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    return fib(n - 1) + fib(n - 2);
}
--------------------------------
int largestPrimeFactor(int n) {
    for (int i = 2; i < n; i++) {
        while (n % i == 0 && n > i) {
            n /= i;
        }
    }
    return n;
}
--------------------------------
int sumToN(int n) {
    int result = 0;
    for (int i = 1; i <= n; i++) {
        result += i;
    }
    return result;
}
--------------------------------
int fibfib(int n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 0;
    }
    if (n == 2) {
        return 1;
    }
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);
}
--------------------------------
boolean isMultiplyPrime(int a) {
    int num = 0;
    for (int i = 2; i <= a; i++) {
        while (a % i == 0) {
            a /= i;
            num++;
        }
    }
    return num == 3;
}
--------------------------------
boolean isSimplePower(int x, int n) {
    if (n == 1) {
        return x == 1;
    }
    int power = 1;
    while (power < x) {
        power *= n;
    }
    return power == x;
}
--------------------------------
int chooseNum(int x, int y) {
    if (x > y) {
        return -1;
    }
    if (y % 2 == 0) {
        return y;
    }
    if (x == y) {
        return -1;
    }
    return y - 1;
}
--------------------------------
boolean isEqualToSumEven(int n) {
    return n % 2 == 0 && n >= 8;
}
--------------------------------
int specialFactorial(int n) {
    int fact = 1;
    int specialFact = 1;
    for (int i = 1; i <= n; i++) {
        fact *= i;
        specialFact *= fact;
    }
    return specialFact;
}
--------------------------------
int xOrY(int n, int x, int y) {
    boolean isPrime = n >= 2;
    for (int i = 2; i < n; i++) {
        if (n % i == 0) {
            isPrime = false;
            break;
        }
    }
    if (isPrime) {
        return x;
    }
    return y;
}
--------------------------------
boolean rightAngleTriangle(int a, int b, int c) {
    return (a * a == b * b + c * c) || (b * b == a * a + c * c) || (c * c == a * a + b * b);
}
--------------------------------
int fastPow(int n, int k) {
    if (k == 0) {
        return 1;
    }
    int temp = fastPow(n, k / 2);
    if (k % 2 == 0) {
        return temp * temp;
    } else {
        return n * temp * temp;
    }
}
--------------------------------
boolean isPalin(String s) {
    int l = s.length() / 2;
    for (int i = 0; i < l; i++) {
        if (s.charAt(i)!= s.charAt(s.length() - i - 1)) {
            return false;
        }
    }
    return true;
}
--------------------------------
int findSum(int n) {
    int ans = 0;
    int temp = 0;
    for (int i = 1; i <= n; i++) {
        if (temp < n) {
            temp = i - 1;
            int num = 1;
            while (temp < n) {
                if (temp + i <= n) {
                    ans += i * num;
                } else {
                    ans += (n - temp) * num;
                }
                temp += i;
                num += 1;
            }
        }
    }
    return ans;
}
--------------------------------
int getNextGap(int gap) {
    gap = (int) (gap * 10 / 13);
    if (gap < 1) {
        return 1;
    }
    return gap;
}
--------------------------------
int countNonDecreasing(int n) {
    int k = 10;
    int count = 1;
    for (int i = 1; i <= n; i++) {
        count *= k + i - 1;
        count /= i;
    }
    return count;
}
--------------------------------
int power(int x, int y) {
    if (y == 0) {
        return 1;
    } else if (y % 2 == 0) {
        return power(x, y / 2) * power(x, y / 2);
    } else {
        return x * power(x, y / 2) * power(x, y / 2);
    }
}
--------------------------------
double power(double x, int y) {
    if (y == 0) {
        return 1;
    }
    double temp = power(x, y / 2);
    if (y % 2 == 0) {
        return temp * temp;
    } else {
        if (y > 0) {
            return x * temp * temp;
        } else {
            return temp * temp / x;
        }
    }
}
--------------------------------
int multiply(int x, int y) {
    if (y == 0) {
        return 0;
    }
    if (y > 0) {
        return x + multiply(x, y - 1);
    }
    if (y < 0) {
        return - multiply(x, - y);
    }
}
--------------------------------
int smallest(int x, int y, int z) {
    if (y % x!= 0) {
        return y;
    } else {
        return z;
    }
}
--------------------------------
boolean isPowerOfFour(int n) {
    if (n == 0) {
        return false;
    }
    while (n!= 1) {
        if (n % 4!= 0) {
            return false;
        }
        n = n / 4;
    }
    return true;
}
--------------------------------
int modInverse(int a, int m) {
    int m0 = m;
    int x0 = 0, x1 = 1;
    if (m == 1) return 0;
    while (a > 1) {
        int q = a / m;
        int t = m;
        m = a % m;
        a = t;
        t = x0;
        x0 = x1 - q * x0;
        x1 = t;
    }
    if (x1 < 0) x1 += m0;
    return x1;
}
--------------------------------
int cntRotations(String s, int n) {
    String s2 = s + s;
    int[] pre = new int[2 * n];
    for (int i = 0; i < 2 * n; i++) {
        if (i!= 0) {
            pre[i] += pre[i - 1];
        }
        if (s2.charAt(i) == 'a' || s2.charAt(i) == 'e' || s2.charAt(i) == 'i' || s2.charAt(i) == 'o' || s2.charAt(i) == 'u') {
            pre[i] += 1;
        }
    }
    int ans = 0;
    for (int i = n - 1; i < 2 * n - 1; i++) {
        int r = i, l = i - n;
        int x1 = pre[r];
        if (l >= 0) {
            x1 -= pre[l];
        }
        r = i - n / 2;
        int left = pre[r];
        if (l >= 0) {
            left -= pre[l];
        }
        int right = x1 - left;
        if (left > right) {
            ans += 1;
        }
    }
    return ans;
}
--------------------------------
int binomialCoeff(int n, int k) {
    int res = 1;
    if (k > n - k) {
        k = n - k;
    }
    for (int i = 0; i < k; i++) {
        res *= n - i;
        res /= i + 1;
    }
    return res;
}
--------------------------------
boolean isPrefix(String temp, String s) {
    if (temp.length() < s.length()) {
        return false;
    }
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i)!= temp.charAt(i)) {
            return false;
        }
    }
    return true;
}
--------------------------------
String lexicographicallySmallestString(String s, int n) {
    int lastZe = -1;
    String ans = "";
    for (int i = n - 1; i >= 0; i--) {
        if (s.charAt(i) == '0') {
            lastZe = i;
            break;
        }
    }
    for (int i = 0; i < n; i++) {
        if (i <= lastZe && s.charAt(i) == '0') {
            ans += s.charAt(i);
        } else if (i > lastZe) {
            ans += s.charAt(i);
        }
    }
    return ans;
}
--------------------------------
int calculateMax(int n, int m, int k) {
    int low = 0, high = m;
    int ans = -1;
    while (low <= high) {
        int mid = (low + high) / 2;
        int val = 0;
        int l = k - 1;
        int r = n - k;
        val += mid;
        if (mid >= l) {
            val += l * (2 * mid - l - 1) / 2;
        } else {
            val += mid * (mid - 1) / 2 + (l - mid);
        }
        if (mid >= r) {
            val += r * (2 * mid - r - 1) / 2;
        } else {
            val += mid * (mid - 1) / 2 + (r - mid);
        }
        if (val <= m) {
            ans = Math.max(ans, mid);
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return ans;
}
--------------------------------
int findLength(String s, char i, char j) {
    int required = i;
    int length = 0;
    for (char curr : s.toCharArray()) {
        if (curr == required) {
            length++;
            if (required == i) {
                required = j;
            } else {
                required = i;
            }
        }
    }
    return length;
}
--------------------------------
boolean checkReverse(int leftSum, int rightSum) {
    int rev = 0;
    int temp = rightSum;
    while (temp!= 0) {
        rev = rev * 10 + temp % 10;
        temp /= 10;
    }
    return (rev == leftSum);
}
--------------------------------
boolean isComposite(int n) {
    if (n <= 1) {
        return false;
    }
    if (n <= 3) {
        return false;
    }
    if (n % 2 == 0 || n % 3 == 0) {
        return true;
    }
    for (int i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return true;
        }
    }
    return false;
}
--------------------------------
int minDeletion(String s) {
    int n = s.length();
    int first_idx1 = -1;
    int last_idx0 = -1;
    for (int i = 0; i < n; i++) {
        if (s.charAt(i) == '1') {
            first_idx1 = i;
            break;
        }
    }
    for (int i = n - 1; i >= 0; i--) {
        if (s.charAt(i) == '0') {
            last_idx0 = i;
            break;
        }
    }
    if (first_idx1 == -1 || last_idx0 == -1) {
        return 0;
    }
    int count1 = 0;
    int count0 = 0;
    for (int i = 0; i < last_idx0; i++) {
        if (s.charAt(i) == '1') {
            count1++;
        }
    }
    for (int i = first_idx1 + 1; i < n; i++) {
        if (s.charAt(i) == '0') {
            count0++;
        }
    }
    return Math.min(count0, count1);
}
--------------------------------
int minSteps(String s, int n) {
    int cost = 0;
    int[] f = new int[26];
    for (int i = 0; i < n; i++) {
        int currEle = s.charAt(i) - 'a';
        int smaller = 0;
        for (int j = currEle + 1; j < 26; j++) {
            if (f[j]!= 0) {
                smaller += f[j];
            }
        }
        if (smaller == 0) {
            cost += i + 1;
        } else {
            cost += i - smaller + 1;
        }
        f[s.charAt(i) - 'a'] += 1;
    }
    return cost;
}
--------------------------------
int numberOfWays(int n) {
    int count = 0;
    for (int a = 1; a < n; a++) {
        for (int b = 1; b < n; b++) {
            int c = n - (a + b);
            if (a < b + c && b < a + c && c < a + b) {
                count++;
            }
        }
    }
    return count;
}
--------------------------------
int slopeOfNum(String num, int n) {
    int slope = 0;
    for (int i = 1; i < n - 1; i++) {
        if (num.charAt(i) > num.charAt(i - 1) && num.charAt(i) > num.charAt(i + 1)) {
            slope++;
        } else if (num.charAt(i) < num.charAt(i - 1) && num.charAt(i) < num.charAt(i + 1)) {
            slope++;
        }
    }
    return slope;
}
--------------------------------
int middleOfThree(int a, int b, int c) {
    int x = a - b;
    int y = b - c;
    int z = a - c;
    if (x * y > 0) {
        return b;
    } else if (x * z > 0) {
        return c;
    } else {
        return a;
    }
}
--------------------------------
int countMaxSetBits(int left, int right) {
    while ((left | (left + 1)) <= right) {
        left |= left + 1;
    }
    return left;
}
--------------------------------
int findS(int s) {
    int l = 1;
    int r = s / 2 + 1;
    while (l <= r) {
        int mid = (l + r) / 2;
        int sum = mid * (mid + 1) / 2;
        if (sum == s) {
            return mid;
        } else if (sum > s) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return -1;
}
--------------------------------
boolean check(String s) {
    int min = Integer.MAX_VALUE;
    int max = Integer.MIN_VALUE;
    int sum = 0;
    for (int i = 0; i < s.length(); i++) {
        int ascii = s.charAt(i);
        if (ascii < 97 || ascii > 122) {
            return false;
        }
        sum += ascii;
        if (min > ascii) {
            min = ascii;
        }
        if (max < ascii) {
            max = ascii;
        }
    }
    min -= 1;
    int e_sum = max * (max + 1) / 2 - min * (min + 1) / 2;
    return sum == e_sum;
}
--------------------------------
int minimumPossibleProduct(int k) {
    int res = 1;
    int r = (1 << k) - 1;
    for (int i = 0; i < k; i++) {
        res *= r - 1;
    }
    res *= r;
    return res;
}
--------------------------------
int findInGrid(int i, int j) {
    if (i == j) {
        return i * i - (i - 1);
    } else if (i > j) {
        if (i % 2 == 0) {
            return i * i - (j - 1);
        } else {
            return (i - 1) * (i - 1) + 1 + (j - 1);
        }
    } else {
        if (j % 2 == 0) {
            return (j - 1) * (j - 1) + 1 + (i - 1);
        } else {
            return j * j - (i - 1);
        }
    }
}
--------------------------------
int findMinOperationsReqEmpStr(String s) {
    int cnt_one = 0;
    int cnt_zero = 0;
    int n = s.length();
    for (int i = 0; i < n; i++) {
        if (s.charAt(i) == '0') {
            if (cnt_one > 0) {
                cnt_one--;
            }
            cnt_zero++;
        } else {
            if (cnt_zero > 0) {
                cnt_zero--;
            }
            cnt_one++;
        }
    }
    return cnt_one + cnt_zero;
}
--------------------------------
boolean isReachable(int x1, int y1, int x2, int y2) {
    while (x2 > x1 && y2 > y1) {
        if (x2 > y2) {
            x2 %= y2;
        } else {
            y2 %= x2;
        }
    }
    if (x2 == x1) {
        return y2 - y1 >= 0 && (y2 - y1) % x1 == 0;
    } else if (y2 == y1) {
        return x2 - x1 >= 0 && (x2 - x1) % y1 == 0;
    } else {
        return false;
    }
}
--------------------------------
int findMaxSoln(int n, int x, int y) {
    int ans = Integer.MIN_VALUE;
    for (int k = 0; k <= n; k++) {
        if (k % x == y) {
            ans = Math.max(ans, k);
        }
    }
    return ans;
}
--------------------------------
int numberOfPairs(int n) {
    int count = 0;
    int i = 1;
    int j = n - 1;
    while (i < j) {
        if (i + j == n) {
            count++;
        }
        i++;
        j--;
    }
    return count;
}
--------------------------------
int minChanges(String s, int n) {
    int count = 0, zeros = 0, ones = 0;
    if (s.charAt(0)!= '1') {
        count++;
        ones++;
    }
    for (int i = 1; i < n; i++) {
        if (s.charAt(i) == '0') {
            zeros++;
        } else {
            ones++;
        }
        if (zeros > ones) {
            zeros--;
            ones++;
            count++;
        }
    }
    return count;
}
--------------------------------
int kVisibleFromLeft(int n, int k) {
    if (n == k) {
        return 1;
    }
    if (k == 1) {
        int ans = 1;
        for (int i = 1; i < n; i++) {
            ans *= i;
        }
        return ans;
    }
    return kVisibleFromLeft(n - 1, k - 1) + (n - 1) * kVisibleFromLeft(n - 1, k);
}
--------------------------------
double find(int n, int sum) {
    if (sum > 6 * n || sum < n) {
        return 0;
    }
    if (n == 1) {
        if (sum >= 1 && sum <= 6) {
            return 1.0 / 6;
        } else {
            return 0;
        }
    }
    double s = 0;
    for (int i = 1; i < 7; i++) {
        s += find(n - 1, sum - i) / 6;
    }
    return s;
}
--------------------------------
int binCoff(int n, int r) {
    int val = 1;
    if (r > (n - r)) {
        r = n - r;
    }
    for (int i = 0; i < r; i++) {
        val *= (n - i);
        val /= (i + 1);
    }
    return val;
}
--------------------------------
int getMask(int val) {
    int mask = 0;
    if (val == 0) {
        return 1;
    }
    while (val) {
        int d = val % 10;
        mask |= (1 << d);
        val /= 10;
    }
    return mask;
}
--------------------------------
int waysToKAdjacentSetBits(int n, int k, int currentIndex, int adjacentSetBits, int lastBit) {
    if (currentIndex == n) {
        if (adjacentSetBits == k) {
            return 1;
        }
        return 0;
    }
    int noOfWays = 0;
    if (lastBit == 1) {
        noOfWays += waysToKAdjacentSetBits(n, k, currentIndex + 1, adjacentSetBits + 1, 1);
        noOfWays += waysToKAdjacentSetBits(n, k, currentIndex + 1, adjacentSetBits, 0);
    } else if (lastBit!= 1) {
        noOfWays += waysToKAdjacentSetBits(n, k, currentIndex + 1, adjacentSetBits, 1);
        noOfWays += waysToKAdjacentSetBits(n, k, currentIndex + 1, adjacentSetBits, 0);
    }
    return noOfWays;
}
--------------------------------
int checkFunc(int i, int j, String st) {
    if (st.charAt(i) == '(' && st.charAt(j) == ')') {
        return 1;
    }
    if (st.charAt(i) == '(' && st.charAt(j) == '?') {
        return 1;
    }
    if (st.charAt(i) == '?' && st.charAt(j) == ')') {
        return 1;
    }
    if (st.charAt(i) == '[' && st.charAt(j) == ']') {
        return 1;
    }
    if (st.charAt(i) == '[' && st.charAt(j) == '?') {
        return 1;
    }
    if (st.charAt(i) == '?' && st.charAt(j) == ']') {
        return 1;
    }
    if (st.charAt(i) == '{' && st.charAt(j) == '}') {
        return 1;
    }
    if (st.charAt(i) == '{' && st.charAt(j) == '?') {
        return 1;
    }
    if (st.charAt(i) == '?' && st.charAt(j) == '}') {
        return 1;
    }
    return 0;
}
--------------------------------
int findGolomb(int n) {
    if (n == 1) {
        return 1;
    }
    return 1 + findGolomb(n - findGolomb(findGolomb(n - 1)));
}
--------------------------------
boolean allOnes(String s, int n) {
    int co = 0;
    for (int i = 0; i < s.length(); i++) {
        co += 1 if (s.charAt(i) == '1') else 0;
    }
    return co == n;
}
--------------------------------
int pad(int n) {
    int p_prev_prev = 1, p_prev = 1, p_curr = 1, p_next = 1;
    for (int i = 3; i <= n; i++) {
        p_next = p_prev_prev + p_prev;
        p_prev_prev = p_prev;
        p_prev = p_curr;
        p_curr = p_next;
    }
    return p_next;
}
--------------------------------
int oddLengthPalindrome(int k) {
    int palin = k;
    k = k / 10;
    while (k > 0) {
        int rev = k % 10;
        palin = palin * 10 + rev;
        k = k / 10;
    }
    return palin;
}
--------------------------------
String changeString(String s0) {
    char[] s = s0.toCharArray();
    int n = s0.length();
    if (s[0] == '?') {
        s[0] = 'a';
        if (s[0] == s[1]) {
            s[0] = (char) (s[0] + 1);
        }
    }
    for (int i = 1; i < n - 1; i++) {
        if (s[i] == '?') {
            s[i] = 'a';
            if (s[i] == s[i - 1]) {
                s[i] = (char) (s[i] + 1);
            }
            if (s[i] == s[i + 1]) {
                s[i] = (char) (s[i] + 1);
            }
            if (s[i] == s[i - 1]) {
                s[i] = (char) (s[i] + 1);
            }
        }
    }
    if (s[n - 1] == '?') {
        s[n - 1] = 'a';
        if (s[n - 1] == s[n - 2]) {
            s[n - 1] = (char) (s[n - 1] + 1);
        }
    }
    return String.valueOf(s);
}
--------------------------------
int totalHammingDistance(int n) {
    int i = 1, sum = 0;
    while (n / i > 0) {
        sum = sum + n / i;
        i = i * 2;
    }
    return sum;
}
--------------------------------
int checkBitonic(String s) {
    int i = 1;
    for (i = 1; i < s.length(); i++) {
        if (s.charAt(i) > s.charAt(i - 1)) {
            continue;
        }
        if (s.charAt(i) <= s.charAt(i - 1)) {
            break;
        }
    }
    if (i == s.length() - 1) {
        return 1;
    }
    int j = i + 1;
    for (j = i + 1; j < s.length(); j++) {
        if (s.charAt(j) < s.charAt(j - 1)) {
            continue;
        }
        if (s.charAt(j) >= s.charAt(j - 1)) {
            break;
        }
    }
    i = j;
    if (i!= s.length() - 1) {
        return 0;
    }
    return 1;
}
--------------------------------
boolean endsWith(String str, String pat) {
    int patLen = pat.length();
    int strLen = str.length();
    if (patLen > strLen) {
        return false;
    }
    patLen -= 1;
    strLen -= 1;
    while (patLen >= 0) {
        if (pat.charAt(patLen)!= str.charAt(strLen)) {
            return false;
        }
        patLen -= 1;
        strLen -= 1;
    }
    return true;
}
--------------------------------
int getSum(int n, int d) {
    if (n < d) {
        return 0;
    }
    while (n % 10!= d) {
        n -= 1;
    }
    int k = n / 10;
    return (k + 1) * d + (k * 10 + 10 * k * k) / 2;
}
--------------------------------
int balancedStringBySwapping(String s) {
    int unbalanced_pair = 0;
    for (int i = 0; i < s.length(); i++) {
        if (unbalanced_pair > 0 && s.charAt(i) == ']') {
            unbalanced_pair--;
        } else if (s.charAt(i) == '[') {
            unbalanced_pair++;
        }
    }
    return (unbalanced_pair + 1) / 2;
}
--------------------------------
int computeHash(String s) {
    int p = 31;
    int mod = 10 ** 9 + 7;
    int hashVal = 0;
    int mul = 1;
    for (char ch : s.toCharArray()) {
        hashVal = (hashVal + (ch - 'a' + 1) * mul) % mod;
        mul = mul * p % mod;
    }
    return hashVal;
}
--------------------------------
int countOfSubstringWithOnlyOnes(String s) {
    int res = 0, count = 0;
    for (int i = 0; i < s.length(); i++) {
        count = count + 1 if s.charAt(i) == '1' else 0;
        res = res + count;
    }
    return res;
}
--------------------------------
int composite(int n) {
    int flag = 0;
    int c = 0;
    for (int j = 1; j <= n; j++) {
        if (n % j == 0) {
            c += 1;
        }
    }
    if (c >= 3) {
        flag = 1;
    }
    return flag;
}
--------------------------------
boolean isDivBySix(String s, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += (int)(s.charAt(i) - 'a') + 1;
    }
    if (sum % 3!= 0) {
        return false;
    }
    int lastDigit = (int)(s.charAt(n - 1) - 'a') + 1;
    if (lastDigit % 2!= 0) {
        return false;
    }
    return true;
}
--------------------------------
boolean IsRedundantBraces(String s) {
    int a = 0, b = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '(' && s.charAt(i + 2) == ')') {
            return true;
        }
        if (s.charAt(i) == '*' || s.charAt(i) == '+' || s.charAt(i) == '-' || s.charAt(i) == '/') {
            a++;
        }
        if (s.charAt(i) == '(') {
            b++;
        }
    }
    if (b > a) {
        return true;
    }
    return false;
}
--------------------------------
int countSubStr(String s, int n) {
    int count = 0;
    int i = 0;
    while (i < (n - 2)) {
        if (s.charAt(i) == '0' && s.charAt(i + 1) == '1' && s.charAt(i + 2) == '0') {
            count++;
            i += 3;
        } else if (s.charAt(i) == '1' && s.charAt(i + 1) == '0' && s.charAt(i + 2) == '1') {
            count++;
            i += 3;
        } else {
            i++;
        }
    }
    return count;
}
--------------------------------
int prefixOccurrences(String s) {
    char c = s.charAt(0);
    int countC = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == c) {
            countC++;
        }
    }
    return countC;
}
--------------------------------
boolean isValid(String s, int len) {
    for (int i = 1; i < len; i++) {
        if (s.charAt(i) == s.charAt(i - 1)) {
            return false;
        }
    }
    return true;
}
--------------------------------
int count(String s, int k) {
    int n = s.length();
    int d = 0;
    int count = 0;
    for (int i = 0; i < n; i++) {
        d += s.charAt(i);
    }
    if (d % k == 0) {
        count += 1;
    }
    for (int i = k; i < n; i++) {
        int prev = s.charAt(i - k);
        d -= prev;
        d += s.charAt(i);
        if (d % k == 0) {
            count += 1;
        }
    }
    return count;
}
--------------------------------
int findSubstringCount(String s) {
    int result = 0;
    int n = s.length();
    int i = 0;
    while (i < n - 1) {
        if (s.charAt(i) + 1 == s.charAt(i + 1)) {
            result += 1;
            while (i < n - 1 && s.charAt(i) + 1 == s.charAt(i + 1)) {
                i += 1;
            }
        }
        i += 1;
    }
    return result;
}
--------------------------------
boolean find(String s1, String s2) {
    int len1 = s1.length();
    int len2 = s2.length();
    if (len1!= len2) {
        return false;
    }
    int[] d = new int[len1];
    d[0] = s2.charAt(0) - s1.charAt(0);
    for (int i = 1; i < len1; i++) {
        if (s1.charAt(i) > s2.charAt(i)) {
            return false;
        } else {
            d[i] = s2.charAt(i) - s1.charAt(i);
        }
    }
    for (int i = len1 - 1; i >= 0; i--) {
        if (d[i] < d[i + 1]) {
            return false;
        }
    }
    return true;
}
--------------------------------
boolean isInGivenBase(String s, int bas) {
    if (bas > 16) {
        return false;
    } else if (bas <= 10) {
        for (int i = 0; i < s.length(); i++) {
            if (!(s.charAt(i) >= '0' && s.charAt(i) < '0' + bas)) {
                return false;
            }
        }
    } else {
        for (int i = 0; i < s.length(); i++) {
            if (!(s.charAt(i) >= '0' && s.charAt(i) < '0' + bas || s.charAt(i) >= 'A' && s.charAt(i) < 'A' + bas - 10)) {
                return false;
            }
        }
    }
    return true;
}
--------------------------------
int countNonEmptySubstr(String s) {
    int n = s.length();
    return n * (n + 1) / 2;
}
--------------------------------
int evenDecimalValue(String s, int n) {
    int result = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            int decimalValue = 0;
            int powerOf2 = 1;
            for (int k = i; k <= j; k++) {
                decimalValue += (s.charAt(k) - '0') * powerOf2;
                powerOf2 *= 2;
            }
            if (decimalValue % 2 == 0) {
                result += 1;
            }
        }
    }
    return result;
}
--------------------------------
int calculate(String s) {
    int ans = 6;
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            for (int k = 0; k < 10; k++) {
                for (int l = 0; l < 10; l++) {
                    for (int m = 0; m < 10; m++) {
                        for (int n = 0; n < 10; n++) {
                            if (i + j + k == l + m + n) {
                                int c = 0;
                                if (i!= s.charAt(0) - '0') {
                                    c++;
                                }
                                if (j!= s.charAt(1) - '0') {
                                    c++;
                                }
                                if (k!= s.charAt(2) - '0') {
                                    c++;
                                }
                                if (l!= s.charAt(3) - '0') {
                                    c++;
                                }
                                if (m!= s.charAt(4) - '0') {
                                    c++;
                                }
                                if (n!= s.charAt(5) - '0') {
                                    c++;
                                }
                                if (c < ans) {
                                    ans = c;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return ans;
}
--------------------------------
int xorZero(String s) {
    int oneCount = 0;
    int zeroCount = 0;
    int n = s.length();
    for (int i = 0; i < n; i++) {
        if (s.charAt(i) == '1') {
            oneCount++;
        } else {
            zeroCount++;
        }
    }
    if (oneCount % 2 == 0) {
        return zeroCount;
    }
    return oneCount;
}
--------------------------------
String evenLength(String n) {
    String res = n;
    for (int j = n.length() - 1; j >= 0; j--) {
        res += n.charAt(j);
    }
    return res;
}
--------------------------------
int countSubstringWithEqualEnds(String s) {
    int result = 0;
    int n = s.length();
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            if (s.charAt(i) == s.charAt(j)) {
                result++;
            }
        }
    }
    return result;
}
--------------------------------
double normalSlope(double a, double b, double x1, double y1) {
    double g = a / 2;
    double f = b / 2;
    if (g - x1 == 0) {
        return -1;
    }
    double slope = (f - y1) / (g - x1);
    if (slope == 0) {
        return -2;
    }
    return slope;
}
--------------------------------
boolean orthogonality(int x1, int y1, int x2, int y2, int r1, int r2) {
    int dsquare = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
    if (dsquare == r1 * r1 + r2 * r2) {
        return true;
    } else {
        return false;
    }
}
--------------------------------
double findAreaShaded(double a) {
    double sqArea = a * a;
    double semiCircleArea = (3.14 * (a * a) / 8);
    double shadedArea = 4 * semiCircleArea - sqArea;
    return shadedArea;
}
--------------------------------
int factorial(int a, int b) {
    int res = 1;
    for (int i = 1; i <= a + b + 1; i++) {
        res = res * i;
    }
    for (int i = 1; i <= a + 1; i++) {
        res = res / i;
    }
    for (int i = 1; i <= b + 1; i++) {
        res = res / i;
    }
    return res;
}
--------------------------------
int factorTree(int n) {
    int height = 0;
    while (n > 1) {
        boolean flag = false;
        for (int i = 2; i <= Math.sqrt(n); i++) {
            if (n % i == 0) {
                n = n / i;
                flag = true;
                break;
            }
        }
        height += 1;
        if (!flag) {
            break;
        }
    }
    return height;
}
--------------------------------
String findIfPossible(int n, int s, int x) {
    if (s >= x && s % 2 == x % 2) {
        if (n >= 3) {
            return "Yes";
        }
        if (n == 1) {
            if (s == x) {
                return "Yes";
            } else {
                return "No";
            }
        }
        if (n == 2) {
            int c = (s - x) / 2;
            int a = c;
            int b = c;
            a = a + x;
            if ((a ^ b) == x) {
                return "Yes";
            } else {
                return "No";
            }
        }
    } else {
        return "No";
    }
}
--------------------------------
int maximumTripletXor(int a, int b, int c) {
    int ans = 0;
    for (int i = 30; i >= 0; i--) {
        int cur = 1 << i;
        if (a >= cur) {
            ans += cur;
            a -= cur;
        } else if (b >= cur) {
            ans += cur;
            b -= cur;
        } else if (c >= cur) {
            ans += cur;
            c -= cur;
        }
    }
    return ans;
}
--------------------------------
int itemType(int n) {
    int count = 0;
    int day = 1;
    while (count + day * (day + 1) / 2 < n) {
        count += day * (day + 1) / 2;
        day += 1;
    }
    for (int type = day; type >= 0; type--) {
        count += type;
        if (count >= n) {
            return type;
        }
    }
    return 0;
}
--------------------------------
int maxGcdInRange(int l, int r) {
    int ans = 1;
    for (int z = r; z > 0; z--) {
        if ((r / z) - ((l - 1) / z) > 1) {
            ans = z;
            break;
        }
    }
    return ans;
}
--------------------------------
int sumOfDigits(int n) {
    int sum = 0;
    while (n!= 0) {
        sum += (n % 10);
        n = n / 10;
    }
    return sum;
}
--------------------------------
boolean isRepUnitNum(int n, int b) {
    int length = 0;
    int count_one = 0;
    while (n!= 0) {
        int r = n % b;
        length += 1;
        if (r == 1) {
            count_one += 1;
        }
        n = n / b;
    }
    return count_one >= 3 && count_one == length;
}
--------------------------------
boolean isStraightLineNum(int n) {
    if (n <= 99) {
        return false;
    }
    String s = String.valueOf(n);
    int d = s.charAt(1) - s.charAt(0);
    for (int i = 2; i < s.length(); i++) {
        if (s.charAt(i) - s.charAt(i - 1)!= d) {
            return false;
        }
    }
    return true;
}
--------------------------------
int getCount(int d, int n) {
    int no = n / d;
    int result = no;
    for (int p = 2; p * p <= no; p++) {
        if (no % p == 0) {
            while (no % p == 0) {
                no /= p;
            }
            result -= result / p;
        }
    }
    if (no > 1) {
        result -= result / no;
    }
    return result;
}
--------------------------------
boolean isEvenParity(int x) {
    int parity = 0;
    while (x!= 0) {
        if (x & 1) {
            parity += 1;
        }
        x = x >> 1;
    }
    if (parity % 2 == 0) {
        return true;
    } else {
        return false;
    }
}
--------------------------------
int isPerfect(int n) {
    int sum = 1;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            sum += i;
            if (i * i!= n) {
                sum += n / i;
            }
        }
    }
    return sum == n && n!= 1? n : 0;
}
--------------------------------
int logAToBaseB(int a, int b) {
    if (a > (b - 1)) {
        return 1 + logAToBaseB(a / b, b);
    } else {
        return 0;
    }
}
--------------------------------
int usingBinarySearch(int start, int end, int n, int s) {
    if (start >= end) {
        return start;
    }
    int mid = start + (end - start) / 2;
    int totalSum = (n * (n + 1)) / 2;
    int midSum = (mid * (mid + 1)) / 2;
    if (totalSum - midSum <= s) {
        return usingBinarySearch(start, mid, n, s);
    }
    return usingBinarySearch(mid + 1, end, n, s);
}
--------------------------------
String minInt(String s) {
    char[] s1 = s.toCharArray();
    for (int i = 0; i < s.length(); i++) {
        if (s1[i] >= '5') {
            s1[i] = (char) ('9' - s1[i] + '0');
        }
    }
    if (s1[0] == '0') {
        s1[0] = '9';
    }
    return String.valueOf(s1);
}
--------------------------------
int countTriplets(int a, int b, int c) {
    int ans = 0;
    for (int i = 1; i <= a; i++) {
        for (int j = 1; j <= b; j++) {
            for (int k = 1; k <= c; k++) {
                if (i * k > j * j) {
                    ans++;
                }
            }
        }
    }
    return ans;
}
--------------------------------
boolean topsyTurvy(String s) {
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '2' || s.charAt(i) == '4' || s.charAt(i) == '5' || s[i] == '6' || s[i] == '7' || s[i] == '9') {
            return false;
        }
    }
    return true;
}
--------------------------------
int sumOfLastDig(int n, int m) {
    int sum = 0;
    int k = n / m;
    int[] arr = new int[10];
    for (int i = 0; i < 10; i++) {
        arr[i] = (m * (i + 1)) % 10;
        sum += arr[i];
    }
    int rem = k % 10;
    int ans = k / 10 * sum;
    for (int i = 0; i < rem; i++) {
        ans += arr[i];
    }
    return ans;
}
--------------------------------
int totalPay(int totalItems, int priceOfOneItem, int n, int m) {
    int freeItems = 0;
    int actual = 0;
    freeItems = totalItems / (n + m);
    actual = totalItems - freeItems;
    int amount = actual * priceOfOneItem;
    return amount;
}
--------------------------------
int minOperations(int x, int y, int p, int q) {
    if (y % x!= 0) {
        return -1;
    }
    int d = y / x;
    int a = 0;
    while (d % p == 0) {
        d /= p;
        a += 1;
    }
    int b = 0;
    while (d % q == 0) {
        d /= q;
        b += 1;
    }
    if (d!= 1) {
        return -1;
    }
    return a + b;
}
--------------------------------
boolean isMersenne(int n) {
    while (n!= 0) {
        int r = n % 2;
        if (r == 0) {
            return false;
        }
        n /= 2;
    }
    return true;
}
--------------------------------
int findThirdDigit(int n) {
    if (n < 3) {
        return 0;
    }
    return 1 & n? 6 : 0;
}
--------------------------------
boolean isOddLength(int num) {
    int count = 0;
    while (num > 0) {
        num = num / 10;
        count += 1;
    }
    if (count % 2!= 0) {
        return true;
    }
    return false;
}
--------------------------------
boolean checkIsPossible(int l, int r, int k) {
    int count = 0;
    for (int i = l; i <= r; i++) {
        if (i % k == 0) {
            count++;
        }
    }
    return count > 1;
}
--------------------------------
int bytes(int kilobytes) {
    int b = kilobytes * 1024;
    return b;
}
--------------------------------
int octahedralNum(int n) {
    return n * (2 * n * n + 1) / 3;
}
--------------------------------
String checkEqual(String s) {
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i)!= '1' && s.charAt(i)!= '0' && s.charAt(i)!= '8') {
            return "No";
        }
    }
    int start = 0;
    int end = s.length() - 1;
    while (start < end) {
        if (s.charAt(start)!= s.charAt(end)) {
            return "No";
        }
        start++;
        end--;
    }
    return "Yes";
}
--------------------------------
boolean isUndulating(String n) {
    if (n.length() <= 2) {
        return false;
    }
    for (int i = 2; i < n.length(); i++) {
        if (n.charAt(i - 2)!= n.charAt(i)) {
            return false;
        }
    }
    return true;
}
--------------------------------
int firstDigit(int n) {
    while (n >= 10) {
        n /= 10;
    }
    return n;
}
--------------------------------
int countDigit(int n) {
    if (n == 0) {
        return 0;
    }
    return 1 + countDigit(n / 10);
}
--------------------------------
boolean isDivisibleBy5(String s) {
    int n = s.length();
    return s.charAt(n - 1) == '0' || s.charAt(n - 1) == '5';
}
--------------------------------
int inv(int a, int m) {
    int m0 = m;
    int x0 = 0, x1 = 1;
    if (m == 1) {
        return 0;
    }
    while (a > 1) {
        int q = a / m;
        int t = m;
        m = a % m;
        a = t;
        t = x0;
        x0 = x1 - q * x0;
        x1 = t;
    }
    if (x1 < 0) {
        x1 = x1 + m0;
    }
    return x1;
}
--------------------------------
boolean onlyFirstAndLastAreSet(int n) {
    if (n == 1) {
        return true;
    }
    if (n == 2) {
        return false;
    }
    return ((n - 1) & (n - 2)) == 0;
}
--------------------------------
int divide(int dividend, int divisor) {
    int sign = - 1;
    if ((dividend < 0) ^ (divisor < 0)) {
        sign = 1;
    }
    dividend = Math.abs(dividend);
    divisor = Math.abs(divisor);
    int quotient = 0;
    int temp = 0;
    for (int i = 31; i >= 0; i--) {
        if (temp + (divisor << i) <= dividend) {
            temp += divisor << i;
            quotient |= 1 << i;
        }
    }
    return sign * quotient;
}
--------------------------------
char findProfession(int level, int pos) {
    if (level == 1) {
        return 'e';
    }
    if (findProfession(level - 1, (pos + 1) / 2) == 'd') {
        return 'd' if (pos % 2) else 'e';
    }
    return 'e' if (pos % 2) else 'd';
}
--------------------------------
boolean hasCloseElements(List<Double> numbers, double threshold) {
    for (int i = 0; i < numbers.size(); i++) {
        for (int j = i + 1; j < numbers.size(); j++) {
            double distance = Math.abs(numbers.get(i) - numbers.get(j));
            if (distance < threshold) {
                return true;
            }
        }
    }
    return false;
}
--------------------------------
double truncateNumber(double number) {
    return number % 1;
}
--------------------------------
boolean belowZero(List<Integer> operations) {
    int balance = 0;
    for (int op : operations) {
        balance += op;
        if (balance < 0) {
            return true;
        }
    }
    return false;
}
--------------------------------
double meanAbsoluteDeviation(List<Double> numbers) {
    double sum = 0;
    for (double num : numbers) {
        sum += num;
    }
    double mean = sum / numbers.size();
    double sumAbsDiff = 0;
    for (double num : numbers) {
        sumAbsDiff += Math.abs(num - mean);
    }
    return sumAbsDiff / numbers.size();
}
--------------------------------
List<Integer> intersperse(List<Integer> numbers, int delimiter) {
    List<Integer> result = new ArrayList<>();
    if (numbers.isEmpty()) {
        return result;
    }
    for (int i = 0; i < numbers.size() - 1; i++) {
        result.add(numbers.get(i));
        result.add(delimiter);
    }
    result.add(numbers.get(numbers.size() - 1));
    return result;
}
--------------------------------
List<Integer> sumProduct(List<Integer> numbers) {
    int sum = 0;
    int prod = 1;
    for (int n : numbers) {
        sum += n;
        prod *= n;
    }
    return Arrays.asList(sum, prod);
}
--------------------------------
List<String> allPrefixes(String s) {
    List<String> result = new ArrayList<>();
    for (int i = 1; i <= s.length(); i++) {
        result.add(s.substring(0, i));
    }
    return result;
}
--------------------------------
List<Integer> parseMusic(String musicString) {
    List<Integer> result = new ArrayList<>();
    List<String> current = new ArrayList<>();
    for (int i = 0; i < musicString.length() + 1; i++) {
        if (i == musicString.length() || musicString.charAt(i) =='') {
            if (current.stream().collect(Collectors.joining()).equals("o")) {
                result.add(4);
            }
            if (current.stream().collect(Collectors.joining()).equals("o|")) {
                result.add(2);
            }
            if (current.stream().collect(Collectors.joining()).equals(".|")) {
                result.add(1);
            }
            current.clear();
        } else {
            current.add(String.valueOf(musicString.charAt(i)));
        }
    }
    return result;
}
--------------------------------
int strlen(String s) {
    return s.length();
}
--------------------------------
List<Integer> factorize(int n) {
    List<Integer> factors = new ArrayList<>();
    int i = 2;
    while (i <= n) {
        if (n % i == 0) {
            factors.add(i);
            n /= i;
        } else {
            i += 1;
        }
    }
    return factors;
}
--------------------------------
String concatenate(List<String> strings) {
    StringBuilder result = new StringBuilder();
    for (String s : strings) {
        result.append(s);
    }
    return result.toString();
}
--------------------------------
List<Double> getPositive(List<Double> l) {
    List<Double> result = new ArrayList<>();
    for (int i = 0; i < l.size(); i++) {
        if (l.get(i) > 0) {
            result.add(l.get(i));
        }
    }
    return result;
}
--------------------------------
List<Double> sortEven(List<Double> l) {
    List<Double> evens = new ArrayList<>();
    for (int i = 0; i < l.size(); i += 2) {
        evens.add(l.get(i));
    }
    Collections.sort(evens);
    List<Double> result = new ArrayList<>();
    for (int i = 0; i < l.size(); i++) {
        if (i % 2 == 0) {
            result.add(evens.get(i / 2));
        }
        if (i % 2 == 1) {
            result.add(l.get(i));
        }
    }
    return result;
}
--------------------------------
String decodeCyclic(String s) {
    List<String> output = new ArrayList<>();
    int i = 0;
    while (i <= s.length() - 3) {
        String x = s.substring(i + 2, i + 3) + s.substring(i, i + 2);
        output.add(x);
        i += 3;
    }
    return String.join("", output) + s.substring(i);
}
--------------------------------
int carRaceCollision(int n) {
    return n * n;
}
--------------------------------
List<Integer> incrList(List<Integer> l) {
    List<Integer> result = new ArrayList<>();
    for (Integer i : l) {
        result.add(i + 1);
    }
    return result;
}
--------------------------------
boolean pairsSumToZero(List<Integer> l) {
    for (int i = 0; i < l.size(); i++) {
        for (int j = i + 1; j < l.size(); j++) {
            if (l.get(i) + l.get(j) == 0) {
                return true;
            }
        }
    }
    return false;
}
--------------------------------
String changeBase(int x, int b) {
    String ret = "";
    while (x > 0) {
        ret = ret + x % b;
        x = x / b;
    }
    return ret;
}
--------------------------------
double median(List<Double> l) {
    l.sort(Comparator.naturalOrder());
    if (l.size() % 2 == 1) {
        return l.get(l.size() / 2);
    } else {
        return (l.get(l.size() / 2 - 1) + l.get(l.size() / 2)) / 2.0;
    }
}
--------------------------------
String decodeShift(String s) {
    String result = "";
    for (char ch : s.toCharArray()) {
        int w = (int) ch + 21 - (int) 'a';
        w = (w % 26) + (int) 'a';
        result += (char) w;
    }
    return result;
}
--------------------------------
boolean belowThreshold(List<Integer> l, int t) {
    for (int n : l) {
        if (n >= t) {
            return false;
        }
    }
    return true;
}
--------------------------------
boolean correctBracketing(String brackets) {
    int depth = 0;
    for (char b : brackets.toCharArray()) {
        if (b == '<') {
            depth++;
        } else {
            depth--;
        }
        if (depth < 0) {
            return false;
        }
    }
    return depth == 0;
}
--------------------------------
boolean monotonic(List<Double> l) {
    int incr = 0;
    int decr = 0;
    for (int i = 1; i < l.size(); i++) {
        if (l.get(i) > l.get(i - 1)) {
            incr = 1;
        }
        if (l.get(i) < l.get(i - 1)) {
            decr = 1;
        }
    }
    return incr + decr!= 2;
}
--------------------------------
List<Double> derivative(List<Double> xs) {
    List<Double> result = new ArrayList<>();
    for (int i = 1; i < xs.size(); i++) {
        result.add(i * xs.get(i));
    }
    return result;
}
--------------------------------
int vowelsCount(String s) {
    String vowels = "aeiouAEIOU";
    int count = 0;
    for (char ch : s.toCharArray()) {
        if (vowels.contains(ch)) {
            count++;
        }
    }
    if (s.endsWith("y") || s.endsWith("Y")) {
        count++;
    }
    return count;
}
--------------------------------
int digitSum(String s) {
    int sum = 0;
    for (char c : s.toCharArray()) {
        if (Character.isUpperCase(c)) {
            sum += c;
        }
    }
    return sum;
}
--------------------------------
int fruitDistribution(String s, int n) {
    List<Character> num1 = new ArrayList<>();
    List<Character> num2 = new ArrayList<>();
    boolean flag = false;
    for (int i = 0; i < s.length(); i++) {
        if (Character.isDigit(s.charAt(i))) {
            if (!flag) {
                num1.add(s.charAt(i));
            }
            if (flag) {
                num2.add(s.charAt(i));
            }
        } else if (!flag && num1.size() > 0) {
            flag = true;
        }
    }
    return n - Integer.parseInt(String.valueOf(num1)) - Integer.parseInt(String.valueOf(num2));
}
--------------------------------
List<Integer> pluck(List<Integer> arr) {
    List<Integer> result = new ArrayList<>();
    for (int i = 0; i < arr.size(); i++) {
        if (arr.get(i) % 2 == 0) {
            if (result.isEmpty()) {
                result.add(arr.get(i));
                result.add(i);
            } else if (arr.get(i) < result.get(0)) {
                result.set(0, arr.get(i));
                result.set(1, i);
            }
        }
    }
    return result;
}
--------------------------------
List<Integer> strangeSortList(List<Integer> lst) {
    List<Integer> res = new ArrayList<>();
    lst.sort(Comparator.naturalOrder());
    int l = 0;
    int r = lst.size() - 1;
    while (l < r) {
        res.add(lst.get(l));
        l += 1;
        res.add(lst.get(r));
        r -= 1;
    }
    if (l == r) {
        res.add(lst.get(l));
    }
    return res;
}
--------------------------------
double triangleArea(double a, double b, double c) {
    if (a + b <= c || a + c <= b || b + c <= a) {
        return -1.0;
    }
    double s = (a + b + c) / 2;
    double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));
    return area;
}
--------------------------------
boolean willItFly(List<Integer> q, int w) {
    int sum = 0;
    for (int i = 0; i < q.size(); i++) {
        if (q.get(i)!= q.get(q.size() - 1 - i)) {
            return false;
        }
        sum += q.get(i);
    }
    return sum <= w;
}
--------------------------------
boolean isCube(int a) {
    a = Math.abs(a);
    int i = (int) Math.round(Math.pow(a, 1.0 / 3));
    return i * i * i == a;
}
--------------------------------
int hexKey(String num) {
    String key = "2357BD";
    int total = 0;
    for (char c : num.toCharArray()) {
        if (key.contains(c)) {
            total++;
        }
    }
    return total;
}
--------------------------------
String decimalToBinary(int dec) {
    String ans = "";
    if (dec!= 0) {
        while (dec > 0) {
            ans = ans + (dec % 2);
            dec /= 2;
        }
    } else {
        ans += "0";
    }
    return "db" + ans + "db";
}
--------------------------------
boolean primeLength(String s) {
    int l = s.length();
    if (l < 2) {
        return false;
    }
    for (int i = 2; i < l; i++) {
        if (l % i == 0) {
            return false;
        }
    }
    return true;
}
--------------------------------
int startsOneEnds(int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    return 18 * (int) Math.pow(10, n - 2);
}
--------------------------------
int add(List<Integer> lst) {
    int sum = 0;
    for (int i = 1; i < lst.size(); i += 2) {
        if (lst.get(i) % 2 == 0) {
            sum += lst.get(i);
        }
    }
    return sum;
}
--------------------------------
List<List<Integer> > getRow(List<List<Integer> > lst, int x) {
    List<List<Integer> > coords = new ArrayList<>();
    for (int i = 0; i < lst.size(); i++) {
        for (int j = lst.get(i).size() - 1; j >= 0; j--) {
            if (lst.get(i).get(j) == x) {
                coords.add(Arrays.asList(i, j));
            }
        }
    }
    return coords;
}
--------------------------------
int nextSmallest(List<Integer> lst) {
    lst.sort(Comparator.naturalOrder());
    for (int i = 1; i < lst.size(); i++) {
        if (lst.get(i)!= lst.get(i - 1)) {
            return lst.get(i);
        }
    }
    return -1;
}
--------------------------------
boolean anyInt(double a, double b, double c) {
    if (Math.round(a)!= a || Math.round(b)!= b || Math.round(c)!= c) {
        return false;
    }
    return a + b == c || a + c == b || b + c == a;
}
--------------------------------
List<Integer> countUpTo(int n) {
    List<Integer> primes = new ArrayList<>();
    for (int i = 2; i < n; i++) {
        boolean isPrime = true;
        for (int j = 2; j < i; j++) {
            if (i % j == 0) {
                isPrime = false;
                break;
            }
        }
        if (isPrime) {
            primes.add(i);
        }
    }
    return primes;
}
--------------------------------
int closestInteger(String value) {
    double w = Double.parseDouble(value);
    return Math.round(w);
}
--------------------------------
List<Integer> makeAPile(int n) {
    List<Integer> result = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        result.add(n + 2 * i);
    }
    return result;
}
--------------------------------
List<String> wordStrings(String s) {
    List<String> words = new ArrayList<>();
    List<Character> current = new ArrayList<>();
    for (int i = 0; i < s.length() + 1; i++) {
        if (i == s.length() || s.charAt(i) =='' || s.charAt(i) == ',') {
            if (current.size() > 0) {
                words.add(String.valueOf(current));
                current.clear();
            }
        } else {
            current.add(s.charAt(i));
        }
    }
    return words;
}
--------------------------------
String roundedAvg(int n, int m) {
    if (n > m) {
        return "-1";
    }
    int num = (n + m) / 2;
    StringBuilder ret = new StringBuilder();
    while (num > 0) {
        ret.insert(0, num % 2);
        num /= 2;
    }
    return ret.toString();
}
--------------------------------
List<Integer> uniqueDigits(List<Integer> x) {
    List<Integer> digits = new ArrayList<>();
    for (int n : x) {
        boolean isUnique = true;
        for (char c : String.valueOf(n).toCharArray()) {
            if (c % 2 == 0) {
                isUnique = false;
                break;
            }
        }
        if (isUnique) {
            digits.add(n);
        }
    }
    digits.sort(Comparator.naturalOrder());
    return digits;
}
--------------------------------
int countNums(List<Integer> arr) {
    int num = 0;
    for (int n : arr) {
        int neg = -1;
        if (n < 0) {
            neg = 1;
        }
        n = Math.abs(n);
        List<Integer> digits = new ArrayList<>();
        for (char c : String.valueOf(n).toCharArray()) {
            digits.add(c - '0');
        }
        digits.set(0, digits.get(0) * neg);
        int sum = 0;
        for (int d : digits) {
            sum += d;
        }
        if (sum > 0) {
            num += 1;
        }
    }
    return num;
}
--------------------------------
boolean moveOneBall(List<Integer> arr) {
    if (arr == null) {
        return true;
    }
    int num = 0;
    for (int i = 1; i < arr.size(); i++) {
        if (arr.get(i) < arr.get(i - 1)) {
            num++;
        }
    }
    if (arr.get(arr.size() - 1) > arr.get(0)) {
        num++;
    }
    if (num < 2) {
        return true;
    }
    return false;
}
--------------------------------
String exchange(List<Integer> lst1, List<Integer> lst2) {
    int odd = 0;
    int even = 0;
    for (int n : lst1) {
        if (n % 2 == 1) {
            odd++;
        }
    }
    for (int n : lst2) {
        if (n % 2 == 0) {
            even++;
        }
    }
    if (even >= odd) {
        return "YES";
    }
    return "NO";
}
--------------------------------
List<String> oddCount(List<String> lst) {
    List<String> results = new ArrayList<>();
    String originalStr = "the number of odd elements in the string i of the input.";
    for (String s : lst) {
        int sum = 0;
        for (char d : s.toCharArray()) {
            if (Character.isDigit(d) && (d - '0') % 2 == 1) {
                sum += 1;
            }
        }
        List<Character> result = new ArrayList<>();
        for (char c : originalStr.toCharArray()) {
            if (c == 'i') {
                result.add(String.valueOf(sum).charAt(0));
            } else {
                result.add(c);
            }
        }
        results.add(String.valueOf(result));
    }
    return results;
}
--------------------------------
int minSubArraySum(List<Integer> nums) {
    int minSum = Integer.MAX_VALUE;
    int sum = 0;
    for (int num : nums) {
        sum += num;
        if (minSum > sum) {
            minSum = sum;
        }
        if (sum > 0) {
            sum = 0;
        }
    }
    return minSum;
}
--------------------------------
int maxFill(List<List<Integer> > grid, int capacity) {
    int res = 0;
    for (List<Integer> well : grid) {
        int sum = 0;
        for (int n : well) {
            sum += n;
        }
        if (sum > 0) {
            res += (sum - 1) / capacity + 1;
        }
    }
    return res;
}
--------------------------------
List<String> selectWords(String s, int n) {
    List<String> result = new ArrayList<>();
    List<String> current = new ArrayList<>();
    int consonantNum = 0;
    for (int i = 0; i < s.length() + 1; i++) {
        if (i == s.length() || s.charAt(i) =='') {
            if (consonantNum == n) {
                result.add(String.join("", current));
            }
            current.clear();
            consonantNum = 0;
        } else {
            current.add(s.charAt(i) + "");
            if (s.charAt(i)!= 'a' && s.charAt(i)!= 'e' && s.charAt(i)!= 'i' && s.charAt(i)!= 'o' && s.charAt(i)!= 'u' && s.charAt(i)!= 'A' && s.charAt(i)!= 'E' && s.charAt(i)!= 'I' && s.charAt(i)!= 'O' && s.charAt(i)!= 'U') {
                consonantNum++;
            }
        }
    }
    return result;
}
--------------------------------
int solution(List<Integer> lst) {
    int sum = 0;
    for (int i = 0; i < lst.size(); i += 2) {
        if (lst.get(i) % 2 == 1) {
            sum += lst.get(i);
        }
    }
    return sum;
}
--------------------------------
int addElements(List<Integer> arr, int k) {
    int sum = 0;
    for (int i = 0; i < k; i++) {
        if (-99 <= arr.get(i) && arr.get(i) <= 99) {
            sum += arr.get(i);
        }
    }
    return sum;
}
--------------------------------
List<Integer> getOddCollatz(int n) {
    List<Integer> oddCollatz = new ArrayList<>();
    while (n > 1) {
        if (n % 2 == 1) {
            oddCollatz.add(n);
            n = n * 3 + 1;
        } else {
            n /= 2;
        }
    }
    oddCollatz.add(1);
    oddCollatz.sort(Comparator.naturalOrder());
    return oddCollatz;
}
--------------------------------
boolean isSorted(List<Integer> lst) {
    for (int i = 1; i < lst.size(); i++) {
        if (lst.get(i) < lst.get(i - 1)) {
            return false;
        }
        if (i >= 2 && lst.get(i) == lst.get(i - 1) && lst.get(i) == lst.get(i - 2)) {
            return false;
        }
    }
    return true;
}
--------------------------------
String intersection(List<Integer> interval1, List<Integer> interval2) {
    int inter1 = Math.max(interval1.get(0), interval2.get(0));
    int inter2 = Math.min(interval1.get(1), interval2.get(1));
    int l = inter2 - inter1;
    if (l < 2) {
        return "NO";
    }
    for (int i = 2; i < l; i++) {
        if (l % i == 0) {
            return "NO";
        }
    }
    return "YES";
}
--------------------------------
int prodSigns(List<Integer> arr) {
    if (arr.size() == 0) {
        return -32768;
    }
    int sum = 0;
    int prods = 1;
    for (int i : arr) {
        sum += Math.abs(i);
        if (i == 0) {
            prods = 0;
        }
        if (i < 0) {
            prods = -prods;
        }
    }
    return sum * prods;
}
--------------------------------
List<Integer> minPath(List<List<Integer> > grid, int k) {
    int n = grid.size();
    int min_num = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (grid.get(i).get(j) == 1) {
                List<Integer> tmp = new ArrayList<>();
                if (i!= 0) {
                    tmp.add(grid.get(i - 1).get(j));
                }
                if (j!= 0) {
                    tmp.add(grid.get(i).get(j - 1));
                }
                if (i!= n - 1) {
                    tmp.add(grid.get(i + 1).get(j));
                }
                if (j!= n - 1) {
                    tmp.add(grid.get(i).get(j + 1));
                }
                min_num = Math.min(tmp);
            }
        }
    }
    List<Integer> ans = new ArrayList<>();
    for (int i = 0; i < k; i++) {
        if (i % 2 == 0) {
            ans.add(1);
        } else {
            ans.add(min_num);
        }
    }
    return ans;
}
--------------------------------
int digits(int n) {
    int prod = 1;
    for (char digit : String.valueOf(n).toCharArray()) {
        if (digit % 2 == 1) {
            if (prod == 0) {
                prod = 1;
            }
            prod *= digit - '0';
        }
    }
    return prod;
}
--------------------------------
boolean isNested(String s) {
    int count = 0;
    int maxCount = 0;
    for (char ch : s.toCharArray()) {
        if (ch == '[') {
            count++;
        }
        if (ch == ']') {
            count--;
        }
        if (count < 0) {
            count = 0;
        }
        if (count > maxCount) {
            maxCount = count;
        }
        if (count <= maxCount - 2) {
            return true;
        }
    }
    return false;
}
--------------------------------
int sumSquares(List<Double> lst) {
    double sum = 0;
    for (double i : lst) {
        sum += Math.ceil(i) * Math.ceil(i);
    }
    return sum;
}
--------------------------------
int canArrange(List<Integer> arr) {
    int index = -1;
    for (int i = 0; i < arr.size(); i++) {
        if (arr.get(i) <= i) {
            index = i;
        }
    }
    return index;
}
--------------------------------
List<Integer> largestSmallestIntegers(List<Integer> lst) {
    int maxNeg = 0, minPos = 0;
    for (int n : lst) {
        if (n < 0 && (maxNeg == 0 || n > maxNeg)) {
            maxNeg = n;
        }
        if (n > 0 && (minPos == 0 || n < minPos)) {
            minPos = n;
        }
    }
    return Arrays.asList(maxNeg, minPos);
}
--------------------------------
String fixSpaces(String text) {
    List<Character> res = new ArrayList<>();
    int spaceLen = 0;
    for (int i = 0; i < text.length() + 1; i++) {
        if (i == text.length() || text.charAt(i)!='') {
            if (spaceLen == 1) {
                res.add('_');
            }
            if (spaceLen == 2) {
                res.add('__');
            }
            if (spaceLen > 2) {
                res.add('-');
            }
            spaceLen = 0;
            if (i!= text.length()) {
                res.add(text.charAt(i));
            }
        } else {
            spaceLen++;
        }
    }
    return String.valueOf(res);
}
--------------------------------
String filenameCheck(String fileName) {
    int digitNum = 0, dotNum = 0;
    if (fileName.length() < 5 ||!Character.isLetter(fileName.charAt(0))) {
        return "No";
    }
    String suffix = fileName.substring(fileName.length() - 4);
    if (!suffix.equals(".txt") &&!suffix.equals(".exe") &&!suffix.equals(".dll")) {
        return "No";
    }
    for (char c : fileName.toCharArray()) {
        if (Character.isDigit(c)) {
            digitNum++;
        }
        if (c == '.') {
            dotNum++;
        }
    }
    if (digitNum > 3 || dotNum!= 1) {
        return "No";
    }
    return "Yes";
}
--------------------------------
int sumSquares(List<Integer> lst) {
    int sum = 0;
    for (int i = 0; i < lst.size(); i++) {
        if (i % 3 == 0) {
            sum += lst.get(i) * lst.get(i);
        } else if (i % 4 == 0) {
            sum += lst.get(i) * lst.get(i) * lst.get(i);
        } else {
            sum += lst.get(i);
        }
    }
    return sum;
}
--------------------------------
String wordsInSentence(String sentence) {
    List<String> result = new ArrayList<>();
    List<String> current = new ArrayList<>();
    for (int i = 0; i < sentence.length() + 1; i++) {
        if (i == sentence.length() || sentence.charAt(i) =='') {
            boolean isPrime = true;
            int l = current.size();
            if (l < 2) {
                isPrime = false;
            }
            for (int j = 2; j < l; j++) {
                if (l % j == 0) {
                    isPrime = false;
                    break;
                }
            }
            if (isPrime) {
                result.add(String.join("", current) + " ");
            }
            current.clear();
        } else {
            current.add(sentence.charAt(i) + "");
        }
    }
    String resultString = String.join("", result);
    if (resultString.length() > 0) {
        resultString = resultString.substring(0, resultString.length() - 1);
    }
    return resultString;
}
--------------------------------
boolean simplify(String x, String n) {
    int a = 0, b = 0, c = 0, d = 0;
    for (int i = 0; i < x.length(); i++) {
        if (x.charAt(i) == '/') {
            a = Integer.parseInt(x.substring(0, i));
            b = Integer.parseInt(x.substring(i + 1));
        }
    }
    for (int i = 0; i < n.length(); i++) {
        if (n.charAt(i) == '/') {
            c = Integer.parseInt(n.substring(0, i));
            d = Integer.parseInt(n.substring(i + 1));
        }
    }
    return (a * c) % (b * d) == 0;
}
--------------------------------
int specialFilter(List<Integer> nums) {
    int count = 0;
    for (int num : nums) {
        if (num > 10) {
            String w = Integer.toString(num);
            if (w.charAt(0) % 2 == 1 && w.charAt(w.length() - 1) % 2 == 1) {
                count++;
            }
        }
    }
    return count;
}
--------------------------------
int getMaxTriples(int n) {
    int[] arr = new int[n];
    for (int i = 1; i <= n; i++) {
        arr[i - 1] = i * i - i + 1;
    }
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            for (int k = j + 1; k < n; k++) {
                if ((arr[i] + arr[j] + arr[k]) % 3 == 0) {
                    count++;
                }
            }
        }
    }
    return count;
}
--------------------------------
int doubleTheDifference(List<Double> lst) {
    int sum = 0;
    for (double d : lst) {
        int num = (int) Math.round(d);
        if (d == num) {
            if (num > 0 && num % 2 == 1) {
                sum += num * num;
            }
        }
    }
    return sum;
}
--------------------------------
List<Integer> compare(List<Integer> game, List<Integer> guess) {
    List<Integer> result = new ArrayList<>();
    for (int i = 0; i < game.size(); i++) {
        result.add(Math.abs(game.get(i) - guess.get(i)));
    }
    return result;
}
--------------------------------
String strongestExtension(String className, List<String> extensions) {
    String strongest = "";
    int max = - Integer.MAX_VALUE;
    for (String extension : extensions) {
        int strength = 0;
        for (char chr : extension.toCharArray()) {
            if (Character.isUpperCase(chr)) {
                strength += 1;
            }
            if (Character.isLowerCase(chr)) {
                strength -= 1;
            }
        }
        if (strength > max) {
            max = strength;
            strongest = extension;
        }
    }
    return className + "." + strongest;
}
--------------------------------
String intToMiniRoman(int number) {
    int[] num = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    String[] sym = {"m", "cm", "d", "cd", "c", "xc", "l", "xl", "x", "ix", "v", "iv", "i"};
    int pos = 0;
    StringBuilder res = new StringBuilder();
    while (number > 0) {
        while (number >= num[pos]) {
            res.append(sym[pos]);
            number -= num[pos];
        }
        if (number > 0) {
            pos += 1;
        }
    }
    return res.toString();
}
--------------------------------
List<Integer> eat(int number, int need, int remaining) {
    if (need > remaining) {
        return Arrays.asList(number + remaining, 0);
    } else {
        return Arrays.asList(number + need, remaining - need);
    }
}
--------------------------------
int doAlgebra(List<String> ops, List<Integer> operands) {
    List<Integer> nums = new ArrayList<>(operands);
    List<String> currentOps = new ArrayList<>(ops);
    int i = currentOps.size() - 1;
    while (i >= 0) {
        if (currentOps.get(i).equals("**")) {
            nums.set(i, (int) Math.pow(nums.get(i), nums.get(i + 1)));
            nums.remove(i + 1);
            currentOps.remove(i);
        }
        i--;
    }
    i = 0;
    while (i < currentOps.size()) {
        if (currentOps.get(i).equals("*")) {
            nums.set(i, nums.get(i) * nums.get(i + 1));
            nums.remove(i + 1);
            currentOps.remove(i);
        } else if (currentOps.get(i).equals("//")) {
            nums.set(i, nums.get(i) / nums.get(i + 1));
            nums.remove(i + 1);
            currentOps.remove(i);
        } else {
            i++;
        }
    }
    i = 0;
    while (i < currentOps.size()) {
        if (currentOps.get(i).equals("+")) {
            nums.set(i, nums.get(i) + nums.get(i + 1));
            nums.remove(i + 1);
            currentOps.remove(i);
        } else if (currentOps.get(i).equals("-")) {
            nums.set(i, nums.get(i) - nums.get(i + 1));
            nums.remove(i + 1);
            currentOps.remove(i);
        } else {
            i++;
        }
    }
    return nums.get(0);
}
--------------------------------
List<Integer> generateIntegers(int a, int b) {
    int lower = Math.max(2, Math.min(a, b));
    int upper = Math.min(8, Math.max(a, b));
    List<Integer> result = new ArrayList<>();
    for (int i = lower; i <= upper; i += 2) {
        result.add(i);
    }
    return result;
}
--------------------------------
boolean isStepNum(int n) {
    int prevDigit = -1;
    while (n > 0) {
        int curDigit = n % 10;
        if (prevDigit == -1) {
            prevDigit = curDigit;
        } else {
            if (Math.abs(prevDigit - curDigit)!= 1) {
                return false;
            }
        }
        prevDigit = curDigit;
        n /= 10;
    }
    return true;
}
--------------------------------
int numOfWays(int n, int k) {
    int p = 1;
    if (k % 2 == 1) {
        p = -1;
    }
    return ((n - 1) ^ k + p * (n - 1)) / n;
}
--------------------------------
List<Integer> findDivisors(int n) {
    List<Integer> v = new ArrayList<>();
    for (int i = 1; i <= Math.sqrt(n); i++) {
        if (n % i == 0) {
            if (n / i == i) {
                v.add(i);
            } else {
                v.add(i);
                v.add(n / i);
            }
        }
    }
    return v;
}
--------------------------------
int eggDrop(int n, int k) {
    if (k == 1 || k == 0) {
        return k;
    }
    if (n == 1) {
        return k;
    }
    int min = Integer.MAX_VALUE;
    for (int x = 1; x <= k; x++) {
        int res = Math.max(eggDrop(n - 1, x - 1), eggDrop(n, k - x));
        if (res < min) {
            min = res;
        }
    }
    return min + 1;
}
--------------------------------
boolean isPowerOfTwo(int n) {
    return (Math.ceil(Math.log(n) / Math.log(2)) == Math.floor(Math.log(n) / Math.log(2)));
}
--------------------------------
String shortestPalindrome(String s) {
    int n = s.length();
    String[] v = new String[n * 2];
    for (int i = 0; i < n; i++) {
        int l = i;
        int r = i;
        String ans1 = "";
        String ans2 = "";
        while (l >= 0 && r < n && s.charAt(l) == s.charAt(r)) {
            ans1 += s.charAt(l);
            l--;
            r++;
        }
        l = i - 1;
        r = i;
        while (l >= 0 && r < n && s.charAt(l) == s.charAt(r)) {
            ans2 += s.charAt(l);
            l--;
            r++;
        }
        v[i * 2] = ans1;
        v[i * 2 + 1] = ans2;
    }
    String ans = v[0];
    for (int i = 0; i < v.length; i++) {
        if (!v[i].equals("")) {
            ans = min(ans, v[i]);
        }
    }
    return ans;
}
--------------------------------
int minimumAdjacentDifference(List<Integer> a, int n, int k) {
    int minDiff = Integer.MAX_VALUE;
    for (int i = 0; i <= k; i++) {
        int maxDiff = Integer.MIN_VALUE;
        for (int j = 0; j < n - k - 1; j++) {
            int max = Integer.MIN_VALUE;
            for (int p = i; p <= i + j; p++) {
                max = Math.max(max, a.get(p + 1) - a.get(p));
            }
            maxDiff = Math.max(maxDiff, max);
        }
        minDiff = Math.min(minDiff, maxDiff);
    }
    return minDiff;
}
--------------------------------
int cal(List<Integer> arr, int mid) {
    int chocolate = 0;
    for (int i : arr) {
        if (i >= mid) {
            chocolate += i - mid;
        }
    }
    return chocolate;
}
--------------------------------
boolean check(int v, List<Integer> a, int m) {
    int tec = 0;
    int ans = 0;
    int[] b = new int[a.size() + 3];
    for (int i = 0; i < a.size(); i++) {
        tec -= b[i];
        if (a.get(i) + tec < v) {
            int mov = v - a.get(i) - tec;
            ans += mov;
            tec += mov;
            b[i + 2] = mov;
        }
    }
    return ans <= m;
}
--------------------------------
int largestNum(List<Integer> arr) {
    int res = 0;
    arr.sort(Comparator.naturalOrder());
    int l = 0, r = arr.size() - 1;
    while (l < r) {
        int sum = arr.get(l) + arr.get(r);
        if (sum == 0) {
            res = Math.max(res, Math.max(arr.get(l), arr.get(r)));
            return res;
        } else if (sum < 0) {
            l++;
        } else {
            r--;
        }
    }
    return res;
}
--------------------------------
int binarySearch(List<Integer> p, int n) {
    int i = 0;
    int j = p.size() - 1;
    int index = -1;
    while (i <= j) {
        int mid = i + (j - i) / 2;
        if (p.get(mid) >= n) {
            index = mid;
            j = mid - 1;
        } else {
            i = mid + 1;
        }
    }
    return index;
}
--------------------------------
int findMinLength(List<Integer> arr) {
    int index = arr.size() - 1;
    while (index > 0 && arr.get(index) >= arr.get(index - 1)) {
        index--;
    }
    return index;
}
--------------------------------
int minDigits(int n, int k) {
    int digitsNum = (int) Math.floor(Math.log10(n) + 1);
    int tempSum = 0;
    int temp = digitsNum;
    int result = 0;
    int x = 0;
    int v = 0;
    int sum = 0;
    int num2 = n;
    while (num2!= 0) {
        sum += num2 % 10;
        num2 /= 10;
    }
    if (sum <= k) {
        x = 0;
    } else {
        while (temp > 0) {
            v = n / (int) Math.pow(10, temp - 1);
            tempSum += v % 10;
            if (tempSum >= k) {
                v /= 10;
                v += 1;
                result = v * (int) Math.pow(10, temp);
                break;
            }
            temp -= 1;
        }
        x = result - n;
    }
    return x;
}
--------------------------------
int checkForPerfectSquare(List<Integer> arr, int i, int j) {
    int mid = 0, sum = 0;
    for (int m = i; m <= j; m++) {
        sum += arr.get(m);
    }
    int low = 0, high = sum / 2;
    while (low <= high) {
        mid = low + (high - low) / 2;
        if (mid * mid == sum) {
            return mid;
        } else if (mid * mid > sum) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return -1;
}
--------------------------------
int minFlips(List<List<Integer> > mat, String s) {
    int n = mat.size();
    int m = mat.get(0).size();
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (mat.get(i).get(j)!= (s.charAt(i + j) - '0')) {
                count++;
            }
        }
    }
    return count;
}
--------------------------------
List<List<Integer> > constructTree(int n, List<List<Integer> > edges) {
    List<List<Integer> > adjl = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        adjl.add(new ArrayList<>());
    }
    for (List<Integer> e : edges) {
        int u = e.get(0);
        int v = e.get(1);
        adjl.get(u).add(v);
        adjl.get(v).add(u);
    }
    return adjl;
}
--------------------------------
int findSumOfValues(int v, List<Integer> parent, List<Integer> valuesChildren) {
    int curNode = v;
    int sum = 0;
    while (curNode!= -1) {
        sum += valuesChildren.get(curNode);
        curNode = parent.get(curNode);
    }
    return sum;
}
--------------------------------
int getDistinct(int d, int count) {
    int num = 0;
    int count = 10 ** (count - 1);
    while (count > 0) {
        num += count * d;
        count /= 10;
    }
    return num;
}
--------------------------------
boolean isIncreasing(List<Integer> arr) {
    for (int i = 0; i < arr.size() - 1; i++) {
        if (arr.get(i) > arr.get(i + 1)) {
            return false;
        }
    }
    return true;
}
--------------------------------
int minAdjSwaps(List<List<Integer> > mat) {
    int n = mat.size();
    int[] cntZero = new int[n];
    for (int i = 0; i < n; i++) {
        for (int j = n - 1; j >= 0; j--) {
            if (mat.get(i).get(j)!= 0) {
                break;
            }
            cntZero[i]++;
        }
    }
    int cntSwaps = 0;
    for (int i = 0; i < n; i++) {
        if (cntZero[i] < (n - i - 1)) {
            int first = i;
            while (first < n && cntZero[first] < (n - i - 1)) {
                first++;
            }
            if (first == n) {
                return -1;
            }
            while (first > i) {
                cntZero[first] = cntZero[first - 1];
                cntZero[first - 1] = 1;
                first--;
                cntSwaps++;
            }
        }
    }
    return cntSwaps;
}
--------------------------------
int solve(List<Integer> values, List<Integer> salary, int mod) {
    int ret = 1;
    int amt = 0;
    values.sort(Comparator.naturalOrder());
    salary.sort(Comparator.naturalOrder());
    while (!salary.isEmpty()) {
        while (!values.isEmpty() && values.get(values.size() - 1) >= salary.get(salary.size() - 1)) {
            amt += 1;
            values.remove(values.size() - 1);
        }
        if (amt == 0) {
            return 0;
        }
        ret *= amt;
        amt -= 1;
        ret %= mod;
        salary.remove(salary.size() - 1);
    }
    return ret;
}
--------------------------------
List<Integer> organizeInOrder(List<Integer> vec, List<Character> op, int n) {
    List<Integer> result = new ArrayList<>(n);
    vec.sort(Comparator.naturalOrder());
    int i = 0, j = n - 1, k = 0;
    while (i <= j && k <= n - 2) {
        if (op.get(k) == '<') {
            result.add(vec.get(i));
            i++;
        } else {
            result.add(vec.get(j));
            j--;
        }
        k++;
    }
    result.add(vec.get(i));
    return result;
}
--------------------------------
int countPoints(int n, int m, List<Integer> a, List<Integer> b, int x, int y) {
    a.sort(Comparator.naturalOrder());
    b.sort(Comparator.naturalOrder());
    int j = 0;
    int count = 0;
    for (int i = 0; i < n; i++) {
        while (j < m) {
            if (a.get(i) + y < b.get(j)) {
                break;
            }
            if (b.get(j) >= a.get(i) - x && b.get(j) <= a.get(i) + y) {
                count += 1;
                j += 1;
                break;
            } else {
                j += 1;
            }
        }
    }
    return count;
}
--------------------------------
boolean areSame(List<Integer> a, List<Integer> b) {
    Collections.sort(a);
    Collections.sort(b);
    return a.equals(b);
}
--------------------------------
int countNumberOfStrings(String s) {
    int n = s.length() - 1;
    int count = 1 << n;
    return count;
}
--------------------------------
List<Integer> primePower(int x) {
    List<Integer> primePow = new ArrayList<>();
    for (int i = 2; i * i <= x; i++) {
        if (x % i == 0) {
            int p = 1;
            while (x % i == 0) {
                x /= i;
                p *= i;
            }
            primePow.add(p);
        }
    }
    if (x > 1) {
        primePow.add(x);
    }
    return primePow;
}
--------------------------------
boolean isPerfect(int n0) {
    double n = Math.sqrt(n0);
    if (Math.floor(n)!= Math.ceil(n)) {
        return false;
    }
    return true;
}
--------------------------------
int findSum(int l, int r) {
    int[] arr = new int[r - l + 1];
    int i = 0;
    int x = 2;
    while (i <= r) {
        arr[i] = i + x;
        if (i + 1 <= r) {
            arr[i + 1] = i + 1 + x;
        }
        x *= -1;
        i += 2;
    }
    int sum = 0;
    for (int i = l; i <= r; i++) {
        sum += arr[i];
    }
    return sum;
}
--------------------------------
int results(int n, int k) {
    return (int) Math.round(Math.pow(n, 1.0 / Math.pow(2, k)));
}
--------------------------------
List<Integer> factors(int n) {
    List<Integer> v = new ArrayList<>();
    v.add(1);
    for (int i = 2; i <= Math.sqrt(n); i++) {
        if (n % i == 0) {
            v.add(i);
            if (n / i!= i) {
                v.add(n / i);
            }
        }
    }
    return v;
}
--------------------------------
int smallestNum(int n) {
    double x = Math.pow(10, ((n - 1) / 2.0));
    return (int) Math.ceil(x);
}
--------------------------------
int smallest(String s) {
    int[] a = new int[s.length()];
    for (int i = 0; i < s.length(); i++) {
        a[i] = s.charAt(i) - '0';
    }
    List<Integer> b = new ArrayList<>();
    for (int i = 0; i < a.length; i++) {
        if (a[i] % 2!= 0) {
            b.add(a[i]);
        }
    }
    Collections.sort(b);
    if (b.size() > 1) {
        return b.get(0) * 10 + b.get(1);
    }
    return -1;
}
--------------------------------
List<Double> Diagonals(double a, double b, double c, double d) {
    List<Double> ans = new ArrayList<>();
    ans.add(Math.sqrt((a * c + b * d) * (a * d + b * c) / (a * b + c * d)));
    ans.add(Math.sqrt((a * c + b * d) * (a * b + c * d) / (a * d + b * c)));
    return ans;
}
--------------------------------
int findNumberOfDigits(int n, int bas) {
    int dig = (int) Math.floor(Math.log(n) / Math.log(bas)) + 1;
    return dig;
}
--------------------------------
double nGon(int n) {
    double proAngleVar = 0;
    if (n % 4 == 0) {
        proAngleVar = Math.PI * (180.0 / n) / 180;
    } else {
        proAngleVar = Math.PI * (180.0 / (2 * n)) / 180;
    }
    double negX = 1.0e+99;
    double posX = - 1.0e+99;
    double negY = 1.0e+99;
    double posY = - 1.0e+99;
    for (int j = 0; j < n; j++) {
        double px = Math.cos(2 * Math.PI * j / n + proAngleVar);
        double py = Math.sin(2 * Math.PI * j / n + proAngleVar);
        negX = Math.min(negX, px);
        posX = Math.max(posX, px);
        negY = Math.min(negY, py);
        posY = Math.max(posY, py);
    }
    double opt2 = Math.max(posX - negX, posY - negY);
    return opt2 / Math.sin(Math.PI / n) / 2;
}
--------------------------------
int findMaxK(int n) {
    int p = (int) Math.log(n) / Math.log(2);
    return (int) Math.pow(2, p);
}
--------------------------------
int nthFibo(int n) {
    double a = (5 ** 0.5 + 1) / 2;
    double b = (- 5 ** 0.5 + 1) / 2;
    double r = 5 ** 0.5;
    double ans = (a ** n - b ** n) / r;
    return (int) ans;
}
--------------------------------
double findProb(int l, int r) {
    double count_of_ps = Math.floor(Math.sqrt(r)) - Math.ceil(Math.sqrt(l)) + 1;
    double total = r - l + 1;
    double prob = count_of_ps / total;
    return prob;
}
--------------------------------
int previousFibonacci(int n) {
    double a = n / ((1 + Math.sqrt(5)) / 2.0);
    return Math.round(a);
}
--------------------------------
List<Integer> distPrime(List<Integer> arr, List<Integer> allPrimes) {
    List<Integer> list1 = new ArrayList<>();
    for (int i : allPrimes) {
        for (int j : arr) {
            if (j % i == 0) {
                list1.add(i);
                break;
            }
        }
    }
    return list1;
}
--------------------------------
List<Integer> getArray(int n) {
    List<Integer> ans = new ArrayList<>();
    int p2 = 1;
    while (n > 0) {
        if (n % 2 == 1) {
            ans.add(p2);
        }
        n >>= 1;
        p2 *= 2;
    }
    return ans;
}
--------------------------------
int maximumLength(List<Integer> a) {
    int[] counts = new int[11];
    int ans = 0;
    for (int index = 0; index < a.size(); index++) {
        counts[a.get(index)]++;
        List<Integer> k = new ArrayList<>();
        for (int i : counts) {
            if (i!= 0) {
                k.add(i);
            }
        }
        Collections.sort(k);
        if (k.size() == 1 || (k.get(0) == k.get(k.size() - 2) && k.get(k.size() - 1) - k.get(k.size() - 2) == 1) || (k.get(0) == 1 && k.get(1) == k.get(k.size() - 1))) {
            ans = index;
        }
    }
    return ans + 1;
}
--------------------------------
int maxEdges(double n) {
    int edges = (int) Math.floor(n * n / 4);
    return edges;
}
--------------------------------
int findK(int n, int k) {
    int[] a = new int[n];
    for (int i = 1; i <= n; i++) {
        if (i % 2 == 1) {
            a[i - 1] = i;
        }
    }
    for (int i = 1; i <= n; i++) {
        if (i % 2 == 0) {
            a[i - 1] = i;
        }
    }
    return a[k - 1];
}
--------------------------------
boolean isKeith(int x, int temp) {
    int[] terms = new int[100];
    int n = 0;
    while (temp > 0) {
        terms[n] = temp % 10;
        temp = temp / 10;
        n += 1;
    }
    for (int i = 0; i < n / 2; i++) {
        int temp = terms[i];
        terms[i] = terms[n - i - 1];
        terms[n - i - 1] = temp;
    }
    int nextTerm = 0;
    for (int i = 1; i <= n; i++) {
        nextTerm += terms[n - i];
    }
    return nextTerm == x;
}
--------------------------------
boolean factors(int n, int k) {
    List<Integer> v = new ArrayList<>();
    while (n % 2 == 0) {
        v.add(2);
        n /= 2;
    }
    if (v.size() >= k) {
        return true;
    }
    for (int i = 3; i * i <= n; i += 2) {
        if (n % i == 0) {
            v.add(i);
            while (n % i == 0) {
                n /= i;
            }
        }
        if (v.size() >= k) {
            return true;
        }
    }
    if (n > 2) {
        v.add(n);
    }
    if (v.size() >= k) {
        return true;
    }
    return false;
}
--------------------------------
List<String> separateParenGroups(String parenString) {
    List<String> allParens = new ArrayList<>();
    List<Character> currentParen = new ArrayList<>();
    int currentDepth = 0;
    for (char c : parenString.toCharArray()) {
        if (c == '(') {
            currentDepth++;
            currentParen.add(c);
        } else if (c == ')') {
            currentDepth--;
            currentParen.add(c);
            if (currentDepth == 0) {
                allParens.add(new String(currentParen));
                currentParen.clear();
            }
        }
    }
    return allParens;
}
--------------------------------
List<Integer> parseNestedParens(String parenString) {
    List<Integer> allLevels = new ArrayList<>();
    int level = 0;
    int maxLevel = 0;
    for (int i = 0; i < parenString.length(); i++) {
        char chr = parenString.charAt(i);
        if (chr == '(') {
            level += 1;
            if (level > maxLevel) {
                maxLevel = level;
            }
        }
        if (chr == ')') {
            level -= 1;
            if (level == 0) {
                allLevels.add(maxLevel);
                maxLevel = 0;
            }
        }
    }
    return allLevels;
}
--------------------------------
List<String> filterBySubstring(List<String> strings, String substring) {
    List<String> result = new ArrayList<>();
    for (String s : strings) {
        if (s.contains(substring)) {
            result.add(s);
        }
    }
    return result;
}
--------------------------------
List<Integer> rollingMax(List<Integer> numbers) {
    int runningMax = 0;
    List<Integer> result = new ArrayList<>();
    for (int n : numbers) {
        if (n > runningMax) {
            runningMax = n;
        }
        result.add(runningMax);
    }
    return result;
}
--------------------------------
String makePalindrome(String s) {
    if (s == null || s.length() == 0) {
        return "";
    }
    for (int i = 0; i < s.length(); i++) {
        String r_str = s.substring(i);
        if (r_str.equals(new StringBuilder(r_str).reverse().toString())) {
            String n_str = s.substring(0, i);
            String n2_str = new StringBuilder(n_str).reverse().toString();
            return s + n2_str;
        }
    }
    return s.substring(0, s.length() - 2) + s.substring(s.length() - 2, s.length());
}
--------------------------------
String stringXor(String a, String b) {
    String result = "";
    for (int i = 0; i < a.length(); i++) {
        if (a.charAt(i) == b.charAt(i)) {
            result += "0";
        } else {
            result += "1";
        }
    }
    return result;
}
--------------------------------
String longest(List<String> strings) {
    if (strings == null || strings.isEmpty()) {
        return "";
    }
    int maxLen = 0;
    for (String s : strings) {
        if (s.length() > maxLen) {
            maxLen = s.length();
        }
    }
    for (String s : strings) {
        if (s.length() == maxLen) {
            return s;
        }
    }
    return "";
}
--------------------------------
String StringSequence(int n) {
    String[] s = new String[2 * n];
    for (int i = 0; i < n; i++) {
        s[2 * i] = String.valueOf(i);
        s[2 * i + 1] = " ";
    }
    s[2 * n - 1] = String.valueOf(n);
    return String.join("", s);
}
--------------------------------
int countDistinctCharacters(String s) {
    Set<Character> distinct = new HashSet<>();
    for (char c : s.toLowerCase().toCharArray()) {
        distinct.add(c);
    }
    return distinct.size();
}
--------------------------------
int howManyTimes(String s, String sub) {
    int times = 0;
    for (int i = 0; i < s.length() - sub.length() + 1; i++) {
        if (s.substring(i, i + sub.length()).equals(sub)) {
            times++;
        }
    }
    return times;
}
--------------------------------
String sortNumbers(String numbers) {
    Map<String, Integer> toNum = new HashMap<>();
    toNum.put("zero", 0);
    toNum.put("one", 1);
    toNum.put("two", 2);
    toNum.put("three", 3);
    toNum.put("four", 4);
    toNum.put("five", 5);
    toNum.put("six", 6);
    toNum.put("seven", 7);
    toNum.put("eight", 8);
    toNum.put("nine", 9);
    Map<Integer, String> fromNum = new HashMap<>();
    fromNum.put(0, "zero");
    fromNum.put(1, "one");
    fromNum.put(2, "two");
    fromNum.put(3, "three");
    fromNum.put(4, "four");
    fromNum.put(5, "five");
    fromNum.put(6, "six");
    fromNum.put(7, "seven");
    fromNum.put(8, "eight");
    fromNum.put(9, "nine");
    List<Integer> ints = new ArrayList<>();
    List<Character> current = new ArrayList<>();
    for (int i = 0; i < numbers.length() + 1; i++) {
        if (i == numbers.length() || numbers.charAt(i) =='') {
            if (current.stream().map(c -> c.toString()).collect(Collectors.joining()).equals("")) {
                continue;
            }
            if (toNum.containsKey(current.stream().map(c -> c.toString()).collect(Collectors.joining()))) {
                ints.add(toNum.get(current.stream().map(c -> c.toString()).collect(Collectors.joining())));
                current.clear();
            }
        } else {
            current.add(numbers.charAt(i));
        }
    }
    ints.sort(Comparator.naturalOrder());
    List<String> result = new ArrayList<>();
    for (int i = 0; i < ints.size(); i++) {
        result.add(fromNum.get--------------------------------
List<Double> findClosestElements(List<Double> numbers) {
    List<Double> closestPair = new ArrayList<>();
    closestPair.add(numbers.get(0));
    closestPair.add(numbers.get(1));
    double distance = Math.abs(closestPair.get(0) - closestPair.get(1));
    for (int i = 0; i < numbers.size(); i++) {
        for (int j = i + 1; j < numbers.size(); j++) {
            if (Math.abs(numbers.get(i) - numbers.get(j)) < distance) {
                closestPair.set(0, numbers.get(i));
                closestPair.set(1, numbers.get(j));
                distance = Math.abs(numbers.get(i) - numbers.get(j));
            }
        }
    }
    closestPair.sort(Double::compare);
    return closestPair;
}
--------------------------------
List<Double> rescaleToUnit(List<Double> numbers) {
    double minNum = numbers.stream().min(Double::compare).get();
    double maxNum = numbers.stream().max(Double::compare).get();
    List<Double> result = new ArrayList<>();
    for (double n : numbers) {
        result.add((n - minNum) / (maxNum - minNum));
    }
    return result;
}
--------------------------------
List<Integer> filterIntegers(List<Object> values) {
    List<Integer> result = new ArrayList<>();
    for (Object e : values) {
        if (e instanceof Integer) {
            result.add((Integer) e);
        }
    }
    return result;
}
--------------------------------
List<Integer> removeDuplicates(List<Integer> numbers) {
    Map<Integer, Integer> counter = new HashMap<>();
    for (int i : numbers) {
        counter.put(i, counter.getOrDefault(i, 0) + 1);
    }
    List<Integer> result = new ArrayList<>();
    for (int i : numbers) {
        if (counter.get(i) == 1) {
            result.add(i);
        }
    }
    return result;
}
--------------------------------
String flipCase(String s) {
    String result = "";
    for (char c : s.toCharArray()) {
        if (Character.isLowerCase(c)) {
            result += Character.toUpperCase(c);
        } else {
            result += Character.toLowerCase(c);
        }
    }
    return result;
}
--------------------------------
List<String> filterByPrefix(List<String> strings, String prefix) {
    List<String> result = new ArrayList<>();
    for (int i = 0; i < strings.size(); i++) {
        if (strings.get(i).startsWith(prefix)) {
            result.add(strings.get(i));
        }
    }
    return result;
}
--------------------------------
double findZero(List<Double> xs) {
    double ans = 0;
    double value = 0;
    for (int i = 0; i < xs.size(); i++) {
        value += xs.get(i) * Math.pow(ans, i);
    }
    while (Math.abs(value) > 1e-6) {
        double driv = 0;
        for (int i = 1; i < xs.size(); i++) {
            driv += xs.get(i) * Math.pow(ans, i - 1) * i;
        }
        ans -= value / driv;
        value = 0;
        for (int i = 0; i < xs.size(); i++) {
            value += xs.get(i) * Math.pow(ans, i);
        }
    }
    return ans;
}
--------------------------------
List<Integer> sortThird(List<Integer> l) {
    List<Integer> thirds = new ArrayList<>();
    for (int i = 0; i < l.size(); i += 3) {
        thirds.add(l.get(i));
    }
    Collections.sort(thirds);
    List<Integer> result = new ArrayList<>();
    for (int i = 0; i < l.size(); i++) {
        if (i % 3 == 0) {
            result.add(thirds.get(i / 3));
        } else {
            result.add(l.get(i));
        }
    }
    return result;
}
--------------------------------
List<Integer> unique(List<Integer> l) {
    List<Integer> result = new ArrayList<Integer>(new HashSet<Integer>(l));
    Collections.sort(result);
    return result;
}
--------------------------------
double maxElement(List<Double> l) {
    return Collections.max(l);
}
--------------------------------
boolean triplesSumToZero(List<Integer> l) {
    for (int i = 0; i < l.size(); i++) {
        for (int j = i + 1; j < l.size(); j++) {
            for (int k = j + 1; k < l.size(); k++) {
                if (l.get(i) + l.get(j) + l.get(k) == 0) {
                    return true;
                }
            }
        }
    }
    return false;
}
--------------------------------
int fib4(int n) {
    int[] results = new int[n + 1];
    results[0] = 0;
    results[1] = 0;
    results[2] = 2;
    results[3] = 0;
    for (int i = 4; i <= n; i++) {
        results[i] = results[i - 4] + results[i - 3] + results[i - 2] + results[i - 1];
    }
    return results[n];
}
--------------------------------
boolean isPalindrome(String text) {
    String pr = text.substring(0, text.length() - 1);
    return pr.equals(text);
}
--------------------------------
String removeVowels(String text) {
    String result = "";
    String vowels = "aeiou";
    for (char ch : text.toCharArray()) {
        if (!vowels.contains(ch.toLowerCase())) {
            result += ch;
        }
    }
    return result;
}
--------------------------------
boolean sameChars(String s0, String s1) {
    Set<Character> set0 = new HashSet<>();
    for (char c : s0.toCharArray()) {
        set0.add(c);
    }
    Set<Character> set1 = new HashSet<>();
    for (char c : s1.toCharArray()) {
        set1.add(c);
    }
    return set0.equals(set1);
}
--------------------------------
List<Integer> common(List<Integer> l1, List<Integer> l2) {
    Set<Integer> us = new HashSet<>();
    for (int e1 : l1) {
        for (int e2 : l2) {
            if (e1 == e2) {
                us.add(e1);
            }
        }
    }
    List<Integer> ret = new ArrayList<>(us);
    Collections.sort(ret);
    return ret;
}
--------------------------------
boolean correctBracketing(String brackets) {
    int depth = 0;
    for (char b : brackets.toCharArray()) {
        if (b == '(') {
            depth += 1;
        } else {
            depth -= 1;
        }
        if (depth < 0) {
            return false;
        }
    }
    return depth == 0;
}
--------------------------------
String circularShift(int x, int shift) {
    String s = String.valueOf(x);
    if (shift > s.length()) {
        return new StringBuilder(s).reverse().toString();
    }
    return s.substring(s.length() - shift) + s.substring(0, s.length() - shift);
}
--------------------------------
int search(List<Integer> lst) {
    Map<Integer, Integer> counter = new HashMap<>();
    for (int i : lst) {
        counter.put(i, counter.getOrDefault(i, 0) + 1);
    }
    int ans = -1;
    for (int key : counter.keySet()) {
        int value = counter.get(key);
        if (value >= key && key > ans) {
            ans = key;
        }
    }
    return ans;
}
--------------------------------
int smallestChange(List<Integer> arr) {
    int ans = 0;
    for (int i = 0; i < arr.size() / 2; i++) {
        if (arr.get(i)!= arr.get(arr.size() - i - 1)) {
            ans++;
        }
    }
    return ans;
}
--------------------------------
List<String> totalMatch(List<String> lst1, List<String> lst2) {
    int sum1 = 0;
    for (String st : lst1) {
        sum1 += st.length();
    }
    int sum2 = 0;
    for (String st : lst2) {
        sum2 += st.length();
    }
    return lst2 if (sum1 > sum2) else lst1;
}
--------------------------------
boolean isHappy(String s) {
    if (s.length() < 3) {
        return false;
    }
    for (int i = 0; i < s.length() - 2; i++) {
        if (s.charAt(i) == s.charAt(i + 1) || s.charAt(i + 1) == s.charAt(i + 2) || s.charAt(i) == s.charAt(i + 2)) {
            return false;
        }
    }
    return true;
}
--------------------------------
List<String> numericalLetterGrade(List<Double> grades) {
    List<String> letterGrades = new ArrayList<>();
    for (double gpa : grades) {
        if (gpa == 4.0) {
            letterGrades.add("A+");
        } else if (gpa > 3.7) {
            letterGrades.add("A");
        } else if (gpa > 3.3) {
            letterGrades.add("A-");
        } else if (gpa > 3.0) {
            letterGrades.add("B+");
        } else if (gpa > 2.7) {
            letterGrades.add("B");
        } else if (gpa > 2.3) {
            letterGrades.add("B-");
        } else if (gpa > 2.0) {
            letterGrades.add("C+");
        } else if (gpa > 1.7) {
            letterGrades.add("C");
        } else if (gpa > 1.3) {
            letterGrades.add("C-");
        } else if (gpa > 1.0) {
            letterGrades.add("D+");
        } else if (gpa > 0.7) {
            letterGrades.add("D");
        } else if (gpa > 0.0) {
            letterGrades.add("D-");
        } else {
            letterGrades.add("E");
        }
    }
    return letterGrades;
}
--------------------------------
String solve(int n) {
    List<String> bi_str = new ArrayList<>();
    int sum = 0;
    for (char c : String.valueOf(n).toCharArray()) {
        sum += c - '0';
    }
    while (sum > 0) {
        bi_str.add(0, String.valueOf(sum % 2));
        sum /= 2;
    }
    return String.join("", bi_str);
}
--------------------------------
String antiShuffle(String s) {
    String[] ret = new String[s.length() + 1];
    String[] current = new String[0];
    for (int i = 0; i < s.length() + 1; i++) {
        if (i == s.length() || s.charAt(i) =='') {
            Arrays.sort(current);
            if (ret.length > 0) {
                ret[ret.length - 1] ='';
            }
            ret[ret.length] = String.join("", current);
            current = new String[0];
        } else {
            current[current.length] = s.charAt(i);
        }
    }
    return String.join("", ret);
}
--------------------------------
List<Integer> sortArray(List<Integer> array) {
    if (array == null) {
        return array;
    }
    if ((array.get(0) + array.get(array.size() - 1)) % 2 == 1) {
        Collections.sort(array);
    } else {
        Collections.sort(array, Collections.reverseOrder());
    }
    return array;
}
--------------------------------
String encrypt(String s) {
    char[] ans = new char[s.length()];
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if (Character.isLetter(c)) {
            ans[i] = (char) ('a' + (c - 'a' + 4) % 26);
        } else {
            ans[i] = c;
        }
    }
    return new String(ans);
}
--------------------------------
int isBored(String s) {
    boolean isStart = true;
    int sum = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '.' || s.charAt(i) == '?' || s.charAt(i) == '!') {
            isStart = true;
        } else if (isStart) {
            if (s.charAt(i) =='') {
                continue;
            }
            if (s.substring(i, i + 2).equals("I ")) {
                sum += 1;
            }
            isStart = false;
        }
    }
    return sum;
}
--------------------------------
String encode(String message) {
    String vowels = "aeiouAEIOU";
    String ret = "";
    for (char c : message.toCharArray()) {
        if (Character.isUpperCase(c)) {
            c = Character.toLowerCase(c);
            if (vowels.indexOf(c)!= -1) {
                c = (char) ('a' + ((c - 'a' + 2) % 26));
            }
        } else if (Character.isLowerCase(c)) {
            c = Character.toUpperCase(c);
            if (vowels.indexOf(c)!= -1) {
                c = (char) ('A' + ((c - 'A' + 2) % 26));
            }
        }
        ret += c;
    }
    return ret;
}
--------------------------------
int skjkasdkd(List<Integer> lst) {
    int largest = 0;
    for (int n : lst) {
        if (n > largest) {
            boolean prime = true;
            for (int i = 2; i < n; i++) {
                if (n % i == 0) {
                    prime = false;
                }
            }
            if (prime) {
                largest = n;
            }
        }
    }
    int sum = 0;
    String s = String.valueOf(largest);
    for (int i = 0; i < s.length(); i++) {
        sum += s.charAt(i) - '0';
    }
    return sum;
}
--------------------------------
boolean checkDictCase(Map<String, String> dict) {
    if (dict == null) {
        return false;
    }
    int isLower = 0;
    int isUpper = 0;
    for (String key : dict.keySet()) {
        for (char c : key.toCharArray()) {
            if (Character.isLowerCase(c)) {
                isLower++;
            } else if (Character.isUpperCase(c)) {
                isUpper++;
            } else {
                return false;
            }
        }
    }
    return isLower + isUpper == 1;
}
--------------------------------
int multiply(int a, int b) {
    return (Math.abs(a) % 10) * (Math.abs(b) % 10);
}
--------------------------------
int countUpper(String s) {
    String u_vowel = "AEIOU";
    int count = 0;
    for (int i = 0; i < s.length(); i += 2) {
        if (s.charAt(i) in u_vowel) {
            count += 1;
        }
    }
    return count;
}
--------------------------------
List<String> byLength(List<Integer> arr) {
    Map<Integer, String> numTo = new HashMap<>();
    numTo.put(1, "One");
    numTo.put(2, "Two");
    numTo.put(3, "Three");
    numTo.put(4, "Four");
    numTo.put(5, "Five");
    numTo.put(6, "Six");
    numTo.put(7, "Seven");
    numTo.put(8, "Eight");
    numTo.put(9, "Nine");
    List<Integer> sortedArr = new ArrayList<>(arr);
    Collections.sort(sortedArr, Collections.reverseOrder());
    List<String> newArr = new ArrayList<>();
    for (Integer n : sortedArr) {
        if (n >= 1 && n <= 9) {
            newArr.add(numTo.get(n));
        }
    }
    return newArr;
}
--------------------------------
List<Integer> f(int n) {
    int sum = 0;
    int prod = 1;
    List<Integer> result = new ArrayList<>();
    for (int i = 1; i <= n; i++) {
        sum += i;
        prod *= i;
        if (i % 2 == 0) {
            result.add(prod);
        } else {
            result.add(sum);
        }
    }
    return result;
}
--------------------------------
List<Integer> evenOddPalindrome(int n) {
    int evenCount = 0;
    int oddCount = 0;
    for (int i = 1; i <= n; i++) {
        String s = String.valueOf(i);
        String rStr = new StringBuilder(s).reverse().toString();
        if (s.equals(rStr)) {
            if (i % 2 == 1) {
                oddCount++;
            } else {
                evenCount++;
            }
        }
    }
    return Arrays.asList(evenCount, oddCount);
}
--------------------------------
Map<Character, Integer> histogram(String test) {
    Map<Character, Integer> count = new HashMap<>();
    int max = 0;
    for (int i = 0; i < test.length(); i++) {
        if (test.charAt(i)!='') {
            count.put(test.charAt(i), count.getOrDefault(test.charAt(i), 0) + 1);
            if (count.get(test.charAt(i)) > max) {
                max = count.get(test.charAt(i));
            }
        }
    }
    Map<Character, Integer> result = new HashMap<>();
    for (Map.Entry<Character, Integer> entry : count.entrySet()) {
        if (entry.getValue() == max) {
            result.put(entry.getKey(), entry.getValue());
        }
    }
    return result;
}
--------------------------------
List<String> reverseDelete(String s, String c) {
    List<String> ret = new ArrayList<>();
    for (char ch : s.toCharArray()) {
        if (!c.contains(String.valueOf(ch))) {
            ret.add(String.valueOf(ch));
        }
    }
    String flag = "False";
    if ("".join(ret).equals("".join(new StringBuilder(ret).reverse()))) {
        flag = "True";
    }
    return Arrays.asList("".join(ret), flag);
}
--------------------------------
List<Integer> sortArray(List<Integer> arr) {
    List<Integer> bin = new ArrayList<>();
    for (int i : arr) {
        int b = 0;
        int n = Math.abs(i);
        while (n > 0) {
            b += n % 2;
            n /= 2;
        }
        bin.add(b);
    }
    for (int i = 0; i < arr.size(); i++) {
        for (int j = 1; j < arr.size(); j++) {
            if (bin.get(j) < bin.get(j - 1) || (bin.get(j) == bin.get(j - 1) && arr.get(j) < arr.get(j - 1))) {
                bin.set(j, bin.get(j - 1));
                bin.set(j - 1, bin.get(j));
                arr.set(j, arr.get(j - 1));
                arr.set(j - 1, arr.get(j));
            }
        }
    }
    return arr;
}
--------------------------------
String getClosestVowel(String word) {
    String vowels = "AEIOUaeiou";
    for (int i = word.length() - 2; i >= 0; i--) {
        if (word.charAt(i) == vowels.charAt(i) && word.charAt(i + 1)!= vowels.charAt(i + 1) && word.charAt(i - 1)!= vowels.charAt(i - 1)) {
            return word.charAt(i);
        }
    }
    return "";
}
--------------------------------
String matchParens(List<String> lst) {
    List<String> strings = Arrays.asList(lst.get(0) + lst.get(1), lst.get(1) + lst.get(0));
    for (String l : strings) {
        int count = 0;
        for (char c : l.toCharArray()) {
            if (c == '(') {
                count++;
            } else if (c == ')') {
                count--;
            }
            if (count < 0) {
                break;
            }
        }
        if (count == 0) {
            return "Yes";
        }
    }
    return "No";
}
--------------------------------
List<Integer> maximum(List<Integer> arr, int k) {
    if (k == 0) {
        return new ArrayList<>();
    }
    arr.sort(Comparator.naturalOrder());
    return arr.subList(arr.size() - k, arr.size());
}
--------------------------------
boolean validDate(String date) {
    if (date.length()!= 10) {
        return false;
    }
    for (int i = 0; i < 10; i++) {
        if (i == 2 || i == 5) {
            if (date.charAt(i)!= '-') {
                return false;
            }
        } else if (!Character.isDigit(date.charAt(i))) {
            return false;
        }
    }
    int month = Integer.parseInt(date.substring(0, 2));
    int day = Integer.parseInt(date.substring(3, 5));
    int year = Integer.parseInt(date.substring(6, 10));
    if (month < 1 || month > 12) {
        return false;
    }
    if (day < 1 || day > 31) {
        return false;
    }
    if (day == 31 && (month == 4 || month == 6 || month == 9 || month == 11 || month == 2)) {
        return false;
    }
    if (day == 30 && month == 2) {
        return false;
    }
    return true;
}
--------------------------------
Object splitWords(String txt) {
    List<String> result = new ArrayList<>();
    if (txt.contains(" ")) {
        String[] words = txt.split(" ");
        for (String word : words) {
            result.add(word);
        }
        return result;
    }
    if (txt.contains(",")) {
        String[] words = txt.split(",");
        for (String word : words) {
            result.add(word);
        }
        return result;
    }
    int num = 0;
    for (char c : txt.toCharArray()) {
        if (Character.isLowerCase(c) && c % 2 == 0) {
            num++;
        }
    }
    result.add(String.valueOf(num));
    return result;
}
--------------------------------
List<Integer> tri(int n) {
    if (n == 0) {
        return Arrays.asList(1);
    }
    List<Integer> tris = Arrays.asList(1, 3);
    for (int i = 2; i <= n; i++) {
        if (i % 2 == 0) {
            tris.add(i / 2 + 1);
        } else {
            tris.add(tris.get(i - 1) + tris.get(i - 2) + (i + 3) / 2);
        }
    }
    return tris;
}
--------------------------------
boolean checkIfLastCharIsALetter(String txt) {
    if (txt == null || txt.length() == 0) {
        return false;
    }
    return Character.isLetter(txt.charAt(txt.length() - 1)) && (txt.length() == 1 ||!Character.isLetter(txt.charAt(txt.length() - 2)));
}
--------------------------------
List<Integer> orderByPoints(List<Integer> nums) {
    List<Integer> result = new ArrayList<>();
    for (int num : nums) {
        String w = String.valueOf(Math.abs(num));
        int sum = 0;
        for (char c : w.toCharArray()) {
            sum += c - '0';
        }
        if (num < 0) {
            sum -= 2 * (w.charAt(0) - '0');
        }
        result.add(sum);
    }
    for (int i = 0; i < nums.size(); i++) {
        for (int j = 1; j < nums.size(); j++) {
            if (result.get(j - 1) > result.get(j)) {
                result.set(j, result.get(j - 1));
                nums.set(j, nums.get(j - 1));
            }
        }
    }
    return nums;
}
--------------------------------
List<String> bf(String planet1, String planet2) {
    List<String> planets = Arrays.asList("Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune");
    int idx1 = planets.indexOf(planet1);
    int idx2 = planets.indexOf(planet2);
    if (idx1 == -1 || idx2 == -1 || idx1 == idx2) {
        return Collections.emptyList();
    }
    return planets.subList(idx2 + 1, idx1 + 1);
}
--------------------------------
List<String> sortedListSum(List<String> lst) {
    List<String> result = new ArrayList<>();
    for (String i : lst) {
        if (i.length() % 2 == 0) {
            result.add(i);
        }
    }
    result.sort(Comparator.comparing(String::length).thenComparing(Comparator.naturalOrder()));
    return result;
}
--------------------------------
boolean cycpatternCheck(String a, String b) {
    for (int i = 0; i < b.length(); i++) {
        String rotate = b.substring(i) + b.substring(0, i);
        if (rotate.contains(a)) {
            return true;
        }
    }
    return false;
}
--------------------------------
List<Integer> evenOddCount(int num) {
    int evenCount = 0, oddCount = 0;
    for (char c : String.valueOf(Math.abs(num)).toCharArray()) {
        if (Character.getNumericValue(c) % 2 == 0) {
            evenCount++;
        } else {
            oddCount++;
        }
    }
    return Arrays.asList(evenCount, oddCount);
}
--------------------------------
String findMax(List<String> words) {
    String max = "";
    int max_length = 0;
    for (String word : words) {
        List<Character> unique = new ArrayList<>();
        for (char w : word.toCharArray()) {
            if (!unique.contains(w)) {
                unique.add(w);
            }
        }
        if (unique.size() > max_length || (unique.size() == max_length && word.compareTo(max) < 0)) {
            max = word;
            max_length = unique.size();
        }
    }
    return max;
}
--------------------------------
String solve(String s) {
    boolean noLetter = true;
    char[] result = new char[s.length()];
    for (int i = 0; i < s.length(); i++) {
        char ch = s.charAt(i);
        if (Character.isUpperCase(ch)) {
            ch = Character.toLowerCase(ch);
            noLetter = false;
        } else if (Character.isLowerCase(ch)) {
            ch = Character.toUpperCase(ch);
            noLetter = false;
        }
        result[i] = ch;
    }
    if (noLetter) {
        return new String(result).substring(0, result.length - 1);
    } else {
        return new String(result);
    }
}
--------------------------------
int mostFrequent(List<Integer> arr, int n) {
    Map<Integer, Integer> hp = new HashMap<>();
    for (int i = 0; i < n; i++) {
        if (hp.containsKey(arr.get(i))) {
            hp.put(arr.get(i), hp.get(arr.get(i)) + 1);
        } else {
            hp.put(arr.get(i), 1);
        }
    }
    int maxCount = 0;
    int res = -1;
    for (Map.Entry<Integer, Integer> entry : hp.entrySet()) {
        if (maxCount < entry.getValue()) {
            res = entry.getKey();
            maxCount = entry.getValue();
        }
    }
    return res;
}
--------------------------------
int find(List<Integer> a, List<Integer> b, int k, int n1, int n2) {
    Set<Integer> s = new HashSet<>();
    for (int i = 0; i < n2; i++) {
        s.add(b.get(i));
    }
    int missing = 0;
    for (int i = 0; i < n1; i++) {
        if (!s.contains(a.get(i))) {
            missing++;
        }
        if (missing == k) {
            return a.get(i);
        }
    }
    return -1;
}
--------------------------------
int solveQuery(int start, int end, List<Integer> arr) {
    Map<Integer, Integer> frequency = new HashMap<>();
    for (int i = start; i <= end; i++) {
        frequency.put(arr.get(i), frequency.getOrDefault(arr.get(i), 0) + 1);
    }
    int count = 0;
    for (int key : frequency.keySet()) {
        if (key == frequency.get(key)) {
            count++;
        }
    }
    return count;
}
--------------------------------
int segregate(List<Integer> arr, int size) {
    int j = 0;
    for (int i = 0; i < size; i++) {
        if (arr.get(i) <= 0) {
            arr.set(i, arr.get(j));
            arr.set(j, arr.get(i));
            j++;
        }
    }
    return j;
}
--------------------------------
int countTriplets(List<Integer> a, int n) {
    Set<Integer> s = new HashSet<>();
    for (int i = 0; i < n; i++) {
        s.add(a.get(i));
    }
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int xr = a.get(i) ^ a.get(j);
            if (s.contains(xr) && xr!= a.get(i) && xr!= a.get(j)) {
                count++;
            }
        }
    }
    return count / 3;
}
--------------------------------
int leastFrequent(List<Integer> arr, int n) {
    Map<Integer, Integer> hp = new HashMap<>();
    for (int i = 0; i < n; i++) {
        if (hp.containsKey(arr.get(i))) {
            hp.put(arr.get(i), hp.get(arr.get(i)) + 1);
        } else {
            hp.put(arr.get(i), 1);
        }
    }
    int minCount = n + 1;
    int res = -1;
    for (Map.Entry<Integer, Integer> entry : hp.entrySet()) {
        if (minCount >= entry.getValue()) {
            res = entry.getKey();
            minCount = entry.getValue();
        }
    }
    return res;
}
--------------------------------
int findPermutations(List<Integer> arr) {
    int cnt = 0;
    int maxInd = -1;
    int minInd = 10000000;
    Map<Integer, Integer> index_of = new HashMap<>();
    for (int i = 0; i < arr.size(); i++) {
        index_of.put(arr.get(i), i + 1);
    }
    for (int i = 1; i <= arr.size(); i++) {
        maxInd = Math.max(maxInd, index_of.getOrDefault(i, 0));
        minInd = Math.min(minInd, index_of.getOrDefault(i, 0));
        if (maxInd - minInd + 1 == i) {
            cnt++;
        }
    }
    return cnt;
}
--------------------------------
int formQuadruplets(List<Integer> arr, int n) {
    int ans = 0, pairs = 0;
    pairs = n / 4;
    arr.sort(Collections.reverseOrder());
    for (int i = 0; i < n - pairs; i += 3) {
        ans += arr.get(i + 2);
    }
    return ans;
}
--------------------------------
String lexicographicallyMaximum(String s, int n) {
    Map<Character, Integer> m = new HashMap<>();
    for (int i = 0; i < n; i++) {
        if (m.containsKey(s.charAt(i))) {
            m.put(s.charAt(i), m.get(s.charAt(i)) + 1);
        } else {
            m.put(s.charAt(i), 1);
        }
    }
    List<Character> v = new ArrayList<>();
    for (int i = 'a'; i < 'a' + Math.min(n, 25); i++) {
        if (!m.containsKey(i)) {
            v.add(i);
        }
    }
    int j = v.size() - 1;
    for (int i = 0; i < n; i++) {
        if (s.charAt(i) >= 'a' + Math.min(n, 25) || (m.containsKey(s.charAt(i)) && m.get(s.charAt(i)) > 1)) {
            if (v.get(j) < s.charAt(i)) {
                continue;
            }
            m.put(s.charAt(i), m.get(s.charAt(i)) - 1);
            s = s.substring(0, i) + v.get(j) + s.substring(i + 1);
            j--;
        }
        if (j < 0) {
            break;
        }
    }
    int l = 0;
    for (int i = n - 1; i >= 0; i--) {
        if (l > j) {
            break;
        }
        if (s.charAt(i) >= 'a' + Math.min(n, 25) || (m.containsKey(s.charAt(i)) && m.get(s.charAt(i)) > 1)) {
            m.put(s.charAt(i), m.get(s.charAt(i)) - 1);
            s = s.substring(0, i) + v.get(l) + s.substring(i + 1);
            l++;
        }
    --------------------------------
int noOfValidKbers(int k, List<Integer> arr) {
    Set<Integer> st = new HashSet<>();
    while (k!= 0) {
        st.add(k % 10);
        k = k / 10;
    }
    int count = 0;
    for (int i = 0; i < arr.size(); i++) {
        int no = arr.get(i);
        boolean flag = true;
        while (no!= 0) {
            int digit = no % 10;
            if (!st.contains(digit)) {
                flag = false;
                break;
            }
            no = no / 10;
        }
        if (flag == true) {
            count++;
        }
    }
    return count;
}
--------------------------------
int delCost(String s, List<Integer> cost) {
    int ans = 0;
    Map<Character, Integer> forMax = new HashMap<>();
    Map<Character, Integer> forTot = new HashMap<>();
    for (int i = 0; i < s.length(); i++) {
        if (!forMax.containsKey(s.charAt(i))) {
            forMax.put(s.charAt(i), cost.get(i));
        } else {
            forMax.put(s.charAt(i), Math.max(cost.get(i), forMax.get(s.charAt(i))));
        }
        if (!forTot.containsKey(s.charAt(i))) {
            forTot.put(s.charAt(i), cost.get(i));
        } else {
            forTot.put(s.charAt(i), forTot.get(s.charAt(i)) + cost.get(i));
        }
    }
    for (Map.Entry<Character, Integer> entry : forMax.entrySet()) {
        ans += forTot.get(entry.getKey()) - entry.getValue();
    }
    return ans;
}
--------------------------------
List<String> replaceDuplicates(List<String> names) {
    Map<String, Integer> hash = new HashMap<>();
    for (int i = 0; i < names.size(); i++) {
        if (!hash.containsKey(names.get(i))) {
            hash.put(names.get(i), 1);
        } else {
            int count = hash.get(names.get(i));
            hash.put(names.get(i), count + 1);
            names.set(i, names.get(i) + count);
        }
    }
    return names;
}
--------------------------------
List<Integer> minmaxNumbers(List<List<Integer> > matrix, List<Integer> res) {
    Set<Integer> s = new HashSet<>();
    for (int i = 0; i < matrix.size(); i++) {
        int min_r = Integer.MAX_VALUE;
        for (int j = 0; j < matrix.get(i).size(); j++) {
            min_r = Math.min(min_r, matrix.get(i).get(j));
        }
        s.add(min_r);
    }
    for (int j = 0; j < matrix.get(0).size(); j++) {
        int max_c = Integer.MIN_VALUE;
        for (int i = 0; i < matrix.size(); i++) {
            max_c = Math.max(max_c, matrix.get(i).get(j));
        }
        if (s.contains(max_c)) {
            res.add(max_c);
        }
    }
    return res;
}
--------------------------------
int lengthOfLongestAP(List<Integer> a, int n) {
    Map<Integer, Map<Integer, Integer>> dp = new HashMap<>();
    int res = 2;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int d = a.get(j) - a.get(i);
            if (dp.containsKey(d)) {
                if (dp.get(d).containsKey(i)) {
                    dp.get(d).put(j, dp.get(d).get(i) + 1);
                } else {
                    dp.get(d).put(j, 2);
                }
            } else {
                Map<Integer, Integer> m = new HashMap<>();
                m.put(j, 2);
                dp.put(d, m);
            }
            res = Math.max(res, dp.get(d).get(j));
        }
    }
    return res;
}
--------------------------------
char findKthChar(int n, int k) {
    String prev = "A";
    String cur = "";
    if (n == 1) {
        return 'A';
    }
    for (int i = 2; i <= n; i++) {
        cur = prev + "B";
        for (int j = 0; j < prev.length(); j++) {
            if (prev.charAt(j) == 'A') {
                prev = prev.substring(0, j) + "B" + prev.substring(j + 1);
            } else {
                prev = prev.substring(0, j) + "A" + prev.substring(j + 1);
            }
        }
        prev = prev.substring(0, prev.length() - 1) + prev.substring(prev.length() - 1);
        cur += prev;
        prev = cur;
    }
    return cur.charAt(k - 1);
}
--------------------------------
char findKthLargest(String s, int k) {
    char[] tmp = s.toCharArray();
    Arrays.sort(tmp, Collections.reverseOrder());
    return tmp[k - 1];
}
--------------------------------
int subArraylen(List<Integer> arr, int n, int k) {
    Map<Integer, Integer> mp = new HashMap<>();
    mp.put(arr.get(0), 0);
    for (int i = 1; i < n; i++) {
        arr.set(i, arr.get(i) + arr.get(i - 1));
        mp.put(arr.get(i), i);
    }
    int len = Integer.MAX_VALUE;
    for (int i = 0; i < n; i++) {
        if (arr.get(i) < k) {
            continue;
        } else {
            int x = arr.get(i) - k;
            if (x == 0) {
                len = Math.min(len, i);
            }
            if (!mp.containsKey(x)) {
                continue;
            } else {
                len = Math.min(len, i - mp.get(x));
            }
        }
    }
    return len;
}
--------------------------------
int findMaxLen(List<Integer> a, int k) {
    int n = a.size();
    a.sort(Comparator.naturalOrder());
    boolean[] vis = new boolean[n];
    Map<Integer, Integer> mp = new HashMap<>();
    for (int i = 0; i < n; i++) {
        mp.put(a.get(i), i);
    }
    int c = 0;
    for (int i = 0; i < n; i++) {
        if (!vis[i]) {
            int check = a.get(i) * k;
            if (mp.containsKey(check)) {
                c++;
                vis[mp.get(check)] = true;
            }
        }
    }
    return n - c;
}
--------------------------------
List<Integer> minDistancePoints(List<Integer> a, int k, int n) {
    Map<Integer, Integer> m = new HashMap<>();
    Queue<Integer> q = new LinkedList<>();
    for (int i = 0; i < n; i++) {
        m.put(a.get(i), 1);
        q.add(a.get(i));
    }
    List<Integer> ans = new ArrayList<>();
    while (k > 0) {
        int x = q.poll();
        if (x - 1!= null &&!m.containsKey(x - 1)) {
            m.put(x - 1, 1);
            q.add(x - 1);
            ans.add(x - 1);
            k--;
        }
        if (x + 1!= null &&!m.containsKey(x + 1)) {
            m.put(x + 1, 1);
            q.add(x + 1);
            ans.add(x + 1);
            k--;
        }
    }
    return ans;
}
--------------------------------
boolean isValidLen(String s, int len, int k) {
    int n = s.length();
    Map<Character, Integer> mp = new HashMap<>();
    int right = 0;
    while (right < len) {
        if (mp.containsKey(s.charAt(right))) {
            mp.put(s.charAt(right), mp.get(s.charAt(right)) + 1);
        } else {
            mp.put(s.charAt(right), 1);
        }
        right++;
    }
    if (mp.size() <= k) {
        return true;
    }
    while (right < n) {
        if (mp.containsKey(s.charAt(right))) {
            mp.put(s.charAt(right), mp.get(s.charAt(right)) + 1);
        } else {
            mp.put(s.charAt(right), 1);
        }
        mp.put(s.charAt(right - len), mp.get(s.charAt(right - len)) - 1);
        if (mp.get(s.charAt(right - len)) == 0) {
            mp.remove(s.charAt(right - len));
        }
        if (mp.size() <= k) {
            return true;
        }
        right++;
    }
    return mp.size() <= k;
}
--------------------------------
int partition(List<Integer> arr, int low, int high) {
    int pivot = arr.get(high);
    int i = (low - 1);
    for (int j = low; j < high; j++) {
        if (arr.get(j) <= pivot) {
            i += 1;
            int temp = arr.get(i);
            arr.set(i, arr.get(j));
            arr.set(j, temp);
        }
    }
    int temp = arr.get(i + 1);
    arr.set(i + 1, arr.get(high));
    arr.set(high, temp);
    return i + 1;
}
--------------------------------
int strScore(List<String> strs, String s, int n) {
    Map<String, Integer> m = new HashMap<>();
    for (int i = 0; i < n; i++) {
        m.put(strs.get(i), i + 1);
    }
    if (!m.containsKey(s)) {
        return 0;
    }
    int score = 0;
    for (int i = 0; i < s.length(); i++) {
        score += (int) s.charAt(i) - (int) 'a' + 1;
    }
    score = score * m.get(s);
    return score;
}
--------------------------------
List<Integer> countEle(List<Integer> s, List<Integer> a, int n) {
    Map<Integer, Boolean> mp = new HashMap<>();
    List<Integer> ans = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        int num = a.get(i);
        if (mp.containsKey(num)) {
            ans.add(0);
        } else {
            int cnt = 0;
            while (s.get(0)!= num) {
                mp.put(s.get(0), true);
                s.remove(0);
                cnt++;
            }
            s.remove(0);
            cnt++;
            ans.add(cnt);
        }
    }
    return ans;
}
--------------------------------
int maxDistinctChar(String s, int n, int k) {
    int[] freq = new int[26];
    for (int i = 0; i < n; i++) {
        freq[s.charAt(i) - 'a']++;
    }
    int[] v = new int[26];
    for (int i = 0; i < 26; i++) {
        v[i] = freq[i];
    }
    Arrays.sort(v);
    for (int i = 0; i < 26; i++) {
        int mn = Math.min(v[i] - 1, k);
        v[i] -= mn;
        k -= mn;
    }
    if (k > 0) {
        for (int i = 0; i < 26; i++) {
            int mn = Math.min(v[i], k);
            v[i] -= mn;
            k -= mn;
        }
    }
    int res = 0;
    for (int i = 0; i < 26; i++) {
        if (v[i] == 1) {
            res++;
        }
    }
    return res;
}
--------------------------------
int findKth(List<Integer> arr, int n, int k) {
    Map<Integer, Integer> missing = new HashMap<>();
    int count = 0;
    for (int i = 0; i < n; i++) {
        missing.put(arr.get(i), 1);
    }
    int maxM = Collections.max(arr);
    int minM = Collections.min(arr);
    for (int i = minM + 1; i < maxM; i++) {
        if (!missing.containsKey(i)) {
            count++;
        }
        if (count == k) {
            return i;
        }
    }
    return -1;
}
--------------------------------
boolean almostSort(List<Integer> a, int n) {
    for (int i = 0; i < n - 1; i++) {
        if (a.get(i) > a.get(i + 1)) {
            Collections.swap(a, i, i + 1);
            i++;
        }
    }
    for (int i = 0; i < n - 1; i++) {
        if (a.get(i) > a.get(i + 1)) {
            return false;
        }
    }
    return true;
}
--------------------------------
int maximumSum(String s, int n, int k) {
    int sum = 0;
    int[] freq = new int[256];
    for (int i = 0; i < n; i++) {
        freq[s.charAt(i)]++;
    }
    Arrays.sort(freq, Collections.reverseOrder());
    for (int i = 255; i >= 0; i--) {
        if (k > freq[i]) {
            sum += freq[i] * freq[i];
            k -= freq[i];
        } else {
            sum += freq[i] * k;
            break;
        }
    }
    return sum;
}
--------------------------------
int findMinOperations(List<Integer> arr, int N, int K) {
    int operations = 0;
    for (int i = 0; i < K; i++) {
        Map<Integer, Integer> freq = new HashMap<>();
        for (int j = i; j < N; j += K) {
            freq.put(arr.get(j), freq.getOrDefault(arr.get(j), 0) + 1);
        }
        int max1 = 0;
        int num = 0;
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            if (entry.getValue() > max1) {
                max1 = entry.getValue();
                num = entry.getKey();
            }
        }
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            if (entry.getKey()!= num) {
                operations += entry.getValue();
            }
        }
    }
    return operations;
}
--------------------------------
List<String> subString(String s, int n) {
    List<String> v = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        for (int len = 1; len <= n - i; len++) {
            String find = s.substring(i, i + len);
            v.add(find);
        }
    }
    return v;
}
--------------------------------
boolean checkUniqueFrequency(List<Integer> arr, int n) {
    Map<Integer, Integer> freq = new HashMap<>();
    for (int i = 0; i < n; i++) {
        freq.put(arr.get(i), freq.getOrDefault(arr.get(i), 0) + 1);
    }
    Set<Integer> uniqueFreq = new HashSet<>();
    for (int i : freq.keySet()) {
        if (freq.get(i) in uniqueFreq) {
            return false;
        } else {
            uniqueFreq.add(freq.get(i));
        }
    }
    return true;
}
--------------------------------
int minCost(String str1, String str2, int n) {
    int cost = 0;
    char[] tmp = str1.toCharArray();
    for (int i = 0; i < n; i++) {
        if (tmp[i]!= str2.charAt(i)) {
            if (i < n - 1 && tmp[i + 1]!= str2.charAt(i + 1)) {
                char tmp1 = tmp[i];
                tmp[i] = tmp[i + 1];
                tmp[i + 1] = tmp1;
                cost++;
            } else {
                cost++;
            }
        }
    }
    return cost;
}
--------------------------------
boolean isValidNum(String x) {
    Map<Integer, Integer> mp = new HashMap<>();
    for (int i = 0; i < x.length(); i++) {
        if (mp.containsKey(x.charAt(i) - '0')) {
            return false;
        }
        if (x.charAt(i) - '0' > 5) {
            return false;
        }
        mp.put(x.charAt(i) - '0', 1);
    }
    return true;
}
--------------------------------
int minimizeDiff(List<Integer> arr, int n, int k) {
    int max = Collections.max(arr);
    int min = Collections.min(arr);
    if (max - min <= k) {
        return max - min;
    }
    int avg = (max + min) / 2;
    for (int i = 0; i < n; i++) {
        if (arr.get(i) > avg) {
            arr.set(i, arr.get(i) - k);
        } else {
            arr.set(i, arr.get(i) + k);
        }
    }
    max = Collections.max(arr);
    min = Collections.min(arr);
    return max - min;
}
--------------------------------
int getMinCost(List<Integer> arr, int n) {
    int minEle = Collections.min(arr);
    return minEle * (n - 1);
}
--------------------------------
boolean possibility(Map<Integer, Integer> m, int length, String s) {
    int count_odd = 0;
    for (int i = 0; i < length; i++) {
        if ((m.get(s.charAt(i) - '0') & 1) == 1) {
            count_odd++;
        }
        if (count_odd > 1) {
            return false;
        }
    }
    return true;
}
--------------------------------
int minimumCostOfBreaking(List<Integer> x, List<Integer> y, int m, int n) {
    int res = 0;
    x.sort(Collections.reverseOrder());
    y.sort(Collections.reverseOrder());
    int hzntl = 1, vert = 1;
    int i = 0, j = 0;
    while (i < m && j < n) {
        if (x.get(i) > y.get(j)) {
            res += x.get(i) * vert;
            hzntl += 1;
            i += 1;
        } else {
            res += y.get(j) * hzntl;
            vert += 1;
            j += 1;
        }
    }
    int total = 0;
    while (i < m) {
        total += x.get(i);
        i += 1;
    }
    res += total * vert;
    total = 0;
    while (j < n) {
        total += y.get(j);
        j += 1;
    }
    res += total * hzntl;
    return res;
}
--------------------------------
int findMaximumScore(List<Integer> a, int n) {
    Map<Integer, Integer> freq = new HashMap<>();
    for (int i = 0; i < n; i++) {
        if (freq.containsKey(a.get(i))) {
            freq.put(a.get(i), freq.get(a.get(i)) + 1);
        } else {
            freq.put(a.get(i), 1);
        }
    }
    int[] dp = new int[max(a) + 1];
    dp[0] = 0;
    dp[1] = freq.getOrDefault(1, 0);
    for (int i = 2; i < dp.length; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + freq.getOrDefault(i, 0) * i);
    }
    return dp[dp.length - 1];
}
--------------------------------
int countWays(String s, String t, int k, int mod) {
    int n = s.length();
    int a = 0;
    int b = 0;
    for (int i = 0; i < n; i++) {
        String p = s.substring(i, n) + s.substring(0, i);
        if (p.equals(t)) {
            a++;
        } else {
            b++;
        }
    }
    int[] dp1 = new int[k + 1];
    int[] dp2 = new int[k + 1];
    dp1[0] = 1;
    dp2[0] = 0;
    if (s.equals(t)) {
        dp1[0] = 1;
        dp2[0] = 0;
    } else {
        dp1[0] = 0;
        dp2[0] = 1;
    }
    for (int i = 1; i <= k; i++) {
        dp1[i] = ((dp1[i - 1] * (a - 1)) % mod + (dp2[i - 1] * a) % mod) % mod;
        dp2[i] = ((dp1[i - 1] * b) % mod + (dp2[i - 1] * (b - 1)) % mod) % mod;
    }
    return dp1[k];
}
--------------------------------
int findSubarraySum(List<Integer> arr, int n, int k) {
    int res = 0;
    int curr_sum = 0;
    Map<Integer, Integer> prev_sum = new HashMap<>();
    for (int i = 0; i < n; i++) {
        curr_sum += arr.get(i);
        if (curr_sum == k) {
            res += 1;
        }
        if (curr_sum - k in prev_sum) {
            res += prev_sum.get(curr_sum - k);
        }
        prev_sum.put(curr_sum, prev_sum.getOrDefault(curr_sum, 0) + 1);
    }
    return res;
}
--------------------------------
int maximumOccurrence(String s) {
    int n = s.length();
    Map<String, Integer> freq = new HashMap<>();
    for (int i = 0; i < n; i++) {
        String temp = "";
        temp += s.charAt(i);
        freq.put(temp, freq.getOrDefault(temp, 0) + 1);
    }
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            String temp = "";
            temp += s.charAt(i);
            temp += s.charAt(j);
            freq.put(temp, freq.getOrDefault(temp, 0) + 1);
        }
    }
    int answer = Integer.MIN_VALUE;
    for (int value : freq.values()) {
        answer = Math.max(answer, value);
    }
    return answer;
}
--------------------------------
int countCharacters(List<String> strings, String chars) {
    int res = 0;
    Map<Character, Integer> freq = new HashMap<>();
    for (int i = 0; i < chars.length(); i++) {
        freq.put(chars.charAt(i), freq.getOrDefault(chars.charAt(i), 0) + 1);
    }
    for (String st : strings) {
        boolean flag = true;
        for (char c : st.toCharArray()) {
            if (!freq.containsKey(c)) {
                flag = false;
                break;
            }
        }
        if (flag) {
            res += st.length();
        }
    }
    return res;
}
--------------------------------
int distinctSubstring(String p, String q, int k, int n) {
    Set<String> ss = new HashSet<>();
    for (int i = 0; i < n; i++) {
        int sum = 0;
        String s = "";
        for (int j = i; j < n; j++) {
            int pos = p.charAt(j) - 'a';
            sum += q.charAt(pos) - '0';
            s += p.charAt(j);
            if (sum <= k) {
                ss.add(s);
            } else {
                break;
            }
        }
    }
    return ss.size();
}
--------------------------------
int uniqueMorseRep(List<String> arr) {
    String[] morseCode = {".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."};
    Set<String> st = new HashSet<>();
    int n = arr.size();
    for (int i = 0; i < n; i++) {
        String temp = "";
        int m = arr.get(i).length();
        for (int j = 0; j < m; j++) {
            temp += morseCode[arr.get(i).charAt(j) - 'a'];
        }
        st.add(temp);
    }
    return st.size();
}
--------------------------------
int countSubstrings(String st, int k) {
    int n = st.length();
    int answer = 0;
    Map<Character, Integer> map = new HashMap<>();
    for (int i = 0; i < k; i++) {
        if (!map.containsKey(st.charAt(i))) {
            map.put(st.charAt(i), 1);
        } else {
            map.put(st.charAt(i), map.get(st.charAt(i)) + 1);
        }
    }
    if (map.size() == k) {
        answer += 1;
    }
    for (int i = k; i < n; i++) {
        if (!map.containsKey(st.charAt(i))) {
            map.put(st.charAt(i), 1);
        } else {
            map.put(st.charAt(i), map.get(st.charAt(i)) + 1);
        }
        map.put(st.charAt(i - k), map.get(st.charAt(i - k)) - 1);
        if (map.get(st.charAt(i - k)) == 0) {
            map.remove(st.charAt(i - k));
        }
        if (map.size() == k) {
            answer += 1;
        }
    }
    return answer;
}
--------------------------------
boolean canConstruct(String s, int k) {
    HashMap<Character, Integer> m = new HashMap<>();
    int p = 0;
    if (s.length() == k) {
        return true;
    }
    for (int i = 0; i < s.length(); i++) {
        m.put(s.charAt(i), m.getOrDefault(s.charAt(i), 0) + 1);
    }
    if (k > s.length()) {
        return false;
    } else {
        for (Map.Entry<Character, Integer> entry : m.entrySet()) {
            if (entry.getValue() % 2!= 0) {
                p = p + 1;
            }
        }
    }
    if (k < p) {
        return false;
    }
    return true;
}
--------------------------------
boolean equalIgnoreCase(String str1, String str2) {
    str1 = str1.toUpperCase();
    str2 = str2.toUpperCase();
    return str1.equals(str2);
}
--------------------------------
int findLongestSub(String bin) {
    int n = bin.length();
    int sum = 0;
    int prevSum = 0;
    int maxLen = 0;
    for (int i = 0; i < n; i++) {
        if (bin.charAt(i) == '1') {
            sum++;
        } else {
            sum--;
        }
        if (sum > 0) {
            maxLen = i + 1;
        } else if (sum <= 0) {
            if (sum - 1 == prevSum) {
                int currLen = i - prevSum;
                maxLen = Math.max(maxLen, currLen);
            }
        }
        prevSum = sum;
    }
    return maxLen;
}
--------------------------------
boolean hasAllCodes(String s, int k) {
    Set<String> us = new HashSet<>();
    for (int i = 0; i <= s.length() - k; i++) {
        us.add(s.substring(i, i + k));
    }
    return us.size() == (1 << k);
}
--------------------------------
boolean checkPalin(String word) {
    int n = word.length();
    word = word.toLowerCase();
    for (int i = 0; i < n; i++) {
        if (word.charAt(i)!= word.charAt(n - 1)) {
            return false;
        }
        n--;
    }
    return true;
}
--------------------------------
String convert(String st) {
    String w = "";
    String z = "";
    st = st.toUpperCase() + " ";
    for (int i = 0; i < st.length(); i++) {
        char ch = st.charAt(i);
        if (ch!='') {
            w += ch;
        } else {
            z += w.substring(0, 1).toLowerCase() + w.substring(1) + " ";
            w = "";
        }
    }
    return z;
}
--------------------------------
int maxLines(int n, List<Integer> x1, List<Integer> y1, List<Integer> x2, List<Integer> y2) {
    Set<Double> slopes = new HashSet<>();
    for (int i = 0; i < n; i++) {
        if (x1.get(i) == x2.get(i)) {
            slopes.add(Double.MAX_VALUE);
        } else {
            slopes.add((y2.get(i) - y1.get(i)) * 1.0 / (x2.get(i) - x1.get(i)));
        }
    }
    return slopes.size();
}
--------------------------------
HashMap<Integer, Integer> PrimeFactor(int n) {
    HashMap<Integer, Integer> primef = new HashMap<Integer, Integer>();
    while (n % 2 == 0) {
        if (primef.containsKey(2)) {
            primef.put(2, primef.get(2) + 1);
        } else {
            primef.put(2, 1);
        }
        n = n / 2;
    }
    for (int i = 3; i <= Math.sqrt(n); i = i + 2) {
        while (n % i == 0) {
            if (primef.containsKey(i)) {
                primef.put(i, primef.get(i) + 1);
            } else {
                primef.put(i, 1);
            }
            n = n / i;
        }
    }
    if (n > 2) {
        primef.put(n, 1);
    }
    return primef;
}
--------------------------------
String isDivisibleByDivisor(int s, int d) {
    s %= d;
    Set<Integer> hashMap = new HashSet<>();
    hashMap.add(s);
    for (int i = 0; i < d + 1; i++) {
        s += s % d;
        s %= d;
        if (hashMap.contains(s)) {
            if (s == 0) {
                return "Yes";
            }
            return "No";
        }
        hashMap.add(s);
    }
    return "Yes";
}
--------------------------------
boolean oddSum(List<Integer> a, int n, int k) {
    Set<Integer> odd = new HashSet<>();
    Set<Integer> even = new HashSet<>();
    for (int i = 0; i < n; i++) {
        if (a.get(i) % 2 == 0) {
            even.add(a.get(i));
        } else {
            odd.add(a.get(i));
        }
    }
    if (odd.size() >= k) {
        return true;
    }
    boolean flag = false;
    for (int i = 1; i < k; i += 2) {
        if (even.size() >= k - i) {
            return true;
        }
    }
    return flag;
}
--------------------------------
int dayOfYear(String date) {
    int[] days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    int year = Integer.parseInt(date.substring(0, 4));
    int month = Integer.parseInt(date.substring(5, 7));
    int day = Integer.parseInt(date.substring(8));
    if (month > 2 && year % 4 == 0 && (year % 100!= 0 || year % 400 == 0)) {
        day += 1;
    }
    while (month > 1) {
        day = day + days[month - 2];
        month -= 1;
    }
    return day;
}
--------------------------------
boolean isPerfectSquare(List<Integer> arr, int n) {
    Map<Integer, Integer> umap = new HashMap<>();
    for (int i = 0; i < n; i++) {
        umap.put(arr.get(i), umap.getOrDefault(arr.get(i), 0) + 1);
    }
    for (Map.Entry<Integer, Integer> entry : umap.entrySet()) {
        if (entry.getValue() % 2 == 1) {
            return false;
        }
    }
    return true;
}
--------------------------------
int minMoves(int n) {
    String s = String.valueOf(n);
    int ans = Integer.MAX_VALUE;
    int length = s.length();
    for (int i = 0; i < length; i++) {
        for (int j = 0; j < length; j++) {
            if (i == j) {
                continue;
            }
            char[] t = s.toCharArray();
            int cur = 0;
            for (int k = i; k < length - 1; k++) {
                char tmp = t[k];
                t[k] = t[k + 1];
                t[k + 1] = tmp;
                cur += 1;
            }
            for (int k = j - (j > i); k < length - 2; k++) {
                char tmp = t[k];
                t[k] = t[k + 1];
                t[k + 1] = tmp;
                cur += 1;
            }
            int pos = -1;
            for (int k = 0; k < length; k++) {
                if (t[k]!= '0') {
                    pos = k;
                    break;
                }
            }
            for (int k = pos; k > 0; k--) {
                char tmp = t[k];
                t[k] = t[k - 1];
                t[k - 1] = tmp;
                cur += 1;
            }
            int nn = Integer.parseInt(new String(t));
            if (nn % 25 == 0) {
                ans = Math.min(ans, cur);
            }
        }
    }
    if (ans == Integer.MAX_VALUE) {
        return -1;
    }
    return ans;
}
--------------------------------
int minimumOperations(List<Integer> a, int n) {
    Map<Integer, Integer> mp = new HashMap<>();
    for (int i = 0; i < n; i++) {
        mp.put(a.get(i), mp.getOrDefault(a.get(i), 0) + 1);
    }
    int count = 0;
    for (Map.Entry<Integer, Integer> entry : mp.entrySet()) {
        if (entry.getValue() > 1) {
            count += entry.getValue() - 1;
        }
    }
    return count;
}
--------------------------------
int kaprekarRec(int n, int prev) {
    if (n == 0) {
        return 0;
    }
    prev = n;
    int[] digits = new int[4];
    for (int i = 0; i < 4; i++) {
        digits[i] = n % 10;
        n = n / 10;
    }
    Arrays.sort(digits);
    int asc = 0;
    for (int i = 0; i < 4; i++) {
        asc = asc * 10 + digits[i];
    }
    Arrays.sort(digits);
    int desc = 0;
    for (int i = 3; i >= 0; i--) {
        desc = desc * 10 + digits[i];
    }
    int diff = Math.abs(asc - desc);
    if (diff == prev) {
        return diff;
    }
    return kaprekarRec(diff, prev);
}
--------------------------------
String fractionToDecimal(int numr, int denr) {
    String res = "";
    Map<Integer, Integer> mp = new HashMap<>();
    int rem = numr % denr;
    while (rem!= 0 &&!mp.containsKey(rem)) {
        mp.put(rem, res.length());
        rem = rem * 10;
        int res_part = rem / denr;
        res += res_part;
        rem = rem % denr;
    }
    if (rem == 0) {
        return "";
    }
    if (mp.containsKey(rem)) {
        return res.substring(mp.get(rem));
    }
    return "";
}
--------------------------------
boolean isFancy(String num) {
    Map<String, String> fp = new HashMap<>();
    fp.put("0", "0");
    fp.put("1", "1");
    fp.put("6", "9");
    fp.put("8", "8");
    fp.put("9", "6");
    int n = num.length();
    int l = 0, r = n - 1;
    while (l <= r) {
        if (!fp.containsKey(num.charAt(l)) || fp.get(num.charAt(l))!= num.charAt(r)) {
            return false;
        }
        l++;
        r--;
    }
    return true;
}
--------------------------------
double distinctOddRatio(List<Integer> numbers) {
    int distinctCount = new HashSet<>(numbers).size();
    int distinctOddCount = numbers.stream().filter(n -> n % 2 == 1).collect(Collectors.toSet()).size();
    return (double) distinctOddCount / distinctCount;
}
--------------------------------
int compareSum(List<Integer> numbers, List<String> words) {
    int intSum = 0;
    for (int number : numbers) {
        intSum += number;
    }
    int wordLengthSum = 0;
    for (String word : words) {
        wordLengthSum += word.length();
    }
    if (intSum < wordLengthSum) {
        return -1;
    } else if (intSum > wordLengthSum) {
        return 1;
    } else {
        return 0;
    }
}
--------------------------------
boolean allLongerThan(List<String> shortWords, List<String> longWords) {
    int maxOfShort = 0;
    for (String w : shortWords) {
        maxOfShort = Math.max(maxOfShort, w.length());
    }
    int minOfLong = Integer.MAX_VALUE;
    for (String w : longWords) {
        minOfLong = Math.min(minOfLong, w.length());
    }
    return minOfLong > maxOfShort;
}
--------------------------------
int compareOddEvenRange(List<Integer> numbers) {
    int rangeOdd = Collections.max(numbers.stream().filter(n -> n % 2 == 1).collect(Collectors.toList())) - Collections.min(numbers.stream().filter(n -> n % 2 == 1).collect(Collectors.toList()));
    int rangeEven = Collections.max(numbers.stream().filter(n -> n % 2 == 0).collect(Collectors.toList())) - Collections.min(numbers.stream().filter(n -> n % 2 == 0).collect(Collectors.toList()));
    if (rangeOdd < rangeEven) {
        return -1;
    }
    if (rangeOdd > rangeEven) {
        return 1;
    }
    return 0;
}
--------------------------------
double averageDistinctLength(List<String> words) {
    Set<String> distinctWords = new HashSet<>(words);
    double averageLen = distinctWords.stream().mapToInt(String::length).sum() / distinctWords.size();
    return averageLen;
}
--------------------------------
int withDrawBalance(int start, List<Integer> withdrawals) {
    int end = withdrawals.stream().reduce(start, (balance, nextWithdrawal) -> {
        if (nextWithdrawal <= balance) {
            return balance - nextWithdrawal;
        } else {
            return balance;
        }
    });
    return end;
}
--------------------------------
String firstShortAndStartsWithO(List<String> words) {
    return words.stream().filter(w -> w.length() < 5).filter(w -> w.startsWith("o")).findFirst().orElse("");
}
--------------------------------
int bigNumberAtIndex(List<Integer> numbers, int index) {
    int targetNum = numbers.stream().filter(n -> n > 5).skip(index).findFirst().get();
    return targetNum;
}
--------------------------------
boolean containsSquareInRange(int rangeStart, int rangeLength) {
    return Arrays.stream(IntStream.range(rangeStart, rangeStart + rangeLength).toArray())
        .anyMatch(n -> Math.sqrt(n) * Math.sqrt(n) == n);
}
--------------------------------
Map<Integer, List<Integer> > groupNumbersByMod(List<Integer> numbers, int mod) {
    Map<Integer, List<Integer> > numberGroups = new HashMap<>();
    for (Integer k : numbers) {
        numberGroups.computeIfAbsent(k % mod, (m) -> new ArrayList<>()).add(k);
    }
    return numberGroups;
}
--------------------------------
Map<Character, List<String> > groupWordsByFirstChar(List<String> words) {
    Map<Character, List<String> > wordGroups = new HashMap<>();
    for (String word : words) {
        char firstChar = word.charAt(0);
        List<String> wordGroup = wordGroups.get(firstChar);
        if (wordGroup == null) {
            wordGroup = new ArrayList<>();
            wordGroups.put(firstChar, wordGroup);
        }
        wordGroup.add(word);
    }
    return wordGroups;
}
--------------------------------
List<String> orderByLengthAndDescending(List<String> words) {
    List<String> sortedWords = words.stream().sorted(Comparator.comparing(String::length).reversed()).collect(Collectors.toList());
    return sortedWords;
}
--------------------------------
List<String> orderFirstCharDescendingReverse(List<String> words) {
    return words.stream()
        .sorted((w1, w2) -> {
            int c1 = w1.charAt(0);
            int c2 = w2.charAt(0);
            if (c1 == c2) {
                return w2.compareTo(w1);
            }
            return c2 - c1;
        })
        .collect(Collectors.toList());
}
--------------------------------
List<Integer> getSubListOfNegative(List<Integer> numbers, int start, int length) {
    List<Integer> subList = new ArrayList<>();
    for (int i = start; i < numbers.size() && subList.size() < length; i++) {
        if (numbers.get(i) < 0) {
            subList.add(numbers.get(i));
        }
    }
    return subList;
}
--------------------------------
List<Integer> getPositiveSequence(List<Integer> numbers) {
    List<Integer> subSequence = new ArrayList<>();
    for (Integer n : numbers) {
        if (n > 0) {
            subSequence.add(n);
        } else {
            break;
        }
    }
    return subSequence;
}
--------------------------------
List<Integer> getLargerThanIndexSequence(List<Integer> numbers) {
    List<Integer> subSequence = new ArrayList<>();
    for (int i = 0; i < numbers.size(); i++) {
        if (numbers.get(i) >= numbers.get(i + 1)) {
            subSequence.add(numbers.get(i));
        }
    }
    return subSequence;
}
--------------------------------
List<String> rearrangeWordByIndexes(List<String> words, List<Integer> indexes) {
    List<Integer> newIndexes = indexes.stream()
        .filter(n -> n >= words.size())
        .map(n -> n % words.size())
        .collect(Collectors.toList());
    List<String> newWords = newIndexes.stream()
        .map(n -> words.get(n))
        .collect(Collectors.toList());
    return newWords;
}
--------------------------------
List<List<String> > getWordsUpperLower(List<String> words) {
    List<List<String> > upperLowerWords = new ArrayList<List<String> >();
    for (String w : words) {
        List<String> upperLower = new ArrayList<String>();
        upperLower.add(w.toUpperCase());
        upperLower.add(w.toLowerCase());
        upperLowerWords.add(upperLower);
    }
    return upperLowerWords;
}
--------------------------------
List<Boolean> selectIfInPlace(List<Integer> numbers) {
    List<Boolean> numsInPlace = new ArrayList<>();
    for (int index = 0; index < numbers.size(); index++) {
        numsInPlace.add(numbers.get(index) == index);
    }
    return numsInPlace;
}
--------------------------------
List<List<Integer> > selectPairs(List<Integer> numbersA, List<Integer> numbersB) {
    List<List<Integer> > pairs = new ArrayList<>();
    for (Integer a : numbersA) {
        for (Integer b : numbersB) {
            if (a < b) {
                pairs.add(Arrays.asList(a, b));
            }
        }
    }
    return pairs;
}
--------------------------------
List<String> stringCrossJoin(List<String> endWords, List<String> beginWords) {
    List<String> crossStrings = new ArrayList<>();
    for (String b : beginWords) {
        for (String e : endWords) {
            if (b.charAt(0) == e.charAt(e.length() - 1)) {
                crossStrings.add(e + " " + b);
            }
        }
    }
    return crossStrings;
}
--------------------------------
int elementsContainSubword(List<String> words, String subword) {
    if (all(subword::contains, words.subList(0, 5))) {
        return 1;
    } else if (any(subword::contains, words.subList(0, 5))) {
        return 0;
    } else {
        return -1;
    }
}
--------------------------------
List<Integer> ConcatLargeNumbers(List<Integer> numbersA, List<Integer> numbersB, int flag) {
    List<Integer> allNumbers = new ArrayList<>();
    for (int n : numbersA) {
        if (n > flag) {
            allNumbers.add(n);
        }
    }
    for (int n : numbersB) {
        if (n > flag) {
            allNumbers.add(n);
        }
    }
    return allNumbers;
}
--------------------------------
int DotProduct(List<Integer> vectorA, List<Integer> vectorB) {
    int dotProduct = 0;
    for (int i = 0; i < vectorA.size(); i++) {
        dotProduct += vectorA.get(i) * vectorB.get(i);
    }
    return dotProduct;
}
--------------------------------
List<Integer> SetDifference(List<Integer> setA, List<Integer> setB) {
    List<Integer> difference = new ArrayList<Integer>();
    for (int i = 0; i < setA.size(); i++) {
        if (!setB.contains(setA.get(i))) {
            difference.add(setA.get(i));
        }
    }
    for (int i = 0; i < setB.size(); i++) {
        if (!setA.contains(setB.get(i))) {
            difference.add(setB.get(i));
        }
    }
    Collections.sort(difference);
    return difference;
}
--------------------------------
