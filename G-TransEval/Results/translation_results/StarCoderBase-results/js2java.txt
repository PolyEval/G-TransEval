int greatestCommonDivisor(int a, int b) {
    if (a == = 0 || b == = 0) {
        return a + b;
    }
    if (a == = b) {
        return a;
    }
    if (a > b) {
        return greatestCommonDivisor(a % b, b);
    } else {
        return greatestCommonDivisor(a, b % a);
    }
}
--------------------------------
int largestDivisor(int n) {
    for (int i = 2; i <= n; i++) {
        if (n % i == 0) {
            return n / i;
        }
    }
    return 1;
}
--------------------------------
boolean isPrime(int n) {
 if (n < 2) {
   return false;
 }
 for (int k = 2; k < n; k++) {
   if (n % k == 0) {
     return false;
   }
 }
 return true;
}
--------------------------------
int fizzBuzz(int n) {
    int count = 0;
    for (int i = 0; i < n; i++) {
        if (i % 11 == 0 || i % 13 == 0) {
            int q = i;
            while (q > 0) {
                if (q % 10 == 7) {
                    count += 1;
                }
                q = Math.trunc(q / 10);
            }
        }
    }
    return count;
}
--------------------------------
int primeFib(int n) {
    int f0 = 0;
    int f1 = 1;
    while (n > 0) {
        int p = f0 + f1;
        boolean isPrime = p >= 2;
        for (int i = 2; i < p; i++) {
            if (p % i == 0) {
                isPrime = false;
                break;
            }
        }
        if (isPrime) {
            n -= 1;
        }
        f0 = f1;
        f1 = p;
    }
    return f1;
}
--------------------------------
double triangleArea(double a, double h) {
    return a * h / 2;
}
--------------------------------
int modP(int n, int p) {
    int ret = 1;
    for (int i = 0; i < n; i++) {
        ret = (ret * 2) % p;
    }
    return ret;
}
--------------------------------
int add(int x, int y) {
    return x + y;
}
--------------------------------
int fib(int n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    return fib(n - 1) + fib(n - 2);
}
--------------------------------
int largestPrimeFactor(int n) {
    for (int i = 2; i < n; i++) {
        while (n % i == 0 && n > i) {
            n /= i;
        }
    }
    return n;
}
--------------------------------
int sumToN(int n) {
    int result = 0;
    for (int i = 1; i <= n; i++) {
        result += i;
    }
    return result;
}
--------------------------------
int fibfib(int n) {
if (n == = 0) {
return 0;
}
if (n == = 1) {
return 0;
}
if (n == = 2) {
return 1;
}
return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);
}
--------------------------------
boolean isMultiplyPrime(int a) {
    int num = 0;
    for (int i = 2; i <= a; i++) {
        while (a % i == = 0 && a >= i) {
            a /= i;
            num += 1;
        }
    }
    return num == = 3;
}
--------------------------------
boolean isSimplePower(int x, int n) {
    if (n == 1) {
        return x == 1;
    }
    int power = 1;
    while (power < x) {
        power *= n;
    }
    return power == x;
}
--------------------------------
int chooseNum(int x, int y) {
if (x > y) {
return -1;
}
if (y % 2 == 0) {
return y;
}
if (x == y) {
return -1;
}
return y - 1;
}
--------------------------------
boolean isEqualToSumEven(int n) {
    return (n % 2 == 0) && (n >= 8);
}
--------------------------------
int specialFactorial(int n) {
    int fact = 1;
    int specialFact = 1;
    for (int i = 1; i <= n; i++) {
        fact *= i;
        specialFact *= fact;
    }
    return specialFact;
}
--------------------------------
int xOrY(int n, int x, int y) {
    boolean isPrime = n >= 2;
    for (int i = 2; i < n; i++) {
        if (n % i == 0) {
            isPrime = false;
            break;
        }
    }
    if (isPrime) {
        return x;
    }
    return y;
}
--------------------------------
boolean rightAngleTriangle(int a, int b, int c) {
    return a * a == b * b + c * c || b * b == a * a + c * c || c * c == a * a + b * b;
}
--------------------------------
int fastPow(int n, int k) {
    if (k == 0) {
        return 1;
    }
    int temp = fastPow(n, k / 2);
    if (k % 2 == 0) {
        return temp * temp;
    } else {
        return n * temp * temp;
    }
}
--------------------------------
boolean isPalin(String s) {
    int l = s.length() / 2;
    for (int i = 0; i < l; i++) {
        if (s.charAt(i)!= = s.charAt(s.length() - i - 1)) {
            return false;
        }
    }
    return true;
}
--------------------------------
int findSum(int n) {
    int ans = 0, temp = 0;
    for (int i = 1; i <= n && temp < n; i++) {
        temp = i - 1;
        int num = 1;
        while (temp < n) {
            if (temp + i <= n) {
                ans += i * num;
            } else {
                ans += (n - temp) * num;
            }
            temp += i;
            num++;
        }
    }
    return ans;
}
--------------------------------
int getNextGap(int gap) {
    gap = (int) Math.trunc(gap * 10 / 13);
    if (gap < 1) {
        return 1;
    }
    return gap;
}
--------------------------------
int countNonDecreasing(int n) {
    int k = 10;
    int count = 1;
    for (int i = 1; i <= n; i++) {
        count *= k + i - 1;
        count = Math.floor(count / i);
    }
    return count;
}
--------------------------------
int power(int x, int y) {
    if (y == 0) {
        return 1;
    } else if (y % 2 == 0) {
        return power(x, (int) Math.floor(y / 2)) * power(x, (int) Math.floor(y / 2));
    } else {
        return x * power(x, (int) Math.floor(y / 2)) * power(x, (int) Math.floor(y / 2));
    }
}
--------------------------------
double power(double x, int y) {
    if (y == 0) {
        return 1;
    }
    double temp = power(x, (int) Math.floor(y / 2));
    if (y % 2 == 0) {
        return temp * temp;
    } else {
        if (y > 0) {
            return x * temp * temp;
        } else {
            return temp * temp / x;
        }
    }
}
--------------------------------
int multiply(int x, int y) {
    if (y == 0) {
        return 0;
    } else if (y > 0) {
        return x + multiply(x, y - 1);
    } else {
        return -multiply(x, -y);
    }
}
--------------------------------
int smallest(int x, int y, int z) {
    if (y / x!= Math.floor(y / x)) {
        return y / z!= Math.floor(y / z)? y : z;
    }
    return x / z!= Math.floor(x / z)? x : z;
}
--------------------------------
boolean isPowerOfFour(int n) {
    if (n == 0) {
        return false;
    }
    while (n!= 1) {
        if (n % 4!= 0) {
            return false;
        }
        n = n / 4;
    }
    return true;
}
--------------------------------
int modInverse(int a, int m) {
    int m0 = m;
    int x0 = 0, x1 = 1;
    if (m == 1) {
        return 0;
    }
    while (a > 1) {
        int q = (int) Math.trunc(a / m);
        int t = m;
        m = a % m;
        a = t;
        t = x0;
        x0 = x1 - q * x0;
        x1 = t;
    }
    if (x1 < 0) {
        x1 += m0;
    }
    return x1;
}
--------------------------------
int cntRotations(String s, int n) {
    String s2 = s + s;
    int[] pre = new int[2 * n];
    for (int i = 0; i < 2 * n; i++) {
        if (i!= 0) {
            pre[i] += pre[i - 1];
        }
        if (s2.charAt(i) == 'a' || s2.charAt(i) == 'e' || s2.charAt(i) == 'i' || s2.charAt(i) == 'o' || s2.charAt(i) == 'u') {
            pre[i]++;
        }
    }
    int ans = 0;
    for (int i = n - 1; i < 2 * n - 1; i++) {
        int r = i, l = i - n;
        int x1 = pre[r];
        if (l >= 0) {
            x1 -= pre[l];
        }
        r = i - Math.floor(n / 2);
        int left = pre[r];
        if (l >= 0) {
            left -= pre[l];
        }
        int right = x1 - left;
        if (left > right) {
            ans++;
        }
    }
    return ans;
}
--------------------------------
int binomialCoeff(int n, int k) {
    int res = 1;
    if (k > n - k) {
        k = n - k;
    }
    for (int i = 0; i < k; ++i) {
        res *= n - i;
        res = (int) Math.floor(res / (i + 1));
    }
    return res;
}
--------------------------------
boolean isPrefix(String temp, String s) {
    if (temp.length() < s.length()) {
        return false;
    } else {
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i)!= temp.charAt(i)) {
                return false;
            }
        }
        return true;
    }
}
--------------------------------
String lexicographicallySmallestString(String s, int n) {
    int lastZe = -1;
    String ans = "";
    for (int i = n - 1; i >= 0; i--) {
        if (s.charAt(i) == '0') {
            lastZe = i;
            break;
        }
    }
    for (int i = 0; i < n; i++) {
        if (i <= lastZe && s.charAt(i) == '0') {
            ans += s.charAt(i);
        } else if (i > lastZe) {
            ans += s.charAt(i);
        }
    }
    return ans;
}
--------------------------------
int calculateMax(int n, int m, int k) {
    int low = 0, high = m;
    int ans = -1;
    while (low <= high) {
        int mid = (low + high) / 2;
        int val = 0;
        int l = k - 1;
        int r = n - k;
        val += mid;
        if (mid >= l) {
            val += l * (2 * mid - l - 1) / 2;
        } else {
            val += mid * (mid - 1) / 2 + (l - mid);
        }
        if (mid >= r) {
            val += r * (2 * mid - r - 1) / 2;
        } else {
            val += mid * (mid - 1) / 2 + (r - mid);
        }
        if (val <= m) {
            ans = Math.max(ans, mid);
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return ans;
}
--------------------------------
int findLength(String s, char i, char j) {
    int required = i;
    int length = 0;
    for (char curr : s.toCharArray()) {
        if (curr == required) {
            length += 1;
            if (required == i) {
                required = j;
            } else {
                required = i;
            }
        }
    }
    return length;
}
--------------------------------
boolean checkReverse(int leftSum, int rightSum) {
    int rev = 0;
    int temp = rightSum;
    while (temp!= = 0) {
        rev = rev * 10 + temp % 10;
        temp = Math.trunc(temp / 10);
    }
    if (rev == = leftSum) {
        return true;
    }
    return false;
}
--------------------------------
boolean isComposite(int n) {
    if (n <= 1) {
        return false;
    }
    if (n <= 3) {
        return false;
    }
    if (n % 2 == = 0 || n % 3 == = 0) {
        return true;
    }
    for (int i = 5; i * i <= n; i = i + 6) {
        if (n % i == = 0 || n % (i + 2) == = 0) {
            return true;
        }
    }
    return false;
}
--------------------------------
int minDeletion(String s) {
    int n = s.length();
    int firstIdx1 = -1;
    int lastIdx0 = -1;
    for (int i = 0; i < n; i++) {
        if (s.charAt(i) == = '1') {
            firstIdx1 = i;
            break;
        }
    }
    for (int i = n - 1; i >= 0; i--) {
        if (s.charAt(i) == = '0') {
            lastIdx0 = i;
            break;
        }
    }
    if (firstIdx1 == = -1 || lastIdx0 == = -1) {
        return 0;
    }
    int count1 = 0, count0 = 0;
    for (int i = 0; i < lastIdx0; i++) {
        if (s.charAt(i) == = '1') {
            count1++;
        }
    }
    for (int i = firstIdx1 + 1; i < n; i++) {
        if (s.charAt(i) == = '1') {
            count0++;
        }
    }
    return Math.min(count0, count1);
}
--------------------------------
int minSteps(String s, int n) {
    int[] f = new int[26];
    int cost = 0;
    for (int i = 0; i < n; i++) {
        int currEle = s.charAt(i) - 'a';
        int smaller = 0;
        for (int j = 0; j <= currEle; j++) {
            if (f[j]!= 0) {
                smaller += f[j];
            }
        }
        if (smaller == 0) {
            cost += i + 1;
        } else {
            cost += i - smaller + 1;
        }
        f[s.charAt(i) - 'a']++;
    }
    return cost;
}
--------------------------------
int numberOfWays(int n) {
    int count = 0;
    for (int a = 1; a < n; a++) {
        for (int b = 1; b < n; b++) {
            int c = n - (a + b);
            if (a + b > c && a + c > b && b + c > a) {
                count++;
            }
        }
    }
    return count;
}
--------------------------------
int slopeOfNum(String num, int n) {
    int slope = 0;
    for (int i = 1; i < n - 1; i++) {
        if (num.charAt(i) > num.charAt(i - 1) && num.charAt(i) > num.charAt(i + 1)) {
            slope++;
        } else if (num.charAt(i) < num.charAt(i - 1) && num.charAt(i) < num.charAt(i + 1)) {
            slope++;
        }
    }
    return slope;
}
--------------------------------
int middleOfThree(int a, int b, int c) {
    int x = a - b;
    int y = b - c;
    int z = a - c;
    if (x * y > 0) {
        return b;
    } else if (x * z > 0) {
        return c;
    } else {
        return a;
    }
}
--------------------------------
int countMaxSetBits(int left, int right) {
    while ((left | (left + 1)) <= right) {
        left |= left + 1;
    }
    return left;
}
--------------------------------
int findS(int s) {
    int l = 1, r = (int) Math.floor(s / 2) + 1;
    while (l <= r) {
        int mid = (int) Math.floor((l + r) / 2);
        int sum = mid * (mid + 1) / 2;
        if (sum == s) {
            return mid;
        } else if (sum > s) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return -1;
}
--------------------------------
boolean check(String s) {
    int min = Integer.MAX_VALUE;
    int max = -Integer.MAX_VALUE;
    int sum = 0;
    for (int i = 0; i < s.length(); i++) {
        int ascii = s.charAt(i);
        if (ascii < 96 || ascii > 122) {
            return false;
        }
        sum += ascii;
        if (min > ascii) {
            min = ascii;
        }
        if (max < ascii) {
            max = ascii;
        }
    }
    min -= 1;
    int eSum = max * (max + 1) / 2 - min * (min + 1) / 2;
    return sum == eSum;
}
--------------------------------
int minimumPossibleProduct(int k) {
    int res = 1;
    int r = (1 << k) - 1;
    for (int i = 0; i < k; i++) {
        res *= r - 1;
    }
    res *= r;
    return res;
}
--------------------------------
int findInGrid(int i, int j) {
    if (i == j) {
        return i * i - (i - 1);
    } else if (i > j) {
        if (i % 2 == 0) {
            return i * i - (j - 1);
        } else {
            return (i - 1) * (i - 1) + 1 + (j - 1);
        }
    } else {
        if (j % 2 == 0) {
            return (j - 1) * (j - 1) + 1 + (i - 1);
        } else {
            return j * j - (i - 1);
        }
    }
}
--------------------------------
int findMinOperationsReqEmpStr(String s) {
    int cntOne = 0;
    int cntZero = 0;
    int n = s.length();
    for (int i = 0; i < n; i++) {
        if (s.charAt(i) == '0') {
            if (cntOne!= 0) {
                cntOne--;
            }
            cntZero++;
        } else {
            if (cntZero!= 0) {
                cntZero--;
            }
            cntOne++;
        }
    }
    return cntOne + cntZero;
}
--------------------------------
boolean isReachable(int x1, int y1, int x2, int y2) {
    while (x2 > x1 && y2 > y1) {
        if (x2 > y2) {
            x2 %= y2;
        } else {
            y2 %= x2;
        }
    }
    if (x2 == = x1) {
        return (y2 - y1) >= 0 && (y2 - y1) % x1 == = 0;
    } else if (y2 == = y1) {
        return (x2 - x1) >= 0 && (x2 - x1) % y1 == = 0;
    } else {
        return false;
    }
}
--------------------------------
int findMaxSoln(int n, int x, int y) {
    int ans = -Integer.MAX_VALUE;
    for (int k = 0; k <= n; k++) {
        if (k % x == y) {
            ans = Math.max(ans, k);
        }
    }
    return ans >= 0 && ans <= n? ans : -1;
}
--------------------------------
int numberOfPairs(int n) {
    int count = 0;
    int i = 1, j = n - 1;
    while (i < j) {
        if (i + j == n) {
            count++;
        }
        i++;
        j--;
    }
    return count;
}
--------------------------------
int minChanges(String s, int n) {
    int count = 0, zeros = 0, ones = 0;
    if (s.charAt(0)!= = "1") {
        count++;
        ones++;
    }
    for (int i = 1; i < n; i++) {
        if (s.charAt(i) == = "0") {
            zeros++;
        } else {
            ones++;
        }
        if (zeros > ones) {
            zeros--;
            ones++;
            count++;
        }
    }
    return count;
}
--------------------------------
int kVisibleFromLeft(int n, int k) {
    if (n == k) {
        return 1;
    }
    if (k == 1) {
        int ans = 1;
        for (int i = 1; i < n; i++) {
            ans *= i;
        }
        return ans;
    }
    return kVisibleFromLeft(n - 1, k - 1) + (n - 1) * kVisibleFromLeft(n - 1, k);
}
--------------------------------
double find(int n, int sum) {
    if (sum > 6 * n || sum < n) {
        return 0;
    }
    if (n == 1) {
        if (sum >= 1 && sum <= 6) {
            return 1.0 / 6;
        } else {
            return 0;
        }
    }
    double s = 0;
    for (int i = 1; i <= 6; i++) {
        s += find(n - 1, sum - i) / 6;
    }
    return s;
}
--------------------------------
int binCoff(int n, int r) {
    int val = 1;
    int i;
    if (r > n - r) {
        r = n - r;
    }
    for (i = 0; i < r; i++) {
        val *= n - i;
        val /= i + 1;
    }
    return val;
}
--------------------------------
int getMask(int val) {
    int mask = 0;
    if (val == 0) {
        return 1;
    }
    while (val) {
        int d = val % 10;
        mask |= (1 << d);
        val = (int) Math.floor(val / 10);
    }
    return mask;
}
--------------------------------
int waysToKAdjacentSetBits(int n, int k, int currentIndex, int adjacentSetBits, int lastBit) {
if (currentIndex == n) {
if (adjacentSetBits == k) {
return 1;
}
return 0;
}
int noOfWays = 0;
if (lastBit == 1) {
noOfWays += waysToKAdjacentSetBits(n, k, currentIndex + 1, adjacentSetBits + 1, 1);
noOfWays += waysToKAdjacentSetBits(n, k, currentIndex + 1, adjacentSetBits, 0);
} else if (!lastBit) {
noOfWays += waysToKAdjacentSetBits(n, k, currentIndex + 1, adjacentSetBits, 1);
noOfWays += waysToKAdjacentSetBits(n, k, currentIndex + 1, adjacentSetBits, 0);
}
return noOfWays;
}
--------------------------------
int checkFunc(int i, int j, String st) {
    if (st.charAt(i) == '(' && st.charAt(j) == ')') {
        return 1;
    }
    if (st.charAt(i) == '(' && st.charAt(j) == '?') {
        return 1;
    }
    if (st.charAt(i) == '?' && st.charAt(j) == ')') {
        return 1;
    }
    if (st.charAt(i) == '[' && st.charAt(j) == ']') {
        return 1;
    }
    if (st.charAt(i) == '[' && st.charAt(j) == '?') {
        return 1;
    }
    if (st.charAt(i) == '?' && st.charAt(j) == ']') {
        return 1;
    }
    if (st.charAt(i) == '{' && st.charAt(j) == '}') {
        return 1;
    }
    if (st.charAt(i) == '{' && st.charAt(j) == '?') {
        return 1;
    }
    if (st.charAt(i) == '?' && st.charAt(j) == '}') {
        return 1;
    }
    return 0;
}
--------------------------------
int findGolomb(int n) {
    if (n == 1) {
        return 1;
    }
    return 1 + findGolomb(n - findGolomb(findGolomb(n - 1)));
}
--------------------------------
boolean allOnes(String s, int n) {
    int co = 0;
    for (int i = 0; i < s.length(); i++) {
        co += s.charAt(i) == = '1'? 1 : 0;
    }
    return co == = n;
}
--------------------------------
int pad(int n) {
    int pPrevPrev = 1, pPrev = 1, pCurr = 1, pNext = 1;
    for (int i = 3; i <= n; i++) {
        pNext = pPrevPrev + pPrev;
        pPrevPrev = pPrev;
        pPrev = pCurr;
        pCurr = pNext;
    }
    return pNext;
}
--------------------------------
int oddLengthPalindrome(int k) {
    int palin = k;
    k = k / 10;
    while (k > 0) {
        int rev = k % 10;
        palin = palin * 10 + rev;
        k = k / 10;
    }
    return palin;
}
--------------------------------
String changeString(String s0) {
    String[] s = s0.split("");
    int n = s0.length();
    if (s[0] == "?") {
        s[0] = "a";
        if (s[0] == s[1]) {
            s[0] = String.valueOf(s[0].charAt(0) + 1);
        }
    }
    for (int i = 1; i < n - 1; i++) {
        if (s[i] == "?") {
            s[i] = "a";
            if (s[i] == s[i - 1]) {
                s[i] = String.valueOf(s[i].charAt(0) + 1);
            }
            if (s[i] == s[i + 1]) {
                s[i] = String.valueOf(s[i].charAt(0) + 1);
            }
            if (s[i] == s[i - 1]) {
                s[i] = String.valueOf(s[i].charAt(0) + 1);
            }
        }
    }
    if (s[n - 1] == "?") {
        s[n - 1] = "a";
        if (s[n - 1] == s[n - 2]) {
            s[n - 1] = String.valueOf(s[n - 1].charAt(0) + 1);
        }
    }
    return String.join("", s);
}
--------------------------------
int totalHammingDistance(int n) {
    int i = 1, sum = 0;
    while (Math.floor(n / i) > 0) {
        sum = sum + Math.floor(n / i);
        i = i * 2;
    }
    return sum;
}
--------------------------------
int checkBitonic(String s) {
    int i = 1;
    for (; i < s.length(); i++) {
        if (s.charAt(i) > s.charAt(i - 1)) {
            continue;
        }
        if (s.charAt(i) <= s.charAt(i - 1)) {
            break;
        }
    }
    if (i == s.length() - 1) {
        return 1;
    }
    int j = i + 1;
    for (; j < s.length(); j++) {
        if (s.charAt(j) < s.charAt(j - 1)) {
            continue;
        }
        if (s.charAt(j) >= s.charAt(j - 1)) {
            break;
        }
    }
    i = j;
    if (i!= s.length()) {
        return 0;
    }
    return 1;
}
--------------------------------
boolean endsWith(String str, String pat) {
    int patLen = pat.length();
    int strLen = str.length();
    if (patLen > strLen) {
        return false;
    }
    patLen--;
    strLen--;
    while (patLen >= 0) {
        if (pat.charAt(patLen)!= str.charAt(strLen)) {
            return false;
        }
        patLen--;
        strLen--;
    }
    return true;
}
--------------------------------
int getSum(int n, int d) {
    if (n < d) {
        return 0;
    }
    while (n % 10!= d) {
        n--;
    }
    int k = (int) Math.floor(n / 10);
    return (k + 1) * d + (k * 10 + 10 * k * k) / 2;
}
--------------------------------
int balancedStringBySwapping(String s) {
    int unbalancedPair = 0;
    for (int i = 0; i < s.length(); ++i) {
        if (unbalancedPair > 0 && s.charAt(i) == = "]") {
            --unbalancedPair;
        } else if (s.charAt(i) == = "[") {
            ++unbalancedPair;
        }
    }
    return (unbalancedPair + 1) / 2;
}
--------------------------------
int computeHash(String s) {
    int p = 31;
    int mod = 1e9 + 7;
    int hashVal = 0;
    int mul = 1;
    for (char ch : s.toCharArray()) {
        hashVal = (hashVal + (ch - 'a' + 1) * mul) % mod;
        mul = mul * p % mod;
    }
    return hashVal;
}
--------------------------------
int countOfSubstringWithOnlyOnes(String s) {
    int res = 0, count = 0;
    for (int i = 0; i < s.length(); i++) {
        count = s.charAt(i) == '1'? count + 1 : 0;
        res = res + count;
    }
    return res;
}
--------------------------------
int composite(int n) {
    int flag = 0;
    int c = 0;
    for (int j = 1; j <= n; j++) {
        if (n % j == 0) {
            c += 1;
        }
    }
    if (c >= 3) {
        flag = 1;
    }
    return flag;
}
--------------------------------
boolean isDivBySix(String s, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += s.charAt(i) - 'a' + 1;
    }
    if (sum % 3!= = 0) {
        return false;
    }
    int lastDigit = (s.charAt(n - 1) - 'a' + 1) % 10;
    if (lastDigit % 2!= = 0) {
        return false;
    }
    return true;
}
--------------------------------
boolean IsRedundantBraces(String s) {
    int a = 0, b = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '(' && s.charAt(i + 2) == ')') {
            return true;
        }
        if (s.charAt(i) == '*' || s.charAt(i) == '+' || s.charAt(i) == '-' || s.charAt(i) == '/') {
            a++;
        }
        if (s.charAt(i) == '(') {
            b++;
        }
    }
    if (b > a) {
        return true;
    }
    return false;
}
--------------------------------
int countSubStr(String s, int n) {
    int count = 0;
    for (int i = 0; i < n - 2;) {
        if (s.charAt(i) == = '0' && s.charAt(i + 1) == = '1' && s.charAt(i + 2) == = '0') {
            count++;
            i += 3;
        } else if (s.charAt(i) == = '1' && s.charAt(i + 1) == = '0' && s.charAt(i + 2) == = '1') {
            count++;
            i += 3;
        } else {
            i++;
        }
    }
    return count;
}
--------------------------------
int prefixOccurrences(String s) {
    char c = s.charAt(0);
    int countC = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == c) {
            countC++;
        }
    }
    return countC;
}
--------------------------------
boolean isValid(String s, int len) {
    for (int i = 1; i < len; i++) {
        if (s.charAt(i) == s.charAt(i - 1)) {
            return false;
        }
    }
    return true;
}
--------------------------------
int count(String s, int k) {
    int n = s.length();
    int d = 0;
    int count = 0;
    for (int i = 0; i < n; i++) {
        d += s.charAt(i);
    }
    if (d % k == 0) {
        count += 1;
    }
    for (int i = k; i < n; i++) {
        int prev = s.charAt(i - k);
        d -= prev;
        d += s.charAt(i);
        if (d % k == 0) {
            count += 1;
        }
    }
    return count;
}
--------------------------------
int findSubstringCount(String s) {
    int result = 0;
    int n = s.length();
    int i = 0;
    while (i < n - 1) {
        if (s.charAt(i).charCodeAt(0) + 1 == = s.charAt(i + 1).charCodeAt(0)) {
            result++;
            while (i < n - 1 && s.charAt(i).charCodeAt(0) + 1 == = s.charAt(i + 1).charCodeAt(0)) {
                i++;
            }
        }
        i++;
    }
    return result;
}
--------------------------------
boolean find(String s1, String s2) {
    int len1 = s1.length(), len2 = s2.length();
    if (len1!= len2) {
        return false;
    }
    int[] d = new int[len1];
    d[0] = s2.charAt(0) - s1.charAt(0);
    for (int i = 1; i < len1; i++) {
        if (s1.charAt(i) > s2.charAt(i)) {
            return false;
        } else {
            d[i] = s2.charAt(i) - s1.charAt(i);
        }
    }
    for (int i = 0; i < len1 - 1; i++) {
        if (d[i] < d[i + 1]) {
            return false;
        }
    }
    return true;
}
--------------------------------
boolean isInGivenBase(String s, int bas) {
    if (bas > 16) {
        return false;
    } else if (bas <= 10) {
        for (int i = 0; i < s.length(); i++) {
            if (!(s.charAt(i) >= '0' && s.charAt(i) < '0' + bas)) {
                return false;
            }
        }
    } else {
        for (int i = 0; i < s.length(); i++) {
            if (!((s.charAt(i) >= '0' && s.charAt(i) < '0' + bas) || (s.charAt(i) >= 'A' && s.charAt(i) < 'A' + bas - 10))) {
                return false;
            }
        }
    }
    return true;
}
--------------------------------
int countNonEmptySubstr(String s) {
    int n = s.length();
    return n * (n + 1) / 2;
}
--------------------------------
int evenDecimalValue(String s, int n) {
    int result = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            int decimalValue = 0;
            int powerOf2 = 1;
            for (int k = i; k <= j; k++) {
                decimalValue += (s.charAt(k) - '0') * powerOf2;
                powerOf2 *= 2;
            }
            if (decimalValue % 2 == 0) {
                result++;
            }
        }
    }
    return result;
}
--------------------------------
int calculate(String s) {
    int ans = 6;
    for (int i = 0; i < 10; ++i) {
        for (int j = 0; j < 10; ++j) {
            for (int k = 0; k < 10; ++k) {
                for (int l = 0; l < 10; ++l) {
                    for (int m = 0; m < 10; ++m) {
                        for (int n = 0; n < 10; ++n) {
                            if (i + j + k == l + m + n) {
                                int c = 0;
                                if (i!= s.charAt(0) - '0') {
                                    c++;
                                }
                                if (j!= s.charAt(1) - '0') {
                                    c++;
                                }
                                if (k!= s.charAt(2) - '0') {
                                    c++;
                                }
                                if (l!= s.charAt(3) - '0') {
                                    c++;
                                }
                                if (m!= s.charAt(4) - '0') {
                                    c++;
                                }
                                if (n!= s.charAt(5) - '0') {
                                    c++;
                                }
                                if (c < ans) {
                                    ans = c;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return ans;
}
--------------------------------
int xorZero(String s) {
    int oneCount = 0, zeroCount = 0;
    int n = s.length();
    for (int i = 0; i < n; i++) {
        if (s.charAt(i) == = '1') {
            oneCount++;
        } else {
            zeroCount++;
        }
    }
    if (oneCount % 2 == = 0) {
        return zeroCount;
    }
    return oneCount;
}
--------------------------------
String evenLength(String n) {
    String res = n;
    for (int j = n.length() - 1; j >= 0; --j) {
        res += n.charAt(j);
    }
    return res;
}
--------------------------------
int countSubstringWithEqualEnds(String s) {
    int result = 0;
    int n = s.length();
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            if (s.charAt(i) == = s.charAt(j)) {
                result++;
            }
        }
    }
    return result;
}
--------------------------------
double normalSlope(double a, double b, double x1, double y1) {
    double g = a / 2;
    double f = b / 2;
    if (g - x1 == 0) {
        return -1;
    }
    double slope = (f - y1) / (g - x1);
    if (slope == 0) {
        return -2;
    }
    return slope;
}
--------------------------------
boolean orthogonality(int x1, int y1, int x2, int y2, int r1, int r2) {
    int dsquare = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
    if (dsquare == = r1 * r1 + r2 * r2) {
        return true;
    } else {
        return false;
    }
}
--------------------------------
double findAreaShaded(double a) {
    double sqArea = a * a;
    double semiCircleArea = 3.14 * (a * a) / 8;
    double shadedArea = 4 * semiCircleArea - sqArea;
    return shadedArea;
}
--------------------------------
int factorial(int a, int b) {
    int res = 1;
    for (int i = 1; i <= a + b; i++) {
        res = res * i;
    }
    for (int i = 1; i <= a; i++) {
        res = res / i;
    }
    for (int i = 1; i <= b; i++) {
        res = res / i;
    }
    return res;
}
--------------------------------
int factorTree(int n) {
    int height = 0;
    while (n > 1) {
        boolean flag = false;
        for (int i = 2; i <= Math.sqrt(n); i++) {
            if (n % i == 0) {
                n = Math.floor(n / i);
                flag = true;
                break;
            }
        }
        height++;
        if (!flag) {
            break;
        }
    }
    return height;
}
--------------------------------
String findIfPossible(int n, int s, int x) {
    if (s >= x && s % 2 == x % 2) {
        if (n >= 3) {
            return "Yes";
        }
        if (n == 1) {
            if (s == x) {
                return "Yes";
            } else {
                return "No";
            }
        }
        if (n == 2) {
            int c = (s - x) / 2;
            int a = c;
            int b = c;
            a = a + x;
            if ((a ^ b) == x) {
                return "Yes";
            } else {
                return "No";
            }
        }
    }
    return "No";
}
--------------------------------
int maximumTripletXor(int a, int b, int c) {
    int ans = 0;
    for (int i = 30; i >= 0; i--) {
        int cur = 1 << i;
        if (a >= cur) {
            ans += cur;
            a -= cur;
        } else if (b >= cur) {
            ans += cur;
            b -= cur;
        } else if (c >= cur) {
            ans += cur;
            c -= cur;
        }
    }
    return ans;
}
--------------------------------
int itemType(int n) {
    int count = 0;
    int day = 1;
    while (count + day * (day + 1) / 2 < n) {
        count += day * (day + 1) / 2;
        day++;
    }
    for (int type = day; type > 0; type--) {
        count += type;
        if (count >= n) {
            return type;
        }
    }
}
--------------------------------
int maxGcdInRange(int l, int r) {
    int ans = 1;
    for (int z = r; z >= 1; z--) {
        if (Math.floor(r / z) - Math.floor((l - 1) / z) > 1) {
            ans = z;
            break;
        }
    }
    return ans;
}
--------------------------------
int sumOfDigits(int n) {
    int sum = 0;
    while (n!= 0) {
        sum += n % 10;
        n = Math.trunc(n / 10);
    }
    return sum;
}
--------------------------------
boolean isRepUnitNum(int n, int b) {
    int length = 0;
    int countOne = 0;
    while (n!= = 0) {
        int r = n % b;
        length++;
        if (r == = 1) {
            countOne++;
        }
        n = Math.trunc(n / b);
    }
    return countOne >= 3 && countOne == = length;
}
--------------------------------
boolean isStraightLineNum(int n) {
    if (n <= 99) {
        return false;
    }
    String s = Integer.toString(n);
    int d = s.charAt(1) - s.charAt(0);
    for (int i = 2; i < s.length(); i++) {
        if (s.charAt(i) - s.charAt(i - 1)!= d) {
            return false;
        }
    }
    return true;
}
--------------------------------
int getCount(int d, int n) {
    int no = (int) Math.floor(n / d);
    int result = no;
    for (int p = 2; p * p <= no; ++p) {
        if (no % p == 0) {
            while (no % p == 0) {
                no = (int) Math.floor(no / p);
            }
            result = (int) Math.floor(result - result / p);
        }
    }
    if (no > 1) {
        result = (int) Math.floor(result - result / no);
    }
    return result;
}
--------------------------------
boolean isEvenParity(int x) {
    int parity = 0;
    while (x!= = 0) {
        if (x % 2 == = 1) {
            parity++;
        }
        x = x >> 1;
    }
    if (parity % 2 == = 0) {
        return true;
    } else {
        return false;
    }
}
--------------------------------
int isPerfect(int n) {
    int sum = 1;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            if (i * i!= n) {
                sum = sum + i + n / i;
            } else {
                sum = sum + i;
            }
        }
    }
    if (sum == n && n!= 1) {
        return n;
    }
    return 0;
}
--------------------------------
int logAToBaseB(int a, int b) {
    return a > b - 1? 1 + logAToBaseB(Math.floor(a / b), b) : 0;
}
--------------------------------
int usingBinarySearch(int start, int end, int n, int s) {
    if (start >= end) {
        return start;
    }
    int mid = start + (end - start) / 2;
    int totalSum = n * (n + 1) / 2;
    int midSum = mid * (mid + 1) / 2;
    if (totalSum - midSum <= s) {
        return usingBinarySearch(start, mid, n, s);
    }
    return usingBinarySearch(mid + 1, end, n, s);
}
--------------------------------
String minInt(String s) {
    char[] s1 = s.toCharArray();
    for (int i = 0; i < s.length(); i++) {
        if (s1[i] >= '5') {
            s1[i] = (char) ('9' - s1[i] + '0');
        }
    }
    if (s1[0] == '0') {
        s1[0] = '9';
    }
    return String.valueOf(s1);
}
--------------------------------
int countTriplets(int a, int b, int c) {
    int ans = 0;
    for (int i = 1; i <= a; i++) {
        for (int j = 1; j <= b; j++) {
            for (int k = 1; k <= c; k++) {
                if (i * k > j * j) {
                    ans++;
                }
            }
        }
    }
    return ans;
}
--------------------------------
boolean topsyTurvy(String s) {
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == = '2' || s.charAt(i) == = '4' || s.charAt(i) == = '5' || s.charAt(i) == = '6' || s.charAt(i) == = '7' || s.charAt(i) == = '9') {
            return false;
        }
    }
    return true;
}
--------------------------------
int sumOfLastDig(int n, int m) {
    int sum = 0;
    int k = (int)Math.floor(n / m);
    int[] arr = new int[10];
    for (int i = 0; i < 10; i++) {
        arr[i] = (m * (i + 1)) % 10;
        sum += arr[i];
    }
    int rem = k % 10;
    int ans = (int)Math.floor(k / 10) * sum;
    for (int i = 0; i < rem; i++) {
        ans += arr[i];
    }
    return ans;
}
--------------------------------
int totalPay(int totalItems, int priceOfOneItem, int n, int m) {
    int freeItems = 0, actual = 0;
    freeItems = totalItems / (n + m);
    actual = totalItems - freeItems;
    int amount = actual * priceOfOneItem;
    return amount;
}
--------------------------------
int minOperations(int x, int y, int p, int q) {
    if (y % x!= = 0) {
        return -1;
    }
    int d = (int) Math.trunc(y / x);
    int a = 0;
    while (d % p == = 0) {
        d = (int) Math.trunc(d / p);
        a += 1;
    }
    int b = 0;
    while (d % q == = 0) {
        d = (int) Math.trunc(d / q);
        b += 1;
    }
    if (d!= = 1) {
        return -1;
    }
    return a + b;
}
--------------------------------
boolean isMersenne(int n) {
    while (n!= 0) {
        int r = n % 2;
        if (r == 0) {
            return false;
        }
        n = n / 2;
    }
    return true;
}
--------------------------------
int findThirdDigit(int n) {
    if (n < 3) {
        return 0;
    }
    return n & 1? 1 : 6;
}
--------------------------------
boolean isOddLength(int num) {
    int count = 0;
    while (num > 0) {
        num = Math.floor(num / 10);
        count++;
    }
    if (count % 2!= 0) {
        return true;
    }
    return false;
}
--------------------------------
boolean checkIsPossible(int l, int r, int k) {
    int count = 0;
    for (int i = l; i <= r; i++) {
        if (i % k == 0) {
            count++;
        }
    }
    return count > 1;
}
--------------------------------
int bytes(int kilobytes) {
    int b = kilobytes * 1024;
    return b;
}
--------------------------------
int octahedralNum(int n) {
    return n * (2 * n * n + 1) / 3;
}
--------------------------------
String checkEqual(String s) {
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i)!= = '1' && s.charAt(i)!= = '0' && s.charAt(i)!= = '8') {
            return "No";
        }
    }
    int start = 0, end = s.length() - 1;
    while (start < end) {
        if (s.charAt(start)!= = s.charAt(end)) {
            return "No";
        }
        start++;
        end--;
    }
    return "Yes";
}
--------------------------------
boolean isUndulating(String n) {
    if (n.length() <= 2) {
        return false;
    }
    for (int i = 2; i < n.length(); i++) {
        if (n.charAt(i - 2)!= = n.charAt(i)) {
            return false;
        }
    }
    return true;
}
--------------------------------
int firstDigit(int n) {
    while (n >= 10) {
        n = (int) Math.floor(n / 10);
    }
    return n;
}
--------------------------------
int countDigit(int n) {
    if (n == 0) {
        return 0;
    }
    return 1 + countDigit(Math.trunc(n / 10));
}
--------------------------------
boolean isDivisibleBy5(String s) {
    int n = s.length();
    return s.charAt(n - 1) - '0' == 0 || s.charAt(n - 1) - '0' == 5;
}
--------------------------------
int inv(int a, int m) {
    int m0 = m;
    int x0 = 0, x1 = 1;
    if (m == 1) {
        return 0;
    }
    while (a > 1) {
        int q = (int) Math.trunc(a / m);
        int t = m;
        m = a % m;
        a = t;
        t = x0;
        x0 = x1 - q * x0;
        x1 = t;
    }
    if (x1 < 0) {
        x1 += m0;
    }
    return x1;
}
--------------------------------
boolean onlyFirstAndLastAreSet(int n) {
    if (n == 1) {
        return true;
    }
    if (n == 2) {
        return false;
    }
    return ((n - 1) & (n - 2)) == 0;
}
--------------------------------
int divide(int dividend, int divisor) {
    int sign = ((dividend < 0) ^ (divisor < 0))? -1 : 1;
    dividend = Math.abs(dividend);
    divisor = Math.abs(divisor);
    int quotient = 0, temp = 0;
    for (int i = 31; i >= 0; --i) {
        if (temp + (divisor << i) <= dividend) {
            temp += divisor << i;
            quotient |= 1 << i;
        }
    }
    if (sign == -1) {
        quotient = -quotient;
    }
    return quotient;
}
--------------------------------
char findProfession(int level, int pos) {
    if (level == 1) {
        return 'e';
    }
    if (findProfession(level - 1, (pos + 1) / 2) == 'd') {
        return pos % 2? 'd' : 'e';
    }
    return pos % 2? 'e' : 'd';
}
--------------------------------
boolean hasCloseElements(List<Double> numbers, double threshold) {
    for (int i = 0; i < numbers.size(); i++) {
        for (int j = i + 1; j < numbers.size(); j++) {
            double distance = Math.abs(numbers.get(i) - numbers.get(j));
            if (distance < threshold) {
                return true;
            }
        }
    }
    return false;
}
--------------------------------
double truncateNumber(double number) {
    return number % 1;
}
--------------------------------
boolean belowZero(List<Integer> operations) {
    int balance = 0;
    for (int op : operations) {
        balance += op;
        if (balance < 0) {
            return true;
        }
    }
    return false;
}
--------------------------------
double meanAbsoluteDeviation(List<Double> numbers) {
    double sumNum = 0;
    for (double num : numbers) {
        sumNum += num;
    }
    double mean = sumNum / numbers.length;
    double sumAbsDiff = 0;
    for (double num : numbers) {
        sumAbsDiff += Math.abs(num - mean);
    }
    return sumAbsDiff / numbers.length;
}
--------------------------------
List<Integer> intersperse(List<Integer> numbers, int delimiter) {
    List<Integer> result = new ArrayList<>();
    if (numbers.size() == 0) {
        return result;
    }
    for (int i = 0; i < numbers.size() - 1; i++) {
        result.add(numbers.get(i));
        result.add(delimiter);
    }
    result.add(numbers.get(numbers.size() - 1));
    return result;
}
--------------------------------
List<Integer> sumProduct(List<Integer> numbers) {
    int sumValue = 0;
    int prodValue = 1;
    for (int n : numbers) {
        sumValue += n;
        prodValue *= n;
    }
    return Arrays.asList(sumValue, prodValue);
}
--------------------------------
List<String> allPrefixes(String s) {
    List<String> result = new ArrayList<>();
    for (int i = 1; i <= s.length(); i++) {
        result.add(s.substring(0, i));
    }
    return result;
}
--------------------------------
List<Integer> parseMusic(String musicString) {
    List<Integer> result = new ArrayList<>();
    List<Character> current = new ArrayList<>();
    for (int i = 0; i <= musicString.length(); i++) {
        if (i == musicString.length() || musicString.charAt(i) =='') {
            if (current.toString().equals("o")) {
                result.add(4);
            }
            if (current.toString().equals("o|")) {
                result.add(2);
            }
            if (current.toString().equals(".|")) {
                result.add(1);
            }
            current.clear();
        } else {
            current.add(musicString.charAt(i));
        }
    }
    return result;
}
--------------------------------
int strlen(String s) {
    return s.length();
}
--------------------------------
List<Integer> factorize(int n) {
    List<Integer> factors = new ArrayList<>();
    for (int i = 2; i <= n; i++) {
        if (n % i == 0) {
            n /= i;
            factors.add(i);
            i--;
        }
    }
    return factors;
}
--------------------------------
String concatenate(List<String> strings) {
    StringBuilder result = new StringBuilder();
    for (String s : strings) {
        result.append(s);
    }
    return result.toString();
}
--------------------------------
List<Double> getPositive(List<Double> l) {
    List<Double> result = new ArrayList<>();
    for (int i = 0; i < l.size(); i++) {
        if (l.get(i) > 0) {
            result.add(l.get(i));
        }
    }
    return result;
}
--------------------------------
List<Double> sortEven(List<Double> l) {
    List<Double> evens = new ArrayList<>();
    for (int i = 0; i < l.size(); i += 2) {
        evens.add(l.get(i));
    }
    Collections.sort(evens);
    List<Double> result = new ArrayList<>();
    for (int i = 0; i < l.size(); i++) {
        if (i % 2 == 0) {
            result.add(evens.get(i / 2));
        }
        if (i % 2 == 1) {
            result.add(l.get(i));
        }
    }
    return result;
}
--------------------------------
String decodeCyclic(String s) {
    String output = "";
    int i = 0;
    while (i <= s.length() - 3) {
        String x = s.substring(i + 2, i + 3) + s.substring(i, i + 2);
        output += x;
        i += 3;
    }
    return output + s.substring(i);
}
--------------------------------
int carRaceCollision(int n) {
    return Math.pow(n, 2);
}
--------------------------------
List<Integer> incrList(List<Integer> l) {
    List<Integer> result = new ArrayList<Integer>();
    for (Integer i : l) {
        result.add(i + 1);
    }
    return result;
}
--------------------------------
boolean pairsSumToZero(List<Integer> l) {
    for (int i = 0; i < l.size(); i++) {
        for (int j = i + 1; j < l.size(); j++) {
            if (l.get(i) + l.get(j) == 0) {
                return true;
            }
        }
    }
    return false;
}
--------------------------------
String changeBase(int x, int b) {
    String ret = "";
    while (x > 0) {
        ret = (x % b) + ret;
        x = x / b;
    }
    return ret;
}
--------------------------------
double median(List<Double> l) {
    l.sort(Comparator.naturalOrder());
    if (l.size() % 2 == 1) {
        return l.get(l.size() / 2);
    } else {
        return (l.get(l.size() / 2 - 1) + l.get(l.size() / 2)) / 2.0;
    }
}
--------------------------------
String decodeShift(String s) {
    String result = "";
    for (char ch : s.toCharArray()) {
        int w = (ch + 21 - 'a') % 26 + 'a';
        result += (char) w;
    }
    return result;
}
--------------------------------
boolean belowThreshold(List<Integer> l, int t) {
    for (int n : l) {
        if (n >= t) {
            return false;
        }
    }
    return true;
}
--------------------------------
boolean correctBracketing(String brackets) {
    int depth = 0;
    for (char b : brackets.toCharArray()) {
        if (b == = '<') {
            depth += 1;
        } else {
            depth -= 1;
        }
        if (depth < 0) {
            return false;
        }
    }
    return depth == = 0;
}
--------------------------------
boolean monotonic(List<Double> l) {
    int incr = 0;
    int decr = 0;
    for (int i = 1; i < l.size(); i++) {
        if (l.get(i) > l.get(i - 1)) {
            incr = 1;
        }
        if (l.get(i) < l.get(i - 1)) {
            decr = 1;
        }
    }
    return incr + decr!= 2;
}
--------------------------------
List<Double> derivative(List<Double> xs) {
    List<Double> result = new ArrayList<>();
    for (int i = 1; i < xs.size(); i++) {
        result.add(i * xs.get(i));
    }
    return result;
}
--------------------------------
int vowelsCount(String s) {
    String vowels = "aeiouAEIOU";
    int count = 0;
    for (char ch : s.toCharArray()) {
        if (vowels.contains(ch)) {
            count += 1;
        }
    }
    if (s.charAt(s.length() - 1) == = 'y' || s.charAt(s.length() - 1) == = 'Y') {
        count += 1;
    }
    return count;
}
--------------------------------
int digitSum(String s) {
    int sum = 0;
    for (char c : s.toCharArray()) {
        if (Character.isUpperCase(c) && Character.isLowerCase(c)) {
            sum += c;
        }
    }
    return sum;
}
--------------------------------
int fruitDistribution(String s, int n) {
    List<Integer> num1 = new ArrayList<>();
    List<Integer> num2 = new ArrayList<>();
    boolean flag = false;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) >= '0' && s.charAt(i) <= '9') {
            if (!flag) {
                num1.add(s.charAt(i) - '0');
            }
            if (flag) {
                num2.add(s.charAt(i) - '0');
            }
        } else if (!flag && num1.size() > 0) {
            flag = true;
        }
    }
    return n - Integer.parseInt(num1.stream().map(String::valueOf).collect(Collectors.joining())) - Integer.parseInt(num2.stream().map(String::valueOf).collect(Collectors.joining()));
}
--------------------------------
List<Integer> pluck(List<Integer> arr) {
    List<Integer> result = new ArrayList<>();
    for (int i = 0; i < arr.size(); i++) {
        if (arr.get(i) % 2 == 0) {
            if (result.isEmpty()) {
                result.add(arr.get(i));
                result.add(i);
            } else if (arr.get(i) < result.get(0)) {
                result.set(0, arr.get(i));
                result.set(1, i);
            }
        }
    }
    return result;
}
--------------------------------
List<Integer> strangeSortList(List<Integer> lst) {
    List<Integer> res = new ArrayList<>();
    lst.sort((a, b) -> a - b);
    int l = 0;
    int r = lst.size() - 1;
    while (l < r) {
        res.add(lst.get(l));
        l += 1;
        res.add(lst.get(r));
        r -= 1;
    }
    if (l == r) {
        res.add(lst.get(l));
    }
    return res;
}
--------------------------------
double triangleArea(double a, double b, double c) {
    if (a + b <= c || a + c <= b || b + c <= a) {
        return -1;
    }
    double s = (a + b + c) / 2;
    double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));
    return area;
}
--------------------------------
boolean willItFly(List<Integer> q, int w) {
    int sum = 0;
    for (int i = 0; i < q.size(); i++) {
        if (q.get(i)!= q.get(q.size() - 1 - i)) {
            return false;
        }
        sum += q.get(i);
    }
    return sum <= w;
}
--------------------------------
boolean isCube(int a) {
    a = Math.abs(a);
    int i = Math.round(Math.pow(a, 1.0 / 3));
    return Math.pow(i, 3) == = a;
}
--------------------------------
int hexKey(String num) {
    String key = "2357BD";
    int total = 0;
    for (char c : num.toCharArray()) {
        if (key.contains(c)) {
            total += 1;
        }
    }
    return total;
}
--------------------------------
String decimalToBinary(int dec) {
    String ans = "";
    if (dec!= 0) {
        while (dec > 0) {
            ans = (dec % 2) + ans;
            dec = dec / 2;
        }
    } else {
        ans = "0";
    }
    return "db" + ans + "db";
}
--------------------------------
boolean primeLength(String s) {
    int len = s.length();
    if (len < 2) {
        return false;
    }
    for (int i = 2; i < len; i++) {
        if (len % i == 0) {
            return false;
        }
    }
    return true;
}
--------------------------------
int startsOneEnds(int n) {
if (n < 1) {
return 0;
}
if (n == = 1) {
return 1;
}
return 18 * Math.pow(10, n - 2);
}
--------------------------------
int add(List<Integer> lst) {
    int sum = 0;
    for (int i = 1; i < lst.size(); i += 2) {
        if (lst.get(i) % 2 == 0) {
            sum += lst.get(i);
        }
    }
    return sum;
}
--------------------------------
List<List<Integer> > getRow(List<List<Integer> > lst, int x) {
    List<List<Integer> > coords = new ArrayList<>();
    for (int i = 0; i < lst.size(); i++) {
        for (int j = lst.get(i).size() - 1; j >= 0; j--) {
            if (lst.get(i).get(j) == x) {
                coords.add(Arrays.asList(i, j));
            }
        }
    }
    return coords;
}
--------------------------------
int nextSmallest(List<Integer> lst) {
    lst.sort(Comparator.naturalOrder());
    for (int i = 1; i < lst.size(); i++) {
        if (lst.get(i)!= = lst.get(i - 1)) {
            return lst.get(i);
        }
    }
    return -1;
}
--------------------------------
boolean anyInt(double a, double b, double c) {
    if (Math.round(a)!= = a || Math.round(b)!= = b || Math.round(c)!= = c) {
        return false;
    }
    return a + b == = c || a + c == = b || b + c == = a;
}
--------------------------------
List<Integer> countUpTo(int n) {
    List<Integer> primes = new ArrayList<>();
    for (int i = 2; i < n; i++) {
        boolean p = true;
        for (int j = 2; j < i; j++) {
            if (i % j == 0) {
                p = false;
                break;
            }
        }
        if (p) {
            primes.add(i);
        }
    }
    return primes;
}
--------------------------------
int closestInteger(String value) {
    double w = Double.parseDouble(value);
    return Math.round(w);
}
--------------------------------
List<Integer> makeAPile(int n) {
    List<Integer> result = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        result.add(n + 2 * i);
    }
    return result;
}
--------------------------------
List<String> wordStrings(String s) {
    List<String> words = new ArrayList<>();
    StringBuilder current = new StringBuilder();
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) =='' || s.charAt(i) == ',') {
            if (current.length() > 0) {
                words.add(current.toString());
                current.setLength(0);
            }
        } else {
            current.append(s.charAt(i));
        }
    }
    if (current.length() > 0) {
        words.add(current.toString());
    }
    return words;
}
--------------------------------
String roundedAvg(int n, int m) {
    if (n > m) {
        return "-1";
    }
    int num = (n + m) / 2;
    String ret = "";
    while (num > 0) {
        ret = (num % 2) + ret;
        num = num / 2;
    }
    return ret;
}
--------------------------------
List<Integer> uniqueDigits(List<Integer> x) {
    List<Integer> digits = new ArrayList<>();
    for (int n : x) {
        boolean isUnique = true;
        for (char c : n.toString().toCharArray()) {
            if (c % 2 == 0) {
                isUnique = false;
                break;
            }
        }
        if (isUnique) {
            digits.add(n);
        }
    }
    digits.sort((a, b) -> a - b);
    return digits;
}
--------------------------------
int countNums(List<Integer> arr) {
    int num = 0;
    for (int n : arr) {
        int neg = n < 0? -1 : 1;
        n = Math.abs(n);
        List<Integer> digits = new ArrayList<>();
        for (char c : n.toString().toCharArray()) {
            digits.add(c - '0');
        }
        digits.set(0, digits.get(0) * neg);
        int sum = 0;
        for (int d : digits) {
            sum += d;
        }
        if (sum > 0) {
            num += 1;
        }
    }
    return num;
}
--------------------------------
boolean moveOneBall(List<Integer> arr) {
    if (arr.size() == 0) {
        return true;
    }
    int num = 0;
    for (int i = 1; i < arr.size(); i++) {
        if (arr.get(i) < arr.get(i - 1)) {
            num += 1;
        }
    }
    if (arr.get(arr.size() - 1) > arr.get(0)) {
        num += 1;
    }
    if (num < 2) {
        return true;
    }
    return false;
}
--------------------------------
String exchange(List<Integer> lst1, List<Integer> lst2) {
    int odd = 0;
    int even = 0;
    for (int n : lst1) {
        if (n % 2 == 1) {
            odd++;
        }
    }
    for (int n : lst2) {
        if (n % 2 == 0) {
            even++;
        }
    }
    if (even >= odd) {
        return "YES";
    }
    return "NO";
}
--------------------------------
List<String> oddCount(List<String> lst) {
    List<String> results = new ArrayList<>();
    String originalStr = "the number of odd elements in the string i of the input.";
    for (String s : lst) {
        int sum = 0;
        for (char d : s.toCharArray()) {
            if (d >= '0' && d <= '9' && d % 2 == 1) {
                sum += 1;
            }
        }
        List<String> result = new ArrayList<>();
        for (char c : originalStr.toCharArray()) {
            if (c == 'i') {
                result.add(sum.toString());
            } else {
                result.add(c);
            }
        }
        results.add(result.stream().collect(Collectors.joining()));
    }
    return results;
}
--------------------------------
int minSubArraySum(List<Integer> nums) {
    int minSum = Integer.MAX_VALUE;
    int sum = 0;
    for (int num : nums) {
        sum += num;
        if (minSum > sum) {
            minSum = sum;
        }
        if (sum > 0) {
            sum = 0;
        }
    }
    return minSum;
}
--------------------------------
int maxFill(List<List<Integer> > grid, int capacity) {
    int res = 0;
    for (List<Integer> well : grid) {
        int sum = 0;
        for (int n : well) {
            sum += n;
        }
        if (sum > 0) {
            res += (sum - 1) / capacity + 1;
        }
    }
    return res;
}
--------------------------------
List<String> selectWords(String s, int n) {
    List<String> result = new ArrayList<>();
    String vowels = "aeiouAEIOU";
    StringBuilder current = new StringBuilder();
    int consonantNum = 0;
    for (int i = 0; i <= s.length(); i++) {
        if (i == s.length() || s.charAt(i) =='') {
            if (consonantNum == n) {
                result.add(current.toString());
            }
            current.setLength(0);
            consonantNum = 0;
        } else {
            current.append(s.charAt(i));
            if (!vowels.contains(s.charAt(i))) {
                consonantNum += 1;
            }
        }
    }
    return result;
}
--------------------------------
int solution(List<Integer> lst) {
    int sum = 0;
    for (int i = 0; i < lst.size(); i += 2) {
        if (lst.get(i) % 2 == 1) {
            sum += lst.get(i);
        }
    }
    return sum;
}
--------------------------------
int addElements(List<Integer> arr, int k) {
    int sum = 0;
    for (int i = 0; i < k; i++) {
        if (arr.get(i) >= -99 && arr.get(i) <= 99) {
            sum += arr.get(i);
        }
    }
    return sum;
}
--------------------------------
List<Integer> getOddCollatz(int n) {
    List<Integer> oddCollatz = new ArrayList<>();
    while (n!= = 1) {
        if (n % 2 == = 1) {
            oddCollatz.add(n);
            n = n * 3 + 1;
        } else {
            n /= 2;
        }
    }
    oddCollatz.add(1);
    oddCollatz.sort((a, b) = > a - b);
    return oddCollatz;
}
--------------------------------
boolean isSorted(List<Integer> lst) {
    for (int i = 1; i < lst.size(); i++) {
        if (lst.get(i) < lst.get(i - 1)) {
            return false;
        }
        if (i >= 2 && lst.get(i) == = lst.get(i - 1) && lst.get(i) == = lst.get(i - 2)) {
            return false;
        }
    }
    return true;
}
--------------------------------
String intersection(List<Integer> interval1, List<Integer> interval2) {
    int inter1 = Math.max(interval1.get(0), interval2.get(0));
    int inter2 = Math.min(interval1.get(1), interval2.get(1));
    int l = inter2 - inter1;
    if (l < 2) {
        return "NO";
    }
    for (int i = 2; i < l; i++) {
        if (l % i == 0) {
            return "NO";
        }
    }
    return "YES";
}
--------------------------------
int prodSigns(List<Integer> arr) {
    if (arr.size() == 0) {
        return -32768;
    }
    int sum = 0;
    int prods = 1;
    for (int i : arr) {
        sum += Math.abs(i);
        if (i == 0) {
            prods = 0;
        }
        if (i < 0) {
            prods = -prods;
        }
    }
    return sum * prods;
}
--------------------------------
List<Integer> minPath(List<List<Integer> > grid, int k) {
    int n = grid.size();
    int minNum = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (grid.get(i).get(j) == 1) {
                List<Integer> tmp = new ArrayList<>();
                if (i!= 0) {
                    tmp.add(grid.get(i - 1).get(j));
                }
                if (j!= 0) {
                    tmp.add(grid.get(i).get(j - 1));
                }
                if (i!= n - 1) {
                    tmp.add(grid.get(i + 1).get(j));
                }
                if (j!= n - 1) {
                    tmp.add(grid.get(i).get(j + 1));
                }
                minNum = Math.min(minNum, tmp.stream().min(Integer::compareTo).get());
            }
        }
    }
    List<Integer> ans = new ArrayList<>();
    for (int i = 0; i < k; i++) {
        if (i % 2 == 0) {
            ans.add(1);
        } else {
            ans.add(minNum);
        }
    }
    return ans;
}
--------------------------------
int digits(int n) {
    int prod = 0;
    for (char digit : n.toString().toCharArray()) {
        if (digit % 2 == 1) {
            if (prod == 0) {
                prod = 1;
            }
            prod *= digit - '0';
        }
    }
    return prod;
}
--------------------------------
boolean isNested(String s) {
    int count = 0;
    int maxCount = 0;
    for (char ch : s.toCharArray()) {
        if (ch == = "[") {
            count += 1;
        }
        if (ch == = "]") {
            count -= 1;
        }
        if (count < 0) {
            count = 0;
        }
        if (count > maxCount) {
            maxCount = count;
        }
        if (count <= maxCount - 2) {
            return true;
        }
    }
    return false;
}
--------------------------------
int sumSquares(List<Double> lst) {
    int sum = 0;
    for (double i : lst) {
        sum += Math.ceil(i) * Math.ceil(i);
    }
    return sum;
}
--------------------------------
int canArrange(List<Integer> arr) {
    int index = -1;
    for (int i = 0; i < arr.size(); i++) {
        if (arr.get(i) <= i) {
            index = i;
        }
    }
    return index;
}
--------------------------------
List<Integer> largestSmallestIntegers(List<Integer> lst) {
    int maxNeg = 0, minPos = 0;
    for (int n : lst) {
        if (n < 0 && (maxNeg == = 0 || n > maxNeg)) {
            maxNeg = n;
        }
        if (n > 0 && (minPos == = 0 || n < minPos)) {
            minPos = n;
        }
    }
    return Arrays.asList(maxNeg, minPos);
}
--------------------------------
String fixSpaces(String text) {
    List<String> res = new ArrayList<>();
    int spaceLen = 0;
    for (int i = 0; i <= text.length(); i++) {
        if (i == text.length() || text.charAt(i)!='') {
            if (spaceLen == 1) {
                res.add("_");
            }
            if (spaceLen == 2) {
                res.add("__");
            }
            if (spaceLen > 2) {
                res.add("-");
            }
            spaceLen = 0;
            if (i!= text.length()) {
                res.add(text.charAt(i));
            }
        } else {
            spaceLen += 1;
        }
    }
    return String.join("", res);
}
--------------------------------
String filenameCheck(String fileName) {
    int digitNum = 0, dotNum = 0;
    if (fileName.length() < 5 || fileName.charAt(0) == = fileName.charAt(0).toLowerCase()) {
        return "No";
    }
    String suffix = fileName.substring(fileName.length() - 4);
    if (suffix!= = ".txt" && suffix!= = ".exe" && suffix!= = ".dll") {
        return "No";
    }
    for (char c : fileName.toCharArray()) {
        if ("0" <= c && c <= "9") {
            digitNum += 1;
        }
        if (c == = ".") {
            dotNum += 1;
        }
    }
    if (digitNum > 3 || dotNum!= = 1) {
        return "No";
    }
    return "Yes";
}
--------------------------------
int sumSquares(List<Integer> lst) {
    int sum = 0;
    for (int i = 0; i < lst.size(); i++) {
        if (i % 3 == 0) {
            sum += lst.get(i) * lst.get(i);
        } else if (i % 4 == 0) {
            sum += lst.get(i) * lst.get(i) * lst.get(i);
        } else {
            sum += lst.get(i);
        }
    }
    return sum;
}
--------------------------------
String wordsInSentence(String sentence) {
    List<String> result = new ArrayList<>();
    List<String> current = new ArrayList<>();
    for (int i = 0; i <= sentence.length(); i++) {
        if (i == sentence.length() || sentence.charAt(i) =='') {
            boolean isPrime = true;
            int l = current.size();
            if (l < 2) {
                isPrime = false;
            }
            for (int j = 2; j < l; j++) {
                if (l % j == 0) {
                    isPrime = false;
                    break;
                }
            }
            if (isPrime) {
                result.add(current.stream().collect(Collectors.joining("")) + " ");
            }
            current.clear();
        } else {
            current.add(String.valueOf(sentence.charAt(i)));
        }
    }
    result = result.stream().collect(Collectors.joining(""));
    if (result.length() > 0) {
        result = result.substring(0, result.length() - 1);
    }
    return result;
}
--------------------------------
boolean simplify(String x, String n) {
    int a = 0, b = 0, c = 0, d = 0;
    for (int i = 0; i < x.length(); i++) {
        if (x.charAt(i) == = "/") {
            a = Integer.parseInt(x.substring(0, i));
            b = Integer.parseInt(x.substring(i + 1));
        }
    }
    for (int i = 0; i < n.length(); i++) {
        if (n.charAt(i) == = "/") {
            c = Integer.parseInt(n.substring(0, i));
            d = Integer.parseInt(n.substring(i + 1));
        }
    }
    return (a * c) % (b * d) == = 0;
}
--------------------------------
int specialFilter(List<Integer> nums) {
    int count = 0;
    for (int num : nums) {
        if (num > 10) {
            String w = num.toString();
            if (w.charAt(0) % 2 == 1 && w.charAt(w.length() - 1) % 2 == 1) {
                count += 1;
            }
        }
    }
    return count;
}
--------------------------------
int getMaxTriples(int n) {
    int[] arr = new int[n];
    for (int i = 1; i <= n; i++) {
        arr[i - 1] = i * i - i + 1;
    }
    int count = 0;
    for (int i = 0; i < n - 2; i++) {
        for (int j = i + 1; j < n; j++) {
            for (int k = j + 1; k < n; k++) {
                if ((arr[i] + arr[j] + arr[k]) % 3 == 0) {
                    count += 1;
                }
            }
        }
    }
    return count;
}
--------------------------------
int doubleTheDifference(List<Double> lst) {
    int sum = 0;
    for (double d : lst) {
        int num = (int) Math.round(d);
        if (d == = num) {
            if (num > 0 && num % 2 == = 1) {
                sum += num * num;
            }
        }
    }
    return sum;
}
--------------------------------
List<Integer> compare(List<Integer> game, List<Integer> guess) {
    List<Integer> result = new ArrayList<>();
    for (int i = 0; i < game.size(); i++) {
        result.add(Math.abs(game.get(i) - guess.get(i)));
    }
    return result;
}
--------------------------------
String strongestExtension(String className, List<String> extensions) {
    String strongest = "";
    int max = -Integer.MAX_VALUE;
    for (String extension : extensions) {
        int strength = 0;
        for (char chr : extension.toCharArray()) {
            if (Character.isUpperCase(chr) && Character.isLowerCase(chr)) {
                strength += 1;
            }
            if (Character.isLowerCase(chr) && Character.isUpperCase(chr)) {
                strength -= 1;
            }
        }
        if (strength > max) {
            max = strength;
            strongest = extension;
        }
    }
    return className + "." + strongest;
}
--------------------------------
String intToMiniRoman(int number) {
    String[] num = { "m", "cm", "d", "cd", "c", "xc", "l", "xl", "x", "ix", "v", "iv", "i" };
    int[] sym = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };
    int pos = 0;
    String res = "";
    while (number > 0) {
        while (number >= sym[pos]) {
            res += num[pos];
            number -= sym[pos];
        }
        if (number > 0) {
            pos += 1;
        }
    }
    return res;
}
--------------------------------
List<Integer> eat(int number, int need, int remaining) {
    return need > remaining? Arrays.asList(number + remaining, 0) : Arrays.asList(number + need, remaining - need);
}
--------------------------------
int doAlgebra(List<String> ops, List<Integer> operands) {
    List<Integer> nums = new ArrayList<>(operands);
    List<String> currentOps = new ArrayList<>(ops);
    int i = currentOps.size() - 1;
    while (i >= 0) {
        if (currentOps.get(i).equals("**")) {
            nums.set(i, (int) Math.pow(nums.get(i), nums.get(i + 1)));
            nums.remove(i + 1);
            currentOps.remove(i);
        }
        i--;
    }
    i = 0;
    while (i < currentOps.size()) {
        if (currentOps.get(i).equals("*")) {
            nums.set(i, nums.get(i) * nums.get(i + 1));
            nums.remove(i + 1);
            currentOps.remove(i);
        } else if (currentOps.get(i).equals("//")) {
            nums.set(i, (int) Math.floor(nums.get(i) / nums.get(i + 1)));
            nums.remove(i + 1);
            currentOps.remove(i);
        } else {
            i++;
        }
    }
    i = 0;
    while (i < currentOps.size()) {
        if (currentOps.get(i).equals("+")) {
            nums.set(i, nums.get(i) + nums.get(i + 1));
            nums.remove(i + 1);
            currentOps.remove(i);
        } else if (currentOps.get(i).equals("-")) {
            nums.set(i, nums.get(i) - nums.get(i + 1));
            nums.remove(i + 1);
            currentOps.remove(i);
        } else {
            i++;
        }
    }
    return nums.get(0);
}
--------------------------------
List<Integer> generateIntegers(int a, int b) {
    int lower = Math.max(2, Math.min(a, b));
    int upper = Math.min(8, Math.max(a, b));
    List<Integer> result = new ArrayList<>();
    for (int i = lower; i <= upper; i += 2) {
        result.add(i);
    }
    return result;
}
--------------------------------
boolean isStepNum(int n) {
    int prevDigit = -1;
    while (n > 0) {
        int curDigit = n % 10;
        if (prevDigit == -1) {
            prevDigit = curDigit;
        } else {
            if (Math.abs(prevDigit - curDigit)!= 1) {
                return false;
            }
        }
        prevDigit = curDigit;
        n = Math.trunc(n / 10);
    }
    return true;
}
--------------------------------
int numOfWays(int n, int k) {
    int p = 1;
    if (k % 2!= 0) {
        p = -1;
    }
    return (int) ((Math.pow(n - 1, k) + p * (n - 1)) / n);
}
--------------------------------
List<Integer> findDivisors(int n) {
    List<Integer> v = new ArrayList<>();
    for (int i = 1; i <= Math.sqrt(n); i++) {
        if (n % i == 0) {
            if (n / i == i) {
                v.add(i);
            } else {
                v.add(i);
                v.add(Math.floor(n / i));
            }
        }
    }
    return v;
}
--------------------------------
int eggDrop(int n, int k) {
    if (k == 1 || k == 0) {
        return k;
    }
    if (n == 1) {
        return k;
    }
    int min = Integer.MAX_VALUE;
    int x, res;
    for (x = 1; x <= k; x++) {
        res = Math.max(eggDrop(n - 1, x - 1), eggDrop(n, k - x));
        if (res < min) {
            min = res;
        }
    }
    return min + 1;
}
--------------------------------
boolean isPowerOfTwo(int n) {
    if (n == 0) {
        return false;
    }
    return Math.ceil(Math.log(n) / Math.log(2)) == Math.floor(Math.log(n) / Math.log(2));
}
--------------------------------
String shortestPalindrome(String s) {
    int n = s.length();
    String[] v = new String[n * 2];
    for (int i = 0; i < n; i++) {
        int l = i;
        int r = i;
        String ans1 = "";
        String ans2 = "";
        while (l >= 0 && r < n && s.charAt(l) == = s.charAt(r)) {
            ans1 += s.charAt(l);
            l--;
            r++;
        }
        l = i - 1;
        r = i;
        while (l >= 0 && r < n && s.charAt(l) == = s.charAt(r)) {
            ans2 += s.charAt(l);
            l--;
            r++;
        }
        v[i * 2] = ans1;
        v[i * 2 + 1] = ans2;
    }
    String ans = v[0];
    for (int i = 0; i < v.length; i++) {
        if (v[i]!= = "") {
            if (ans.charAt(0) >= v[i].charAt(0)) {
                ans = v[i];
            }
        }
    }
    return ans;
}
--------------------------------
int minimumAdjacentDifference(List<Integer> a, int n, int k) {
    int minDiff = Integer.MAX_VALUE;
    for (int i = 0; i <= k; i++) {
        int maxDiff = Integer.MIN_VALUE;
        for (int j = 0; j < n - k - 1; j++) {
            for (int p = i; p <= i + j; p++) {
                maxDiff = Math.max(maxDiff, a.get(p + 1) - a.get(p));
            }
        }
        minDiff = Math.min(minDiff, maxDiff);
    }
    return minDiff;
}
--------------------------------
int cal(List<Integer> arr, int mid) {
    int chocolate = 0;
    for (int i : arr) {
        if (i >= mid) {
            chocolate += i - mid;
        }
    }
    return chocolate;
}
--------------------------------
boolean check(int v, List<Integer> a, int m) {
    int tec = 0, ans = 0;
    int[] b = new int[a.size() + 3];
    for (int i = 0; i < a.size(); i++) {
        tec -= b[i];
        if (a.get(i) + tec < v) {
            int mov = v - a.get(i) - tec;
            ans += mov;
            tec += mov;
            b[i + 2] = mov;
        }
    }
    return ans <= m;
}
--------------------------------
int largestNum(List<Integer> arr) {
    int res = 0;
    arr.sort((a, b) -> a - b);
    int l = 0, r = arr.size() - 1;
    while (l < r) {
        int sum = arr.get(l) + arr.get(r);
        if (sum == 0) {
            res = Math.max(res, Math.max(arr.get(l), arr.get(r)));
            return res;
        } else if (sum < 0) {
            l++;
        } else {
            r--;
        }
    }
    return res;
}
--------------------------------
int binarySearch(List<Integer> p, int n) {
    int i = 0;
    int j = p.size() - 1;
    int index = -1;
    while (i <= j) {
        int mid = i + (j - i) / 2;
        if (p.get(mid) >= n) {
            index = mid;
            j = mid - 1;
        } else {
            i = mid + 1;
        }
    }
    return index;
}
--------------------------------
int findMinLength(List<Integer> arr) {
    int index = arr.size() - 1;
    while (index > 0 && arr.get(index) >= arr.get(index - 1)) {
        index--;
    }
    return index;
}
--------------------------------
int minDigits(int n, int k) {
    int digits_num = (int) Math.floor(Math.log(n) / Math.log(10) + 1);
    int temp_sum = 0;
    int temp = digits_num;
    int result;
    int x, v;
    int sum = 0;
    int num2 = n;
    while (num2!= 0) {
        sum += num2 % 10;
        num2 = (int) Math.trunc(num2 / 10);
    }
    if (sum <= k) {
        x = 0;
    } else {
        while (temp > 0) {
            v = (int) Math.trunc(n / Math.pow(10, temp - 1));
            temp_sum += v % 10;
            if (temp_sum >= k) {
                v = (int) Math.trunc(v / 10);
                v++;
                result = v * (int) Math.pow(10, temp);
                break;
            }
            temp--;
        }
        x = result - n;
        return x;
    }
    return -1;
}
--------------------------------
int checkForPerfectSquare(List<Integer> arr, int i, int j) {
    int mid, sum = 0;
    for (int m = i; m <= j; m++) {
        sum += arr.get(m);
    }
    int low = 0, high = (int) Math.floor(sum / 2);
    while (low <= high) {
        mid = low + (int) Math.floor((high - low) / 2);
        if (mid * mid == sum) {
            return mid;
        } else if (mid * mid > sum) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return -1;
}
--------------------------------
int minFlips(List<List<Integer> > mat, String s) {
    int n = mat.size();
    int m = mat.get(0).size();
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (mat.get(i).get(j)!= s.charAt(i + j) - '0') {
                count++;
            }
        }
    }
    return count;
}
--------------------------------
List<List<Integer> > constructTree(int n, List<List<Integer> > edges) {
    List<List<Integer> > adjl = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        adjl.add(new ArrayList<>());
    }
    for (List<Integer> e : edges) {
        int u = e.get(0);
        int v = e.get(1);
        adjl.get(u).add(v);
        adjl.get(v).add(u);
    }
    return adjl;
}
--------------------------------
int findSumOfValues(int v, List<Integer> parent, List<Integer> valuesChildren) {
    int curNode = v;
    int sum = 0;
    while (curNode!= -1) {
        sum += valuesChildren.get(curNode);
        curNode = parent.get(curNode);
    }
    return sum;
}
--------------------------------
int getDistinct(int d, int count) {
    int num = 0;
    count = (int) Math.pow(10, count - 1);
    while (count > 0) {
        num += count * d;
        count = (int) Math.trunc(count / 10);
    }
    return num;
}
--------------------------------
boolean isIncreasing(List<Integer> arr) {
    for (int i = 0; i < arr.size() - 1; i++) {
        if (arr.get(i) > arr.get(i + 1)) {
            return false;
        }
    }
    return true;
}
--------------------------------
int minAdjSwaps(List<List<Integer> > mat) {
    int n = mat.size();
    List<Integer> cntZero = new ArrayList<>(n);
    for (int i = 0; i < n; i++) {
        for (int j = n - 1; j >= 0 && mat.get(i).get(j) == 0; j--) {
            cntZero.add(i, cntZero.get(i) + 1);
        }
    }
    int cntSwaps = 0;
    for (int i = 0; i < n; i++) {
        if (cntZero.get(i) < (n - i - 1)) {
            int first = i;
            while (first < n && cntZero.get(first) < (n - i - 1)) {
                first++;
            }
            if (first == n) {
                return -1;
            }
            while (first > i) {
                [ cntZero.get(first), cntZero.get(first - 1) ] = [ cntZero.get(first - 1), cntZero.get(first) ];
                first--;
                cntSwaps++;
            }
        }
    }
    return cntSwaps;
}
--------------------------------
int solve(List<Integer> values, List<Integer> salary, int mod) {
    int ret = 1;
    int amt = 0;
    values.sort((a, b) -> a - b);
    salary.sort((a, b) -> a - b);
    while (!salary.isEmpty()) {
        while (!values.isEmpty() && values.get(values.size() - 1) >= salary.get(salary.size() - 1)) {
            amt++;
            values.remove(values.size() - 1);
        }
        if (amt == 0) {
            return 0;
        }
        ret *= amt--;
        ret %= mod;
        salary.remove(salary.size() - 1);
    }
    return ret;
}
--------------------------------
List<Integer> organizeInOrder(List<Integer> vec, List<Character> op, int n) {
    List<Integer> result = new ArrayList<>(n);
    vec.sort(Comparator.naturalOrder());
    int i = 0, j = n - 1, k = 0;
    while (i <= j && k <= n - 2) {
        if (op.get(k) == '<') {
            result.add(vec.get(i++));
        } else {
            result.add(vec.get(j--));
        }
        k++;
    }
    result.add(vec.get(i));
    return result;
}
--------------------------------
int countPoints(int n, int m, List<Integer> a, List<Integer> b, int x, int y) {
    a.sort(Comparator.naturalOrder());
    b.sort(Comparator.naturalOrder());
    int j = 0;
    int count = 0;
    for (int i = 0; i < n; i++) {
        while (j < m) {
            if (a.get(i) + y < b.get(j)) {
                break;
            }
            if (b.get(j) >= a.get(i) - x && b.get(j) <= a.get(i) + y) {
                count++;
                j++;
                break;
            } else {
                j++;
            }
        }
    }
    return count;
}
--------------------------------
boolean areSame(List<Integer> a, List<Integer> b) {
    a.sort((a, b) -> a - b);
    b.sort((a, b) -> a - b);
    return a.toString().equals(b.toString());
}
--------------------------------
int countNumberOfStrings(String s) {
    int n = s.length() - 1;
    int count = (int) Math.pow(2, n);
    return count;
}
--------------------------------
List<Integer> primePower(int x) {
    List<Integer> primePow = new ArrayList<>();
    for (int i = 2; i * i <= x; i++) {
        if (x % i == 0) {
            int p = 1;
            while (x % i == 0) {
                x /= i;
                p *= i;
            }
            primePow.add(p);
        }
    }
    if (x > 1) {
        primePow.add(x);
    }
    return primePow;
}
--------------------------------
boolean isPerfect(int n0) {
    int n = (int) Math.sqrt(n0);
    if (Math.floor(n)!= Math.ceil(n)) {
        return false;
    }
    return true;
}
--------------------------------
int findSum(int l, int r) {
    int[] arr = new int[r - l + 1];
    int i = 0;
    int x = 2;
    while (i <= r) {
        arr[i - l] = i + x;
        if (i + 1 <= r) {
            arr[i - l] += i + 1 + x;
        }
        x *= -1;
        i += 2;
    }
    int sum = 0;
    for (i = l; i <= r; ++i) {
        sum += arr[i - l];
    }
    return sum;
}
--------------------------------
int results(int n, int k) {
    return Math.round(Math.pow(n, 1.0 / Math.pow(2.0, k)));
}
--------------------------------
List<Integer> factors(int n) {
    List<Integer> v = new ArrayList<>();
    v.add(1);
    for (int i = 2; i <= Math.sqrt(n); i++) {
        if (n % i == 0) {
            v.add(i);
            if (n / i!= i) {
                v.add(n / i);
            }
        }
    }
    return v;
}
--------------------------------
int smallestNum(int n) {
    double x = Math.pow(10.0, (n - 1) / 2.0);
    return Math.ceil(x);
}
--------------------------------
int smallest(String s) {
    int[] a = new int[s.length()];
    for (int i = 0; i < s.length(); i++) {
        a[i] = s.charAt(i) - '0';
    }
    List<Integer> b = new ArrayList<>();
    for (int i = 0; i < a.length; i++) {
        if (a[i] % 2!= 0) {
            b.add(a[i]);
        }
    }
    Collections.sort(b);
    if (b.size() > 1) {
        return b.get(0) * 10 + b.get(1);
    }
    return -1;
}
--------------------------------
List<Double> Diagonals(double a, double b, double c, double d) {
    List<Double> ans = new ArrayList<>();
    ans.add(Math.sqrt((a * c + b * d) * (a * d + b * c) / (a * b + c * d)));
    ans.add(Math.sqrt((a * c + b * d) * (a * b + c * d) / (a * d + b * c)));
    return ans;
}
--------------------------------
int findNumberOfDigits(int n, int bas) {
    int dig = (int) Math.floor(Math.log(n) / Math.log(bas)) + 1;
    return dig;
}
--------------------------------
double nGon(int n) {
    double proAngleVar;
    if (n % 4 == 0) {
        proAngleVar = Math.PI * (180.0 / n) / 180;
    } else {
        proAngleVar = Math.PI * (180.0 / (2 * n)) / 180;
    }
    double negX = 1.0e+99, posX = -1.0e+99, negY = 1.0e+99, posY = -1.0e+99;
    for (int j = 0; j < n; ++j) {
        double px = Math.cos(2 * Math.PI * j / n + proAngleVar);
        double py = Math.sin(2 * Math.PI * j / n + proAngleVar);
        negX = Math.min(negX, px);
        posX = Math.max(posX, px);
        negY = Math.min(negY, py);
        posY = Math.max(posY, py);
    }
    double opt2 = Math.max(posX - negX, posY - negY);
    return opt2 / Math.sin(Math.PI / n) / 2;
}
--------------------------------
int findMaxK(int n) {
    int p = (int) Math.floor(Math.log(n) / Math.log(2));
    return (int) Math.pow(2, p);
}
--------------------------------
int nthFibo(int n) {
    double a = (Math.pow(5, 0.5) + 1) / 2;
    double b = (-1 * Math.pow(5, 0.5) + 1) / 2;
    double r = Math.pow(5, 0.5);
    double ans = (Math.pow(a, n) - Math.pow(b, n)) / r;
    return Math.floor(ans);
}
--------------------------------
double findProb(int l, int r) {
    int countOfPs = (int) Math.floor(Math.sqrt(r)) - (int) Math.ceil(Math.sqrt(l)) + 1;
    int total = r - l + 1;
    double prob = (double) countOfPs / (double) total;
    return prob;
}
--------------------------------
int previousFibonacci(int n) {
    double a = n / ((1 + Math.sqrt(5)) / 2.0);
    return Math.round(a);
}
--------------------------------
List<Integer> distPrime(List<Integer> arr, List<Integer> allPrimes) {
    List<Integer> list1 = new ArrayList<>();
    for (int i : allPrimes) {
        for (int j : arr) {
            if (j % i == 0) {
                list1.add(i);
                break;
            }
        }
    }
    return list1;
}
--------------------------------
List<Integer> getArray(int n) {
    List<Integer> ans = new ArrayList<>();
    int p2 = 1;
    while (n > 0) {
        if (n % 2 == 1) {
            ans.add(p2);
        }
        n >>= 1;
        p2 *= 2;
    }
    return ans;
}
--------------------------------
int maximumLength(List<Integer> a) {
    int[] counts = new int[11];
    int ans = 0;
    for (int index = 0; index < a.length; index++) {
        counts[a.get(index)] += 1;
        List<Integer> k = new ArrayList<>();
        for (int i : counts) {
            if (i!= 0) {
                k.add(i);
            }
        }
        Collections.sort(k);
        if (k.size() == 1 || (k.get(0) == k.get(k.size() - 2) && k.get(k.size() - 1) - k.get(k.size() - 2) == 1) || (k.get(0) == 1 && k.get(1) == k.get(k.size() - 1))) {
            ans = index;
        }
    }
    return ans + 1;
}
--------------------------------
int maxEdges(double n) {
    int edges = (int) Math.floor(n * n / 4);
    return edges;
}
--------------------------------
int findK(int n, int k) {
    int[] a = new int[n];
    for (int i = 1; i < n; i++) {
        if (i % 2 == 1) {
            a[i] = i;
        }
    }
    for (int i = 1; i < n; i++) {
        if (i % 2 == 0) {
            a[i] = i;
        }
    }
    return a[k - 1];
}
--------------------------------
boolean isKeith(int x, int temp) {
    List<Integer> terms = new ArrayList<>();
    int n = 0;
    while (temp > 0) {
        terms.add(temp % 10);
        temp = (int) Math.floor(temp / 10);
        n++;
    }
    terms = terms.stream().collect(Collectors.toList());
    int nextTerm = 0, i = n;
    while (nextTerm < x) {
        nextTerm = 0;
        for (int j = 1; j <= n; j++) {
            nextTerm += terms.get(i - j);
        }
        terms.add(nextTerm);
        i++;
    }
    return nextTerm == x;
}
--------------------------------
boolean factors(int n, int k) {
    List<Integer> v = new ArrayList<>();
    while (n % 2 == 0) {
        v.add(2);
        n = n / 2;
    }
    if (v.size() >= k) {
        return true;
    }
    for (int i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            n = n / i;
            v.add(i);
        }
        if (v.size() >= k) {
            return true;
        }
    }
    if (n > 2) {
        v.add(n);
    }
    if (v.size() >= k) {
        return true;
    }
    return false;
}
--------------------------------
List<String> separateParenGroups(String parenString) {
    List<String> allParens = new ArrayList<>();
    List<String> currentParen = new ArrayList<>();
    int currentDepth = 0;
    for (char c : parenString.toCharArray()) {
        if (c == = '(') {
            currentDepth += 1;
            currentParen.add(c);
        } else if (c == = ')') {
            currentDepth -= 1;
            currentParen.add(c);
            if (currentDepth == = 0) {
                allParens.add(currentParen.toString());
                currentParen.clear();
            }
        }
    }
    return allParens;
}
--------------------------------
List<Integer> parseNestedParens(String parenString) {
    List<Integer> allLevels = new ArrayList<>();
    int level = 0;
    int maxLevel = 0;
    for (int i = 0; i < parenString.length(); i++) {
        char chr = parenString.charAt(i);
        if (chr == = '(') {
            level += 1;
            if (level > maxLevel) {
                maxLevel = level;
            }
        }
        if (chr == = ')') {
            level -= 1;
            if (level == = 0) {
                allLevels.add(maxLevel);
                maxLevel = 0;
            }
        }
    }
    return allLevels;
}
--------------------------------
List<String> filterBySubstring(List<String> strings, String substring) {
    List<String> result = new ArrayList<>();
    for (String s : strings) {
        if (s.contains(substring)) {
            result.add(s);
        }
    }
    return result;
}
--------------------------------
List<Integer> rollingMax(List<Integer> numbers) {
    int runningMax = 0;
    List<Integer> result = new ArrayList<>();
    for (int n : numbers) {
        if (n > runningMax) {
            runningMax = n;
        }
        result.add(runningMax);
    }
    return result;
}
--------------------------------
String makePalindrome(String s) {
    if (s.length() == 0) {
        return "";
    }
    for (int i = 0; i < s.length(); i++) {
        String rStr = s.substring(i);
        if (rStr.equals(new StringBuilder(rStr).reverse().toString())) {
            String nStr = s.substring(0, i);
            String n2Str = new StringBuilder(nStr).reverse().toString();
            return s + n2Str;
        }
    }
    return s.substring(0, s.length() - 1) + new StringBuilder(s).reverse().toString();
}
--------------------------------
String stringXor(String a, String b) {
    String result = "";
    for (int i = 0; i < a.length(); i++) {
        if (a.charAt(i) == b.charAt(i)) {
            result += "0";
        } else {
            result += "1";
        }
    }
    return result;
}
--------------------------------
String longest(List<String> strings) {
    if (strings.isEmpty()) {
        return "";
    }
    int maxLen = Collections.max(strings, (s) -> s.length());
    for (String s : strings) {
        if (s.length() == maxLen) {
            return s;
        }
    }
    return "";
}
--------------------------------
String StringSequence(int n) {
    String[] s = new String[2 * n + 1];
    for (int i = 0; i < n; i++) {
        s[2 * i] = Integer.toString(i);
        s[2 * i + 1] = " ";
    }
    s[2 * n] = Integer.toString(n);
    return String.join("", s);
}
--------------------------------
int countDistinctCharacters(String s) {
    Set<Character> distinct = new HashSet<>();
    for (char c : s.toLowerCase().toCharArray()) {
        distinct.add(c);
    }
    return distinct.size();
}
--------------------------------
int howManyTimes(String s, String sub) {
    int times = 0;
    for (int i = 0; i <= s.length() - sub.length(); i++) {
        if (s.substring(i, i + sub.length()).equals(sub)) {
            times += 1;
        }
    }
    return times;
}
--------------------------------
String sortNumbers(String numbers) {
    Map<String, Integer> toNum = new HashMap<>();
    toNum.put("zero", 0);
    toNum.put("one", 1);
    toNum.put("two", 2);
    toNum.put("three", 3);
    toNum.put("four", 4);
    toNum.put("five", 5);
    toNum.put("six", 6);
    toNum.put("seven", 7);
    toNum.put("eight", 8);
    toNum.put("nine", 9);
    Map<Integer, String> fromNum = new HashMap<>();
    fromNum.put(0, "zero");
    fromNum.put(1, "one");
    fromNum.put(2, "two");
    fromNum.put(3, "three");
    fromNum.put(4, "four");
    fromNum.put(5, "five");
    fromNum.put(6, "six");
    fromNum.put(7, "seven");
    fromNum.put(8, "eight");
    fromNum.put(9, "nine");
    List<Integer> ints = new ArrayList<>();
    List<String> current = new ArrayList<>();
    for (int i = 0; i <= numbers.length(); i++) {
        if (i == numbers.length() || numbers.charAt(i) =='') {
            if (toNum.containsKey(current.stream().collect(Collectors.joining()))) {
                ints.add(toNum.get(current.stream().collect(Collectors.joining())));
                current.clear();
            }
        } else {
            current.add(numbers.charAt(i) + "");
        }
    }
    ints.sort((a, b) -> a - b);
    List<String> result = new ArrayList<>();
    for (int i = 0; i < ints.size(); i++) {
        result.add(fromNum.get(ints.get(i)));
        if (i!= ints.size() - 1) {
            result.add(" ");
        }
    }
    return result.stream().collect(Collectors.join--------------------------------
List<Double> findClosestElements(List<Double> numbers) {
    List<Double> closestPair = new ArrayList<>();
    closestPair.add(numbers.get(0));
    closestPair.add(numbers.get(1));
    double distance = Math.abs(closestPair.get(0) - closestPair.get(1));
    for (int i = 0; i < numbers.size(); i++) {
        for (int j = i + 1; j < numbers.size(); j++) {
            if (Math.abs(numbers.get(i) - numbers.get(j)) < distance) {
                closestPair.set(0, numbers.get(i));
                closestPair.set(1, numbers.get(j));
                distance = Math.abs(numbers.get(i) - numbers.get(j));
            }
        }
    }
    closestPair.sort((a, b) -> a - b);
    return closestPair;
}
--------------------------------
List<Double> rescaleToUnit(List<Double> numbers) {
    double minNum = Double.MIN_VALUE;
    double maxNum = Double.MAX_VALUE;
    for (double n : numbers) {
        if (n < minNum) {
            minNum = n;
        }
        if (n > maxNum) {
            maxNum = n;
        }
    }
    List<Double> result = new ArrayList<>();
    for (double n : numbers) {
        result.add((n - minNum) / (maxNum - minNum));
    }
    return result;
}
--------------------------------
List<Integer> filterIntegers(List<Object> values) {
    List<Integer> result = new ArrayList<>();
    for (Object e : values) {
        if (e instanceof Integer) {
            result.add((Integer) e);
        }
    }
    return result;
}
--------------------------------
List<Integer> removeDuplicates(List<Integer> numbers) {
    Map<Integer, Integer> counter = new HashMap<>();
    for (int i : numbers) {
        counter.put(i, counter.getOrDefault(i, 0) + 1);
    }
    List<Integer> result = new ArrayList<>();
    for (int i : numbers) {
        if (counter.get(i) == 1) {
            result.add(i);
        }
    }
    return result;
}
--------------------------------
String flipCase(String s) {
    String result = "";
    for (char c : s.toCharArray()) {
        if (c == c.toLowerCase() && c!= c.toUpperCase()) {
            result += c.toUpperCase();
        } else {
            result += c.toLowerCase();
        }
    }
    return result;
}
--------------------------------
List<String> filterByPrefix(List<String> strings, String prefix) {
    List<String> result = new ArrayList<>();
    for (int i = 0; i < strings.size(); i++) {
        if (strings.get(i).startsWith(prefix)) {
            result.add(strings.get(i));
        }
    }
    return result;
}
--------------------------------
double findZero(List<Double> xs) {
    double ans = 0;
    double value = 0;
    for (int i = 0; i < xs.size(); i++) {
        value += xs.get(i) * Math.pow(ans, i);
    }
    while (Math.abs(value) > 1e-6) {
        double driv = 0;
        for (int i = 1; i < xs.size(); i++) {
            driv += xs.get(i) * Math.pow(ans, i - 1) * i;
        }
        ans -= value / driv;
        value = 0;
        for (int i = 0; i < xs.size(); i++) {
            value += xs.get(i) * Math.pow(ans, i);
        }
    }
    return ans;
}
--------------------------------
List<Integer> sortThird(List<Integer> l) {
    List<Integer> thirds = new ArrayList<>();
    for (int i = 0; i < l.size(); i += 3) {
        thirds.add(l.get(i));
    }
    Collections.sort(thirds);
    List<Integer> result = new ArrayList<>();
    for (int i = 0; i < l.size(); i++) {
        if (i % 3 == 0) {
            result.add(thirds.get(i / 3));
        } else {
            result.add(l.get(i));
        }
    }
    return result;
}
--------------------------------
List<Integer> unique(List<Integer> l) {
    List<Integer> result = new ArrayList<>(new HashSet<>(l));
    result.sort(Comparator.naturalOrder());
    return result;
}
--------------------------------
double maxElement(List<Double> l) {
    return Collections.max(l);
}
--------------------------------
boolean triplesSumToZero(List<Integer> l) {
    for (int i = 0; i < l.size(); i++) {
        for (int j = i + 1; j < l.size(); j++) {
            for (int k = j + 1; k < l.size(); k++) {
                if (l.get(i) + l.get(j) + l.get(k) == 0) {
                    return true;
                }
            }
        }
    }
    return false;
}
--------------------------------
int fib4(int n) {
    int[] results = { 0, 0, 2, 0 };
    for (int i = 4; i <= n; i++) {
        results.push(results[i - 4] + results[i - 3] + results[i - 2] + results[i - 1]);
    }
    return results[n];
}
--------------------------------
boolean isPalindrome(String text) {
    String pr = new StringBuilder(text).reverse().toString();
    return pr.equals(text);
}
--------------------------------
String removeVowels(String text) {
    String result = "";
    String vowels = "aeiou";
    for (char ch : text.toCharArray()) {
        if (!vowels.contains(ch.toLowerCase())) {
            result += ch;
        }
    }
    return result;
}
--------------------------------
boolean sameChars(String s0, String s1) {
    Set<Character> set0 = new HashSet<>();
    for (char c : s0.toCharArray()) {
        set0.add(c);
    }
    Set<Character> set1 = new HashSet<>();
    for (char c : s1.toCharArray()) {
        set1.add(c);
    }
    return set0.stream().sorted().collect(Collectors.joining()).equals(set1.stream().sorted().collect(Collectors.joining()));
}
--------------------------------
List<Integer> common(List<Integer> l1, List<Integer> l2) {
    Set<Integer> us = new HashSet<>();
    for (int e1 : l1) {
        for (int e2 : l2) {
            if (e1 == e2) {
                us.add(e1);
            }
        }
    }
    List<Integer> ret = new ArrayList<>(us);
    ret.sort((a, b) -> a - b);
    return ret;
}
--------------------------------
boolean correctBracketing(String brackets) {
    int depth = 0;
    for (char b : brackets.toCharArray()) {
        if (b == = '(') {
            depth += 1;
        } else {
            depth -= 1;
        }
        if (depth < 0) {
            return false;
        }
    }
    return depth == = 0;
}
--------------------------------
String circularShift(int x, int shift) {
    String s = Integer.toString(x);
    if (shift > s.length()) {
        return new StringBuilder(s).reverse().toString();
    }
    return s.substring(s.length() - shift) + s.substring(0, s.length() - shift);
}
--------------------------------
int search(List<Integer> lst) {
    Map<Integer, Integer> counter = new HashMap<>();
    for (int i : lst) {
        counter.put(i, counter.getOrDefault(i, 0) + 1);
    }
    int ans = -1;
    for (Map.Entry<Integer, Integer> entry : counter.entrySet()) {
        if (entry.getValue() >= entry.getKey() && entry.getKey() > ans) {
            ans = entry.getKey();
        }
    }
    return ans;
}
--------------------------------
int smallestChange(List<Integer> arr) {
    int ans = 0;
    for (int i = 0; i < Math.floor(arr.size() / 2); i++) {
        if (arr.get(i)!= arr.get(arr.size() - i - 1)) {
            ans += 1;
        }
    }
    return ans;
}
--------------------------------
List<String> totalMatch(List<String> lst1, List<String> lst2) {
    int sum1 = 0;
    for (String st : lst1) {
        sum1 += st.length();
    }
    int sum2 = 0;
    for (String st : lst2) {
        sum2 += st.length();
    }
    return sum1 > sum2? lst2 : lst1;
}
--------------------------------
boolean isHappy(String s) {
    if (s.length() < 3) {
        return false;
    }
    for (int i = 0; i < s.length() - 2; i++) {
        if (s.charAt(i) == = s.charAt(i + 1) || s.charAt(i + 1) == = s.charAt(i + 2) || s.charAt(i) == = s.charAt(i + 2)) {
            return false;
        }
    }
    return true;
}
--------------------------------
List<String> numericalLetterGrade(List<Double> grades) {
    List<String> letterGrade = new ArrayList<>();
    for (int i = 0; i < grades.size(); i++) {
        double gpa = grades.get(i);
        if (gpa == 4.0) {
            letterGrade.add("A+");
        } else if (gpa > 3.7) {
            letterGrade.add("A");
        } else if (gpa > 3.3) {
            letterGrade.add("A-");
        } else if (gpa > 3.0) {
            letterGrade.add("B+");
        } else if (gpa > 2.7) {
            letterGrade.add("B");
        } else if (gpa > 2.3) {
            letterGrade.add("B-");
        } else if (gpa > 2.0) {
            letterGrade.add("C+");
        } else if (gpa > 1.7) {
            letterGrade.add("C");
        } else if (gpa > 1.3) {
            letterGrade.add("C-");
        } else if (gpa > 1.0) {
            letterGrade.add("D+");
        } else if (gpa > 0.7) {
            letterGrade.add("D");
        } else if (gpa > 0.0) {
            letterGrade.add("D-");
        } else {
            letterGrade.add("E");
        }
    }
    return letterGrade;
}
--------------------------------
String solve(int n) {
    String biStr = "";
    int sum = 0;
    for (char c : n.toString().toCharArray()) {
        sum += c - '0';
    }
    while (sum > 0) {
        biStr = (sum % 2) + biStr;
        sum = (int) Math.floor(sum / 2);
    }
    return biStr;
}
--------------------------------
String antiShuffle(String s) {
    List<String> ret = new ArrayList<>();
    List<String> current = new ArrayList<>();
    for (int i = 0; i <= s.length(); i++) {
        if (i == s.length() || s.charAt(i) =='') {
            Collections.sort(current);
            if (ret.size() > 0) {
                ret.add(" ");
            }
            ret.add(String.join("", current));
            current.clear();
        } else {
            current.add(s.charAt(i));
        }
    }
    return String.join("", ret);
}
--------------------------------
List<Integer> sortArray(List<Integer> array) {
    if (array.isEmpty()) {
        return array;
    }
    if ((array.get(0) + array.get(array.size() - 1)) % 2 == 1) {
        Collections.sort(array, (a, b) -> a - b);
    } else {
        Collections.sort(array, (a, b) -> b - a);
    }
    return array;
}
--------------------------------
String encrypt(String s) {
    String ans = "";
    for (char c : s.toCharArray()) {
        if (c.toUpperCase()!= c.toLowerCase()) {
            ans += (char) ('a' + (c - 'a' + 4) % 26);
        } else {
            ans += c;
        }
    }
    return ans;
}
--------------------------------
int isBored(String s) {
    int isStart = true;
    int sum = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '.' || s.charAt(i) == '?' || s.charAt(i) == '!') {
            isStart = true;
        } else if (isStart) {
            if (s.charAt(i) =='') {
                continue;
            }
            if (s.substring(i, i + 2) == 'I ') {
                sum += 1;
            }
            isStart = false;
        }
    }
    return sum;
}
--------------------------------
String encode(String message) {
    String vowels = "aeiouAEIOU";
    StringBuilder ret = new StringBuilder();
    for (char c : message.toCharArray()) {
        if (Character.isUpperCase(c) && Character.isLowerCase(c)) {
            c = Character.toLowerCase(c);
            if (vowels.contains(c)) {
                c = (char) ('a' + (c - 'a' + 2) % 26);
            }
        } else if (Character.isLowerCase(c) && Character.isUpperCase(c)) {
            c = Character.toUpperCase(c);
            if (vowels.contains(c)) {
                c = (char) ('A' + (c - 'A' + 2) % 26);
            }
        }
        ret.append(c);
    }
    return ret.toString();
}
--------------------------------
int skjkasdkd(List<Integer> lst) {
    int largest = 0;
    for (int n : lst) {
        if (n > largest) {
            boolean prime = true;
            for (int i = 2; i < n; i++) {
                if (n % i == 0) {
                    prime = false;
                }
            }
            if (prime) {
                largest = n;
            }
        }
    }
    int sum = 0;
    String s = largest.toString();
    for (int i = 0; i < s.length(); i++) {
        sum += s.charAt(i) - '0';
    }
    return sum;
}
--------------------------------
boolean checkDictCase(Map<String, String> dict) {
    if (dict.size() == 0) {
        return false;
    }
    int isLower = 0;
    int isUpper = 0;
    for (Map.Entry<String, String> entry : dict.entrySet()) {
        String key = entry.getKey();
        String value = entry.getValue();
        for (char c : key.toCharArray()) {
            if (Character.isLowerCase(c) && Character.isUpperCase(c)) {
                return false;
            } else if (Character.isLowerCase(c)) {
                isLower = 1;
            } else if (Character.isUpperCase(c)) {
                isUpper = 1;
            }
        }
    }
    return isLower + isUpper == 1;
}
--------------------------------
int multiply(int a, int b) {
    return Math.abs(a) % 10 * Math.abs(b) % 10;
}
--------------------------------
int countUpper(String s) {
    String uVowel = "AEIOU";
    int count = 0;
    for (int i = 0; i < s.length(); i += 2) {
        if (uVowel.contains(s.charAt(i))) {
            count++;
        }
    }
    return count;
}
--------------------------------
List<String> byLength(List<Integer> arr) {
    Map<Integer, String> numTo = new HashMap<>();
    numTo.put(1, "One");
    numTo.put(2, "Two");
    numTo.put(3, "Three");
    numTo.put(4, "Four");
    numTo.put(5, "Five");
    numTo.put(6, "Six");
    numTo.put(7, "Seven");
    numTo.put(8, "Eight");
    numTo.put(9, "Nine");
    List<Integer> sortedArr = new ArrayList<>(arr);
    Collections.sort(sortedArr, (a, b) -> b - a);
    List<String> newArr = new ArrayList<>();
    for (int n : sortedArr) {
        if (n >= 1 && n <= 9) {
            newArr.add(numTo.get(n));
        }
    }
    return newArr;
}
--------------------------------
List<Integer> f(int n) {
    int sum = 1;
    int prod = 0;
    List<Integer> result = new ArrayList<>();
    for (int i = 1; i <= n; i++) {
        prod += i;
        sum *= i;
        if (i % 2 == 0) {
            result.add(sum);
        } else {
            result.add(prod);
        }
    }
    return result;
}
--------------------------------
List<Integer> evenOddPalindrome(int n) {
    int evenCount = 0;
    int oddCount = 0;
    for (int i = 1; i <= n; i++) {
        String s = Integer.toString(i);
        String rStr = new StringBuilder(s).reverse().toString();
        if (s.equals(rStr)) {
            if (i % 2 == 1) {
                oddCount += 1;
            } else {
                evenCount += 1;
            }
        }
    }
    return Arrays.asList(evenCount, oddCount);
}
--------------------------------
Map<Character, Integer> histogram(String test) {
    Map<Character, Integer> count = new HashMap<>();
    int max = 0;
    for (int i = 0; i < test.length(); i++) {
        if (test.charAt(i)!='') {
            count.put(test.charAt(i), count.getOrDefault(test.charAt(i), 0) + 1);
            if (count.get(test.charAt(i)) > max) {
                max = count.get(test.charAt(i));
            }
        }
    }
    Map<Character, Integer> result = new HashMap<>();
    for (Map.Entry<Character, Integer> entry : count.entrySet()) {
        if (entry.getValue() == max) {
            result.put(entry.getKey(), entry.getValue());
        }
    }
    return result;
}
--------------------------------
List<String> reverseDelete(String s, String c) {
    List<String> ret = new ArrayList<>();
    for (char ch : s.toCharArray()) {
        if (!c.contains(ch)) {
            ret.add(ch);
        }
    }
    String flag = "False";
    if (ret.toString().equals(new StringBuilder(ret.toString()).reverse().toString())) {
        flag = "True";
    }
    return Arrays.asList(ret.toString(), flag);
}
--------------------------------
List<Integer> sortArray(List<Integer> arr) {
    List<Integer> bin = new ArrayList<>();
    for (int i : arr) {
        int b = 0;
        int n = Math.abs(i);
        while (n > 0) {
            b += n % 2;
            n = Math.floor(n / 2);
        }
        bin.add(b);
    }
    for (int i = 0; i < arr.size(); i++) {
        for (int j = 1; j < arr.size(); j++) {
            if (bin.get(j) < bin.get(j - 1) || (bin.get(j) == bin.get(j - 1) && arr.get(j) < arr.get(j - 1))) {
                [ bin.get(j), bin.get(j - 1) ] = [ bin.get(j - 1), bin.get(j) ];
                [ arr.get(j), arr.get(j - 1) ] = [ arr.get(j - 1), arr.get(j) ];
            }
        }
    }
    return arr;
}
--------------------------------
String getClosestVowel(String word) {
    String vowels = "AEIOUaeiou";
    for (int i = word.length() - 2; i > 0; i--) {
        if (vowels.contains(word.charAt(i)) &&!vowels.contains(word.charAt(i + 1)) &&!vowels.contains(word.charAt(i - 1))) {
            return word.charAt(i);
        }
    }
    return "";
}
--------------------------------
String matchParens(List<String> lst) {
    List<String> strings = Arrays.asList(lst.get(0) + lst.get(1), lst.get(1) + lst.get(0));
    for (String l : strings) {
        int count = 0;
        for (char c : l.toCharArray()) {
            if (c == = '(') {
                count += 1;
            }
            if (c == = ')') {
                count -= 1;
            }
            if (count < 0) {
                break;
            }
        }
        if (count == = 0) {
            return "Yes";
        }
    }
    return "No";
}
--------------------------------
List<Integer> maximum(List<Integer> arr, int k) {
    if (k == 0) {
        return new ArrayList<>();
    }
    arr.sort((a, b) -> a - b);
    return arr.subList(arr.size() - k, arr.size());
}
--------------------------------
boolean validDate(String date) {
    if (date.length()!= 10) {
        return false;
    }
    for (int i = 0; i < 10; i++) {
        if (i == 2 || i == 5) {
            if (date.charAt(i)!= '-') {
                return false;
            }
        } else if (date.charAt(i) < '0' || date.charAt(i) > '9') {
            return false;
        }
    }
    int month = Integer.parseInt(date.substring(0, 2));
    int day = Integer.parseInt(date.substring(3, 5));
    int year = Integer.parseInt(date.substring(6, 10));
    if (month < 1 || month > 12) {
        return false;
    }
    if (day < 1 || day > 31) {
        return false;
    }
    if (day == 31 && (month == 4 || month == 6 || month == 9 || month == 11 || month == 2)) {
        return false;
    }
    if (day == 30 && month == 2) {
        return false;
    }
    return true;
}
--------------------------------
Object splitWords(String txt) {
    List<String> result = new ArrayList<>();
    if (txt.contains(" ")) {
        String[] words = txt.split(" ");
        for (String word : words) {
            result.add(word);
        }
        return result;
    }
    if (txt.contains(",")) {
        String[] words = txt.split(",");
        for (String word : words) {
            result.add(word);
        }
        return result;
    }
    int num = 0;
    for (char c : txt.toCharArray()) {
        if (Character.isLowerCase(c) && Character.isUpperCase(c) == false && c % 2 == 0) {
            num += 1;
        }
    }
    return Arrays.asList(num.toString());
}
--------------------------------
List<Integer> tri(int n) {
    if (n == 0) {
        return Arrays.asList(1);
    }
    List<Integer> tris = Arrays.asList(1, 3);
    for (int i = 2; i <= n; i++) {
        if (i % 2 == 0) {
            tris.add(1 + i / 2);
        } else {
            tris.add(tris.get(i - 2) + tris.get(i - 1) + (i + 3) / 2);
        }
    }
    return tris;
}
--------------------------------
boolean checkIfLastCharIsALetter(String txt) {
    if (txt.length() == 0) {
        return false;
    }
    return txt.charAt(txt.length() - 1).toUpperCase()!= txt.charAt(txt.length() - 1).toLowerCase() && (txt.length() == 1 || txt.charAt(txt.length() - 2).toUpperCase() == txt.charAt(txt.length() - 2).toLowerCase());
}
--------------------------------
List<Integer> orderByPoints(List<Integer> nums) {
    List<Integer> result = new ArrayList<>();
    for (int num : nums) {
        String w = Math.abs(num).toString();
        int sum = 0;
        for (char c : w.toCharArray()) {
            sum += c - '0';
        }
        if (num < 0) {
            sum -= 2 * (w.charAt(0) - '0');
        }
        result.add(sum);
    }
    for (int i = 0; i < nums.size(); i++) {
        for (int j = 1; j < nums.size(); j++) {
            if (result.get(j - 1) > result.get(j)) {
                int temp = result.get(j);
                result.set(j, result.get(j - 1));
                result.set(j - 1, temp);
                int temp2 = nums.get(j);
                nums.set(j, nums.get(j - 1));
                nums.set(j - 1, temp2);
            }
        }
    }
    return nums;
}
--------------------------------
List<String> bf(String planet1, String planet2) {
    List<String> planets = Arrays.asList("Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune");
    int idx1 = planets.indexOf(planet1);
    int idx2 = planets.indexOf(planet2);
    if (idx1 == -1 || idx2 == -1 || idx1 == idx2) {
        return Collections.emptyList();
    }
    return idx1 > idx2? planets.subList(idx2 + 1, idx1) : planets.subList(idx1 + 1, idx2);
}
--------------------------------
List<String> sortedListSum(List<String> lst) {
    List<String> result = new ArrayList<>();
    for (String i : lst) {
        if (i.length() % 2 == 0) {
            result.add(i);
        }
    }
    result.sort((l, r) -> {
        if (l.length() == r.length()) {
            return l.compareTo(r);
        }
        return l.length() - r.length();
    });
    return result;
}
--------------------------------
boolean cycpatternCheck(String a, String b) {
    for (int i = 0; i < b.length(); i++) {
        String rotate = b.substring(i) + b.substring(0, i);
        if (a.contains(rotate)) {
            return true;
        }
    }
    return false;
}
--------------------------------
List<Integer> evenOddCount(int num) {
    int evenCount = 0, oddCount = 0;
    for (char i : Math.abs(num).toString().toCharArray()) {
        if (i % 2 == 0) {
            evenCount += 1;
        } else {
            oddCount += 1;
        }
    }
    return Arrays.asList(evenCount, oddCount);
}
--------------------------------
String findMax(List<String> words) {
    String max = "";
    int maxLength = 0;
    for (String word : words) {
        List<Character> unique = new ArrayList<>();
        for (char w : word.toCharArray()) {
            if (!unique.contains(w)) {
                unique.add(w);
            }
        }
        if (unique.size() > maxLength || (unique.size() == maxLength && word < max)) {
            max = word;
            maxLength = unique.size();
        }
    }
    return max;
}
--------------------------------
String solve(String s) {
    boolean noLetter = true;
    char[] result = new char[s.length()];
    for (int i = 0; i < s.length(); i++) {
        char ch = s.charAt(i);
        if (Character.isUpperCase(ch) && Character.isLowerCase(ch)) {
            ch = Character.toLowerCase(ch);
            noLetter = false;
        } else if (Character.isLowerCase(ch) && Character.isUpperCase(ch)) {
            ch = Character.toUpperCase(ch);
            noLetter = false;
        }
        result[i] = ch;
    }
    if (noLetter) {
        return new String(result).reverse();
    } else {
        return new String(result);
    }
}
--------------------------------
int mostFrequent(List<Integer> arr, int n) {
    Map<Integer, Integer> hp = new HashMap<>();
    for (int i = 0; i < n; i++) {
        if (hp.containsKey(arr.get(i))) {
            hp.put(arr.get(i), hp.get(arr.get(i)) + 1);
        } else {
            hp.put(arr.get(i), 1);
        }
    }
    int maxCount = 0, res = -1;
    for (Map.Entry<Integer, Integer> entry : hp.entrySet()) {
        if (maxCount < entry.getValue()) {
            res = entry.getKey();
            maxCount = entry.getValue();
        }
    }
    return res;
}
--------------------------------
int find(List<Integer> a, List<Integer> b, int k, int n1, int n2) {
    Set<Integer> s = new HashSet<>();
    for (int i = 0; i < n2; i++) {
        s.add(b.get(i));
    }
    int missing = 0;
    for (int i = 0; i < n1; i++) {
        if (!s.contains(a.get(i))) {
            missing++;
        }
        if (missing == k) {
            return a.get(i);
        }
    }
    return -1;
}
--------------------------------
int solveQuery(int start, int end, List<Integer> arr) {
    Map<Integer, Integer> mp = new HashMap<>();
    for (int i = start; i <= end; i++) {
        mp.put(arr.get(i), mp.getOrDefault(arr.get(i), 0) + 1);
    }
    int count = 0;
    for (Map.Entry<Integer, Integer> entry : mp.entrySet()) {
        if (entry.getKey() == entry.getValue()) {
            count++;
        }
    }
    return count;
}
--------------------------------
int segregate(List<Integer> arr, int size) {
    int j = 0;
    for (int i = 0; i < size; i++) {
        if (arr.get(i) <= 0) {
            arr.set(i, arr.get(j));
            arr.set(j, arr.get(i));
            j++;
        }
    }
    return j;
}
--------------------------------
int countTriplets(List<Integer> a, int n) {
    Set<Integer> s = new HashSet<>();
    for (int i = 0; i < n; i++) {
        s.add(a.get(i));
    }
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int xr = a.get(i) ^ a.get(j);
            if (s.contains(xr) && xr!= a.get(i) && xr!= a.get(j)) {
                count++;
            }
        }
    }
    return (int) Math.floor(count / 3);
}
--------------------------------
int leastFrequent(List<Integer> arr, int n) {
    Map<Integer, Integer> hp = new HashMap<>();
    for (int i = 0; i < n; i++) {
        if (hp.containsKey(arr.get(i))) {
            hp.put(arr.get(i), hp.get(arr.get(i)) + 1);
        } else {
            hp.put(arr.get(i), 1);
        }
    }
    int minCount = n + 1, res = -1;
    for (Map.Entry<Integer, Integer> entry : hp.entrySet()) {
        if (minCount >= entry.getValue()) {
            res = entry.getKey();
            minCount = entry.getValue();
        }
    }
    return res;
}
--------------------------------
int findPermutations(List<Integer> arr) {
    int cnt = 0;
    int maxInd = -1, minInd = 10000000;
    int n = arr.size();
    Map<Integer, Integer> indexOf = new HashMap<>();
    for (int i = 0; i < n; i++) {
        indexOf.put(arr.get(i), i + 1);
    }
    for (int i = 1; i <= n; i++) {
        maxInd = Math.max(maxInd, indexOf.getOrDefault(i, 0));
        minInd = Math.min(minInd, indexOf.getOrDefault(i, 0));
        if (maxInd - minInd + 1 == i) {
            cnt++;
        }
    }
    return cnt;
}
--------------------------------
int formQuadruplets(List<Integer> arr, int n) {
    int ans = 0, pairs = 0;
    pairs = (int) Math.floor(n / 4);
    arr.sort(Comparator.reverseOrder());
    for (int i = 0; i < n - pairs; i += 3) {
        ans += arr.get(i + 2);
    }
    return ans;
}
--------------------------------
String lexicographicallyMaximum(String s, int n) {
    Map<Character, Integer> m = new HashMap<>();
    for (int i = 0; i < n; ++i) {
        if (m.containsKey(s.charAt(i))) {
            m.put(s.charAt(i), m.get(s.charAt(i)) + 1);
        } else {
            m.put(s.charAt(i), 1);
        }
    }
    List<Character> v = new ArrayList<>();
    for (int i = 'a'.codePointAt(0); i < 'a'.codePointAt(0) + Math.min(n, 25); ++i) {
        if (!m.containsKey(String.valueOf(Character.toChars(i)))) {
            v.add(Character.toChars(i)[0]);
        }
    }
    int j = v.size() - 1;
    for (int i = 0; i < n; ++i) {
        if (s.charAt(i).codePointAt(0) >= 'a'.codePointAt(0) + Math.min(n, 25) || (m.containsKey(s.charAt(i)) && m.get(s.charAt(i)) > 1)) {
            if (v.get(j).codePointAt(0) < s.charAt(i).codePointAt(0)) {
                continue;
            }
            m.put(s.charAt(i), m.get(s.charAt(i)) - 1);
            s = s.substring(0, i) + v.get(j) + s.substring(i + 1);
            j--;
        }
        if (j < 0) {
            break;
        }
    }
    int l = 0;
    for (int i = n - 1; i >= 0; i--) {
        if (l > j) {
            break;
        }
        if (s.charAt(i).codePointAt(0) >= 'a'.codePointAt(0) + Math.min(n, 25) || m.containsKey(s.charAt(i)) && m.get(s.charAt(i)) > 1--------------------------------
int noOfValidKbers(int k, List<Integer> arr) {
    Set<Integer> set = new HashSet<>();
    while (k!= = 0) {
        set.add(k % 10);
        k = Math.trunc(k / 10);
    }
    int count = 0;
    for (int i = 0; i < arr.size(); i++) {
        int no = arr.get(i);
        boolean flag = true;
        while (no!= = 0) {
            int digit = no % 10;
            if (!set.contains(digit)) {
                flag = false;
                break;
            }
            no = Math.trunc(no / 10);
        }
        if (flag) {
            count++;
        }
    }
    return count;
}
--------------------------------
int delCost(String s, List<Integer> cost) {
    int ans = 0;
    Map<Character, Integer> forMax = new HashMap<>();
    Map<Character, Integer> forTot = new HashMap<>();
    for (int i = 0; i < s.length(); i++) {
        if (!forMax.containsKey(s.charAt(i))) {
            forMax.put(s.charAt(i), cost.get(i));
        } else {
            forMax.put(s.charAt(i), Math.max(forMax.get(s.charAt(i)), cost.get(i)));
        }
        if (!forTot.containsKey(s.charAt(i))) {
            forTot.put(s.charAt(i), cost.get(i));
        } else {
            forTot.put(s.charAt(i), forTot.get(s.charAt(i)) + cost.get(i));
        }
    }
    for (Map.Entry<Character, Integer> i : forMax.entrySet()) {
        ans += forTot.get(i.getKey()) - i.getValue();
    }
    return ans;
}
--------------------------------
List<String> replaceDuplicates(List<String> names) {
    Map<String, Integer> hash = new HashMap<>();
    for (int i = 0; i < names.size(); i++) {
        if (!hash.containsKey(names.get(i))) {
            hash.put(names.get(i), 1);
        } else {
            int count = hash.get(names.get(i));
            hash.put(names.get(i), hash.get(names.get(i)) + 1);
            names.set(i, names.get(i) + count);
        }
    }
    return names;
}
--------------------------------
List<Integer> minmaxNumbers(List<List<Integer> > matrix, List<Integer> res) {
    Set<Integer> s = new HashSet<>();
    for (int i = 0; i < matrix.size(); i++) {
        int minR = Integer.MAX_VALUE;
        for (int j = 0; j < matrix.get(i).size(); j++) {
            minR = Math.min(minR, matrix.get(i).get(j));
        }
        s.add(minR);
    }
    for (int j = 0; j < matrix.get(0).size(); j++) {
        int maxC = Integer.MIN_VALUE;
        for (int i = 0; i < matrix.size(); i++) {
            maxC = Math.max(maxC, matrix.get(i).get(j));
        }
        if (s.contains(maxC)) {
            res.add(maxC);
        }
    }
    return res;
}
--------------------------------
int lengthOfLongestAP(List<Integer> a, int n) {
    Map<Integer, Integer> dp = new HashMap<>();
    int res = 2;
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            int d = a.get(j) - a.get(i);
            if (dp.containsKey(d)) {
                if (dp.get(d).containsKey(i)) {
                    dp.get(d).put(j, dp.get(d).get(i) + 1);
                } else {
                    dp.get(d).put(j, 2);
                }
            } else {
                dp.put(d, new HashMap<>());
                dp.get(d).put(j, 2);
            }
            res = Math.max(res, dp.get(d).get(j));
        }
    }
    return res;
}
--------------------------------
char findKthChar(int n, int k) {
    String prev = "A";
    String cur = "";
    if (n == 1) {
        return 'A';
    }
    for (int j = 2; j <= n; j++) {
        cur = prev + "B";
        for (int i = 0; i < prev.length(); i++) {
            if (prev.charAt(i) == 'A') {
                prev = prev.substring(0, i) + "B" + prev.substring(i + 1);
            } else {
                prev = prev.substring(0, i) + "A" + prev.substring(i + 1);
            }
        }
        prev = prev.split("").reverse().join("");
        cur += prev;
        prev = cur;
    }
    return cur.charAt(k - 1);
}
--------------------------------
char findKthLargest(String s, int k) {
    char[] tmp = s.toCharArray();
    Arrays.sort(tmp);
    return tmp[tmp.length - k];
}
--------------------------------
int subArraylen(List<Integer> arr, int n, int k) {
    Map<Integer, Integer> mp = new HashMap<>();
    mp.put(arr.get(0), 0);
    for (int i = 1; i < n; i++) {
        arr.set(i, arr.get(i) + arr.get(i - 1));
        mp.put(arr.get(i), i);
    }
    int len = Integer.MAX_VALUE;
    for (int i = 0; i < n; i++) {
        if (arr.get(i) < k) {
            continue;
        } else {
            int x = arr.get(i) - k;
            if (x == 0) {
                len = Math.min(len, i);
            }
            if (!mp.containsKey(x)) {
                continue;
            } else {
                len = Math.min(len, i - mp.get(x));
            }
        }
    }
    return len;
}
--------------------------------
int findMaxLen(List<Integer> a, int k) {
    int n = a.size();
    a.sort(Comparator.naturalOrder());
    boolean[] vis = new boolean[n];
    Map<Integer, Integer> mp = new HashMap<>();
    for (int i = 0; i < n; i++) {
        mp.put(a.get(i), i);
    }
    int c = 0;
    for (int i = 0; i < n; ++i) {
        if (!vis[i]) {
            int check = a.get(i) * k;
            if (mp.containsKey(check)) {
                c++;
                vis[mp.get(check)] = true;
            }
        }
    }
    return n - c;
}
--------------------------------
List<Integer> minDistancePoints(List<Integer> a, int k, int n) {
    Map<Integer, Integer> m = new HashMap<>();
    Queue<Integer> q = new LinkedList<>();
    for (int i = 0; i < n; ++i) {
        m.put(a.get(i), 1);
        q.add(a.get(i));
    }
    List<Integer> ans = new ArrayList<>();
    while (k > 0) {
        int x = q.poll();
        if (!m.containsKey(x - 1) && k > 0) {
            m.put(x - 1, 1);
            q.add(x - 1);
            ans.add(x - 1);
            k--;
        }
        if (!m.containsKey(x + 1) && k > 0) {
            m.put(x + 1, 1);
            q.add(x + 1);
            ans.add(x + 1);
            k--;
        }
    }
    return ans;
}
--------------------------------
boolean isValidLen(String s, int len, int k) {
    int n = s.length();
    Map<Character, Integer> mp = new HashMap<>();
    int right = 0;
    while (right < len) {
        if (mp.containsKey(s.charAt(right))) {
            mp.put(s.charAt(right), mp.get(s.charAt(right)) + 1);
        } else {
            mp.put(s.charAt(right), 1);
        }
        right++;
    }
    if (mp.size() <= k) {
        return true;
    }
    while (right < n) {
        if (mp.containsKey(s.charAt(right))) {
            mp.put(s.charAt(right), mp.get(s.charAt(right)) + 1);
        } else {
            mp.put(s.charAt(right), 1);
        }
        if (mp.containsKey(s.charAt(right - len))) {
            mp.put(s.charAt(right - len), mp.get(s.charAt(right - len)) - 1);
        }
        if (mp.containsKey(s.charAt(right - len)) && mp.get(s.charAt(right - len)) == 0) {
            mp.remove(s.charAt(right - len));
        }
        if (mp.size() <= k) {
            return true;
        }
        right++;
    }
    return mp.size() <= k;
}
--------------------------------
int partition(List<Integer> arr, int low, int high) {
    int pivot = arr.get(high);
    int i = (low - 1);
    for (int j = low; j <= high - 1; j++) {
        if (arr.get(j) <= pivot) {
            i++;
            int temp = arr.get(i);
            arr.set(i, arr.get(j));
            arr.set(j, temp);
        }
    }
    int temp = arr.get(i + 1);
    arr.set(i + 1, arr.get(high));
    arr.set(high, temp);
    return (i + 1);
}
--------------------------------
int strScore(List<String> strs, String s, int n) {
    Map<String, Integer> m = new HashMap<>();
    for (int i = 0; i < n; i++) {
        m.put(strs.get(i), i + 1);
    }
    if (!m.containsKey(s)) {
        return 0;
    }
    int score = 0;
    for (int i = 0; i < s.length(); i++) {
        score += s.charAt(i) - 'a' + 1;
    }
    score = score * m.get(s);
    return score;
}
--------------------------------
List<Integer> countEle(List<Integer> s, List<Integer> a, int n) {
    Map<Integer, Boolean> mp = new HashMap<>();
    List<Integer> ans = new ArrayList<>();
    for (int i = 0; i < n; ++i) {
        int num = a.get(i);
        if (mp.containsKey(num)) {
            ans.add(0);
        } else {
            int cnt = 0;
            while (s.get(0)!= num) {
                mp.put(s.get(0), true);
                s.remove(0);
                cnt++;
            }
            s.remove(0);
            cnt++;
            ans.add(cnt);
        }
    }
    return ans;
}
--------------------------------
int maxDistinctChar(String s, int n, int k) {
    Map<Character, Integer> freq = new HashMap<>();
    for (int i = 0; i < n; i++) {
        if (freq.containsKey(s.charAt(i))) {
            freq.put(s.charAt(i), freq.get(s.charAt(i)) + 1);
        } else {
            freq.put(s.charAt(i), 1);
        }
    }
    List<Integer> v = new ArrayList<>();
    for (Map.Entry<Character, Integer> it : freq.entrySet()) {
        v.add(it.getValue());
    }
    v.sort(Comparator.naturalOrder());
    for (int i = 0; i < v.size(); i++) {
        int mn = Math.min(v.get(i) - 1, k);
        v.set(i, v.get(i) - mn);
        k -= mn;
    }
    if (k > 0) {
        for (int i = 0; i < v.size(); i++) {
            int mn = Math.min(v.get(i), k);
            v.set(i, v.get(i) - mn);
            k -= mn;
        }
    }
    int res = 0;
    for (int i = 0; i < v.size(); i++) {
        if (v.get(i) == 1) {
            res++;
        }
    }
    return res;
}
--------------------------------
int findKth(List<Integer> arr, int n, int k) {
    Set<Integer> missing = new HashSet<>();
    int count = 0;
    for (int i = 0; i < n; i++) {
        missing.add(arr.get(i));
    }
    int maxM = Collections.max(arr);
    int minM = Collections.min(arr);
    for (int i = minM + 1; i < maxM; i++) {
        if (!missing.contains(i)) {
            count++;
        }
        if (count == k) {
            return i;
        }
    }
    return -1;
}
--------------------------------
boolean almostSort(List<Integer> a, int n) {
    for (int i = 0; i < n - 1; i++) {
        if (a.get(i) > a.get(i + 1)) {
            Collections.swap(a, i, i + 1);
            i++;
        }
    }
    for (int i = 0; i < n - 1; i++) {
        if (a.get(i) > a.get(i + 1)) {
            return false;
        }
    }
    return true;
}
--------------------------------
int maximumSum(String s, int n, int k) {
    int sum = 0;
    int[] freq = new int[256];
    for (int i = 0; i < n; i++) {
        freq[s.charAt(i)]++;
    }
    Arrays.sort(freq, (a, b) -> b - a);
    for (int i = 0; i < 256; i++) {
        if (k > freq[i]) {
            sum += freq[i] * freq[i];
            k -= freq[i];
        } else {
            sum += freq[i] * k;
            break;
        }
    }
    return sum;
}
--------------------------------
int findMinOperations(List<Integer> arr, int N, int K) {
    int operations = 0;
    for (int i = 0; i < K; i++) {
        Map<Integer, Integer> freq = new HashMap<>();
        for (int j = i; j < N; j += K) {
            freq.put(arr.get(j), freq.getOrDefault(arr.get(j), 0) + 1);
        }
        int max1 = 0, num = 0;
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            if (entry.getValue() > max1) {
                max1 = entry.getValue();
                num = entry.getKey();
            }
        }
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            if (entry.getKey()!= num) {
                operations += entry.getValue();
            }
        }
    }
    return operations;
}
--------------------------------
List<String> subString(String s, int n) {
    List<String> v = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        for (int len = 1; len <= n - i; len++) {
            String find = s.substring(i, i + len);
            v.add(find);
        }
    }
    return v;
}
--------------------------------
boolean checkUniqueFrequency(List<Integer> arr, int n) {
    Map<Integer, Integer> freq = new HashMap<>();
    for (int i = 0; i < n; i++) {
        freq.put(arr.get(i), freq.getOrDefault(arr.get(i), 0) + 1);
    }
    Set<Integer> uniqueFreq = new HashSet<>();
    for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
        if (uniqueFreq.contains(entry.getValue())) {
            return false;
        } else {
            uniqueFreq.add(entry.getValue());
        }
    }
    return true;
}
--------------------------------
int minCost(String str1, String str2, int n) {
    int cost = 0;
    char[] tmp = str1.toCharArray();
    for (int i = 0; i < n; i++) {
        if (tmp[i]!= str2.charAt(i)) {
            if (i < n - 1 && tmp[i + 1]!= str2.charAt(i + 1)) {
                char tmp = tmp[i];
                tmp[i] = tmp[i + 1];
                tmp[i + 1] = tmp;
                cost++;
            } else {
                cost++;
            }
        }
    }
    return cost;
}
--------------------------------
boolean isValidNum(String x) {
    Map<Integer, Integer> mp = new HashMap<>();
    for (int i = 0; i < x.length(); i++) {
        if (mp.containsKey(x.charAt(i) - '0')) {
            return false;
        } else if (x.charAt(i) - '0' > 5) {
            return false;
        } else {
            mp.put(x.charAt(i) - '0', 1);
        }
    }
    return true;
}
--------------------------------
int minimizeDiff(List<Integer> arr, int n, int k) {
    int max = Collections.max(arr);
    int min = Collections.min(arr);
    if (max - min <= k) {
        return max - min;
    }
    int avg = (max + min) / 2;
    for (int i = 0; i < n; i++) {
        if (arr.get(i) > avg) {
            arr.set(i, arr.get(i) - k);
        } else {
            arr.set(i, arr.get(i) + k);
        }
    }
    max = Collections.max(arr);
    min = Collections.min(arr);
    return max - min;
}
--------------------------------
int getMinCost(List<Integer> arr, int n) {
    int minEle = Collections.min(arr);
    return minEle * (n - 1);
}
--------------------------------
boolean possibility(Map<Integer, Integer> m, int length, String s) {
    int countOdd = 0;
    for (int i = 0; i < length; i++) {
        if ((m.get(s.charAt(i) - '0') & 1) == 1) {
            countOdd++;
        }
        if (countOdd > 1) {
            return false;
        }
    }
    return true;
}
--------------------------------
int minimumCostOfBreaking(List<Integer> x, List<Integer> y, int m, int n) {
    int res = 0;
    Collections.sort(x, Collections.reverseOrder());
    Collections.sort(y, Collections.reverseOrder());
    int hzntl = 1, vert = 1;
    int i = 0, j = 0;
    while (i < m && j < n) {
        if (x.get(i) > y.get(j)) {
            res += x.get(i) * vert;
            hzntl++;
            i++;
        } else {
            res += y.get(j) * hzntl;
            vert++;
            j++;
        }
    }
    int total = 0;
    while (i < m) {
        total += x.get(i++);
    }
    res += total * vert;
    total = 0;
    while (j < n) {
        total += y.get(j++);
    }
    res += total * hzntl;
    return res;
}
--------------------------------
int findMaximumScore(List<Integer> a, int n) {
    Map<Integer, Integer> freq = new HashMap<>();
    for (int i = 0; i < n; i++) {
        if (freq.containsKey(a.get(i))) {
            freq.put(a.get(i), freq.get(a.get(i)) + 1);
        } else {
            freq.put(a.get(i), 1);
        }
    }
    int[] dp = new int[Math.max(a.get(0), a.get(1)) + 1];
    dp[0] = 0;
    dp[1] = freq.get(1)!= null? freq.get(1) : 0;
    for (int i = 2; i < dp.length; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + (freq.get(i)!= null? freq.get(i) : 0) * i);
    }
    return dp[dp.length - 1];
}
--------------------------------
int countWays(String s, String t, int k, int mod) {
    int n = s.length();
    int a = 0, b = 0;
    for (int i = 0; i < n; i++) {
        String p = s.substring(i, n) + s.substring(0, i);
        if (p == = t) {
            a++;
        } else {
            b++;
        }
    }
    int[] dp1 = new int[k + 1];
    int[] dp2 = new int[k + 1];
    if (s == = t) {
        dp1[0] = 1;
        dp2[0] = 0;
    } else {
        dp1[0] = 0;
        dp2[0] = 1;
    }
    for (int i = 1; i <= k; i++) {
        dp1[i] = ((dp1[i - 1] * (a - 1)) % mod + (dp2[i - 1] * a) % mod) % mod;
        dp2[i] = ((dp1[i - 1] * (b)) % mod + (dp2[i - 1] * (b - 1)) % mod) % mod;
    }
    return dp1[k];
}
--------------------------------
int findSubarraySum(List<Integer> arr, int n, int k) {
    Map<Integer, Integer> prevSum = new HashMap<>();
    int res = 0;
    int currSum = 0;
    for (int i = 0; i < n; i++) {
        currSum += arr.get(i);
        if (currSum == k) {
            res++;
        }
        if (prevSum.containsKey(currSum - k)) {
            res += prevSum.get(currSum - k);
        }
        prevSum.put(currSum, prevSum.getOrDefault(currSum, 0) + 1);
    }
    return res;
}
--------------------------------
int maximumOccurrence(String s) {
    int n = s.length();
    Map<String, Integer> freq = new HashMap<>();
    for (int i = 0; i < n; i++) {
        String temp = "";
        temp += s.charAt(i);
        freq.put(temp, freq.getOrDefault(temp, 0) + 1);
    }
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            String temp = "";
            temp += s.charAt(i);
            temp += s.charAt(j);
            freq.put(temp, freq.getOrDefault(temp, 0) + 1);
        }
    }
    int answer = -Integer.MAX_VALUE;
    for (Map.Entry<String, Integer> entry : freq.entrySet()) {
        answer = Math.max(answer, entry.getValue());
    }
    return answer;
}
--------------------------------
int countCharacters(List<String> strings, String chars) {
    int res = 0;
    Map<Character, Integer> freq = new HashMap<>();
    for (char c : chars.toCharArray()) {
        freq.put(c, freq.getOrDefault(c, 0) + 1);
    }
    for (String st : strings) {
        boolean flag = true;
        for (char c : st.toCharArray()) {
            if (!freq.containsKey(c)) {
                flag = false;
                break;
            }
        }
        if (flag) {
            res += st.length();
        }
    }
    return res;
}
--------------------------------
int distinctSubstring(String p, String q, int k, int n) {
    Set<String> ss = new HashSet<>();
    for (int i = 0; i < n; ++i) {
        int sum = 0;
        String s = "";
        for (int j = i; j < n; ++j) {
            int pos = p.charAt(j) - 'a';
            sum += q.charAt(pos) - '0';
            s += p.charAt(j);
            if (sum <= k) {
                ss.add(s);
            } else {
                break;
            }
        }
    }
    return ss.size();
}
--------------------------------
int uniqueMorseRep(List<String> arr) {
    String[] morseCode = { ".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.." };
    Set<String> st = new HashSet<>();
    int N = arr.size();
    for (int i = 0; i < N; i++) {
        String temp = "";
        int M = arr.get(i).length();
        for (int j = 0; j < M; j++) {
            temp += morseCode[arr.get(i).charAt(j) - 'a'];
        }
        st.add(temp);
    }
    return st.size();
}
--------------------------------
int countSubstrings(String st, int k) {
    int n = st.length();
    int answer = 0;
    Map<Character, Integer> map = new HashMap<>();
    for (int i = 0; i < k; i++) {
        if (!map.containsKey(st.charAt(i))) {
            map.put(st.charAt(i), 1);
        } else {
            map.put(st.charAt(i), map.get(st.charAt(i)) + 1);
        }
    }
    if (map.size() == k) {
        answer++;
    }
    for (int i = k; i < n; i++) {
        if (!map.containsKey(st.charAt(i))) {
            map.put(st.charAt(i), 1);
        } else {
            map.put(st.charAt(i), map.get(st.charAt(i)) + 1);
        }
        map.put(st.charAt(i - k), map.get(st.charAt(i - k)) - 1);
        if (map.containsKey(st.charAt(i - k)) && map.get(st.charAt(i - k)) == 0) {
            map.remove(st.charAt(i - k));
        }
        if (map.size() == k) {
            answer++;
        }
    }
    return answer;
}
--------------------------------
boolean canConstruct(String s, int k) {
    Map<Character, Integer> m = new HashMap<>();
    int i = 0, j = 0, p = 0;
    if (s.length() == k) {
        return true;
    }
    for (i = 0; i < s.length(); i++) {
        m.put(s.charAt(i), m.getOrDefault(s.charAt(i), 0) + 1);
    }
    if (k > s.length()) {
        return false;
    } else {
        for (Character h : m.keySet()) {
            if (m.get(h) % 2!= 0) {
                p = p + 1;
            }
        }
    }
    if (k < p) {
        return false;
    }
    return true;
}
--------------------------------
boolean equalIgnoreCase(String str1, String str2) {
    str1 = str1.toUpperCase();
    str2 = str2.toUpperCase();
    return str1 == = str2;
}
--------------------------------
int findLongestSub(String bin) {
    int n = bin.length(), i;
    int sum = 0;
    Map<Integer, Integer> prevSum = new HashMap<>();
    int maxlen = 0;
    for (i = 0; i < n; i++) {
        if (bin.charAt(i) == '1') {
            sum++;
        } else {
            sum--;
        }
        if (sum > 0) {
            maxlen = i + 1;
        } else if (sum <= 0) {
            if (prevSum.containsKey(sum - 1)) {
                int currLen = i - prevSum.get(sum - 1);
                maxlen = Math.max(maxlen, currLen);
            }
        }
        if (!prevSum.containsKey(sum)) {
            prevSum.put(sum, i);
        }
    }
    return maxlen;
}
--------------------------------
boolean hasAllCodes(String s, int k) {
    Set<String> us = new HashSet<>();
    for (int i = 0; i + k <= s.length(); i++) {
        us.add(s.substring(i, i + k));
    }
    return us.size() == 1 << k;
}
--------------------------------
boolean checkPalin(String word) {
    int n = word.length();
    word = word.toLowerCase();
    for (int i = 0; i < n; i++, n--) {
        if (word.charAt(i)!= word.charAt(n - 1)) {
            return false;
        }
    }
    return true;
}
--------------------------------
String convert(String st) {
    String w = "", z = "";
    st = st.toUpperCase() + " ";
    for (int i = 0; i < st.length(); i++) {
        char ch = st.charAt(i);
        if (ch!= = " ") {
            w += ch;
        } else {
            z += w.substring(0, 1).toLowerCase() + w.substring(1) + " ";
            w = "";
        }
    }
    return z;
}
--------------------------------
int maxLines(int n, List<Integer> x1, List<Integer> y1, List<Integer> x2, List<Integer> y2) {
    Set<Double> s = new HashSet<>();
    double slope;
    for (int i = 0; i < n; i++) {
        if (x1.get(i) == x2.get(i)) {
            slope = Double.MAX_VALUE;
        } else {
            slope = (y2.get(i) - y1.get(i)) * 1.0 / (x2.get(i) - x1.get(i));
        }
        s.add(slope);
    }
    return s.size();
}
--------------------------------
HashMap<Integer, Integer> PrimeFactor(int n) {
    HashMap<Integer, Integer> primef = new HashMap<Integer, Integer>();
    while (n % 2 == = 0) {
        if (primef.containsKey(2)) {
            primef.put(2, primef.get(2) + 1);
        } else {
            primef.put(2, 1);
        }
        n = n / 2;
    }
    for (int i = 3; i <= Math.sqrt(n); i++) {
        while (n % i == = 0) {
            if (primef.containsKey(i)) {
                primef.put(i, primef.get(i) + 1);
            } else {
                primef.put(i, 1);
            }
            n = n / i;
        }
    }
    if (n > 2) {
        primef.put(n, 1);
    }
    return primef;
}
--------------------------------
String isDivisibleByDivisor(int s, int d) {
    s %= d;
    int[] hashMap = new int[d];
    hashMap[0] = s;
    for (int i = 0; i <= d; i++) {
        s += s % d;
        s %= d;
        if (Arrays.asList(hashMap).contains(s)) {
            if (s == 0) {
                return "Yes";
            }
            return "No";
        } else {
            hashMap[i] = s;
        }
    }
    return "Yes";
}
--------------------------------
boolean oddSum(List<Integer> a, int n, int k) {
    Set<Integer> odd = new HashSet<>();
    Set<Integer> even = new HashSet<>();
    for (int i = 0; i < n; i++) {
        if (a.get(i) % 2 == 0) {
            even.add(a.get(i));
        } else {
            odd.add(a.get(i));
        }
    }
    if (odd.size() >= k) {
        return true;
    }
    boolean flag = false;
    for (int i = 1; i < k; i += 2) {
        int needed = k - i;
        if (needed <= even.size()) {
            return true;
        }
    }
    return flag;
}
--------------------------------
int dayOfYear(String date) {
    int[] days = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
    int year = Integer.parseInt(date.substring(0, 4));
    int month = Integer.parseInt(date.substring(5, 7));
    int day = Integer.parseInt(date.substring(8));
    if (month > 2 && year % 4 == 0 && (year % 100!= 0 || year % 400 == 0)) {
        ++day;
    }
    while (month > 1) {
        day = day + days[month - 2];
        --month;
    }
    return day;
}
--------------------------------
boolean isPerfectSquare(List<Integer> arr, int n) {
    Map<Integer, Integer> umap = new HashMap<>();
    for (int i = 0; i < n; i++) {
        umap.put(arr.get(i), umap.getOrDefault(arr.get(i), 0) + 1);
    }
    for (Map.Entry<Integer, Integer> itr : umap.entrySet()) {
        if (itr.getValue() % 2 == 1) {
            return false;
        }
    }
    return true;
}
--------------------------------
int minMoves(int n) {
    String s = Integer.toString(n);
    int ans = Integer.MAX_VALUE;
    int length = s.length();
    for (int i = 0; i < length; ++i) {
        for (int j = 0; j < length; ++j) {
            if (i == j) {
                continue;
            }
            String t = s.split("");
            int cur = 0;
            for (int k = i; k < length - 1; ++k) {
                [ t[k], t[k + 1] ] = [ t[k + 1], t[k] ];
                ++cur;
            }
            for (int k = j - (j > i? 1 : 0); k < length - 2; ++k) {
                [ t[k], t[k + 1] ] = [ t[k + 1], t[k] ];
                ++cur;
            }
            int pos = -1;
            for (int k = 0; k < length; ++k) {
                if (t[k]!= = "") {
                    pos = k;
                    break;
                }
            }
            for (int k = pos; k > 0; --k) {
                [ t[k], t[k - 1] ] = [ t[k - 1], t[k] ];
                ++cur;
            }
            int nn = Integer.parseInt(t.join(""));
            if (nn % 25 == = 0) {
                ans = Math.min(ans, cur);
            }
        }
    }
    if (ans == = Integer.MAX_VALUE) {
        return -1;
    }
    return ans;
}
--------------------------------
int minimumOperations(List<Integer> a, int n) {
    Map<Integer, Integer> mp = new HashMap<>();
    for (int i = 0; i < n; i++) {
        mp.put(a.get(i), mp.getOrDefault(a.get(i), 0) + 1);
    }
    int count = 0;
    for (Map.Entry<Integer, Integer> entry : mp.entrySet()) {
        if (entry.getValue() > 1) {
            count += entry.getValue() - 1;
        }
    }
    return count;
}
--------------------------------
int kaprekarRec(int n, int prev) {
    if (n == 0) {
        return 0;
    }
    prev = n;
    int[] digits = new int[4];
    for (int i = 0; i < 4; i++) {
        digits[i] = n % 10;
        n = n / 10;
    }
    Arrays.sort(digits);
    int asc = 0;
    for (int i = 0; i < 4; i++) {
        asc = asc * 10 + digits[i];
    }
    digits = new int[4];
    for (int i = 3; i >= 0; i--) {
        digits[i] = asc % 10;
        asc = asc / 10;
    }
    Arrays.sort(digits);
    int desc = 0;
    for (int i = 3; i >= 0; i--) {
        desc = desc * 10 + digits[i];
    }
    int diff = Math.abs(asc - desc);
    if (diff == prev) {
        return diff;
    }
    return kaprekarRec(diff, prev);
}
--------------------------------
String fractionToDecimal(int numr, int denr) {
    String res = "";
    Map<Integer, Integer> mp = new HashMap<>();
    mp.clear();
    int rem = numr % denr;
    while ((rem!= 0) && (!mp.containsKey(rem))) {
        mp.put(rem, res.length());
        rem = rem * 10;
        int res_part = Math.floor(rem / denr);
        res += res_part.toString();
        rem = rem % denr;
    }
    if (rem == 0) {
        return "";
    }
    if (mp.containsKey(rem)) {
        return res.substring(mp.get(rem));
    }
    return "";
}
--------------------------------
boolean isFancy(String num) {
    Map<String, String> fp = new HashMap<>();
    fp.put("0", "0");
    fp.put("1", "1");
    fp.put("6", "9");
    fp.put("8", "8");
    fp.put("9", "6");
    int n = num.length();
    int l = 0, r = n - 1;
    while (l <= r) {
        if (!fp.containsKey(num.charAt(l)) || fp.get(num.charAt(l))!= num.charAt(r)) {
            return false;
        }
        l++;
        r--;
    }
    return true;
}
--------------------------------
double distinctOddRatio(List<Integer> numbers) {
    Set<Integer> distinctNumbers = new HashSet<>(numbers);
    int distinctOddCount = distinctNumbers.stream().filter(n -> n % 2 == 1).count();
    return (double) distinctOddCount / distinctNumbers.size();
}
--------------------------------
int compareSum(List<Integer> numbers, List<String> words) {
    int intSum = numbers.stream().reduce(0, (acc, n) -> acc + n);
    int wordLengthSum = words.stream().reduce(0, (acc, w) -> acc + w.length());
    if (intSum < wordLengthSum) {
        return -1;
    } else if (intSum > wordLengthSum) {
        return 1;
    } else {
        return 0;
    }
}
--------------------------------
boolean allLongerThan(List<String> shortWords, List<String> longWords) {
    int maxOfShort = Collections.max(shortWords, Comparator.comparingInt(String::length));
    int minOfLong = Collections.min(longWords, Comparator.comparingInt(String::length));
    return minOfLong > maxOfShort;
}
--------------------------------
int compareOddEvenRange(List<Integer> numbers) {
    int rangeOdd = Math.max(numbers.stream().filter(n -> n % 2 == 1).toArray()) - Math.min(numbers.stream().filter(n -> n % 2 == 1).toArray());
    int rangeEven = Math.max(numbers.stream().filter(n -> n % 2 == 0).toArray()) - Math.min(numbers.stream().filter(n -> n % 2 == 0).toArray());
    if (rangeOdd < rangeEven) {
        return -1;
    }
    if (rangeOdd > rangeEven) {
        return 1;
    }
    return 0;
}
--------------------------------
double averageDistinctLength(List<String> words) {
    Set<String> distinctWords = new HashSet<>(words);
    double averageLen = distinctWords.stream().mapToDouble(String::length).sum() / distinctWords.size();
    return averageLen;
}
--------------------------------
int withDrawBalance(int start, List<Integer> withdrawals) {
    int end = withdrawals.stream().reduce(start, (balance, nextWithdrawal) -> {
        return nextWithdrawal <= balance? balance - nextWithdrawal : balance;
    });
    return end;
}
--------------------------------
String firstShortAndStartsWithO(List<String> words) {
    return words.stream().filter(w -> w.length() < 5).filter(w -> w.charAt(0) == 'o').findFirst().orElse("");
}
--------------------------------
int bigNumberAtIndex(List<Integer> numbers, int index) {
    int targetNum = numbers.stream().filter(n -> n > 5).collect(Collectors.toList()).get(index);
    return targetNum;
}
--------------------------------
boolean containsSquareInRange(int rangeStart, int rangeLength) {
    return Arrays.stream(IntStream.range(rangeStart, rangeStart + rangeLength).toArray()).anyMatch(n -> Math.pow(Math.sqrt(n), 2) == n);
}
--------------------------------
Map<Integer, List<Integer> > groupNumbersByMod(List<Integer> numbers, int mod) {
    Map<Integer, List<Integer> > numberGroups = new HashMap<>();
    for (Integer n : numbers) {
        int key = n % mod;
        if (numberGroups.containsKey(key)) {
            numberGroups.get(key).add(n);
        } else {
            List<Integer> group = new ArrayList<>();
            group.add(n);
            numberGroups.put(key, group);
        }
    }
    return numberGroups;
}
--------------------------------
Map<Character, List<String> > groupWordsByFirstChar(List<String> words) {
    Map<Character, List<String> > wordsGroups = new HashMap<>();
    for (String w : words) {
        char key = w.charAt(0);
        if (wordsGroups.containsKey(key)) {
            wordsGroups.get(key).add(w);
        } else {
            List<String> list = new ArrayList<>();
            list.add(w);
            wordsGroups.put(key, list);
        }
    }
    return wordsGroups;
}
--------------------------------
List<String> orderByLengthAndDescending(List<String> words) {
    List<String> sortedWords = words.stream().sorted((a, b) -> a.length() - b.length()!= 0? a.length() - b.length() : b.compareTo(a)).collect(Collectors.toList());
    return sortedWords;
}
--------------------------------
List<String> orderFirstCharDescendingReverse(List<String> words) {
    List<String> sortedWords = words.stream().sorted((a, b) -> {
        int diff = b.codePointAt(0) - a.codePointAt(0);
        if (diff!= 0) return diff;
        return a.compareTo(b);
    }).collect(Collectors.toList());
    Collections.reverse(sortedWords);
    return sortedWords;
}
--------------------------------
List<Integer> getSubListOfNegative(List<Integer> numbers, int start, int length) {
    List<Integer> subList = numbers.subList(start, numbers.size()).stream().filter(n -> n < 0).limit(length).collect(Collectors.toList());
    return subList;
}
--------------------------------
List<Integer> getPositiveSequence(List<Integer> numbers) {
    List<Integer> subSequence = new ArrayList<>();
    for (int i = 0; i < numbers.size(); i++) {
        if (numbers.get(i) <= 0) {
            continue;
        }
        subSequence = numbers.subList(i, numbers.size());
        break;
    }
    for (int i = 0; i < subSequence.size(); i++) {
        if (subSequence.get(i) > 0) {
            continue;
        }
        subSequence = subSequence.subList(0, i);
        break;
    }
    return subSequence;
}
--------------------------------
List<Integer> getLargerThanIndexSequence(List<Integer> numbers) {
    List<Integer> subSequence = numbers.stream().map(n -> new int[]{n, numbers.indexOf(n)}).collect(Collectors.toList());
    for (int i = 0; i < subSequence.size(); i++) {
        if (subSequence.get(i)[0] < subSequence.get(i)[1]) {
            continue;
        }
        subSequence = subSequence.subList(i, subSequence.size());
        break;
    }
    for (int i = 0; i < subSequence.size(); i++) {
        if (subSequence.get(i)[0] >= subSequence.get(i)[1]) {
            continue;
        }
        subSequence = subSequence.subList(0, i);
    }
    return subSequence.stream().map(x -> x[0]).collect(Collectors.toList());
}
--------------------------------
List<String> rearrangeWordByIndexes(List<String> words, List<Integer> indexes) {
    List<Integer> newIndexes = indexes.stream().filter(n -> n >= words.size()).map(n -> n % words.size());
    List<String> newWords = newIndexes.stream().map(n -> words.get(n)).collect(Collectors.toList());
    return newWords;
}
--------------------------------
List<List<String> > getWordsUpperLower(List<String> words) {
    List<List<String> > upperLowerWords = new ArrayList<>();
    for (String w : words) {
        upperLowerWords.add(Arrays.asList(w.toUpperCase(), w.toLowerCase()));
    }
    return upperLowerWords;
}
--------------------------------
List<Boolean> selectIfInPlace(List<Integer> numbers) {
    List<Boolean> numsInPlace = numbers.stream().map(num -> num == index).collect(Collectors.toList());
    return numsInPlace;
}
--------------------------------
List<List<Integer> > selectPairs(List<Integer> numbersA, List<Integer> numbersB) {
    List<List<Integer> > pairs = new ArrayList<>();
    for (Integer a : numbersA) {
        for (Integer b : numbersB) {
            if (a < b) {
                pairs.add(Arrays.asList(a, b));
            }
        }
    }
    return pairs;
}
--------------------------------
List<String> stringCrossJoin(List<String> endWords, List<String> beginWords) {
    List<String> crossStrings = new ArrayList<>();
    for (String b : beginWords) {
        for (String e : endWords) {
            if (b.charAt(0) == e.charAt(e.length() - 1)) {
                crossStrings.add(e + " " + b);
            }
        }
    }
    return crossStrings;
}
--------------------------------
int elementsContainSubword(List<String> words, String subword) {
    if (words.subList(0, 5).stream().allMatch(w -> w.contains(subword))) {
        return 1;
    } else if (words.subList(0, 5).stream().anyMatch(w -> w.contains(subword))) {
        return 0;
    } else {
        return -1;
    }
}
--------------------------------
List<Integer> ConcatLargeNumbers(List<Integer> numbersA, List<Integer> numbersB, int flag) {
    List<Integer> allNumbers = new ArrayList<>();
    for (int n : numbersA) {
        if (n > flag) {
            allNumbers.add(n);
        }
    }
    for (int n : numbersB) {
        if (n > flag) {
            allNumbers.add(n);
        }
    }
    return allNumbers;
}
--------------------------------
int DotProduct(List<Integer> vectorA, List<Integer> vectorB) {
    int dotProduct = 0;
    for (int i = 0; i < vectorA.size(); i++) {
        dotProduct += vectorA.get(i) * vectorB.get(i);
    }
    return dotProduct;
}
--------------------------------
List<Integer> SetDifference(List<Integer> setA, List<Integer> setB) {
    List<Integer> difference = new ArrayList<>(new HashSet<>(setA));
    difference.addAll(setB);
    difference.sort((a, b) -> a - b);
    difference.removeIf(x ->!setA.contains(x) ||!setB.contains(x));
    return difference;
}
--------------------------------
