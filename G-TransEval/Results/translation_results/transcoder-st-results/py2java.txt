int greatestCommonDivisor ( int a , int b ) {
  if ( a == 0 || b == 0 ) {
    return a + b ;
  }
  if ( a == b ) {
    return a ;
  }
  if ( a > b ) {
    return greatestCommonDivisor ( a % b , b ) ;
  }
  else {
    return greatestCommonDivisor ( a , b % a ) ;
  }
}

***Example ends here:
int largest_divisor ( int n ) {
  for ( int i = 2 ;
  i <= n ;
  i ++ ) {
    if ( n % i == 0 ) {
      return n / i ;
    }
  }
  return 1 ;
}

***Example ends here:
boolean isPrime ( int n ) {
  if ( n < 2 ) {
    return false ;
  }
  for ( int k = 2 ;
  k < n ;
  k ++ ) {
    if ( n % k == 0 ) {
      return false ;
    }
  }
  return true ;
}

***Example ends here:
int fizzBuzz ( int n ) {
  int count = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( i % 11 == 0 || i % 13 == 0 ) {
      int q = i ;
      while ( q > 0 ) {
        if ( q % 10 == 7 ) count ++ ;
        q /= 10 ;
      }
    }
  }
  return count ;
}

***Example ends here:
int primeFib ( int n ) {
  int f0 = 0 ;
  int f1 = 1 ;
  while ( n > 0 ) {
    int p = f0 + f1 ;
    boolean isPrime = p >= 2 ;
    for ( int i = 2 ;
    i < p ;
    i ++ ) {
      if ( p % i == 0 ) {
        isPrime = false ;
        break ;
      }
    }
    if ( isPrime ) {
      n -- ;
    }
    f0 = f1 ;
    f1 = p ;
  }
  return f1 ;
}

***Example ends here:
double triangleArea ( double a , double h ) {
  return a * h / 2 ;
}

***Example ends here:
int modp ( int n , int p ) {
  int ret = 1 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    ret = ( ret * 2 ) % p ;
  }
  return ret ;
}

***Example ends here:
int add ( int x , int y ) {
  return x + y ;
}

***Example ends here:
int fib ( int n ) {
  if ( n == 0 ) {
    return 0 ;
  }
  if ( n == 1 ) {
    return 1 ;
  }
  return fib ( n - 1 ) + fib ( n - 2 ) ;
}

***Example ends here:
int largePrimeFactor ( int n ) {
  for ( int i = 2 ;
  i < n ;
  i ++ ) {
    while ( n % i == 0 && n > i ) {
      n /= i ;
    }
  }
  return n ;
}

***Example ends here:
int sumToN ( int n ) {
  int result = 0 ;
  for ( int i = 1 ;
  i <= n ;
  i ++ ) {
    result += i ;
  }
  return result ;
}

***Example ends here:
int fibfib ( int n ) {
  if ( n == 0 ) {
    return 0 ;
  }
  if ( n == 1 ) {
    return 0 ;
  }
  if ( n == 2 ) {
    return 1 ;
  }
  return fibfib ( n - 1 ) + fibfib ( n - 2 ) + fibfib ( n - 3 ) ;
}

***Example ends here:
boolean isMultiplyPrime ( int a ) {
  int num = 0 ;
  for ( int i = 2 ;
  i <= a ;
  i ++ ) {
    while ( a % i == 0 && a >= i ) {
      a /= i ;
      num ++ ;
    }
  }
  return num == 3 ;
}

***Example ends here:
boolean isSimplePower ( int x , int n ) {
  if ( n == 1 ) {
    return x == 1 ;
  }
  int power = 1 ;
  while ( power < x ) {
    power *= n ;
  }
  return power == x ;
}

***Example ends here:
int chooseNum ( int x , int y ) {
  if ( x > y ) {
    return - 1 ;
  }
  if ( y % 2 == 0 ) {
    return y ;
  }
  if ( x == y ) {
    return - 1 ;
  }
  return y - 1 ;
}

***Example ends here:
boolean isEqualToSumEven ( int n ) {
  return n % 2 == 0 && n >= 8 ;
}

***Example ends here:
int specialFactorial ( int n ) {
  int fact = 1 ;
  int specialFact = 1 ;
  for ( int i = 1 ;
  i <= n ;
  i ++ ) {
    fact *= i ;
    specialFact *= fact ;
  }
  return specialFact ;
}

***Example ends here:
int xOrY ( int n , int x , int y ) {
  boolean isPrime = n >= 2 ;
  for ( int i = 2 ;
  i < n ;
  i ++ ) {
    if ( n % i == 0 ) {
      isPrime = false ;
      break ;
    }
  }
  if ( isPrime ) {
    return x ;
  }
  return y ;
}

***Example ends here:
boolean rightAngleTriangle ( double a , double b , double c ) {
  return a * a == b * b + c * c || b * b == a * a + c * c || c * c == a * a + b * b ;
}

***Example ends here:
int fastPow ( int n , int k ) {
  if ( k == 0 ) {
    return 1 ;
  }
  int temp = fastPow ( n , k / 2 ) ;
  if ( k % 2 == 0 ) {
    return temp * temp ;
  }
  else {
    return n * temp * temp ;
  }
}

***Example ends here:
boolean isPalin ( String s ) {
  int l = s . length ( ) / 2 ;
  for ( int i = 0 ;
  i < l ;
  i ++ ) {
    if ( s . charAt ( i ) != s . charAt ( s . length ( ) - i - 1 ) ) {
      return false ;
    }
  }
  return true ;
}

***Example ends here:
int findSum ( int n ) {
  int ans = 0 ;
  int temp = 0 ;
  for ( int i = 1 ;
  i <= n ;
  i ++ ) {
    if ( ! temp < n ) break ;
    temp = i - 1 ;
    int num = 1 ;
    while ( temp < n ) {
      if ( temp + i <= n ) ans += i * num ;
      else ans += ( n - temp ) * num ;
      temp += i ;
      num ++ ;
    }
  }
  return ans ;
}

***Example ends here:
int getNextGap ( int gap ) {
  gap = gap * 10 / 13 ;
  if ( gap < 1 ) {
    return 1 ;
  }
  return gap ;
}

***Example ends here:
int countNonDecreasing ( int n ) {
  int k = 10 ;
  int count = 1 ;
  for ( int i = 1 ;
  i <= n ;
  i ++ ) {
    count *= k + i - 1 ;
    count /= i ;
  }
  return count ;
}

***Example ends here:
int power ( int x , int y ) {
  if ( y == 0 ) {
    return 1 ;
  }
  else if ( y % 2 == 0 ) {
    return power ( x , y / 2 ) * power ( x , y / 2 ) ;
  }
  else {
    return x * power ( x , y / 2 ) * power ( x , y / 2 ) ;
  }
}

***Example ends here:
int power ( int x , int y ) {
  if ( y == 0 ) {
    return 1 ;
  }
  int temp = power ( x , y / 2 ) ;
  if ( y % 2 == 0 ) {
    return temp * temp ;
  }
  else {
    if ( y > 0 ) {
      return x * temp * temp ;
    }
    else {
      return temp * temp / x ;
    }
  }
}

***Example ends here:
int multiply ( int x , int y ) {
  if ( y == 0 ) {
    return 0 ;
  }
  if ( y > 0 ) {
    return x + multiply ( x , y - 1 ) ;
  }
  if ( y < 0 ) {
    return - multiply ( x , - y ) ;
  }
  return 0 ;
}

***Example ends here:
int smallest ( int x , int y , int z ) {
  if ( ! y / x ) return ( ! y / z ) ? y : z ;
  return ( ! x / z ) ? x : z ;
}

***Example ends here:
boolean isPowerOfFour ( int n ) {
  if ( n == 0 ) {
    return false ;
  }
  while ( n != 1 ) {
    if ( n % 4 != 0 ) {
      return false ;
    }
    n = n / 4 ;
  }
  return true ;
}

***Example ends here:
int modInverse ( int a , int m ) {
  int m0 = m ;
  int x0 = 0 , x1 = 1 ;
  if ( m == 1 ) {
    return 0 ;
  }
  while ( a > 1 ) {
    int q = a / m ;
    int t = m ;
    m = a % m ;
    a = t ;
    t = x0 ;
    x0 = x1 - q * x0 ;
    x1 = t ;
  }
  if ( x1 < 0 ) {
    x1 += m0 ;
  }
  return x1 ;
}

***Example ends here:
int cntRotations ( String s , int n ) {
  String s2 = s + s ;
  int [ ] pre = new int [ 2 * n ] ;
  for ( int i = 0 ;
  i < 2 * n ;
  i ++ ) {
    if ( i != 0 ) {
      pre [ i ] += pre [ i - 1 ] ;
    }
    if ( s2 . charAt ( i ) == 'a' || s2 . charAt ( i ) == 'e' || s2 . charAt ( i ) == 'i' || s2 . charAt ( i ) == 'o' || s2 . charAt ( i ) == 'u' ) {
      pre [ i ] ++ ;
    }
  }
  int ans = 0 ;
  for ( int i = n - 1 ;
  i < 2 * n - 1 ;
  i ++ ) {
    int r = i , l = i - n ;
    int x1 = pre [ r ] ;
    if ( l >= 0 ) {
      x1 -= pre [ l ] ;
    }
    r = i - n / 2 ;
    int left = pre [ r ] ;
    if ( l >= 0 ) {
      left -= pre [ l ] ;
    }
    int right = x1 - left ;
    if ( left > right ) {
      ans ++ ;
    }
  }
  return ans ;
}

***Example ends here:
int binomialCoeff ( int n , int k ) {
  int res = 1 ;
  if ( k > n - k ) {
    k = n - k ;
  }
  for ( int i = 0 ;
  i < k ;
  i ++ ) {
    res *= n - i ;
    res /= i + 1 ;
  }
  return res ;
}

***Example ends here:
boolean isPrefix ( String temp , String s ) {
  if ( temp . length ( ) < s . length ( ) ) {
    return false ;
  }
  else {
    for ( int i = 0 ;
    i < s . length ( ) ;
    i ++ ) {
      if ( ( s . charAt ( i ) != temp . charAt ( i ) ) ) {
        return false ;
      }
    }
    return true ;
  }
}

***Example ends here:
String lexicographicallySmallestString ( String s , int n ) {
  int lastEze = - 1 ;
  String ans = "" ;
  for ( int i = n - 1 ;
  i >= 0 ;
  i -- ) {
    if ( s . charAt ( i ) == '0' ) {
      lastEze = i ;
      break ;
    }
  }
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( i <= lastEze && s . charAt ( i ) == '0' ) {
      ans += s . charAt ( i ) ;
    }
    else if ( i > lastEze ) {
      ans += s . charAt ( i ) ;
    }
  }
  return ans ;
}

***Example ends here:
int calculateMax ( int n , int m , int k ) {
  int ans = - 1 ;
  int low = 0 , high = m ;
  while ( low <= high ) {
    int mid = ( low + high ) / 2 ;
    int val = 0 ;
    int l = k - 1 ;
    int r = n - k ;
    val += mid ;
    if ( mid >= l ) {
      val += l * ( 2 * mid - l - 1 ) / 2 ;
    }
    else {
      val += mid * ( mid - 1 ) / 2 + ( l - mid ) ;
    }
    if ( mid >= r ) {
      val += r * ( 2 * mid - r - 1 ) / 2 ;
    }
    else {
      val += mid * ( mid - 1 ) / 2 + ( r - mid ) ;
    }
    if ( val <= m ) {
      ans = Math . max ( ans , mid ) ;
      low = mid + 1 ;
    }
    else {
      high = mid - 1 ;
    }
  }
  return ans ;
}

***Example ends here:
int findLength ( String s , int i , int j ) {
  int required = i ;
  int length = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    char curr = s . charAt ( i ) ;
    if ( curr == required ) {
      length ++ ;
      if ( required == i ) {
        required = j ;
      }
      else {
        required = i ;
      }
    }
  }
  return length ;
}

***Example ends here:
boolean checkReverse ( int leftSum , int rightSum ) {
  int rev = 0 ;
  int temp = rightSum ;
  while ( temp != 0 ) {
    rev = rev * 10 + temp % 10 ;
    temp /= 10 ;
  }
  if ( rev == leftSum ) return true ;
  return false ;
}

***Example ends here:
boolean isComposite ( int n ) {
  if ( n <= 1 ) return false ;
  if ( n <= 3 ) return false ;
  if ( n % 2 == 0 || n % 3 == 0 ) return true ;
  for ( int i = 5 ;
  i <= n ;
  i += 6 ) {
    if ( i * i > n ) break ;
    if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ;
  }
  return false ;
}

***Example ends here:
int minDeletion ( String s ) {
  int n = s . length ( ) ;
  int firstidx1 = - 1 ;
  int lastIdx0 = - 1 ;
  for ( int i = 0 ;
  i <= n ;
  i ++ ) {
    if ( s . charAt ( i ) == '1' ) {
      firstidx1 = i ;
      break ;
    }
  }
  for ( int i = n - 1 ;
  i >= 0 ;
  i -- ) {
    if ( s . charAt ( i ) == '0' ) {
      lastIdx0 = i ;
      break ;
    }
  }
  if ( firstidx1 == - 1 || lastIdx0 == - 1 ) {
    return 0 ;
  }
  int count1 = 0 , count0 = 0 ;
  for ( int i = 0 ;
  i <= lastIdx0 ;
  i ++ ) {
    if ( s . charAt ( i ) == '1' ) {
      count1 ++ ;
    }
  }
  for ( int i = firstidx1 + 1 ;
  i < n ;
  i ++ ) {
    if ( s . charAt ( i ) == '1' ) {
      count0 ++ ;
    }
  }
  return Math . min ( count0 , count1 ) ;
}

***Example ends here:
int minSteps ( String s , int n ) {
  int cost = 0 ;
  int [ ] f = new int [ 26 ] ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    int currEle = s . charAt ( i ) - 'a' ;
    int smaller = 0 ;
    for ( int j = 0 ;
    j < currEle + 1 ;
    j ++ ) {
      if ( f [ j ] != 0 ) {
        smaller += f [ j ] ;
      }
    }
    if ( smaller == 0 ) {
      cost += i + 1 ;
    }
    else {
      cost += i - smaller + 1 ;
    }
    f [ s . charAt ( i ) - 'a' ] ++ ;
  }
  return cost ;
}

***Example ends here:
int numberOfWays ( int n ) {
  int count = 0 ;
  for ( int a = 1 ;
  a < n ;
  a ++ ) {
    for ( int b = 1 ;
    b < n ;
    b ++ ) {
      int c = n - ( a + b ) ;
      if ( a < b + c && b < a + c && c < a + b ) {
        count ++ ;
      }
    }
  }
  return count ;
}

***Example ends here:
int slopeOfNum ( int [ ] num , int n ) {
  int slope = 0 ;
  for ( int i = 1 ;
  i < n - 1 ;
  i ++ ) {
    if ( num [ i ] > num [ i - 1 ] && num [ i ] > num [ i + 1 ] ) {
      slope += 1 ;
    }
    else if ( num [ i ] < num [ i - 1 ] && num [ i ] < num [ i + 1 ] ) {
      slope += 1 ;
    }
  }
  return slope ;
}

***Example ends here:
int middleOfThree ( int a , int b , int c ) {
  int x = a - b ;
  int y = b - c ;
  int z = a - c ;
  if ( x * y > 0 ) {
    return b ;
  }
  else if ( x * z > 0 ) {
    return c ;
  }
  else {
    return a ;
  }
}

***Example ends here:
int countMaxSetBits ( int left , int right ) {
  while ( ( left = left | ( left + 1 ) ) <= right ) {
    left |= left + 1 ;
  }
  return left ;
}

***Example ends here:
int findS ( int s ) {
  int l = 1 ;
  int r = s / 2 + 1 ;
  while ( l <= r ) {
    int mid = ( l + r ) / 2 ;
    int sum = mid * ( mid + 1 ) / 2 ;
    if ( sum == s ) {
      return mid ;
    }
    else if ( sum > s ) {
      r = mid - 1 ;
    }
    else {
      l = mid + 1 ;
    }
  }
  return - 1 ;
}

***Example ends here:
boolean check ( String s ) {
  int min = Integer . MAX_VALUE ;
  int max = - Integer . MAX_VALUE ;
  int sum = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    int ascii = ( int ) s . charAt ( i ) ;
    if ( ascii < 96 || ascii > 122 ) {
      return false ;
    }
    sum += ascii ;
    if ( min > ascii ) {
      min = ascii ;
    }
    if ( max < ascii ) {
      max = ascii ;
    }
  }
  min -- ;
  int eSum = max * ( max + 1 ) / 2 - min * ( min + 1 ) / 2 ;
  return sum == eSum ;
}

***Example ends here:
int minimumPossibleProduct ( int k ) {
  int res = 1 ;
  int r = ( 1 << k ) - 1 ;
  for ( int i = 0 ;
  i < k ;
  i ++ ) {
    res *= r - 1 ;
  }
  res *= r ;
  return res ;
}

***Example ends here:
int findInGrid ( int i , int j ) {
  if ( i == j ) {
    return i * i - ( i - 1 ) ;
  }
  else if ( i > j ) {
    if ( i % 2 == 0 ) {
      return i * i - ( j - 1 ) ;
    }
    else {
      return ( i - 1 ) * ( i - 1 ) + 1 + ( j - 1 ) ;
    }
  }
  else {
    if ( j % 2 == 0 ) {
      return ( j - 1 ) * ( j - 1 ) + 1 + ( i - 1 ) ;
    }
    else {
      return j * j - ( i - 1 ) ;
    }
  }
}

***Example ends here:
int findMinOperationsReqEmpStr ( String s ) {
  int cntOne = 0 ;
  int cntZero = 0 ;
  int n = s . length ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( s . charAt ( i ) == '0' ) {
      if ( cntOne > 0 ) {
        cntOne = cntOne - 1 ;
      }
      cntZero = cntZero + 1 ;
    }
    else {
      if ( cntZero > 0 ) {
        cntZero = cntZero - 1 ;
      }
      cntOne = cntOne + 1 ;
    }
  }
  return cntOne + cntZero ;
}

***Example ends here:
boolean isReachable ( int x1 , int y1 , int x2 , int y2 ) {
  while ( x2 > x1 && y2 > y1 ) {
    if ( x2 > y2 ) {
      x2 %= y2 ;
    }
    else {
      y2 %= x2 ;
    }
  }
  if ( x2 == x1 ) {
    return y2 - y1 >= 0 && ( y2 - y1 ) % x1 == 0 ;
  }
  else if ( y2 == y1 ) {
    return x2 - x1 >= 0 && ( x2 - x1 ) % y1 == 0 ;
  }
  else {
    return false ;
  }
}

***Example ends here:
int findMaxSoln ( int n , int x , int y ) {
  int ans = - Integer . MAX_VALUE ;
  for ( int k = 0 ;
  k < n + 1 ;
  k ++ ) {
    if ( k % x == y ) {
      ans = Math . max ( ans , k ) ;
    }
  }
  return ans >= 0 && ans <= n ? ans : - 1 ;
}

***Example ends here:
int numberOfPairs ( int n ) {
  int count = 0 ;
  int i = 1 ;
  int j = n - 1 ;
  while ( i < j ) {
    if ( ( i + j ) == n ) {
      count ++ ;
    }
    i ++ ;
    j -- ;
  }
  return count ;
}

***Example ends here:
int minChanges ( String s , int n ) {
  int count = 0 , zeros = 0 , ones = 0 ;
  if ( s . charAt ( 0 ) != '1' ) {
    count += 1 ;
    ones += 1 ;
  }
  for ( int i = 1 ;
  i < n ;
  i ++ ) {
    if ( s . charAt ( i ) == '0' ) {
      zeros += 1 ;
    }
    else {
      ones += 1 ;
    }
    if ( zeros > ones ) {
      zeros -= 1 ;
      ones += 1 ;
      count += 1 ;
    }
  }
  return count ;
}

***Example ends here:
int kVisibleFromLeft ( int n , int k ) {
  if ( n == k ) {
    return 1 ;
  }
  if ( k == 1 ) {
    int ans = 1 ;
    for ( int i = 1 ;
    i < n ;
    i ++ ) {
      ans *= i ;
    }
    return ans ;
  }
  return kVisibleFromLeft ( n - 1 , k - 1 ) + ( n - 1 ) * kVisibleFromLeft ( n - 1 , k ) ;
}

***Example ends here:
double find ( int n , int sum ) {
  if ( sum > 6 * n || sum < n ) {
    return 0 ;
  }
  if ( n == 1 ) {
    if ( sum >= 1 && sum <= 6 ) {
      return 1.0 / 6 ;
    }
    else {
      return 0 ;
    }
  }
  double s = 0 ;
  for ( int i = 1 ;
  i < 7 ;
  i ++ ) {
    s += find ( n - 1 , sum - i ) / 6 ;
  }
  return s ;
}

***Example ends here:
int binCoff ( int n , int r ) {
  int val = 1 ;
  if ( r > ( n - r ) ) {
    r = n - r ;
  }
  for ( int i = 0 ;
  i < r ;
  i ++ ) {
    val *= n - i ;
    val /= i + 1 ;
  }
  return val ;
}

***Example ends here:
int getMask ( int val ) {
  int mask = 0 ;
  if ( val == 0 ) {
    return 1 ;
  }
  while ( val != 0 ) {
    int d = val % 10 ;
    mask |= ( 1 << d ) ;
    val /= 10 ;
  }
  return mask ;
}

***Example ends here:
int waysToKAdjacentSetBits ( int n , int k , int currentIndex , int adjacentSetBits , int lastBit ) {
  if ( currentIndex == n ) {
    if ( adjacentSetBits == k ) return 1 ;
    return 0 ;
  }
  int noOfWays = 0 ;
  if ( lastBit == 1 ) {
    noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ;
    noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ;
  }
  else if ( lastBit != 1 ) {
    noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) ;
    noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ;
  }
  return noOfWays ;
}

***Example ends here:
int checkMethod ( char i , char j , String st ) {
  if ( st . charAt ( i ) == '(' && st . charAt ( j ) == ')' ) return 1 ;
  if ( st . charAt ( i ) == '(' && st . charAt ( j ) == '?' ) return 1 ;
  if ( st . charAt ( i ) == ')' && st . charAt ( j ) == ')' ) return 1 ;
  if ( st . charAt ( i ) == '[' && st . charAt ( j ) == ']' ) return 1 ;
  if ( st . charAt ( i ) == '[' && st . charAt ( j ) == '?' ) return 1 ;
  if ( st . charAt ( i ) == '?' && st . charAt ( j ) == ']' ) return 1 ;
  if ( st . charAt ( i ) == '{' && st . charAt ( j ) == '}' ) return 1 ;
  if ( st . charAt ( i ) == '{' && st . charAt ( j ) == '?' ) return 1 ;
  if ( st . charAt ( i ) == '}' ) return 1 ;
  return 0 ;
}

***Example ends here:
int findGolomb ( int n ) {
  if ( n == 1 ) {
    return 1 ;
  }
  return 1 + findGolomb ( n - findGolomb ( findGolomb ( n - 1 ) ) ) ;
}

***Example ends here:
boolean allOnes ( String s , int n ) {
  int co = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    co += s . charAt ( i ) == '1' ? 1 : 0 ;
  }
  return co == n ;
}

***Example ends here:
int pad ( int n ) {
  int pPrevPrev = 1 , pPrev = 1 , pCurr = 1 , pNext = 1 ;
  for ( int i = 3 ;
  i <= n ;
  i ++ ) {
    pNext = pPrevPrev + pPrev ;
    pPrevPrev = pPrev ;
    pPrev = pCurr ;
    pCurr = pNext ;
  }
  return pNext ;
}

***Example ends here:
int oddLengthPalindrome ( int k ) {
  int palin = k ;
  k = k / 10 ;
  while ( k > 0 ) {
    int rev = k % 10 ;
    palin = palin * 10 + rev ;
    k = k / 10 ;
  }
  return palin ;
}

***Example ends here:
String changeString ( String s0 ) {
  StringBuilder sb = new StringBuilder ( s0 ) ;
  int n = s0 . length ( ) ;
  if ( sb . charAt ( 0 ) == '?' ) {
    sb . setCharAt ( 0 , 'a' ) ;
    if ( sb . charAt ( 0 ) == sb . charAt ( 1 ) ) {
      sb . setCharAt ( 0 , ( char ) ( sb . charAt ( 0 ) + 1 ) ) ;
    }
  }
  for ( int i = 1 ;
  i < n - 1 ;
  i ++ ) {
    if ( sb . charAt ( i ) == '?' ) {
      sb . setCharAt ( i , 'a' ) ;
      if ( sb . charAt ( i ) == sb . charAt ( i - 1 ) ) {
        sb . setCharAt ( i , ( char ) ( sb . charAt ( i ) + 1 ) ) ;
      }
      if ( sb . charAt ( i ) == sb . charAt ( i + 1 ) ) {
        sb . setCharAt ( i , ( char ) ( sb . charAt ( i ) + 1 ) ) ;
      }
      if ( sb . charAt ( i ) == sb . charAt ( i - 1 ) ) {
        sb . setCharAt ( i , ( char ) ( sb . charAt ( i ) + 1 ) ) ;
      }
    }
  }
  if ( sb . charAt ( n - 1 ) == '?' ) {
    sb . setCharAt ( n - 1 , 'a' ) ;
    if ( sb . charAt ( n - 1 ) == sb . charAt ( n - 2 ) ) {
      sb . setCharAt ( n - 1 , ( char ) ( sb . charAt ( n - 1 ) + 1 ) ) ;
    }
  }
  return sb . toString ( ) ;
}

***Example ends here:
int totalHammingDistance ( int n ) {
  int i = 1 , sum = 0 ;
  while ( n / i > 0 ) {
    sum = sum + n / i ;
    i = i * 2 ;
  }
  return sum ;
}

***Example ends here:
int checkBitonic ( String s ) {
  int i = 1 ;
  for ( i = 1 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( s . charAt ( i ) > s . charAt ( i - 1 ) ) continue ;
    if ( s . charAt ( i ) <= s . charAt ( i - 1 ) ) break ;
  }
  if ( i == s . length ( ) - 1 ) return 1 ;
  int j = i + 1 ;
  for ( j = i + 1 ;
  j < s . length ( ) ;
  j ++ ) {
    if ( s . charAt ( j ) < s . charAt ( j - 1 ) ) continue ;
    if ( s . charAt ( j ) >= s . charAt ( j - 1 ) ) break ;
  }
  i = j ;
  if ( i != s . length ( ) - 1 ) return 0 ;
  return 1 ;
}

***Example ends here:
boolean endWith ( String str , String pat ) {
  int patternsLen = pat . length ( ) ;
  int strLen = str . length ( ) ;
  if ( patternsLen > strLen ) {
    return false ;
  }
  patternsLen -- ;
  strLen -- ;
  while ( patternsLen >= 0 ) {
    if ( pat . charAt ( patternsLen ) != str . charAt ( strLen ) ) {
      return false ;
    }
    patternsLen -- ;
    strLen -- ;
  }
  return true ;
}

***Example ends here:
int getSum ( int n , int d ) {
  if ( n < d ) {
    return 0 ;
  }
  while ( n % 10 != d ) {
    n -- ;
  }
  int k = n / 10 ;
  return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ;
}

***Example ends here:
int balanceStringBySwapping ( String s ) {
  int unbalancedPair = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( unbalancedPair > 0 && s . charAt ( i ) == ']' ) {
      unbalancedPair -- ;
    }
    else if ( s . charAt ( i ) == '[' ) {
      unbalancedPair ++ ;
    }
  }
  return ( unbalancedPair + 1 ) / 2 ;
}

***Example ends here:
int computeHash ( String s ) {
  int p = 31 ;
  int mod = 10 * 9 + 7 ;
  int hashVal = 0 ;
  int mul = 1 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    char ch = s . charAt ( i ) ;
    hashVal = ( hashVal + ( ch - 'a' + 1 ) * mul ) % mod ;
    mul = mul * p % mod ;
  }
  return hashVal ;
}

***Example ends here:
int countOfSubstringWithOnlyOnes ( String s ) {
  int res = 0 , count = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    count = s . charAt ( i ) == '1' ? count + 1 : 0 ;
    res = res + count ;
  }
  return res ;
}

***Example ends here:
int composite ( int n ) {
  int flag = 0 ;
  int c = 0 ;
  for ( int j = 1 ;
  j <= n ;
  j ++ ) {
    if ( n % j == 0 ) {
      c ++ ;
    }
  }
  if ( c >= 3 ) {
    flag = 1 ;
  }
  return flag ;
}

***Example ends here:
boolean isDivByStrings ( String s , int n ) {
  int sum = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    sum += s . charAt ( i ) - 'a' + 1 ;
  }
  if ( sum % 3 != 0 ) {
    return false ;
  }
  int lastDigit = ( s . charAt ( n - 1 ) - 'a' + 1 ) % 10 ;
  if ( lastDigit % 2 != 0 ) {
    return false ;
  }
  return true ;
}

***Example ends here:
boolean isRedundantBraces ( String s ) {
  int a = 0 , b = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( s . charAt ( i ) == '(' && s . charAt ( i + 2 ) == ')' ) {
      return true ;
    }
    if ( s . charAt ( i ) == '*' || s . charAt ( i ) == '+' || s . charAt ( i ) == '-' || s . charAt ( i ) == '/' ) {
      a ++ ;
    }
    if ( s . charAt ( i ) == '(' ) {
      b ++ ;
    }
  }
  if ( b > a ) {
    return true ;
  }
  return false ;
}

***Example ends here:
int countSubStr ( String s , int n ) {
  int count = 0 ;
  int i = 0 ;
  while ( i < ( n - 2 ) ) {
    if ( s . charAt ( i ) == '0' && s . charAt ( i + 1 ) == '1' && s . charAt ( i + 2 ) == '0' ) {
      count ++ ;
      i += 3 ;
    }
    else if ( s . charAt ( i ) == '1' && s . charAt ( i + 1 ) == '0' && s . charAt ( i + 2 ) == '1' ) {
      count ++ ;
      i += 3 ;
    }
    else {
      i += 1 ;
    }
  }
  return count ;
}

***Example ends here:
int prefixOccurrences ( String s ) {
  char c = s . charAt ( 0 ) ;
  int countC = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( s . charAt ( i ) == c ) {
      countC ++ ;
    }
  }
  return countC ;
}

***Example ends here:
boolean isValid ( String s , int len ) {
  for ( int i = 1 ;
  i < len ;
  i ++ ) {
    if ( s . charAt ( i ) == s . charAt ( i - 1 ) ) {
      return false ;
    }
  }
  return true ;
}

***Example ends here:
int count ( String s , int k ) {
  int n = s . length ( ) ;
  int d = 0 ;
  int count = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    d += s . charAt ( i ) ;
  }
  if ( d % k == 0 ) {
    count ++ ;
  }
  for ( int i = k ;
  i < n ;
  i ++ ) {
    int prev = s . charAt ( i - k ) ;
    d -= prev ;
    d += s . charAt ( i ) ;
    if ( d % k == 0 ) {
      count ++ ;
    }
  }
  return count ;
}

***Example ends here:
int findSubstringCount ( String s ) {
  int result = 0 ;
  int n = s . length ( ) ;
  int i = 0 ;
  while ( i < n - 1 ) {
    if ( ( int ) s . charAt ( i ) + 1 == ( int ) s . charAt ( i + 1 ) ) {
      result ++ ;
      while ( i < n - 1 && ( int ) s . charAt ( i ) + 1 == ( int ) s . charAt ( i + 1 ) ) {
        i ++ ;
      }
    }
    i ++ ;
  }
  return result ;
}

***Example ends here:
boolean indexOf ( String s1 , String s2 ) {
  int len1 = s1 . length ( ) ;
  int len2 = s2 . length ( ) ;
  if ( len1 != len2 ) {
    return false ;
  }
  int [ ] d = new int [ len1 ] ;
  d [ 0 ] = ( int ) s2 . charAt ( 0 ) - ( int ) s1 . charAt ( 0 ) ;
  for ( int i = 1 ;
  i < len1 ;
  i ++ ) {
    if ( s1 . charAt ( i ) > s2 . charAt ( i ) ) {
      return false ;
    }
    else {
      d [ i ] = ( int ) s2 . charAt ( i ) - s1 . charAt ( i ) ;
    }
  }
  for ( int i = 0 ;
  i < len1 - 1 ;
  i ++ ) {
    if ( d [ i ] < d [ i + 1 ] ) {
      return false ;
    }
  }
  return true ;
}

***Example ends here:
boolean isInGivenBase ( String s , int bas ) {
  if ( bas > 16 ) {
    return false ;
  }
  else if ( bas <= 10 ) {
    for ( int i = 0 ;
    i < s . length ( ) ;
    i ++ ) {
      if ( ! ( ( char ) s . charAt ( i ) >= '0' && ( char ) s . charAt ( i ) < '0' + bas ) ) {
        return false ;
      }
    }
  }
  else {
    for ( int i = 0 ;
    i < s . length ( ) ;
    i ++ ) {
      if ( ! ( ( char ) s . charAt ( i ) >= '0' && ( char ) s . charAt ( i ) < '0' + bas ) || ( ( char ) s . charAt ( i ) >= 'A' && ( char ) s . charAt ( i ) < ( 'A' + bas - 10 ) ) ) ) {
        return false ;
      }
    }
  }
  return true ;
}

***Example ends here:
int countNonEmptySubstring ( String s ) {
  int n = s . length ( ) ;
  return n * ( n + 1 ) / 2 ;
}

***Example ends here:
int evenDecimalValue ( String s , int n ) {
  int result = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    for ( int j = i ;
    j < n ;
    j ++ ) {
      int decimalValue = 0 ;
      int powerOf2 = 1 ;
      for ( int k = i ;
      k <= j ;
      k ++ ) {
        decimalValue += ( s . charAt ( k ) - '0' ) * powerOf2 ;
        powerOf2 *= 2 ;
      }
      if ( decimalValue % 2 == 0 ) {
        result ++ ;
      }
    }
  }
  return result ;
}

***Example ends here:
int calculate ( String s ) {
  int ans = 6 ;
  for ( int i = 0 ;
  i < 10 ;
  i ++ ) {
    for ( int j = 0 ;
    j < 10 ;
    j ++ ) {
      for ( int k = 0 ;
      k < 10 ;
      k ++ ) {
        for ( int l = 0 ;
        l < 10 ;
        l ++ ) {
          for ( int m = 0 ;
          m < 10 ;
          m ++ ) {
            for ( int n = 0 ;
            n < 10 ;
            n ++ ) {
              if ( i + j + k == l + m + n ) {
                int c = 0 ;
                if ( i != ( int ) s . charAt ( 0 ) - '0' ) {
                  c ++ ;
                }
                if ( j != ( int ) s . charAt ( 1 ) - '0' ) {
                  c ++ ;
                }
                if ( k != ( int ) s . charAt ( 2 ) - '0' ) {
                  c ++ ;
                }
                if ( l != ( int ) s . charAt ( 3 ) - '0' ) {
                  c ++ ;
                }
                if ( m != ( int ) s . charAt ( 4 ) - '0' ) {
                  c ++ ;
                }
                if ( n != ( int ) s . charAt ( 5 ) - '0' ) {
                  c ++ ;
                }
                if ( c < ans ) {
                  ans = c ;
                }
              }
            }
          }
        }
      }
    }
  }
  return ans ;
}

***Example ends here:
int xorZero ( String s ) {
  int oneCount = 0 ;
  int zeroCount = 0 ;
  int n = s . length ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( s . charAt ( i ) == '1' ) {
      oneCount ++ ;
    }
    else {
      zeroCount ++ ;
    }
  }
  if ( oneCount % 2 == 0 ) {
    return zeroCount ;
  }
  return oneCount ;
}

***Example ends here:
String evenLength ( String n ) {
  String res = n ;
  for ( int j = n . length ( ) - 1 ;
  j >= 0 ;
  j -- ) {
    res += n . charAt ( j ) ;
  }
  return res ;
}

***Example ends here:
int countSubstringWithEqualEnds ( String s ) {
  int result = 0 ;
  int n = s . length ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    for ( int j = i ;
    j < n ;
    j ++ ) {
      if ( s . charAt ( i ) == s . charAt ( j ) ) {
        result = result + 1 ;
      }
    }
  }
  return result ;
}

***Example ends here:
double normalSlope ( double a , double b , double x1 , double y1 ) {
  double g = a / 2 ;
  double f = b / 2 ;
  if ( g - x1 == 0 ) {
    return - 1 ;
  }
  double slope = ( f - y1 ) / ( g - x1 ) ;
  if ( slope == 0 ) {
    return - 2 ;
  }
  return slope ;
}

***Example ends here:
boolean orthogonality ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) {
  int dsquare = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ;
  if ( dsquare == r1 * r1 + r2 * r2 ) return true ;
  else return false ;
}

***Example ends here:
double findAreaShaded ( double a ) {
  double sq_area = a * a ;
  double semiCircleArea = ( 3.14 * ( a * a ) / 8 ) ;
  double shadedArea = 4 * semiCircleArea - sq_area ;
  return shadedArea ;
}

***Example ends here:
int factorial ( int a , int b ) {
  int res = 1 ;
  for ( int i = 1 ;
  i <= a ;
  i ++ ) {
    res = res * i ;
  }
  for ( int i = 1 ;
  i <= a ;
  i ++ ) {
    res = res / i ;
  }
  for ( int i = 1 ;
  i <= b ;
  i ++ ) {
    res = res / i ;
  }
  return res ;
}

***Example ends here:
int factorTree ( int n ) {
  int height = 0 ;
  while ( n > 1 ) {
    boolean flag = false ;
    for ( int i = 2 ;
    i <= ( int ) Math . sqrt ( n ) ;
    i ++ ) {
      if ( n % i == 0 ) {
        n = n / i ;
        flag = true ;
        break ;
      }
    }
    height ++ ;
    if ( ! flag ) break ;
  }
  return height ;
}

***Example ends here:
String findIfPossible ( int n , int s , int x ) {
  if ( s >= x && s % 2 == x % 2 ) {
    if ( n >= 3 ) {
      return "Yes" ;
    }
    if ( n == 1 ) {
      if ( s == x ) {
        return "Yes" ;
      }
      else {
        return "No" ;
      }
    }
    if ( n == 2 ) {
      int c = ( s - x ) / 2 ;
      int a = c ;
      int b = c ;
      a = a + x ;
      if ( ( a ^ b ) == x ) {
        return "Yes" ;
      }
      else {
        return "No" ;
      }
    }
  }
  else {
    return "No" ;
  }
}

***Example ends here:
int maximumTripletXor ( int a , int b , int c ) {
  int ans = 0 ;
  for ( int i = 30 ;
  i >= 0 ;
  i -- ) {
    int cur = 1 << i ;
    if ( a >= cur ) {
      ans += cur ;
      a -= cur ;
    }
    else if ( b >= cur ) {
      ans += cur ;
      b -= cur ;
    }
    else if ( c >= cur ) {
      ans += cur ;
      c -= cur ;
    }
  }
  return ans ;
}

***Example ends here:
int itemType ( int n ) {
  int count = 0 ;
  int day = 1 ;
  while ( count + day * ( day + 1 ) / 2 < n ) {
    count += day * ( day + 1 ) / 2 ;
    day ++ ;
  }
  for ( int type = day ;
  -- type >= 0 ;
  ) {
    count += type ;
    if ( count >= n ) {
      return type ;
    }
  }
  return 0 ;
}

***Example ends here:
int maxGCdInRange ( int l , int r ) {
  int ans = 1 ;
  for ( int z = r ;
  z > 0 ;
  z -- ) {
    if ( r / z - ( l - 1 ) / z > 1 ) {
      ans = z ;
      break ;
    }
  }
  return ans ;
}

***Example ends here:
int sumOfDigits ( int n ) {
  int sum = 0 ;
  while ( n != 0 ) {
    sum += ( n % 10 ) ;
    n = n / 10 ;
  }
  return sum ;
}

***Example ends here:
boolean isRepUnitNum ( int n , int b ) {
  int length = 0 ;
  int countOne = 0 ;
  while ( ( n != 0 ) ) {
    int r = n % b ;
    length ++ ;
    if ( r == 1 ) {
      countOne ++ ;
    }
    n = n / b ;
  }
  return countOne >= 3 && countOne == length ;
}

***Example ends here:
boolean isStraighLineNum ( int n ) {
  if ( ( n <= 99 ) ) {
    return false ;
  }
  String s = String . valueOf ( n ) ;
  int d = ( int ) s . charAt ( 1 ) - ( int ) s . charAt ( 0 ) ;
  for ( int i = 2 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( ( int ) s . charAt ( i ) - ( int ) s . charAt ( i - 1 ) != d ) {
      return false ;
    }
  }
  return true ;
}

***Example ends here:
int getCount ( int d , int n ) {
  int no = n / d ;
  int result = no ;
  for ( int p = 2 ;
  p <= no ;
  p ++ ) {
    if ( p * p > no ) break ;
    if ( no % p == 0 ) {
      while ( no % p == 0 ) {
        no /= p ;
      }
      result -= result / p ;
    }
  }
  if ( no > 1 ) {
    result -= result / no ;
  }
  return result ;
}

***Example ends here:
boolean isEvenParity ( int x ) {
  int parity = 0 ;
  while ( x != 0 ) {
    if ( ( x & 1 ) != 0 ) {
      parity ++ ;
    }
    x = x >>> 1 ;
  }
  if ( parity % 2 == 0 ) {
    return true ;
  }
  else {
    return false ;
  }
}

***Example ends here:
int isperfect ( int n ) {
  int sum = 1 ;
  for ( int i = 2 ;
  i <= n ;
  i ++ ) {
    if ( i * i > n ) break ;
    if ( n % i == 0 ) {
      if ( i * i != n ) sum = sum + i + n / i ;
      else sum = sum + i ;
    }
  }
  if ( sum == n && n != 1 ) return n ;
  return 0 ;
}

***Example ends here:
int logAToBaseB ( int a , int b ) {
  return a > ( b - 1 ) ? 1 + logAToBaseB ( a / b , b ) : 0 ;
}

***Example ends here:
int usingBinarySearch ( int start , int end , int n , int s ) {
  if ( start >= end ) return start ;
  int mid = start + ( end - start ) / 2 ;
  int totalSum = ( n * ( n + 1 ) ) / 2 ;
  int midSum = ( mid * ( mid + 1 ) ) / 2 ;
  if ( totalSum - midSum <= s ) return usingBinarySearch ( start , mid , n , s ) ;
  return usingBinarySearch ( mid + 1 , end , n , s ) ;
}

***Example ends here:
String minInt ( String s ) {
  StringBuilder s1 = new StringBuilder ( s ) ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( s1 . charAt ( i ) >= '5' ) {
      s1 . setCharAt ( i , ( char ) ( '9' - s1 . charAt ( i ) + '0' ) ) ;
    }
  }
  if ( s1 . charAt ( 0 ) == '0' ) {
    s1 . setCharAt ( 0 , '9' ) ;
  }
  return s1 . toString ( ) ;
}

***Example ends here:
int countTriplets ( int a , int b , int c ) {
  int ans = 0 ;
  for ( int i = 1 ;
  i <= a ;
  i ++ ) {
    for ( int j = 1 ;
    j <= b ;
    j ++ ) {
      for ( int k = 1 ;
      k <= c ;
      k ++ ) {
        if ( i * k > j * j ) {
          ans ++ ;
        }
      }
    }
  }
  return ans ;
}

***Example ends here:
boolean topsyTurvy ( String s ) {
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( s . charAt ( i ) == '2' || s . charAt ( i ) == '4' || s . charAt ( i ) == '5' || s . charAt ( i ) == '6' || s . charAt ( i ) == '7' || s . charAt ( i ) == '9' ) {
      return false ;
    }
  }
  return true ;
}

***Example ends here:
int sumOfLastDig ( int n , int m ) {
  int sum = 0 ;
  int k = n / m ;
  int [ ] arr = new int [ 10 ] ;
  for ( int i = 0 ;
  i < 10 ;
  i ++ ) {
    arr [ i ] = m * ( i + 1 ) % 10 ;
    sum += arr [ i ] ;
  }
  int rem = k % 10 ;
  int ans = k / 10 * sum ;
  for ( int i = 0 ;
  i < rem ;
  i ++ ) ans += arr [ i ] ;
  return ans ;
}

***Example ends here:
int totalPay ( int totalItems , int priceOfOneItem , int n , int m ) {
  int freeItems = 0 ;
  int actual = 0 ;
  freeItems = totalItems / ( n + m ) ;
  actual = totalItems - freeItems ;
  int amount = actual * priceOfOneItem ;
  return amount ;
}

***Example ends here:
int minOperations ( int x , int y , int p , int q ) {
  if ( y % x != 0 ) return - 1 ;
  int d = y / x ;
  int a = 0 ;
  while ( d % p == 0 ) {
    d /= p ;
    a ++ ;
  }
  int b = 0 ;
  while ( d % q == 0 ) {
    d /= q ;
    b ++ ;
  }
  if ( d != 1 ) return - 1 ;
  return a + b ;
}

***Example ends here:
boolean isMersenne ( int n ) {
  while ( n != 0 ) {
    int r = n % 2 ;
    if ( r == 0 ) {
      return false ;
    }
    n /= 2 ;
  }
  return true ;
}

***Example ends here:
int findThirdDigit ( int n ) {
  if ( n < 3 ) {
    return 0 ;
  }
  return ( n & 1 ) != 0 ? 1 : 6 ;
}

***Example ends here:
boolean isOddLength ( int num ) {
  int count = 0 ;
  while ( num > 0 ) {
    num = num / 10 ;
    count ++ ;
  }
  if ( count % 2 != 0 ) {
    return true ;
  }
  return false ;
}

***Example ends here:
boolean checkIsPossible ( int l , int r , int k ) {
  int count = 0 ;
  for ( int i = l ;
  i <= r ;
  i ++ ) {
    if ( i % k == 0 ) {
      count ++ ;
    }
  }
  return count > 1 ;
}

***Example ends here:
int bytes ( int kilobytes ) {
  int b = kilobytes * 1024 ;
  return b ;
}

***Example ends here:
int octahedralNum ( int n ) {
  return n * ( 2 * n * n + 1 ) / 3 ;
}

***Example ends here:
String checkEqual ( String s ) {
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( s . charAt ( i ) != '1' && s . charAt ( i ) != '0' && s . charAt ( i ) != '8' ) {
      return "No" ;
    }
  }
  int start = 0 ;
  int end = s . length ( ) - 1 ;
  while ( start < end ) {
    if ( s . charAt ( start ) != s . charAt ( end ) ) {
      return "No" ;
    }
    start ++ ;
    end -- ;
  }
  return "Yes" ;
}

***Example ends here:
boolean isAbundulating ( int [ ] n ) {
  if ( n . length <= 2 ) {
    return false ;
  }
  for ( int i = 2 ;
  i < n . length ;
  i ++ ) {
    if ( n [ i - 2 ] != n [ i ] ) {
      return false ;
    }
  }
  return true ;
}

***Example ends here:
int firstDigit ( int n ) {
  while ( n >= 10 ) {
    n /= 10 ;
  }
  return n ;
}

***Example ends here:
int countDigit ( int n ) {
  if ( n == 0 ) {
    return 0 ;
  }
  return 1 + countDigit ( n / 10 ) ;
}

***Example ends here:
boolean isDivisibleBy5 ( String s ) {
  int n = s . length ( ) ;
  return s . charAt ( n - 1 ) == '0' || s . charAt ( n - 1 ) == '5' ;
}

***Example ends here:
int inv ( int a , int m ) {
  int m0 = m ;
  int x0 = 0 , x1 = 1 ;
  if ( m == 1 ) {
    return 0 ;
  }
  while ( a > 1 ) {
    int q = a / m ;
    int t = m ;
    m = a % m ;
    a = t ;
    t = x0 ;
    x0 = x1 - q * x0 ;
    x1 = t ;
  }
  if ( x1 < 0 ) {
    x1 = x1 + m0 ;
  }
  return x1 ;
}

***Example ends here:
boolean onlyFirstAndLastAreSet ( int n ) {
  if ( n == 1 ) return true ;
  if ( n == 2 ) return false ;
  return ( ( n - 1 ) & ( n - 2 ) ) == 0 ;
}

***Example ends here:
int divide ( int dividend , int divisor ) {
  int sign = ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? - 1 : 1 ;
  dividend = Math . abs ( dividend ) ;
  divisor = Math . abs ( divisor ) ;
  int quotient = 0 ;
  int temp = 0 ;
  for ( int i = 31 ;
  i >= 0 ;
  i -- ) {
    if ( temp + ( divisor << i ) <= dividend ) {
      temp += divisor << i ;
      quotient |= 1 << i ;
    }
  }
  if ( sign == - 1 ) {
    quotient = - quotient ;
  }
  return quotient ;
}

***Example ends here:
char findProfession ( int level , int pos ) {
  if ( level == 1 ) return 'e' ;
  if ( findProfession ( level - 1 , ( pos + 1 ) / 2 ) == 'd' ) return pos % 2 != 0 ? 'd' : 'e' ;
  return pos % 2 != 0 ? 'e' : 'd' ;
}

***Example ends here:
boolean hasCloseElements ( int [ ] numbers , int threshold ) {
  for ( int i = 0 ;
  i < numbers . length ;
  i ++ ) {
    for ( int j = i + 1 ;
    j < numbers . length ;
    j ++ ) {
      int distance = Math . abs ( numbers [ i ] - numbers [ j ] ) ;
      if ( distance < threshold ) {
        return true ;
      }
    }
  }
  return false ;
}

***Example ends here:
int truncateNumber ( int number ) {
  return number % 1 ;
}

***Example ends here:
boolean belowZero ( int [ ] operations ) {
  int balance = 0 ;
  for ( int op : operations ) {
    balance += op ;
    if ( balance < 0 ) {
      return true ;
    }
  }
  return false ;
}

***Example ends here:
double meanAbsoluteDeviation ( double [ ] numbers ) {
  double sumNum = 0 ;
  for ( double num : numbers ) {
    sumNum += num ;
  }
  double mean = sumNum / numbers . length ;
  double sumAbsDiff = 0 ;
  for ( double num : numbers ) {
    sumAbsDiff += Math . abs ( num - mean ) ;
  }
  return sumAbsDiff / numbers . length ;
}

***Example ends here:
String intersperse ( String [ ] numbers , String delimiter ) {
  StringBuilder result = new StringBuilder ( ) ;
  if ( numbers == null ) return result . toString ( ) ;
  for ( int i = 0 ;
  i < numbers . length - 1 ;
  i ++ ) {
    result . append ( numbers [ i ] ) ;
    result . append ( delimiter ) ;
  }
  result . append ( numbers [ numbers . length - 1 ] ) ;
  return result . toString ( ) ;
}

***Example ends here:
double [ ] sumProduct ( double [ ] numbers ) {
  double sumValue = 0 ;
  double prodValue = 1 ;
  for ( double n : numbers ) {
    sumValue += n ;
    prodValue *= n ;
  }
  return new double [ ] {
    sumValue , prodValue }
    ;
  }
  
***Example ends here:
String [ ] allPrefixes ( String string ) {
  String [ ] result = new String [ string . length ( ) ] ;
  for ( int i = 1 ;
  i <= string . length ( ) ;
  i ++ ) {
    result [ i ] = string . substring ( 0 , i ) ;
  }
  return result ;
}

***Example ends here:
int parseMusic ( String musicString ) {
  StringBuilder current = new StringBuilder ( ) ;
  StringBuilder result = new StringBuilder ( ) ;
  for ( int i = 0 ;
  i <= musicString . length ( ) ;
  i ++ ) {
    if ( i == musicString . length ( ) || musicString . charAt ( i ) == ' ' ) {
      if ( current . toString ( ) . equals ( "o" ) ) {
        result . append ( 4 ) ;
      }
      if ( current . toString ( ) . equals ( "o|" ) ) {
        result . append ( 2 ) ;
      }
      if ( current . toString ( ) . equals ( ".|" ) ) {
        result . append ( 1 ) ;
      }
      current . clear ( ) ;
    }
    else {
      current . append ( musicString . charAt ( i ) ) ;
    }
  }
  return result . toString ( ) ;
}

***Example ends here:
int strlen ( String s ) {
  return s . length ( ) ;
}

***Example ends here:
int [ ] factorize ( int n ) {
  int [ ] factors = new int [ n ] ;
  int i = 2 ;
  while ( i <= n ) {
    if ( n % i == 0 ) {
      factors [ i ] = i ;
      n /= i ;
    }
    else {
      i ++ ;
    }
  }
  return factors ;
}

***Example ends here:
String concatenate ( String [ ] strings ) {
  StringBuilder result = new StringBuilder ( ) ;
  for ( String s : strings ) {
    result . append ( s ) ;
  }
  return result . toString ( ) ;
}

***Example ends here:
int [ ] getPositive ( int [ ] l ) {
  int [ ] result = new int [ l . length ] ;
  for ( int i = 0 ;
  i < l . length ;
  i ++ ) {
    if ( l [ i ] > 0 ) {
      result [ i ] = l [ i ] ;
    }
  }
  return result ;
}

***Example ends here:
int [ ] sortEven ( int [ ] l ) {
  int [ ] evens = new int [ l . length ] ;
  for ( int i = 0 ;
  i < l . length ;
  i += 2 ) evens [ i ] = l [ i ] ;
  Arrays . sort ( evens ) ;
  int [ ] result = new int [ l . length ] ;
  for ( int i = 0 ;
  i < l . length ;
  i ++ ) {
    if ( i % 2 == 0 ) result [ i ] = evens [ i / 2 ] ;
    if ( i % 2 == 1 ) result [ i ] = l [ i ] ;
  }
  return result ;
}

***Example ends here:
String decodeCyclic ( String s ) {
  StringBuilder output = new StringBuilder ( ) ;
  int i = 0 ;
  while ( i <= s . length ( ) - 3 ) {
    String x = s . substring ( i + 2 ) + s . substring ( i , i + 2 ) ;
    output . append ( x ) ;
    i += 3 ;
  }
  return output . toString ( ) + s . substring ( i ) ;
}

***Example ends here:
double carRackCollision ( double n ) {
  return n * n ;
}

***Example ends here:
int [ ] incrList ( int [ ] l ) {
  int [ ] result = new int [ l . length ] ;
  for ( int i = 0 ;
  i < l . length ;
  i ++ ) {
    result [ i ] = l [ i ] + 1 ;
  }
  return result ;
}

***Example ends here:
boolean pairsSumToZero ( int [ ] l ) {
  for ( int i = 0 ;
  i < l . length ;
  i ++ ) {
    for ( int j = i + 1 ;
    j < l . length ;
    j ++ ) {
      if ( l [ i ] + l [ j ] == 0 ) {
        return true ;
      }
    }
  }
  return false ;
}

***Example ends here:
String changeBase ( int x , int b ) {
  StringBuilder ret = new StringBuilder ( ) ;
  while ( x > 0 ) {
    ret . insert ( 0 , String . valueOf ( x % b ) ) ;
    x /= b ;
  }
  return ret . toString ( ) ;
}

***Example ends here:
double median ( double [ ] l ) {
  Arrays . sort ( l ) ;
  if ( l . length % 2 == 1 ) {
    return l [ l . length / 2 ] ;
  }
  else {
    return ( l [ l . length / 2 - 1 ] + l [ l . length / 2 ] ) / 2.0 ;
  }
}

***Example ends here:
String decodeShift ( @ NonNull String s ) {
  StringBuilder result = new StringBuilder ( ) ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    char ch = s . charAt ( i ) ;
    int w = ( ( int ) ch + 21 - 'a' ) % 26 + 'a' ;
    result . append ( ( char ) w ) ;
  }
  return result . toString ( ) ;
}

***Example ends here:
boolean belowThreshold ( double [ ] l , double t ) {
  for ( double n : l ) {
    if ( n >= t ) {
      return false ;
    }
  }
  return true ;
}

***Example ends here:
boolean correctBracketing ( String brackets ) {
  int depth = 0 ;
  for ( char b : brackets . toCharArray ( ) ) {
    if ( b == '<' ) depth ++ ;
    else depth -- ;
    if ( depth < 0 ) return false ;
  }
  return depth == 0 ;
}

***Example ends here:
boolean monotonic ( int [ ] l ) {
  int incr = 0 ;
  int decr = 0 ;
  for ( int i = 1 ;
  i < l . length ;
  i ++ ) {
    if ( l [ i ] > l [ i - 1 ] ) {
      incr = 1 ;
    }
    if ( l [ i ] < l [ i - 1 ] ) {
      decr = 1 ;
    }
  }
  return incr + decr != 2 ;
}

***Example ends here:
double [ ] derivative ( double [ ] xs ) {
  double [ ] result = new double [ xs . length ] ;
  for ( int i = 1 ;
  i < xs . length ;
  i ++ ) {
    result [ i ] = i * xs [ i ] ;
  }
  return result ;
}

***Example ends here:
int vowelsCount ( String s ) {
  String vowels = "aeiouAEIOU" ;
  int count = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    char ch = s . charAt ( i ) ;
    if ( vowels . indexOf ( ch ) != - 1 ) count ++ ;
  }
  if ( s . charAt ( s . length ( ) - 1 ) == 'y' || s . charAt ( s . length ( ) - 1 ) == 'Y' ) count ++ ;
  return count ;
}

***Example ends here:
int digSum ( String s ) {
  int sum = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    char c = s . charAt ( i ) ;
    if ( Character . isUpperCase ( c ) ) {
      sum += c ;
    }
  }
  return sum ;
}

***Example ends here:
int fruitDistribution ( String s , int n ) {
  StringBuilder num1 = new StringBuilder ( ) ;
  StringBuilder num2 = new StringBuilder ( ) ;
  boolean flag = false ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( Character . isDigit ( s . charAt ( i ) ) ) {
      if ( ! flag ) num1 . append ( s . charAt ( i ) ) ;
      if ( flag ) num2 . append ( s . charAt ( i ) ) ;
    }
    else if ( ! flag && num1 . length ( ) > 0 ) flag = true ;
  }
  return n - Integer . parseInt ( num1 . toString ( ) ) - Integer . parseInt ( num2 . toString ( ) ) ;
}

***Example ends here:
int [ ] pluck ( int [ ] arr ) {
  int [ ] result = new int [ arr . length ] ;
  for ( int i = 0 ;
  i < arr . length ;
  i ++ ) {
    if ( arr [ i ] % 2 == 0 ) {
      if ( result [ 0 ] == 0 ) {
        result [ 0 ] = arr [ i ] ;
        result [ 1 ] = i ;
      }
      else if ( arr [ i ] < result [ 0 ] ) {
        result [ 0 ] = arr [ i ] ;
        result [ 1 ] = i ;
      }
    }
  }
  return result ;
}

***Example ends here:
int [ ] strangeSortList ( int [ ] list ) {
  int [ ] res = new int [ list . length ] ;
  Arrays . sort ( list ) ;
  int l = 0 ;
  int r = list . length - 1 ;
  while ( l < r ) {
    res [ l ] = list [ l ] ;
    l ++ ;
    res [ r ] = list [ r ] ;
    r -- ;
  }
  if ( l == r ) {
    res [ l ] = list [ l ] ;
  }
  return res ;
}

***Example ends here:
double triangleArea ( double a , double b , double c ) {
  if ( a + b <= c || a + c <= b || b + c <= a ) {
    return - 1.0 ;
  }
  double s = ( a + b + c ) / 2 ;
  double area = Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ;
  return area ;
}

***Example ends here:
boolean wildcardItFly ( int [ ] q , int w ) {
  int sum = 0 ;
  for ( int i = 0 ;
  i < q . length ;
  i ++ ) {
    if ( q [ i ] != q [ q . length - i - 1 ] ) {
      return false ;
    }
    sum += q [ i ] ;
  }
  return sum <= w ;
}

***Example ends here:
boolean isCube ( double a ) {
  a = Math . abs ( a ) ;
  long i = Math . round ( a * ( 1.0 / 3 ) ) ;
  return i * i == a ;
}

***Example ends here:
int hexKey ( String num ) {
  String key = "2357BD" ;
  int total = 0 ;
  for ( char c : num . toCharArray ( ) ) {
    if ( key . indexOf ( c ) != - 1 ) {
      total ++ ;
    }
  }
  return total ;
}

***Example ends here:
String decimalToBinary ( int dec ) {
  StringBuilder ans = new StringBuilder ( ) ;
  if ( dec != 0 ) {
    while ( dec > 0 ) {
      ans . insert ( 0 , String . valueOf ( dec % 2 ) ) ;
      dec /= 2 ;
    }
  }
  else {
    ans . append ( "0" ) ;
  }
  return "db" + ans . toString ( ) + "db" ;
}

***Example ends here:
boolean primeLength ( String s ) {
  int l = s . length ( ) ;
  if ( l < 2 ) {
    return false ;
  }
  for ( int i = 2 ;
  i < l ;
  i ++ ) {
    if ( l % i == 0 ) {
      return false ;
    }
  }
  return true ;
}

***Example ends here:
int startsOneEnds ( int n ) {
  if ( n < 1 ) return 0 ;
  if ( n == 1 ) return 1 ;
  return 18 * ( 10 * ( n - 2 ) ) ;
}

***Example ends here:
int add ( int [ ] list ) {
  int sum = 0 ;
  for ( int i = 1 ;
  i < list . length ;
  i += 2 ) {
    if ( list [ i ] % 2 == 0 ) {
      sum += list [ i ] ;
    }
  }
  return sum ;
}

***Example ends here:
int [ ] getRow ( int [ ] [ ] list , int x ) {
  int [ ] coords = new int [ list . length ] ;
  for ( int i = 0 ;
  i < list . length ;
  i ++ ) {
    for ( int j = list [ i ] . length - 1 ;
    j >= 0 ;
    j -- ) {
      if ( list [ i ] [ j ] == x ) {
        coords [ i ] = j ;
      }
    }
  }
  return coords ;
}

***Example ends here:
int nextSmallest ( int [ ] list ) {
  Arrays . sort ( list ) ;
  for ( int i = 1 ;
  i < list . length ;
  i ++ ) {
    if ( list [ i ] != list [ i - 1 ] ) {
      return list [ i ] ;
    }
  }
  return - 1 ;
}

***Example ends here:
boolean anyInt ( double a , double b , double c ) {
  if ( Math . round ( a ) != a || Math . round ( b ) != b || Math . round ( c ) != c ) {
    return false ;
  }
  return a + b == c || a + c == b || b + c == a ;
}

***Example ends here:
int [ ] countUpTo ( int n ) {
  int [ ] primes = new int [ n ] ;
  for ( int i = 2 ;
  i < n ;
  i ++ ) {
    boolean isPrime = true ;
    for ( int j = 2 ;
    j < i ;
    j ++ ) {
      if ( i % j == 0 ) {
        isPrime = false ;
        break ;
      }
    }
    if ( isPrime ) {
      primes [ i ] = i ;
    }
  }
  return primes ;
}

***Example ends here:
int closestInteger ( String value ) {
  double w = Double . parseDouble ( value ) ;
  return Math . round ( w ) ;
}

***Example ends here:
int [ ] makeAPile ( int n ) {
  int [ ] result = new int [ n ] ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    result [ i ] = n + 2 * i ;
  }
  return result ;
}

***Example ends here:
String [ ] wordString ( String s ) {
  List < String > current = new ArrayList < String > ( ) ;
  List < String > words = new ArrayList < String > ( ) ;
  for ( int i = 0 ;
  i <= s . length ( ) ;
  i ++ ) {
    if ( i == s . length ( ) || s . charAt ( i ) == ' ' || s . charAt ( i ) == ',' ) {
      if ( current . size ( ) > 0 ) {
        words . add ( current . toString ( ) ) ;
        current . clear ( ) ;
      }
    }
    else {
      current . add ( s . charAt ( i ) ) ;
    }
  }
  return words . toArray ( new String [ 0 ] ) ;
}

***Example ends here:
String roundedAvg ( int n , int m ) {
  if ( n > m ) return - 1 ;
  int num = ( n + m ) / 2 ;
  StringBuilder ret = new StringBuilder ( ) ;
  while ( num > 0 ) {
    ret . insert ( 0 , String . valueOf ( num % 2 ) ) ;
    num /= 2 ;
  }
  return ret . toString ( ) ;
}

***Example ends here:
String uniqueDigits ( String [ ] input ) {
  StringBuilder digits = new StringBuilder ( ) ;
  for ( String n : input ) {
    boolean isUnique = true ;
    for ( char c : String . valueOf ( n ) . toCharArray ( ) ) {
      if ( ( int ) c % 2 == 0 ) {
        isUnique = false ;
        break ;
      }
    }
    if ( isUnique ) {
      digits . append ( n ) ;
    }
  }
  Collections . sort ( digits ) ;
  return digits . toString ( ) ;
}

***Example ends here:
int countNums ( int [ ] arr ) {
  int num = 0 ;
  for ( int n : arr ) {
    int neg = n < 0 ? - 1 : 1 ;
    n = Math . abs ( n ) ;
    int [ ] digits = new int [ n ] ;
    for ( char c : String . valueOf ( n ) . toCharArray ( ) ) {
      digits [ 0 ] = ( int ) c - '0' ;
    }
    digits [ 0 ] *= neg ;
    int sum = 0 ;
    for ( int d : digits ) {
      sum += d ;
    }
    if ( sum > 0 ) {
      num ++ ;
    }
  }
  return num ;
}

***Example ends here:
boolean moveOneBall ( int [ ] arr ) {
  if ( arr == null ) return true ;
  int num = 0 ;
  for ( int i = 1 ;
  i < arr . length ;
  i ++ ) if ( arr [ i ] < arr [ i - 1 ] ) num ++ ;
  if ( arr [ arr . length - 1 ] > arr [ 0 ] ) num ++ ;
  if ( num < 2 ) return true ;
  return false ;
}

***Example ends here:
String exchange ( List < Integer > lst1 , List < Integer > lst2 ) {
  int odd = 0 ;
  int even = 0 ;
  for ( Integer n : lst1 ) {
    if ( n % 2 == 1 ) {
      odd ++ ;
    }
  }
  for ( Integer n : lst2 ) {
    if ( n % 2 == 0 ) {
      even ++ ;
    }
  }
  if ( even >= odd ) {
    return "YES" ;
  }
  return "NO" ;
}

***Example ends here:
String [ ] oddCount ( String [ ] list ) {
  String [ ] results = new String [ list . length ] ;
  String originalStr = "the number of odd elements in the string i of the input." ;
  for ( String s : list ) {
    int sum = 0 ;
    for ( char d : s . toCharArray ( ) ) {
      if ( Character . isDigit ( d ) && ( int ) d % 2 == 1 ) {
        sum ++ ;
      }
    }
    StringBuilder result = new StringBuilder ( ) ;
    for ( char c : originalStr . toCharArray ( ) ) {
      if ( c == 'i' ) {
        result . append ( String . valueOf ( sum ) ) ;
      }
      else {
        result . append ( c ) ;
      }
    }
    results [ result . length - 1 ] = result . toString ( ) ;
  }
  return results ;
}

***Example ends here:
int minSubArraySum ( int [ ] nums ) {
  int minSum = Integer . MAX_VALUE ;
  int sum = 0 ;
  for ( int num : nums ) {
    sum += num ;
    if ( minSum > sum ) {
      minSum = sum ;
    }
    if ( sum > 0 ) {
      sum = 0 ;
    }
  }
  return minSum ;
}

***Example ends here:
int maxFill ( int [ ] [ ] grid , int capacity ) {
  int res = 0 ;
  for ( int [ ] well : grid ) {
    int sum = 0 ;
    for ( int n : well ) {
      sum += n ;
    }
    if ( sum > 0 ) {
      res += ( sum - 1 ) / capacity + 1 ;
    }
  }
  return res ;
}

***Example ends here:
String selectWords ( String s , int n ) {
  String vowels = "aeiouAEIOU" ;
  StringBuilder current = new StringBuilder ( ) ;
  StringBuilder result = new StringBuilder ( ) ;
  int consonantNum = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) + 1 ;
  i ++ ) {
    if ( i == s . length ( ) || s . charAt ( i ) == ' ' ) {
      if ( consonantNum == n ) {
        result . append ( current . toString ( ) ) ;
      }
      current . clear ( ) ;
      consonantNum = 0 ;
    }
    else {
      current . append ( s . charAt ( i ) ) ;
      if ( ! vowels . contains ( s . charAt ( i ) ) ) {
        consonantNum ++ ;
      }
    }
  }
  return result . toString ( ) ;
}

***Example ends here:
int solution ( int [ ] list ) {
  int sum = 0 ;
  for ( int i = 0 ;
  i < list . length ;
  i += 2 ) {
    if ( list [ i ] % 2 == 1 ) {
      sum += list [ i ] ;
    }
  }
  return sum ;
}

***Example ends here:
int addElements ( int [ ] arr , int k ) {
  int sum = 0 ;
  for ( int i = 0 ;
  i < k ;
  i ++ ) {
    if ( - 99 <= arr [ i ] && arr [ i ] <= 99 ) {
      sum += arr [ i ] ;
    }
  }
  return sum ;
}

***Example ends here:
List < Integer > getOddCollatz ( int n ) {
  List < Integer > oddCollatz = new ArrayList < > ( ) ;
  while ( n > 1 ) {
    if ( n % 2 == 1 ) {
      oddCollatz . add ( n ) ;
      n = n * 3 + 1 ;
    }
    else {
      n /= 2 ;
    }
  }
  oddCollatz . add ( 1 ) ;
  Collections . sort ( oddCollatz ) ;
  return oddCollatz ;
}

***Example ends here:
boolean isSorted ( int [ ] list ) {
  for ( int i = 1 ;
  i < list . length ;
  i ++ ) {
    if ( list [ i ] < list [ i - 1 ] ) {
      return false ;
    }
    if ( i >= 2 && list [ i ] == list [ i - 1 ] && list [ i ] == list [ i - 2 ] ) {
      return false ;
    }
  }
  return true ;
}

***Example ends here:
String intersection ( int [ ] interval1 , int [ ] interval2 ) {
  int inter1 = Math . max ( interval1 [ 0 ] , interval2 [ 0 ] ) ;
  int inter2 = Math . min ( interval1 [ 1 ] , interval2 [ 1 ] ) ;
  int l = inter2 - inter1 ;
  if ( l < 2 ) {
    return "NO" ;
  }
  for ( int i = 2 ;
  i < l ;
  i ++ ) {
    if ( l % i == 0 ) {
      return "NO" ;
    }
  }
  return "YES" ;
}

***Example ends here:
int prodSigns ( int [ ] arr ) {
  if ( arr == null ) return - 32768 ;
  int sum = 0 ;
  int prods = 1 ;
  for ( int i = 0 ;
  i < arr . length ;
  i ++ ) {
    sum += Math . abs ( arr [ i ] ) ;
    if ( i == 0 ) {
      prods = 0 ;
    }
    if ( i < 0 ) {
      prods = - prods ;
    }
  }
  return sum * prods ;
}

***Example ends here:
int [ ] minPath ( int [ ] [ ] grid , int k ) {
  int n = grid . length ;
  int minNum = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    for ( int j = 0 ;
    j < n ;
    j ++ ) {
      if ( grid [ i ] [ j ] == 1 ) {
        int [ ] tmp = new int [ n ] ;
        if ( i != 0 ) {
          tmp [ i ] = grid [ i - 1 ] [ j ] ;
        }
        if ( j != 0 ) {
          tmp [ i ] = grid [ i ] [ j - 1 ] ;
        }
        if ( i != n - 1 ) {
          tmp [ i ] = grid [ i + 1 ] [ j ] ;
        }
        if ( j != n - 1 ) {
          tmp [ i ] = grid [ i ] [ j + 1 ] ;
        }
        minNum = Math . min ( tmp [ i ] , tmp [ j ] ) ;
      }
    }
  }
  int [ ] ans = new int [ k ] ;
  for ( int i = 0 ;
  i < k ;
  i ++ ) {
    if ( i % 2 == 0 ) {
      ans [ i ] = 1 ;
    }
    else {
      ans [ i ] = minNum ;
    }
  }
  return ans ;
}

***Example ends here:
int digits ( int n ) {
  int prod = 1 ;
  for ( char digit : String . valueOf ( n ) . toCharArray ( ) ) {
    if ( ( digit % 2 ) == 1 ) {
      if ( prod == 0 ) {
        prod = 1 ;
      }
      prod *= digit - '0' ;
    }
  }
  return prod ;
}

***Example ends here:
boolean isNested ( String s ) {
  int count = 0 ;
  int maxCount = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    char ch = s . charAt ( i ) ;
    if ( ch == '[' ) count ++ ;
    if ( ch == ']' ) count -- ;
    if ( count < 0 ) count = 0 ;
    if ( count > maxCount ) maxCount = count ;
    if ( count <= maxCount - 2 ) return true ;
  }
  return false ;
}

***Example ends here:
double sumSquares ( double [ ] list ) {
  double sum = 0 ;
  for ( double i : list ) {
    sum += Math . ceil ( i ) * Math . ceil ( i ) ;
  }
  return sum ;
}

***Example ends here:
int canRearrange ( int [ ] arr ) {
  int index = - 1 ;
  for ( int i = 0 ;
  i < arr . length ;
  i ++ ) {
    if ( arr [ i ] <= i ) {
      index = i ;
    }
  }
  return index ;
}

***Example ends here:
int [ ] largeSmallIntegers ( int [ ] list ) {
  int maxNeg = 0 , minPos = 0 ;
  for ( int n : list ) {
    if ( n < 0 && ( maxNeg == 0 || n > maxNeg ) ) {
      maxNeg = n ;
    }
    if ( n > 0 && ( minPos == 0 || n < minPos ) ) {
      minPos = n ;
    }
  }
  return new int [ ] {
    maxNeg , minPos }
    ;
  }
  
***Example ends here:
String fixSpaces ( String text ) {
  StringBuilder sb = new StringBuilder ( ) ;
  int spaceLen = 0 ;
  for ( int i = 0 ;
  i <= text . length ( ) ;
  i ++ ) {
    if ( i == text . length ( ) || text . charAt ( i ) != ' ' ) {
      if ( spaceLen == 1 ) {
        sb . append ( '_' ) ;
      }
      if ( spaceLen == 2 ) {
        sb . append ( '__' ) ;
      }
      if ( spaceLen > 2 ) {
        sb . append ( '-' ) ;
      }
      spaceLen = 0 ;
      if ( i != text . length ( ) ) {
        sb . append ( text . charAt ( i ) ) ;
      }
    }
    else {
      spaceLen ++ ;
    }
  }
  return sb . toString ( ) ;
}

***Example ends here:
String fileNameCheck ( String fileName ) {
  int digNum = 0 , dotNum = 0 ;
  if ( fileName . length ( ) < 5 || ! Character . isLetter ( fileName . charAt ( 0 ) ) ) {
    return "No" ;
  }
  String suffix = fileName . substring ( fileName . length ( ) - 4 ) ;
  if ( suffix . compareTo ( ".txt" ) != 0 && suffix . compareTo ( ".exe" ) != 0 && suffix . compareTo ( ".dll" ) != 0 ) {
    return "No" ;
  }
  for ( int i = 0 ;
  i < fileName . length ( ) ;
  i ++ ) {
    char c = fileName . charAt ( i ) ;
    if ( Character . isDigit ( c ) ) {
      digNum ++ ;
    }
    if ( c == '.' ) {
      dotNum ++ ;
    }
  }
  if ( digNum > 3 || dotNum != 1 ) {
    return "No" ;
  }
  return "Yes" ;
}

***Example ends here:
int sumSquares ( int [ ] list ) {
  int sum = 0 ;
  for ( int i = 0 ;
  i < list . length ;
  i ++ ) {
    if ( i % 3 == 0 ) {
      sum += list [ i ] * list [ i ] ;
    }
    else if ( i % 4 == 0 ) {
      sum += list [ i ] * list [ i ] * list [ i ] ;
    }
    else {
      sum += list [ i ] ;
    }
  }
  return sum ;
}

***Example ends here:
String wordsInSentence ( String sentence ) {
  StringBuilder result = new StringBuilder ( ) ;
  StringBuilder current = new StringBuilder ( ) ;
  for ( int i = 0 ;
  i <= sentence . length ( ) ;
  i ++ ) {
    if ( i == sentence . length ( ) || sentence . charAt ( i ) == ' ' ) {
      boolean isPrime = true ;
      int l = current . length ( ) ;
      if ( l < 2 ) {
        isPrime = false ;
      }
      for ( int j = 2 ;
      j < l ;
      j ++ ) {
        if ( l % j == 0 ) {
          isPrime = false ;
          break ;
        }
      }
      if ( isPrime ) {
        result . append ( current . toString ( ) + " " ) ;
      }
      current . clear ( ) ;
    }
    else {
      current . append ( sentence . charAt ( i ) ) ;
    }
  }
  result = result . toString ( ) ;
  if ( result . length ( ) > 0 ) {
    result = result . substring ( 0 , result . length ( ) - 1 ) ;
  }
  return result . toString ( ) ;
}

***Example ends here:
boolean simplify ( String str , String n ) {
  int a = 0 , b = 0 , c = 0 , d = 0 ;
  for ( int i = 0 ;
  i < str . length ( ) ;
  i ++ ) {
    if ( str . charAt ( i ) == '/' ) {
      a = Integer . parseInt ( str . substring ( 0 , i ) ) ;
      b = Integer . parseInt ( str . substring ( i + 1 ) ) ;
    }
  }
  for ( int i = 0 ;
  i < n . length ( ) ;
  i ++ ) {
    if ( n . charAt ( i ) == '/' ) {
      c = Integer . parseInt ( n . substring ( 0 , i ) ) ;
      d = Integer . parseInt ( n . substring ( i + 1 ) ) ;
    }
  }
  return ( a * c ) % ( b * d ) == 0 ;
}

***Example ends here:
int specialFilter ( int [ ] nums ) {
  int count = 0 ;
  for ( int num : nums ) {
    if ( num > 10 ) {
      String w = String . valueOf ( num ) ;
      if ( ( int ) w . charAt ( 0 ) % 2 == 1 && ( int ) w . charAt ( w . length ( ) - 1 ) % 2 == 1 ) count ++ ;
    }
  }
  return count ;
}

***Example ends here:
int getMaxTriples ( int n ) {
  int [ ] arr = new int [ n ] ;
  for ( int i = 1 ;
  i <= n ;
  i ++ ) {
    arr [ i ] = i * i - i + 1 ;
  }
  int count = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    for ( int j = i + 1 ;
    j < n ;
    j ++ ) {
      for ( int k = j + 1 ;
      k < n ;
      k ++ ) {
        if ( ( arr [ i ] + arr [ j ] + arr [ k ] ) % 3 == 0 ) {
          count ++ ;
        }
      }
    }
  }
  return count ;
}

***Example ends here:
double doubleTheDifference ( double [ ] list ) {
  double sum = 0 ;
  for ( double d : list ) {
    double num = Math . round ( d ) ;
    if ( d == num ) {
      if ( num > 0 && num % 2 == 1 ) {
        sum += num * num ;
      }
    }
  }
  return sum ;
}

***Example ends here:
int [ ] compare ( int [ ] game , int [ ] guess ) {
  int [ ] result = new int [ game . length ] ;
  for ( int i = 0 ;
  i < game . length ;
  i ++ ) {
    result [ i ] = Math . abs ( game [ i ] - guess [ i ] ) ;
  }
  return result ;
}

***Example ends here:
String strongestExtension ( String className , String [ ] extensions ) {
  String strongest = "" ;
  int max = - Integer . MAX_VALUE ;
  for ( String extension : extensions ) {
    int strength = 0 ;
    for ( char chr : extension . toCharArray ( ) ) {
      if ( Character . isUpperCase ( chr ) ) {
        strength ++ ;
      }
      if ( Character . isLowerCase ( chr ) ) {
        strength -- ;
      }
    }
    if ( strength > max ) {
      max = strength ;
      strongest = extension ;
    }
  }
  return className + "." + strongest ;
}

***Example ends here:
String intToLowestRoman ( int number ) {
  int [ ] num = {
    1000 , 900 , 500 , 400 , 100 , 90 , 50 , 40 , 10 , 9 , 5 , 4 , 1 }
    ;
    String [ ] sym = {
      "m" , "cm" , "d" , "cd" , "c" , "xc" , "l" , "xl" , "x" , "ix" , "v" , "iv" , "i" }
      ;
      int pos = 0 ;
      StringBuilder sb = new StringBuilder ( ) ;
      while ( number > 0 ) {
        while ( number >= num [ pos ] ) {
          sb . append ( sym [ pos ] ) ;
          number -= num [ pos ] ;
        }
        if ( number > 0 ) {
          pos ++ ;
        }
      }
      return sb . toString ( ) ;
    }
    
***Example ends here:
int [ ] eat ( int number , int need , int remaining ) {
  return need > remaining ? new int [ ] {
    number + remaining , 0 }
    : new int [ ] {
      number + need , remaining - need }
      ;
    }
    
***Example ends here:
double doAlgebra ( String [ ] ops , String [ ] operands ) {
  double [ ] nums = Arrays . copyOf ( operands , operands . length ) ;
  String [ ] currentOps = Arrays . copyOf ( ops , ops . length ) ;
  int i = currentOps . length - 1 ;
  while ( i >= 0 ) {
    if ( currentOps [ i ] . equals ( "**" ) ) {
      nums [ i ] = Math . pow ( nums [ i ] , nums [ i + 1 ] ) ;
      nums [ i + 1 ] = 0 ;
      currentOps [ i ] = 0 ;
    }
    i -- ;
  }
  i = 0 ;
  while ( i < currentOps . length ) {
    if ( currentOps [ i ] . equals ( "*" ) ) {
      nums [ i ] *= nums [ i + 1 ] ;
      nums [ i + 1 ] = 0 ;
      currentOps [ i ] = 0 ;
    }
    else if ( currentOps [ i ] . equals ( "//" ) ) {
      nums [ i ] /= nums [ i + 1 ] ;
      nums [ i + 1 ] = 0 ;
      currentOps [ i ] = 0 ;
    }
    else {
      i ++ ;
    }
  }
  i = 0 ;
  while ( i < currentOps . length ) {
    if ( currentOps [ i ] . equals ( "+" ) ) {
      nums [ i ] += nums [ i + 1 ] ;
      nums [ i + 1 ] = 0 ;
      currentOps [ i ] = 0 ;
    }
    else if ( currentOps [ i ] . equals ( "-" ) ) {
      nums [ i ] -= nums [ i + 1 ] ;
      nums [ i + 1 ] = 0 ;
      currentOps [ i ] = 0 ;
    }
    else {
      i ++ ;
    }
  }
  return nums [ 0 ] ;
}

***Example ends here:
int [ ] generateIntegers ( int a , int b ) {
  int lower = Math . max ( 2 , Math . min ( a , b ) ) ;
  int upper = Math . min ( 8 , Math . max ( a , b ) ) ;
  int [ ] result = new int [ upper ] ;
  for ( int i = lower ;
  i <= upper ;
  i += 2 ) {
    result [ i ] = i ;
  }
  return result ;
}

***Example ends here:
boolean isStepNum ( int n ) {
  int prevDigit = - 1 ;
  while ( n > 0 ) {
    int curDigit = n % 10 ;
    if ( prevDigit == - 1 ) {
      prevDigit = curDigit ;
    }
    else {
      if ( Math . abs ( prevDigit - curDigit ) != 1 ) {
        return false ;
      }
    }
    prevDigit = curDigit ;
    n /= 10 ;
  }
  return true ;
}

***Example ends here:
int numOfWays ( int n , int k ) {
  int p = 1 ;
  if ( k % 2 != 0 ) p = - 1 ;
  return ( ( n - 1 ) * k + p * ( n - 1 ) ) / n ;
}

***Example ends here:
int [ ] findDivisors ( int n ) {
  int [ ] v = new int [ n ] ;
  for ( int i = 1 ;
  i <= ( int ) Math . sqrt ( n ) ;
  i ++ ) {
    if ( n % i == 0 ) {
      if ( n / i == i ) {
        v [ i ] = i ;
      }
      else {
        v [ i ] = i ;
        v [ i ] = n / i ;
      }
    }
  }
  return v ;
}

***Example ends here:
int jarDrop ( int n , int k ) {
  if ( k == 1 || k == 0 ) {
    return k ;
  }
  if ( n == 1 ) {
    return k ;
  }
  int min = Integer . MAX_VALUE ;
  for ( int x = 1 ;
  x <= k ;
  x ++ ) {
    int res = Math . max ( jarDrop ( n - 1 , x - 1 ) , jarDrop ( n , k - x ) ) ;
    if ( res < min ) {
      min = res ;
    }
  }
  return min + 1 ;
}

***Example ends here:
boolean isPowerOfTwo ( int n ) {
  return Math . ceil ( Math . log2 ( n ) ) == Math . floor ( Math . log2 ( n ) ) ;
}

***Example ends here:
String shortestPalindrome ( String s ) {
  int n = s . length ( ) ;
  String [ ] v = new String [ n ] ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    int l = i ;
    int r = i ;
    String ans1 = "" ;
    String ans2 = "" ;
    while ( l >= 0 && r < n && s . charAt ( l ) == s . charAt ( r ) ) {
      ans1 += s . charAt ( l ) ;
      l -- ;
      r ++ ;
    }
    l = i - 1 ;
    r = i ;
    while ( l >= 0 && r < n && s . charAt ( l ) == s . charAt ( r ) ) {
      ans2 += s . charAt ( l ) ;
      l -- ;
      r ++ ;
    }
    v [ i ] = ans1 ;
    v [ i ] = ans2 ;
  }
  String ans = v [ 0 ] ;
  for ( int i = 0 ;
  i < v . length ;
  i ++ ) {
    if ( v [ i ] != "" ) {
      ans = Math . min ( ans , v [ i ] ) ;
    }
  }
  return ans ;
}

***Example ends here:
int minimumAdjacentDifference ( int [ ] a , int n , int k ) {
  int minDiff = Integer . MAX_VALUE ;
  for ( int i = 0 ;
  i < k + 1 ;
  i ++ ) {
    int maxDiff = - Integer . MAX_VALUE ;
    for ( int j = 0 ;
    j < n - k - 1 ;
    j ++ ) {
      for ( int p = i ;
      p <= i + j + 1 ;
      p ++ ) {
        maxDiff = Math . max ( maxDiff , a [ p + 1 ] - a [ p ] ) ;
      }
    }
    minDiff = Math . min ( minDiff , maxDiff ) ;
  }
  return minDiff ;
}

***Example ends here:
int cal ( int [ ] a , int mid ) {
  int chocolate = 0 ;
  for ( int i = 0 ;
  i < a . length ;
  i ++ ) if ( a [ i ] >= mid ) chocolate += a [ i ] - mid ;
  return chocolate ;
}

***Example ends here:
boolean check ( int v , int [ ] a , int m ) {
  int tec = 0 ;
  int ans = 0 ;
  int [ ] b = new int [ a . length + 3 ] ;
  for ( int i = 0 ;
  i < a . length ;
  i ++ ) {
    tec -= b [ i ] ;
    if ( a [ i ] + tec < v ) {
      int mov = v - a [ i ] - tec ;
      ans = ans + mov ;
      tec += mov ;
      b [ i + 2 ] = mov ;
    }
  }
  return ans <= m ;
}

***Example ends here:
int largeNum ( int [ ] arr ) {
  int res = 0 ;
  Arrays . sort ( arr ) ;
  int l = 0 , r = arr . length - 1 ;
  while ( l < r ) {
    int sum = arr [ l ] + arr [ r ] ;
    if ( sum == 0 ) {
      res = Math . max ( res , Math . max ( arr [ l ] , arr [ r ] ) ) ;
      return res ;
    }
    else if ( sum < 0 ) {
      l ++ ;
    }
    else {
      r -- ;
    }
  }
  return res ;
}

***Example ends here:
int binarySearch ( int [ ] p , int n ) {
  int i = 0 ;
  int j = p . length - 1 ;
  int index = - 1 ;
  while ( i <= j ) {
    int mid = i + ( j - i ) / 2 ;
    if ( p [ mid ] >= n ) {
      index = mid ;
      j = mid - 1 ;
    }
    else {
      i = mid + 1 ;
    }
  }
  return index ;
}

***Example ends here:
int findMinLength ( int [ ] arr ) {
  int index = arr . length - 1 ;
  while ( index > 0 && arr [ index ] >= arr [ index - 1 ] ) {
    index -- ;
  }
  return index ;
}

***Example ends here:
int minDigits ( int n , int k ) {
  int digitNum = Math . floor ( Math . log10 ( n ) + 1 ) ;
  int tempSum = 0 ;
  int temp = digitNum ;
  int result = 0 ;
  int x , v ;
  int sum = 0 ;
  int num2 = n ;
  while ( num2 != 0 ) {
    sum += num2 % 10 ;
    num2 /= 10 ;
  }
  if ( sum <= k ) {
    x = 0 ;
  }
  else {
    while ( temp > 0 ) {
      v = n / ( 10 * ( temp - 1 ) ) ;
      tempSum += v % 10 ;
      if ( tempSum >= k ) {
        v /= 10 ;
        v += 1 ;
        result = v * ( 10 * temp ) ;
        break ;
      }
      temp -- ;
    }
    x = result - n ;
    return x ;
  }
  return - 1 ;
}

***Example ends here:
int checkForPerfectSquare ( int [ ] arr , int i , int j ) {
  int mid = 0 , sum = 0 ;
  for ( int m = i ;
  m <= j ;
  m ++ ) {
    sum += arr [ m ] ;
  }
  int low = 0 , high = sum / 2 ;
  while ( low <= high ) {
    mid = low + ( high - low ) / 2 ;
    if ( mid * mid == sum ) {
      return mid ;
    }
    else if ( mid * mid > sum ) {
      high = mid - 1 ;
    }
    else {
      low = mid + 1 ;
    }
  }
  return - 1 ;
}

***Example ends here:
int minFlips ( char [ ] [ ] mat , String s ) {
  int n = mat . length ;
  int m = mat [ 0 ] . length ;
  int count = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    for ( int j = 0 ;
    j < m ;
    j ++ ) {
      if ( mat [ i ] [ j ] != ( char ) s . charAt ( i + j ) - '0' ) count ++ ;
    }
  }
  return count ;
}

***Example ends here:
int [ ] [ ] constructTree ( int n , int [ ] [ ] edges ) {
  int [ ] [ ] adjl = new int [ n ] [ ] ;
  for ( int i = 0 ;
  i < edges . length ;
  i ++ ) {
    adjl [ i ] = new int [ ] ;
  }
  for ( int [ ] e : edges ) {
    int u = e [ 0 ] ;
    int v = e [ 1 ] ;
    adjl [ u ] [ v ] = v ;
    adjl [ v ] [ u ] = v ;
  }
  return adjl ;
}

***Example ends here:
int findSumOfValues ( int v , int [ ] parent , int [ ] valuesChildren ) {
  int curNode = v ;
  int Sum = 0 ;
  while ( curNode != - 1 ) {
    Sum += valuesChildren [ curNode ] ;
    curNode = parent [ curNode ] ;
  }
  return Sum ;
}

***Example ends here:
int getDistinct ( int d , int count ) {
  int num = 0 ;
  count = 10 * ( count - 1 ) ;
  while ( count > 0 ) {
    num += count * d ;
    count /= 10 ;
  }
  return num ;
}

***Example ends here:
boolean isIncreasing ( int [ ] arr ) {
  for ( int i = 0 ;
  i < arr . length - 1 ;
  i ++ ) {
    if ( arr [ i ] > arr [ i + 1 ] ) {
      return false ;
    }
  }
  return true ;
}

***Example ends here:
int minAdjSwaps ( int [ ] [ ] mat ) {
  int n = mat . length ;
  int [ ] cnZero = new int [ n ] ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    for ( int j = n - 1 ;
    j >= 0 ;
    j -- ) {
      if ( mat [ i ] [ j ] != 0 ) {
        break ;
      }
      cnZero [ i ] ++ ;
    }
  }
  int cnswaps = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( cnZero [ i ] < ( n - i - 1 ) ) {
      int first = i ;
      while ( first < n && cnZero [ first ] < ( n - i - 1 ) ) {
        first ++ ;
      }
      if ( first == n ) {
        return - 1 ;
      }
      while ( first > i ) {
        cnZero [ first ] = cnZero [ first - 1 ] ;
        cnZero [ first - 1 ] = cnZero [ first ] ;
        first -- ;
        cnswaps ++ ;
      }
    }
  }
  return cnswaps ;
}

***Example ends here:
int solve ( List < Integer > values , List < Integer > salary , int mod ) {
  int ret = 1 ;
  int amt = 0 ;
  Collections . sort ( values ) ;
  Collections . sort ( salary ) ;
  while ( salary . size ( ) > 0 ) {
    while ( values . size ( ) > 0 && values . get ( values . size ( ) - 1 ) >= salary . get ( values . size ( ) - 1 ) ) {
      amt ++ ;
      values . remove ( values . size ( ) - 1 ) ;
    }
    if ( amt == 0 ) {
      return 0 ;
    }
    ret *= amt ;
    amt -- ;
    ret %= mod ;
    salary . remove ( salary . size ( ) - 1 ) ;
  }
  return ret ;
}

***Example ends here:
int [ ] organizeInOrder ( int [ ] vec , char [ ] op , int n ) {
  int [ ] result = new int [ n ] ;
  Arrays . sort ( vec ) ;
  int i = 0 , j = n - 1 , k = 0 ;
  while ( i <= j && k <= n - 2 ) {
    if ( op [ k ] == '<' ) {
      result [ k ] = vec [ i ] ;
      i ++ ;
    }
    else {
      result [ k ] = vec [ j ] ;
      j -- ;
    }
    k ++ ;
  }
  result [ n - 1 ] = vec [ i ] ;
  return result ;
}

***Example ends here:
int countPoints ( int n , int m , int [ ] a , int [ ] b , int x , int y ) {
  Arrays . sort ( a ) ;
  Arrays . sort ( b ) ;
  int j = 0 ;
  int count = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    while ( j < m ) {
      if ( a [ i ] + y < b [ j ] ) break ;
      if ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) {
        count ++ ;
        j ++ ;
        break ;
      }
      else {
        j ++ ;
      }
    }
  }
  return count ;
}

***Example ends here:
boolean areSame ( int [ ] a , int [ ] b ) {
  Arrays . sort ( a ) ;
  Arrays . sort ( b ) ;
  return a == b ;
}

***Example ends here:
int countNumberOfStrings ( String s ) {
  int n = s . length ( ) - 1 ;
  int count = 2 * n ;
  return count ;
}

***Example ends here:
ArrayList primePower ( int x ) {
  ArrayList primePow = new ArrayList ( ) ;
  for ( int i = 2 ;
  i <= x ;
  i ++ ) {
    if ( i * i > x + 1 ) break ;
    if ( x % i == 0 ) {
      int p = 1 ;
      while ( x % i == 0 ) {
        x /= i ;
        p *= i ;
      }
      primePow . add ( p ) ;
    }
  }
  if ( x > 1 ) {
    primePow . add ( x ) ;
  }
  return primePow ;
}

***Example ends here:
int isperfect ( double n0 ) {
  double n = Math . sqrt ( n0 ) ;
  if ( Math . floor ( n ) != Math . ceil ( n ) ) {
    return 0 ;
  }
  return 1 ;
}

***Example ends here:
int findSum ( int l , int r ) {
  int [ ] arr = new int [ r ] ;
  int i = 0 ;
  int x = 2 ;
  while ( i <= r ) {
    arr [ i ] = i + x ;
    if ( i + 1 <= r ) {
      arr [ i + 1 ] = i + x ;
    }
    x *= - 1 ;
    i += 2 ;
  }
  int sum = 0 ;
  for ( i = l ;
  i <= r ;
  i ++ ) {
    sum += arr [ i ] ;
  }
  return sum ;
}

***Example ends here:
double results ( double n , double k ) {
  return Math . round ( n * ( 1.0 / 2 * k ) ) ;
}

***Example ends here:
int [ ] factors ( int n ) {
  int [ ] v = new int [ 2 ] ;
  v [ 0 ] = 1 ;
  for ( int i = 2 ;
  i <= ( int ) Math . sqrt ( n ) ;
  i += 1 ) {
    if ( n % i == 0 ) {
      v [ i ] = i ;
      if ( n / i != i ) {
        v [ i ] = n / i ;
      }
    }
  }
  return v ;
}

***Example ends here:
double smallestNum ( double n ) {
  double x = 10.0 * ( ( n - 1 ) / 2.0 ) ;
  return Math . ceil ( x ) ;
}

***Example ends here:
int smallest ( String s ) {
  int [ ] a = new int [ s . length ( ) ] ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    a [ i ] = s . charAt ( i ) - '0' ;
  }
  List < Integer > b = new ArrayList < > ( ) ;
  for ( int i = 0 ;
  i < a . length ;
  i ++ ) {
    if ( a [ i ] % 2 != 0 ) {
      b . add ( a [ i ] ) ;
    }
  }
  Collections . sort ( b ) ;
  if ( b . size ( ) > 1 ) {
    return b . get ( 0 ) * 10 + b . get ( 1 ) ;
  }
  return - 1 ;
}

***Example ends here:
double [ ] diagonals ( double a , double b , double c , double d ) {
  double [ ] ans = new double [ 2 ] ;
  ans [ 0 ] = Math . sqrt ( ( a * c + b * d ) * ( a * d + b * c ) / ( a * b + c * d ) ) ;
  ans [ 1 ] = Math . sqrt ( ( a * c + b * d ) * ( a * b + c * d ) / ( a * d + b * c ) ) ;
  return ans ;
}

***Example ends here:
double findNumberOfDigits ( double n , double base ) {
  double dig = Math . floor ( Math . log ( n ) / Math . log ( base ) ) + 1 ;
  return dig ;
}

***Example ends here:
double ngon ( int n ) {
  double proAngleVar = 0 ;
  if ( n % 4 == 0 ) proAngleVar = Math . PI * ( 180.0 / n ) / 180 ;
  else proAngleVar = Math . PI * ( 180.0 / ( 2 * n ) ) / 180 ;
  double negX = 1.0e+99 ;
  double posX = - 1.0e+99 ;
  double negY = 1.0e+99 ;
  double posY = - 1.0e+99 ;
  for ( int j = 0 ;
  j < n ;
  j ++ ) {
    double px = Math . cos ( 2 * Math . PI * j / n + proAngleVar ) ;
    double py = Math . sin ( 2 * Math . PI * j / n + proAngleVar ) ;
    negX = Math . min ( negX , px ) ;
    posX = Math . max ( posX , px ) ;
    negY = Math . min ( negY , py ) ;
    posY = Math . max ( posY , py ) ;
  }
  double opt2 = Math . max ( posX - negX , posY - negY ) ;
  return opt2 / Math . sin ( Math . PI / n ) / 2 ;
}

***Example ends here:
int findMaxK ( int n ) {
  int p = ( int ) Math . log2 ( n ) ;
  return 2 * p ;
}

***Example ends here:
int nthFibo ( int n ) {
  double a = ( 5 * 0.5 + 1 ) / 2 ;
  double b = ( - 5 * 0.5 + 1 ) / 2 ;
  double r = 5 * 0.5 ;
  double ans = ( a * n - b * n ) / r ;
  return ( int ) ans ;
}

***Example ends here:
double findProb ( double l , double r ) {
  double countOfPS = Math . floor ( Math . sqrt ( r ) ) - Math . ceil ( Math . sqrt ( l ) ) + 1 ;
  double total = r - l + 1 ;
  double prob = countOfPS / total ;
  return prob ;
}

***Example ends here:
double previousFibonacci ( double n ) {
  double a = n / ( ( 1 + Math . sqrt ( 5 ) ) / 2.0 ) ;
  return Math . round ( a ) ;
}

***Example ends here:
int distPrime ( int [ ] arr , int [ ] allPrimes ) {
  List < Integer > list1 = new ArrayList < > ( ) ;
  for ( int i : allPrimes ) {
    for ( int j : arr ) {
      if ( j % i == 0 ) {
        list1 . add ( i ) ;
        break ;
      }
    }
  }
  return list1 . size ( ) ;
}

***Example ends here:
List < Integer > getArray ( int n ) {
  List < Integer > ans = new ArrayList < > ( ) ;
  int p2 = 1 ;
  while ( n > 0 ) {
    if ( n % 2 == 1 ) {
      ans . add ( p2 ) ;
    }
    n >>= 1 ;
    p2 *= 2 ;
  }
  return ans ;
}

***Example ends here:
int maximumLength ( int [ ] a ) {
  int [ ] counts = new int [ 11 ] ;
  int ans = 0 ;
  for ( int index = 0 ;
  index < a . length ;
  index ++ ) {
    counts [ a [ index ] ] ++ ;
    List < Integer > k = new ArrayList < > ( ) ;
    for ( int i : counts ) {
      if ( i != 0 ) {
        k . add ( i ) ;
      }
    }
    Collections . sort ( k ) ;
    if ( k . size ( ) == 1 || ( k . get ( 0 ) == k . get ( k . size ( ) - 2 ) && k . get ( k . size ( ) - 1 ) - k . get ( k . size ( ) - 2 ) == 1 ) || ( k . get ( 0 ) == 1 && k . get ( 1 ) == k . get ( k . size ( ) - 1 ) ) ) {
      ans = index ;
    }
  }
  return ans + 1 ;
}

***Example ends here:
double maxEdges ( double n ) {
  double edges = Math . floor ( n * n / 4 ) ;
  return edges ;
}

***Example ends here:
int findK ( int n , int k ) {
  List < Integer > a = new ArrayList < > ( ) ;
  for ( int i = 1 ;
  i < n ;
  i ++ ) {
    if ( i % 2 == 1 ) {
      a . add ( i ) ;
    }
  }
  for ( int i = 1 ;
  i < n ;
  i ++ ) {
    if ( i % 2 == 0 ) {
      a . add ( i ) ;
    }
  }
  return a . get ( k - 1 ) ;
}

***Example ends here:
boolean isKeith ( int x , int temp ) {
  List < Integer > terms = new ArrayList < > ( ) ;
  int n = 0 ;
  while ( temp > 0 ) {
    terms . add ( temp % 10 ) ;
    temp = temp / 10 ;
    n ++ ;
  }
  Collections . reverse ( terms ) ;
  int nextTerm = 0 , i = n ;
  while ( nextTerm < x ) {
    nextTerm = 0 ;
    for ( int j = 1 ;
    j <= n ;
    j ++ ) {
      nextTerm += terms . get ( i - j ) ;
    }
    terms . add ( nextTerm ) ;
    i ++ ;
  }
  return nextTerm == x ;
}

***Example ends here:
boolean factors ( int n , int k ) {
  List < Integer > v = new ArrayList < > ( ) ;
  while ( n % 2 == 0 ) {
    v . add ( 2 ) ;
    n /= 2 ;
  }
  if ( v . size ( ) >= k ) return true ;
  for ( int i = 3 ;
  i <= n ;
  i += 2 ) {
    if ( i * i > n ) break ;
    while ( n % i == 0 ) {
      n = n / i ;
      v . add ( i ) ;
    }
    if ( v . size ( ) >= k ) return true ;
  }
  if ( n > 2 ) v . add ( n ) ;
  if ( v . size ( ) >= k ) return true ;
  return false ;
}

***Example ends here:
String [ ] separateParenGroups ( String parenString ) {
  List < String > allParens = new ArrayList < > ( ) ;
  StringBuilder currentParen = new StringBuilder ( ) ;
  int currentDepth = 0 ;
  for ( int i = 0 ;
  i < parenString . length ( ) ;
  i ++ ) {
    char c = parenString . charAt ( i ) ;
    if ( c == '(' ) {
      currentDepth ++ ;
      currentParen . append ( c ) ;
    }
    else if ( c == ')' ) {
      currentDepth -- ;
      currentParen . append ( c ) ;
      if ( currentDepth == 0 ) {
        allParens . add ( currentParen . toString ( ) ) ;
        currentParen . clear ( ) ;
      }
    }
  }
  return allParens . toArray ( new String [ allParens . size ( ) ] ) ;
}

***Example ends here:
ArrayList parseNestedParens ( String parenString ) {
  ArrayList allLevels = new ArrayList ( ) ;
  int level = 0 ;
  int maxLevel = 0 ;
  for ( int i = 0 ;
  i < parenString . length ( ) ;
  i ++ ) {
    char chr = parenString . charAt ( i ) ;
    if ( chr == '(' ) {
      level ++ ;
      if ( level > maxLevel ) {
        maxLevel = level ;
      }
    }
    if ( chr == ')' ) {
      level -- ;
      if ( level == 0 ) {
        allLevels . add ( maxLevel ) ;
        maxLevel = 0 ;
      }
    }
  }
  return allLevels ;
}

***Example ends here:
String [ ] filterBySubstring ( String [ ] strings , String substring ) {
  List < String > result = new ArrayList < String > ( ) ;
  for ( String s : strings ) {
    if ( s . contains ( substring ) ) {
      result . add ( s ) ;
    }
  }
  return result . toArray ( new String [ result . size ( ) ] ) ;
}

***Example ends here:
int [ ] rollingMax ( int [ ] numbers ) {
  int runningMax = 0 ;
  int [ ] result = new int [ numbers . length ] ;
  for ( int n : numbers ) {
    if ( n > runningMax ) {
      runningMax = n ;
    }
    result [ n ] = runningMax ;
  }
  return result ;
}

***Example ends here:
String makePalindrome ( String s ) {
  if ( s == null ) return "" ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    String rStr = s . substring ( i ) ;
    if ( rStr . equals ( rStr . substring ( 0 , rStr . length ( ) - 1 ) ) ) {
      String nStr = s . substring ( 0 , i ) ;
      String n2Str = nStr . substring ( 0 , nStr . length ( ) - 1 ) ;
      return s + n2Str ;
    }
  }
  return s . substring ( 0 , s . length ( ) - 2 ) + s . substring ( 0 , s . length ( ) - 1 ) ;
}

***Example ends here:
String stringXOR ( String a , String b ) {
  StringBuilder result = new StringBuilder ( ) ;
  for ( int i = 0 ;
  i < a . length ( ) ;
  i ++ ) {
    if ( a . charAt ( i ) == b . charAt ( i ) ) {
      result . append ( '0' ) ;
    }
    else {
      result . append ( '1' ) ;
    }
  }
  return result . toString ( ) ;
}

***Example ends here:
String longest ( String [ ] strings ) {
  if ( strings == null ) return "" ;
  int bufLen = Math . max ( strings . length , strings . length ) ;
  for ( String s : strings ) {
    if ( s . length ( ) == bufLen ) return s ;
  }
  return "" ;
}

***Example ends here:
String stringSequence ( int n ) {
  StringBuilder sb = new StringBuilder ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    sb . append ( i ) ;
    sb . append ( " " ) ;
  }
  sb . append ( n ) ;
  return sb . toString ( ) ;
}

***Example ends here:
int countDistinctCharacters ( String s ) {
  Set < Character > distinct = new HashSet < > ( ) ;
  for ( char c : s . toLowerCase ( ) . toCharArray ( ) ) {
    distinct . add ( c ) ;
  }
  return distinct . size ( ) ;
}

***Example ends here:
int howManyTimes ( String s , String sub ) {
  int times = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) - sub . length ( ) + 1 ;
  i ++ ) {
    if ( s . substring ( i , i + sub . length ( ) ) . equals ( sub ) ) {
      times ++ ;
    }
  }
  return times ;
}

***Example ends here:
String sortNumbers ( String [ ] numbers ) {
  Map < String , Integer > toNum = new HashMap < > ( ) ;
  toNum . put ( "zero" , 0 ) ;
  toNum . put ( "one" , 1 ) ;
  toNum . put ( "two" , 2 ) ;
  toNum . put ( "three" , 3 ) ;
  toNum . put ( "four" , 4 ) ;
  toNum . put ( "five" , 5 ) ;
  toNum . put ( "six" , 6 ) ;
  toNum . put ( "seven" , 7 ) ;
  toNum . put ( "eight" , 8 ) ;
  toNum . put ( "nine" , 9 ) ;
  Map < Integer , String > fromNum = new HashMap < > ( ) ;
  fromNum . put ( 0 , "zero" ) ;
  fromNum . put ( 1 , "one" ) ;
  fromNum . put ( 2 , "two" ) ;
  fromNum . put ( 3 , "three" ) ;
  fromNum . put ( 4 , "four" ) ;
  fromNum . put ( 5 , "five" ) ;
  fromNum . put ( 6 , "six" ) ;
  fromNum . put ( 7 , "seven" ) ;
  fromNum . put ( 8 , "eight" ) ;
  fromNum . put ( 9 , "nine" ) ;
  List < Integer > ints = new ArrayList < > ( ) ;
  StringBuilder current = new StringBuilder ( ) ;
  for ( int i = 0 ;
  i < numbers . length + 1 ;
  i ++ ) {
    if ( i == numbers . length || numbers [ i ] . equals ( " " ) ) {
      if ( toNum . containsKey ( current . toString ( ) ) ) {
        ints . add ( toNum . get ( current . toString ( ) ) ) ;
        current . setLength ( 0 ) ;
      }
    }
    else {
      current . append ( numbers [ i ] ) ;
    }
  }
  Collections . sort ( ints ) ;
  StringBuilder result = new StringBuilder ( ) ;
  for ( int i = 0 ;
  i < ints . size ( ) ;
  i ++ ) {
    result . append ( fromNum . get ( ints . get ( i ) ) ) ;
    if ( i != ints . size ( ) - 1 ) {
      result . append ( " " ) ;
    }
  }
  return result . toString ( ) ;
}

***Example ends here:
int [ ] findClosestElements ( int [ ] numbers ) {
  int [ ] closestPair = {
    numbers [ 0 ] , numbers [ 1 ] }
    ;
    int distance = Math . abs ( closestPair [ 0 ] - closestPair [ 1 ] ) ;
    for ( int i = 0 ;
    i < numbers . length ;
    i ++ ) {
      for ( int j = i + 1 ;
      j < numbers . length ;
      j ++ ) {
        if ( Math . abs ( numbers [ i ] - numbers [ j ] ) < distance ) {
          closestPair [ 0 ] = numbers [ i ] ;
          closestPair [ 1 ] = numbers [ j ] ;
          distance = Math . abs ( numbers [ i ] - numbers [ j ] ) ;
        }
      }
    }
    Arrays . sort ( closestPair ) ;
    return closestPair ;
  }
  
***Example ends here:
double [ ] rescaleToUnit ( double [ ] numbers ) {
  double minNum = Math . min ( numbers ) ;
  double maxNum = Math . max ( numbers ) ;
  double [ ] result = new double [ numbers . length ] ;
  for ( int n = 0 ;
  n < numbers . length ;
  n ++ ) {
    result [ n ] = ( numbers [ n ] - minNum ) / ( maxNum - minNum ) ;
  }
  return result ;
}

***Example ends here:
int [ ] filterIntegers ( int [ ] values ) {
  int [ ] result = new int [ values . length ] ;
  for ( int e : values ) {
    if ( e == 0 ) {
      result [ e ] = 0 ;
    }
  }
  return result ;
}

***Example ends here:
int [ ] removeDuplicates ( int [ ] numbers ) {
  HashMap < Integer , Integer > counter = new HashMap < > ( ) ;
  for ( int i = 0 ;
  i < numbers . length ;
  i ++ ) {
    counter . put ( numbers [ i ] , counter . get ( numbers [ i ] , 0 ) + 1 ) ;
  }
  int [ ] result = new int [ numbers . length ] ;
  for ( int i = 0 ;
  i < numbers . length ;
  i ++ ) {
    if ( counter . get ( numbers [ i ] ) == 1 ) {
      result [ i ] = numbers [ i ] ;
    }
  }
  return result ;
}

***Example ends here:
String flipCase ( String s ) {
  StringBuilder result = new StringBuilder ( ) ;
  for ( char c : s . toCharArray ( ) ) {
    if ( Character . isLowerCase ( c ) ) {
      result . append ( Character . toUpperCase ( c ) ) ;
    }
    else {
      result . append ( Character . toLowerCase ( c ) ) ;
    }
  }
  return result . toString ( ) ;
}

***Example ends here:
String [ ] filterByPrefix ( String [ ] strings , String prefix ) {
  String [ ] result = new String [ strings . length ] ;
  for ( int i = 0 ;
  i < strings . length ;
  i ++ ) {
    if ( strings [ i ] . startsWith ( prefix ) ) {
      result [ i ] = strings [ i ] ;
    }
  }
  return result ;
}

***Example ends here:
double findZero ( double [ ] xs ) {
  double ans = 0 ;
  double value = 0 ;
  for ( int i = 0 ;
  i < xs . length ;
  i ++ ) {
    value += xs [ i ] * ans * xs [ i ] ;
  }
  while ( Math . abs ( value ) > 1e-6 ) {
    double driv = 0 ;
    for ( int i = 1 ;
    i < xs . length ;
    i ++ ) {
      driv += xs [ i ] * ans * ( i - 1 ) * xs [ i ] ;
    }
    ans -= value / driv ;
    value = 0 ;
    for ( int i = 0 ;
    i < xs . length ;
    i ++ ) {
      value += xs [ i ] * ans * xs [ i ] ;
    }
  }
  return ans ;
}

***Example ends here:
int [ ] sortThird ( int [ ] l ) {
  int [ ] thirds = new int [ l . length ] ;
  for ( int i = 0 ;
  i < l . length ;
  i += 3 ) {
    thirds [ i ] = l [ i ] ;
  }
  Arrays . sort ( thirds ) ;
  int [ ] result = new int [ l . length ] ;
  for ( int i = 0 ;
  i < l . length ;
  i ++ ) {
    if ( i % 3 == 0 ) {
      result [ i ] = thirds [ i / 3 ] ;
    }
    else {
      result [ i ] = l [ i ] ;
    }
  }
  return result ;
}

***Example ends here:
ArrayList unique ( ArrayList l ) {
  ArrayList result = new ArrayList ( l ) ;
  Collections . sort ( result ) ;
  return result ;
}

***Example ends here:
double maxElement ( double [ ] l ) {
  return Math . max ( l , 0 ) ;
}

***Example ends here:
boolean triplesSumToZero ( int [ ] l ) {
  for ( int i = 0 ;
  i < l . length ;
  i ++ ) {
    for ( int j = i + 1 ;
    j < l . length ;
    j ++ ) {
      for ( int k = j + 1 ;
      k < l . length ;
      k ++ ) {
        if ( l [ i ] + l [ j ] + l [ k ] == 0 ) {
          return true ;
        }
      }
    }
  }
  return false ;
}

***Example ends here:
int fib4 ( int n ) {
  int [ ] results = {
    0 , 0 , 2 , 0 }
    ;
    for ( int i = 4 ;
    i <= n ;
    i ++ ) {
      results [ i ] = results [ i - 4 ] + results [ i - 3 ] + results [ i - 2 ] + results [ i - 1 ] ;
    }
    return results [ n ] ;
  }
  
***Example ends here:
boolean isPalindrome ( String text ) {
  String pr = text . substring ( 0 , text . length ( ) - 1 ) ;
  return pr . equals ( text ) ;
}

***Example ends here:
String removeVowels ( String text ) {
  StringBuilder result = new StringBuilder ( ) ;
  String vowels = "aeiou" ;
  for ( char ch : text . toCharArray ( ) ) {
    if ( ! vowels . contains ( Character . toLowerCase ( ch ) ) ) {
      result . append ( ch ) ;
    }
  }
  return result . toString ( ) ;
}

***Example ends here:
boolean sameChars ( String s0 , String s1 ) {
  HashSet < Character > set0 = new HashSet < > ( ) ;
  for ( char c : s0 . toCharArray ( ) ) {
    set0 . add ( c ) ;
  }
  HashSet < Character > set1 = new HashSet < > ( ) ;
  for ( char c : s1 . toCharArray ( ) ) {
    set1 . add ( c ) ;
  }
  return set0 . equals ( set1 ) ;
}

***Example ends here:
String [ ] common ( String [ ] l1 , String [ ] l2 ) {
  HashSet < String > us = new HashSet < String > ( ) ;
  for ( String e1 : l1 ) {
    for ( String e2 : l2 ) {
      if ( e1 . equals ( e2 ) ) {
        us . add ( e1 ) ;
      }
    }
  }
  String [ ] ret = us . toArray ( new String [ us . size ( ) ] ) ;
  Arrays . sort ( ret ) ;
  return ret ;
}

***Example ends here:
boolean correctBracketing ( String brackets ) {
  int depth = 0 ;
  for ( char b : brackets . toCharArray ( ) ) {
    if ( b == "(" ) {
      depth ++ ;
    }
    else {
      depth -- ;
    }
    if ( depth < 0 ) {
      return false ;
    }
  }
  return depth == 0 ;
}

***Example ends here:
String circularShift ( int x , int shift ) {
  String s = String . valueOf ( x ) ;
  if ( shift > s . length ( ) ) {
    return s . substring ( 0 , s . length ( ) - 1 ) ;
  }
  return s . substring ( s . length ( ) - shift ) + s . substring ( 0 , s . length ( ) - shift ) ;
}

***Example ends here:
int search ( int [ ] list ) {
  HashMap < Integer , Integer > counter = new HashMap ( ) ;
  for ( int i = 0 ;
  i < list . length ;
  i ++ ) {
    counter . put ( list [ i ] , counter . getOrDefault ( list [ i ] , 0 ) + 1 ) ;
  }
  int ans = - 1 ;
  for ( Map . Entry < Integer , Integer > entry : counter . entrySet ( ) ) {
    if ( entry . getValue ( ) >= entry . getKey ( ) && entry . getValue ( ) > ans ) {
      ans = entry . getKey ( ) ;
    }
  }
  return ans ;
}

***Example ends here:
int smallestChange ( int [ ] arr ) {
  int ans = 0 ;
  for ( int i = 0 ;
  i < arr . length / 2 ;
  i ++ ) {
    if ( arr [ i ] != arr [ arr . length - i - 1 ] ) {
      ans ++ ;
    }
  }
  return ans ;
}

***Example ends here:
int totalMatch ( List < String > lst1 , List < String > lst2 ) {
  int sum1 = 0 ;
  for ( String st : lst1 ) {
    sum1 += st . length ( ) ;
  }
  int sum2 = 0 ;
  for ( String st : lst2 ) {
    sum2 += st . length ( ) ;
  }
  return sum1 > sum2 ? lst2 : lst1 ;
}

***Example ends here:
boolean isHappy ( String s ) {
  if ( s . length ( ) < 3 ) return false ;
  for ( int i = 0 ;
  i < s . length ( ) - 2 ;
  i ++ ) {
    if ( s . charAt ( i ) == s . charAt ( i + 1 ) || s . charAt ( i + 1 ) == s . charAt ( i + 2 ) || s . charAt ( i ) == s . charAt ( i + 2 ) ) return false ;
  }
  return true ;
}

***Example ends here:
String numericalLetterGrade ( double [ ] grades ) {
  StringBuilder letterGrade = new StringBuilder ( ) ;
  for ( double gpa : grades ) {
    if ( gpa == 4.0 ) {
      letterGrade . append ( "A+" ) ;
    }
    else if ( gpa > 3.7 ) {
      letterGrade . append ( "A" ) ;
    }
    else if ( gpa > 3.3 ) {
      letterGrade . append ( "A-" ) ;
    }
    else if ( gpa > 3.0 ) {
      letterGrade . append ( "B+" ) ;
    }
    else if ( gpa > 2.7 ) {
      letterGrade . append ( "B" ) ;
    }
    else if ( gpa > 2.3 ) {
      letterGrade . append ( "B-" ) ;
    }
    else if ( gpa > 2.0 ) {
      letterGrade . append ( "C+" ) ;
    }
    else if ( gpa > 1.7 ) {
      letterGrade . append ( "C" ) ;
    }
    else if ( gpa > 1.3 ) {
      letterGrade . append ( "C-" ) ;
    }
    else if ( gpa > 1.0 ) {
      letterGrade . append ( "D+" ) ;
    }
    else if ( gpa > 0.7 ) {
      letterGrade . append ( "D" ) ;
    }
    else if ( gpa > 0.0 ) {
      letterGrade . append ( "D-" ) ;
    }
    else {
      letterGrade . append ( "E" ) ;
    }
  }
  return letterGrade . toString ( ) ;
}

***Example ends here:
String solve ( int n ) {
  StringBuilder biStr = new StringBuilder ( ) ;
  int sum = 0 ;
  for ( char c : String . valueOf ( n ) . toCharArray ( ) ) {
    sum += c - '0' ;
  }
  while ( sum > 0 ) {
    biStr . insert ( 0 , String . valueOf ( sum % 2 ) ) ;
    sum /= 2 ;
  }
  return biStr . toString ( ) ;
}

***Example ends here:
String antiShuffle ( String s ) {
  StringBuilder ret = new StringBuilder ( ) ;
  StringBuilder current = new StringBuilder ( ) ;
  for ( int i = 0 ;
  i < s . length ( ) + 1 ;
  i ++ ) {
    if ( i == s . length ( ) || s . charAt ( i ) == ' ' ) {
      Collections . sort ( current ) ;
      if ( ret . length ( ) > 0 ) {
        ret . append ( " " ) ;
      }
      ret . append ( current . toString ( ) ) ;
      current . clear ( ) ;
    }
    else {
      current . append ( s . charAt ( i ) ) ;
    }
  }
  return ret . toString ( ) ;
}

***Example ends here:
int [ ] sortArray ( int [ ] array ) {
  if ( array == null ) return array ;
  if ( ( array [ 0 ] + array [ array . length - 1 ] ) % 2 == 1 ) {
    Arrays . sort ( array ) ;
  }
  else {
    Arrays . sort ( array , Collections . reverseOrder ( ) ) ;
  }
  return array ;
}

***Example ends here:
String encrypt ( String s ) {
  StringBuilder ans = new StringBuilder ( ) ;
  for ( char c : s . toCharArray ( ) ) {
    if ( Character . isLetter ( c ) ) {
      ans . append ( ( char ) ( 'a' + ( c - 'a' + 4 ) % 26 ) ) ;
    }
    else {
      ans . append ( c ) ;
    }
  }
  return ans . toString ( ) ;
}

***Example ends here:
int isBored ( String s ) {
  boolean isStart = true ;
  int sum = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( s . charAt ( i ) == '.' || s . charAt ( i ) == '?' || s . charAt ( i ) == '!' ) {
      isStart = true ;
    }
    else if ( isStart ) {
      if ( s . charAt ( i ) == ' ' ) continue ;
      if ( s . substring ( i , i + 2 ) . equals ( "I " ) ) sum ++ ;
      isStart = false ;
    }
  }
  return sum ;
}

***Example ends here:
String encode ( String message ) {
  String vowels = "aeiouAEIOU" ;
  StringBuilder ret = new StringBuilder ( ) ;
  for ( int i = 0 ;
  i < message . length ( ) ;
  i ++ ) {
    char c = message . charAt ( i ) ;
    if ( Character . isUpperCase ( c ) ) {
      c = Character . toLowerCase ( c ) ;
      if ( vowels . indexOf ( c ) != - 1 ) {
        c = ( char ) ( 'a' + ( c - 'a' + 2 ) % 26 ) ;
      }
    }
    else if ( Character . isLowerCase ( c ) ) {
      c = Character . toUpperCase ( c ) ;
      if ( vowels . indexOf ( c ) != - 1 ) {
        c = ( char ) ( 'A' + ( c - 'A' + 2 ) % 26 ) ;
      }
    }
    ret . append ( c ) ;
  }
  return ret . toString ( ) ;
}

***Example ends here:
int skjkasdkd ( int [ ] list ) {
  int largest = 0 ;
  for ( int n : list ) {
    if ( n > largest ) {
      boolean prime = true ;
      for ( int i = 2 ;
      i < n ;
      i ++ ) {
        if ( n % i == 0 ) {
          prime = false ;
        }
      }
      if ( prime ) {
        largest = n ;
      }
    }
  }
  int sum = 0 ;
  String s = Integer . toString ( largest ) ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    sum += s . charAt ( i ) - '0' ;
  }
  return sum ;
}

***Example ends here:
boolean checkMapCase ( String [ ] dict ) {
  if ( dict == null ) return false ;
  int isLower = 0 ;
  int isUpper = 0 ;
  for ( String key : dict ) {
    for ( char c : key . toCharArray ( ) ) {
      if ( Character . isLowerCase ( c ) ) {
        isLower = 1 ;
      }
      else if ( Character . isUpperCase ( c ) ) {
        isUpper = 1 ;
      }
      else {
        return false ;
      }
    }
  }
  return isLower + isUpper == 1 ;
}

***Example ends here:
int multiply ( int a , int b ) {
  return ( Math . abs ( a ) % 10 ) * ( Math . abs ( b ) % 10 ) ;
}

***Example ends here:
int countUpperCase ( String s ) {
  String uVowel = "AEIOU" ;
  int count = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i += 2 ) {
    if ( uVowel . indexOf ( s . charAt ( i ) ) != - 1 ) count ++ ;
  }
  return count ;
}

***Example ends here:
String [ ] byLength ( String [ ] arr ) {
  HashMap < Integer , String > numTo = new HashMap < > ( ) ;
  numTo . put ( 1 , "One" ) ;
  numTo . put ( 2 , "Two" ) ;
  numTo . put ( 3 , "Three" ) ;
  numTo . put ( 4 , "Four" ) ;
  numTo . put ( 5 , "Five" ) ;
  numTo . put ( 6 , "Six" ) ;
  numTo . put ( 7 , "Seven" ) ;
  numTo . put ( 8 , "Eight" ) ;
  numTo . put ( 9 , "Nine" ) ;
  List < Integer > sortedArr = new ArrayList < > ( arr ) ;
  Collections . sort ( sortedArr , Collections . reverseOrder ( ) ) ;
  String [ ] newArr = new String [ sortedArr . size ( ) ] ;
  for ( int n : sortedArr ) {
    if ( n >= 1 && n <= 9 ) {
      newArr [ n ] = numTo . get ( n ) ;
    }
  }
  return newArr ;
}

***Example ends here:
int [ ] f ( int n ) {
  int sum = 0 ;
  int prod = 1 ;
  int [ ] result = new int [ n + 1 ] ;
  for ( int i = 1 ;
  i <= n ;
  i ++ ) {
    sum += i ;
    prod *= i ;
    if ( i % 2 == 0 ) {
      result [ i ] = prod ;
    }
    else {
      result [ i ] = sum ;
    }
  }
  return result ;
}

***Example ends here:
int [ ] evenOdPalindrome ( int n ) {
  int evenCount = 0 ;
  int oddCount = 0 ;
  for ( int i = 1 ;
  i <= n ;
  i ++ ) {
    String s = String . valueOf ( i ) ;
    String rStr = s . substring ( 0 , s . length ( ) - 1 ) ;
    if ( s . equals ( rStr ) ) {
      if ( i % 2 == 1 ) {
        oddCount ++ ;
      }
      else {
        evenCount ++ ;
      }
    }
  }
  return new int [ ] {
    evenCount , oddCount }
    ;
  }
  
***Example ends here:
Map < String , Integer > histogram ( String test ) {
  Map < String , Integer > count = new HashMap < > ( ) ;
  int max = 0 ;
  for ( int i = 0 ;
  i < test . length ( ) ;
  i ++ ) {
    if ( test . charAt ( i ) != ' ' ) {
      count . put ( test . charAt ( i ) , count . getOrDefault ( test . charAt ( i ) , 0 ) + 1 ) ;
      if ( count . get ( test . charAt ( i ) ) > max ) {
        max = count . get ( test . charAt ( i ) ) ;
      }
    }
  }
  Map < String , Integer > result = new HashMap < > ( ) ;
  for ( Map . Entry < String , Integer > entry : count . entrySet ( ) ) {
    if ( entry . getValue ( ) == max ) {
      result . put ( entry . getKey ( ) , entry . getValue ( ) ) ;
    }
  }
  return result ;
}

***Example ends here:
String [ ] reverseDelete ( String s , String c ) {
  StringBuilder ret = new StringBuilder ( ) ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    char ch = s . charAt ( i ) ;
    if ( ! c . contains ( ch ) ) {
      ret . append ( ch ) ;
    }
  }
  String flag = "false" ;
  if ( ret . toString ( ) . equals ( ret . toString ( ) ) ) {
    flag = "true" ;
  }
  return new String [ ] {
    ret . toString ( ) , flag }
    ;
  }
  
***Example ends here:
int [ ] sortArray ( int [ ] arr ) {
  int [ ] bin = new int [ arr . length ] ;
  for ( int i = 0 ;
  i < arr . length ;
  i ++ ) {
    int b = 0 ;
    int n = Math . abs ( arr [ i ] ) ;
    while ( n > 0 ) {
      b += n % 2 ;
      n /= 2 ;
    }
    bin [ i ] = b ;
  }
  for ( int i = 0 ;
  i < arr . length ;
  i ++ ) {
    for ( int j = 1 ;
    j < arr . length ;
    j ++ ) {
      if ( bin [ j ] < bin [ j - 1 ] || ( bin [ j ] == bin [ j - 1 ] && arr [ j ] < arr [ j - 1 ] ) ) {
        bin [ j ] = bin [ j - 1 ] ;
        bin [ j - 1 ] = bin [ j ] ;
        arr [ j ] = arr [ j - 1 ] ;
      }
    }
  }
  return arr ;
}

***Example ends here:
String getClosestVowel ( String word ) {
  String vowels = "AEIOUaeiou" ;
  for ( int i = word . length ( ) - 2 ;
  i > 0 ;
  i -- ) {
    if ( vowels . contains ( word . charAt ( i ) ) && ! vowels . contains ( word . charAt ( i + 1 ) ) && ! vowels . contains ( word . charAt ( i - 1 ) ) ) {
      return word . charAt ( i ) ;
    }
  }
  return "" ;
}

***Example ends here:
String matchParens ( String [ ] list ) {
  String [ ] strings = {
    list [ 0 ] + list [ 1 ] , list [ 1 ] + list [ 0 ] }
    ;
    for ( String l : strings ) {
      int count = 0 ;
      for ( char c : l . toCharArray ( ) ) {
        if ( c == '(' ) {
          count ++ ;
        }
        if ( c == ')' ) {
          count -- ;
        }
        if ( count < 0 ) {
          break ;
        }
      }
      if ( count == 0 ) {
        return "Yes" ;
      }
    }
    return "No" ;
  }
  
***Example ends here:
int [ ] maximum ( int [ ] arr , int k ) {
  if ( k == 0 ) {
    return new int [ 0 ] ;
  }
  Arrays . sort ( arr ) ;
  return arr . clone ( ) ;
}

***Example ends here:
boolean validDate ( String date ) {
  if ( date . length ( ) != 10 ) {
    return false ;
  }
  for ( int i = 0 ;
  i < 10 ;
  i ++ ) {
    if ( i == 2 || i == 5 ) {
      if ( date . charAt ( i ) != '-' ) {
        return false ;
      }
    }
    else if ( ! Character . isDigit ( date . charAt ( i ) ) ) {
      return false ;
    }
  }
  int month = Integer . parseInt ( date . substring ( 0 , 2 ) ) ;
  int day = Integer . parseInt ( date . substring ( 3 , 5 ) ) ;
  int year = Integer . parseInt ( date . substring ( 6 , 10 ) ) ;
  if ( month < 1 || month > 12 ) {
    return false ;
  }
  if ( day < 1 || day > 31 ) {
    return false ;
  }
  if ( day == 31 && ( month == 4 || month == 6 || month == 9 || month == 11 || month == 2 ) ) {
    return false ;
  }
  if ( day == 30 && month == 2 ) {
    return false ;
  }
  return true ;
}

***Example ends here:
String [ ] splitWords ( String txt ) {
  StringBuilder current = new StringBuilder ( ) ;
  StringBuilder result = new StringBuilder ( ) ;
  if ( txt . contains ( " " ) ) {
    for ( int i = 0 ;
    i < txt . length ( ) + 1 ;
    i ++ ) {
      if ( i == txt . length ( ) || txt . charAt ( i ) == ' ' ) {
        if ( current . length ( ) > 0 ) {
          result . append ( current . toString ( ) ) ;
          current . clear ( ) ;
        }
      }
      else {
        current . append ( txt . charAt ( i ) ) ;
      }
    }
    return result . toString ( ) . trim ( ) . trim ( ) . split ( " " ) ;
  }
  if ( txt . contains ( "," ) ) {
    for ( int i = 0 ;
    i < txt . length ( ) + 1 ;
    i ++ ) {
      if ( i == txt . length ( ) || txt . charAt ( i ) == ',' ) {
        if ( current . length ( ) > 0 ) {
          result . append ( current . toString ( ) ) ;
          current . clear ( ) ;
        }
      }
      else {
        current . append ( txt . charAt ( i ) ) ;
      }
    }
    return result . toString ( ) . trim ( ) . split ( " " ) ;
  }
  int num = 0 ;
  for ( char c : txt . toCharArray ( ) ) {
    if ( Character . isLowerCase ( c ) && ( int ) c % 2 == 0 ) {
      num ++ ;
    }
  }
  return new String [ ] {
    String . valueOf ( num ) }
    ;
  }
  
***Example ends here:
int [ ] tri ( int n ) {
  if ( n == 0 ) {
    return new int [ ] {
      1 }
      ;
    }
    int [ ] tris = new int [ ] {
      1 , 3 }
      ;
      for ( int i = 2 ;
      i <= n ;
      i ++ ) {
        if ( i % 2 == 0 ) {
          tris [ i ] = i / 2 + 1 ;
        }
        else {
          tris [ i ] = tris [ i - 1 ] + tris [ i - 2 ] + ( i + 3 ) / 2 ;
        }
      }
      return tris ;
    }
    
***Example ends here:
boolean checkIfLastCharIsALetter ( String txt ) {
  if ( txt == null ) return false ;
  return Character . isLetter ( txt . charAt ( txt . length ( ) - 1 ) ) && ( txt . length ( ) == 1 || ! Character . isLetter ( txt . charAt ( txt . length ( ) - 2 ) ) ) ;
}

***Example ends here:
int [ ] orderByPoints ( int [ ] nums ) {
  int [ ] result = new int [ nums . length ] ;
  for ( int num : nums ) {
    String w = String . valueOf ( Math . abs ( num ) ) ;
    int sum = 0 ;
    for ( int i = 0 ;
    i < w . length ( ) ;
    i ++ ) {
      sum += w . charAt ( i ) - '0' ;
    }
    if ( num < 0 ) {
      sum -= 2 * ( w . charAt ( 0 ) - '0' ) ;
    }
    result [ i ] = sum ;
  }
  for ( int i = 0 ;
  i < nums . length ;
  i ++ ) {
    for ( int j = 1 ;
    j < nums . length ;
    j ++ ) {
      if ( result [ j - 1 ] > result [ j ] ) {
        result [ j ] = result [ j - 1 ] ;
        result [ j - 1 ] = result [ j ] ;
        nums [ j ] = nums [ j - 1 ] ;
      }
    }
  }
  return nums ;
}

***Example ends here:
String bf ( String planet1 , String planet2 ) {
  String [ ] planets = {
    "Mercury" , "Venus" , "Earth" , "Mars" , "Jupiter" , "Saturn" , "Uranus" , "Neptune" }
    ;
    int idx1 = planets . contains ( planet1 ) ? planets [ 0 ] . indexOf ( planet1 ) : - 1 ;
    int idx2 = planets . contains ( planet2 ) ? planets [ 0 ] . indexOf ( planet2 ) : - 1 ;
    if ( idx1 == - 1 || idx2 == - 1 || idx1 == idx2 ) {
      return new String ( ) ;
    }
    return idx1 > idx2 ? planets . substring ( idx2 + 1 , idx1 ) : planets . substring ( idx1 + 1 , idx2 ) ;
  }
  
***Example ends here:
List < String > sortedListSum ( List < String > list ) {
  List < String > result = new ArrayList < > ( ) ;
  for ( int i = 0 ;
  i < list . size ( ) ;
  i ++ ) {
    if ( list . get ( i ) . length ( ) % 2 == 0 ) {
      result . add ( list . get ( i ) ) ;
    }
  }
  Collections . sort ( result , new Comparator < String > ( ) {
    public int compare ( String s , String s1 ) {
      return ( s . length ( ) ) ;
    }
  }
  ) ;
  return result ;
}

***Example ends here:
boolean cycpPatternCheck ( String a , String b ) {
  for ( int i = 0 ;
  i < b . length ( ) ;
  i ++ ) {
    String rotate = b . substring ( i ) + b . substring ( 0 , i ) ;
    if ( a . contains ( rotate ) ) {
      return true ;
    }
  }
  return false ;
}

***Example ends here:
int [ ] evenOddCount ( int num ) {
  int evenCount = 0 , oddCount = 0 ;
  for ( String i : String . valueOf ( Math . abs ( num ) ) . split ( " " ) ) {
    if ( Integer . parseInt ( i ) % 2 == 0 ) {
      evenCount ++ ;
    }
    else {
      oddCount ++ ;
    }
  }
  return new int [ ] {
    evenCount , oddCount }
    ;
  }
  
***Example ends here:
String findMax ( String [ ] words ) {
  String max = "" ;
  int maxLength = 0 ;
  for ( String word : words ) {
    List < String > unique = new ArrayList < String > ( ) ;
    for ( String w : word . split ( " " ) ) {
      if ( ! unique . contains ( w ) ) {
        unique . add ( w ) ;
      }
    }
    if ( unique . size ( ) > maxLength || ( unique . size ( ) == maxLength && word . compareTo ( max ) < 0 ) ) {
      max = word ;
      maxLength = unique . size ( ) ;
    }
  }
  return max ;
}

***Example ends here:
String solve ( String s ) {
  boolean noLetter = true ;
  StringBuilder result = new StringBuilder ( ) ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    char ch = s . charAt ( i ) ;
    if ( Character . isUpperCase ( ch ) ) {
      ch = Character . toLowerCase ( ch ) ;
      noLetter = false ;
    }
    else if ( Character . isLowerCase ( ch ) ) {
      ch = Character . toUpperCase ( ch ) ;
      noLetter = false ;
    }
    result . append ( ch ) ;
  }
  if ( noLetter ) {
    return result . toString ( ) . substring ( 0 , result . length ( ) - 1 ) ;
  }
  else {
    return result . toString ( ) ;
  }
}

***Example ends here:
int mostFrequent ( int [ ] arr , int n ) {
  HashMap < Integer , Integer > hp = new HashMap < > ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( hp . containsKey ( arr [ i ] ) ) {
      hp . put ( arr [ i ] , 1 ) ;
    }
    else {
      hp . put ( arr [ i ] , 1 ) ;
    }
  }
  int maxCount = 0 , res = - 1 ;
  for ( Map . Entry < Integer , Integer > entry : hp . entrySet ( ) ) {
    if ( maxCount < entry . getValue ( ) ) {
      res = entry . getKey ( ) ;
      maxCount = entry . getValue ( ) ;
    }
  }
  return res ;
}

***Example ends here:
int find ( int [ ] a , int [ ] b , int k , int n1 , int n2 ) {
  HashSet < Integer > s = new HashSet < > ( ) ;
  for ( int i = 0 ;
  i < n2 ;
  i ++ ) {
    s . add ( b [ i ] ) ;
  }
  int missing = 0 ;
  for ( int i = 0 ;
  i < n1 ;
  i ++ ) {
    if ( ! s . contains ( a [ i ] ) ) {
      missing ++ ;
    }
    if ( missing == k ) {
      return a [ i ] ;
    }
  }
  return - 1 ;
}

***Example ends here:
int solveQuery ( int start , int end , int [ ] arr ) {
  Map < Integer , Integer > frequency = new HashMap < > ( ) ;
  for ( int i = start ;
  i <= end ;
  i ++ ) {
    frequency . put ( arr [ i ] , frequency . getOrDefault ( arr [ i ] , 0 ) + 1 ) ;
  }
  int count = 0 ;
  for ( Map . Entry < Integer , Integer > entry : frequency . entrySet ( ) ) {
    if ( entry . getValue ( ) == 0 ) {
      count ++ ;
    }
  }
  return count ;
}

***Example ends here:
int segregate ( int [ ] arr , int size ) {
  int j = 0 ;
  for ( int i = 0 ;
  i < size ;
  i ++ ) {
    if ( arr [ i ] <= 0 ) {
      arr [ i ] = arr [ j ] ;
      j ++ ;
    }
  }
  return j ;
}

***Example ends here:
int countTriplets ( int [ ] a , int n ) {
  HashSet < Integer > s = new HashSet < > ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    s . add ( a [ i ] ) ;
  }
  int count = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    for ( int j = i + 1 ;
    j < n ;
    j += 1 ) {
      int xr = a [ i ] ^ a [ j ] ;
      if ( s . contains ( xr ) && xr != a [ i ] && xr != a [ j ] ) {
        count ++ ;
      }
    }
  }
  return ( int ) ( count / 3 ) ;
}

***Example ends here:
int leastFrequent ( int [ ] arr , int n ) {
  HashMap < Integer , Integer > hp = new HashMap < > ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( hp . containsKey ( arr [ i ] ) ) hp . get ( arr [ i ] ) ++ ;
    else hp . put ( arr [ i ] , 1 ) ;
  }
  int minCount = n + 1 ;
  int res = - 1 ;
  for ( Map . Entry < Integer , Integer > entry : hp . entrySet ( ) ) {
    if ( minCount >= entry . getValue ( ) ) {
      res = entry . getKey ( ) ;
      minCount = entry . getValue ( ) ;
    }
  }
  return res ;
}

***Example ends here:
int findPermutations ( int [ ] arr ) {
  int cnt = 0 ;
  int maxInd = - 1 , minInd = 10000000 ;
  int n = arr . length ;
  Map < Integer , Integer > indexOfOf = new HashMap < > ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    indexOfOf . put ( arr [ i ] , i + 1 ) ;
  }
  for ( int i = 1 ;
  i <= n ;
  i ++ ) {
    maxInd = Math . max ( maxInd , indexOfOf . get ( i ) ) ;
    minInd = Math . min ( minInd , indexOfOf . get ( i ) ) ;
    if ( maxInd - minInd + 1 == i ) {
      cnt ++ ;
    }
  }
  return cnt ;
}

***Example ends here:
int formQuadruplets ( int [ ] arr , int n ) {
  int ans = 0 , pairs ;
  pairs = n / 4 ;
  Arrays . sort ( arr , Collections . reverseOrder ( ) ) ;
  for ( int i = 0 ;
  i < n - pairs ;
  i += 3 ) {
    ans += arr [ i + 2 ] ;
  }
  return ans ;
}

***Example ends here:
String lexicographicallyMax ( String s , int n ) {
  Map < Character , Integer > m = new HashMap < > ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( m . containsKey ( s . charAt ( i ) ) ) {
      m . put ( s . charAt ( i ) , 1 ) ;
    }
    else {
      m . put ( s . charAt ( i ) , 1 ) ;
    }
  }
  List < Character > v = new ArrayList < > ( ) ;
  for ( int i = Character . getNumericValue ( "a" ) ;
  i <= Character . getNumericValue ( "a" ) + Math . min ( n , 25 ) ;
  i ++ ) {
    if ( ! m . containsKey ( ( char ) i ) ) {
      v . add ( ( char ) i ) ;
    }
  }
  int j = v . size ( ) - 1 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( ( char ) s . charAt ( i ) >= 'a' + Math . min ( n , 25 ) || ( m . containsKey ( s . charAt ( i ) ) && m . get ( s . charAt ( i ) ) > 1 ) ) {
      if ( ( char ) v . get ( j ) < ( char ) s . charAt ( i ) ) {
        continue ;
      }
      m . get ( s . charAt ( i ) ) -- ;
      s = s . substring ( 0 , i ) + v . get ( j ) + s . substring ( i + 1 ) ;
      j -- ;
    }
  }
  if ( j < 0 ) {
    break ;
  }
  int l = 0 ;
  for ( int i = n - 1 ;
  i >= 0 ;
  i -- ) {
    if ( l > j ) {
      break ;
    }
    if ( ( char ) s . charAt ( i ) >= 'a' + Math . min ( n , 25 ) || m . containsKey ( s . charAt ( i ) ) && m . get ( s . charAt ( i ) ) > 1 ) {
      m . get ( s . charAt ( i ) ) -- ;
      s = s . substring ( 0 , i ) + v . get ( l ) + s . substring ( i + 1 ) ;
      l ++ ;
    }
  }
  return s ;
}

***Example ends here:
int noOfValidKbers ( int k , int [ ] arr ) {
  HashSet < Integer > st = new HashSet < > ( ) ;
  while ( k != 0 ) {
    st . add ( k % 10 ) ;
    k = k / 10 ;
  }
  int count = 0 ;
  for ( int i = 0 ;
  i < arr . length ;
  i ++ ) {
    int no = arr [ i ] ;
    boolean flag = true ;
    while ( no != 0 ) {
      int digit = no % 10 ;
      if ( ! st . contains ( digit ) ) {
        flag = false ;
        break ;
      }
      no = no / 10 ;
    }
    if ( flag == true ) {
      count ++ ;
    }
  }
  return count ;
}

***Example ends here:
int delCost ( String [ ] s , String [ ] cost ) {
  int ans = 0 ;
  Map < String , Integer > forMax = new HashMap < > ( ) ;
  Map < String , Integer > forMtot = new HashMap < > ( ) ;
  for ( int i = 0 ;
  i < s . length ;
  i ++ ) {
    if ( ! forMax . containsKey ( s [ i ] ) ) {
      forMax . put ( s [ i ] , cost [ i ] ) ;
    }
    else {
      forMax . put ( s [ i ] , Math . max ( cost [ i ] , forMax . get ( s [ i ] ) ) ) ;
    }
    if ( ! forMtot . containsKey ( s [ i ] ) ) {
      forMtot . put ( s [ i ] , cost [ i ] ) ;
    }
    else {
      forMtot . get ( s [ i ] ) + = cost [ i ] ;
    }
  }
  for ( Map . Entry < String , Integer > entry : forMax . entrySet ( ) ) {
    ans += forMtot . get ( entry . getKey ( ) ) - entry . getValue ( ) ;
  }
  return ans ;
}

***Example ends here:
String [ ] replaceDuplicates ( String [ ] names ) {
  HashMap < String , Integer > hash = new HashMap < > ( ) ;
  for ( int i = 0 ;
  i < names . length ;
  i ++ ) {
    if ( ! hash . containsKey ( names [ i ] ) ) {
      hash . put ( names [ i ] , 1 ) ;
    }
    else {
      Integer count = hash . get ( names [ i ] ) ;
      hash . put ( names [ i ] , 1 ) ;
      names [ i ] += count ;
    }
  }
  return names ;
}

***Example ends here:
List < Integer > minmaxNumbers ( int [ ] [ ] matrix , List < Integer > res ) {
  HashSet < Integer > s = new HashSet < > ( ) ;
  for ( int i = 0 ;
  i < matrix . length ;
  i ++ ) {
    int minR = Integer . MAX_VALUE ;
    for ( int j = 0 ;
    j < matrix [ i ] . length ;
    j ++ ) {
      minR = Math . min ( minR , matrix [ i ] [ j ] ) ;
    }
    s . add ( minR ) ;
  }
  for ( int j = 0 ;
  j < matrix [ 0 ] . length ;
  j ++ ) {
    int maxC = - Integer . MAX_VALUE ;
    for ( int i = 0 ;
    i < matrix . length ;
    i ++ ) {
      maxC = Math . max ( maxC , matrix [ i ] [ j ] ) ;
    }
    if ( s . contains ( maxC ) ) {
      res . add ( maxC ) ;
    }
  }
  return res ;
}

***Example ends here:
int lengthOfLongestAP ( int [ ] a , int n ) {
  Map < Integer , Map < Integer , Integer >> dp = new HashMap < > ( ) ;
  int res = 2 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    for ( int j = i + 1 ;
    j < n ;
    j ++ ) {
      int d = a [ j ] - a [ i ] ;
      if ( dp . containsKey ( d ) ) {
        if ( dp . get ( d ) . containsKey ( i ) ) {
          dp . get ( d ) . put ( j , dp . get ( d ) . get ( i ) + 1 ) ;
        }
        else {
          dp . get ( d ) . put ( j , 2 ) ;
        }
      }
      else {
        dp . put ( d , new HashMap < > ( ) ) ;
        dp . get ( d ) . put ( j , 2 ) ;
      }
      res = Math . max ( res , dp . get ( d ) . get ( j ) ) ;
    }
  }
  return res ;
}

***Example ends here:
String findKthChar ( int n , int k ) {
  String prev = "A" ;
  String cur = "" ;
  if ( n == 1 ) {
    return "A" ;
  }
  for ( int i = 2 ;
  i <= n ;
  i ++ ) {
    cur = prev + "B" ;
    for ( int j = 0 ;
    j < prev . length ( ) ;
    j ++ ) {
      if ( prev . charAt ( j ) == 'A' ) {
        prev = prev . substring ( 0 , j ) + "B" + prev . substring ( j + 1 ) ;
      }
      else {
        prev = prev . substring ( 0 , j ) + "A" + prev . substring ( j + 1 ) ;
      }
    }
    prev = prev . substring ( 0 , prev . length ( ) - 1 ) ;
    cur += prev ;
    prev = cur ;
  }
  return cur . charAt ( k - 1 ) ;
}

***Example ends here:
String findKthLargest ( String s , int k ) {
  String [ ] tmp = s . split ( " " ) ;
  Arrays . sort ( tmp , Collections . reverseOrder ( ) ) ;
  return tmp [ k - 1 ] ;
}

***Example ends here:
int subArraylen ( int [ ] arr , int n , int k ) {
  HashMap < Integer , Integer > mp = new HashMap < > ( ) ;
  mp . put ( arr [ 0 ] , 0 ) ;
  for ( int i = 1 ;
  i < n ;
  i ++ ) {
    arr [ i ] = arr [ i ] + arr [ i - 1 ] ;
    mp . put ( arr [ i ] , i ) ;
  }
  int len = Integer . MAX_VALUE ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( arr [ i ] < k ) {
      continue ;
    }
    else {
      int x = arr [ i ] - k ;
      if ( x == 0 ) {
        len = Math . min ( len , i ) ;
      }
      if ( ! mp . containsKey ( x ) ) {
        continue ;
      }
      else {
        len = Math . min ( len , i - mp . get ( x ) ) ;
      }
    }
  }
  return len ;
}

***Example ends here:
int findMaxLen ( int [ ] a , int k ) {
  int n = a . length ;
  Arrays . sort ( a ) ;
  boolean [ ] vis = new boolean [ n ] ;
  Map < Integer , Integer > mp = new HashMap < > ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    mp . put ( a [ i ] , i ) ;
  }
  int c = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( ! vis [ i ] ) {
      int check = a [ i ] * k ;
      if ( mp . containsKey ( check ) ) {
        c ++ ;
        vis [ mp . get ( check ) ] = true ;
      }
    }
  }
  return n - c ;
}

***Example ends here:
int [ ] minDistancePoints ( int [ ] a , int k , int n ) {
  HashMap < Integer , Integer > m = new HashMap < > ( ) ;
  List < Integer > q = new ArrayList < > ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    m . put ( a [ i ] , 1 ) ;
    q . add ( a [ i ] ) ;
  }
  int [ ] ans = new int [ n ] ;
  while ( k > 0 ) {
    int x = q . get ( 0 ) ;
    q = q . subList ( 1 , 0 ) ;
    if ( ( x - 1 ) != m . get ( x - 1 ) && k > 0 ) {
      m . put ( x - 1 , 1 ) ;
      q . add ( x - 1 ) ;
      ans [ k ] = x - 1 ;
      k -- ;
    }
    if ( ( x + 1 ) != m . get ( x + 1 ) && k > 0 ) {
      m . put ( x + 1 , 1 ) ;
      q . add ( x + 1 ) ;
      ans [ k ] = x + 1 ;
      k -- ;
    }
  }
  return ans ;
}

***Example ends here:
boolean isValidLen ( String s , int length , int k ) {
  int n = s . length ( ) ;
  Map < Character , Integer > mp = new HashMap < > ( ) ;
  int right = 0 ;
  while ( right < length ) {
    if ( mp . containsKey ( s . charAt ( right ) ) ) {
      mp . put ( s . charAt ( right ) , 1 ) ;
    }
    else {
      mp . put ( s . charAt ( right ) , 1 ) ;
    }
    right ++ ;
  }
  if ( mp . size ( ) <= k ) {
    return true ;
  }
  while ( right < n ) {
    if ( mp . containsKey ( s . charAt ( right ) ) ) {
      mp . put ( s . charAt ( right ) , 1 ) ;
    }
    else {
      mp . put ( s . charAt ( right ) , 1 ) ;
    }
    mp . get ( s . charAt ( right - length ) ) -- ;
    if ( mp . get ( s . charAt ( right - length ) ) == 0 ) {
      mp . remove ( s . charAt ( right - length ) ) ;
    }
    if ( mp . size ( ) <= k ) {
      return true ;
    }
    right ++ ;
  }
  return mp . size ( ) <= k ;
}

***Example ends here:
int partition ( int [ ] arr , int low , int high ) {
  int pivot = arr [ high ] ;
  int i = ( low - 1 ) ;
  for ( int j = low ;
  j < high ;
  j ++ ) {
    if ( arr [ j ] <= pivot ) {
      i ++ ;
      arr [ i ] = arr [ j ] ;
      arr [ j ] = arr [ i ] ;
    }
  }
  arr [ i + 1 ] = arr [ high ] ;
  arr [ high ] = arr [ i + 1 ] ;
  return i + 1 ;
}

***Example ends here:
int strScore ( String [ ] strs , String s , int n ) {
  Map < String , Integer > m = new HashMap < > ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    m . put ( strs [ i ] , i + 1 ) ;
  }
  if ( ! m . keySet ( ) . contains ( s ) ) {
    return 0 ;
  }
  int score = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    score += s . charAt ( i ) - 'a' + 1 ;
  }
  score = score * m . get ( s ) ;
  return score ;
}

***Example ends here:
int [ ] countEle ( int [ ] s , int [ ] a , int n ) {
  HashMap < Integer , Boolean > mp = new HashMap < > ( ) ;
  List < Integer > ans = new ArrayList < > ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    int num = a [ i ] ;
    if ( mp . containsKey ( num ) ) {
      ans . add ( 0 ) ;
    }
    else {
      int cnt = 0 ;
      while ( s [ 0 ] != num ) {
        mp . put ( s [ 0 ] , true ) ;
        s . remove ( 0 ) ;
        cnt ++ ;
      }
      s . remove ( 0 ) ;
      cnt ++ ;
      ans . add ( cnt ) ;
    }
  }
  return ans . toArray ( new Integer [ ans . size ( ) ] ) ;
}

***Example ends here:
int maxDistinctChar ( String s , int n , int k ) {
  HashMap < Character , Integer > freq = new HashMap < > ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( freq . containsKey ( s . charAt ( i ) ) ) {
      freq . put ( s . charAt ( i ) , 1 ) ;
    }
    else {
      freq . put ( s . charAt ( i ) , 1 ) ;
    }
  }
  List < Integer > v = new ArrayList < > ( ) ;
  for ( Map . Entry < Character , Integer > entry : freq . entrySet ( ) ) {
    v . add ( entry . getValue ( ) ) ;
  }
  Collections . sort ( v ) ;
  for ( int i = 0 ;
  i < v . size ( ) ;
  i ++ ) {
    int mn = Math . min ( v . get ( i ) - 1 , k ) ;
    v . set ( i , v . get ( i ) - mn ) ;
    k -= mn ;
  }
  if ( k > 0 ) {
    for ( int i = 0 ;
    i < v . size ( ) ;
    i ++ ) {
      int mn = Math . min ( v . get ( i ) , k ) ;
      v . set ( i , v . get ( i ) - mn ) ;
      k -= mn ;
    }
  }
  int res = 0 ;
  for ( int i = 0 ;
  i < v . size ( ) ;
  i ++ ) {
    if ( v . get ( i ) == 1 ) {
      res ++ ;
    }
  }
  return res ;
}

***Example ends here:
int findKth ( int [ ] arr , int n , int k ) {
  HashMap < Integer , Integer > missing = new HashMap < > ( ) ;
  int count = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    missing . put ( arr [ i ] , 1 ) ;
  }
  int maxM = Collections . max ( arr ) ;
  int minM = Collections . min ( arr ) ;
  for ( int i = minM + 1 ;
  i < maxM ;
  i ++ ) {
    if ( ! missing . containsKey ( i ) ) {
      count ++ ;
    }
    if ( count == k ) {
      return i ;
    }
  }
  return - 1 ;
}

***Example ends here:
boolean isSameSort ( int [ ] a , int n ) {
  for ( int i = 0 ;
  i < n - 1 ;
  i ++ ) {
    if ( a [ i ] > a [ i + 1 ] ) {
      a [ i ] = a [ i + 1 ] ;
      i ++ ;
    }
  }
  for ( int i = 0 ;
  i < n - 1 ;
  i ++ ) {
    if ( a [ i ] > a [ i + 1 ] ) {
      return false ;
    }
  }
  return true ;
}

***Example ends here:
int maximumSum ( String s , int n , int k ) {
  int sum = 0 ;
  int [ ] freq = new int [ 256 ] ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    freq [ ( int ) s . charAt ( i ) ] ++ ;
  }
  Arrays . sort ( freq , Collections . reverseOrder ( ) ) ;
  for ( int i = 0 ;
  i < 256 ;
  i ++ ) {
    if ( k > freq [ i ] ) {
      sum += freq [ i ] * freq [ i ] ;
      k -= freq [ i ] ;
    }
    else {
      sum += freq [ i ] * k ;
      break ;
    }
  }
  return sum ;
}

***Example ends here:
int findMinOperations ( int [ ] arr , int n , int k ) {
  int operations = 0 ;
  for ( int i = 0 ;
  i < k ;
  i ++ ) {
    Map < Integer , Integer > freq = new HashMap < > ( ) ;
    for ( int j = i ;
    j < n ;
    j += k ) {
      freq . put ( arr [ j ] , freq . getOrDefault ( arr [ j ] , 0 ) + 1 ) ;
    }
    int max1 = 0 ;
    int num = 0 ;
    for ( Map . Entry < Integer , Integer > entry : freq . entrySet ( ) ) {
      if ( entry . getValue ( ) > max1 ) {
        max1 = entry . getValue ( ) ;
        num = entry . getKey ( ) ;
      }
    }
    for ( Map . Entry < Integer , Integer > entry : freq . entrySet ( ) ) {
      if ( entry . getKey ( ) != num ) {
        operations += entry . getValue ( ) ;
      }
    }
  }
  return operations ;
}

***Example ends here:
String [ ] subString ( String s , int n ) {
  String [ ] v = new String [ n ] ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    for ( int len = 1 ;
    len <= n - i ;
    len ++ ) {
      String find = s . substring ( i , i + len ) ;
      v [ i ] = find ;
    }
  }
  return v ;
}

***Example ends here:
boolean checkUniqueFrequency ( int [ ] arr , int n ) {
  Map < Integer , Integer > freq = new HashMap < > ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    freq . put ( arr [ i ] , freq . getOrDefault ( arr [ i ] , 0 ) + 1 ) ;
  }
  Set < Integer > uniqueFrequency = new HashSet < > ( ) ;
  for ( Integer i : freq . keySet ( ) ) {
    if ( uniqueFrequency . contains ( freq . get ( i ) ) ) {
      return false ;
    }
    else {
      uniqueFrequency . add ( freq . get ( i ) ) ;
    }
  }
  return true ;
}

***Example ends here:
int minCost ( String str1 , String str2 , int n ) {
  int cost = 0 ;
  char [ ] tmp = str1 . toCharArray ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( tmp [ i ] != str2 . charAt ( i ) ) {
      if ( i < n - 1 && tmp [ i + 1 ] != str2 . charAt ( i + 1 ) ) {
        tmp [ i ] = tmp [ i + 1 ] ;
        tmp [ i + 1 ] = tmp [ i ] ;
        cost ++ ;
      }
      else {
        cost ++ ;
      }
    }
  }
  return cost ;
}

***Example ends here:
boolean isValidNum ( String str ) {
  Map < Character , Integer > mp = new HashMap < > ( ) ;
  for ( int i = 0 ;
  i < str . length ( ) ;
  i ++ ) {
    if ( mp . containsKey ( ( char ) str . charAt ( i ) - '0' ) ) {
      return false ;
    }
    else if ( ( char ) str . charAt ( i ) - '0' > 5 ) {
      return false ;
    }
    else {
      mp . put ( ( char ) str . charAt ( i ) - '0' , 1 ) ;
    }
  }
  return true ;
}

***Example ends here:
int minimizeDiff ( int [ ] arr , int n , int k ) {
  int maxElement = Math . max ( arr . length , 0 ) ;
  int minElement = Math . min ( arr . length , 0 ) ;
  if ( maxElement - minElement <= k ) {
    return maxElement - minElement ;
  }
  int avg = ( maxElement + minElement ) / 2 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( arr [ i ] > avg ) {
      arr [ i ] -= k ;
    }
    else {
      arr [ i ] += k ;
    }
  }
  maxElement = Math . max ( arr . length , 0 ) ;
  minElement = Math . min ( arr . length , 0 ) ;
  return maxElement - minElement ;
}

***Example ends here:
int getMinCost ( int [ ] arr , int n ) {
  int minEle = Math . min ( arr . length , arr [ 0 ] ) ;
  return minEle * ( n - 1 ) ;
}

***Example ends here:
boolean possibility ( int [ ] m , int length , String s ) {
  int countOdd = 0 ;
  for ( int i = 0 ;
  i < length ;
  i ++ ) {
    if ( ( m [ s . charAt ( i ) - '0' ] & 1 ) != 0 ) {
      countOdd ++ ;
    }
    if ( countOdd > 1 ) {
      return false ;
    }
  }
  return true ;
}

***Example ends here:
int minimumCostOfBreaking ( int [ ] x , int [ ] y , int m , int n ) {
  int res = 0 ;
  Arrays . sort ( x , Collections . reverseOrder ( ) ) ;
  Arrays . sort ( y , Collections . reverseOrder ( ) ) ;
  int hzntl = 1 , vert = 1 ;
  int i = 0 , j = 0 ;
  while ( i < m && j < n ) {
    if ( x [ i ] > y [ j ] ) {
      res += x [ i ] * vert ;
      hzntl ++ ;
      i ++ ;
    }
    else {
      res += y [ j ] * hzntl ;
      vert ++ ;
      j ++ ;
    }
  }
  int total = 0 ;
  while ( i < m ) {
    total += x [ i ] ;
    i ++ ;
  }
  res += total * vert ;
  total = 0 ;
  while ( j < n ) {
    total += y [ j ] ;
    j ++ ;
  }
  res += total * hzntl ;
  return res ;
}

***Example ends here:
int findMaximumScore ( int [ ] a , int n ) {
  HashMap < Integer , Integer > freq = new HashMap < > ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( freq . containsKey ( a [ i ] ) ) {
      freq . put ( a [ i ] , 1 ) ;
    }
    else {
      freq . put ( a [ i ] , 1 ) ;
    }
  }
  int [ ] dp = new int [ Math . max ( a . length + 1 , 1 ) ] ;
  dp [ 0 ] = 0 ;
  dp [ 1 ] = freq . get ( 1 ) ;
  for ( int i = 2 ;
  i < dp . length ;
  i ++ ) {
    dp [ i ] = Math . max ( dp [ i - 1 ] , dp [ i - 2 ] + freq . get ( i ) * i ) ;
  }
  return dp [ dp . length - 1 ] ;
}

***Example ends here:
int countWays ( String s , String t , int k , int mod ) {
  int n = s . length ( ) ;
  int a = 0 ;
  int b = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    String p = s . substring ( i , n ) + s . substring ( 0 , i ) ;
    if ( p . equals ( t ) ) a ++ ;
    else b ++ ;
  }
  int [ ] dp1 = new int [ k + 1 ] ;
  int [ ] dp2 = new int [ k + 1 ] ;
  if ( s . equals ( t ) ) {
    dp1 [ 0 ] = 1 ;
    dp2 [ 0 ] = 0 ;
  }
  else {
    dp1 [ 0 ] = 0 ;
    dp2 [ 0 ] = 1 ;
  }
  for ( int i = 1 ;
  i <= k ;
  i ++ ) {
    dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod ;
    dp2 [ i ] = ( ( dp1 [ i - 1 ] * b ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod ;
  }
  return dp1 [ k ] ;
}

***Example ends here:
int findSubarraySum ( int [ ] arr , int n , int k ) {
  HashMap < Integer , Integer > prevSum = new HashMap < > ( ) ;
  int res = 0 ;
  int currSum = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    currSum += arr [ i ] ;
    if ( currSum == k ) {
      res ++ ;
    }
    if ( prevSum . containsKey ( ( currSum - k ) ) ) {
      res += prevSum . get ( currSum - k ) ;
    }
    prevSum . put ( currSum , prevSum . get ( currSum ) + 1 ) ;
  }
  return res ;
}

***Example ends here:
int maximumOccurrence ( String s ) {
  int n = s . length ( ) ;
  Map < String , Integer > freq = new HashMap < > ( ) ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    String temp = "" ;
    temp += s . charAt ( i ) ;
    freq . put ( temp , freq . getOrDefault ( temp , 0 ) + 1 ) ;
  }
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    for ( int j = i + 1 ;
    j < n ;
    j ++ ) {
      temp = "" ;
      temp += s . charAt ( i ) ;
      temp += s . charAt ( j ) ;
      freq . put ( temp , freq . getOrDefault ( temp , 0 ) + 1 ) ;
    }
  }
  int answer = - Integer . MAX_VALUE ;
  for ( Map . Entry < String , Integer > entry : freq . entrySet ( ) ) {
    answer = Math . max ( answer , entry . getValue ( ) ) ;
  }
  return answer ;
}

***Example ends here:
int countCharacters ( String [ ] strings , String [ ] chars ) {
  int res = 0 ;
  Map < Character , Integer > freq = new HashMap < > ( ) ;
  for ( int i = 0 ;
  i < chars . length ;
  i ++ ) {
    freq . put ( chars [ i ] , freq . get ( chars [ i ] ) + 1 ) ;
  }
  for ( String st : strings ) {
    boolean flag = true ;
    for ( char c : Collections . list ( st ) ) {
      if ( ! freq . containsKey ( c ) ) {
        flag = false ;
        break ;
      }
    }
    if ( flag ) {
      res += st . length ( ) ;
    }
  }
  return res ;
}

***Example ends here:
int distincSubString ( String p , String q , int k , int n ) {
  Set < String > ss = new HashSet < > ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    int sum = 0 ;
    String s = "" ;
    for ( int j = i ;
    j < n ;
    j ++ ) {
      int pos = p . charAt ( j ) - 'a' ;
      sum += q . charAt ( pos ) - '0' ;
      s += p . charAt ( j ) ;
      if ( sum <= k ) {
        ss . add ( s ) ;
      }
      else {
        break ;
      }
    }
  }
  return ss . size ( ) ;
}

***Example ends here:
int uniqueMorseRep ( String [ ] arr ) {
  String [ ] morseCode = {
    ".-" , "-..." , "-.-." , "-..." , "." , "..-." , "..-." , "..." , "..-." , "..." , "..-." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." , "..." }
    ;
    Set < String > st = new HashSet < String > ( ) ;
    int n = arr . length ;
    for ( int i = 0 ;
    i < n ;
    i ++ ) {
      String temp = "" ;
      int m = arr [ i ] . length ( ) ;
      for ( int j = 0 ;
      j < m ;
      j ++ ) {
        temp += morseCode [ ( int ) arr [ i ] . charAt ( j ) - 'a' ] ;
      }
      st . add ( temp ) ;
    }
    return st . size ( ) ;
  }
  
***Example ends here:
int countSubstrings ( String str , int k ) {
  int n = str . length ( ) ;
  int answer = 0 ;
  Map < Character , Integer > map = new HashMap < > ( ) ;
  for ( int i = 0 ;
  i < k ;
  i ++ ) {
    if ( ! map . containsKey ( str . charAt ( i ) ) ) {
      map . put ( str . charAt ( i ) , 1 ) ;
    }
    else {
      map . get ( str . charAt ( i ) ) ++ ;
    }
  }
  if ( map . size ( ) == k ) {
    answer ++ ;
  }
  for ( int i = k ;
  i < n ;
  i ++ ) {
    if ( ! map . containsKey ( str . charAt ( i ) ) ) {
      map . put ( str . charAt ( i ) , 1 ) ;
    }
    else {
      map . get ( str . charAt ( i ) ) ++ ;
    }
    map . get ( str . charAt ( i - k ) ) -- ;
    if ( map . get ( str . charAt ( i - k ) ) == 0 ) {
      map . remove ( str . charAt ( i - k ) ) ;
    }
    if ( map . size ( ) == k ) {
      answer ++ ;
    }
  }
  return answer ;
}

***Example ends here:
boolean canConstruct ( String s , int k ) {
  Map < Character , Integer > m = new HashMap < > ( ) ;
  int p = 0 ;
  if ( s . length ( ) == k ) {
    return true ;
  }
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    m . put ( s . charAt ( i ) , m . getOrDefault ( s . charAt ( i ) , 0 ) + 1 ) ;
  }
  if ( k > s . length ( ) ) {
    return false ;
  }
  else {
    for ( Map . Entry < Character , Integer > entry : m . entrySet ( ) ) {
      if ( entry . getValue ( ) % 2 != 0 ) {
        p = p + 1 ;
      }
    }
  }
  if ( k < p ) {
    return false ;
  }
  return true ;
}

***Example ends here:
boolean equalsIgnoreCase ( String str1 , String str2 ) {
  str1 = str1 . toUpperCase ( ) ;
  str2 = str2 . toUpperCase ( ) ;
  return str1 . equals ( str2 ) ;
}

***Example ends here:
int findLongestSub ( String bin ) {
  int n = bin . length ( ) ;
  int sum = 0 ;
  Map < Integer , Integer > prevSum = new HashMap < > ( ) ;
  int maxLen = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( bin . charAt ( i ) == "1" ) {
      sum += 1 ;
    }
    else {
      sum -= 1 ;
    }
    if ( sum > 0 ) {
      maxLen = i + 1 ;
    }
    else if ( sum <= 0 ) {
      if ( prevSum . containsKey ( ( sum - 1 ) ) ) {
        int currLen = i - prevSum . get ( sum - 1 ) ;
        maxLen = Math . max ( maxLen , currLen ) ;
      }
    }
    if ( ! prevSum . containsKey ( sum ) ) {
      prevSum . put ( sum , i ) ;
    }
  }
  return maxLen ;
}

***Example ends here:
boolean hasAllCodes ( String s , int k ) {
  Set < String > us = new HashSet < > ( ) ;
  for ( int i = 0 ;
  i < s . length ( ) + 1 ;
  i ++ ) {
    us . add ( s . substring ( i , k ) ) ;
  }
  return us . size ( ) == 1 << k ;
}

***Example ends here:
boolean checkPalin ( String word ) {
  int n = word . length ( ) ;
  word = word . toLowerCase ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( word . charAt ( i ) != word . charAt ( n - 1 ) ) {
      return false ;
    }
    n -- ;
  }
  return true ;
}

***Example ends here:
String convert ( String st ) {
  String w = "" ;
  String z = "" ;
  st = st . toUpperCase ( ) + " " ;
  for ( int i = 0 ;
  i < st . length ( ) ;
  i ++ ) {
    char ch = st . charAt ( i ) ;
    if ( ch != ' ' ) {
      w += ch ;
    }
    else {
      z += w . substring ( 0 , 1 ) . toLowerCase ( ) + w . substring ( 1 , w . length ( ) ) + " " ;
      w = "" ;
    }
  }
  return z ;
}

***Example ends here:
int maxLines ( int n , int [ ] x1 , int [ ] y1 , int [ ] x2 , int [ ] y2 ) {
  HashSet < Integer > s = new HashSet < > ( ) ;
  int slope = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( x1 [ i ] == x2 [ i ] ) {
      slope = Integer . MAX_VALUE ;
    }
    else {
      slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) ;
    }
    s . add ( slope ) ;
  }
  return s . size ( ) ;
}

***Example ends here:
HashMap primeFactor ( int n ) {
  HashMap primef = new HashMap ( ) ;
  while ( n % 2 == 0 ) {
    if ( primef . containsKey ( 2 ) ) {
      primef . put ( 2 , 1 ) ;
    }
    else {
      primef . put ( 2 , 1 ) ;
    }
    n = n / 2 ;
  }
  for ( int i = 3 ;
  i <= ( int ) Math . sqrt ( n ) ;
  i += 2 ) {
    while ( n % i == 0 ) {
      if ( primef . containsKey ( i ) ) {
        primef . put ( i , 1 ) ;
      }
      else {
        primef . put ( i , 1 ) ;
      }
      n = n / i ;
    }
  }
  if ( n > 2 ) {
    primef . put ( n , 1 ) ;
  }
  return primef ;
}

***Example ends here:
String isDivisibleByDivisor ( String s , int d ) {
  s %= d ;
  HashSet < String > hashMap = new HashSet < > ( ) ;
  hashMap . add ( s ) ;
  for ( int i = 0 ;
  i < d + 1 ;
  i ++ ) {
    s += s % d ;
    s %= d ;
    if ( hashMap . contains ( s ) ) {
      if ( s . equals ( 0 ) ) {
        return "Yes" ;
      }
      return "No" ;
    }
    else {
      hashMap . add ( s ) ;
    }
  }
  return "Yes" ;
}

***Example ends here:
boolean oddSum ( int [ ] a , int n , int k ) {
  Set < Integer > odd = new HashSet < > ( ) ;
  Set < Integer > even = new HashSet < > ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( a [ i ] % 2 == 0 ) {
      even . add ( a [ i ] ) ;
    }
    else {
      odd . add ( a [ i ] ) ;
    }
  }
  if ( odd . size ( ) >= k ) {
    return true ;
  }
  boolean flag = false ;
  for ( int i = 1 ;
  i < k ;
  i += 2 ) {
    int needed = k - i ;
    if ( needed <= even . size ( ) ) {
      return true ;
    }
  }
  return flag ;
}

***Example ends here:
int dayOfYear ( String date ) {
  int [ ] days = {
    31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }
    ;
    int year = Integer . parseInt ( date . substring ( 0 , 4 ) ) ;
    int month = Integer . parseInt ( date . substring ( 5 , 7 ) ) ;
    int day = Integer . parseInt ( date . substring ( 8 ) ) ;
    if ( month > 2 && year % 4 == 0 && ( year % 100 != 0 || year % 400 == 0 ) ) {
      day ++ ;
    }
    while ( month > 1 ) {
      day = day + days [ month - 2 ] ;
      month -- ;
    }
    return day ;
  }
  
***Example ends here:
boolean isPerfectSquare ( int [ ] arr , int n ) {
  HashMap < Integer , Integer > umap = new HashMap < > ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    umap . put ( arr [ i ] , umap . getOrDefault ( arr [ i ] , 0 ) + 1 ) ;
  }
  for ( Map . Entry < Integer , Integer > entry : umap . entrySet ( ) ) {
    if ( entry . getValue ( ) % 2 == 1 ) {
      return false ;
    }
  }
  return true ;
}

***Example ends here:
int minMoves ( int n ) {
  String s = String . valueOf ( n ) ;
  int ans = Integer . MAX_VALUE ;
  int length = s . length ( ) ;
  for ( int i = 0 ;
  i < length ;
  i ++ ) {
    for ( int j = 0 ;
    j < length ;
    j ++ ) {
      if ( i == j ) continue ;
      char [ ] t = s . toCharArray ( ) ;
      int cur = 0 ;
      for ( int k = i ;
      k < length - 1 ;
      k ++ ) {
        t [ k ] = t [ k + 1 ] ;
        cur ++ ;
      }
      for ( int k = j - ( j > i ) ;
      k < length - 2 ;
      k ++ ) {
        t [ k ] = t [ k + 1 ] ;
        cur ++ ;
      }
      int pos = - 1 ;
      for ( int k = 0 ;
      k < length ;
      k ++ ) {
        if ( t [ k ] != '0' ) {
          pos = k ;
          break ;
        }
      }
      for ( int k = pos ;
      k > 0 ;
      k -- ) {
        t [ k ] = t [ k - 1 ] ;
        cur ++ ;
      }
    }
    int nn = Integer . parseInt ( String . valueOf ( t ) ) ;
    if ( nn % 25 == 0 ) ans = Math . min ( ans , cur ) ;
  }
  return ans ;
}

***Example ends here:
int minimumOperations ( int [ ] a , int n ) {
  HashMap < Integer , Integer > mp = new HashMap < > ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    mp . put ( a [ i ] , mp . getOrDefault ( a [ i ] , 0 ) + 1 ) ;
  }
  int count = 0 ;
  for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) {
    if ( entry . getValue ( ) > 1 ) {
      count += entry . getValue ( ) - 1 ;
    }
  }
  return count ;
}

***Example ends here:
int kaprekarRec ( int n , int prev ) {
  if ( n == 0 ) {
    return 0 ;
  }
  prev = n ;
  int [ ] digits = new int [ 4 ] ;
  for ( int i = 0 ;
  i < 4 ;
  i ++ ) {
    digits [ i ] = n % 10 ;
    n = n / 10 ;
  }
  Arrays . sort ( digits ) ;
  int asc = 0 ;
  for ( int i = 0 ;
  i < 4 ;
  i ++ ) {
    asc = asc * 10 + digits [ i ] ;
  }
  Arrays . sort ( digits ) ;
  int desc = 0 ;
  for ( int i = 3 ;
  i >= 0 ;
  i -- ) {
    desc = desc * 10 + digits [ i ] ;
  }
  int diff = Math . abs ( asc - desc ) ;
  if ( diff == prev ) {
    return diff ;
  }
  return kaprekarRec ( diff , prev ) ;
}

***Example ends here:
String fractionToDecimal ( int numr , int denr ) {
  String res = "" ;
  HashMap < Integer , Integer > mp = new HashMap ( ) ;
  int rem = numr % denr ;
  while ( rem != 0 && ! mp . containsKey ( rem ) ) {
    mp . put ( rem , res . length ( ) ) ;
    rem = rem * 10 ;
    int resPart = rem / denr ;
    res += String . valueOf ( resPart ) ;
    rem = rem % denr ;
  }
  if ( rem == 0 ) {
    return "" ;
  }
  if ( mp . containsKey ( rem ) ) {
    return res . substring ( mp . get ( rem ) ) ;
  }
  return "" ;
}

***Example ends here:
boolean isFancy ( String num ) {
  HashMap < Character , Character > is = new HashMap < > ( ) ;
  is . put ( '0' , '0' ) ;
  is . put ( '1' , '1' ) ;
  is . put ( '6' , '9' ) ;
  is . put ( '8' , '8' ) ;
  is . put ( '9' , '6' ) ;
  int n = num . length ( ) ;
  int l = 0 , r = n - 1 ;
  while ( l <= r ) {
    if ( ! is . containsKey ( num . charAt ( l ) ) || is . get ( num . charAt ( l ) ) != num . charAt ( r ) ) {
      return false ;
    }
    l ++ ;
    r -- ;
  }
  return true ;
}

***Example ends here:
double distincOddRatio ( int [ ] numbers ) {
  int distincCount = Arrays . stream ( numbers ) . mapToInt ( Integer :: intValue ) . sum ( ) ;
  int distincOddCount = Arrays . stream ( numbers ) . filter ( n -> n % 2 == 1 ) . mapToInt ( Integer :: intValue ) . sum ( ) ;
  return distincOddCount / distincCount ;
}

***Example ends here:
int compareSum ( int [ ] numbers , String [ ] words ) {
  int intSum = Arrays . stream ( numbers ) . mapToInt ( String :: valueOf ) . sum ( ) ;
  int wordLengthSum = Arrays . stream ( words ) . mapToInt ( String :: valueOf ) . sum ( ) ;
  if ( intSum < wordLengthSum ) {
    return - 1 ;
  }
  else if ( intSum > wordLengthSum ) {
    return 1 ;
  }
  else {
    return 0 ;
  }
}

***Example ends here:
boolean allLongerThan ( String [ ] shortWords , String [ ] longWords ) {
  int maxOfShort = Math . max ( shortWords . length , longWords . length ) ;
  int minOfLong = Math . min ( longWords . length , longWords . length ) ;
  return minOfLong > maxOfShort ;
}

***Example ends here:
int compareOddEvenRange ( int [ ] numbers ) {
  int rangeOdd = Math . max ( numbers . length , numbers [ 0 ] ) ;
  int rangeEven = Math . max ( numbers . length , numbers [ 1 ] ) ;
  if ( rangeOdd < rangeEven ) {
    return - 1 ;
  }
  if ( rangeOdd > rangeEven ) {
    return 1 ;
  }
  return 0 ;
}

***Example ends here:
int averageDistinctLength ( String [ ] words ) {
  Set < String > distincWords = new HashSet < > ( Arrays . asList ( words ) ) ;
  int averageLen = distincWords . size ( ) > 0 ? Arrays . stream ( distincWords ) . mapToInt ( String :: length ) . sum ( ) / distincWords . size ( ) : 0 ;
  return averageLen ;
}

***Example ends here:
double withdrawBalance ( double start , double withdrawals ) {
  double end = Math . pow ( withdrawals , 2 ) ;
  return end ;
}

***Example ends here:
String firstShortAndStartsWithO ( String [ ] words ) {
  String matchedElement = ( String ) Arrays . stream ( words ) . filter ( w1 -> w1 . length ( ) < 5 ) . findFirst ( ) . orElse ( "" ) ;
  return matchedElement ;
}

***Example ends here:
int bigNumberAtIndex ( int [ ] numbers , int index ) {
  int targetNum = numbers . length ;
  for ( int n : numbers ) {
    if ( n > 5 ) {
      targetNum += n ;
    }
  }
  return targetNum ;
}

***Example ends here:
boolean containsSquareInRange ( int rangeStart , int rangeLength ) {
  boolean containsSquare = Arrays . stream ( rangeStart , rangeStart + rangeLength ) . anyMatch ( n -> ( int ) Math . sqrt ( n ) * n == n ) ;
  return containsSquare ;
}

***Example ends here:
Map < String , List < String >> groupNumbersByMod ( String [ ] numbers , int mod ) {
  Map < String , List < String >> numberGroups = new HashMap < > ( ) ;
  for ( String k : Arrays . stream ( numbers ) . map ( n -> n % mod ) . collect ( Collectors . toList ( ) ) ) {
    numberGroups . put ( k , numberGroups . get ( k ) ) ;
  }
  return numberGroups ;
}

***Example ends here:
Map < String , List < String >> groupWordsByFirstChar ( String [ ] words ) {
  Map < String , List < String >> wordGroups = new HashMap < > ( ) ;
  for ( String k : new ArrayList < > ( Arrays . asList ( words ) ) ) {
    List < String > g = new ArrayList < > ( ) ;
    g . add ( k ) ;
    wordGroups . put ( k , wordGroups . get ( k ) , Collections . unmodifiableList ( g ) ) ;
  }
  return wordGroups ;
}

***Example ends here:
String [ ] orderByLengthAndDescending ( String [ ] words ) {
  String [ ] sortedWords = new String [ words . length ] ;
  System . arraycopy ( words , 0 , sortedWords , 0 , words . length ) ;
  return sortedWords ;
}

***Example ends here:
String [ ] orderFirstCharDescendingReverse ( String [ ] words ) {
  String [ ] sortedWords = new String [ words . length ] ;
  System . arraycopy ( words , 0 , sortedWords , 0 , words . length ) ;
  return sortedWords ;
}

***Example ends here:
int [ ] getSureOfNegative ( int [ ] numbers , int start , int length ) {
  int [ ] subArray = new int [ numbers . length ] ;
  for ( int n = start ;
  n < numbers . length ;
  n ++ ) {
    subArray [ n ] = numbers [ n ] ;
  }
  return subArray ;
}

***Example ends here:
int getPositiveSequence ( int [ ] numbers ) {
  int [ ] subSequence = new int [ numbers . length ] ;
  System . arraycopy ( numbers , 0 , subSequence , 0 , numbers . length ) ;
  return subSequence [ numbers . length ] ;
}

***Example ends here:
int [ ] getLargerThanIndexSequence ( int [ ] numbers ) {
  int [ ] subSequence = new int [ numbers . length ] ;
  for ( int i = 0 ;
  i < numbers . length ;
  i ++ ) {
    subSequence [ i ] = numbers [ i ] ;
  }
  return subSequence ;
}

***Example ends here:
String [ ] rearrangeWordByIndexes ( String [ ] words , int [ ] indexes ) {
  int [ ] newIndexes = new int [ indexes . length ] ;
  for ( int n : indexes ) {
    if ( n >= words . length ) newIndexes [ n ] = n % words . length ;
  }
  String [ ] newWords = new String [ newIndexes . length ] ;
  for ( int n : newIndexes ) newWords [ n ] = words [ n ] ;
  return newWords ;
}

***Example ends here:
String [ ] getWordsUpperLower ( String [ ] words ) {
  String [ ] upperLowerWords = new String [ words . length ] ;
  for ( int i = 0 ;
  i < words . length ;
  i ++ ) {
    upperLowerWords [ i ] = words [ i ] . toUpperCase ( ) ;
  }
  return upperLowerWords ;
}

***Example ends here:
int [ ] selectIfInPlace ( int [ ] numbers ) {
  int [ ] numsInPlace = new int [ numbers . length ] ;
  for ( int index = 0 ;
  index < numsInPlace . length ;
  index ++ ) {
    numsInPlace [ index ] = numbers [ index ] ;
  }
  return numsInPlace ;
}

***Example ends here:
int [ ] [ ] selectPairs ( int [ ] numbersA , int [ ] numbersB ) {
  int [ ] [ ] pairs = new int [ numbersA . length ] [ numbersB . length ] ;
  for ( int a = 0 ;
  a < numbersA . length ;
  a ++ ) for ( int b = 0 ;
  b < numbersB . length ;
  b ++ ) if ( numbersA [ a ] < numbersB [ b ] ) return pairs [ a ] ;
  return pairs ;
}

***Example ends here:
String [ ] stringCrossJoin ( String [ ] endWords , String [ ] beginWords ) {
  String [ ] crossStrings = new String [ beginWords . length ] ;
  for ( String b : beginWords ) for ( String e : endWords ) if ( b . charAt ( 0 ) == e . charAt ( b . length ( ) - 1 ) ) return crossStrings ;
  return null ;
}

***Example ends here:
int elementsContainSubWord ( String [ ] words , String subWord ) {
  if ( Arrays . binarySearch ( words , subWord ) >= 0 ) {
    return 1 ;
  }
  else if ( Arrays . binarySearch ( words , subWord ) >= 0 ) {
    return 0 ;
  }
  else {
    return - 1 ;
  }
}

***Example ends here:
String [ ] concatLargeNumbers ( String [ ] numbersA , String [ ] numbersB , int flag ) {
  String [ ] allNumbers = new String [ numbersA . length + numbersB . length ] ;
  System . arraycopy ( numbersA , 0 , allNumbers , 0 , numbersA . length ) ;
  System . arraycopy ( numbersB , 0 , allNumbers , numbersB . length , numbersA . length ) ;
  return allNumbers ;
}

***Example ends here:
double dotProduct ( double [ ] vectorA , double [ ] vectorB ) {
  double dotProduct = Arrays . stream ( vectorA ) . sum ( ) ;
  return dotProduct ;
}

***Example ends here:
int setDifference ( int [ ] setA , int [ ] setB ) {
  int [ ] difference = new int [ setA . length ] ;
  System . arraycopy ( setA , 0 , difference , 0 , setA . length ) ;
  System . arraycopy ( setB , 0 , difference , setA . length , setB . length ) ;
  return difference . length ;
}

***Example ends here:
