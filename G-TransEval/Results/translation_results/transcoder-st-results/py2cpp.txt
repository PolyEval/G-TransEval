int greatestCommonDivisor ( int a , int b ) throw ( ) {
  if ( a == 0 || b == 0 ) return a + b ;
  if ( a == b ) return a ;
  if ( a > b ) return greatestCommonDivisor ( a % b , b ) ;
  else return greatestCommonDivisor ( a , b % a ) ;
}

***Example ends here:
int largest_divisor ( int n ) {
  for ( int i = 2 ;
  i <= n ;
  i ++ ) {
    if ( n % i == 0 ) return n / i ;
  }
  return 1 ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
}

***Example ends here:
bool isPrime ( int n ) {
  if ( n < 2 ) return false ;
  for ( int k = 2 ;
  k < n ;
  k ++ ) {
    if ( n % k == 0 ) return false ;
  }
  return true ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
}

***Example ends here:
int fizzBuzz ( int n ) {
  int count = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( i % 11 == 0 || i % 13 == 0 ) {
      int q = i ;
      while ( q > 0 ) {
        if ( q % 10 == 7 ) count ++ ;
        q /= 10 ;
      }
    }
  }
  return count ;
  return n * n ;
}

***Example ends here:
int primeFib ( int n ) {
  int f0 = 0 ;
  int f1 = 1 ;
  while ( n -- > 0 ) {
    int p = f0 + f1 ;
    bool isPrime = p >= 2 ;
    for ( int i = 2 ;
    i < p ;
    i ++ ) {
      if ( p % i == 0 ) {
        isPrime = false ;
        break ;
      }
    }
    if ( isPrime ) n -- ;
    f0 = f1 ;
    f1 = p ;
  }
  return f1 ;
}

***Example ends here:
double triangleArea ( double a , double h ) {
  return a * h / 2 ;
}

***Example ends here:
int modp ( int n , int p ) {
  int ret = 1 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) ret = ( ret * 2 ) % p ;
  return ret ;
  return n * n ;
}

***Example ends here:
int add ( int x , int y ) {
  return x + y ;
}

***Example ends here:
int fib ( int n ) {
  if ( n == 0 ) return 0 ;
  if ( n == 1 ) return 1 ;
  return fib ( n - 1 ) + fib ( n - 2 ) ;
  return n * n ;
}

***Example ends here:
int largest_prime_factor ( int n ) {
  for ( int i = 2 ;
  i < n ;
  i ++ ) {
    while ( n % i == 0 && n > i ) n /= i ;
  }
  return n ;
}

***Example ends here:
int sumToN ( int n ) {
  int result = 0 ;
  for ( int i = 1 ;
  i <= n ;
  i ++ ) result += i ;
  return result ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
}

***Example ends here:
int fibfib ( int n ) {
  if ( n == 0 ) return 0 ;
  if ( n == 1 ) return 0 ;
  if ( n == 2 ) return 1 ;
  return fibfib ( n - 1 ) + fibfib ( n - 2 ) + fibfib ( n - 3 ) ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
}

***Example ends here:
bool isMultPrime ( int a ) {
  int num = 0 ;
  for ( int i = 2 ;
  i <= a ;
  i ++ ) {
    while ( a % i == 0 && a >= i ) {
      a /= i ;
      num ++ ;
    }
  }
  return num == 3 ;
  return a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a ;
}

***Example ends here:
bool isSimplePower ( int x , int n ) {
  if ( n == 1 ) return x == 1 ;
  int power = 1 ;
  while ( power < x ) power *= n ;
  return power == x ;
  return x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x ;
}

***Example ends here:
int chooseNum ( int x , int y ) {
  if ( x > y ) return - 1 ;
  if ( y % 2 == 0 ) return y ;
  if ( x == y ) return - 1 ;
  return y - 1 ;
  return x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x ;
}

***Example ends here:
bool isEqualToSumEven ( int n ) {
  return n % 2 == 0 && n >= 8 ;
}

***Example ends here:
int specialFactorial ( int n ) {
  int fact = 1 ;
  int specialFactorial = 1 ;
  for ( int i = 1 ;
  i <= n ;
  i ++ ) {
    fact *= i ;
    specialFactorial *= fact ;
  }
  return specialFactorial ;
}

***Example ends here:
int xOrY ( int n , int x , int y ) {
  bool isPrime = n >= 2 ;
  for ( int i = 2 ;
  i < n ;
  i ++ ) {
    if ( n % i == 0 ) {
      isPrime = false ;
      break ;
    }
  }
  if ( isPrime ) return x ;
  return y ;
}

***Example ends here:
bool rightAngleTriangle ( double a , double b , double c ) {
  return a * a == b * b + c * c || b * b == a * a + c * c || c * c == a * a + b * b ;
}

***Example ends here:
int fastPow ( int n , int k ) {
  if ( k == 0 ) return 1 ;
  int temp = fastPow ( n , k / 2 ) ;
  if ( k % 2 == 0 ) return temp * temp ;
  else return n * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp ;
}

***Example ends here:
bool is_palin ( string s ) {
  int l = s . length ( ) / 2 ;
  for ( int i = 0 ;
  i < l ;
  i ++ ) {
    if ( s [ i ] != s [ s . length ( ) - i - 1 ] ) return false ;
  }
  return true ;
}

***Example ends here:
int findSum ( int n ) {
  int ans = 0 ;
  int temp = 0 ;
  for ( int i = 1 ;
  i <= n ;
  i ++ ) {
    if ( ! temp < n ) break ;
    temp = i - 1 ;
    int num = 1 ;
    while ( temp < n ) {
      if ( temp + i <= n ) ans += i * num ;
      else ans += ( n - temp ) * num ;
      temp += i ;
      num ++ ;
    }
  }
  return ans ;
  return n * n ;
}

***Example ends here:
int getNextGap ( int gap ) {
  gap = gap * 10 / 13 ;
  if ( gap < 1 ) return 1 ;
  return gap ;
  return gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap * gap ;
}

***Example ends here:
int countNonDecreasing ( int n ) {
  int k = 10 ;
  int count = 1 ;
  for ( int i = 1 ;
  i <= n ;
  i ++ ) {
    count *= k + i - 1 ;
    count /= i ;
  }
  return count ;
}

***Example ends here:
int power ( int x , int y ) {
  if ( y == 0 ) return 1 ;
  else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ;
  else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ;
}

***Example ends here:
double power ( double x , int y ) {
  if ( y == 0 ) return 1 ;
  double temp = power ( x , y / 2 ) ;
  if ( y % 2 == 0 ) return temp * temp ;
  else {
    if ( y > 0 ) return x * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp * temp ;
  }
  return x ;
}

***Example ends here:
int multiply ( int x , int y ) {
  if ( y == 0 ) return 0 ;
  if ( y > 0 ) return x + multiply ( x , y - 1 ) ;
  if ( y < 0 ) return - multiply ( x , - y ) ;
  return x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x ;
}

***Example ends here:
int smallest ( int x , int y , int z ) {
  if ( ! y / x ) return ( ! y / z ) ? y : z ;
  return ( ! x / z ) ? x : z ;
  return x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x * x ;
}

***Example ends here:
bool isPowerOfFour ( int n ) {
  if ( n == 0 ) return false ;
  while ( n != 1 ) {
    if ( n % 4 != 0 ) return false ;
    n = n / 4 ;
  }
  return true ;
}

***Example ends here:
int modInverse ( int a , int m ) {
  int m0 = m ;
  int x0 = 0 , x1 = 1 ;
  if ( m == 1 ) return 0 ;
  while ( a > 1 ) {
    int q = a / m ;
    int t = m ;
    m = a % m ;
    a = t ;
    t = x0 ;
    x0 = x1 - q * x0 ;
    x1 = t ;
  }
  if ( x1 < 0 ) x1 += m0 ;
  return x1 ;
  return a * a ;
}

***Example ends here:
int cnt_rotations ( string s , int n ) {
  string s2 = s + s ;
  vector < int > pre ( 2 * n , 0 ) ;
  for ( int i = 0 ;
  i < 2 * n ;
  i ++ ) {
    if ( i != 0 ) pre [ i ] += pre [ i - 1 ] ;
    if ( s2 [ i ] == 'a' || s2 [ i ] == 'e' || s2 [ i ] == 'i' || s2 [ i ] == 'o' || s2 [ i ] == 'u' ) pre [ i ] ++ ;
  }
  int ans = 0 ;
  for ( int i = n - 1 ;
  i > 2 * n - 1 ;
  i -- ) {
    int r = i , l = i - n ;
    int x1 = pre [ r ] ;
    if ( l >= 0 ) x1 -= pre [ l ] ;
    r = i - n / 2 ;
    int left = pre [ r ] ;
    if ( l >= 0 ) left -= pre [ l ] ;
    int right = x1 - left ;
    if ( left > right ) ans ++ ;
  }
  return ans ;
  return n * n ;
}

***Example ends here:
int binomial_coeff ( int n , int k ) {
  int res = 1 ;
  if ( k > n - k ) k = n - k ;
  for ( int i = 0 ;
  i < k ;
  i ++ ) {
    res *= n - i ;
    res /= i + 1 ;
  }
  return res ;
}

***Example ends here:
bool isPrefix ( string temp , string s ) {
  if ( temp . length ( ) < s . length ( ) ) return false ;
  else {
    for ( int i = 0 ;
    i < s . length ( ) ;
    i ++ ) if ( ( s [ i ] != temp [ i ] ) ) return false ;
    return true ;
  }
}

***Example ends here:
string lexicographicallySmallestString ( string s , int n ) {
  int lastEze = - 1 ;
  string ans ;
  for ( int i = n - 1 ;
  i >= 0 ;
  i -- ) {
    if ( s [ i ] == '0' ) {
      lastEze = i ;
      break ;
    }
  }
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( i <= lastEze && s [ i ] == '0' ) ans += s [ i ] ;
    else if ( i > lastEze ) ans += s [ i ] ;
  }
  return ans ;
  return " " + s + " " + s ;
}

***Example ends here:
int calculateMax ( int n , int m , int k ) {
  int ans = - 1 ;
  int low = 0 , high = m ;
  while ( low <= high ) {
    int mid = ( low + high ) / 2 ;
    int val = 0 ;
    int l = k - 1 ;
    int r = n - k ;
    val += mid ;
    if ( mid >= l ) val += l * ( 2 * mid - l - 1 ) / 2 ;
    else val += mid * ( mid - 1 ) / 2 + ( l - mid ) ;
    if ( mid >= r ) val += r * ( 2 * mid - r - 1 ) / 2 ;
    else val += mid * ( mid - 1 ) / 2 + ( r - mid ) ;
    if ( val <= m ) {
      ans = max ( ans , mid ) ;
      low = mid + 1 ;
    }
    else high = mid - 1 ;
  }
  return ans ;
  return n * n ;
}

***Example ends here:
int findLength ( string s , int i , int j ) {
  int required = i ;
  int length = 0 ;
  for ( int curr = 0 ;
  curr < s . length ( ) ;
  curr ++ ) {
    if ( s [ curr ] == required ) {
      length ++ ;
      if ( required == i ) required = j ;
      else required = i ;
    }
  }
  return length ;
  return i * i ;
}

***Example ends here:
bool checkReverse ( int leftSum , int rightSum ) {
  int rev = 0 ;
  int temp = rightSum ;
  while ( temp != 0 ) {
    rev = rev * 10 + temp % 10 ;
    temp /= 10 ;
  }
  if ( rev == leftSum ) return true ;
  return false ;
  return leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum * leftSum ;
}

***Example ends here:
bool isComposite ( int n ) {
  if ( n <= 1 ) return false ;
  if ( n <= 3 ) return false ;
  if ( n % 2 == 0 || n % 3 == 0 ) return true ;
  for ( int i = 5 ;
  i <= n + 1 ;
  i += 6 ) {
    if ( i * i > n ) break ;
    if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ;
  }
  return false ;
}

***Example ends here:
int minDeletion ( string s ) {
  int n = s . length ( ) ;
  int firstId1 = - 1 ;
  int lastIdx0 = - 1 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( s [ i ] == '1' ) {
      firstId1 = i ;
      break ;
    }
  }
  for ( int i = n - 1 ;
  i >= 0 ;
  i -- ) {
    if ( s [ i ] == '0' ) {
      lastIdx0 = i ;
      break ;
    }
  }
  if ( firstId1 == - 1 || lastIdx0 == - 1 ) return 0 ;
  int count1 = 0 , count0 = 0 ;
  for ( int i = 0 ;
  i <= lastIdx0 ;
  i ++ ) {
    if ( s [ i ] == '1' ) count1 ++ ;
  }
  for ( int i = firstId1 + 1 ;
  i < n ;
  i ++ ) {
    if ( s [ i ] == '1' ) count0 ++ ;
  }
  return min ( count0 , count1 ) ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
}

***Example ends here:
int minSteps ( string s , int n ) {
  int cost = 0 ;
  vector < int > f ( 26 , 0 ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    int currEle = s [ i ] - 'a' ;
    int smaller = 0 ;
    for ( int j = 0 ;
    j < currEle + 1 ;
    j ++ ) {
      if ( f [ j ] != 0 ) smaller += f [ j ] ;
    }
    if ( smaller == 0 ) cost += i + 1 ;
    else cost += i - smaller + 1 ;
    f [ s [ i ] - 'a' ] ++ ;
  }
  return cost ;
  return n * n ;
}

***Example ends here:
int numberOfWays ( int n ) {
  int count = 0 ;
  for ( int a = 1 ;
  a < n ;
  a ++ ) {
    for ( int b = 1 ;
    b < n ;
    b ++ ) {
      int c = n - ( a + b ) ;
      if ( a < b + c && b < a + c && c < a + b ) count ++ ;
    }
  }
  return count ;
  return n * n ;
}

***Example ends here:
int slopeOfNum ( int * num , int n ) {
  int slope = 0 ;
  for ( int i = 1 ;
  i < n - 1 ;
  i ++ ) {
    if ( num [ i ] > num [ i - 1 ] && num [ i ] > num [ i + 1 ] ) slope ++ ;
    else if ( num [ i ] < num [ i - 1 ] && num [ i ] < num [ i + 1 ] ) slope ++ ;
  }
  return slope ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
}

***Example ends here:
int middleOfThree ( int a , int b , int c ) {
  int x = a - b ;
  int y = b - c ;
  int z = a - c ;
  if ( x * y > 0 ) return b ;
  else if ( x * z > 0 ) return c ;
  else return a ;
  return a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a ;
}

***Example ends here:
int countMaxSetBits ( int left , int right ) {
  while ( ( left | ( left + 1 ) ) <= right ) left |= left + 1 ;
  return left ;
  return left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left * left ;
}

***Example ends here:
int findS ( int s ) {
  int l = 1 ;
  int r = s / 2 + 1 ;
  while ( l <= r ) {
    int mid = ( l + r ) / 2 ;
    int sum = mid * ( mid + 1 ) / 2 ;
    if ( sum == s ) return mid ;
    else if ( sum > s ) r = mid - 1 ;
    else l = mid + 1 ;
  }
  return - 1 ;
}

***Example ends here:
bool check ( string s ) {
  int min = INT_MAX ;
  int max = - INT_MAX ;
  int sum = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    int ascii = s [ i ] ;
    if ( ascii < 96 || ascii > 122 ) return false ;
    sum += ascii ;
    if ( min > ascii ) min = ascii ;
    if ( max < ascii ) max = ascii ;
  }
  min -- ;
  int eSum = max * ( max + 1 ) / 2 - min * ( min + 1 ) / 2 ;
  return sum == eSum ;
  return sum * sum ;
}

***Example ends here:
int minimumPossibleProduct ( int k ) {
  int res = 1 ;
  int r = ( 1 << k ) - 1 ;
  for ( int i = 0 ;
  i < k ;
  i ++ ) res *= r - 1 ;
  res *= r ;
  return res ;
}

***Example ends here:
int findInGrid ( int i , int j ) {
  if ( i == j ) return i * i - ( i - 1 ) ;
  else if ( i > j ) {
    if ( i % 2 == 0 ) return i * i - ( j - 1 ) ;
    else return ( i - 1 ) * ( i - 1 ) + 1 + ( j - 1 ) ;
  }
  else {
    if ( j % 2 == 0 ) return ( j - 1 ) * ( j - 1 ) + 1 + ( i - 1 ) ;
    else return j * j - ( i - 1 ) ;
  }
  return i * i ;
}

***Example ends here:
int findMinOperationsReqEmpStr ( string s ) {
  int cntOne = 0 ;
  int cntZero = 0 ;
  int n = s . length ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( s [ i ] == '0' ) {
      if ( cntOne > 0 ) cntOne = cntOne - 1 ;
      cntZero = cntZero + 1 ;
    }
    else {
      if ( cntZero > 0 ) cntZero = cntZero - 1 ;
      cntOne = cntOne + 1 ;
    }
  }
  return cntOne + cntZero ;
  return n * n ;
}

***Example ends here:
bool isReachable ( int x1 , int y1 , int x2 , int y2 ) {
  while ( x2 > x1 && y2 > y1 ) {
    if ( x2 > y2 ) x2 %= y2 ;
    else y2 %= x2 ;
  }
  if ( x2 == x1 ) return y2 - y1 >= 0 && ( y2 - y1 ) % x1 == 0 ;
  else if ( y2 == y1 ) return x2 - x1 >= 0 && ( x2 - x1 ) % y1 == 0 ;
  else return false ;
}

***Example ends here:
int findMaxSoln ( int n , int x , int y ) {
  int ans = - INT_MAX ;
  for ( int k = 0 ;
  k < n + 1 ;
  k ++ ) {
    if ( k % x == y ) ans = max ( ans , k ) ;
  }
  return ans >= 0 && ans <= n ? ans : - 1 ;
}

***Example ends here:
int numberOfPairs ( int n ) {
  int count = 0 ;
  int i = 1 ;
  int j = n - 1 ;
  while ( i < j ) {
    if ( ( i + j ) == n ) count ++ ;
    i ++ ;
    j -- ;
  }
  return count ;
}

***Example ends here:
int minChanges ( string s , int n ) {
  int count = 0 , zeros = 0 , ones = 0 ;
  if ( s [ 0 ] != '1' ) {
    count ++ ;
    ones ++ ;
  }
  for ( int i = 1 ;
  i < n ;
  i ++ ) {
    if ( s [ i ] == '0' ) zeros ++ ;
    else ones ++ ;
    if ( zeros > ones ) {
      zeros -- ;
      ones ++ ;
      count ++ ;
    }
  }
  return count ;
}

***Example ends here:
int kVisibleFromLeft ( int n , int k ) {
  if ( n == k ) return 1 ;
  if ( k == 1 ) {
    int ans = 1 ;
    for ( int i = 1 ;
    i < n ;
    i ++ ) ans *= i ;
    return ans ;
  }
  return kVisibleFromLeft ( n - 1 , k - 1 ) + ( n - 1 ) * kVisibleFromLeft ( n - 1 , k ) ;
}

***Example ends here:
double find ( int n , double sum ) {
  if ( sum > 6 * n || sum < n ) return 0 ;
  if ( n == 1 ) {
    if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ;
    else return 0 ;
  }
  double s = 0 ;
  for ( int i = 1 ;
  i < 7 ;
  i ++ ) s += find ( n - 1 , sum - i ) / 6 ;
  return s ;
}

***Example ends here:
int binCoff ( int n , int r ) {
  int val = 1 ;
  if ( r > ( n - r ) ) r = n - r ;
  for ( int i = 0 ;
  i < r ;
  i ++ ) {
    val *= n - i ;
    val /= i + 1 ;
  }
  return val ;
}

***Example ends here:
int getMask ( int val ) {
  int mask = 0 ;
  if ( val == 0 ) return 1 ;
  while ( val ) {
    int d = val % 10 ;
    mask |= ( 1 << d ) ;
    val /= 10 ;
  }
  return mask ;
}

***Example ends here:
int waysToKAdjacentSetBits ( int n , int k , int currentIndex , int adjacentSetBits , int lastBit ) {
  if ( currentIndex == n ) {
    if ( adjacentSetBits == k ) return 1 ;
    return 0 ;
  }
  int noOfWays = 0 ;
  if ( lastBit == 1 ) {
    noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ;
    noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ;
  }
  else if ( lastBit != 1 ) {
    noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) ;
    noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ;
  }
  return noOfWays ;
  return n * n ;
}

***Example ends here:
int checkMethod ( int i , int j , string st ) {
  if ( st [ i ] == '(' && st [ j ] == ')' ) return 1 ;
  if ( st [ i ] == '(' && st [ j ] == '?' ) return 1 ;
  if ( st [ i ] == '?' && st [ j ] == ')' ) return 1 ;
  if ( st [ i ] == '[' && st [ j ] == ']' ) return 1 ;
  if ( st [ i ] == '[' && st [ j ] == '?' ) return 1 ;
  if ( st [ i ] == '?' && st [ j ] == ']' ) return 1 ;
  if ( st [ i ] == '{' && st [ j ] == '}' ) return 1 ;
  if ( st [ i ] == '{' && st [ j ] == '?' ) return 1 ;
  if ( st [ i ] == '?' && st [ j ] == '}' ) return 1 ;
  return 0 ;
  return i * i ;
  return i * i ;
}

***Example ends here:
int findGolomb ( int n ) {
  if ( n == 1 ) return 1 ;
  return 1 + findGolomb ( n - findGolomb ( findGolomb ( n - 1 ) ) ) ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
}

***Example ends here:
bool allOnes ( string s , int n ) {
  int co = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) co += s [ i ] == '1' ? 1 : 0 ;
  return co == n ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
}

***Example ends here:
int pad ( int n ) {
  int p_prev_prev = 1 , p_prev = 1 , p_curr = 1 , p_next = 1 ;
  for ( int i = 3 ;
  i <= n ;
  i ++ ) {
    p_next = p_prev_prev + p_prev ;
    p_prev_prev = p_prev ;
    p_prev = p_curr ;
    p_curr = p_next ;
  }
  return p_next ;
  return n * n ;
}

***Example ends here:
int odd_length_palindrome ( int k ) {
  int palin = k ;
  k = k / 10 ;
  while ( k > 0 ) {
    int rev = k % 10 ;
    palin = palin * 10 + rev ;
    k = k / 10 ;
  }
  return palin ;
}

***Example ends here:
string changeString ( string s0 ) {
  string result = s0 ;
  int n = s0 . length ( ) ;
  if ( result [ 0 ] == '?' ) {
    result [ 0 ] = 'a' ;
    if ( result [ 0 ] == result [ 1 ] ) result [ 0 ] = ( char ) ( result [ 0 ] + 1 ) ;
  }
  for ( int i = 1 ;
  i < n - 1 ;
  i ++ ) {
    if ( result [ i ] == '?' ) {
      result [ i ] = 'a' ;
      if ( result [ i ] == result [ i - 1 ] ) result [ i ] = ( char ) ( result [ i ] + 1 ) ;
      if ( result [ i ] == result [ i + 1 ] ) result [ i ] = ( char ) ( result [ i ] + 1 ) ;
      if ( result [ i ] == result [ i - 1 ] ) result [ i ] = ( char ) ( result [ i ] + 1 ) ;
    }
  }
  if ( result [ n - 1 ] == '?' ) {
    result [ n - 1 ] = 'a' ;
    if ( result [ n - 1 ] == result [ n - 2 ] ) result [ n - 1 ] = ( char ) ( result [ n - 1 ] + 1 ) ;
  }
  return result ;
  return " " + s0 + " " + s0 ;
}

***Example ends here:
int totalHammingDistance ( int n ) {
  int i = 1 , sum = 0 ;
  while ( n / i > 0 ) {
    sum = sum + n / i ;
    i = i * 2 ;
  }
  return sum ;
}

***Example ends here:
int checkBitonic ( string s ) {
  int i = 1 ;
  for ( ;
  i < s . length ( ) ;
  i ++ ) {
    if ( s [ i ] > s [ i - 1 ] ) continue ;
    if ( s [ i ] <= s [ i - 1 ] ) break ;
  }
  if ( i == s . length ( ) - 1 ) return 1 ;
  int j = i + 1 ;
  for ( ;
  j + 1 < s . length ( ) ;
  j ++ ) {
    if ( s [ j ] < s [ j - 1 ] ) continue ;
    if ( s [ j ] >= s [ j - 1 ] ) break ;
  }
  i = j ;
  if ( i != s . length ( ) - 1 ) return 0 ;
  return 1 ;
  return 1 * 1 ;
  return 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 ;
}

***Example ends here:
bool ends_with ( string str , string pat ) {
  int pat_len = pat . length ( ) ;
  int str_len = str . length ( ) ;
  if ( pat_len > str_len ) return false ;
  pat_len -- ;
  str_len -- ;
  while ( pat_len >= 0 ) {
    if ( pat [ pat_len ] != str [ str_len ] ) return false ;
    pat_len -- ;
    str_len -- ;
  }
  return true ;
}

***Example ends here:
int getSum ( int n , int d ) {
  if ( n < d ) return 0 ;
  while ( n % 10 != d ) n -- ;
  int k = n / 10 ;
  return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ;
}

***Example ends here:
int balanced_string_by_swapping ( string s ) {
  int unbalanced_pair = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( unbalanced_pair > 0 && s [ i ] == ']' ) unbalanced_pair -- ;
    else if ( s [ i ] == '[' ) unbalanced_pair ++ ;
  }
  return ( unbalanced_pair + 1 ) / 2 ;
  return s . length ( ) ;
}

***Example ends here:
int computeHashCode ( string s ) {
  int p = 31 ;
  int mod = 10 * 9 + 7 ;
  int hashVal = 0 ;
  int mul = 1 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    char ch = s [ i ] ;
    hashVal = ( hashVal + ( ch - 'a' + 1 ) * mul ) % mod ;
    mul = mul * p % mod ;
  }
  return hashVal ;
}

***Example ends here:
int countOfSubstringWithOnlyOnes ( string s ) {
  int res = 0 , count = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    count = s [ i ] == '1' ? count + 1 : 0 ;
    res = res + count ;
  }
  return res ;
  return res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res
***Example ends here:
int composite ( int n ) {
  int flag = 0 ;
  int c = 0 ;
  for ( int j = 1 ;
  j <= n ;
  j ++ ) {
    if ( n % j == 0 ) c ++ ;
  }
  if ( c >= 3 ) flag = 1 ;
  return flag ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
}

***Example ends here:
bool is_div_by_six ( string s , int n ) {
  int sum = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) sum += s [ i ] - 'a' + 1 ;
  if ( sum % 3 != 0 ) return false ;
  int last_digit = ( s [ n - 1 ] - 'a' + 1 ) % 10 ;
  if ( last_digit % 2 != 0 ) return false ;
  return true ;
}

***Example ends here:
bool isRedundantBraces ( string s ) {
  int a = 0 , b = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( s [ i ] == '(' && s [ i + 2 ] == ')' ) return true ;
    if ( s [ i ] == '*' || s [ i ] == '+' || s [ i ] == '-' || s [ i ] == '/' ) a ++ ;
    if ( s [ i ] == '(' ) b ++ ;
  }
  if ( b > a ) return true ;
  return false ;
}

***Example ends here:
int countSubStr ( string s , int n ) {
  int count = 0 ;
  int i = 0 ;
  while ( i < ( n - 2 ) ) {
    if ( s [ i ] == '0' && s [ i + 1 ] == '1' && s [ i + 2 ] == '0' ) {
      count ++ ;
      i += 3 ;
    }
    else if ( s [ i ] == '1' && s [ i + 1 ] == '0' && s [ i + 2 ] == '1' ) {
      count ++ ;
      i += 3 ;
    }
    else {
      i ++ ;
    }
  }
  return count ;
  return n * n ;
}

***Example ends here:
int prefixOccurrences ( string s ) {
  char c = s [ 0 ] ;
  int countC = 0 ;
  for ( int i = 1 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( s [ i ] == c ) countC ++ ;
  }
  return countC ;
  return s . length ( ) ;
}

***Example ends here:
bool isValid ( string s , int len ) {
  for ( int i = 1 ;
  i < len ;
  i ++ ) {
    if ( s [ i ] == s [ i - 1 ] ) return false ;
  }
  return true ;
  return len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len * len *
***Example ends here:
int count ( string s , int k ) {
  int n = s . length ( ) ;
  int d = 0 ;
  int count = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) d += s [ i ] ;
  if ( d % k == 0 ) count ++ ;
  for ( int i = k ;
  i < n ;
  i ++ ) {
    int prev = s [ i - k ] ;
    d -= prev ;
    d += s [ i ] ;
    if ( d % k == 0 ) count ++ ;
  }
  return count ;
  return n * n ;
}

***Example ends here:
int findSubstringCount ( string s ) {
  int result = 0 ;
  int n = s . length ( ) ;
  int i = 0 ;
  while ( i < n - 1 ) {
    if ( s [ i ] + 1 == s [ i + 1 ] ) {
      result ++ ;
      while ( i < n - 1 && s [ i ] + 1 == s [ i + 1 ] ) {
        i ++ ;
      }
    }
    i ++ ;
  }
  return result ;
}

***Example ends here:
bool find ( string s1 , string s2 ) {
  int len1 = s1 . length ( ) ;
  int len2 = s2 . length ( ) ;
  if ( len1 != len2 ) return false ;
  vector < int > d ( len1 , 0 ) ;
  d [ 0 ] = s2 [ 0 ] - s1 [ 0 ] ;
  for ( int i = 1 ;
  i < len1 ;
  i ++ ) {
    if ( s1 [ i ] > s2 [ i ] ) return false ;
    else d [ i ] = s2 [ i ] - s1 [ i ] ;
  }
  for ( int i = 0 ;
  i < len1 - 1 ;
  i ++ ) {
    if ( d [ i ] < d [ i + 1 ] ) return false ;
  }
  return true ;
  return s1 . length ( ) == s2 . length ( ) ;
}

***Example ends here:
bool isInGivenBase ( string s , int bas ) {
  if ( bas > 16 ) return false ;
  else if ( bas <= 10 ) {
    for ( int i = 0 ;
    i < s . length ( ) ;
    i ++ ) if ( ! ( s [ i ] >= '0' && s [ i ] < '0' + bas ) ) return false ;
  }
  else {
    for ( int i = 0 ;
    i < s . length ( ) ;
    i ++ ) if ( ! ( ( s [ i ] >= '0' && s [ i ] < '0' + bas ) || ( s [ i ] >= 'A' && s [ i ] < ( 'A' + bas - 10 ) ) ) return false ;
  }
  return true ;
}

***Example ends here:
int countNonEmptySubstring ( string s ) {
  int n = s . length ( ) ;
  return n * ( n + 1 ) / 2 ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n
***Example ends here:
int evenDecimalValue ( string s , int n ) {
  int result = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    for ( int j = i ;
    j < n ;
    j ++ ) {
      int decimalValue = 0 ;
      int powerOf2 = 1 ;
      for ( int k = i ;
      k <= j ;
      k ++ ) {
        decimalValue += ( s [ k ] - '0' ) * powerOf2 ;
        powerOf2 *= 2 ;
      }
      if ( decimalValue % 2 == 0 ) result ++ ;
    }
  }
  return result ;
  return n * n ;
}

***Example ends here:
int calculate ( string s ) {
  int ans = 6 ;
  for ( int i = 0 ;
  i < 10 ;
  i ++ ) {
    for ( int j = 0 ;
    j < 10 ;
    j ++ ) {
      for ( int k = 0 ;
      k < 10 ;
      k ++ ) {
        for ( int l = 0 ;
        l < 10 ;
        l ++ ) {
          for ( int m = 0 ;
          m < 10 ;
          m ++ ) {
            for ( int n = 0 ;
            n < 10 ;
            n ++ ) {
              if ( i + j + k == l + m + n ) {
                int c = 0 ;
                if ( i != s [ 0 ] - '0' ) c ++ ;
                if ( j != s [ 1 ] - '0' ) c ++ ;
                if ( k != s [ 2 ] - '0' ) c ++ ;
                if ( l != s [ 3 ] - '0' ) c ++ ;
                if ( m != s [ 4 ] - '0' ) c ++ ;
                if ( n != s [ 5 ] - '0' ) c ++ ;
                if ( c < ans ) ans = c ;
              }
            }
          }
        }
      }
    }
  }
}
return ans ;
return ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans ;
}

***Example ends here:
int xorZero ( string s ) {
  int oneCount = 0 ;
  int zeroCount = 0 ;
  int n = s . length ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( s [ i ] == '1' ) oneCount ++ ;
    else zeroCount ++ ;
  }
  if ( oneCount % 2 == 0 ) return zeroCount ;
  return oneCount ;
  return n * n ;
}

***Example ends here:
int evenLength ( string n ) {
  int res = n . length ( ) ;
  for ( int j = n . length ( ) - 1 ;
  j >= 0 ;
  -- j ) res += n [ j ] ;
  return res ;
  return n . length ( ) ;
}

***Example ends here:
int countSubstringWithEqualEnds ( string s ) {
  int result = 0 ;
  int n = s . length ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    for ( int j = i ;
    j < n ;
    j ++ ) {
      if ( s [ i ] == s [ j ] ) result = result + 1 ;
    }
  }
  return result ;
  return n * n ;
}

***Example ends here:
double normalSlope ( double a , double b , double x1 , double y1 ) {
  double g = a / 2 ;
  double f = b / 2 ;
  if ( g - x1 == 0 ) return - 1 ;
  double slope = ( f - y1 ) / ( g - x1 ) ;
  if ( slope == 0 ) return - 2 ;
  return slope ;
}

***Example ends here:
bool orthogonality ( double x1 , double y1 , double x2 , double y2 , double r1 , double r2 ) {
  double dsquare = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ;
  if ( dsquare == r1 * r1 + r2 * r2 ) return true ;
  else return false ;
}

***Example ends here:
double findAreaShaded ( double a ) {
  double sqArea = a * a ;
  double semiCircleArea = ( 3.14 * ( a * a ) / 8 ) ;
  double shadedArea = 4 * semiCircleArea - sqArea ;
  return shadedArea ;
  return a * a ;
}

***Example ends here:
int factorial ( int a , int b ) {
  int res = 1 ;
  for ( int i = 1 ;
  i <= a + b ;
  i ++ ) res = res * i ;
  for ( int i = 1 ;
  i <= a + 1 ;
  i ++ ) res = res / i ;
  for ( int i = 1 ;
  i <= b + 1 ;
  i ++ ) res = res / i ;
  return res ;
  return a * a ;
}

***Example ends here:
int factorTree ( int n ) {
  int height = 0 ;
  while ( n > 1 ) {
    bool flag = false ;
    for ( int i = 2 ;
    i <= ( int ) sqrt ( n ) ;
    i ++ ) {
      if ( n % i == 0 ) {
        n = n / i ;
        flag = true ;
        break ;
      }
    }
    height ++ ;
    if ( ! flag ) break ;
  }
  return height ;
  return n * n ;
}

***Example ends here:
string findIfPossible ( int n , int s , int x ) {
  if ( s >= x && s % 2 == x % 2 ) {
    if ( n >= 3 ) return "Yes" ;
    if ( n == 1 ) {
      if ( s == x ) return "Yes" ;
      else return "No" ;
    }
    if ( n == 2 ) {
      int c = ( s - x ) / 2 ;
      int a = c ;
      int b = c ;
      a = a + x ;
      if ( ( a ^ b ) == x ) return "Yes" ;
      else return "No" ;
    }
  }
  else return "No" ;
}

***Example ends here:
int maximumTripletXor ( int a , int b , int c ) {
  int ans = 0 ;
  for ( int i = 30 ;
  i >= 0 ;
  -- i ) {
    int cur = 1 << i ;
    if ( a >= cur ) {
      ans += cur ;
      a -= cur ;
    }
    else if ( b >= cur ) {
      ans += cur ;
      b -= cur ;
    }
    else if ( c >= cur ) {
      ans += cur ;
      c -= cur ;
    }
  }
  return ans ;
  return a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a *
***Example ends here:
int itemType ( int n ) {
  int count = 0 ;
  int day = 1 ;
  while ( count + day * ( day + 1 ) / 2 < n ) {
    count += day * ( day + 1 ) / 2 ;
    day ++ ;
  }
  for ( int type = day ;
  -- type >= 0 ;
  ) {
    count += type ;
    if ( count >= n ) return type ;
  }
  return 0 ;
  return n * n ;
}

***Example ends here:
int maxGCInRange ( int l , int r ) {
  int ans = 1 ;
  for ( int z = r ;
  z > 0 ;
  -- z ) {
    if ( r / z - ( l - 1 ) / z > 1 ) {
      ans = z ;
      break ;
    }
  }
  return ans ;
  return l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l *
***Example ends here:
int sumOfDigits ( int n ) {
  int sum = 0 ;
  while ( n != 0 ) {
    sum += ( n % 10 ) ;
    n = n / 10 ;
  }
  return sum ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n
***Example ends here:
bool isRepUnitNum ( int n , int b ) {
  int length = 0 ;
  int countOne = 0 ;
  while ( ( n != 0 ) ) {
    int r = n % b ;
    length ++ ;
    if ( r == 1 ) countOne ++ ;
    n = n / b ;
  }
  return countOne >= 3 && countOne == length ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
}

***Example ends here:
bool isStraightLineNum ( int n ) {
  if ( ( n <= 99 ) ) return false ;
  string s = to_string ( n ) ;
  int d = s [ 1 ] - s [ 0 ] ;
  for ( int i = 2 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( s [ i ] - s [ i - 1 ] != d ) return false ;
  }
  return true ;
}

***Example ends here:
int getCount ( int d , int n ) {
  int no = n / d ;
  int result = no ;
  for ( int p = 2 ;
  p <= no ;
  p ++ ) {
    if ( p * p > no ) break ;
    if ( no % p == 0 ) {
      while ( no % p == 0 ) no /= p ;
      result -= result / p ;
    }
  }
  if ( no > 1 ) result -= result / no ;
  return result ;
}

***Example ends here:
bool IsEvenParity ( unsigned int x ) {
  unsigned int parity = 0 ;
  while ( x != 0 ) {
    if ( x & 1 ) parity ++ ;
    x = x >> 1 ;
  }
  if ( parity % 2 == 0 ) return true ;
  else return false ;
}

***Example ends here:
int isPerfect ( int n ) {
  int sum = 1 ;
  for ( int i = 2 ;
  i <= n ;
  i ++ ) {
    if ( i * i > n ) break ;
    if ( n % i == 0 ) {
      if ( i * i != n ) sum = sum + i + n / i ;
      else sum = sum + i ;
    }
  }
  if ( sum == n && n != 1 ) return n ;
  return 0 ;
  return n * n ;
}

***Example ends here:
int logAToBaseB ( int a , int b ) {
  return a > ( b - 1 ) ? 1 + logAToBaseB ( a / b , b ) : 0 ;
  return a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a
***Example ends here:
int usingBinarySearch ( int start , int end , int n , int s ) {
  if ( start >= end ) return start ;
  int mid = start + ( end - start ) / 2 ;
  int totalSum = ( n * ( n + 1 ) ) / 2 ;
  int midSum = ( mid * ( mid + 1 ) ) / 2 ;
  if ( totalSum - midSum <= s ) return usingBinarySearch ( start , mid , n , s ) ;
  return usingBinarySearch ( mid + 1 , end , n , s ) ;
}

***Example ends here:
string minInt ( string s ) {
  string s1 = s ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( s1 [ i ] >= '5' ) s1 [ i ] = ( char ) ( '9' - s1 [ i ] + '0' ) ;
  }
  if ( s1 [ 0 ] == '0' ) s1 [ 0 ] = '9' ;
  return s1 ;
  return " " + s + " " + s ;
}

***Example ends here:
int countTriplets ( int a , int b , int c ) {
  int ans = 0 ;
  for ( int i = 1 ;
  i <= a ;
  i ++ ) {
    for ( int j = 1 ;
    j <= b ;
    j ++ ) {
      for ( int k = 1 ;
      k <= c ;
      k ++ ) {
        if ( i * k > j * j ) ans ++ ;
      }
    }
  }
  return ans ;
  return a * a ;
}

***Example ends here:
bool topsyTurvy ( string s ) {
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( s [ i ] == '2' || s [ i ] == '4' || s [ i ] == '5' || s [ i ] == '6' || s [ i ] == '7' || s [ i ] == '9' ) return false ;
  }
  return true ;
  return s . length ( ) > 0 ;
}

***Example ends here:
int sumOfLastDig ( int n , int m ) {
  int sum = 0 ;
  int k = n / m ;
  int arr [ 10 ] ;
  for ( int i = 0 ;
  i < 10 ;
  i ++ ) {
    arr [ i ] = m * ( i + 1 ) % 10 ;
    sum += arr [ i ] ;
  }
  int rem = k % 10 ;
  int ans = k / 10 * sum ;
  for ( int i = 0 ;
  i < rem ;
  i ++ ) ans += arr [ i ] ;
  return ans ;
  return n * n ;
}

***Example ends here:
int totalPay ( int totalItems , int priceOfOneItem , int n , int m ) {
  int freeItems ;
  int actual ;
  freeItems = totalItems / ( n + m ) ;
  actual = totalItems - freeItems ;
  int amount = actual * priceOfOneItem ;
  return amount ;
  return totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems * totalItems ;
}

***Example ends here:
int minOperations ( int x , int y , int p , int q ) {
  if ( y % x != 0 ) return - 1 ;
  int d = y / x ;
  int a = 0 ;
  while ( d % p == 0 ) {
    d /= p ;
    a ++ ;
  }
  int b = 0 ;
  while ( d % q == 0 ) {
    d /= q ;
    b ++ ;
  }
  if ( d != 1 ) return - 1 ;
  return a + b ;
}

***Example ends here:
bool isMersenne ( int n ) {
  while ( n != 0 ) {
    int r = n % 2 ;
    if ( r == 0 ) return false ;
    n /= 2 ;
  }
  return true ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
}

***Example ends here:
int findThirdDigit ( int n ) {
  if ( n < 3 ) return 0 ;
  return n & 1 ? 1 : 6 ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *
***Example ends here:
bool isOddLength ( int num ) {
  int count = 0 ;
  while ( num > 0 ) {
    num = num / 10 ;
    count ++ ;
  }
  if ( count % 2 != 0 ) return true ;
  return false ;
  return num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num ;
}

***Example ends here:
bool checkIsPossible ( int l , int r , int k ) {
  int count = 0 ;
  for ( int i = l ;
  i <= r ;
  i ++ ) {
    if ( i % k == 0 ) count ++ ;
  }
  return count > 1 ;
}

***Example ends here:
double bytes ( double kilobytes ) {
  double b = kilobytes * 1024 ;
  return b ;
  return kilobytes * kilobytes * kilobytes * kilobytes * kilobytes * kilobytes * kilobytes * kilobytes * kilobytes * kilobytes * kilobytes * kilobytes * kilobytes * kilobytes * kilobytes * ki @@
***Example ends here:
int octahedral_num ( int n ) {
  return n * ( 2 * n * n + 1 ) / 3 ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n *
***Example ends here:
string checkEqual ( string s ) {
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( s [ i ] != '1' && s [ i ] != '0' && s [ i ] != '8' ) return "No" ;
  }
  int start = 0 ;
  int end = s . length ( ) - 1 ;
  while ( start < end ) {
    if ( s [ start ] != s [ end ] ) return "No" ;
    start ++ ;
    end -- ;
  }
  return "Yes" ;
  return " " + s + " " + s ;
}

***Example ends here:
bool isSundulating ( string n ) {
  if ( n . length ( ) <= 2 ) return false ;
  for ( int i = 2 ;
  i < n . length ( ) ;
  i ++ ) {
    if ( n [ i - 2 ] != n [ i ] ) return false ;
  }
  return true ;
}

***Example ends here:
int firstDigit ( int n ) {
  while ( n >= 10 ) n /= 10 ;
  return n ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n
***Example ends here:
int countDigit ( int n ) {
  if ( n == 0 ) return 0 ;
  return 1 + countDigit ( n / 10 ) ;
  return n * n ;
}

***Example ends here:
bool isDivisibleBy5 ( string s ) {
  int n = s . length ( ) ;
  return s [ n - 1 ] == '0' || s [ n - 1 ] == '5' ;
  return n * n ;
}

***Example ends here:
int inv ( int a , int m ) {
  int m0 = m ;
  int x0 = 0 , x1 = 1 ;
  if ( m == 1 ) return 0 ;
  while ( a > 1 ) {
    int q = a / m ;
    int t = m ;
    m = a % m ;
    a = t ;
    t = x0 ;
    x0 = x1 - q * x0 ;
    x1 = t ;
  }
  if ( x1 < 0 ) x1 = x1 + m0 ;
  return x1 ;
  return a * a ;
}

***Example ends here:
bool onlyFirstAndLastAreSet ( int n ) {
  if ( n == 1 ) return true ;
  if ( n == 2 ) return false ;
  return ( ( n - 1 ) & ( n - 2 ) ) == 0 ;
}

***Example ends here:
int divide ( int dividend , int divisor ) {
  int sign = ( ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? - 1 : 1 ) ;
  dividend = abs ( dividend ) ;
  divisor = abs ( divisor ) ;
  int quotient = 0 ;
  int temp = 0 ;
  for ( int i = 31 ;
  i >= 0 ;
  i -- ) {
    if ( temp + ( divisor << i ) <= dividend ) {
      temp += divisor << i ;
      quotient |= 1 << i ;
    }
  }
  if ( sign == - 1 ) quotient = - quotient ;
  return quotient ;
  return dividend * dividend ;
}

***Example ends here:
char findProfession ( int level , int pos ) {
  if ( level == 1 ) return 'e' ;
  if ( findProfession ( level - 1 , ( pos + 1 ) / 2 ) == 'd' ) return pos % 2 == 0 ? 'd' : 'e' ;
  return pos % 2 == 0 ? 'e' : 'd' ;
  return level * level ;
}

***Example ends here:
bool hasCloseElements ( vector < int > numbers , double threshold ) {
  for ( int i = 0 ;
  i < numbers . size ( ) ;
  i ++ ) {
    for ( int j = i + 1 ;
    j < numbers . size ( ) ;
    j ++ ) {
      double distance = fabs ( numbers [ i ] - numbers [ j ] ) ;
      if ( distance < threshold ) return true ;
    }
  }
  return false ;
  return numbers . size ( ) > numbers . size ( ) ;
}

***Example ends here:
int truncateNumber ( int number ) {
  return number % 1 ;
  return number * number * number * number * number * number * number * number * number * number * number * number * number * number * number * number * number * number * number * number * number * number * number * number *
***Example ends here:
bool below_zero ( std :: vector < int > operations ) {
  int balance = 0 ;
  for ( int i = 0 ;
  i < operations . size ( ) ;
  i ++ ) {
    balance += operations [ i ] ;
    if ( balance < 0 ) return true ;
  }
  return false ;
}

***Example ends here:
double meanAbsoluteDeviation ( double * numbers ) {
  double sumNum = 0 ;
  for ( double num : numbers ) sumNum += num ;
  double mean = sumNum / numbers . size ( ) ;
  double sumAbsDiff = 0 ;
  for ( double num : numbers ) sumAbsDiff += fabs ( num - mean ) ;
  return sumAbsDiff / numbers . size ( ) ;
}

***Example ends here:
string intersperse ( string numbers , char delimiter ) {
  string result ;
  if ( numbers . empty ( ) ) return result ;
  for ( int i = 0 ;
  i < numbers . length ( ) - 1 ;
  i ++ ) {
    result += numbers [ i ] ;
    result += delimiter ;
  }
  result += numbers [ numbers . length ( ) - 1 ] ;
  return result ;
  return " " + numbers + " " + numbers ;
}

***Example ends here:
int sumProduct ( int * numbers ) {
  int sumValue = 0 ;
  int prodValue = 1 ;
  for ( int n = 0 ;
  n < numbers [ 0 ] ;
  n ++ ) {
    sumValue += numbers [ n ] ;
    prodValue *= numbers [ n ] ;
  }
  return sumValue ;
  return numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers ;
}

***Example ends here:
string allPrefixes ( string string ) {
  string result ;
  for ( int i = 1 ;
  i <= string . length ( ) ;
  i ++ ) result += string . substr ( 0 , i ) ;
  return result ;
  return " " + string + " " + string ;
}

***Example ends here:
string parseMusic ( string musicString ) {
  string current ;
  string result ;
  for ( int i = 0 ;
  i < musicString . length ( ) + 1 ;
  i ++ ) {
    if ( i == musicString . length ( ) || musicString [ i ] == ' ' ) {
      if ( strcmp ( current . c_str ( ) , "o" ) == 0 ) result += to_string ( 4 ) ;
      if ( strcmp ( current . c_str ( ) , "o|" ) == 0 ) result += to_string ( 2 ) ;
      if ( strcmp ( current . c_str ( ) , ".|" ) == 0 ) result += to_string ( 1 ) ;
      current . clear ( ) ;
    }
    else current += musicString [ i ] ;
  }
  return result ;
  return " " + musicString + " " + musicString ;
  return " " + musicString ;
  return " " + musicString ;
  return " " + musicString ;
}

***Example ends here:
int strlen ( const char * s ) {
  return strlen ( s ) ;
  return s * s * s * s * s * s * s * s * s * s * s * s * s * s * s * s * s * s * s * s * s * s * s *
***Example ends here:
int factorize ( int n ) {
  int factors [ n ] ;
  int i = 2 ;
  while ( i <= n ) {
    if ( n % i == 0 ) {
      factors [ i ] = i ;
      n /= i ;
    }
    else i ++ ;
  }
  return factors [ n ] ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
}

***Example ends here:
string concatenate ( string strings ) {
  string result ;
  for ( string s : strings ) result += s ;
  return result ;
  return " " + strings + " " + strings ;
}

***Example ends here:
string getPositive ( string l ) {
  string result ;
  for ( int i = 0 ;
  i < l . length ( ) ;
  i ++ ) {
    if ( l [ i ] > 0 ) result += l [ i ] ;
  }
  return result ;
  return " " + l + " " + l ;
}

***Example ends here:
string sortEven ( string l ) {
  string evens ;
  for ( int i = 0 ;
  i < l . length ( ) ;
  i += 2 ) evens += l [ i ] ;
  sort ( evens . begin ( ) , evens . end ( ) ) ;
  string result ;
  for ( int i = 0 ;
  i < l . length ( ) ;
  i += 2 ) {
    if ( i % 2 == 0 ) result += evens [ i / 2 ] ;
    if ( i % 2 == 1 ) result += l [ i ] ;
  }
  return result ;
  return " " + l + " " + l ;
}

***Example ends here:
string decodeCyclic ( string s ) {
  string output ;
  int i = 0 ;
  while ( i <= s . length ( ) - 3 ) {
    string x = s . substr ( i + 2 ) + s . substr ( i , i + 2 ) ;
    output += x ;
    i += 3 ;
  }
  return output + s . substr ( i ) ;
  return " " + s + " " + s ;
}

***Example ends here:
double carace_collision ( double n ) {
  return n * n ;
}

***Example ends here:
int incrList ( int l ) {
  int result = 0 ;
  for ( int i = 0 ;
  i < l ;
  i ++ ) result += i + 1 ;
  return result ;
  return l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l
***Example ends here:
bool pairsSumToZero ( int * l ) {
  for ( int i = 0 ;
  i < sizeof ( l ) / sizeof ( int ) ;
  i ++ ) {
    for ( int j = i + 1 ;
    j < sizeof ( l ) / sizeof ( int ) ;
    j ++ ) {
      if ( l [ i ] + l [ j ] == 0 ) return true ;
    }
  }
  return false ;
}

***Example ends here:
string changeBase ( int x , int b ) {
  string ret ;
  while ( x > 0 ) {
    ret . insert ( 0 , to_string ( x % b ) ) ;
    x /= b ;
  }
  return ret ;
  return " " + to_string ( x ) + " " + to_string ( x ) ;
}

***Example ends here:
double median ( vector < double > l ) {
  sort ( l . begin ( ) , l . end ( ) ) ;
  if ( l . size ( ) % 2 == 1 ) return l [ l . size ( ) / 2 ] ;
  else return ( l [ l . size ( ) / 2 - 1 ] + l [ l . size ( ) / 2 ] ) / 2.0 ;
}

***Example ends here:
string decodeShift ( string s ) {
  string result ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    char ch = s [ i ] ;
    int w = ( ch + 21 - 21 - "a" ) % 26 + "a" ;
    result += ( char ) w ;
  }
  return result ;
  return " " + s + " " + s ;
}

***Example ends here:
bool below_threshold ( int l , int t ) {
  for ( int n = 0 ;
  n < l ;
  n ++ ) {
    if ( n >= t ) return false ;
  }
  return true ;
  return l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l
***Example ends here:
bool correctBracketing ( string brackets ) {
  int depth = 0 ;
  for ( char b : brackets ) {
    if ( b == '<' ) depth ++ ;
    else depth -- ;
    if ( depth < 0 ) return false ;
  }
  return depth == 0 ;
}

***Example ends here:
bool monotonic ( string l ) {
  int incr = 0 ;
  int decr = 0 ;
  for ( int i = 1 ;
  i < l . length ( ) ;
  i ++ ) {
    if ( l [ i ] > l [ i - 1 ] ) incr = 1 ;
    if ( l [ i ] < l [ i - 1 ] ) decr = 1 ;
  }
  return incr + decr != 2 ;
  return incr * incr ;
}

***Example ends here:
double derivative ( double * xs ) {
  double result ;
  for ( int i = 1 ;
  i < sizeof ( xs ) / sizeof ( double ) ;
  i ++ ) result += i * xs [ i ] ;
  return result ;
  return xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs * xs ;
}

***Example ends here:
int vowelsCount ( string s ) {
  string vowels = "aeiouAEIOU" ;
  int count = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    char ch = s [ i ] ;
    if ( vowels . find ( ch ) != string :: npos ) count ++ ;
  }
  if ( s [ s . length ( ) - 1 ] == 'y' || s [ s . length ( ) - 1 ] == 'Y' ) count ++ ;
  return count ;
}

***Example ends here:
int digit_sum ( string s ) {
  int sum = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( isupper ( s [ i ] ) ) sum += toupper ( s [ i ] ) ;
  }
  return sum ;
  return sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum *
***Example ends here:
int fruitDistribution ( string s , int n ) {
  string num1 ;
  string num2 ;
  bool flag = false ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( isdigit ( s [ i ] ) ) {
      if ( ! flag ) num1 += s [ i ] ;
      if ( flag ) num2 += s [ i ] ;
    }
    else if ( ! flag && num1 . length ( ) > 0 ) flag = true ;
  }
  return n - atoi ( num1 . c_str ( ) ) - atoi ( num2 . c_str ( ) ) ;
  return n * n ;
}

***Example ends here:
int pluck ( int * arr ) {
  int result [ 2 ] ;
  for ( int i = 0 ;
  i < sizeof ( arr ) / sizeof ( int ) ;
  i ++ ) {
    if ( arr [ i ] % 2 == 0 ) {
      if ( result [ 0 ] == 0 ) {
        result [ 0 ] = arr [ i ] ;
        result [ 1 ] = i ;
      }
      else if ( arr [ i ] < result [ 0 ] ) {
        result [ 0 ] = arr [ i ] ;
        result [ 1 ] = i ;
      }
    }
  }
  return result [ 0 ] ;
}

***Example ends here:
string strangeSortArray ( string list ) {
  string res ;
  sort ( list . begin ( ) , list . end ( ) ) ;
  int l = 0 ;
  int r = list . length ( ) - 1 ;
  while ( l < r ) {
    res += list [ l ] ;
    l ++ ;
    res += list [ r ] ;
    r -- ;
  }
  if ( l == r ) res += list [ l ] ;
  return res ;
  return " " + list + " " + list ;
}

***Example ends here:
double triangleArea ( double a , double b , double c ) {
  if ( a + b <= c || a + c <= b || b + c <= a ) return - 1.0 ;
  double s = ( a + b + c ) / 2 ;
  double area = sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ;
  return area ;
  return a * a ;
}

***Example ends here:
bool will_it_fly ( string q , int w ) {
  int sum = 0 ;
  for ( int i = 0 ;
  i < q . length ( ) ;
  i ++ ) {
    if ( q [ i ] != q [ q . length ( ) - i - 1 ] ) return false ;
    sum += q [ i ] ;
  }
  return sum <= w ;
}

***Example ends here:
bool isCube ( double a ) {
  a = fabs ( a ) ;
  int i = round ( a * ( 1.0 / 3 ) ) ;
  return i * i == a ;
  return a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a
***Example ends here:
int hexKey ( string num ) {
  string key = "2357BD" ;
  int total = 0 ;
  for ( int i = 0 ;
  i < num . length ( ) ;
  i ++ ) {
    if ( key . find ( num [ i ] ) != string :: npos ) total ++ ;
  }
  return total ;
}

***Example ends here:
string decimalToBinary ( int dec ) {
  string ans ;
  if ( dec != 0 ) {
    while ( dec > 0 ) {
      ans . insert ( 0 , to_string ( dec % 2 ) ) ;
      dec /= 2 ;
    }
  }
  else ans += "0" ;
  return "db" + ans + "db" ;
  return " " + to_string ( dec ) ;
}

***Example ends here:
bool primeLength ( string s ) {
  int l = s . length ( ) ;
  if ( l < 2 ) return false ;
  for ( int i = 2 ;
  i < l ;
  i ++ ) {
    if ( l % i == 0 ) return false ;
  }
  return true ;
}

***Example ends here:
int startsOneEnds ( int n ) {
  if ( n < 1 ) return 0 ;
  if ( n == 1 ) return 1 ;
  return 18 * ( 10 * ( n - 2 ) ) ;
  return n * n ;
}

***Example ends here:
int add ( int * lst ) {
  int sum = 0 ;
  for ( int i = 1 ;
  i < sizeof ( lst ) / sizeof ( int ) ;
  i += 2 ) {
    if ( lst [ i ] % 2 == 0 ) sum += lst [ i ] ;
  }
  return sum ;
  return sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum ;
}

***Example ends here:
vector < pair < int , int >> getRow ( vector < int > lst , int x ) {
  vector < pair < int , int >> coords ;
  for ( int i = 0 ;
  i < lst . size ( ) ;
  i ++ ) {
    for ( int j = lst [ i ] . size ( ) - 1 ;
    j >= 0 ;
    j -- ) {
      if ( lst [ i ] [ j ] == x ) coords . push_back ( make_pair ( i , j ) ) ;
    }
  }
  return coords ;
}

***Example ends here:
int nextSmallest ( int * list ) {
  sort ( list , list + sizeof ( int ) / sizeof ( int ) ) ;
  for ( int i = 1 ;
  i < sizeof ( int ) / sizeof ( int ) ;
  i ++ ) {
    if ( list [ i ] != list [ i - 1 ] ) return list [ i ] ;
  }
  return - 1 ;
  return list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list * list *
***Example ends here:
bool anyInt ( int a , int b , int c ) {
  if ( round ( a ) != a || round ( b ) != b || round ( c ) != c ) return false ;
  return a + b == c || a + c == b || b + c == a ;
}

***Example ends here:
int countUpTo ( int n ) {
  int primes = 0 ;
  for ( int i = 2 ;
  i < n ;
  i ++ ) {
    bool isPrime = true ;
    for ( int j = 2 ;
    j < i ;
    j ++ ) {
      if ( i % j == 0 ) {
        isPrime = false ;
        break ;
      }
    }
    if ( isPrime ) primes ++ ;
  }
  return primes ;
  return n * n ;
}

***Example ends here:
int closestInteger ( string value ) {
  double w = atof ( value . c_str ( ) ) ;
  return round ( w ) ;
  return w * w * w * w * w * w * w * w * w * w * w * w * w * w * w * w * w * w * w * w * w * w * w * w * w * w * w * w * w * w
***Example ends here:
int makeAile ( int n ) {
  int result = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) result += n + 2 * i ;
  return result ;
}

***Example ends here:
string wordString ( string s ) {
  string current ;
  string words ;
  for ( int i = 0 ;
  i < s . length ( ) + 1 ;
  i ++ ) {
    if ( i == s . length ( ) || s [ i ] == " " || s [ i ] == "," ) {
      if ( current . length ( ) > 0 ) {
        words += current ;
        current . clear ( ) ;
      }
    }
    else {
      current += s [ i ] ;
    }
  }
  return words ;
  return " " + s + " " + s ;
}

***Example ends here:
string roundedAvg ( int n , int m ) {
  if ( n > m ) return string ( - 1 ) ;
  int num = ( n + m ) / 2 ;
  string ret ;
  while ( num > 0 ) {
    ret . insert ( 0 , to_string ( num % 2 ) ) ;
    num /= 2 ;
  }
  return ret ;
  return " " + to_string ( n ) + " " + to_string ( m ) ;
}

***Example ends here:
int uniqueDigits ( string str ) {
  vector < int > digits ;
  for ( int n = 0 ;
  n < str . length ( ) ;
  n ++ ) {
    bool isUnique = true ;
    for ( char c : str ) {
      if ( ( int ) c % 2 == 0 ) {
        isUnique = false ;
        break ;
      }
    }
    if ( isUnique ) digits . push_back ( n ) ;
  }
  sort ( digits . begin ( ) , digits . end ( ) ) ;
  return digits . size ( ) ;
  return 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0
***Example ends here:
int countNums ( int arr [ ] ) {
  int num = 0 ;
  for ( int n = 0 ;
  n < arr [ 0 ] ;
  n ++ ) {
    int neg = n < 0 ? - 1 : 1 ;
    n = abs ( n ) ;
    int digits [ 10 ] ;
    for ( int i = 0 ;
    i < 10 ;
    i ++ ) digits [ i ] = n - '0' ;
    digits [ 0 ] *= neg ;
    int sum = 0 ;
    for ( int i = 0 ;
    i < 10 ;
    i ++ ) sum += digits [ i ] ;
    if ( sum > 0 ) num ++ ;
  }
  return num ;
}

***Example ends here:
bool moveOneBall ( string arr ) {
  if ( arr . empty ( ) ) return true ;
  int num = 0 ;
  for ( int i = 1 ;
  i < arr . length ( ) ;
  i ++ ) {
    if ( arr [ i ] < arr [ i - 1 ] ) num ++ ;
  }
  if ( arr [ arr . length ( ) - 1 ] > arr [ 0 ] ) num ++ ;
  if ( num < 2 ) return true ;
  return false ;
  return true * true ;
  return true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true *
***Example ends here:
string exchange ( string lst1 , string lst2 ) {
  int odd = 0 ;
  int even = 0 ;
  for ( int n = 0 ;
  n < lst1 . length ( ) ;
  n ++ ) {
    if ( lst1 [ n ] % 2 == 1 ) odd ++ ;
  }
  for ( int n = 0 ;
  n < lst2 . length ( ) ;
  n ++ ) {
    if ( lst2 [ n ] % 2 == 0 ) even ++ ;
  }
  if ( even >= odd ) return "YES" ;
  return "NO" ;
  return " " + lst1 + " " + lst2 ;
  return " " + lst1 ;
  return " " + lst1 ;
  return " " + lst1 ;
  return " " + lst1 ;
}

***Example ends here:
string oddCount ( string lst ) {
  string results ;
  string originalStr = "the number of odd elements in the string i of the input." ;
  for ( string :: size_type pos = 0 ;
  pos < lst . length ( ) ;
  pos ++ ) {
    char s = lst [ pos ] ;
    int sum = 0 ;
    for ( char d : s ) {
      if ( isdigit ( d ) && ( int ) d % 2 == 1 ) sum ++ ;
    }
    string result ;
    for ( char c : originalStr ) {
      if ( c == 'i' ) result += to_string ( sum ) ;
      else result += c ;
    }
    results += result ;
  }
  return results ;
  return " " + lst + " " + lst ;
}

***Example ends here:
int minSubArraySum ( int * nums ) {
  int minSum = INT_MAX ;
  int sum = 0 ;
  for ( int i = 0 ;
  i < nums [ 0 ] ;
  i ++ ) {
    sum += nums [ i ] ;
    if ( minSum > sum ) minSum = sum ;
    if ( sum > 0 ) sum = 0 ;
  }
  return minSum ;
}

***Example ends here:
int maxFill ( int grid [ ] , int capacity ) {
  int res = 0 ;
  for ( int i = 0 ;
  i < grid [ 0 ] ;
  i ++ ) {
    int sum = 0 ;
    for ( int n = 0 ;
    n < capacity ;
    n ++ ) sum += n ;
    if ( sum > 0 ) res += ( sum - 1 ) / capacity + 1 ;
  }
  return res ;
  return grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid * grid *
***Example ends here:
string selectWords ( string s , int n ) {
  string vowels = "aeiouAEIOU" ;
  string current ;
  string result ;
  int consonantNum = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) + 1 ;
  i ++ ) {
    if ( i == s . length ( ) || s [ i ] == " " ) {
      if ( consonantNum == n ) result += current ;
      current . clear ( ) ;
      consonantNum = 0 ;
    }
    else {
      current += s [ i ] ;
      if ( s [ i ] != vowels ) consonantNum ++ ;
    }
  }
  return result ;
  return " " + s + " " + s ;
}

***Example ends here:
int solution ( int * lst ) {
  int sum = 0 ;
  for ( int i = 0 ;
  i < sizeof ( lst ) / sizeof ( int ) ;
  i += 2 ) {
    if ( lst [ i ] % 2 == 1 ) sum += lst [ i ] ;
  }
  return sum ;
  return sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum ;
}

***Example ends here:
int addElements ( int * arr , int k ) {
  int sum = 0 ;
  for ( int i = 0 ;
  i < k ;
  i ++ ) {
    if ( - 99 <= arr [ i ] && arr [ i ] <= 99 ) sum += arr [ i ] ;
  }
  return sum ;
}

***Example ends here:
int getOddCollatz ( int n ) {
  vector < int > odd_collatz ;
  while ( n > 1 ) {
    if ( n % 2 == 1 ) {
      odd_collatz . push_back ( n ) ;
      n = n * 3 + 1 ;
    }
    else {
      n /= 2 ;
    }
  }
  odd_collatz . push_back ( 1 ) ;
  sort ( odd_collatz . begin ( ) , odd_collatz . end ( ) ) ;
  return odd_collatz . size ( ) ;
  return n * n ;
}

***Example ends here:
bool isSorted ( string lst ) {
  for ( int i = 1 ;
  i < lst . length ( ) ;
  i ++ ) {
    if ( lst [ i ] < lst [ i - 1 ] ) return false ;
    if ( i >= 2 && lst [ i ] == lst [ i - 1 ] && lst [ i ] == lst [ i - 2 ] ) return false ;
  }
  return true ;
  return true * true ;
}

***Example ends here:
string intersection ( string interval1 , string interval2 ) {
  int inter1 = max < int > ( interval1 [ 0 ] , interval2 [ 0 ] ) ;
  int inter2 = min < int > ( interval1 [ 1 ] , interval2 [ 1 ] ) ;
  int l = inter2 - inter1 ;
  if ( l < 2 ) return "NO" ;
  for ( int i = 2 ;
  i < l ;
  i ++ ) {
    if ( l % i == 0 ) return "NO" ;
  }
  return "YES" ;
  return " " + interval1 + " " + interval2 ;
}

***Example ends here:
int prodSigns ( int * arr ) {
  if ( arr == NULL ) return - 32768 ;
  int sum = 0 ;
  int prods = 1 ;
  for ( int i = 0 ;
  i < arr -> length ( ) ;
  i ++ ) {
    sum += abs ( arr -> at ( i ) ) ;
    if ( i == 0 ) prods = 0 ;
    if ( i < 0 ) prods = - prods ;
  }
  return sum * prods ;
  return arr -> length ( ) ;
}

***Example ends here:
int minPath ( vector < vector < int >> grid , int k ) {
  int n = grid . size ( ) ;
  int minNum = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    for ( int j = 0 ;
    j < n ;
    j ++ ) {
      if ( grid [ i ] [ j ] == 1 ) {
        vector < int > tmp ;
        if ( i != 0 ) tmp . push_back ( grid [ i - 1 ] [ j ] ) ;
        if ( j != 0 ) tmp . push_back ( grid [ i ] [ j - 1 ] ) ;
        if ( i != n - 1 ) tmp . push_back ( grid [ i + 1 ] [ j ] ) ;
        if ( j != n - 1 ) tmp . push_back ( grid [ i ] [ j + 1 ] ) ;
        minNum = min ( tmp . begin ( ) , tmp . end ( ) ) ;
      }
    }
  }
  int ans = 0 ;
  for ( int i = 0 ;
  i < k ;
  i ++ ) {
    if ( i % 2 == 0 ) ans += 1 ;
    else ans += minNum ;
  }
}
return ans ;
return n * n ;
}

***Example ends here:
int digits ( int n ) {
  int prod = 1 ;
  for ( char digit : to_string ( n ) ) {
    if ( digit % 2 == 1 ) {
      if ( prod == 0 ) prod == 1 ;
      prod *= digit - '0' ;
    }
  }
  return prod ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
}

***Example ends here:
bool isNested ( string s ) {
  int count = 0 ;
  int maxCount = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    char ch = s [ i ] ;
    if ( ch == '[' ) count ++ ;
    if ( ch == ']' ) count -- ;
    if ( count < 0 ) count = 0 ;
    if ( count > maxCount ) maxCount = count ;
    if ( count <= maxCount - 2 ) return true ;
  }
  return false ;
  return true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true *
***Example ends here:
double sumSquares ( double [ ] lst ) {
  double sum = 0 ;
  for ( double i = 0 ;
  i < lst . length ;
  i ++ ) sum += ceil ( lst [ i ] ) * ceil ( lst [ i ] ) ;
  return sum ;
  return lst . length * lst . length * lst . length * lst . length * lst . length * lst . length * lst . length * lst . length * lst . length * lst . length * lst . length * lst . length * lst . length * lst . length * lst . length * lst . length * lst . length * lst . length * lst . length * lst . length * lst . length * lst . length * lst
***Example ends here:
int canRearrange ( int * arr ) {
  int index = - 1 ;
  for ( int i = 0 ;
  i < sizeof ( arr ) / sizeof ( int ) ;
  i ++ ) {
    if ( arr [ i ] <= i ) index = i ;
  }
  return index ;
  return arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr ;
}

***Example ends here:
int largest_smallest_integers ( int * list ) {
  int max_neg = 0 , min_pos = 0 ;
  for ( int n = 0 ;
  n < * list ;
  n ++ ) {
    if ( n < 0 && ( max_neg == 0 || n > max_neg ) ) max_neg = n ;
    if ( n > 0 && ( min_pos == 0 || n < min_pos ) ) min_pos = n ;
  }
  return max_neg ;
}

***Example ends here:
string fixSpaces ( string text ) {
  string res ;
  int spaceLen = 0 ;
  for ( int i = 0 ;
  i < text . length ( ) + 1 ;
  i ++ ) {
    if ( i == text . length ( ) || text [ i ] != ' ' ) {
      if ( spaceLen == 1 ) res += '_' ;
      if ( spaceLen == 2 ) res += '__' ;
      if ( spaceLen > 2 ) res += '-' ;
      spaceLen = 0 ;
      if ( i != text . length ( ) ) res += text [ i ] ;
    }
    else spaceLen ++ ;
  }
  return res ;
  return " " + text + " " + text ;
}

***Example ends here:
string fileNameCheck ( string fileName ) {
  int digNum = 0 , dotNum = 0 ;
  if ( fileName . length ( ) < 5 || ! isalpha ( fileName [ 0 ] ) ) return "No" ;
  string suffix = fileName . substr ( fileName . length ( ) - 4 ) ;
  if ( suffix != ".txt" && suffix != ".exe" && suffix != ".dll" ) return "No" ;
  for ( int i = 0 ;
  i < fileName . length ( ) ;
  i ++ ) {
    if ( isdigit ( fileName [ i ] ) ) digNum ++ ;
    if ( fileName [ i ] == '.' ) dotNum ++ ;
  }
  if ( digNum > 3 || dotNum != 1 ) return "No" ;
  return "Yes" ;
  return " " + fileName + " " + fileName ;
}

***Example ends here:
double sumSquares ( double * lst ) {
  double sum = 0 ;
  for ( int i = 0 ;
  i < sizeof ( lst ) / sizeof ( double ) ;
  i ++ ) {
    if ( i % 3 == 0 ) sum += lst [ i ] * lst [ i ] ;
    else if ( i % 4 == 0 ) sum += lst [ i ] * lst [ i ] * lst [ i ] ;
    else sum += lst [ i ] ;
  }
  return sum ;
}

***Example ends here:
string wordsInSentence ( string sentence ) {
  string result ;
  string current ;
  for ( int i = 0 ;
  i < sentence . length ( ) + 1 ;
  i ++ ) {
    if ( i == sentence . length ( ) || sentence [ i ] == ' ' ) {
      bool isPrime = true ;
      int l = current . length ( ) ;
      if ( l < 2 ) isPrime = false ;
      for ( int j = 2 ;
      j < l ;
      j ++ ) {
        if ( l % j == 0 ) {
          isPrime = false ;
          break ;
        }
      }
      if ( isPrime ) result += current + " " ;
      current . clear ( ) ;
    }
    else current += sentence [ i ] ;
  }
  result = result ;
  if ( result . length ( ) > 0 ) result = result . substr ( 0 , result . length ( ) - 1 ) ;
  return result ;
  return " " + sentence + " " + sentence ;
  return " " + sentence ;
  return " " + sentence ;
}

***Example ends here:
bool simplify ( string x , string n ) {
  int a = 0 , b = 0 , c = 0 , d = 0 ;
  for ( int i = 0 ;
  i < x . length ( ) ;
  i ++ ) {
    if ( x [ i ] == '/' ) {
      a = atoi ( x . substr ( 0 , i ) . c_str ( ) ) ;
      b = atoi ( x . substr ( i + 1 ) . c_str ( ) ) ;
    }
  }
  for ( int i = 0 ;
  i < n . length ( ) ;
  i ++ ) {
    if ( n [ i ] == '/' ) {
      c = atoi ( n . substr ( 0 , i ) . c_str ( ) ) ;
      d = atoi ( n . substr ( i + 1 ) . c_str ( ) ) ;
    }
  }
  return ( a * c ) % ( b * d ) == 0 ;
}

***Example ends here:
int specialFilter ( int nums [ ] ) {
  int count = 0 ;
  for ( int i = 0 ;
  i < nums [ 0 ] ;
  i ++ ) {
    if ( nums [ i ] > 10 ) {
      string w = to_string ( nums [ i ] ) ;
      if ( w [ 0 ] % 2 == 1 && w [ w . length ( ) - 1 ] % 2 == 1 ) count ++ ;
    }
  }
  return count ;
  return nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums * nums
***Example ends here:
int getMaxTriples ( int n ) {
  int arr [ n + 1 ] ;
  for ( int i = 1 ;
  i <= n ;
  i ++ ) arr [ i ] = i * i - i + 1 ;
  int count = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    for ( int j = i + 1 ;
    j < n ;
    j ++ ) {
      for ( int k = j + 1 ;
      k < n ;
      k ++ ) {
        if ( ( arr [ i ] + arr [ j ] + arr [ k ] ) % 3 == 0 ) count ++ ;
      }
    }
  }
  return count ;
  return n * n ;
}

***Example ends here:
double doubleTheDifference ( double * lst ) {
  double sum = 0 ;
  for ( double d : lst ) {
    double num = round ( d ) ;
    if ( d == num ) {
      if ( num > 0 && num % 2 == 1 ) sum += num * num ;
    }
  }
  return sum ;
}

***Example ends here:
int compare ( string game , string guess ) {
  int result = 0 ;
  for ( int i = 0 ;
  i < game . length ( ) ;
  i ++ ) result += abs ( game [ i ] - guess [ i ] ) ;
  return result ;
}

***Example ends here:
string strongest_extension ( string class_name , string extensions ) {
  string strongest ;
  int max = - INT_MAX ;
  for ( string extension : extensions ) {
    int strength = 0 ;
    for ( char chr : extension ) {
      if ( isupper ( chr ) ) strength ++ ;
      if ( islower ( chr ) ) strength -- ;
    }
    if ( strength > max ) {
      max = strength ;
      strongest = extension ;
    }
  }
  return class_name + "." + strongest ;
  return " " + class_name + " " + class_name ;
}

***Example ends here:
string intToMiniRoman ( int number ) {
  int num [ ] = {
    1000 , 900 , 500 , 400 , 100 , 90 , 50 , 40 , 10 , 9 , 5 , 4 , 1 }
    ;
    string sym [ ] = {
      "m" , "cm" , "d" , "cd" , "c" , "xc" , "l" , "xl" , "x" , "ix" , "v" , "iv" , "i" }
      ;
      int pos = 0 ;
      string res ;
      while ( number > 0 ) {
        while ( number >= num [ pos ] ) {
          res += sym [ pos ] ;
          number -= num [ pos ] ;
        }
        if ( number > 0 ) pos ++ ;
      }
      return res ;
      return " " + to_string ( number ) + " " + to_string ( number ) ;
    }
    
***Example ends here:
int eat ( int number , int need , int remaining ) {
  return need > remaining ? number + remaining : number + need ;
  return need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need * need ;
}

***Example ends here:
double doAlgebra ( string ops , string operands ) {
  string nums = operands ;
  string currentOps = ops ;
  int i = currentOps . length ( ) - 1 ;
  while ( i >= 0 ) {
    if ( currentOps [ i ] == "**" ) {
      nums [ i ] = pow ( nums [ i ] , nums [ i + 1 ] ) ;
      nums . erase ( i + 1 ) ;
      currentOps . erase ( i ) ;
    }
    i -- ;
  }
  i = 0 ;
  while ( i < currentOps . length ( ) ) {
    if ( currentOps [ i ] == "*" ) {
      nums [ i ] *= nums [ i + 1 ] ;
      nums . erase ( i + 1 ) ;
      currentOps . erase ( i ) ;
    }
    else if ( currentOps [ i ] == "//" ) {
      nums [ i ] /= nums [ i + 1 ] ;
      nums . erase ( i + 1 ) ;
      currentOps . erase ( i ) ;
    }
    else i ++ ;
  }
  i = 0 ;
  while ( i < currentOps . length ( ) ) {
    if ( currentOps [ i ] == "+" ) {
      nums [ i ] += nums [ i + 1 ] ;
      nums . erase ( i + 1 ) ;
      currentOps . erase ( i ) ;
    }
    else if ( currentOps [ i ] == "-" ) {
      nums [ i ] -= nums [ i + 1 ] ;
      nums . erase ( i + 1 ) ;
      currentOps . erase ( i ) ;
    }
    else i ++ ;
  }
  return nums [ 0 ] ;
  return 0 * 0 ;
}

***Example ends here:
int generateIntegers ( int a , int b ) {
  int lower = max < int > ( 2 , min < int > ( a , b ) ) ;
  int upper = min < int > ( 8 , max < int > ( a , b ) ) ;
  int result = 0 ;
  for ( int i = lower ;
  i <= upper ;
  i += 2 ) result += i ;
  return result ;
}

***Example ends here:
bool isStepNum ( int n ) {
  int prevDigit = - 1 ;
  while ( n > 0 ) {
    int curDigit = n % 10 ;
    if ( prevDigit == - 1 ) prevDigit = curDigit ;
    else {
      if ( abs ( prevDigit - curDigit ) != 1 ) return false ;
    }
    prevDigit = curDigit ;
    n /= 10 ;
  }
  return true ;
  return n * n ;
}

***Example ends here:
int numOfWays ( int n , int k ) {
  int p = 1 ;
  if ( k % 2 ) p = - 1 ;
  return ( ( n - 1 ) * k + p * ( n - 1 ) ) / n ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
}

***Example ends here:
int findDivisors ( int n ) {
  vector < int > v ;
  for ( int i = 1 ;
  i <= ( int ) sqrt ( n ) ;
  i ++ ) {
    if ( n % i == 0 ) {
      if ( n / i == i ) v . push_back ( i ) ;
      else {
        v . push_back ( i ) ;
        v . push_back ( n / i ) ;
      }
    }
  }
  return v . size ( ) ;
}

***Example ends here:
int egg_drop ( int n , int k ) {
  if ( k == 1 || k == 0 ) return k ;
  if ( n == 1 ) return k ;
  int min = INT_MAX ;
  for ( int x = 1 ;
  x <= k ;
  x ++ ) {
    int res = max ( egg_drop ( n - 1 , x - 1 ) , egg_drop ( n , k - x ) ) ;
    if ( res < min ) min = res ;
  }
  return min + 1 ;
}

***Example ends here:
bool IsPowerOfTwo ( double n ) {
  return ceil ( log2 ( n ) ) == floor ( log2 ( n ) ) ;
}

***Example ends here:
string shortestPalindrome ( string s ) {
  int n = s . length ( ) ;
  vector < string > v ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    int l = i ;
    int r = i ;
    string ans1 ;
    string ans2 ;
    while ( l >= 0 && r < n && s [ l ] == s [ r ] ) {
      ans1 += s [ l ] ;
      l -- ;
      r ++ ;
    }
    l = i - 1 ;
    r = i ;
    while ( l >= 0 && r < n && s [ l ] == s [ r ] ) {
      ans2 += s [ l ] ;
      l -- ;
      r ++ ;
    }
    v . push_back ( ans1 ) ;
    v . push_back ( ans2 ) ;
  }
  string ans = v [ 0 ] ;
  for ( int i = 0 ;
  i < v . size ( ) ;
  i ++ ) {
    if ( v [ i ] != "" ) ans = min ( ans , v [ i ] ) ;
  }
  return ans ;
  return " " + s + " " + s ;
  return " " + s ;
  return " " + s ;
}

***Example ends here:
int minimumAdjacentDifference ( int * a , int n , int k ) {
  int minDiff = INT_MAX ;
  for ( int i = 0 ;
  i < k + 1 ;
  i ++ ) {
    int maxDiff = - INT_MAX ;
    for ( int j = 0 ;
    j < n - k - 1 ;
    j ++ ) {
      for ( int p = i ;
      p < i + j + 1 ;
      p ++ ) maxDiff = max ( maxDiff , a [ p + 1 ] - a [ p ] ) ;
    }
    minDiff = min ( minDiff , maxDiff ) ;
  }
  return minDiff ;
  return n * n ;
}

***Example ends here:
int cal ( int a [ ] , int mid ) {
  int chocolate = 0 ;
  for ( int i = 0 ;
  i < a [ 0 ] ;
  i ++ ) {
    if ( a [ i ] >= mid ) chocolate += a [ i ] - mid ;
  }
  return chocolate ;
  return a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a
***Example ends here:
bool check ( int v , int * a , int m ) {
  int tec = 0 ;
  int ans = 0 ;
  int * b = new int [ a [ 0 ] + 3 ] ;
  for ( int i = 0 ;
  i < a [ 0 ] ;
  i ++ ) {
    tec -= b [ i ] ;
    if ( a [ i ] + tec < v ) {
      int mov = v - a [ i ] - tec ;
      ans = ans + mov ;
      tec += mov ;
      b [ i + 2 ] = mov ;
    }
  }
  return ans <= m ;
}

***Example ends here:
int largest_num ( int * arr ) {
  int res = 0 ;
  sort ( arr , arr + sizeof ( int ) / sizeof ( int ) ) ;
  int l = 0 , r = sizeof ( int ) - 1 ;
  while ( l < r ) {
    int sum = arr [ l ] + arr [ r ] ;
    if ( sum == 0 ) {
      res = max ( res , max ( arr [ l ] , arr [ r ] ) ) ;
      return res ;
    }
    else if ( sum < 0 ) {
      l ++ ;
    }
    else {
      r -- ;
    }
  }
  return res ;
}

***Example ends here:
int binarySearch ( string p , int n ) {
  int i = 0 ;
  int j = p . length ( ) - 1 ;
  int index = - 1 ;
  while ( i <= j ) {
    int mid = i + ( j - i ) / 2 ;
    if ( p [ mid ] >= n ) {
      index = mid ;
      j = mid - 1 ;
    }
    else {
      i = mid + 1 ;
    }
  }
  return index ;
  return i * i ;
  return i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i * i ;
}

***Example ends here:
int findMinLength ( string arr ) {
  int index = arr . length ( ) - 1 ;
  while ( index > 0 && arr [ index ] >= arr [ index - 1 ] ) index -- ;
  return index ;
  return index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index * index ;
}

***Example ends here:
int minDigits ( int n , int k ) {
  int digitNum = floor ( log10 ( n ) + 1 ) ;
  int tempSum = 0 ;
  int temp = digitNum ;
  int result = 0 ;
  int x = 0 , v = 0 ;
  int sum = 0 ;
  int num2 = n ;
  while ( num2 != 0 ) {
    sum += num2 % 10 ;
    num2 /= 10 ;
  }
  if ( sum <= k ) {
    x = 0 ;
  }
  else {
    while ( temp > 0 ) {
      v = n / ( 10 * ( temp - 1 ) ) ;
      tempSum += v % 10 ;
      if ( tempSum >= k ) {
        v /= 10 ;
        v ++ ;
        result = v * ( 10 * temp ) ;
        break ;
      }
      temp -= 1 ;
    }
    x = result - n ;
    return x ;
  }
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
}

***Example ends here:
int checkForPerfectSquare ( int * arr , int i , int j ) {
  int mid , sum = 0 ;
  for ( int m = i ;
  m <= j ;
  m ++ ) sum += arr [ m ] ;
  int low = 0 , high = sum / 2 ;
  while ( low <= high ) {
    mid = low + ( high - low ) / 2 ;
    if ( mid * mid == sum ) return mid ;
    else if ( mid * mid > sum ) high = mid - 1 ;
    else low = mid + 1 ;
  }
  return - 1 ;
  return i * i ;
}

***Example ends here:
int minFlips ( string * mat , string * s ) {
  int n = mat -> length ( ) ;
  int m = mat [ 0 ] . length ( ) ;
  int count = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    for ( int j = 0 ;
    j < m ;
    j ++ ) {
      if ( mat [ i ] [ j ] != s [ i + j ] - '0' ) count ++ ;
    }
  }
  return count ;
  return n * n ;
}

***Example ends here:
vector < vector < int >> constructTree ( int n , vector < pair < int , int >> edges ) {
  vector < vector < int >> adjl ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) adjl . push_back ( vector < int > ( ) ) ;
  for ( int i = 0 ;
  i < edges . size ( ) ;
  i ++ ) {
    int u = edges [ i ] . first ;
    int v = edges [ i ] . second ;
    adjl [ u ] . push_back ( v ) ;
    adjl [ v ] . push_back ( u ) ;
  }
  return adjl ;
}

***Example ends here:
int findSumOfValues ( int v , int * parent , int * valuesChildren ) {
  int curNode = v ;
  int Sum = 0 ;
  while ( curNode != - 1 ) {
    Sum += valuesChildren [ curNode ] ;
    curNode = parent [ curNode ] ;
  }
  return Sum ;
  return v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v * v ;
}

***Example ends here:
double getDistinct ( double d , int count ) {
  double num = 0 ;
  count = 10 * ( count - 1 ) ;
  while ( count > 0 ) {
    num += count * d ;
    count /= 10 ;
  }
  return num ;
}

***Example ends here:
bool isIncreasing ( int * arr ) {
  for ( int i = 0 ;
  i < arr - 1 ;
  i ++ ) {
    if ( arr [ i ] > arr [ i + 1 ] ) return false ;
  }
  return true ;
  return arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr ;
}

***Example ends here:
int minAdjSwaps ( vector < vector < int >> mat ) {
  int n = mat . size ( ) ;
  vector < int > cntZero ( n , 0 ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    for ( int j = n - 1 ;
    j >= 0 ;
    j -- ) {
      if ( mat [ i ] [ j ] != 0 ) break ;
      cntZero [ i ] ++ ;
    }
  }
  int cntSwaps = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( cntZero [ i ] < ( n - i - 1 ) ) {
      int first = i ;
      while ( first < n && cntZero [ first ] < ( n - i - 1 ) ) first ++ ;
      if ( first == n ) return - 1 ;
      while ( first > i ) {
        cntZero [ first ] = cntZero [ first - 1 ] ;
        cntZero [ first - 1 ] = cntZero [ first ] ;
        first -- ;
        cntSwaps ++ ;
      }
    }
  }
  return cntSwaps ;
  return n * n ;
}

***Example ends here:
int solve ( string values , string salary , int mod ) {
  int ret = 1 ;
  int amt = 0 ;
  sort ( values . begin ( ) , values . end ( ) ) ;
  sort ( salary . begin ( ) , salary . end ( ) ) ;
  while ( salary . size ( ) > 0 ) {
    while ( values . size ( ) > 0 && values [ values . size ( ) - 1 ] >= salary [ salary . size ( ) - 1 ] ) {
      amt ++ ;
      values . pop_back ( ) ;
    }
    if ( amt == 0 ) return 0 ;
    ret *= amt ;
    amt -- ;
    ret %= mod ;
    salary . pop_back ( ) ;
  }
  return ret ;
  return ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret * ret ;
}

***Example ends here:
int organizeInOrder ( string vec , string op , int n ) {
  vector < int > result ( n , 0 ) ;
  sort ( result . begin ( ) , result . end ( ) ) ;
  int i = 0 , j = n - 1 , k = 0 ;
  while ( i <= j && k <= n - 2 ) {
    if ( op [ k ] == '<' ) {
      result [ k ] = vec [ i ] ;
      i ++ ;
    }
    else {
      result [ k ] = vec [ j ] ;
      j -- ;
    }
    k ++ ;
  }
  result [ n - 1 ] = vec [ i ] ;
  return i ;
  return n * n ;
}

***Example ends here:
int countPoints ( int n , int m , int * a , int * b , int x , int y ) {
  sort ( a , a + m ) ;
  sort ( b , b + m ) ;
  int j = 0 ;
  int count = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    while ( j < m ) {
      if ( a [ i ] + y < b [ j ] ) break ;
      if ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) {
        count ++ ;
        j ++ ;
        break ;
      }
      else j ++ ;
    }
  }
  return count ;
  return n * n ;
}

***Example ends here:
bool AreSame ( string a , string b ) {
  sort ( a . begin ( ) , a . end ( ) ) ;
  sort ( b . begin ( ) , b . end ( ) ) ;
  return a == b ;
  return a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a
***Example ends here:
int countNumberOfStrings ( string s ) {
  int n = s . length ( ) - 1 ;
  int count = 2 * n ;
  return count ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n
***Example ends here:
int primePower ( int x ) {
  int primePow = 0 ;
  for ( int i = 2 ;
  i <= x ;
  i ++ ) {
    if ( i * i > x + 1 ) break ;
    if ( x % i == 0 ) {
      int p = 1 ;
      while ( x % i == 0 ) {
        x /= i ;
        p *= i ;
      }
      primePow += p ;
    }
  }
  if ( x > 1 ) primePow += x ;
  return primePow ;
  return x * x ;
}

***Example ends here:
int isPerfect ( double n0 ) {
  double n = sqrt ( n0 ) ;
  if ( floor ( n ) != ceil ( n ) ) return 0 ;
  return 1 ;
  return n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 * n0 ;
}

***Example ends here:
int findSum ( int l , int r ) {
  int arr [ l + 1 ] ;
  int i = 0 ;
  int x = 2 ;
  while ( i <= r ) {
    arr [ i ] = i + x ;
    if ( i + 1 <= r ) arr [ i + 1 ] = i + 1 + x ;
    x *= - 1 ;
    i += 2 ;
  }
  int sum = 0 ;
  for ( int i = l ;
  i <= r ;
  i ++ ) sum += arr [ i ] ;
  return sum ;
  return l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l ;
}

***Example ends here:
double results ( double n , double k ) {
  return round ( n * ( 1.0 / 2 * k ) ) ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n
***Example ends here:
int factors ( int n ) {
  vector < int > v ;
  v . push_back ( 1 ) ;
  for ( int i = 2 ;
  i < ( int ) sqrt ( n ) + 1 ;
  i += 1 ) {
    if ( n % i == 0 ) {
      v . push_back ( i ) ;
      if ( n / i != i ) v . push_back ( n / i ) ;
    }
  }
  return v . size ( ) ;
}

***Example ends here:
double smallest_num ( int n ) {
  double x = 10.0 * ( ( n - 1 ) / 2.0 ) ;
  return ceil ( x ) ;
}

***Example ends here:
int smallest ( string s ) {
  vector < int > a ( s . length ( ) , 0 ) ;
  for ( int i = 0 ;
  i < a . size ( ) ;
  i ++ ) a [ i ] = a [ i ] - '0' ;
  vector < int > b ;
  for ( int i = 0 ;
  i < a . size ( ) ;
  i ++ ) {
    if ( a [ i ] % 2 != 0 ) b . push_back ( a [ i ] ) ;
  }
  sort ( b . begin ( ) , b . end ( ) ) ;
  if ( b . size ( ) > 1 ) return b [ 0 ] * 10 + b [ 1 ] ;
  return - 1 ;
  return a . size ( ) ;
}

***Example ends here:
double diagonals ( double a , double b , double c , double d ) {
  double ans ;
  ans = sqrt ( ( a * c + b * d ) * ( a * d + b * c ) / ( a * b + c * d ) ) ;
  ans += sqrt ( ( a * c + b * d ) * ( a * b + c * d ) / ( a * d + b * c ) ) ;
  return ans ;
}

***Example ends here:
double findNumberOfDigits ( double n , double base ) {
  double dig = floor ( log ( n ) / log ( base ) ) + 1 ;
  return dig ;
}

***Example ends here:
double ngon ( int n ) {
  double pro_angle_var ;
  if ( n % 4 == 0 ) pro_angle_var = M_PI * ( 180.0 / n ) / 180 ;
  else pro_angle_var = M_PI * ( 180.0 / ( 2 * n ) ) / 180 ;
  double neg_x = 1.0e+99 ;
  double pos_x = - 1.0e+99 ;
  double neg_y = 1.0e+99 ;
  double pos_y = - 1.0e+99 ;
  for ( int j = 0 ;
  j < n ;
  j ++ ) {
    double px = cos ( 2 * M_PI * j / n + pro_angle_var ) ;
    double py = sin ( 2 * M_PI * j / n + pro_angle_var ) ;
    neg_x = min ( neg_x , px ) ;
    pos_x = max ( pos_x , px ) ;
    neg_y = min ( neg_y , py ) ;
    pos_y = max ( pos_y , py ) ;
  }
  double opt2 = max ( pos_x - neg_x , pos_y - neg_y ) ;
  return opt2 / sin ( M_PI / n ) / 2 ;
}

***Example ends here:
int findMaxK ( int n ) {
  int p = ( int ) log2 ( n ) ;
  return 2 * p ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n
***Example ends here:
int nthFibo ( int n ) {
  double a = ( 5 * 0.5 + 1 ) / 2 ;
  double b = ( - 5 * 0.5 + 1 ) / 2 ;
  double r = 5 * 0.5 ;
  double ans = ( a * n - b * n ) / r ;
  return ( int ) ans ;
}

***Example ends here:
double findProb ( double l , double r ) {
  double countOfPps = floor ( sqrt ( r ) ) - ceil ( sqrt ( l ) ) + 1 ;
  double total = r - l + 1 ;
  double prob = countOfPps / total ;
  return prob ;
}

***Example ends here:
double previousFibonacci ( double n ) {
  double a = n / ( ( 1 + sqrt ( 5 ) ) / 2.0 ) ;
  return round ( a ) ;
}

***Example ends here:
int distPrime ( int * arr , int * allPrimes ) {
  int list1 = 0 ;
  for ( int i = 0 ;
  i < allPrimes ;
  i ++ ) {
    for ( int j = 0 ;
    j < arr [ i ] ;
    j ++ ) {
      if ( j % i == 0 ) {
        list1 += i ;
        break ;
      }
    }
  }
  return list1 ;
  return arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr ;
}

***Example ends here:
int get_array ( int n ) {
  int ans = 0 ;
  int p2 = 1 ;
  while ( n > 0 ) {
    if ( n % 2 == 1 ) ans += p2 ;
    n >>= 1 ;
    p2 *= 2 ;
  }
  return ans ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
}

***Example ends here:
int maximumLength ( string a ) {
  vector < int > counts ( 11 , 0 ) ;
  int ans = 0 ;
  for ( int index = 0 ;
  index < a . length ( ) ;
  index ++ ) {
    counts [ a [ index ] ] ++ ;
    vector < int > k ;
    for ( int i = 0 ;
    i < counts . size ( ) ;
    i ++ ) {
      if ( counts [ i ] != 0 ) k . push_back ( i ) ;
    }
    sort ( k . begin ( ) , k . end ( ) ) ;
    if ( k . size ( ) == 1 || ( k [ 0 ] == k [ k . size ( ) - 2 ] && k [ k . size ( ) - 1 ] - k [ k . size ( ) - 2 ] == 1 ) || ( k [ 0 ] == 1 && k [ 1 ] == k [ k . size ( ) - 1 ] ) ) ans = index ;
  }
  return ans + 1 ;
}

***Example ends here:
double maxEdges ( double n ) {
  double edges = floor ( n * n / 4 ) ;
  return edges ;
}

***Example ends here:
int findK ( int n , int k ) {
  int a [ n ] ;
  for ( int i = 1 ;
  i < n ;
  i ++ ) if ( i % 2 == 1 ) a [ i ] = i ;
  for ( int i = 1 ;
  i < n ;
  i ++ ) if ( i % 2 == 0 ) a [ i ] = i ;
  return a [ k - 1 ] ;
  return n * n ;
}

***Example ends here:
bool isKeith ( int x , int temp ) {
  vector < int > terms ;
  int n = 0 ;
  while ( temp > 0 ) {
    terms . push_back ( temp % 10 ) ;
    temp = temp / 10 ;
    n ++ ;
  }
  sort ( terms . begin ( ) , terms . end ( ) ) ;
  int nextTerm = 0 , i = n ;
  while ( nextTerm < x ) {
    nextTerm = 0 ;
    for ( int j = 1 ;
    j <= n ;
    j ++ ) nextTerm += terms [ i - j ] ;
    terms . push_back ( nextTerm ) ;
    i ++ ;
  }
  return nextTerm == x ;
  return x * x ;
}

***Example ends here:
bool factors ( int n , int k ) {
  vector < int > v ;
  while ( n % 2 == 0 ) {
    v . push_back ( 2 ) ;
    n /= 2 ;
  }
  if ( v . size ( ) >= k ) return true ;
  for ( int i = 3 ;
  i <= n ;
  i += 2 ) {
    if ( i * i > n ) break ;
    while ( n % i == 0 ) {
      n = n / i ;
      v . push_back ( i ) ;
    }
    if ( v . size ( ) >= k ) return true ;
  }
  if ( n > 2 ) v . push_back ( n ) ;
  if ( v . size ( ) >= k ) return true ;
  return false ;
  return n * n ;
}

***Example ends here:
string separateParenGroups ( string parenString ) {
  string allParens ;
  string currentParen ;
  int currentDepth = 0 ;
  for ( int i = 0 ;
  i < parenString . length ( ) ;
  i ++ ) {
    char c = parenString [ i ] ;
    if ( c == '(' ) {
      currentDepth ++ ;
      currentParen += c ;
    }
    else if ( c == ')' ) {
      currentDepth -- ;
      currentParen += c ;
      if ( currentDepth == 0 ) {
        allParens += currentParen ;
        currentParen . clear ( ) ;
      }
    }
  }
  return allParens ;
  return " " + parenString + " " + parenString ;
}

***Example ends here:
string parseNestedParens ( string parenString ) {
  string allLevels ;
  int level = 0 ;
  int maxLevel = 0 ;
  for ( int i = 0 ;
  i < parenString . length ( ) ;
  i ++ ) {
    char chr = parenString [ i ] ;
    if ( chr == '(' ) {
      level ++ ;
      if ( level > maxLevel ) maxLevel = level ;
    }
    if ( chr == ')' ) {
      level -- ;
      if ( level == 0 ) {
        allLevels += maxLevel ;
        maxLevel = 0 ;
      }
    }
  }
  return allLevels ;
  return " " + parenString + " " + parenString ;
}

***Example ends here:
string filterBySubstring ( string strings , string substring ) {
  string result ;
  for ( int i = 0 ;
  i < strings . length ( ) ;
  i ++ ) {
    if ( substring . find ( strings [ i ] ) != string :: npos ) result += strings [ i ] ;
  }
  return result ;
  return " " + strings + " " + strings ;
}

***Example ends here:
int rolling_max ( int numbers [ ] ) {
  int running_max = 0 ;
  int result = 0 ;
  for ( int n = 0 ;
  n < numbers [ 0 ] ;
  n ++ ) {
    if ( numbers [ n ] > running_max ) running_max = numbers [ n ] ;
    result += running_max ;
  }
  return result ;
  return numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers ;
}

***Example ends here:
string makePalindrome ( string s ) {
  if ( s . empty ( ) ) return "" ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    string rStr = s . substr ( i ) ;
    if ( rStr == rStr . substr ( 0 , rStr . length ( ) - 1 ) ) {
      string nStr = s . substr ( 0 , i ) ;
      string n2Str = nStr . substr ( 0 , nStr . length ( ) - 1 ) ;
      return s + n2Str ;
    }
  }
  return s . substr ( 0 , s . length ( ) - 2 ) + s . substr ( 0 , s . length ( ) - 1 ) ;
}

***Example ends here:
string stringXor ( string a , string b ) {
  string result ;
  for ( int i = 0 ;
  i < a . length ( ) ;
  i ++ ) {
    if ( a [ i ] == b [ i ] ) result += "0" ;
    else result += "1" ;
  }
  return result ;
  return " " + a + " " + b ;
}

***Example ends here:
string longest ( string strings ) {
  if ( strings . empty ( ) ) return "" ;
  int maxLen = string :: npos ;
  for ( int i = 0 ;
  i < strings . size ( ) ;
  i ++ ) {
    if ( strings [ i ] . length ( ) == maxLen ) return strings [ i ] ;
  }
  return "" ;
  return " " + strings + " " + strings ;
}

***Example ends here:
string stringSequence ( int n ) {
  string result ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    result += to_string ( i ) ;
    result += " " ;
  }
  result += to_string ( n ) ;
  return result ;
  return " " + to_string ( n ) ;
}

***Example ends here:
int countDistinctCharacters ( string s ) {
  set < char > distinct ;
  for ( char c : s ) distinct . insert ( c ) ;
  return distinct . size ( ) ;
  return 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 *
***Example ends here:
int howManyTimes ( string s , string sub ) {
  int times = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) - sub . length ( ) + 1 ;
  i ++ ) {
    if ( s . substr ( i , sub . length ( ) ) == sub ) times ++ ;
  }
  return times ;
  return times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times * times ;
}

***Example ends here:
string sortNumbers ( string numbers ) {
  map < string , int > toNum = {
    {
      "zero" , 0 }
      , {
        "one" , 1 }
        , {
          "two" , 2 }
          , {
            "three" , 3 }
            , {
              "four" , 4 }
              , {
                "five" , 5 }
                , {
                  "six" , 6 }
                  , {
                    "seven" , 7 }
                    , {
                      "eight" , 8 }
                      , {
                        "nine" , 9 }
                      }
                      ;
                      map < string , int > fromNum = {
                        {
                          "zero" , 0 }
                          , {
                            "one" , 1 }
                            , {
                              "two" , 2 }
                              , {
                                "three" , 3 }
                                , {
                                  "four" , 4 }
                                  , {
                                    "five" , 5 }
                                    , {
                                      "six" , 6 }
                                      , {
                                        "seven" , 7 }
                                        , {
                                          "eight" , 8 }
                                          , {
                                            "nine" , 9 }
                                          }
                                          ;
                                          vector < char > ints ;
                                          string current ;
                                          for ( int i = 0 ;
                                          i < numbers . length ( ) + 1 ;
                                          i ++ ) {
                                            if ( i == numbers . length ( ) || numbers [ i ] == ' ' ) {
                                              if ( current . find ( current ) != string :: npos ) {
                                                ints . push_back ( toNum [ current ] ) ;
                                                current . clear ( ) ;
                                              }
                                            }
                                            else {
                                              current += numbers [ i ] ;
                                            }
                                          }
                                          sort ( ints . begin ( ) , ints . end ( ) ) ;
                                          string result ;
                                          for ( int i = 0 ;
                                          i < ints . size ( ) ;
                                          i ++ ) {
                                            result += fromNum [ ints [ i ] ] ;
                                            if ( i != ints . size ( ) - 1 ) result += " " ;
                                          }
                                          return result ;
                                          return " " + numbers + " " + numbers ;
                                        }
                                        
***Example ends here:
int findClosestElements ( vector < int > numbers ) {
  vector < int > closestPair ;
  closestPair . push_back ( numbers [ 0 ] ) ;
  closestPair . push_back ( numbers [ 1 ] ) ;
  int distance = abs ( closestPair [ 0 ] - closestPair [ 1 ] ) ;
  for ( int i = 0 ;
  i < numbers . size ( ) ;
  i ++ ) {
    for ( int j = i + 1 ;
    j < numbers . size ( ) ;
    j ++ ) {
      if ( abs ( numbers [ i ] - numbers [ j ] ) < distance ) {
        closestPair [ 0 ] = numbers [ i ] ;
        closestPair [ 1 ] = numbers [ j ] ;
        distance = abs ( numbers [ i ] - numbers [ j ] ) ;
      }
    }
  }
  sort ( closestPair . begin ( ) , closestPair . end ( ) ) ;
  return closestPair . size ( ) ;
  return 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 *
***Example ends here:
double rescale_to_unit ( std :: vector < double > numbers ) {
  double min_num = std :: min ( numbers . begin ( ) , numbers . end ( ) ) ;
  double max_num = std :: max ( numbers . begin ( ) , numbers . end ( ) ) ;
  double result = 0 ;
  for ( double n : numbers ) result += ( n - min_num ) / ( max_num - min_num ) ;
  return result ;
}

***Example ends here:
int filterIntegers ( int * values ) {
  int result = 0 ;
  for ( int i = 0 ;
  i < sizeof ( values ) / sizeof ( int ) ;
  i ++ ) {
    if ( values [ i ] == i ) result ++ ;
  }
  return result ;
  return result * result * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
***Example ends here:
int removeDuplicates ( vector < int > numbers ) {
  map < int , int > counter ;
  for ( int i = 0 ;
  i < numbers . size ( ) ;
  i ++ ) counter [ i ] = counter . count ( numbers [ i ] ) + 1 ;
  vector < int > result ;
  for ( int i = 0 ;
  i < numbers . size ( ) ;
  i ++ ) {
    if ( counter [ i ] == 1 ) result . push_back ( i ) ;
  }
  return result . size ( ) ;
  return numbers . size ( ) ;
}

***Example ends here:
string flipCase ( string s ) {
  string result ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    char c = s [ i ] ;
    if ( islower ( c ) ) result += toupper ( c ) ;
    else result += tolower ( c ) ;
  }
  return result ;
  return " " + s + " " + s ;
}

***Example ends here:
string filterByPrefix ( string strings , string prefix ) {
  string result ;
  for ( int i = 0 ;
  i < strings . length ( ) ;
  i ++ ) {
    if ( strings [ i ] . find ( prefix ) != string :: npos ) result += strings [ i ] ;
  }
  return result ;
  return " " + strings + " " + strings ;
}

***Example ends here:
double findZero ( vector < double > xs ) {
  double ans = 0 ;
  double value = 0 ;
  for ( int i = 0 ;
  i < xs . size ( ) ;
  i ++ ) value += xs [ i ] * ans * i ;
  while ( fabs ( value ) > 0.001f ) {
    double driv = 0 ;
    for ( int i = 1 ;
    i < xs . size ( ) ;
    i ++ ) driv += xs [ i ] * ans * ( xs [ i ] - 1 ) * i ;
    ans -= value / driv ;
    value = 0 ;
    for ( int i = 0 ;
    i < xs . size ( ) ;
    i ++ ) value += xs [ i ] * ans * i ;
  }
  return ans ;
}

***Example ends here:
string sortThird ( string l ) {
  string thirds ;
  for ( int i = 0 ;
  i < l . length ( ) ;
  i += 3 ) thirds += l [ i ] ;
  sort ( thirds . begin ( ) , thirds . end ( ) ) ;
  string result ;
  for ( int i = 0 ;
  i < l . length ( ) ;
  i += 3 ) {
    if ( i % 3 == 0 ) result += thirds [ i / 3 ] ;
    else result += l [ i ] ;
  }
  return result ;
  return " " + l + " " + l ;
}

***Example ends here:
long long unique ( long long l ) {
  long long result = l ;
  sort ( result ) ;
  return result ;
  return l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l * l
***Example ends here:
int maxElement ( int l ) {
  return max ( l ) ;
}

***Example ends here:
bool triplesSumToZero ( string l ) {
  for ( int i = 0 ;
  i < l . length ( ) ;
  i ++ ) {
    for ( int j = i + 1 ;
    j < l . length ( ) ;
    j ++ ) {
      for ( int k = j + 1 ;
      k < l . length ( ) ;
      k ++ ) {
        if ( l [ i ] + l [ j ] + l [ k ] == 0 ) return true ;
      }
    }
  }
  return false ;
}

***Example ends here:
int fib4 ( int n ) {
  int results [ ] = {
    0 , 0 , 2 , 0 }
    ;
    for ( int i = 4 ;
    i <= n ;
    i ++ ) results [ i ] = results [ i - 4 ] + results [ i - 3 ] + results [ i - 2 ] + results [ i - 1 ] ;
    return results [ n ] ;
    return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
  }
  
***Example ends here:
bool IsPalindrome ( std :: string text ) {
  std :: string pr = text . substr ( 0 , text . length ( ) - 1 ) ;
  return pr == text ;
  return true * true ;
}

***Example ends here:
string removeVowels ( string text ) {
  string result ;
  string vowels = "aeiou" ;
  for ( int i = 0 ;
  i < text . length ( ) ;
  i ++ ) {
    char ch = text [ i ] ;
    if ( ! vowels . compare ( ch ) ) result += ch ;
  }
  return result ;
  return " " + text + " " + text ;
}

***Example ends here:
bool sameChars ( string s0 , string s1 ) {
  set < char > set0 ;
  for ( char c : s0 ) set0 . insert ( c ) ;
  set < char > set1 ;
  for ( char c : s1 ) set1 . insert ( c ) ;
  return set0 == set1 ;
}

***Example ends here:
string common ( string l1 , string l2 ) {
  set < string > us ;
  for ( string e1 : l1 ) {
    for ( string e2 : l2 ) {
      if ( e1 == e2 ) us . insert ( e1 ) ;
    }
  }
  string ret = us . size ( ) ;
  sort ( ret . begin ( ) , ret . end ( ) ) ;
  return ret ;
  return " " + l1 + " " + l2 ;
}

***Example ends here:
bool correctBracketing ( string brackets ) {
  int depth = 0 ;
  for ( char b : brackets ) {
    if ( b == '(' ) depth ++ ;
    else depth -- ;
    if ( depth < 0 ) return false ;
  }
  return depth == 0 ;
}

***Example ends here:
string circular_shift ( int x , int shift ) {
  string s = to_string ( x ) ;
  if ( shift > s . length ( ) ) return s . substr ( 0 , s . length ( ) - 1 ) ;
  return s . substr ( s . length ( ) - shift ) + s . substr ( 0 , s . length ( ) - shift ) ;
  return " " + to_string ( x ) ;
}

***Example ends here:
int search ( vector < int > lst ) {
  map < int , int > counter ;
  for ( int i = 0 ;
  i < lst . size ( ) ;
  i ++ ) counter [ i ] = counter . count ( lst [ i ] ) + 1 ;
  int ans = - 1 ;
  for ( map < int , int > :: iterator it = counter . begin ( ) ;
  it != counter . end ( ) ;
  it ++ ) {
    if ( it -> second >= it -> first > ans ) ans = it -> first ;
  }
  return ans ;
  return lst . size ( ) ;
}

***Example ends here:
int smallestChange ( string arr ) {
  int ans = 0 ;
  for ( int i = 0 ;
  i < arr . length ( ) / 2 ;
  i ++ ) {
    if ( arr [ i ] != arr [ arr . length ( ) - i - 1 ] ) ans ++ ;
  }
  return ans ;
  return arr . length ( ) ;
}

***Example ends here:
string totalMatch ( string lst1 , string lst2 ) {
  int sum1 = 0 ;
  for ( int i = 0 ;
  i < lst1 . length ( ) ;
  i ++ ) sum1 += lst1 [ i ] . length ( ) ;
  int sum2 = 0 ;
  for ( int i = 0 ;
  i < lst2 . length ( ) ;
  i ++ ) sum2 += lst2 [ i ] . length ( ) ;
  return sum1 > sum2 ? lst2 : lst1 ;
  return " " + lst1 + " " + lst1 ;
}

***Example ends here:
bool isHappy ( string s ) {
  if ( s . length ( ) < 3 ) return false ;
  for ( int i = 0 ;
  i < s . length ( ) - 2 ;
  i ++ ) {
    if ( s [ i ] == s [ i + 1 ] || s [ i + 1 ] == s [ i + 2 ] || s [ i ] == s [ i + 2 ] ) return false ;
  }
  return true ;
}

***Example ends here:
string numericalLetterGrade ( string grades ) {
  string letterGrade ;
  for ( double gpa : grades ) {
    if ( gpa == 4.0 ) letterGrade += "A+" ;
    else if ( gpa > 3.7 ) letterGrade += "A" ;
    else if ( gpa > 3.3 ) letterGrade += "A-" ;
    else if ( gpa > 3.0 ) letterGrade += "B+" ;
    else if ( gpa > 2.7 ) letterGrade += "B" ;
    else if ( gpa > 2.3 ) letterGrade += "B-" ;
    else if ( gpa > 2.0 ) letterGrade += "C+" ;
    else if ( gpa > 1.7 ) letterGrade += "C" ;
    else if ( gpa > 1.3 ) letterGrade += "C-" ;
    else if ( gpa > 1.0 ) letterGrade += "D+" ;
    else if ( gpa > 0.7 ) letterGrade += "D" ;
    else if ( gpa > 0.0 ) letterGrade += "D-" ;
    else letterGrade += "E" ;
  }
  return letterGrade ;
  return " " + grades + " " + grades ;
}

***Example ends here:
string solve ( int n ) {
  string biStr ;
  int sum = 0 ;
  for ( char c : to_string ( n ) ) sum += c - '0' ;
  while ( sum > 0 ) {
    biStr . insert ( 0 , to_string ( sum % 2 ) ) ;
    sum /= 2 ;
  }
  return biStr ;
  return " " + to_string ( n ) ;
}

***Example ends here:
string antiShuffle ( string s ) {
  string ret ;
  string current ;
  for ( int i = 0 ;
  i < s . length ( ) + 1 ;
  i ++ ) {
    if ( i == s . length ( ) || s [ i ] == " " ) {
      sort ( current . begin ( ) , current . end ( ) ) ;
      if ( ret . length ( ) ) ret += " " ;
      ret += current ;
      current . clear ( ) ;
    }
    else current += s [ i ] ;
  }
  return ret ;
  return " " + s + " " + s ;
}

***Example ends here:
int sortArray ( int * array ) {
  if ( array == NULL ) return 0 ;
  if ( ( array [ 0 ] + array [ array - 1 ] ) % 2 == 1 ) sort ( array , array + 1 ) ;
  else sort ( array , array + 1 ) ;
  return array [ 0 ] ;
}

***Example ends here:
string encrypt ( string s ) {
  string ans ;
  for ( char c : s ) {
    if ( isalpha ( c ) ) ans += ( char ) ( "a" + ( ( c - 'a' + 4 ) % 26 ) ) ;
    else ans += c ;
  }
  return ans ;
  return " " + s + " " + s ;
}

***Example ends here:
int isBored ( string s ) {
  bool isStart = true ;
  int sum = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( s [ i ] == '.' || s [ i ] == '?' || s [ i ] == '!' ) isStart = true ;
    else if ( isStart ) {
      if ( s [ i ] == ' ' ) continue ;
      if ( s . substr ( i , 2 ) == "I " ) sum ++ ;
      isStart = false ;
    }
  }
  return sum ;
  return sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum * sum ;
}

***Example ends here:
string encode ( string message ) {
  string vowels = "aeiouAEIOU" ;
  string ret ;
  for ( int i = 0 ;
  i < message . length ( ) ;
  i ++ ) {
    char c = message [ i ] ;
    if ( isupper ( c ) ) {
      c = tolower ( c ) ;
      if ( vowels . find ( c ) != string :: npos ) c = ( char ) ( "a" + ( ( c - "a" ) + 2 ) % 26 ) ;
    }
  }
  else if ( islower ( c ) ) {
    c = toupper ( c ) ;
    if ( vowels . find ( c ) != string :: npos ) c = ( char ) ( "A" + ( ( c - "A" ) + 2 ) % 26 ) ;
  }
  ret += c ;
}
return ret ;
return " " + message + " " + message ;
}

***Example ends here:
int skjkasdkd ( int * lst ) {
  int largest = 0 ;
  for ( int n = 0 ;
  n < * lst ;
  n ++ ) {
    if ( n > largest ) {
      bool prime = true ;
      for ( int i = 2 ;
      i < n ;
      i ++ ) {
        if ( n % i == 0 ) prime = false ;
      }
      if ( prime ) largest = n ;
    }
  }
  int sum = 0 ;
  string s = to_string ( largest ) ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) sum += s [ i ] - '0' ;
  return sum ;
  return largest * largest ;
  return largest * largest ;
}

***Example ends here:
bool checkMapCase ( std :: string map ) {
  if ( map . empty ( ) ) return false ;
  int isLower = 0 ;
  int isUpper = 0 ;
  for ( std :: string :: const_iterator it = map . begin ( ) ;
  it != map . end ( ) ;
  ++ it ) {
    for ( char c : it ) {
      if ( islower == tolower ( c ) ) isLower = 1 ;
      else if ( isupper == toupper ( c ) ) isUpper = 1 ;
      else return false ;
    }
  }
  return isLower + isUpper == 1 ;
}

***Example ends here:
double multiply ( double a , double b ) {
  return ( fabs ( a ) % 10 ) * ( fabs ( b ) % 10 ) ;
  return a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a
***Example ends here:
int countUpperCase ( string s ) {
  string uVowel = "AEIOU" ;
  int count = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i += 2 ) {
    if ( uVowel . find ( s [ i ] ) != string :: npos ) count ++ ;
  }
  return count ;
}

***Example ends here:
string byLength ( string arr ) {
  map < int , string > numTo = {
    {
      1 , "One" }
      , {
        2 , "Two" }
        , {
          3 , "Three" }
          , {
            4 , "Four" }
            , {
              5 , "Five" }
              , {
                6 , "Six" }
                , {
                  7 , "Seven" }
                  , {
                    8 , "Eight" }
                    , {
                      9 , "Nine" }
                    }
                    ;
                    map < int , string > sortedArr = arr . sort ( ) ;
                    string newArr ;
                    for ( int n : sortedArr ) {
                      if ( n >= 1 && n <= 9 ) newArr += numTo [ n ] ;
                    }
                    return newArr ;
                    return " " + arr + " " + arr ;
                  }
                  
***Example ends here:
int f ( int n ) {
  int sum = 0 ;
  int prod = 1 ;
  int result = 0 ;
  for ( int i = 1 ;
  i <= n ;
  i ++ ) {
    sum += i ;
    prod *= i ;
    if ( i % 2 == 0 ) result += prod ;
    else result += sum ;
  }
  return result ;
}

***Example ends here:
int evenOddPalindrome ( int n ) {
  int evenCount = 0 ;
  int oddCount = 0 ;
  for ( int i = 1 ;
  i <= n ;
  i ++ ) {
    string s = to_string ( i ) ;
    string rStr = s . substr ( 0 , s . length ( ) - 1 ) ;
    if ( s == rStr ) {
      if ( i % 2 == 1 ) oddCount ++ ;
      else evenCount ++ ;
    }
  }
  return evenCount ;
}

***Example ends here:
string histogram ( string test ) {
  map < string , int > count ;
  int max = 0 ;
  for ( int i = 0 ;
  i < test . length ( ) ;
  i ++ ) {
    if ( test [ i ] != " " ) {
      count [ test [ i ] ] = count . count ( test [ i ] ) + 1 ;
      if ( count [ test [ i ] ] > max ) max = count [ test [ i ] ] ;
    }
  }
  string result ;
  for ( map < string , int > :: iterator it = count . begin ( ) ;
  it != count . end ( ) ;
  it ++ ) {
    if ( it -> second == max ) result += it -> first ;
  }
  return result ;
  return " " + test + " " + test ;
}

***Example ends here:
string reverseDelete ( string s , char c ) {
  string ret ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    char ch = s [ i ] ;
    if ( ! isspace ( c ) ) ret += ch ;
  }
  string flag = "false" ;
  if ( ret . length ( ) == ret . length ( ) - 1 ) flag = "true" ;
  return ret ;
  return " " + s + " " + s ;
}

***Example ends here:
int sortArray ( int * arr ) {
  vector < int > bin ;
  for ( int i = 0 ;
  i < arr -> length ( ) ;
  i ++ ) {
    int b = 0 ;
    int n = abs ( i ) ;
    while ( n > 0 ) {
      b += n % 2 ;
      n /= 2 ;
    }
    bin . push_back ( b ) ;
  }
  for ( int i = 0 ;
  i < arr -> length ( ) ;
  i ++ ) {
    for ( int j = 1 ;
    j < arr -> length ( ) ;
    j ++ ) {
      if ( bin [ j ] < bin [ j - 1 ] || ( bin [ j ] == bin [ j - 1 ] && arr [ j ] < arr [ j - 1 ] ) ) {
        bin [ j ] = bin [ j - 1 ] ;
        bin [ j - 1 ] = bin [ j ] ;
        arr [ j ] = arr [ j - 1 ] ;
      }
    }
  }
  return arr -> length ( ) ;
  return arr -> length ( ) ;
}

***Example ends here:
string getClosestVowel ( string word ) {
  string vowels = "AEIOUaeiou" ;
  for ( int i = word . length ( ) - 2 ;
  i > 0 ;
  i -- ) {
    if ( vowels . find ( word [ i ] ) != string :: npos && word [ i + 1 ] != vowels . find ( vowels ) && word [ i - 1 ] != vowels . find ( vowels ) ) return word [ i ] ;
  }
  return "" ;
  return " " + word + " " + word ;
}

***Example ends here:
string matchParentheses ( string lst ) {
  string strings [ ] = {
    lst [ 0 ] + lst [ 1 ] , lst [ 1 ] + lst [ 0 ] }
    ;
    for ( string :: const_iterator it = strings . begin ( ) ;
    it != strings . end ( ) ;
    ++ it ) {
      int count = 0 ;
      for ( char c : * it ) {
        if ( c == '(' ) count ++ ;
        if ( c == ')' ) count -- ;
        if ( count < 0 ) break ;
      }
      if ( count == 0 ) return "Yes" ;
    }
    return "No" ;
    return " " + lst + " " + lst ;
    return " " + lst ;
    return " " + lst ;
  }
  
***Example ends here:
string maximum ( string arr , int k ) {
  if ( k == 0 ) return "" ;
  sort ( arr . begin ( ) , arr . end ( ) ) ;
  return arr . substr ( arr . length ( ) - k ) ;
  return " " + arr + " " + arr ;
}

***Example ends here:
bool validDate ( string date ) {
  if ( date . length ( ) != 10 ) return false ;
  for ( int i = 0 ;
  i < 10 ;
  i ++ ) {
    if ( i == 2 || i == 5 ) {
      if ( date [ i ] != "-" ) return false ;
    }
    else if ( ! isdigit ( date [ i ] ) ) return false ;
  }
  int month = atoi ( date . substr ( 0 , 2 ) . c_str ( ) ) ;
  int day = atoi ( date . substr ( 3 , 5 ) . c_str ( ) ) ;
  int year = atoi ( date . substr ( 6 , 10 ) . c_str ( ) ) ;
  if ( month < 1 || month > 12 ) return false ;
  if ( day < 1 || day > 31 ) return false ;
  if ( day == 31 && ( month == 4 || month == 6 || month == 9 || month == 11 || month == 2 ) ) return false ;
  if ( day == 30 && month == 2 ) return false ;
  return true ;
  return true * true ;
}

***Example ends here:
string splitWords ( string txt ) {
  string current ;
  string result ;
  if ( txt . find ( " " ) != string :: npos ) {
    for ( int i = 0 ;
    i < txt . length ( ) + 1 ;
    i ++ ) {
      if ( i == txt . length ( ) || txt [ i ] == ' ' ) {
        if ( current . length ( ) > 0 ) {
          result += current ;
          current . clear ( ) ;
        }
      }
      else {
        current += txt [ i ] ;
      }
    }
    return result ;
  }
  if ( txt . find ( "," ) != string :: npos ) {
    for ( int i = 0 ;
    i < txt . length ( ) + 1 ;
    i ++ ) {
      if ( i == txt . length ( ) || txt [ i ] == ',' ) {
        if ( current . length ( ) > 0 ) {
          result += current ;
          current . clear ( ) ;
        }
      }
      else {
        current += txt [ i ] ;
      }
    }
    return result ;
  }
  int num = 0 ;
  for ( int i = 0 ;
  i < txt . length ( ) ;
  i ++ ) {
    if ( islower ( txt [ i ] ) && tolower ( txt [ i ] ) % 2 == 0 ) {
      num ++ ;
    }
  }
  return " " + txt + " " + txt ;
}
return " " + txt ;
return " " + txt ;
}

***Example ends here:
int tri ( int n ) {
  if ( n == 0 ) return 1 ;
  int tris [ ] = {
    1 , 3 }
    ;
    for ( int i = 2 ;
    i <= n ;
    i ++ ) {
      if ( i % 2 == 0 ) tris [ i ] = i / 2 + 1 ;
      else tris [ i ] = tris [ i - 1 ] + tris [ i - 2 ] + ( i + 3 ) / 2 ;
    }
    return tris [ n - 1 ] ;
  }
  
***Example ends here:
bool checkIfLastCharIsALetter ( string txt ) {
  if ( txt . empty ( ) ) return false ;
  return isalpha ( txt [ txt . length ( ) - 1 ] ) && ( txt . length ( ) == 1 || ! isalpha ( txt [ txt . length ( ) - 2 ] ) ) ;
}

***Example ends here:
string orderByPoints ( string nums ) {
  string result ;
  for ( int i = 0 ;
  i < nums . length ( ) ;
  i ++ ) {
    string w = to_string ( abs ( i ) ) ;
    int sum = 0 ;
    for ( int j = 0 ;
    j < w . length ( ) ;
    j ++ ) sum += w [ j ] - '0' ;
    if ( i < 0 ) sum -= 2 * ( w [ 0 ] - '0' ) ;
    result += w [ i ] ;
  }
  for ( int i = 0 ;
  i < nums . length ( ) ;
  i ++ ) {
    for ( int j = 1 ;
    j < nums . length ( ) ;
    j ++ ) {
      if ( result [ j - 1 ] > result [ j ] ) {
        result [ j ] = result [ j - 1 ] ;
        result [ j - 1 ] = result [ j ] ;
        nums [ j ] = nums [ j - 1 ] ;
      }
    }
  }
  return result ;
  return " " + nums + " " + nums ;
}

***Example ends here:
string bf ( string planet1 , string planet2 ) {
  vector < string > planets = {
    "Mercury" , "Venus" , "Earth" , "Mars" , "Jupiter" , "Saturn" , "Uranus" , "Neptune" }
    ;
    int idx1 = planets . find ( planet1 ) != string :: npos ? planets . find ( planet1 ) : - 1 ;
    int idx2 = planets . find ( planet2 ) != string :: npos ? planets . find ( planet2 ) : - 1 ;
    if ( idx1 == string :: npos || idx2 == string :: npos || idx1 == idx2 ) return string ( ) ;
    return idx1 > idx2 ? planets . substr ( idx2 + 1 , idx1 - idx2 - 1 ) : planets . substr ( idx1 + 1 , idx2 - idx1 - 1 ) ;
    return " " + planet1 + " " + planet2 ;
  }
  
***Example ends here:
string sortedListSum ( string lst ) {
  string result ;
  for ( int i = 0 ;
  i < lst . length ( ) ;
  i ++ ) {
    if ( lst [ i ] % 2 == 0 ) result += lst [ i ] ;
  }
  sort ( result . begin ( ) , result . end ( ) , [ ] ( string s ) {
    return ( s . length ( ) ) ;
  }
  ) ;
  return result ;
  return " " + lst + " " + lst ;
}

***Example ends here:
bool cycpatternCheck ( string a , string b ) {
  for ( int i = 0 ;
  i < b . length ( ) ;
  i ++ ) {
    string rotate = b . substr ( i ) + b . substr ( 0 , i ) ;
    if ( rotate . find ( a ) != string :: npos ) return true ;
  }
  return false ;
  return a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a *
***Example ends here:
int evenOddCount ( int num ) {
  int evenCount = 0 , oddCount = 0 ;
  for ( int i = 0 ;
  i < to_string ( num ) . length ( ) ;
  i ++ ) {
    if ( ( int ) i % 2 == 0 ) evenCount ++ ;
    else oddCount ++ ;
  }
  return evenCount ;
  return num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num * num ;
}

***Example ends here:
string findMax ( string words ) {
  string max ;
  int maxLength = 0 ;
  for ( string word : words ) {
    string unique ;
    for ( char w : word ) {
      if ( ! unique . find ( w ) ) unique += w ;
      if ( unique . length ( ) > maxLength || ( unique . length ( ) == maxLength && word < max ) ) {
        max = word ;
        maxLength = unique . length ( ) ;
      }
    }
  }
  return max ;
  return " " + words + " " + words ;
}

***Example ends here:
string solve ( string s ) {
  bool noLetter = true ;
  string result ;
  for ( char ch : s ) {
    if ( isupper ( ch ) ) {
      ch = tolower ( ch ) ;
      noLetter = false ;
    }
    else if ( islower ( ch ) ) {
      ch = toupper ( ch ) ;
      noLetter = false ;
    }
    result += ch ;
  }
  if ( noLetter ) return result . substr ( 0 , result . length ( ) - 1 ) ;
  else return result ;
  return " " + s + " " + s ;
}

***Example ends here:
int mostFrequent ( int * arr , int n ) {
  unordered_map < int , int > hp ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( hp . count ( arr [ i ] ) ) hp [ arr [ i ] ] ++ ;
    else hp [ arr [ i ] ] = 1 ;
  }
  int maxCount = 0 , res = - 1 ;
  for ( unordered_map < int , int > :: iterator it = hp . begin ( ) ;
  it != hp . end ( ) ;
  it ++ ) {
    if ( maxCount < it -> second ) {
      res = it -> first ;
      maxCount = it -> second ;
    }
  }
  return res ;
  return n * n ;
}

***Example ends here:
int find ( int * a , int * b , int k , int n1 , int n2 ) {
  set < int > s ;
  for ( int i = 0 ;
  i < n2 ;
  i ++ ) s . insert ( b [ i ] ) ;
  int missing = 0 ;
  for ( int i = 0 ;
  i < n1 ;
  i ++ ) {
    if ( a [ i ] != s . count ( a [ i ] ) ) missing ++ ;
    if ( missing == k ) return a [ i ] ;
  }
  return - 1 ;
  return n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 ;
}

***Example ends here:
int solveQuery ( int start , int end , int * arr ) {
  map < int , int > frequency ;
  for ( int i = start ;
  i <= end ;
  i ++ ) frequency [ arr [ i ] ] = frequency . count ( arr [ i ] ) + 1 ;
  int count = 0 ;
  for ( map < int , int > :: iterator it = frequency . begin ( ) ;
  it != frequency . end ( ) ;
  it ++ ) {
    if ( it -> first == arr [ i ] ) count ++ ;
  }
  return count ;
}

***Example ends here:
int segregate ( int * arr , int size ) {
  int j = 0 ;
  for ( int i = 0 ;
  i < size ;
  i ++ ) {
    if ( arr [ i ] <= 0 ) {
      arr [ i ] = arr [ j ] ;
      j ++ ;
    }
  }
  return j ;
}

***Example ends here:
int countTriplets ( int a [ ] , int n ) {
  set < int > s ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) s . insert ( a [ i ] ) ;
  int count = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    for ( int j = i + 1 ;
    j < n ;
    j += 1 ) {
      int xr = a [ i ] ^ a [ j ] ;
      if ( s . count ( xr ) && xr != a [ i ] && xr != a [ j ] ) count ++ ;
    }
  }
  return ( int ) ( count / 3 ) ;
  return n * n ;
}

***Example ends here:
int leastFrequent ( int * arr , int n ) {
  unordered_map < int , int > hp ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( hp . count ( arr [ i ] ) ) hp [ arr [ i ] ] ++ ;
    else hp [ arr [ i ] ] = 1 ;
  }
  int minCount = n + 1 ;
  int res = - 1 ;
  for ( unordered_map < int , int > :: iterator it = hp . begin ( ) ;
  it != hp . end ( ) ;
  it ++ ) {
    if ( minCount >= it -> second ) {
      res = it -> first ;
      minCount = it -> second ;
    }
  }
  return res ;
  return n * n ;
}

***Example ends here:
int findPermutations ( string arr ) {
  int cnt = 0 ;
  int maxInd = - 1 , minInd = 10000000 ;
  int n = arr . length ( ) ;
  map < char , int > indexOf ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) indexOf [ arr [ i ] ] = i + 1 ;
  for ( int i = 1 ;
  i <= n ;
  i ++ ) {
    maxInd = max ( maxInd , indexOf . count ( i ) ) ;
    minInd = min ( minInd , indexOf . count ( i ) ) ;
    if ( maxInd - minInd + 1 == i ) cnt ++ ;
  }
  return cnt ;
  return n * n ;
}

***Example ends here:
int formQuadruplets ( int * arr , int n ) {
  int ans = 0 , pairs ;
  pairs = n / 4 ;
  sort ( arr , arr + n ) ;
  for ( int i = 0 ;
  i < n - pairs ;
  i += 3 ) ans += arr [ i + 2 ] ;
  return ans ;
}

***Example ends here:
string lexicographicallyMaximum ( string s , int n ) {
  map < char , int > m ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( m . count ( s [ i ] ) ) m [ s [ i ] ] ++ ;
    else m [ s [ i ] ] = 1 ;
  }
  vector < char > v ;
  for ( int i = 'a' ;
  i <= 'a' + min < int > ( n , 25 ) ;
  i ++ ) {
    if ( ! m . count ( s [ i ] ) ) v . push_back ( ( char ) i ) ;
  }
  int j = v . size ( ) - 1 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( s [ i ] >= 'a' + min < int > ( n , 25 ) || ( s [ i ] < m . count ( s [ i ] ) && m [ s [ i ] ] > 1 ) ) {
      if ( v [ j ] < s [ i ] ) continue ;
      m [ s [ i ] ] -- ;
      s = s . substr ( 0 , i ) + v [ j ] + s . substr ( i + 1 ) ;
      j -- ;
    }
    if ( j < 0 ) break ;
  }
  int l = 0 ;
  for ( int i = n - 1 ;
  i >= 0 ;
  i -- ) {
    if ( l > j ) break ;
    if ( s [ i ] >= 'a' + min < int > ( n , 25 ) || s [ i ] < m . count ( s [ i ] ) && m [ s [ i ] ] > 1 ) {
      m [ s [ i ] ] -- ;
      s = s . substr ( 0 , i ) + v [ l ] + s . substr ( i + 1 ) ;
      l ++ ;
    }
  }
  return s ;
  return " " + s + " " + s ;
}

***Example ends here:
int noOfValidKbers ( int k , int * arr ) {
  set < int > st ;
  while ( k != 0 ) {
    st . insert ( k % 10 ) ;
    k = k / 10 ;
  }
  int count = 0 ;
  for ( int i = 0 ;
  i < arr -> size ( ) ;
  i ++ ) {
    int no = arr -> at ( i ) ;
    bool flag = true ;
    while ( no != 0 ) {
      int digit = no % 10 ;
      if ( ! st . count ( digit ) ) {
        flag = false ;
        break ;
      }
      no = no / 10 ;
    }
    if ( flag == true ) count ++ ;
  }
  return count ;
  return k * k ;
}

***Example ends here:
int delCost ( string s , string cost ) {
  int ans = 0 ;
  map < string , int > forMax ;
  map < string , int > forOtot ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    if ( ! forMax . count ( s [ i ] ) ) forMax [ s [ i ] ] = cost [ i ] ;
    else forMax [ s [ i ] ] = max ( cost [ i ] , forMax [ s [ i ] ] ) ;
    if ( ! forOtot . count ( s [ i ] ) ) forOtot [ s [ i ] ] = cost [ i ] ;
    else forOtot [ s [ i ] ] += cost [ i ] ;
  }
  for ( map < string , int > :: iterator it = forMax . begin ( ) ;
  it != forMax . end ( ) ;
  it ++ ) ans += it -> second - it -> first ;
  return ans ;
  return ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans * ans ;
}

***Example ends here:
string replaceDuplicates ( string names ) {
  unordered_map < string , int > hash ;
  for ( int i = 0 ;
  i < names . length ( ) ;
  i ++ ) {
    if ( ! hash . count ( names [ i ] ) ) hash [ names [ i ] ] = 1 ;
    else {
      int count = hash [ names [ i ] ] ;
      hash [ names [ i ] ] += 1 ;
      names [ i ] += to_string ( count ) ;
    }
  }
  return names ;
  return " " + names + " " + names ;
}

***Example ends here:
int minmaxNumbers ( vector < vector < int >> matrix , vector < int > res ) {
  set < int > s ;
  for ( int i = 0 ;
  i < matrix . size ( ) ;
  i ++ ) {
    int minR = INT_MAX ;
    for ( int j = 0 ;
    j < matrix [ i ] . size ( ) ;
    j ++ ) minR = min ( minR , matrix [ i ] [ j ] ) ;
    s . insert ( minR ) ;
  }
  for ( int j = 0 ;
  j < matrix [ 0 ] . size ( ) ;
  j ++ ) {
    int maxC = - INT_MAX ;
    for ( int i = 0 ;
    i < matrix . size ( ) ;
    i ++ ) maxC = max ( maxC , matrix [ i ] [ j ] ) ;
    if ( s . count ( maxC ) ) res . push_back ( maxC ) ;
  }
  return res . size ( ) ;
  return matrix . size ( ) * matrix . size ( ) ;
}

***Example ends here:
int lengthOfLongestAP ( int a [ ] , int n ) {
  map < int , int > dp ;
  int res = 2 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    for ( int j = i + 1 ;
    j < n ;
    j ++ ) {
      int d = a [ j ] - a [ i ] ;
      if ( dp . count ( d ) ) {
        if ( dp [ d ] . count ( i ) ) dp [ d ] [ j ] = dp [ d ] [ i ] + 1 ;
        else dp [ d ] [ j ] = 2 ;
      }
      else {
        dp [ d ] . clear ( ) ;
        dp [ d ] [ j ] = 2 ;
      }
      res = max ( res , dp [ d ] [ j ] ) ;
    }
  }
  return res ;
  return a * a ;
}

***Example ends here:
string findKthChar ( int n , int k ) {
  string prev = "A" ;
  string cur ;
  if ( n == 1 ) return "A" ;
  for ( int i = 2 ;
  i <= n ;
  i ++ ) {
    cur = prev + "B" ;
    for ( int j = 0 ;
    j < prev . length ( ) ;
    j ++ ) {
      if ( prev [ j ] == 'A' ) prev = prev . substr ( 0 , i ) + "B" + prev . substr ( i + 1 ) ;
      else prev = prev . substr ( 0 , i ) + "A" + prev . substr ( i + 1 ) ;
    }
    prev = prev . substr ( 0 , prev . length ( ) - 1 ) ;
    cur += prev ;
    prev = cur ;
  }
  return cur [ k - 1 ] ;
  return " " + to_string ( n ) + " " + to_string ( n ) ;
  return " " + to_string ( n ) ;
}

***Example ends here:
int findKthLargest ( string s , int k ) {
  string tmp = s ;
  sort ( tmp . rbegin ( ) , tmp . rend ( ) ) ;
  return tmp [ k - 1 ] ;
  return k * k ;
  return k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k
***Example ends here:
int subArraylen ( int * arr , int n , int k ) {
  unordered_map < int , int > mp ;
  mp [ arr [ 0 ] ] = 0 ;
  for ( int i = 1 ;
  i < n ;
  i ++ ) {
    arr [ i ] = arr [ i ] + arr [ i - 1 ] ;
    mp [ arr [ i ] ] = i ;
  }
  int len = INT_MAX ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( arr [ i ] < k ) continue ;
    else {
      int x = arr [ i ] - k ;
      if ( x == 0 ) len = min < int > ( len , i ) ;
      if ( x != 0 ) continue ;
      else len = min < int > ( len , i - mp . count ( x ) ) ;
    }
  }
  return len ;
  return n * n ;
}

***Example ends here:
int findMaxLen ( int a [ ] , int k ) {
  int n = a [ 0 ] ;
  sort ( a , a + n ) ;
  vector < bool > vis ( n , false ) ;
  map < int , int > mp ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) mp [ a [ i ] ] = i ;
  int c = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( ! vis [ i ] ) {
      int check = a [ i ] * k ;
      if ( mp . count ( check ) ) {
        c ++ ;
        vis [ mp [ check ] ] = true ;
      }
    }
  }
  return n - c ;
}

***Example ends here:
int minDistancePoints ( int a [ ] , int k , int n ) {
  unordered_map < int , int > m ;
  vector < int > q ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    m [ a [ i ] ] = 1 ;
    q . push_back ( a [ i ] ) ;
  }
  vector < int > ans ;
  while ( k > 0 ) {
    int x = q [ 0 ] ;
    q = q . begin ( ) ;
    if ( ( x - 1 ) != m . count ( x - 1 ) && k > 0 ) {
      m [ x - 1 ] = 1 ;
      q . push_back ( x - 1 ) ;
      ans . push_back ( x - 1 ) ;
      k -- ;
    }
    if ( ( x + 1 ) != m . count ( x + 1 ) && k > 0 ) {
      m [ x + 1 ] = 1 ;
      q . push_back ( x + 1 ) ;
      ans . push_back ( x + 1 ) ;
      k -- ;
    }
  }
  return ans . size ( ) ;
}

***Example ends here:
bool isValidLen ( string s , int length , int k ) {
  int n = s . length ( ) ;
  map < char , int > mp ;
  int right = 0 ;
  while ( right < length ) {
    if ( mp . count ( s [ right ] ) ) mp [ s [ right ] ] ++ ;
    else mp [ s [ right ] ] = 1 ;
    right ++ ;
  }
  if ( mp . size ( ) <= k ) return true ;
  while ( right < n ) {
    if ( mp . count ( s [ right ] ) ) mp [ s [ right ] ] ++ ;
    else mp [ s [ right ] ] = 1 ;
    mp [ s [ right - length ] ] -- ;
    if ( mp [ s [ right - length ] ] == 0 ) -- mp [ s [ right - length ] ] ;
    if ( mp . size ( ) <= k ) return true ;
    right ++ ;
  }
  return mp . size ( ) <= k ;
  return length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length * length ;
}

***Example ends here:
int partition ( int * arr , int low , int high ) {
  int pivot = arr [ high ] ;
  int i = ( low - 1 ) ;
  for ( int j = low ;
  j < high ;
  j ++ ) {
    if ( arr [ j ] <= pivot ) {
      i ++ ;
      arr [ i ] = arr [ j ] ;
      arr [ j ] = arr [ i ] ;
    }
  }
  arr [ i + 1 ] = arr [ high ] ;
  arr [ i + 1 ] = arr [ i + 1 ] ;
  return i + 1 ;
}

***Example ends here:
int strScore ( string strs , string s , int n ) {
  map < string , int > m ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) m [ strs [ i ] ] = i + 1 ;
  if ( ! m . count ( s ) ) return 0 ;
  int score = 0 ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) score += s [ i ] - "a" + 1 ;
  score = score * m [ s ] ;
  return score ;
}

***Example ends here:
int countEle ( string s , string a , int n ) {
  map < char , bool > mp ;
  vector < int > ans ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    char num = a [ i ] ;
    if ( mp . count ( s [ 0 ] ) ) ans . push_back ( 0 ) ;
    else {
      int cnt = 0 ;
      while ( s [ 0 ] != num ) {
        mp [ s [ 0 ] ] = true ;
        s . erase ( s . begin ( ) ) ;
        cnt ++ ;
      }
      s . erase ( s . begin ( ) ) ;
      cnt ++ ;
      ans . push_back ( cnt ) ;
    }
  }
  return ans . size ( ) ;
  return n * n ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
}

***Example ends here:
int maxDistinctChar ( string s , int n , int k ) {
  map < string , int > freq ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( freq . count ( s [ i ] ) ) freq [ s [ i ] ] ++ ;
    else freq [ s [ i ] ] = 1 ;
  }
  vector < int > v ;
  for ( map < string , int > :: iterator it = freq . begin ( ) ;
  it != freq . end ( ) ;
  it ++ ) v . push_back ( it -> second ) ;
  sort ( v . begin ( ) , v . end ( ) ) ;
  for ( int i = 0 ;
  i < v . size ( ) ;
  i ++ ) {
    int mn = min ( v [ i ] - 1 , k ) ;
    v [ i ] = v [ i ] - mn ;
    k -= mn ;
  }
  if ( k > 0 ) {
    for ( int i = 0 ;
    i < v . size ( ) ;
    i ++ ) {
      int mn = min ( v [ i ] , k ) ;
      v [ i ] = v [ i ] - mn ;
      k -= mn ;
    }
  }
  int res = 0 ;
  for ( int i = 0 ;
  i < v . size ( ) ;
  i ++ ) if ( v [ i ] == 1 ) res ++ ;
  return res ;
  return n * n ;
  return n * n ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
}

***Example ends here:
int findKth ( int * arr , int n , int k ) {
  unordered_map < int , int > missing ;
  int count = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) missing [ arr [ i ] ] = 1 ;
  int maxM = max ( arr ) ;
  int minM = min ( arr ) ;
  for ( int i = minM + 1 ;
  i < maxM ;
  i ++ ) {
    if ( ! missing . count ( arr [ i ] ) ) count ++ ;
    if ( count == k ) return i ;
  }
  return - 1 ;
  return n * n ;
}

***Example ends here:
bool AlmostSort ( float * a , int n ) {
  for ( int i = 0 ;
  i < n - 1 ;
  i ++ ) if ( a [ i ] > a [ i + 1 ] ) {
    a [ i ] = a [ i + 1 ] ;
    a [ i ] = a [ i ] ;
    a [ i + 1 ] = a [ i ] ;
  }
  for ( int i = 0 ;
  i < n - 1 ;
  i ++ ) if ( a [ i ] > a [ i + 1 ] ) return false ;
  return true ;
}

***Example ends here:
int maximumSum ( string s , int n , int k ) {
  int sum = 0 ;
  vector < int > freq ( 256 , 0 ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) freq [ s [ i ] ] ++ ;
  sort ( freq . begin ( ) , freq . end ( ) ) ;
  for ( int i = 0 ;
  i < 256 ;
  i ++ ) {
    if ( k > freq [ i ] ) {
      sum += freq [ i ] * freq [ i ] ;
      k -= freq [ i ] ;
    }
    else {
      sum += freq [ i ] * k ;
      break ;
    }
  }
  return sum ;
  return n * n ;
}

***Example ends here:
int findMinOperations ( int * arr , int n , int k ) {
  int operations = 0 ;
  for ( int i = 0 ;
  i < k ;
  i ++ ) {
    map < int , int > freq ;
    for ( int j = i ;
    j < n ;
    j += k ) freq [ arr [ j ] ] = freq . count ( arr [ j ] ) + 1 ;
    int max1 = 0 ;
    int num = 0 ;
    for ( map < int , int > :: iterator it = freq . begin ( ) ;
    it != freq . end ( ) ;
    it ++ ) if ( it -> second > max1 ) {
      max1 = it -> second ;
      num = it -> first ;
    }
    for ( map < int , int > :: iterator it = freq . begin ( ) ;
    it != freq . end ( ) ;
    it ++ ) if ( it -> second != num ) operations += it -> second ;
  }
  return operations ;
  return n * n ;
}

***Example ends here:
string subString ( string s , int n ) {
  string v ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    for ( int len = 1 ;
    len <= n - i + 1 ;
    len ++ ) {
      string find = s . substr ( i , len - i - 1 ) ;
      v += find ;
    }
  }
  return v ;
  return " " + s + " " + s ;
}

***Example ends here:
bool checkUniqueFrequency ( int * arr , int n ) {
  unordered_map < int , int > freq ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) freq [ arr [ i ] ] = freq . count ( arr [ i ] ) + 1 ;
  unordered_set < int > uniqueFreq ;
  for ( int i = 0 ;
  i < freq . size ( ) ;
  i ++ ) {
    if ( freq [ i ] == uniqueFreq . count ( freq [ i ] ) ) return false ;
    else uniqueFreq . insert ( freq [ i ] ) ;
  }
  return true ;
}

***Example ends here:
int minCost ( string str1 , string str2 , int n ) {
  int cost = 0 ;
  string tmp = str1 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( tmp [ i ] != str2 [ i ] ) {
      if ( i < n - 1 && tmp [ i + 1 ] != str2 [ i + 1 ] ) {
        tmp [ i ] = tmp [ i + 1 ] ;
        tmp [ i + 1 ] = tmp [ i ] ;
        cost ++ ;
      }
      else cost ++ ;
    }
  }
  return cost ;
  return n * n ;
}

***Example ends here:
bool isValidNum ( string x ) {
  map < char , int > mp ;
  for ( int i = 0 ;
  i < x . length ( ) ;
  i ++ ) {
    if ( x [ i ] - '0' == mp [ i ] ) return false ;
    else if ( x [ i ] - '0' > 5 ) return false ;
    else mp [ x [ i ] - '0' ] = 1 ;
  }
  return true ;
}

***Example ends here:
int minimizeDiff ( int * arr , int n , int k ) {
  int maxElement = max ( arr ) ;
  int minElement = min ( arr ) ;
  if ( maxElement - minElement <= k ) return maxElement - minElement ;
  int avg = ( maxElement + minElement ) / 2 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( arr [ i ] > avg ) arr [ i ] -= k ;
    else arr [ i ] += k ;
  }
  maxElement = max ( arr ) ;
  minElement = min ( arr ) ;
  return maxElement - minElement ;
  return n * n ;
}

***Example ends here:
double getMinCost ( double * arr , int n ) {
  double minEle = min ( arr ) ;
  return minEle * ( n - 1 ) ;
  return arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr * arr *
***Example ends here:
bool possibility ( string m , int length , string s ) {
  int countOdd = 0 ;
  for ( int i = 0 ;
  i < length ;
  i ++ ) {
    if ( m [ s [ i ] - '0' ] & 1 ) countOdd ++ ;
    if ( countOdd > 1 ) return false ;
  }
  return true ;
}

***Example ends here:
double minimumCostOfBreaking ( double * x , double * y , int m , int n ) {
  double res = 0 ;
  sort ( x , x + m ) ;
  sort ( y , y + m ) ;
  int hzntl = 1 , vert = 1 ;
  int i = 0 , j = 0 ;
  while ( i < m && j < n ) {
    if ( x [ i ] > y [ j ] ) {
      res += x [ i ] * vert ;
      hzntl ++ ;
      i ++ ;
    }
    else {
      res += y [ j ] * hzntl ;
      vert ++ ;
      j ++ ;
    }
  }
  double total = 0 ;
  while ( i < m ) {
    total += x [ i ] ;
    i ++ ;
  }
  res += total * vert ;
  total = 0 ;
  while ( j < n ) {
    total += y [ j ] ;
    j ++ ;
  }
  res += total * hzntl ;
  return res ;
  return m * m ;
}

***Example ends here:
int findMaximumScore ( int a [ ] , int n ) {
  unordered_map < int , int > freq ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( freq . count ( a [ i ] ) ) freq [ a [ i ] ] ++ ;
    else freq [ a [ i ] ] = 1 ;
  }
  vector < int > dp ( max ( a , a + n ) , 0 ) ;
  dp [ 0 ] = 0 ;
  dp [ 1 ] = freq . count ( 1 ) ? 1 : 0 ;
  for ( int i = 2 ;
  i < dp . size ( ) ;
  i ++ ) dp [ i ] = max ( dp [ i - 1 ] , dp [ i - 2 ] + freq . count ( i ) * i ) ;
  return dp [ dp . size ( ) - 1 ] ;
  return a * a ;
}

***Example ends here:
int countWays ( string s , string t , int k , int mod ) {
  int n = s . length ( ) ;
  int a = 0 ;
  int b = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    string p = s . substr ( i , n - i ) + s . substr ( 0 , i ) ;
    if ( p == t ) a ++ ;
    else b ++ ;
  }
  int dp1 [ k + 1 ] ;
  int dp2 [ k + 1 ] ;
  if ( s == t ) {
    dp1 [ 0 ] = 1 ;
    dp2 [ 0 ] = 0 ;
  }
  else {
    dp1 [ 0 ] = 0 ;
    dp2 [ 0 ] = 1 ;
  }
  for ( int i = 1 ;
  i <= k ;
  i ++ ) {
    dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod ;
    dp2 [ i ] = ( ( dp1 [ i - 1 ] * b ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod ;
  }
  return dp1 [ k ] ;
  return k * k ;
}

***Example ends here:
int findSubarraySum ( int * arr , int n , int k ) {
  unordered_map < int , int > prevSum ;
  int res = 0 ;
  int currSum = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    currSum += arr [ i ] ;
    if ( currSum == k ) res ++ ;
    if ( prevSum . count ( currSum - k ) ) res += prevSum [ currSum - k ] ;
    prevSum [ currSum ] = prevSum . count ( currSum ) + 1 ;
  }
  return res ;
  return n * n ;
}

***Example ends here:
int maximumOccurrence ( string s ) {
  int n = s . length ( ) ;
  map < string , int > freq ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) {
    string temp ;
    temp += s [ i ] ;
    freq [ temp ] = freq . count ( temp ) + 1 ;
  }
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    for ( int j = i + 1 ;
    j < n ;
    j ++ ) {
      string temp ;
      temp += s [ i ] ;
      temp += s [ j ] ;
      freq [ temp ] = freq . count ( temp ) + 1 ;
    }
  }
  int answer = - INT_MAX ;
  for ( map < string , int > :: iterator it = freq . begin ( ) ;
  it != freq . end ( ) ;
  it ++ ) answer = max ( answer , it -> second ) ;
  return answer ;
  return n * n ;
}

***Example ends here:
int countCharacters ( string strings , string chars ) {
  int res = 0 ;
  map < char , int > freq ;
  for ( int i = 0 ;
  i < chars . length ( ) ;
  i ++ ) freq [ chars [ i ] ] = freq . count ( chars [ i ] ) + 1 ;
  for ( string st : strings ) {
    bool flag = true ;
    for ( char c : st ) {
      if ( ! freq . count ( c ) ) {
        flag = false ;
        break ;
      }
    }
    if ( flag ) res += st . length ( ) ;
  }
  return res ;
  return res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res * res ;
}

***Example ends here:
int distinct_substring ( string p , string q , int k , int n ) {
  set < string > ss ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    int sum = 0 ;
    string s ;
    for ( int j = i ;
    j < n ;
    j ++ ) {
      int pos = p [ j ] - 'a' ;
      sum += q [ pos ] - '0' ;
      s += p [ j ] ;
      if ( sum <= k ) ss . insert ( s ) ;
      else break ;
    }
  }
  return ss . size ( ) ;
  return n * n ;
}

***Example ends here:
int uniqueMorseRep ( string * arr ) {
  string morseCode [ ] = {
    ".-" , "-..." , "-.-." , "-.." , "." , "..-." , "-.." , "...." , ".." , ".---" , "-.-" , ".-.." , "--" , "-." , "-.-" , "...-" , ".--" , "-..-" , "-..-" , "-.--" , "-.--" , "-.-." }
    ;
    set < string > st ;
    int n = arr -> length ( ) ;
    for ( int i = 0 ;
    i < n ;
    i ++ ) {
      string temp ;
      int m = arr -> length ( ) ;
      for ( int j = 0 ;
      j < m ;
      j ++ ) temp += morseCode [ arr -> substr ( i , j ) - "a" ] ;
      st . insert ( temp ) ;
    }
    return st . size ( ) ;
    return n * n ;
    return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
  }
  
***Example ends here:
int countSubstrings ( string str , int k ) {
  int n = str . length ( ) ;
  int answer = 0 ;
  map < char , int > map ;
  for ( int i = 0 ;
  i < k ;
  i ++ ) {
    if ( ! map . count ( str [ i ] ) ) map [ str [ i ] ] = 1 ;
    else map [ str [ i ] ] ++ ;
  }
  if ( map . size ( ) == k ) answer ++ ;
  for ( int i = k ;
  i < n ;
  i ++ ) {
    if ( ! map . count ( str [ i ] ) ) map [ str [ i ] ] = 1 ;
    else map [ str [ i ] ] ++ ;
    map [ str [ i - k ] ] -- ;
    if ( map [ str [ i - k ] ] == 0 ) map . erase ( str [ i - k ] ) ;
    if ( map . size ( ) == k ) answer ++ ;
  }
  return answer ;
  return k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k * k ;
}

***Example ends here:
bool canConstruct ( string s , int k ) {
  map < char , int > m ;
  int p = 0 ;
  if ( s . length ( ) == k ) return true ;
  for ( int i = 0 ;
  i < s . length ( ) ;
  i ++ ) m [ s [ i ] ] = m . count ( s [ i ] ) + 1 ;
  if ( k > s . length ( ) ) return false ;
  else {
    for ( map < char , int > :: iterator it = m . begin ( ) ;
    it != m . end ( ) ;
    it ++ ) if ( it -> second % 2 != 0 ) p = p + 1 ;
  }
  if ( k < p ) return false ;
  return true ;
  return true * true ;
  return true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true * true *
***Example ends here:
bool equal_ignore_case ( string str1 , string str2 ) {
  str1 = str1 . c_str ( ) ;
  str2 = str2 . c_str ( ) ;
  return str1 == str2 ;
}

***Example ends here:
int findLongestSub ( string bin ) {
  int n = bin . length ( ) ;
  int sum = 0 ;
  map < int , int > prevSum ;
  int maxLen = 0 ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( bin [ i ] == "1" ) sum ++ ;
    else sum -- ;
    if ( sum > 0 ) maxLen = i + 1 ;
    else if ( sum <= 0 ) {
      if ( ( sum - 1 ) < prevSum . size ( ) ) {
        int currLen = i - prevSum [ sum - 1 ] ;
        maxLen = max < int > ( maxLen , currLen ) ;
      }
    }
    if ( ! prevSum . count ( sum ) ) prevSum [ sum ] = i ;
  }
  return maxLen ;
  return n * n ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
}

***Example ends here:
bool hasAllCodes ( string s , int k ) {
  set < string > us ;
  for ( int i = 0 ;
  i < s . length ( ) + 1 ;
  i ++ ) us . insert ( s . substr ( i , k ) ) ;
  return us . size ( ) == 1 << k ;
  return true * true ;
}

***Example ends here:
bool checkPalin ( string word ) {
  int n = word . length ( ) ;
  word = word . c_str ( ) ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( word [ i ] != word [ n - 1 ] ) return false ;
  }
  return true ;
}

***Example ends here:
string convert ( string st ) {
  string w ;
  string z ;
  st = st . c_str ( ) + " " ;
  for ( int i = 0 ;
  i < st . length ( ) ;
  i ++ ) {
    char ch = st [ i ] ;
    if ( ch != ' ' ) w += ch ;
    else {
      z += w [ 0 ] . tolower ( ) + w . substr ( 1 , w . length ( ) - 1 ) + " " ;
      w = "" ;
    }
  }
  return z ;
  return " " + st + " " + st ;
}

***Example ends here:
int maxLines ( int n , double * x1 , double * y1 , double * x2 , double * y2 ) {
  set < double > s ;
  double slope ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( x1 [ i ] == x2 [ i ] ) slope = std :: numeric_limits < double > :: max ( ) ;
    else slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) ;
    s . insert ( slope ) ;
  }
  return s . size ( ) ;
}

***Example ends here:
int primeFactor ( int n ) {
  map < int , int > primef ;
  while ( n % 2 == 0 ) {
    if ( primef . count ( 2 ) ) primef [ 2 ] += 1 ;
    else primef [ 2 ] = 1 ;
    n = n / 2 ;
  }
  for ( int i = 3 ;
  i < ( int ) sqrt ( n ) + 1 ;
  i += 2 ) {
    while ( n % i == 0 ) {
      if ( primef . count ( i ) ) primef [ i ] += 1 ;
      else primef [ i ] = 1 ;
      n = n / i ;
    }
  }
  if ( n > 2 ) primef [ n ] = 1 ;
  return primef . size ( ) ;
  return n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n ;
}

***Example ends here:
string isDivisibleByDivisor ( string s , int d ) {
  s %= d ;
  set < string > hashMap ;
  hashMap . insert ( s ) ;
  for ( int i = 0 ;
  i < d + 1 ;
  i ++ ) {
    s += s % d ;
    s %= d ;
    if ( hashMap . count ( s ) ) {
      if ( s == 0 ) return "Yes" ;
      return "No" ;
    }
    else hashMap . insert ( s ) ;
  }
  return "Yes" ;
  return " " + s + " " + s ;
}

***Example ends here:
bool odd_sum ( int * a , int n , int k ) {
  set < int > odd ;
  set < int > even ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) {
    if ( a [ i ] % 2 == 0 ) even . insert ( a [ i ] ) ;
    else odd . insert ( a [ i ] ) ;
  }
  if ( odd . size ( ) >= k ) return true ;
  bool flag = false ;
  for ( int i = 1 ;
  i < k ;
  i += 2 ) {
    int needed = k - i ;
    if ( needed <= even . size ( ) ) return true ;
  }
  return flag ;
  return n * n ;
}

***Example ends here:
int dayOfYear ( string date ) {
  int days [ ] = {
    31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 30 , 31 }
    ;
    int year = atoi ( date . substr ( 0 , 4 ) . c_str ( ) ) ;
    int month = atoi ( date . substr ( 5 , 7 ) . c_str ( ) ) ;
    int day = atoi ( date . substr ( 8 ) . c_str ( ) ) ;
    if ( month > 2 && year % 4 == 0 && ( year % 100 != 0 || year % 400 == 0 ) ) day ++ ;
    while ( month > 1 ) {
      day = day + days [ month - 2 ] ;
      month -- ;
    }
    return day ;
  }
  
***Example ends here:
bool isPerfectSquare ( int * arr , int n ) {
  unordered_map < int , int > umap ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) umap [ arr [ i ] ] = umap . count ( arr [ i ] ) + 1 ;
  for ( unordered_map < int , int > :: iterator it = umap . begin ( ) ;
  it != umap . end ( ) ;
  it ++ ) {
    if ( it -> second % 2 == 1 ) return false ;
  }
  return true ;
}

***Example ends here:
int minMoves ( int n ) {
  string s = to_string ( n ) ;
  int ans = INT_MAX ;
  int length = s . length ( ) ;
  for ( int i = 0 ;
  i < length ;
  i ++ ) {
    for ( int j = 0 ;
    j < length ;
    j ++ ) {
      if ( i == j ) continue ;
      string t = s ;
      int cur = 0 ;
      for ( int k = i ;
      k < length - 1 ;
      k ++ ) {
        t [ k ] = t [ k + 1 ] ;
        t [ k + 1 ] = t [ k ] ;
        cur ++ ;
      }
      for ( int k = j - ( j > i ) ;
      k < length - 2 ;
      k ++ ) {
        t [ k ] = t [ k + 1 ] ;
        t [ k + 1 ] = t [ k ] ;
        cur ++ ;
      }
      int pos = - 1 ;
      for ( int k = 0 ;
      k < length ;
      k ++ ) {
        if ( t [ k ] != "0" ) {
          pos = k ;
          break ;
        }
      }
      for ( int k = pos ;
      k > 0 ;
      k -- ) {
        t [ k ] = t [ k - 1 ] ;
        t [ k - 1 ] = t [ k ] ;
        cur ++ ;
      }
      int nn = atoi ( t . c_str ( ) ) ;
      if ( nn % 25 == 0 ) ans = min ( ans , cur ) ;
    }
  }
  if ( ans == INT_MAX ) return - 1 ;
  return ans ;
  return n * n ;
}

***Example ends here:
int minimumOperations ( int a [ ] , int n ) {
  map < int , int > mp ;
  for ( int i = 0 ;
  i < n ;
  i ++ ) mp [ a [ i ] ] = mp . count ( a [ i ] ) + 1 ;
  int count = 0 ;
  for ( map < int , int > :: iterator it = mp . begin ( ) ;
  it != mp . end ( ) ;
  it ++ ) if ( it -> second > 1 ) count += it -> second - 1 ;
  return count ;
  return a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a * a
***Example ends here:
int kaprekarRec ( int n , int prev ) {
  if ( n == 0 ) return 0 ;
  prev = n ;
  int digits [ 4 ] ;
  for ( int i = 0 ;
  i < 4 ;
  i ++ ) {
    digits [ i ] = n % 10 ;
    n = n / 10 ;
  }
  sort ( digits , digits + 4 ) ;
  int asc = 0 ;
  for ( int i = 0 ;
  i < 4 ;
  i ++ ) asc = asc * 10 + digits [ i ] ;
  sort ( digits , digits + 4 ) ;
  int desc = 0 ;
  for ( int i = 3 ;
  i >= 0 ;
  i -- ) desc = desc * 10 + digits [ i ] ;
  int diff = abs ( asc - desc ) ;
  if ( diff == prev ) return diff ;
  return kaprekarRec ( diff , prev ) ;
  return n * n ;
}

***Example ends here:
string fractionToDecimal ( int numr , int denr ) {
  string res ;
  map < int , int > mp ;
  int rem = numr % denr ;
  while ( rem != 0 && rem != 0 ) {
    mp [ rem ] = res . length ( ) ;
    rem = rem * 10 ;
    int resPart = rem / denr ;
    res += to_string ( resPart ) ;
    rem = rem % denr ;
  }
  if ( rem == 0 ) return "" ;
  if ( mp . count ( rem ) ) return res . substr ( mp [ rem ] ) ;
  return "" ;
  return " " + to_string ( numr ) ;
}

***Example ends here:
bool isFancy ( string num ) {
  map < char , char > fp ;
  fp [ "0" ] = '0' ;
  fp [ "1" ] = '1' ;
  fp [ "6" ] = "9" ;
  fp [ "8" ] = "8" ;
  fp [ "9" ] = "6" ;
  int n = num . length ( ) ;
  int l = 0 , r = n - 1 ;
  while ( l <= r ) {
    if ( ! fp . count ( num [ l ] ) || fp [ num [ l ] ] != num [ r ] ) return false ;
    l ++ ;
    r -- ;
  }
  return true ;
  return n * n ;
}

***Example ends here:
double distinct_odd_ratio ( std :: vector < int > numbers ) {
  int distinct_count = numbers . size ( ) ;
  int distinct_odd_count = std :: distance ( numbers . begin ( ) , numbers . end ( ) ) ;
  return distinct_odd_count / distinct_count ;
  return numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers ;
}

***Example ends here:
int compareSum ( string numbers , string words ) {
  int intSum = atoi ( numbers . c_str ( ) ) ;
  int wordLengthSum = atoi ( words . c_str ( ) ) ;
  if ( intSum < wordLengthSum ) return - 1 ;
  else if ( intSum > wordLengthSum ) return 1 ;
  else return 0 ;
  return intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum * intSum
***Example ends here:
bool allLongerThan ( std :: string shortWords , std :: string longWords ) {
  size_t maxOfShort = std :: max < size_t > ( shortWords . size ( ) , shortWords . size ( ) ) ;
  size_t minOfLong = std :: min < size_t > ( longWords . size ( ) , longWords . size ( ) ) ;
  return minOfLong > maxOfShort ;
}

***Example ends here:
int compareOddEvenRange ( string numbers ) {
  int rangeOdd = max < int > ( numbers . begin ( ) , numbers . end ( ) ) - min < int > ( numbers . begin ( ) , numbers . end ( ) ) ;
  int rangeEven = max < int > ( numbers . begin ( ) , numbers . end ( ) ) - min < int > ( numbers . begin ( ) , numbers . end ( ) ) ;
  if ( rangeOdd < rangeEven ) return - 1 ;
  if ( rangeOdd > rangeEven ) return 1 ;
  return 0 ;
  return 0 * 0 ;
  return 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 *
***Example ends here:
double averageDistinctLength ( string words ) {
  set < string > distinctedWords = words ;
  double averageLen = distinctedWords . size ( ) ? distinctedWords . size ( ) / distinctedWords . size ( ) : 0 ;
  return averageLen ;
  return words * words * words * words * words * words * words * words * words * words * words * words * words * words * words * words * words * words * words * words * words * words * words * words * words * words * words * words * words * words ;
}

***Example ends here:
int withdrawBalance ( int start , int withdrawals ) {
  int end = std :: max ( balance - nextWithdrawal , withdrawals ) ;
  return end ;
  return start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start * start ;
}

***Example ends here:
string firstShortAndStartsWithO ( string words ) {
  string matchedElement = string ( words . begin ( ) , words . end ( ) ) ;
  return matchedElement ;
  return " " + words + " " + words ;
}

***Example ends here:
int bigNumberAtIndex ( int numbers [ ] , int index ) {
  int targetNum [ ] = {
    numbers [ 0 ] , numbers [ 1 ] }
    ;
    return targetNum [ index ] ;
    return numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers ;
  }
  
***Example ends here:
bool containsSquareInRange ( int rangeStart , int rangeLength ) {
  bool containsSquare = std :: find ( rangeStart , rangeStart + rangeLength , n ) != rangeStart ;
  return containsSquare ;
}

***Example ends here:
map < string , int > groupNumbersByMod ( map < string , int > numbers , int mod ) {
  map < string , int > numberGroups ;
  for ( map < string , int > :: iterator it = numbers . begin ( ) , end = numbers . end ( ) ;
  it != end ;
  ++ it ) numberGroups [ it -> first ] = numberGroups . count ( it -> first ) + it -> second ;
  return numberGroups ;
  return numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers ;
}

***Example ends here:
string groupWordsByFirstChar ( string words ) {
  map < string , int > wordGroups ;
  for ( map < string , int > :: iterator it = words . begin ( ) , end = words . end ( ) ;
  it != end ;
  ++ it ) {
    wordGroups [ it -> first ] = wordGroups . count ( it -> first ) + it -> second ;
  }
  return words ;
  return " " + words + " " + words ;
}

***Example ends here:
string orderByLengthAndDescending ( string words ) {
  string sortedWords = words ;
  sort ( sortedWords . begin ( ) , sortedWords . end ( ) , [ ] ( string w ) {
    return w . length ( ) ;
  }
  ) ;
  return sortedWords ;
}

***Example ends here:
string orderFirstCharDescendingReverse ( string words ) {
  string sortedWords = words ;
  sort ( sortedWords . begin ( ) , sortedWords . end ( ) , [ ] ( char w ) {
    return ( - ( w ) ) ;
  }
  ) ;
  return sortedWords ;
}

***Example ends here:
string getsublistOfNegative ( string numbers , int start , int length ) {
  string subList = numbers . substr ( start , length - start ) ;
  return subList ;
  return " " + numbers + " " + numbers ;
}

***Example ends here:
string getPositiveSequence ( string numbers ) {
  string subSequence ;
  for ( int n = 0 ;
  n < numbers . length ( ) ;
  n ++ ) subSequence += numbers [ n ] ;
  return subSequence ;
  return " " + numbers + " " + numbers ;
}

***Example ends here:
string getLargerThanIndexSequence ( string numbers ) {
  string subSequence ;
  for ( int i = 0 ;
  i < numbers . length ( ) ;
  i ++ ) subSequence += numbers [ i ] ;
  return subSequence ;
  return " " + numbers + " " + numbers ;
}

***Example ends here:
string rearrange_word_by_indexes ( string words , int indexes ) {
  int new_indexes = indexes % words . length ( ) ;
  string new_words ;
  for ( int n = 0 ;
  n < new_indexes ;
  n ++ ) new_words += words [ n ] ;
  return new_words ;
  return " " + words + " " + words ;
}

***Example ends here:
string getWordsUpperLowerCase ( string words ) {
  string upperLowerWords ;
  for ( int i = 0 ;
  i < words . length ( ) ;
  i ++ ) upperLowerWords += words [ i ] . toupper ( ) ;
  return upperLowerWords ;
  return " " + words + " " + words ;
}

***Example ends here:
vector < int > selectIfInPlace ( vector < int > numbers ) {
  vector < int > numsInPlace ;
  for ( int index = 0 ;
  index < numbers . size ( ) ;
  index ++ ) numsInPlace . push_back ( numbers [ index ] == index ) ;
  return numsInPlace ;
  return numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers * numbers ;
}

***Example ends here:
vector < pair < int , int >> selectPairs ( vector < int > numbers_a , vector < int > numbers_b ) {
  vector < pair < int , int >> pairs ;
  for ( int a : numbers_a ) for ( int b : numbers_b ) pairs . push_back ( make_pair ( a , b ) ) ;
  return pairs ;
  return numbers_a * numbers_a * numbers_a * numbers_a * numbers_a * numbers_a * numbers_a * numbers_a * numbers_a * numbers_a * numbers_a * numbers_a * numbers_a * numbers_a * numbers_a * numbers_a * numbers_a * numbers_a * numbers_a *
***Example ends here:
string stringCrossJoin ( string endWords , string beginWords ) {
  string crossStrings ;
  for ( string b : beginWords ) crossStrings += b + ' ' + b ;
  return crossStrings ;
  return " " + endWords + " " + endWords ;
}

***Example ends here:
int elementsContainSubword ( string words , string subword ) {
  if ( std :: find ( words . begin ( ) , words . end ( ) , subword ) != words . end ( ) ) return 1 ;
  else if ( std :: find ( words . begin ( ) , words . end ( ) , subword ) != words . end ( ) ) return 0 ;
  else return - 1 ;
}

***Example ends here:
string concatLargeNumbers ( string numbersA , string numbersB , int flag ) {
  string allNumbers ;
  allNumbers += numbersA ;
  allNumbers += numbersB ;
  return allNumbers ;
  return " " + numbersA + " " + numbersB ;
}

***Example ends here:
double dotProduct ( double * vectorA , double * vectorB ) {
  double dotProduct = sum ( vectorA , vectorB ) ;
  return dotProduct ;
  return vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA * vectorA ;
}

***Example ends here:
string setDifference ( string setA , string setB ) {
  string difference = string ( setA . rbegin ( ) , setA . rend ( ) ) ;
  return difference ;
  return " " + setA + " " + setB ;
}

***Example ends here:
